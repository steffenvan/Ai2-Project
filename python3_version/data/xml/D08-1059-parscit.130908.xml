<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.9995485">
A Tale of Two Parsers: investigating and combining graph-based and
transition-based dependency parsing using beam-search
</title>
<author confidence="0.99915">
Yue Zhang and Stephen Clark
</author>
<affiliation confidence="0.998674">
Oxford University Computing Laboratory
</affiliation>
<address confidence="0.991116">
Wolfson Building, Parks Road
Oxford OX1 3QD, UK
</address>
<email confidence="0.99978">
{yue.zhang,stephen.clark}@comlab.ox.ac.uk
</email>
<sectionHeader confidence="0.998597" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.994425444444444">
Graph-based and transition-based approaches
to dependency parsing adopt very different
views of the problem, each view having its
own strengths and limitations. We study both
approaches under the framework of beam-
search. By developing a graph-based and a
transition-based dependency parser, we show
that a beam-search decoder is a competitive
choice for both methods. More importantly,
we propose a beam-search-based parser that
combines both graph-based and transition-
based parsing into a single system for train-
ing and decoding, showing that it outper-
forms both the pure graph-based and the pure
transition-based parsers. Testing on the En-
glish and Chinese Penn Treebank data, the
combined system gave state-of-the-art accura-
cies of 92.1% and 86.2%, respectively.
</bodyText>
<sectionHeader confidence="0.999457" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999459130434783">
Graph-based (McDonald et al., 2005; McDon-
ald and Pereira, 2006; Carreras et al., 2006) and
transition-based (Yamada and Matsumoto, 2003;
Nivre et al., 2006) parsing algorithms offer two dif-
ferent approaches to data-driven dependency pars-
ing. Given an input sentence, a graph-based algo-
rithm finds the highest scoring parse tree from all
possible outputs, scoring each complete tree, while
a transition-based algorithm builds a parse by a se-
quence of actions, scoring each action individually.
The terms “graph-based” and “transition-based”
were used by McDonald and Nivre (2007) to de-
scribe the difference between MSTParser (McDon-
ald and Pereira, 2006), which is a graph-based parser
with an exhaustive search decoder, and MaltParser
(Nivre et al., 2006), which is a transition-based
parser with a greedy search decoder. In this paper,
we do not differentiate graph-based and transition-
based parsers by their search algorithms: a graph-
based parser can use an approximate decoder while
a transition-based parser is not necessarily determin-
istic. To make the concepts clear, we classify the two
types of parser by the following two criteria:
</bodyText>
<listItem confidence="0.94111425">
1. whether or not the outputs are built by explicit
transition-actions, such as ”Shift” and ”Reduce”;
2. whether it is dependency graphs or transition-
actions that the parsing model assigns scores to.
</listItem>
<bodyText confidence="0.997041">
By this classification, beam-search can be applied
to both graph-based and transition-based parsers.
Representative of each method, MSTParser and
MaltParser gave comparable accuracies in the
CoNLL-X shared task (Buchholz and Marsi, 2006).
However, they make different types of errors, which
can be seen as a reflection of their theoretical differ-
ences (McDonald and Nivre, 2007). MSTParser has
the strength of exact inference, but its choice of fea-
tures is constrained by the requirement of efficient
dynamic programming. MaltParser is deterministic,
yet its comparatively larger feature range is an ad-
vantage. By comparing the two, three interesting re-
search questions arise: (1) how to increase the flex-
ibility in defining features for graph-based parsing;
(2) how to add search to transition-based parsing;
and (3) how to combine the two parsing approaches
so that the strengths of each are utilized.
In this paper, we study these questions under one
framework: beam-search. Beam-search has been
successful in many NLP tasks (Koehn et al., 2003;
</bodyText>
<page confidence="0.950406">
562
</page>
<note confidence="0.966226">
Proceedings of the 2008 Conference on Empirical Methods in Natural Language Processing, pages 562–571,
Honolulu, October 2008.c�2008 Association for Computational Linguistics
</note>
<figure confidence="0.539022888888889">
Inputs: training examples (xi, yi)
Initialization: set w� = 0
Algorithm:
// R training iterations; N examples
for t = 1..R, i = 1..N:
zi = arg maxyEGEN(xi) 4b(y) · w�
if zi =6 yi:
w� = w� + 4b(yi) − 4b(zi)
Outputs: w�
</figure>
<figureCaption confidence="0.999966">
Figure 1: The perceptron learning algorithm
</figureCaption>
<bodyText confidence="0.999821709677419">
Collins and Roark, 2004), and can achieve accuracy
that is close to exact inference. Moreover, a beam-
search decoder does not impose restrictions on the
search problem in the way that an exact inference
decoder typically does, such as requiring the “op-
timal subproblem” property for dynamic program-
ming, and therefore enables a comparatively wider
range of features for a statistical system.
We develop three parsers. Firstly, using the same
features as MSTParser, we develop a graph-based
parser to examine the accuracy loss from beam-
search compared to exact-search, and the accuracy
gain from extra features that are hard to encode
for exact inference. Our conclusion is that beam-
search is a competitive choice for graph-based pars-
ing. Secondly, using the transition actions from
MaltParser, we build a transition-based parser and
show that search has a positive effect on its accuracy
compared to deterministic parsing. Finally, we show
that by using a beam-search decoder, we are able
to combine graph-based and transition-based pars-
ing into a single system, with the combined system
significantly outperforming each individual system.
In experiments with the English and Chinese Penn
Treebank data, the combined parser gave 92.1% and
86.2% accuracy, respectively, which are comparable
to the best parsing results for these data sets, while
the Chinese accuracy outperforms the previous best
reported by 1.8%. In line with previous work on de-
pendency parsing using the Penn Treebank, we fo-
cus on projective dependency parsing.
</bodyText>
<sectionHeader confidence="0.849347" genericHeader="introduction">
2 The graph-based parser
</sectionHeader>
<bodyText confidence="0.925894125">
Following MSTParser (McDonald et al., 2005; Mc-
Donald and Pereira, 2006), we define the graph-
Variables: agenda – the beam for state items
item – partial parse tree
output – a set of output items
index, prev – word indexes
Input: x – POS-tagged input sentence.
Initialization: agenda = [“”]
</bodyText>
<equation confidence="0.717743238095238">
Algorithm:
for index in 1..x.length():
clear output
for item in agenda:
// for all prev words that can be linked with
// the current word at index
prev = index − 1
while prev =6 0: // while prev is valid
// add link making prev parent of index
newitem = item // duplicate item
newitem.link(prev, index) // modify
output.append(newitem) // record
// if prev does not have a parent word,
// add link making index parent of prev
if item.parent(prev) == 0:
item.link(index, prev) // modify
output.append(item) // record
prev = the index of the first word before
prev whose parent does not exist
or is on its left; 0 if no match
clear agenda
</equation>
<bodyText confidence="0.9832695">
put the best items from output to agenda
Output: the best item in agenda
</bodyText>
<figureCaption confidence="0.929089">
Figure 2: A beam-search decoder for graph-based pars-
ing, developed from the deterministic Covington algo-
rithm for projective parsing (Covington, 2001).
</figureCaption>
<bodyText confidence="0.942316">
based parsing problem as finding the highest scoring
tree y from all possible outputs given an input x:
</bodyText>
<equation confidence="0.998449">
F(x) = arg max Score(y)
yEGEN(x)
</equation>
<bodyText confidence="0.999378222222222">
where GEN(x) denotes the set of possible parses for
the input x. To repeat our earlier comments, in this
paper we do not consider the method of finding the
arg max to be part of the definition of graph-based
parsing, only the fact that the dependency graph it-
self is being scored, and factored into scores at-
tached to the dependency links.
The score of an output parse y is given by a linear
model:
</bodyText>
<equation confidence="0.958254">
Score(y) = 4b(y) · w�
</equation>
<page confidence="0.987045">
563
</page>
<bodyText confidence="0.999895583333334">
where 4b(y) is the global feature vector from y and
w is the weight vector of the model.
We use the discriminative perceptron learning al-
gorithm (Collins, 2002; McDonald et al., 2005) to
train the values of w. The algorithm is shown in Fig-
ure 1. Averaging parameters is a way to reduce over-
fitting for perceptron training (Collins, 2002), and is
applied to all our experiments.
While the MSTParser uses exact-inference (Eis-
ner, 1996), we apply beam-search to decoding. This
is done by extending the deterministic Covington
algorithm for projective dependency parsing (Cov-
ington, 2001). As shown in Figure 2, the decoder
works incrementally, building a state item (i.e. par-
tial parse tree) word by word. When each word is
processed, links are added between the current word
and its predecessors. Beam-search is applied by
keeping the B best items in the agenda at each pro-
cessing stage, while partial candidates are compared
by scores from the graph-based model, according to
partial graph up to the current word.
Before decoding starts, the agenda contains an
empty sentence. At each processing stage, existing
partial candidates from the agenda are extended in
all possible ways according to the Covington algo-
rithm. The top B newly generated candidates are
then put to the agenda. After all input words are pro-
cessed, the best candidate output from the agenda is
taken as the final output.
The projectivity of the output dependency trees
is guaranteed by the incremental Covington process.
The time complexity of this algorithm is O(n2),
where n is the length of the input sentence.
During training, the “early update” strategy of
Collins and Roark (2004) is used: when the correct
state item falls out of the beam at any stage, parsing
is stopped immediately, and the model is updated
using the current best partial item. The intuition is
to improve learning by avoiding irrelevant informa-
tion: when all the items in the current agenda are
incorrect, further parsing steps will be irrelevant be-
cause the correct partial output no longer exists in
the candidate ranking.
Table 1 shows the feature templates from the
MSTParser (McDonald and Pereira, 2006), which
are defined in terms of the context of a word, its
parent and its sibling. To give more templates, fea-
tures from templates 1 – 5 are also conjoined with
</bodyText>
<table confidence="0.99926885">
1 Parent word (P) Pw; Pt; Pwt
2 Child word (C) Cw; Ct; Cwt
3 P and C PwtCwt; PwtCw;
PwCwt; PwtCt;
PtCwt; PwCw; PtCt
4 A tag Bt PtBtCt
between P, C
5 Neighbour words PtPLtCtCLt;
of P, C, PtPLtCtCRt;
left (PL/CL) PtPRtCtCLt;
and right (PR/CR) PtPRtCtCRt;
PtPLtCLt; PtPLtCRt;
PtPRtCLt; PtPRtCRt;
PLtCtCLt; PLtCtCRt;
PRtCtCLt; PRtCtCRt;
PtCtCLt; PtCtCRt;
PtPLtCt; PtPRtCt
6 sibling (S) of C CwSw; CtSt;
CwSt; CtSw;
PtCtSt;
</table>
<tableCaption confidence="0.905564">
Table 1: Feature templates from MSTParser
w – word; t – POS-tag.
Table 2: Additional feature templates for the graph-based
parser
</tableCaption>
<bodyText confidence="0.999968076923077">
the link direction and distance, while features from
template 6 are also conjoined with the direction and
distance between the child and its sibling. Here
“distance” refers to the difference between word in-
dexes. We apply all these feature templates to the
graph-based parser. In addition, we define two extra
feature templates (Table 2) that capture information
about grandchildren and arity (i.e. the number of
children to the left or right). These features are not
conjoined with information about direction and dis-
tance. They are difficult to include in an efficient
dynamic programming decoder, but easy to include
in a beam-search decoder.
</bodyText>
<figure confidence="0.744619222222222">
1 leftmost (CLC) and
rightmost (CRC)
children of C
2 left (la) and right (ra)
arity of P
PtCtCLCt;
PtCtCRCt
Ptla; Ptra;
Pwtla; Pwtra
</figure>
<page confidence="0.798245">
564
</page>
<figureCaption confidence="0.9757145">
Figure 3: Feature context for the transition-based algo-
rithm
</figureCaption>
<sectionHeader confidence="0.883073" genericHeader="method">
3 The transition-based parser
</sectionHeader>
<bodyText confidence="0.997509837837838">
We develop our transition-based parser using the
transition model of the MaltParser (Nivre et al.,
2006), which is characterized by the use of a stack
and four transition actions: Shift, ArcRight, ArcLeft
and Reduce. An input sentence is processed from
left to right, with an index maintained for the current
word. Initially empty, the stack is used throughout
the parsing process to store unfinished words, which
are the words before the current word that may still
be linked with the current or a future word.
The Shift action pushes the current word to the
stack and moves the current index to the next word.
The ArcRight action adds a dependency link from
the stack top to the current word (i.e. the stack top
becomes the parent of the current word), pushes the
current word on to the stack, and moves the current
index to the next word. The ArcLeft action adds a
dependency link from the current word to the stack
top, and pops the stack. The Reduce action pops the
stack. Among the four transition actions, Shift and
ArcRight push a word on to the stack while ArcLeft
and Reduce pop the stack; Shift and ArcRight read
the next input word while ArcLeft and ArcRight add
a link to the output. By repeated application of these
actions, the parser reads through the input and builds
a parse tree.
The MaltParser works deterministically. At each
step, it makes a single decision and chooses one of
the four transition actions according to the current
context, including the next input words, the stack
and the existing links. As illustrated in Figure 3, the
contextual information consists of the top of stack
(ST), the parent (STP) of ST, the leftmost (STLC) and
rightmost child (STRC) of ST, the current word (N0),
the next three words from the input (N1, N2, N3) and
the leftmost child of N0 (N0LC). Given the context
s, the next action T is decided as follows:
</bodyText>
<equation confidence="0.9874665">
T (s) = arg max Score(T, s)
T∈ACTION
</equation>
<bodyText confidence="0.999962181818182">
where ACTION = {Shift, ArcRight, ArcLeft,
Reduce}.
One drawback of deterministic parsing is error
propagation, since once an incorrect action is made,
the output parse will be incorrect regardless of the
subsequent actions. To reduce such error propa-
gation, a parser can keep track of multiple candi-
date outputs and avoid making decisions too early.
Suppose that the parser builds a set of candidates
GEN(x) for the input x, the best output F(x) can
be decided by considering all actions:
</bodyText>
<equation confidence="0.999626">
F(x) = arg max
y∈GEN(x) E T&apos;∈act(y) Score(T0, sT&apos;)
</equation>
<bodyText confidence="0.9990764">
Here T0 represents one action in the sequence
(act(y)) by which y is built, and sT&apos; represents the
corresponding context when T0 is taken.
Our transition-based algorithm keeps B different
sequences of actions in the agenda, and chooses the
one having the overall best score as the final parse.
Pseudo code for the decoding algorithm is shown
in Figure 4. Here each state item contains a partial
parse tree as well as a stack configuration, and state
items are built incrementally by transition actions.
Initially the stack is empty, and the agenda contains
an empty sentence. At each processing stage, one
transition action is applied to existing state items as
a step to build the final parse. Unlike the MaltParser,
which makes a decision at each stage, our transition-
based parser applies all possible actions to each ex-
isting state item in the agenda to generate new items;
then from all the newly generated items, it takes the
B with the highest overall score and puts them onto
the agenda. In this way, some ambiguity is retained
for future resolution.
Note that the number of transition actions needed
to build different parse trees can vary. For exam-
ple, the three-word sentence “A B C” can be parsed
by the sequence of three actions “Shift ArcRight
ArcRight” (B modifies A; C modifies B) or the
sequence of four actions “Shift ArcLeft Shift Ar-
cRight” (both A and C modifies B). To ensure that
all final state items are built by the same number
of transition actions, we require that the final state
</bodyText>
<page confidence="0.991081">
565
</page>
<table confidence="0.70479025">
Variables: agenda – the beam for state items
item – (partial tree, stack config)
output – a set of output items
index – iteration index
Input: x – POS-tagged input sentence.
Initialization: agenda = [(“”, [])]
Algorithm:
for index in 1 .. 2 x x.length() −1:
clear output
for item in agenda:
// when all input words have been read, the
// parse tree has been built; only pop.
</table>
<construct confidence="0.448589">
if item.length() == x.length():
if item.stacksize() &gt; 1:
</construct>
<equation confidence="0.968082380952381">
item.Reduce()
output.append(item)
// when some input words have not been read
else:
if item.lastaction() =� Reduce:
newitem = item
newitem.Shift()
output.append(newitem)
if item.stacksize() &gt; 0:
newitem = item
newitem.ArcRight()
output.append(newitem)
if (item.parent(item.stacktop())==0):
newitem = item
newitem.ArcLeft()
output.append(newitem)
else:
newitem = item
newitem.Reduce()
output.append(newitem)
clear agenda
</equation>
<bodyText confidence="0.8460965">
transfer the best items from output to agenda
Output: the best item in agenda
</bodyText>
<figureCaption confidence="0.995206">
Figure 4: A beam-search decoding algorithm for
transition-based parsing
</figureCaption>
<bodyText confidence="0.9696896">
items must 1) have fully-built parse trees; and 2)
have only one root word left on the stack. In this
way, popping actions should be made even after a
complete parse tree is built, if the stack still contains
more than one word.
Now because each word excluding the root must
be pushed to the stack once and popped off once
during the parsing process, the number of actions
Inputs: training examples (xi, yi)
Initialization: set w� = 0
</bodyText>
<equation confidence="0.870999">
Algorithm:
// R training iterations; N examples
for t = 1..R, i = 1..N:
zi = arg max
y∈GEN(xi
) F-T&apos;∈act(yi) Φ(T0, c0) · w�
if zi =� yi:
w= w� + ET&apos;∈act(yi) Φ(T0, cT&apos;)
− ET&apos;∈act(zi) Φ(T0, cT,)
Outputs: w�
</equation>
<figureCaption confidence="0.956639">
Figure 5: the perceptron learning algorithm for the
transition-based parser
</figureCaption>
<equation confidence="0.944142583333333">
STwt; STw; STt
N0wt; N0w; N0t
N1wt; N1w; N1t
STwtN0wt; STwtN0w;
STwN0wt; STwtN0t;
STtN0wt; STwN0w; STtN0t
N0tN1t
N0tN1tN2t; STtN0tN1t;
STPtSTtN0t; STtSTLCtN0t;
STtSTRCtN0t; STtN0tN0LCt
N0wN1tN2t; STtN0wN1t;
STPtSTtN0w; STtSTLCtN0w;
</equation>
<tableCaption confidence="0.8274335">
STtSTRCtN0w; STtN0wN0LCt
Table 3: Feature templates for the transition-based parser
</tableCaption>
<equation confidence="0.592819">
w – word; t – POS-tag.
</equation>
<bodyText confidence="0.99990325">
needed to parse a sentence is always 2n − 1, where
n is the length of the sentence. Therefore, the de-
coder has linear time complexity, given a fixed beam
size. Because the same transition actions as the
MaltParser are used to build each item, the projec-
tivity of the output dependency tree is ensured.
We use a linear model to score each transition ac-
tion, given a context:
</bodyText>
<equation confidence="0.590822">
5core(T, s) = Φ(T, s) · w�
Φ(T, s) is the feature vector extracted from the ac-
</equation>
<figureCaption confidence="0.593791666666667">
tion T and the context s, and w� is the weight vec-
tor. Features are extracted according to the templates
shown in Table 3, which are based on the context in
Figure 3. Note that our feature definitions are sim-
ilar to those used by MaltParser, but rather than us-
ing a kernel function with simple features (e.g. STw,
</figureCaption>
<figure confidence="0.997090142857143">
1 stack top
2 current word
3 next word
4 ST and N0
5 POS bigram
6 POS trigrams
7 N0 word
</figure>
<page confidence="0.992317">
566
</page>
<bodyText confidence="0.9995519">
N0t, but not STwt or STwN0w), we combine features
manually.
As with the graph-based parser, we use the dis-
criminative perceptron (Collins, 2002) to train the
transition-based model (see Figure 5). It is worth
noticing that, in contrast to MaltParser, which trains
each action decision individually, our training algo-
rithm globally optimizes all action decisions for a
parse. Again, “early update” and averaging parame-
ters are applied to the training process.
</bodyText>
<sectionHeader confidence="0.982905" genericHeader="method">
4 The combined parser
</sectionHeader>
<bodyText confidence="0.999926363636364">
The graph-based and transition-based approaches
adopt very different views of dependency parsing.
McDonald and Nivre (2007) showed that the MST-
Parser and MaltParser produce different errors. This
observation suggests a combined approach: by using
both graph-based information and transition-based
information, parsing accuracy can be improved.
The beam-search framework we have developed
facilitates such a combination. Our graph-based
and transition-based parsers share many similarities.
Both build a parse tree incrementally, keeping an
agenda of comparable state items. Both rank state
items by their current scores, and use the averaged
perceptron with early update for training. The key
differences are the scoring models and incremental
parsing processes they use, which must be addressed
when combining the parsers.
Firstly, we combine the graph-based and the
transition-based score models simply by summation.
This is possible because both models are global and
linear. In particular, the transition-based model can
be written as:
</bodyText>
<equation confidence="0.999292666666667">
ScoreT(y) = ET0∈act(y) Score(T0, sT0)
= ET0∈act(y) Φ(T0, sT0) · ~wT
~wT · ET0∈act(y) Φ(T0, sT0)
</equation>
<bodyText confidence="0.9648735">
If we take ET0∈act(y) Φ(T0, sT0) as the global fea-
ture vector ΦT(y), we have:
</bodyText>
<equation confidence="0.988496">
ScoreT(y) = ΦT(y) · ~wT
</equation>
<bodyText confidence="0.818846">
which has the same form as the graph-based model:
ScoreG(y) = ΦG(y) · ~wG
</bodyText>
<table confidence="0.99622725">
Sections Sentences Words
Training 2–21 39,832 950,028
Dev 22 1,700 40,117
Test 23 2,416 56,684
</table>
<tableCaption confidence="0.999919">
Table 4: The training, development and test data from
</tableCaption>
<note confidence="0.287548">
PTB
</note>
<bodyText confidence="0.815349">
We therefore combine the two models to give:
</bodyText>
<equation confidence="0.9773795">
ScoreC(y) = ScoreG(y) + ScoreT(y)
= ΦG(y) · ~wG + ΦT(y) · ~wT
</equation>
<bodyText confidence="0.999577">
Concatenating the feature vectors ΦG(y) and ΦT(y)
to give a global feature vector ΦC(y), and the weight
vectors ~wG and ~wT to give a weight vector ~wC, the
combined model can be written as:
</bodyText>
<equation confidence="0.994393">
ScoreC(y) = ΦC(y) · ~wC
</equation>
<bodyText confidence="0.905484909090909">
which is a linear model with exactly the same form
as both sub-models, and can be trained with the per-
ceptron algorithm in Figure 1. Because the global
feature vectors from the sub models are concate-
nated, the feature set for the combined model is the
union of the sub model feature sets.
Second, the transition-based decoder can be used
for the combined system. Both the graph-based de-
coder in Figure 2 and the transition-based decoder in
Figure 4 construct a parse tree incrementally. How-
ever, the graph-based decoder works on a per-word
basis, adding links without using transition actions,
and so is not appropriate for the combined model.
The transition-based algorithm, on the other hand,
uses state items which contain partial parse trees,
and so provides all the information needed by the
graph-based parser (i.e. dependency graphs), and
hence the combined system.
In summary, we build the combined parser by
using a global linear model, the union of feature
templates and the decoder from the transition-based
parser.
</bodyText>
<sectionHeader confidence="0.999761" genericHeader="method">
5 Experiments
</sectionHeader>
<bodyText confidence="0.9953576">
We evaluate the parsers using the English and Chi-
nese Penn Treebank corpora. The English data
is prepared by following McDonald et al. (2005).
Bracketed sentences from the Penn Treebank (PTB)
3 are split into training, development and test sets
</bodyText>
<page confidence="0.996164">
567
</page>
<figureCaption confidence="0.89974575">
Figure 6: The influence of beam size on the transition-
based parser, using the development data
X-axis: number of training iterations
Y-axis: word precision
</figureCaption>
<bodyText confidence="0.999751">
as shown in Table 4, and then translated into depen-
dency structures using the head-finding rules from
Yamada and Matsumoto (2003).
Before parsing, POS tags are assigned to the in-
put sentence using our reimplementation of the POS-
tagger from Collins (2002). Like McDonald et al.
(2005), we evaluate the parsing accuracy by the
precision of lexical heads (the percentage of input
words, excluding punctuation, that have been as-
signed the correct parent) and by the percentage
of complete matches, in which all words excluding
punctuation have been assigned the correct parent.
</bodyText>
<subsectionHeader confidence="0.993166">
5.1 Development experiments
</subsectionHeader>
<bodyText confidence="0.982533461538462">
Since the beam size affects all three parsers, we
study its influence first; here we show the effect on
the transition-based parser. Figure 6 shows different
accuracy curves using the development data, each
with a different beam size B. The X-axis represents
the number of training iterations, and the Y-axis the
precision of lexical heads.
The parsing accuracy generally increases as the
beam size increases, while the quantity of increase
becomes very small when B becomes large enough.
The decoding times after the first training iteration
are 10.2s, 27.3s, 45.5s, 79.0s, 145.4s, 261.3s and
469.5s, respectively, when B = 1, 2, 4, 8, 16, 32, 64.
</bodyText>
<table confidence="0.9995955">
Word Complete
MSTParser 1 90.7 36.7
Graph [M] 91.2 40.8
Transition 91.4 41.8
Graph [MA] 91.4 42.5
MSTParser 2 91.5 42.1
Combined [TM] 92.0 45.0
Combined [TMA] 92.1 45.4
</table>
<tableCaption confidence="0.999875">
Table 5: Accuracy comparisons using PTB 3
</tableCaption>
<bodyText confidence="0.999913777777778">
In the rest of the experiments, we set B = 64 in
order to obtain the highest possible accuracy.
When B = 1, the transition-based parser be-
comes a deterministic parser. By comparing the
curves when B = 1 and B = 2, we can see that,
while the use of search reduces the parsing speed, it
improves the quality of the output parses. Therefore,
beam-search is a reasonable choice for transition-
based parsing.
</bodyText>
<subsectionHeader confidence="0.999789">
5.2 Accuracy comparisons
</subsectionHeader>
<bodyText confidence="0.999364346153846">
The test accuracies are shown in Table 5, where each
row represents a parsing model. Rows “MSTParser
1/2” show the first-order (using feature templates 1 –
5 from Table 1) (McDonald et al., 2005) and second-
order (using all feature templates from Table 1)
(McDonald and Pereira, 2006) MSTParsers, as re-
ported by the corresponding papers. Rows “Graph
[M]” and “Graph [MA]” represent our graph-based
parser using features from Table 1 and Table 1 + Ta-
ble 2, respectively; row “Transition” represents our
transition-based parser; and rows “Combined [TM]”
and “Combined [TMA]” represent our combined
parser using features from Table 3 + Table 1 and Ta-
ble 3 + Table 1 + Table 2, respectively. Columns
“Word” and “Complete” show the precision of lexi-
cal heads and complete matches, respectively.
As can be seen from the table, beam-search re-
duced the head word accuracy from 91.5%/42.1%
(“MSTParser 2”) to 91.2%/40.8% (“Graph [M]”)
with the same features as exact-inference. How-
ever, with only two extra feature templates from
Table 2, which are not conjoined with direction or
distance information, the accuracy is improved to
91.4%/42.5% (“Graph [MA]”). This improvement
can be seen as a benefit of beam-search, which al-
lows the definition of more global features.
</bodyText>
<page confidence="0.992902">
568
</page>
<table confidence="0.998098857142857">
Sections Sentences Words
Training 001–815; 16,118 437,859
1001–1136
Dev 886–931; 804 20,453
1148–1151
Test 816–885; 1,915 50,319
1137–1147
</table>
<tableCaption confidence="0.978478">
Table 6: Training, development and test data from CTB
</tableCaption>
<table confidence="0.999949">
Non-root Root Comp.
Graph [MA] 83.86 71.38 29.82
Duan 2007 84.36 73.70 32.70
Transition 84.69 76.73 32.79
Combined [TM] 86.13 77.04 35.25
Combined [TMA] 86.21 76.26 34.41
</table>
<tableCaption confidence="0.999657">
Table 7: Test accuracies with CTB 5 data
</tableCaption>
<bodyText confidence="0.999978105263158">
The combined parser is tested with various sets
of features. Using only graph-based features in Ta-
ble 1, it gave 88.6% accuracy, which is much lower
than 91.2% from the graph-based parser using the
same features (“Graph [M]”). This can be explained
by the difference between the decoders. In particu-
lar, the graph-based model is unable to score the ac-
tions “Reduce” and “Shift”, since they do not mod-
ify the parse tree. Nevertheless, the score serves as a
reference for the effect of additional features in the
combined parser.
Using both transition-based features and graph-
based features from the MSTParser (“Combined
[TM]”), the combined parser achieved 92.0% per-
word accuracy, which is significantly higher than the
pure graph-based and transition-based parsers. Ad-
ditional graph-based features further improved the
accuracy to 92.1%/45.5%, which is the best among
all the parsers compared.1
</bodyText>
<subsectionHeader confidence="0.999739">
5.3 Parsing Chinese
</subsectionHeader>
<bodyText confidence="0.953022216216216">
We use the Penn Chinese Treebank (CTB) 5 for ex-
perimental data. Following Duan et al. (2007), we
1A recent paper, Koo et al. (2008) reported parent-prediction
accuracy of 92.0% using a graph-based parser with a different
(larger) set of features (Carreras, 2007). By applying separate
word cluster information, Koo et al. (2008) improved the accu-
racy to 93.2%, which is the best known accuracy on the PTB
data. We excluded these from Table 5 because our work is not
concerned with the use of such additional knowledge.
split the corpus into training, development and test
data as shown in Table 6, and use the head-finding
rules in Table 8 in the Appendix to turn the bracketed
sentences into dependency structures. Most of the
head-finding rules are from Sun and Jurafsky (2004),
while we added rules to handle NN and FRAG, and
a default rule to use the rightmost node as the head
for the constituent that are not listed.
Like Duan et al. (2007), we use gold-standard
POS-tags for the input. The parsing accuracy is eval-
uated by the percentage of non-root words that have
been assigned the correct head, the percentage of
correctly identified root words, and the percentage
of complete matches, all excluding punctuation.
The accuracies are shown in Table 7. Rows
“Graph [MA]”, “Transition”, “Combined [TM]” and
“Combined [TMA]” show our models in the same
way as for the English experiments from Section 5.2.
Row “Duan 2007” represents the transition-based
model from Duan et al. (2007), which applies beam-
search to the deterministic model from Yamada and
Matsumoto (2003), and achieved the previous best
accuracy on the data.
Our observations on parsing Chinese are essen-
tially the same as for English. Our combined parser
outperforms both the pure graph-based and the pure
transition-based parsers. It gave the best accuracy
we are aware of for dependency parsing using CTB.
</bodyText>
<sectionHeader confidence="0.999988" genericHeader="method">
6 Related work
</sectionHeader>
<bodyText confidence="0.999974176470588">
Our graph-based parser is derived from the work
of McDonald and Pereira (2006). Instead of per-
forming exact inference by dynamic programming,
we incorporated the linear model and feature tem-
plates from McDonald and Pereira (2006) into our
beam-search framework, while adding new global
features. Nakagawa (2007) and Hall (2007) also
showed the effectiveness of global features in im-
proving the accuracy of graph-based parsing, us-
ing the approximate Gibbs sampling method and a
reranking approach, respectively.
Our transition-based parser is derived from the
deterministic parser of Nivre et al. (2006). We
incorporated the transition process into our beam-
search framework, in order to study the influence
of search on this algorithm. Existing efforts to
add search to deterministic parsing include Sagae
</bodyText>
<page confidence="0.994386">
569
</page>
<bodyText confidence="0.999956606060606">
and Lavie (2006b), which applied best-first search
to constituent parsing, and Johansson and Nugues
(2006) and Duan et al. (2007), which applied beam-
search to dependency parsing. All three methods es-
timate the probability of each transition action, and
score a state item by the product of the probabilities
of all its corresponding actions. But different from
our transition-based parser, which trains all transi-
tions for a parse globally, these models train the
probability of each action separately. Based on the
work of Johansson and Nugues (2006), Johansson
and Nugues (2007) studied global training with an
approximated large-margin algorithm. This model
is the most similar to our transition-based model,
while the differences include the choice of learning
and decoding algorithms, the definition of feature
templates and our application of the “early update”
strategy.
Our combined parser makes the biggest contribu-
tion of this paper. In contrast to the models above,
it includes both graph-based and transition-based
components. An existing method to combine mul-
tiple parsing algorithms is the ensemble approach
(Sagae and Lavie, 2006a), which was reported to
be useful in improving dependency parsing (Hall et
al., 2007). A more recent approach (Nivre and Mc-
Donald, 2008) combined MSTParser and MaltParser
by using the output of one parser for features in the
other. Both Hall et al. (2007) and Nivre and McDon-
ald (2008) can be seen as methods to combine sep-
arately defined models. In contrast, our parser com-
bines two components in a single model, in which
all parameters are trained consistently.
</bodyText>
<sectionHeader confidence="0.989354" genericHeader="method">
7 Conclusion and future work
</sectionHeader>
<bodyText confidence="0.999987722222222">
We developed a graph-based and a transition-based
projective dependency parser using beam-search,
demonstrating that beam-search is a competitive
choice for both parsing approaches. We then com-
bined the two parsers into a single system, using dis-
criminative perceptron training and beam-search de-
coding. The appealing aspect of the combined parser
is the incorporation of two largely different views of
the parsing problem, thus increasing the information
available to a single statistical parser, and thereby
significantly increasing the accuracy. When tested
using both English and Chinese dependency data,
the combined parser was highly competitive com-
pared to the best systems in the literature.
The idea of combining different approaches to
the same problem using beam-search and a global
model could be applied to other parsing tasks, such
as constituent parsing, and possibly other NLP tasks.
</bodyText>
<sectionHeader confidence="0.996402" genericHeader="evaluation">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.999282">
This work is supported by the ORS and Clarendon
Fund. We thank the anonymous reviewers for their
detailed comments.
</bodyText>
<sectionHeader confidence="0.996164" genericHeader="conclusions">
Appendix
</sectionHeader>
<tableCaption confidence="0.9827035">
Table 8: Head-finding rules to extract dependency data
from CTB
</tableCaption>
<table confidence="0.54077088">
l PU; l
Constituent
Rules
r ADJP JJ AD; r
r ADVP AD CS JJ NP PP P VA VV; r
r CLP M NN NP; r
r CP IP VP; r
r DEG DNP DEC QP; r
r M; l DP DT OD; l
r DEV AD VP; r
r VV NR NN NT; r
r VP IP NP; r
r LCP LC; r
r CD NP QP; r
r NP NN IP NR NT; r
r NP NN IP NR NT; r
l P PP; l
r QP CLP CD; r
l IP NP VP; l
l VV VA VE; l
l VE VC VV VNV VPT VRD VSB
VCD VP; l
l VA VV; l
l VVI VA; l
r VV VE; r
</table>
<figure confidence="0.974577875">
r
ADJP
ADVP
CLP
CP
DNP
DP
DVP
FRAG
IP
LCP
LST
NP
NN
PP
PRN
QP
UCP
VCD
VP
VPT
VRD
VSB
default
</figure>
<page confidence="0.980363">
570
</page>
<sectionHeader confidence="0.997293" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999870136363636">
Sabine Buchholz and Erwin Marsi. 2006. CoNLL-X
shared task on multilingual dependency parsing. In
Proceedings of CoNLL, pages 149–164, New York
City, USA, June.
Xavier Carreras, Mihai Surdeanu, and Lluis Marquez.
2006. Projective dependency parsing with perceptron.
In Proceedings of CoNLL, New York City, USA, June.
Xavier Carreras. 2007. Experiments with a higher-order
projective dependency parser. In Proceedings of the
CoNLL Shared Task Session ofEMNLP/CoNLL, pages
957–961, Prague, Czech Republic, June.
Michael Collins and Brian Roark. 2004. Incremental
parsing with the perceptron algorithm. In Proceedings
ofACL, pages 111–118, Barcelona, Spain, July.
Michael Collins. 2002. Discriminative training meth-
ods for hidden markov models: Theory and experi-
ments with perceptron algorithms. In Proceedings of
EMNLP, pages 1–8, Philadelphia, USA, July.
Michael A. Covington. 2001. A fundamental algorithm
for dependency parsing. In Proceedings of the ACM
Southeast Conference, Athens, Georgia, March.
Xiangyu Duan, Jun Zhao, and Bo Xu. 2007. Probabilis-
tic models for action-based chinese dependency pars-
ing. In Proceedings of ECML/ECPPKDD, Warsaw,
Poland, September.
Jason Eisner. 1996. Three new probabilistic models for
dependency parsing: An exploration. In Proceedings
of COLING, pages 340–345, Copenhagen, Denmark,
August.
Johan Hall, Jens Nilsson, Joakim Nivre, G¨ulsen Eryigit,
Be´ata Megyesi, Mattias Nilsson, and Markus Saers.
2007. Single malt or blended? a study in multilingual
parser optimization. In Proceedings of the CoNLL
Shared Task Session of EMNLP/CoNLL, pages 933–
939, Prague, Czech Republic, June.
Keith Hall. 2007. K-best spanning tree parsing. In Pro-
ceedings ofACL, Prague, Czech Republic, June.
Richard Johansson and Pierre Nugues. 2006. Investigat-
ing multilingual dependency parsing. In Proceedings
of CoNLL, pages 206–210, New York City, USA, June.
Richard Johansson and Pierre Nugues. 2007. Incremen-
tal dependency parsing using online learning. In Pro-
ceedings of the CoNLL/EMNLP, pages 1134–1138,
Prague, Czech Republic.
Philip Koehn, Franz Och, and Daniel Marcu. 2003. Sta-
tistical phrase-based translation. In Proceedings of
NAACL/HLT, Edmonton, Canada, May.
Terry Koo, Xavier Carreras, and Michael Collins. 2008.
Simple semi-supervised dependency parsing. In Pro-
ceedings of ACL/HLT, pages 595–603, Columbus,
Ohio, June.
Ryan McDonald and Joakim Nivre. 2007. Characteriz-
ing the errors of data-driven dependency parsing mod-
els. In Proceedings of EMNLP/CoNLL, pages 122–
131, Prague, Czech Republic, June.
R McDonald and F Pereira. 2006. Online learning of ap-
proximate dependency parsing algorithms. In In Proc.
of EACL, pages 81–88, Trento, Italy, April.
Ryan McDonald, Koby Crammer, and Fernando Pereira.
2005. Online large-margin training of dependency
parsers. In Proceedings of ACL, pages 91–98, Ann
Arbor, Michigan, June.
Tetsuji Nakagawa. 2007. Multilingual dependency
parsing using global features. In Proceedings of the
CoNLL Shared Task Session ofEMNLP/CoNLL, pages
952–956, Prague, Czech Republic, June.
Joakim Nivre and Ryan McDonald. 2008. Integrating
graph-based and transition-based dependency parsers.
In Proceedings of ACL/HLT, pages 950–958, Colum-
bus, Ohio, June.
Joakim Nivre, Johan Hall, Jens Nilsson, G¨uls¸en Eryiˇgit,
and Svetoslav Marinov. 2006. Labeled pseudo-
projective dependency parsing with support vector ma-
chines. In Proceedings of CoNLL, pages 221–225,
New York City, USA, June.
K Sagae and A Lavie. 2006a. Parser combination by
reparsing. In In Proc. HLT/NAACL, pages 129–132,
New York City, USA, June.
Kenji Sagae and Alon Lavie. 2006b. A best-first prob-
abilistic shift-reduce parser. In Proceedings of COL-
ING/ACL (poster), pages 691–698, Sydney, Australia,
July.
Honglin Sun and Daniel Jurafsky. 2004. Shallow
semantic parsing of Chinese. In Proceedings of
NAACL/HLT, Boston, USA, May.
H Yamada and Y Matsumoto. 2003. Statistical depen-
dency analysis using support vector machines. In Pro-
ceedings ofIWPT, Nancy, France, April.
</reference>
<page confidence="0.99786">
571
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.260524">
<title confidence="0.9853335">A Tale of Two Parsers: investigating and combining graph-based transition-based dependency parsing using beam-search</title>
<author confidence="0.961868">Zhang</author>
<affiliation confidence="0.998727">Oxford University Computing</affiliation>
<address confidence="0.583801">Wolfson Building, Parks</address>
<note confidence="0.582576">Oxford OX1 3QD,</note>
<abstract confidence="0.997596157894737">Graph-based and transition-based approaches to dependency parsing adopt very different views of the problem, each view having its own strengths and limitations. We study both approaches under the framework of beamsearch. By developing a graph-based and a transition-based dependency parser, we show that a beam-search decoder is a competitive choice for both methods. More importantly, we propose a beam-search-based parser that combines both graph-based and transitionbased parsing into a single system for training and decoding, showing that it outperforms both the pure graph-based and the pure transition-based parsers. Testing on the English and Chinese Penn Treebank data, the combined system gave state-of-the-art accuraof respectively.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Sabine Buchholz</author>
<author>Erwin Marsi</author>
</authors>
<title>CoNLL-X shared task on multilingual dependency parsing.</title>
<date>2006</date>
<booktitle>In Proceedings of CoNLL,</booktitle>
<pages>149--164</pages>
<location>New York City, USA,</location>
<contexts>
<context position="2645" citStr="Buchholz and Marsi, 2006" startWordPosition="386" endWordPosition="389">use an approximate decoder while a transition-based parser is not necessarily deterministic. To make the concepts clear, we classify the two types of parser by the following two criteria: 1. whether or not the outputs are built by explicit transition-actions, such as ”Shift” and ”Reduce”; 2. whether it is dependency graphs or transitionactions that the parsing model assigns scores to. By this classification, beam-search can be applied to both graph-based and transition-based parsers. Representative of each method, MSTParser and MaltParser gave comparable accuracies in the CoNLL-X shared task (Buchholz and Marsi, 2006). However, they make different types of errors, which can be seen as a reflection of their theoretical differences (McDonald and Nivre, 2007). MSTParser has the strength of exact inference, but its choice of features is constrained by the requirement of efficient dynamic programming. MaltParser is deterministic, yet its comparatively larger feature range is an advantage. By comparing the two, three interesting research questions arise: (1) how to increase the flexibility in defining features for graph-based parsing; (2) how to add search to transition-based parsing; and (3) how to combine the </context>
</contexts>
<marker>Buchholz, Marsi, 2006</marker>
<rawString>Sabine Buchholz and Erwin Marsi. 2006. CoNLL-X shared task on multilingual dependency parsing. In Proceedings of CoNLL, pages 149–164, New York City, USA, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Xavier Carreras</author>
<author>Mihai Surdeanu</author>
<author>Lluis Marquez</author>
</authors>
<title>Projective dependency parsing with perceptron.</title>
<date>2006</date>
<booktitle>In Proceedings of CoNLL,</booktitle>
<location>New York City, USA,</location>
<contexts>
<context position="1154" citStr="Carreras et al., 2006" startWordPosition="160" endWordPosition="163">sed and a transition-based dependency parser, we show that a beam-search decoder is a competitive choice for both methods. More importantly, we propose a beam-search-based parser that combines both graph-based and transitionbased parsing into a single system for training and decoding, showing that it outperforms both the pure graph-based and the pure transition-based parsers. Testing on the English and Chinese Penn Treebank data, the combined system gave state-of-the-art accuracies of 92.1% and 86.2%, respectively. 1 Introduction Graph-based (McDonald et al., 2005; McDonald and Pereira, 2006; Carreras et al., 2006) and transition-based (Yamada and Matsumoto, 2003; Nivre et al., 2006) parsing algorithms offer two different approaches to data-driven dependency parsing. Given an input sentence, a graph-based algorithm finds the highest scoring parse tree from all possible outputs, scoring each complete tree, while a transition-based algorithm builds a parse by a sequence of actions, scoring each action individually. The terms “graph-based” and “transition-based” were used by McDonald and Nivre (2007) to describe the difference between MSTParser (McDonald and Pereira, 2006), which is a graph-based parser wi</context>
</contexts>
<marker>Carreras, Surdeanu, Marquez, 2006</marker>
<rawString>Xavier Carreras, Mihai Surdeanu, and Lluis Marquez. 2006. Projective dependency parsing with perceptron. In Proceedings of CoNLL, New York City, USA, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Xavier Carreras</author>
</authors>
<title>Experiments with a higher-order projective dependency parser.</title>
<date>2007</date>
<booktitle>In Proceedings of the CoNLL Shared Task Session ofEMNLP/CoNLL,</booktitle>
<pages>957--961</pages>
<location>Prague, Czech Republic,</location>
<contexts>
<context position="26226" citStr="Carreras, 2007" startWordPosition="4290" endWordPosition="4291">es and graphbased features from the MSTParser (“Combined [TM]”), the combined parser achieved 92.0% perword accuracy, which is significantly higher than the pure graph-based and transition-based parsers. Additional graph-based features further improved the accuracy to 92.1%/45.5%, which is the best among all the parsers compared.1 5.3 Parsing Chinese We use the Penn Chinese Treebank (CTB) 5 for experimental data. Following Duan et al. (2007), we 1A recent paper, Koo et al. (2008) reported parent-prediction accuracy of 92.0% using a graph-based parser with a different (larger) set of features (Carreras, 2007). By applying separate word cluster information, Koo et al. (2008) improved the accuracy to 93.2%, which is the best known accuracy on the PTB data. We excluded these from Table 5 because our work is not concerned with the use of such additional knowledge. split the corpus into training, development and test data as shown in Table 6, and use the head-finding rules in Table 8 in the Appendix to turn the bracketed sentences into dependency structures. Most of the head-finding rules are from Sun and Jurafsky (2004), while we added rules to handle NN and FRAG, and a default rule to use the rightmo</context>
</contexts>
<marker>Carreras, 2007</marker>
<rawString>Xavier Carreras. 2007. Experiments with a higher-order projective dependency parser. In Proceedings of the CoNLL Shared Task Session ofEMNLP/CoNLL, pages 957–961, Prague, Czech Republic, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Collins</author>
<author>Brian Roark</author>
</authors>
<title>Incremental parsing with the perceptron algorithm.</title>
<date>2004</date>
<booktitle>In Proceedings ofACL,</booktitle>
<pages>111--118</pages>
<location>Barcelona, Spain,</location>
<contexts>
<context position="3922" citStr="Collins and Roark, 2004" startWordPosition="591" endWordPosition="594">are utilized. In this paper, we study these questions under one framework: beam-search. Beam-search has been successful in many NLP tasks (Koehn et al., 2003; 562 Proceedings of the 2008 Conference on Empirical Methods in Natural Language Processing, pages 562–571, Honolulu, October 2008.c�2008 Association for Computational Linguistics Inputs: training examples (xi, yi) Initialization: set w� = 0 Algorithm: // R training iterations; N examples for t = 1..R, i = 1..N: zi = arg maxyEGEN(xi) 4b(y) · w� if zi =6 yi: w� = w� + 4b(yi) − 4b(zi) Outputs: w� Figure 1: The perceptron learning algorithm Collins and Roark, 2004), and can achieve accuracy that is close to exact inference. Moreover, a beamsearch decoder does not impose restrictions on the search problem in the way that an exact inference decoder typically does, such as requiring the “optimal subproblem” property for dynamic programming, and therefore enables a comparatively wider range of features for a statistical system. We develop three parsers. Firstly, using the same features as MSTParser, we develop a graph-based parser to examine the accuracy loss from beamsearch compared to exact-search, and the accuracy gain from extra features that are hard t</context>
<context position="8823" citStr="Collins and Roark (2004)" startWordPosition="1410" endWordPosition="1413">ts, the agenda contains an empty sentence. At each processing stage, existing partial candidates from the agenda are extended in all possible ways according to the Covington algorithm. The top B newly generated candidates are then put to the agenda. After all input words are processed, the best candidate output from the agenda is taken as the final output. The projectivity of the output dependency trees is guaranteed by the incremental Covington process. The time complexity of this algorithm is O(n2), where n is the length of the input sentence. During training, the “early update” strategy of Collins and Roark (2004) is used: when the correct state item falls out of the beam at any stage, parsing is stopped immediately, and the model is updated using the current best partial item. The intuition is to improve learning by avoiding irrelevant information: when all the items in the current agenda are incorrect, further parsing steps will be irrelevant because the correct partial output no longer exists in the candidate ranking. Table 1 shows the feature templates from the MSTParser (McDonald and Pereira, 2006), which are defined in terms of the context of a word, its parent and its sibling. To give more templ</context>
</contexts>
<marker>Collins, Roark, 2004</marker>
<rawString>Michael Collins and Brian Roark. 2004. Incremental parsing with the perceptron algorithm. In Proceedings ofACL, pages 111–118, Barcelona, Spain, July.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Collins</author>
</authors>
<title>Discriminative training methods for hidden markov models: Theory and experiments with perceptron algorithms.</title>
<date>2002</date>
<booktitle>In Proceedings of EMNLP,</booktitle>
<pages>1--8</pages>
<location>Philadelphia, USA,</location>
<contexts>
<context position="7325" citStr="Collins, 2002" startWordPosition="1166" endWordPosition="1167"> = arg max Score(y) yEGEN(x) where GEN(x) denotes the set of possible parses for the input x. To repeat our earlier comments, in this paper we do not consider the method of finding the arg max to be part of the definition of graph-based parsing, only the fact that the dependency graph itself is being scored, and factored into scores attached to the dependency links. The score of an output parse y is given by a linear model: Score(y) = 4b(y) · w� 563 where 4b(y) is the global feature vector from y and w is the weight vector of the model. We use the discriminative perceptron learning algorithm (Collins, 2002; McDonald et al., 2005) to train the values of w. The algorithm is shown in Figure 1. Averaging parameters is a way to reduce overfitting for perceptron training (Collins, 2002), and is applied to all our experiments. While the MSTParser uses exact-inference (Eisner, 1996), we apply beam-search to decoding. This is done by extending the deterministic Covington algorithm for projective dependency parsing (Covington, 2001). As shown in Figure 2, the decoder works incrementally, building a state item (i.e. partial parse tree) word by word. When each word is processed, links are added between the</context>
<context position="17920" citStr="Collins, 2002" startWordPosition="2952" endWordPosition="2953">(T, s) · w� Φ(T, s) is the feature vector extracted from the action T and the context s, and w� is the weight vector. Features are extracted according to the templates shown in Table 3, which are based on the context in Figure 3. Note that our feature definitions are similar to those used by MaltParser, but rather than using a kernel function with simple features (e.g. STw, 1 stack top 2 current word 3 next word 4 ST and N0 5 POS bigram 6 POS trigrams 7 N0 word 566 N0t, but not STwt or STwN0w), we combine features manually. As with the graph-based parser, we use the discriminative perceptron (Collins, 2002) to train the transition-based model (see Figure 5). It is worth noticing that, in contrast to MaltParser, which trains each action decision individually, our training algorithm globally optimizes all action decisions for a parse. Again, “early update” and averaging parameters are applied to the training process. 4 The combined parser The graph-based and transition-based approaches adopt very different views of dependency parsing. McDonald and Nivre (2007) showed that the MSTParser and MaltParser produce different errors. This observation suggests a combined approach: by using both graph-based</context>
<context position="21744" citStr="Collins (2002)" startWordPosition="3563" endWordPosition="3564"> Chinese Penn Treebank corpora. The English data is prepared by following McDonald et al. (2005). Bracketed sentences from the Penn Treebank (PTB) 3 are split into training, development and test sets 567 Figure 6: The influence of beam size on the transitionbased parser, using the development data X-axis: number of training iterations Y-axis: word precision as shown in Table 4, and then translated into dependency structures using the head-finding rules from Yamada and Matsumoto (2003). Before parsing, POS tags are assigned to the input sentence using our reimplementation of the POStagger from Collins (2002). Like McDonald et al. (2005), we evaluate the parsing accuracy by the precision of lexical heads (the percentage of input words, excluding punctuation, that have been assigned the correct parent) and by the percentage of complete matches, in which all words excluding punctuation have been assigned the correct parent. 5.1 Development experiments Since the beam size affects all three parsers, we study its influence first; here we show the effect on the transition-based parser. Figure 6 shows different accuracy curves using the development data, each with a different beam size B. The X-axis repr</context>
</contexts>
<marker>Collins, 2002</marker>
<rawString>Michael Collins. 2002. Discriminative training methods for hidden markov models: Theory and experiments with perceptron algorithms. In Proceedings of EMNLP, pages 1–8, Philadelphia, USA, July.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael A Covington</author>
</authors>
<title>A fundamental algorithm for dependency parsing.</title>
<date>2001</date>
<booktitle>In Proceedings of the ACM Southeast Conference,</booktitle>
<location>Athens, Georgia,</location>
<contexts>
<context position="6602" citStr="Covington, 2001" startWordPosition="1033" endWordPosition="1034">newitem = item // duplicate item newitem.link(prev, index) // modify output.append(newitem) // record // if prev does not have a parent word, // add link making index parent of prev if item.parent(prev) == 0: item.link(index, prev) // modify output.append(item) // record prev = the index of the first word before prev whose parent does not exist or is on its left; 0 if no match clear agenda put the best items from output to agenda Output: the best item in agenda Figure 2: A beam-search decoder for graph-based parsing, developed from the deterministic Covington algorithm for projective parsing (Covington, 2001). based parsing problem as finding the highest scoring tree y from all possible outputs given an input x: F(x) = arg max Score(y) yEGEN(x) where GEN(x) denotes the set of possible parses for the input x. To repeat our earlier comments, in this paper we do not consider the method of finding the arg max to be part of the definition of graph-based parsing, only the fact that the dependency graph itself is being scored, and factored into scores attached to the dependency links. The score of an output parse y is given by a linear model: Score(y) = 4b(y) · w� 563 where 4b(y) is the global feature ve</context>
</contexts>
<marker>Covington, 2001</marker>
<rawString>Michael A. Covington. 2001. A fundamental algorithm for dependency parsing. In Proceedings of the ACM Southeast Conference, Athens, Georgia, March.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Xiangyu Duan</author>
<author>Jun Zhao</author>
<author>Bo Xu</author>
</authors>
<title>Probabilistic models for action-based chinese dependency parsing.</title>
<date>2007</date>
<booktitle>In Proceedings of ECML/ECPPKDD,</booktitle>
<location>Warsaw, Poland,</location>
<contexts>
<context position="26056" citStr="Duan et al. (2007)" startWordPosition="4262" endWordPosition="4265"> do not modify the parse tree. Nevertheless, the score serves as a reference for the effect of additional features in the combined parser. Using both transition-based features and graphbased features from the MSTParser (“Combined [TM]”), the combined parser achieved 92.0% perword accuracy, which is significantly higher than the pure graph-based and transition-based parsers. Additional graph-based features further improved the accuracy to 92.1%/45.5%, which is the best among all the parsers compared.1 5.3 Parsing Chinese We use the Penn Chinese Treebank (CTB) 5 for experimental data. Following Duan et al. (2007), we 1A recent paper, Koo et al. (2008) reported parent-prediction accuracy of 92.0% using a graph-based parser with a different (larger) set of features (Carreras, 2007). By applying separate word cluster information, Koo et al. (2008) improved the accuracy to 93.2%, which is the best known accuracy on the PTB data. We excluded these from Table 5 because our work is not concerned with the use of such additional knowledge. split the corpus into training, development and test data as shown in Table 6, and use the head-finding rules in Table 8 in the Appendix to turn the bracketed sentences into</context>
<context position="27452" citStr="Duan et al. (2007)" startWordPosition="4495" endWordPosition="4498">as the head for the constituent that are not listed. Like Duan et al. (2007), we use gold-standard POS-tags for the input. The parsing accuracy is evaluated by the percentage of non-root words that have been assigned the correct head, the percentage of correctly identified root words, and the percentage of complete matches, all excluding punctuation. The accuracies are shown in Table 7. Rows “Graph [MA]”, “Transition”, “Combined [TM]” and “Combined [TMA]” show our models in the same way as for the English experiments from Section 5.2. Row “Duan 2007” represents the transition-based model from Duan et al. (2007), which applies beamsearch to the deterministic model from Yamada and Matsumoto (2003), and achieved the previous best accuracy on the data. Our observations on parsing Chinese are essentially the same as for English. Our combined parser outperforms both the pure graph-based and the pure transition-based parsers. It gave the best accuracy we are aware of for dependency parsing using CTB. 6 Related work Our graph-based parser is derived from the work of McDonald and Pereira (2006). Instead of performing exact inference by dynamic programming, we incorporated the linear model and feature templat</context>
<context position="28796" citStr="Duan et al. (2007)" startWordPosition="4703" endWordPosition="4706"> (2007) also showed the effectiveness of global features in improving the accuracy of graph-based parsing, using the approximate Gibbs sampling method and a reranking approach, respectively. Our transition-based parser is derived from the deterministic parser of Nivre et al. (2006). We incorporated the transition process into our beamsearch framework, in order to study the influence of search on this algorithm. Existing efforts to add search to deterministic parsing include Sagae 569 and Lavie (2006b), which applied best-first search to constituent parsing, and Johansson and Nugues (2006) and Duan et al. (2007), which applied beamsearch to dependency parsing. All three methods estimate the probability of each transition action, and score a state item by the product of the probabilities of all its corresponding actions. But different from our transition-based parser, which trains all transitions for a parse globally, these models train the probability of each action separately. Based on the work of Johansson and Nugues (2006), Johansson and Nugues (2007) studied global training with an approximated large-margin algorithm. This model is the most similar to our transition-based model, while the differe</context>
</contexts>
<marker>Duan, Zhao, Xu, 2007</marker>
<rawString>Xiangyu Duan, Jun Zhao, and Bo Xu. 2007. Probabilistic models for action-based chinese dependency parsing. In Proceedings of ECML/ECPPKDD, Warsaw, Poland, September.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jason Eisner</author>
</authors>
<title>Three new probabilistic models for dependency parsing: An exploration.</title>
<date>1996</date>
<booktitle>In Proceedings of COLING,</booktitle>
<pages>340--345</pages>
<location>Copenhagen, Denmark,</location>
<contexts>
<context position="7599" citStr="Eisner, 1996" startWordPosition="1212" endWordPosition="1214">dency graph itself is being scored, and factored into scores attached to the dependency links. The score of an output parse y is given by a linear model: Score(y) = 4b(y) · w� 563 where 4b(y) is the global feature vector from y and w is the weight vector of the model. We use the discriminative perceptron learning algorithm (Collins, 2002; McDonald et al., 2005) to train the values of w. The algorithm is shown in Figure 1. Averaging parameters is a way to reduce overfitting for perceptron training (Collins, 2002), and is applied to all our experiments. While the MSTParser uses exact-inference (Eisner, 1996), we apply beam-search to decoding. This is done by extending the deterministic Covington algorithm for projective dependency parsing (Covington, 2001). As shown in Figure 2, the decoder works incrementally, building a state item (i.e. partial parse tree) word by word. When each word is processed, links are added between the current word and its predecessors. Beam-search is applied by keeping the B best items in the agenda at each processing stage, while partial candidates are compared by scores from the graph-based model, according to partial graph up to the current word. Before decoding star</context>
</contexts>
<marker>Eisner, 1996</marker>
<rawString>Jason Eisner. 1996. Three new probabilistic models for dependency parsing: An exploration. In Proceedings of COLING, pages 340–345, Copenhagen, Denmark, August.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Johan Hall</author>
<author>Jens Nilsson</author>
<author>Joakim Nivre</author>
<author>G¨ulsen Eryigit</author>
<author>Be´ata Megyesi</author>
<author>Mattias Nilsson</author>
<author>Markus Saers</author>
</authors>
<title>Single malt or blended? a study in multilingual parser optimization.</title>
<date>2007</date>
<booktitle>In Proceedings of the CoNLL Shared Task Session of EMNLP/CoNLL,</booktitle>
<pages>933--939</pages>
<location>Prague, Czech Republic,</location>
<contexts>
<context position="29898" citStr="Hall et al., 2007" startWordPosition="4871" endWordPosition="4874">approximated large-margin algorithm. This model is the most similar to our transition-based model, while the differences include the choice of learning and decoding algorithms, the definition of feature templates and our application of the “early update” strategy. Our combined parser makes the biggest contribution of this paper. In contrast to the models above, it includes both graph-based and transition-based components. An existing method to combine multiple parsing algorithms is the ensemble approach (Sagae and Lavie, 2006a), which was reported to be useful in improving dependency parsing (Hall et al., 2007). A more recent approach (Nivre and McDonald, 2008) combined MSTParser and MaltParser by using the output of one parser for features in the other. Both Hall et al. (2007) and Nivre and McDonald (2008) can be seen as methods to combine separately defined models. In contrast, our parser combines two components in a single model, in which all parameters are trained consistently. 7 Conclusion and future work We developed a graph-based and a transition-based projective dependency parser using beam-search, demonstrating that beam-search is a competitive choice for both parsing approaches. We then co</context>
</contexts>
<marker>Hall, Nilsson, Nivre, Eryigit, Megyesi, Nilsson, Saers, 2007</marker>
<rawString>Johan Hall, Jens Nilsson, Joakim Nivre, G¨ulsen Eryigit, Be´ata Megyesi, Mattias Nilsson, and Markus Saers. 2007. Single malt or blended? a study in multilingual parser optimization. In Proceedings of the CoNLL Shared Task Session of EMNLP/CoNLL, pages 933– 939, Prague, Czech Republic, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Keith Hall</author>
</authors>
<title>K-best spanning tree parsing.</title>
<date>2007</date>
<booktitle>In Proceedings ofACL,</booktitle>
<location>Prague, Czech Republic,</location>
<contexts>
<context position="28185" citStr="Hall (2007)" startWordPosition="4612" endWordPosition="4613">uracy on the data. Our observations on parsing Chinese are essentially the same as for English. Our combined parser outperforms both the pure graph-based and the pure transition-based parsers. It gave the best accuracy we are aware of for dependency parsing using CTB. 6 Related work Our graph-based parser is derived from the work of McDonald and Pereira (2006). Instead of performing exact inference by dynamic programming, we incorporated the linear model and feature templates from McDonald and Pereira (2006) into our beam-search framework, while adding new global features. Nakagawa (2007) and Hall (2007) also showed the effectiveness of global features in improving the accuracy of graph-based parsing, using the approximate Gibbs sampling method and a reranking approach, respectively. Our transition-based parser is derived from the deterministic parser of Nivre et al. (2006). We incorporated the transition process into our beamsearch framework, in order to study the influence of search on this algorithm. Existing efforts to add search to deterministic parsing include Sagae 569 and Lavie (2006b), which applied best-first search to constituent parsing, and Johansson and Nugues (2006) and Duan et</context>
</contexts>
<marker>Hall, 2007</marker>
<rawString>Keith Hall. 2007. K-best spanning tree parsing. In Proceedings ofACL, Prague, Czech Republic, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Richard Johansson</author>
<author>Pierre Nugues</author>
</authors>
<title>Investigating multilingual dependency parsing.</title>
<date>2006</date>
<booktitle>In Proceedings of CoNLL,</booktitle>
<pages>206--210</pages>
<location>New York City, USA,</location>
<contexts>
<context position="28773" citStr="Johansson and Nugues (2006)" startWordPosition="4698" endWordPosition="4701">atures. Nakagawa (2007) and Hall (2007) also showed the effectiveness of global features in improving the accuracy of graph-based parsing, using the approximate Gibbs sampling method and a reranking approach, respectively. Our transition-based parser is derived from the deterministic parser of Nivre et al. (2006). We incorporated the transition process into our beamsearch framework, in order to study the influence of search on this algorithm. Existing efforts to add search to deterministic parsing include Sagae 569 and Lavie (2006b), which applied best-first search to constituent parsing, and Johansson and Nugues (2006) and Duan et al. (2007), which applied beamsearch to dependency parsing. All three methods estimate the probability of each transition action, and score a state item by the product of the probabilities of all its corresponding actions. But different from our transition-based parser, which trains all transitions for a parse globally, these models train the probability of each action separately. Based on the work of Johansson and Nugues (2006), Johansson and Nugues (2007) studied global training with an approximated large-margin algorithm. This model is the most similar to our transition-based m</context>
</contexts>
<marker>Johansson, Nugues, 2006</marker>
<rawString>Richard Johansson and Pierre Nugues. 2006. Investigating multilingual dependency parsing. In Proceedings of CoNLL, pages 206–210, New York City, USA, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Richard Johansson</author>
<author>Pierre Nugues</author>
</authors>
<title>Incremental dependency parsing using online learning.</title>
<date>2007</date>
<booktitle>In Proceedings of the CoNLL/EMNLP,</booktitle>
<pages>1134--1138</pages>
<location>Prague, Czech Republic.</location>
<contexts>
<context position="29247" citStr="Johansson and Nugues (2007)" startWordPosition="4774" endWordPosition="4777">rch to deterministic parsing include Sagae 569 and Lavie (2006b), which applied best-first search to constituent parsing, and Johansson and Nugues (2006) and Duan et al. (2007), which applied beamsearch to dependency parsing. All three methods estimate the probability of each transition action, and score a state item by the product of the probabilities of all its corresponding actions. But different from our transition-based parser, which trains all transitions for a parse globally, these models train the probability of each action separately. Based on the work of Johansson and Nugues (2006), Johansson and Nugues (2007) studied global training with an approximated large-margin algorithm. This model is the most similar to our transition-based model, while the differences include the choice of learning and decoding algorithms, the definition of feature templates and our application of the “early update” strategy. Our combined parser makes the biggest contribution of this paper. In contrast to the models above, it includes both graph-based and transition-based components. An existing method to combine multiple parsing algorithms is the ensemble approach (Sagae and Lavie, 2006a), which was reported to be useful </context>
</contexts>
<marker>Johansson, Nugues, 2007</marker>
<rawString>Richard Johansson and Pierre Nugues. 2007. Incremental dependency parsing using online learning. In Proceedings of the CoNLL/EMNLP, pages 1134–1138, Prague, Czech Republic.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Philip Koehn</author>
<author>Franz Och</author>
<author>Daniel Marcu</author>
</authors>
<title>Statistical phrase-based translation.</title>
<date>2003</date>
<booktitle>In Proceedings of NAACL/HLT,</booktitle>
<location>Edmonton, Canada,</location>
<contexts>
<context position="3455" citStr="Koehn et al., 2003" startWordPosition="515" endWordPosition="518">t its choice of features is constrained by the requirement of efficient dynamic programming. MaltParser is deterministic, yet its comparatively larger feature range is an advantage. By comparing the two, three interesting research questions arise: (1) how to increase the flexibility in defining features for graph-based parsing; (2) how to add search to transition-based parsing; and (3) how to combine the two parsing approaches so that the strengths of each are utilized. In this paper, we study these questions under one framework: beam-search. Beam-search has been successful in many NLP tasks (Koehn et al., 2003; 562 Proceedings of the 2008 Conference on Empirical Methods in Natural Language Processing, pages 562–571, Honolulu, October 2008.c�2008 Association for Computational Linguistics Inputs: training examples (xi, yi) Initialization: set w� = 0 Algorithm: // R training iterations; N examples for t = 1..R, i = 1..N: zi = arg maxyEGEN(xi) 4b(y) · w� if zi =6 yi: w� = w� + 4b(yi) − 4b(zi) Outputs: w� Figure 1: The perceptron learning algorithm Collins and Roark, 2004), and can achieve accuracy that is close to exact inference. Moreover, a beamsearch decoder does not impose restrictions on the searc</context>
</contexts>
<marker>Koehn, Och, Marcu, 2003</marker>
<rawString>Philip Koehn, Franz Och, and Daniel Marcu. 2003. Statistical phrase-based translation. In Proceedings of NAACL/HLT, Edmonton, Canada, May.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Terry Koo</author>
<author>Xavier Carreras</author>
<author>Michael Collins</author>
</authors>
<title>Simple semi-supervised dependency parsing.</title>
<date>2008</date>
<booktitle>In Proceedings of ACL/HLT,</booktitle>
<pages>595--603</pages>
<location>Columbus, Ohio,</location>
<contexts>
<context position="26095" citStr="Koo et al. (2008)" startWordPosition="4270" endWordPosition="4273">ess, the score serves as a reference for the effect of additional features in the combined parser. Using both transition-based features and graphbased features from the MSTParser (“Combined [TM]”), the combined parser achieved 92.0% perword accuracy, which is significantly higher than the pure graph-based and transition-based parsers. Additional graph-based features further improved the accuracy to 92.1%/45.5%, which is the best among all the parsers compared.1 5.3 Parsing Chinese We use the Penn Chinese Treebank (CTB) 5 for experimental data. Following Duan et al. (2007), we 1A recent paper, Koo et al. (2008) reported parent-prediction accuracy of 92.0% using a graph-based parser with a different (larger) set of features (Carreras, 2007). By applying separate word cluster information, Koo et al. (2008) improved the accuracy to 93.2%, which is the best known accuracy on the PTB data. We excluded these from Table 5 because our work is not concerned with the use of such additional knowledge. split the corpus into training, development and test data as shown in Table 6, and use the head-finding rules in Table 8 in the Appendix to turn the bracketed sentences into dependency structures. Most of the hea</context>
</contexts>
<marker>Koo, Carreras, Collins, 2008</marker>
<rawString>Terry Koo, Xavier Carreras, and Michael Collins. 2008. Simple semi-supervised dependency parsing. In Proceedings of ACL/HLT, pages 595–603, Columbus, Ohio, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ryan McDonald</author>
<author>Joakim Nivre</author>
</authors>
<title>Characterizing the errors of data-driven dependency parsing models.</title>
<date>2007</date>
<booktitle>In Proceedings of EMNLP/CoNLL,</booktitle>
<pages>122--131</pages>
<location>Prague, Czech Republic,</location>
<contexts>
<context position="1646" citStr="McDonald and Nivre (2007)" startWordPosition="233" endWordPosition="236"> 92.1% and 86.2%, respectively. 1 Introduction Graph-based (McDonald et al., 2005; McDonald and Pereira, 2006; Carreras et al., 2006) and transition-based (Yamada and Matsumoto, 2003; Nivre et al., 2006) parsing algorithms offer two different approaches to data-driven dependency parsing. Given an input sentence, a graph-based algorithm finds the highest scoring parse tree from all possible outputs, scoring each complete tree, while a transition-based algorithm builds a parse by a sequence of actions, scoring each action individually. The terms “graph-based” and “transition-based” were used by McDonald and Nivre (2007) to describe the difference between MSTParser (McDonald and Pereira, 2006), which is a graph-based parser with an exhaustive search decoder, and MaltParser (Nivre et al., 2006), which is a transition-based parser with a greedy search decoder. In this paper, we do not differentiate graph-based and transitionbased parsers by their search algorithms: a graphbased parser can use an approximate decoder while a transition-based parser is not necessarily deterministic. To make the concepts clear, we classify the two types of parser by the following two criteria: 1. whether or not the outputs are buil</context>
<context position="18380" citStr="McDonald and Nivre (2007)" startWordPosition="3018" endWordPosition="3021">igrams 7 N0 word 566 N0t, but not STwt or STwN0w), we combine features manually. As with the graph-based parser, we use the discriminative perceptron (Collins, 2002) to train the transition-based model (see Figure 5). It is worth noticing that, in contrast to MaltParser, which trains each action decision individually, our training algorithm globally optimizes all action decisions for a parse. Again, “early update” and averaging parameters are applied to the training process. 4 The combined parser The graph-based and transition-based approaches adopt very different views of dependency parsing. McDonald and Nivre (2007) showed that the MSTParser and MaltParser produce different errors. This observation suggests a combined approach: by using both graph-based information and transition-based information, parsing accuracy can be improved. The beam-search framework we have developed facilitates such a combination. Our graph-based and transition-based parsers share many similarities. Both build a parse tree incrementally, keeping an agenda of comparable state items. Both rank state items by their current scores, and use the averaged perceptron with early update for training. The key differences are the scoring mo</context>
</contexts>
<marker>McDonald, Nivre, 2007</marker>
<rawString>Ryan McDonald and Joakim Nivre. 2007. Characterizing the errors of data-driven dependency parsing models. In Proceedings of EMNLP/CoNLL, pages 122– 131, Prague, Czech Republic, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R McDonald</author>
<author>F Pereira</author>
</authors>
<title>Online learning of approximate dependency parsing algorithms. In</title>
<date>2006</date>
<booktitle>In Proc. of EACL,</booktitle>
<pages>81--88</pages>
<location>Trento, Italy,</location>
<contexts>
<context position="1130" citStr="McDonald and Pereira, 2006" startWordPosition="155" endWordPosition="159">ch. By developing a graph-based and a transition-based dependency parser, we show that a beam-search decoder is a competitive choice for both methods. More importantly, we propose a beam-search-based parser that combines both graph-based and transitionbased parsing into a single system for training and decoding, showing that it outperforms both the pure graph-based and the pure transition-based parsers. Testing on the English and Chinese Penn Treebank data, the combined system gave state-of-the-art accuracies of 92.1% and 86.2%, respectively. 1 Introduction Graph-based (McDonald et al., 2005; McDonald and Pereira, 2006; Carreras et al., 2006) and transition-based (Yamada and Matsumoto, 2003; Nivre et al., 2006) parsing algorithms offer two different approaches to data-driven dependency parsing. Given an input sentence, a graph-based algorithm finds the highest scoring parse tree from all possible outputs, scoring each complete tree, while a transition-based algorithm builds a parse by a sequence of actions, scoring each action individually. The terms “graph-based” and “transition-based” were used by McDonald and Nivre (2007) to describe the difference between MSTParser (McDonald and Pereira, 2006), which is</context>
<context position="5524" citStr="McDonald and Pereira, 2006" startWordPosition="840" endWordPosition="844">graph-based and transition-based parsing into a single system, with the combined system significantly outperforming each individual system. In experiments with the English and Chinese Penn Treebank data, the combined parser gave 92.1% and 86.2% accuracy, respectively, which are comparable to the best parsing results for these data sets, while the Chinese accuracy outperforms the previous best reported by 1.8%. In line with previous work on dependency parsing using the Penn Treebank, we focus on projective dependency parsing. 2 The graph-based parser Following MSTParser (McDonald et al., 2005; McDonald and Pereira, 2006), we define the graphVariables: agenda – the beam for state items item – partial parse tree output – a set of output items index, prev – word indexes Input: x – POS-tagged input sentence. Initialization: agenda = [“”] Algorithm: for index in 1..x.length(): clear output for item in agenda: // for all prev words that can be linked with // the current word at index prev = index − 1 while prev =6 0: // while prev is valid // add link making prev parent of index newitem = item // duplicate item newitem.link(prev, index) // modify output.append(newitem) // record // if prev does not have a parent wo</context>
<context position="9322" citStr="McDonald and Pereira, 2006" startWordPosition="1493" endWordPosition="1496"> is O(n2), where n is the length of the input sentence. During training, the “early update” strategy of Collins and Roark (2004) is used: when the correct state item falls out of the beam at any stage, parsing is stopped immediately, and the model is updated using the current best partial item. The intuition is to improve learning by avoiding irrelevant information: when all the items in the current agenda are incorrect, further parsing steps will be irrelevant because the correct partial output no longer exists in the candidate ranking. Table 1 shows the feature templates from the MSTParser (McDonald and Pereira, 2006), which are defined in terms of the context of a word, its parent and its sibling. To give more templates, features from templates 1 – 5 are also conjoined with 1 Parent word (P) Pw; Pt; Pwt 2 Child word (C) Cw; Ct; Cwt 3 P and C PwtCwt; PwtCw; PwCwt; PwtCt; PtCwt; PwCw; PtCt 4 A tag Bt PtBtCt between P, C 5 Neighbour words PtPLtCtCLt; of P, C, PtPLtCtCRt; left (PL/CL) PtPRtCtCLt; and right (PR/CR) PtPRtCtCRt; PtPLtCLt; PtPLtCRt; PtPRtCLt; PtPRtCRt; PLtCtCLt; PLtCtCRt; PRtCtCLt; PRtCtCRt; PtCtCLt; PtCtCRt; PtPLtCt; PtPRtCt 6 sibling (S) of C CwSw; CtSt; CwSt; CtSw; PtCtSt; Table 1: Feature tem</context>
<context position="23663" citStr="McDonald and Pereira, 2006" startWordPosition="3881" endWordPosition="3884">e accuracy. When B = 1, the transition-based parser becomes a deterministic parser. By comparing the curves when B = 1 and B = 2, we can see that, while the use of search reduces the parsing speed, it improves the quality of the output parses. Therefore, beam-search is a reasonable choice for transitionbased parsing. 5.2 Accuracy comparisons The test accuracies are shown in Table 5, where each row represents a parsing model. Rows “MSTParser 1/2” show the first-order (using feature templates 1 – 5 from Table 1) (McDonald et al., 2005) and secondorder (using all feature templates from Table 1) (McDonald and Pereira, 2006) MSTParsers, as reported by the corresponding papers. Rows “Graph [M]” and “Graph [MA]” represent our graph-based parser using features from Table 1 and Table 1 + Table 2, respectively; row “Transition” represents our transition-based parser; and rows “Combined [TM]” and “Combined [TMA]” represent our combined parser using features from Table 3 + Table 1 and Table 3 + Table 1 + Table 2, respectively. Columns “Word” and “Complete” show the precision of lexical heads and complete matches, respectively. As can be seen from the table, beam-search reduced the head word accuracy from 91.5%/42.1% (“M</context>
<context position="27936" citStr="McDonald and Pereira (2006)" startWordPosition="4573" endWordPosition="4576"> in the same way as for the English experiments from Section 5.2. Row “Duan 2007” represents the transition-based model from Duan et al. (2007), which applies beamsearch to the deterministic model from Yamada and Matsumoto (2003), and achieved the previous best accuracy on the data. Our observations on parsing Chinese are essentially the same as for English. Our combined parser outperforms both the pure graph-based and the pure transition-based parsers. It gave the best accuracy we are aware of for dependency parsing using CTB. 6 Related work Our graph-based parser is derived from the work of McDonald and Pereira (2006). Instead of performing exact inference by dynamic programming, we incorporated the linear model and feature templates from McDonald and Pereira (2006) into our beam-search framework, while adding new global features. Nakagawa (2007) and Hall (2007) also showed the effectiveness of global features in improving the accuracy of graph-based parsing, using the approximate Gibbs sampling method and a reranking approach, respectively. Our transition-based parser is derived from the deterministic parser of Nivre et al. (2006). We incorporated the transition process into our beamsearch framework, in o</context>
</contexts>
<marker>McDonald, Pereira, 2006</marker>
<rawString>R McDonald and F Pereira. 2006. Online learning of approximate dependency parsing algorithms. In In Proc. of EACL, pages 81–88, Trento, Italy, April.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ryan McDonald</author>
<author>Koby Crammer</author>
<author>Fernando Pereira</author>
</authors>
<title>Online large-margin training of dependency parsers.</title>
<date>2005</date>
<booktitle>In Proceedings of ACL,</booktitle>
<pages>91--98</pages>
<location>Ann Arbor, Michigan,</location>
<contexts>
<context position="1102" citStr="McDonald et al., 2005" startWordPosition="151" endWordPosition="154">e framework of beamsearch. By developing a graph-based and a transition-based dependency parser, we show that a beam-search decoder is a competitive choice for both methods. More importantly, we propose a beam-search-based parser that combines both graph-based and transitionbased parsing into a single system for training and decoding, showing that it outperforms both the pure graph-based and the pure transition-based parsers. Testing on the English and Chinese Penn Treebank data, the combined system gave state-of-the-art accuracies of 92.1% and 86.2%, respectively. 1 Introduction Graph-based (McDonald et al., 2005; McDonald and Pereira, 2006; Carreras et al., 2006) and transition-based (Yamada and Matsumoto, 2003; Nivre et al., 2006) parsing algorithms offer two different approaches to data-driven dependency parsing. Given an input sentence, a graph-based algorithm finds the highest scoring parse tree from all possible outputs, scoring each complete tree, while a transition-based algorithm builds a parse by a sequence of actions, scoring each action individually. The terms “graph-based” and “transition-based” were used by McDonald and Nivre (2007) to describe the difference between MSTParser (McDonald </context>
<context position="5495" citStr="McDonald et al., 2005" startWordPosition="836" endWordPosition="839">we are able to combine graph-based and transition-based parsing into a single system, with the combined system significantly outperforming each individual system. In experiments with the English and Chinese Penn Treebank data, the combined parser gave 92.1% and 86.2% accuracy, respectively, which are comparable to the best parsing results for these data sets, while the Chinese accuracy outperforms the previous best reported by 1.8%. In line with previous work on dependency parsing using the Penn Treebank, we focus on projective dependency parsing. 2 The graph-based parser Following MSTParser (McDonald et al., 2005; McDonald and Pereira, 2006), we define the graphVariables: agenda – the beam for state items item – partial parse tree output – a set of output items index, prev – word indexes Input: x – POS-tagged input sentence. Initialization: agenda = [“”] Algorithm: for index in 1..x.length(): clear output for item in agenda: // for all prev words that can be linked with // the current word at index prev = index − 1 while prev =6 0: // while prev is valid // add link making prev parent of index newitem = item // duplicate item newitem.link(prev, index) // modify output.append(newitem) // record // if p</context>
<context position="7349" citStr="McDonald et al., 2005" startWordPosition="1168" endWordPosition="1171">e(y) yEGEN(x) where GEN(x) denotes the set of possible parses for the input x. To repeat our earlier comments, in this paper we do not consider the method of finding the arg max to be part of the definition of graph-based parsing, only the fact that the dependency graph itself is being scored, and factored into scores attached to the dependency links. The score of an output parse y is given by a linear model: Score(y) = 4b(y) · w� 563 where 4b(y) is the global feature vector from y and w is the weight vector of the model. We use the discriminative perceptron learning algorithm (Collins, 2002; McDonald et al., 2005) to train the values of w. The algorithm is shown in Figure 1. Averaging parameters is a way to reduce overfitting for perceptron training (Collins, 2002), and is applied to all our experiments. While the MSTParser uses exact-inference (Eisner, 1996), we apply beam-search to decoding. This is done by extending the deterministic Covington algorithm for projective dependency parsing (Covington, 2001). As shown in Figure 2, the decoder works incrementally, building a state item (i.e. partial parse tree) word by word. When each word is processed, links are added between the current word and its pr</context>
<context position="21226" citStr="McDonald et al. (2005)" startWordPosition="3478" endWordPosition="3481">without using transition actions, and so is not appropriate for the combined model. The transition-based algorithm, on the other hand, uses state items which contain partial parse trees, and so provides all the information needed by the graph-based parser (i.e. dependency graphs), and hence the combined system. In summary, we build the combined parser by using a global linear model, the union of feature templates and the decoder from the transition-based parser. 5 Experiments We evaluate the parsers using the English and Chinese Penn Treebank corpora. The English data is prepared by following McDonald et al. (2005). Bracketed sentences from the Penn Treebank (PTB) 3 are split into training, development and test sets 567 Figure 6: The influence of beam size on the transitionbased parser, using the development data X-axis: number of training iterations Y-axis: word precision as shown in Table 4, and then translated into dependency structures using the head-finding rules from Yamada and Matsumoto (2003). Before parsing, POS tags are assigned to the input sentence using our reimplementation of the POStagger from Collins (2002). Like McDonald et al. (2005), we evaluate the parsing accuracy by the precision o</context>
<context position="23575" citStr="McDonald et al., 2005" startWordPosition="3867" endWordPosition="3870">n the rest of the experiments, we set B = 64 in order to obtain the highest possible accuracy. When B = 1, the transition-based parser becomes a deterministic parser. By comparing the curves when B = 1 and B = 2, we can see that, while the use of search reduces the parsing speed, it improves the quality of the output parses. Therefore, beam-search is a reasonable choice for transitionbased parsing. 5.2 Accuracy comparisons The test accuracies are shown in Table 5, where each row represents a parsing model. Rows “MSTParser 1/2” show the first-order (using feature templates 1 – 5 from Table 1) (McDonald et al., 2005) and secondorder (using all feature templates from Table 1) (McDonald and Pereira, 2006) MSTParsers, as reported by the corresponding papers. Rows “Graph [M]” and “Graph [MA]” represent our graph-based parser using features from Table 1 and Table 1 + Table 2, respectively; row “Transition” represents our transition-based parser; and rows “Combined [TM]” and “Combined [TMA]” represent our combined parser using features from Table 3 + Table 1 and Table 3 + Table 1 + Table 2, respectively. Columns “Word” and “Complete” show the precision of lexical heads and complete matches, respectively. As can</context>
</contexts>
<marker>McDonald, Crammer, Pereira, 2005</marker>
<rawString>Ryan McDonald, Koby Crammer, and Fernando Pereira. 2005. Online large-margin training of dependency parsers. In Proceedings of ACL, pages 91–98, Ann Arbor, Michigan, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tetsuji Nakagawa</author>
</authors>
<title>Multilingual dependency parsing using global features.</title>
<date>2007</date>
<booktitle>In Proceedings of the CoNLL Shared Task Session ofEMNLP/CoNLL,</booktitle>
<pages>952--956</pages>
<location>Prague, Czech Republic,</location>
<contexts>
<context position="28169" citStr="Nakagawa (2007)" startWordPosition="4609" endWordPosition="4610">he previous best accuracy on the data. Our observations on parsing Chinese are essentially the same as for English. Our combined parser outperforms both the pure graph-based and the pure transition-based parsers. It gave the best accuracy we are aware of for dependency parsing using CTB. 6 Related work Our graph-based parser is derived from the work of McDonald and Pereira (2006). Instead of performing exact inference by dynamic programming, we incorporated the linear model and feature templates from McDonald and Pereira (2006) into our beam-search framework, while adding new global features. Nakagawa (2007) and Hall (2007) also showed the effectiveness of global features in improving the accuracy of graph-based parsing, using the approximate Gibbs sampling method and a reranking approach, respectively. Our transition-based parser is derived from the deterministic parser of Nivre et al. (2006). We incorporated the transition process into our beamsearch framework, in order to study the influence of search on this algorithm. Existing efforts to add search to deterministic parsing include Sagae 569 and Lavie (2006b), which applied best-first search to constituent parsing, and Johansson and Nugues (2</context>
</contexts>
<marker>Nakagawa, 2007</marker>
<rawString>Tetsuji Nakagawa. 2007. Multilingual dependency parsing using global features. In Proceedings of the CoNLL Shared Task Session ofEMNLP/CoNLL, pages 952–956, Prague, Czech Republic, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joakim Nivre</author>
<author>Ryan McDonald</author>
</authors>
<title>Integrating graph-based and transition-based dependency parsers.</title>
<date>2008</date>
<booktitle>In Proceedings of ACL/HLT,</booktitle>
<pages>950--958</pages>
<location>Columbus, Ohio,</location>
<contexts>
<context position="29949" citStr="Nivre and McDonald, 2008" startWordPosition="4879" endWordPosition="4883">del is the most similar to our transition-based model, while the differences include the choice of learning and decoding algorithms, the definition of feature templates and our application of the “early update” strategy. Our combined parser makes the biggest contribution of this paper. In contrast to the models above, it includes both graph-based and transition-based components. An existing method to combine multiple parsing algorithms is the ensemble approach (Sagae and Lavie, 2006a), which was reported to be useful in improving dependency parsing (Hall et al., 2007). A more recent approach (Nivre and McDonald, 2008) combined MSTParser and MaltParser by using the output of one parser for features in the other. Both Hall et al. (2007) and Nivre and McDonald (2008) can be seen as methods to combine separately defined models. In contrast, our parser combines two components in a single model, in which all parameters are trained consistently. 7 Conclusion and future work We developed a graph-based and a transition-based projective dependency parser using beam-search, demonstrating that beam-search is a competitive choice for both parsing approaches. We then combined the two parsers into a single system, using </context>
</contexts>
<marker>Nivre, McDonald, 2008</marker>
<rawString>Joakim Nivre and Ryan McDonald. 2008. Integrating graph-based and transition-based dependency parsers. In Proceedings of ACL/HLT, pages 950–958, Columbus, Ohio, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joakim Nivre</author>
<author>Johan Hall</author>
<author>Jens Nilsson</author>
<author>G¨uls¸en Eryiˇgit</author>
<author>Svetoslav Marinov</author>
</authors>
<title>Labeled pseudoprojective dependency parsing with support vector machines.</title>
<date>2006</date>
<booktitle>In Proceedings of CoNLL,</booktitle>
<pages>221--225</pages>
<location>New York City, USA,</location>
<marker>Nivre, Hall, Nilsson, Eryiˇgit, Marinov, 2006</marker>
<rawString>Joakim Nivre, Johan Hall, Jens Nilsson, G¨uls¸en Eryiˇgit, and Svetoslav Marinov. 2006. Labeled pseudoprojective dependency parsing with support vector machines. In Proceedings of CoNLL, pages 221–225, New York City, USA, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Sagae</author>
<author>A Lavie</author>
</authors>
<title>Parser combination by reparsing. In</title>
<date>2006</date>
<booktitle>In Proc. HLT/NAACL,</booktitle>
<pages>129--132</pages>
<location>New York City, USA,</location>
<contexts>
<context position="29811" citStr="Sagae and Lavie, 2006" startWordPosition="4857" endWordPosition="4860"> Johansson and Nugues (2006), Johansson and Nugues (2007) studied global training with an approximated large-margin algorithm. This model is the most similar to our transition-based model, while the differences include the choice of learning and decoding algorithms, the definition of feature templates and our application of the “early update” strategy. Our combined parser makes the biggest contribution of this paper. In contrast to the models above, it includes both graph-based and transition-based components. An existing method to combine multiple parsing algorithms is the ensemble approach (Sagae and Lavie, 2006a), which was reported to be useful in improving dependency parsing (Hall et al., 2007). A more recent approach (Nivre and McDonald, 2008) combined MSTParser and MaltParser by using the output of one parser for features in the other. Both Hall et al. (2007) and Nivre and McDonald (2008) can be seen as methods to combine separately defined models. In contrast, our parser combines two components in a single model, in which all parameters are trained consistently. 7 Conclusion and future work We developed a graph-based and a transition-based projective dependency parser using beam-search, demonst</context>
</contexts>
<marker>Sagae, Lavie, 2006</marker>
<rawString>K Sagae and A Lavie. 2006a. Parser combination by reparsing. In In Proc. HLT/NAACL, pages 129–132, New York City, USA, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenji Sagae</author>
<author>Alon Lavie</author>
</authors>
<title>A best-first probabilistic shift-reduce parser.</title>
<date>2006</date>
<booktitle>In Proceedings of COLING/ACL (poster),</booktitle>
<pages>691--698</pages>
<location>Sydney, Australia,</location>
<contexts>
<context position="29811" citStr="Sagae and Lavie, 2006" startWordPosition="4857" endWordPosition="4860"> Johansson and Nugues (2006), Johansson and Nugues (2007) studied global training with an approximated large-margin algorithm. This model is the most similar to our transition-based model, while the differences include the choice of learning and decoding algorithms, the definition of feature templates and our application of the “early update” strategy. Our combined parser makes the biggest contribution of this paper. In contrast to the models above, it includes both graph-based and transition-based components. An existing method to combine multiple parsing algorithms is the ensemble approach (Sagae and Lavie, 2006a), which was reported to be useful in improving dependency parsing (Hall et al., 2007). A more recent approach (Nivre and McDonald, 2008) combined MSTParser and MaltParser by using the output of one parser for features in the other. Both Hall et al. (2007) and Nivre and McDonald (2008) can be seen as methods to combine separately defined models. In contrast, our parser combines two components in a single model, in which all parameters are trained consistently. 7 Conclusion and future work We developed a graph-based and a transition-based projective dependency parser using beam-search, demonst</context>
</contexts>
<marker>Sagae, Lavie, 2006</marker>
<rawString>Kenji Sagae and Alon Lavie. 2006b. A best-first probabilistic shift-reduce parser. In Proceedings of COLING/ACL (poster), pages 691–698, Sydney, Australia, July.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Honglin Sun</author>
<author>Daniel Jurafsky</author>
</authors>
<title>Shallow semantic parsing of Chinese.</title>
<date>2004</date>
<booktitle>In Proceedings of NAACL/HLT,</booktitle>
<location>Boston, USA,</location>
<contexts>
<context position="26743" citStr="Sun and Jurafsky (2004)" startWordPosition="4377" endWordPosition="4380">on accuracy of 92.0% using a graph-based parser with a different (larger) set of features (Carreras, 2007). By applying separate word cluster information, Koo et al. (2008) improved the accuracy to 93.2%, which is the best known accuracy on the PTB data. We excluded these from Table 5 because our work is not concerned with the use of such additional knowledge. split the corpus into training, development and test data as shown in Table 6, and use the head-finding rules in Table 8 in the Appendix to turn the bracketed sentences into dependency structures. Most of the head-finding rules are from Sun and Jurafsky (2004), while we added rules to handle NN and FRAG, and a default rule to use the rightmost node as the head for the constituent that are not listed. Like Duan et al. (2007), we use gold-standard POS-tags for the input. The parsing accuracy is evaluated by the percentage of non-root words that have been assigned the correct head, the percentage of correctly identified root words, and the percentage of complete matches, all excluding punctuation. The accuracies are shown in Table 7. Rows “Graph [MA]”, “Transition”, “Combined [TM]” and “Combined [TMA]” show our models in the same way as for the Englis</context>
</contexts>
<marker>Sun, Jurafsky, 2004</marker>
<rawString>Honglin Sun and Daniel Jurafsky. 2004. Shallow semantic parsing of Chinese. In Proceedings of NAACL/HLT, Boston, USA, May.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Yamada</author>
<author>Y Matsumoto</author>
</authors>
<title>Statistical dependency analysis using support vector machines.</title>
<date>2003</date>
<booktitle>In Proceedings ofIWPT,</booktitle>
<location>Nancy, France,</location>
<contexts>
<context position="1203" citStr="Yamada and Matsumoto, 2003" startWordPosition="166" endWordPosition="169"> we show that a beam-search decoder is a competitive choice for both methods. More importantly, we propose a beam-search-based parser that combines both graph-based and transitionbased parsing into a single system for training and decoding, showing that it outperforms both the pure graph-based and the pure transition-based parsers. Testing on the English and Chinese Penn Treebank data, the combined system gave state-of-the-art accuracies of 92.1% and 86.2%, respectively. 1 Introduction Graph-based (McDonald et al., 2005; McDonald and Pereira, 2006; Carreras et al., 2006) and transition-based (Yamada and Matsumoto, 2003; Nivre et al., 2006) parsing algorithms offer two different approaches to data-driven dependency parsing. Given an input sentence, a graph-based algorithm finds the highest scoring parse tree from all possible outputs, scoring each complete tree, while a transition-based algorithm builds a parse by a sequence of actions, scoring each action individually. The terms “graph-based” and “transition-based” were used by McDonald and Nivre (2007) to describe the difference between MSTParser (McDonald and Pereira, 2006), which is a graph-based parser with an exhaustive search decoder, and MaltParser (</context>
<context position="21619" citStr="Yamada and Matsumoto (2003)" startWordPosition="3540" endWordPosition="3543">e union of feature templates and the decoder from the transition-based parser. 5 Experiments We evaluate the parsers using the English and Chinese Penn Treebank corpora. The English data is prepared by following McDonald et al. (2005). Bracketed sentences from the Penn Treebank (PTB) 3 are split into training, development and test sets 567 Figure 6: The influence of beam size on the transitionbased parser, using the development data X-axis: number of training iterations Y-axis: word precision as shown in Table 4, and then translated into dependency structures using the head-finding rules from Yamada and Matsumoto (2003). Before parsing, POS tags are assigned to the input sentence using our reimplementation of the POStagger from Collins (2002). Like McDonald et al. (2005), we evaluate the parsing accuracy by the precision of lexical heads (the percentage of input words, excluding punctuation, that have been assigned the correct parent) and by the percentage of complete matches, in which all words excluding punctuation have been assigned the correct parent. 5.1 Development experiments Since the beam size affects all three parsers, we study its influence first; here we show the effect on the transition-based pa</context>
<context position="27538" citStr="Yamada and Matsumoto (2003)" startWordPosition="4508" endWordPosition="4511"> we use gold-standard POS-tags for the input. The parsing accuracy is evaluated by the percentage of non-root words that have been assigned the correct head, the percentage of correctly identified root words, and the percentage of complete matches, all excluding punctuation. The accuracies are shown in Table 7. Rows “Graph [MA]”, “Transition”, “Combined [TM]” and “Combined [TMA]” show our models in the same way as for the English experiments from Section 5.2. Row “Duan 2007” represents the transition-based model from Duan et al. (2007), which applies beamsearch to the deterministic model from Yamada and Matsumoto (2003), and achieved the previous best accuracy on the data. Our observations on parsing Chinese are essentially the same as for English. Our combined parser outperforms both the pure graph-based and the pure transition-based parsers. It gave the best accuracy we are aware of for dependency parsing using CTB. 6 Related work Our graph-based parser is derived from the work of McDonald and Pereira (2006). Instead of performing exact inference by dynamic programming, we incorporated the linear model and feature templates from McDonald and Pereira (2006) into our beam-search framework, while adding new g</context>
</contexts>
<marker>Yamada, Matsumoto, 2003</marker>
<rawString>H Yamada and Y Matsumoto. 2003. Statistical dependency analysis using support vector machines. In Proceedings ofIWPT, Nancy, France, April.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>