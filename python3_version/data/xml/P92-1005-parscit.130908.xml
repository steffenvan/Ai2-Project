<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.466132">
MONOTONIC SEMANTIC INTERPRETATION*
</title>
<author confidence="0.535166">
Hiyan Alshawi and Richard Crouch
</author>
<affiliation confidence="0.4354175">
SRI International
Cambridge Computer Science Research Centre
</affiliation>
<address confidence="0.9693575">
23 Millers Yard
Cambridge CB2 1RQ, U.K.
</address>
<email confidence="0.96017">
hiyan@cam. sri . corn ralcam. sri. corn
</email>
<sectionHeader confidence="0.993552" genericHeader="abstract">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.999945">
Aspects of semantic interpretation, such as quan-
tifier scoping and reference resolution, are often
realised computationally by non-monotonic opera-
tions involving loss of information and destructive
manipulation of semantic representations. The
paper describes how monotonic reference resolu-
tion and scoping can be carried out using a re-
vised Quasi Logical Form (QLF) representation.
Semantics for QLF are presented in which the de-
notations of formulas are extended monotonically
as QLF expressions are resolved.
</bodyText>
<sectionHeader confidence="0.999696" genericHeader="introduction">
1. INTRODUCTION
</sectionHeader>
<bodyText confidence="0.999648045454545">
The monotonicity property of unification based
grammar formalisms is perhaps the most impor-
tant factor in their widespread use for grammatical
description and parsing. Monotonicity guarantees
that the grammatical analysis of a sentence can
proceed incrementally by combining information
from rules and lexical entries in a nondestructive
way. By contrast, aspects of semantic interpreta-
tion, such as reference and quantifier scope reso-
lution, are often realised by non-monotonic opera-
tions involving loss of information and destructive
manipulation of semantic representations. A &apos;two-
level&apos; approach to semantic interpretation tends to
result (Bronneberg et al. 1980), where an initial,
underspecified representation is transformed into
a separate, specified, representation.
The goal of the work described here is to pro-
vide a model for semantic interpretation that is
fully monotonic in both linguistic and contextual
aspects of interpretation, and which employs just
one level of semantic representation — Quasi Log-
ical Form (QLF). Contextual resolution of under-
</bodyText>
<footnote confidence="0.8240565">
* This work on the Core Language Engine was carried
out under CLARE, a collaborative project involving BP
</footnote>
<affiliation confidence="0.88014875">
Research, British Aerospace, British Telecom, Cambridge
University, SRI International and the UK Defence Research
Agency. The project is funded in part by the UK Depart-
ment of Trade and Industry.
</affiliation>
<bodyText confidence="0.9993365">
specified QLF expressions involves the instantia-
tion of QLF meta-variables. The semantics for the
QLF formalism makes the denotation of a QLF
formula a partial function to truth-values, with
resolution leading to a monotonic extension of the
denotation function. We believe that there are
several advantages to the approach taken, includ-
ing:
</bodyText>
<listItem confidence="0.999895">
• Order independence of resolution operations
• Production of partial interpretations
• Simpler interactions between phenomena
• Reversibility for synthesis/generation
</listItem>
<bodyText confidence="0.999942363636364">
The QLF formalism is a development of Alshawi
1990. As before, underspecified QLFs are pro-
duced on the basis of a unification grammar. Pre-
viously, QLF resolution was only partially mono-
tonic; full monotonicity required changes to the
original QLF formalism and the resolution and
scoping processes. These changes have been im-
plemented in a further development of the Core
Language Engine (Alshawi 1992), although we will
ignore most implementation issues in the present
paper.
The paper is organized as follows. Section 2
provides the syntax of the QLF language and Sec-
tion 3 gives some illustrative examples of mono-
tonic QLF resolution. Sections 4 and 5 present the
semantics of the QLF formalism. Section 6 dis-
cusses the relationship between monotonic inter-
pretation, Pereira&apos;s categorial semantics (Pereira
1990), and context change approaches to seman-
tics. Section 7 mentions some benefits of using
QLF-like representations in implementing natural
language systems.
</bodyText>
<sectionHeader confidence="0.999444" genericHeader="method">
2. SYNTAX OF MONOTONIC QLF
</sectionHeader>
<bodyText confidence="0.9980095">
We give here a syntactic description of the QLF
constructs for terms and formulasl.
</bodyText>
<footnote confidence="0.9509805">
1The notation we use in implementations is slightly dif-
ferent but equivalent to that presented here.
</footnote>
<page confidence="0.997427">
32
</page>
<bodyText confidence="0.92293">
A QLF term must be one of the following
</bodyText>
<listItem confidence="0.999757">
• a term variable: X, Y,
• a term index: +i,
• a constant term: 7, maryl,
• an expressions of the form:
</listItem>
<equation confidence="0.534564">
term(Idx,Cat,Restr,Quant,Reft)
</equation>
<bodyText confidence="0.969185916666667">
The term index, Idx, uniquely identifies the term
expression. Cat is a list of feature-value equations,
for example &lt;type=pro ,num=sing , &gt;. Restr is
a first-order, one-place predicate. For a resolved
term, Quant will be a generalized quantifier (a car-
dinality predicate holding of two properties) and
Reft, the term&apos;s &apos;referent&apos;, will be a constant or
term index. For an &apos;unresolved&apos; term, Quant and
Reft may be meta-variables (_x,_y,...). (QLF
terms may also be functional applications, though
we will ignore these here).
A QLF formula must be one of the following
</bodyText>
<listItem confidence="0.910315833333333">
• the application of a predicate to arguments:
Predicate(Argumentl,...,Argumentn)
• an expression of the form:
form(Category,Restriction,Resolution)
• a formula with scoping constraints:
Scope:Formula
</listItem>
<bodyText confidence="0.999649318181818">
Predicate is a first or higher-order predicate, in-
cluding the usual logical operators and, not, etc.
An argument may be a term, a formula or a
lambda abstract. Lambda abstracts take the form
Var.-Body where Body is a formula or an abstract
and Var is a variable ranging over individuals or
relations. Restriction is a higher-order predi-
cate. Resolution is a formula (the &apos;referent&apos; of the
form expression), or is a meta-variable if the form
expression is unresolved. Scope is either a meta-
variable when scoping information is underspeci-
fied or a (possibly empty) list of term indices e.g.
[+i,+j] if term +i outscopes +j. The terms iden-
tified by the indices must occur within Formula.
The degree to which a QLF is unresolved cor-
responds approximately to the extent to which
meta-variables (appearing above as Quant, Ref t,
Scope, and Resolution) are instantiated to
the appropriate kind of object level expressions
(though see Section 5 for an explicit characteri-
zation of unresolved QLFs and partial interpreta-
tions.)
</bodyText>
<sectionHeader confidence="0.995375" genericHeader="method">
3. EXAMPLE QLF RESOLUTIONS
</sectionHeader>
<bodyText confidence="0.983287658536586">
Resolution of QLFs through the instantiation of
meta-variables has been applied to a wide range
of phenomena. These include pronouns, definite
descriptions, implicit or vague relations, ellipsis
and temporal relations (see Alshawi 1990 for an
account of some kinds of reference resolution in
an earlier QLF formalism). For concreteness, we
present a few illustrative examples of monotonic
QLF resolution2. We do not attempt to describe
the mechanism by which the resolutions are cho-
sen.
It will become evident that the notation is closer
to (the syntactic structure of) natural language
than is the case for traditional logical formalisms.
For example, terms usually correspond to noun
phrases, with information about whether e.g. they
are pronominal, quantified or proper names in-
cluded in the term&apos;s category. This makes the
QLF representation easier to read than it might
seem at first, once its initial unfamiliarity is over-
come.
Quantification: Every boy met a tall girl illus-
trates the representation of quantification. The
basic QLF analysis might be (ignoring tense):
_s :meet (term(+b, &lt;type=q,lex=every&gt; ,boy , _q, _x) ,
term(+g,&lt;type=q,lex=a&gt;,
Y&apos;and(girl(Y),tall(Y)),_r,_y)).
A resolved structure could be obtained by instan-
tiating the quantifier meta-variables _q and
to forall and exists3, and the scoping meta-
variable _s to [+b,+,g] for the `V3&apos; reading:
meet(term(+b,&lt;type=q,lex=every&gt;,
boy,forall,+b),
term(+g,&lt;type=q,lex=a&gt;,
Y&apos;and(girl(Y),tall(Y)),exists,+g)).
In a restriction-body notation for generalized
quantifiers, the truth conditional content of this
resolved expression corresponds to
f °ran (B , boy (B) ,
exists (G , and (girl (G) , tall (G))
meet (B ,G)))
</bodyText>
<footnote confidence="0.866648266666667">
Anaphora: Every boy claims he met her illus-
trates the treatment of anaphora (in a context
2Although the QLF framework can support a variety
of alternative semantic analyses for specific phenomena, to
provide concrete illustrations one or other analysis needs to
be chosen. In the following examples, it should be possible
to separate particular analyses from the general points we
wish to make about monotonic interpretation.
3The benefits of being able to resolve determiners to
quantifiers are discussed in Alshawi 1990. For example,
determiners like some (plural) could be resolved to collec-
tive or distributive quantifiers, three could be interpreted as
meaning either &apos;exactly three&apos; or &apos;at least three&apos;, and if need
be, bare plurals like dogs could be variously interpreted as
meaning &apos;some dogs&apos;, &apos;all dogs&apos; or &apos;most dogs&apos;.
</footnote>
<page confidence="0.999315">
33
</page>
<bodyText confidence="0.8039935">
where Mary is assumed to be salientr
Unresolved:
</bodyText>
<equation confidence="0.850614214285714">
_sl :claim(
term(+b,&lt;type=q,lex=every&gt;,boy,_q1,_x),
_s2:meet(term(+h1,&lt;type=pro,lex=he&gt;,
male,_q2,_y),
term(+h2,&lt;type=pro,lex=her&gt;,
female,_q3,_z))).
Resolved:
[4-b] :claim(
term(+b,&lt;type=q,lex=every&gt;,
boy,forall,+b),
[+h1]:meet(term(+h1,&lt;type=pro,lex=he&gt;,
male,exists,+b),
term(+h2,&lt;type=pro,lex=her&gt;,
female,exists,mary))).
</equation>
<bodyText confidence="0.984901760869565">
The pronominal term for her is resolved so that it
existentially quantifies over female objects identi-
cal to mary. The &apos;bound variable&apos; pronoun he has
a referent coindexed with its antecedent, +b. The
scope of +h2 is left unspecified, since exactly the
same truth conditions arise if it is given wide or
narrow scope with respect to every boy or he.
Vague Relations: An unresolved QLF expres-
sion representing the noun phrase a woman on a
bus might be a term containing a form that arises
from the the prepositional phrase modification:
term(+w,&lt;lex=a,..&gt;,
X&amp;quot;and(woman(X),
form(&lt;type=prep,lex=on&gt;,
1111(+w,term(+b,&lt;lex=a,..&gt;,.
bus,_q2,_b)),
-I) ) ,
_q1,_v).
Informally, the form is resolved by applying its re-
striction, RR(. . . ) to an appropriate salient pred-
icate, and instantiating the form&apos;s meta-variable,
_f, with the result. In this case, the appropriate
predicate might be inside, so that _f is instanti-
ated to
inside(+w,term(+b,&lt;lex=a,..›,bus,_q2,_b)).
Tense: One way of treating tense is by means of
a temporal relation form in the restriction of an
event term. For John slept we might have:
_s:sleep(term(+e,&lt;type=event&gt;,
E-form(&lt;type=trel,tense=past&gt;,
11- and( event (E) ,R(E)) ,
_t) ,
_q1,_e),
term(+j,&lt;type=name&gt;,
J-name(J,&apos;John&apos;),_q2,_j)).
4 Here we simplify the issues arising out of the semantics
of intensional, sentential complement verbs like claim.
Since the tense on the temporal relation category
is past, the resolution says that the event occurred
before a particular speech time, t7:
sleep(
term(+e,&lt;type=event&gt;,
E&apos;form(&lt;type=trel,tense=past&gt;,
R-and(event(E),R(E)),
and(event(E),precede(E,t7))),
exists,+e),
</bodyText>
<equation confidence="0.8193505">
term(+j ,&lt;type=name&gt; ,
J-name (J , &apos; John &apos; ) , exists , joluil)) .
</equation>
<bodyText confidence="0.991038840909091">
The resolution and ( event (E) , precede (E , t7) )
is the result of applying the form&apos;s restriction
Vand(event (E),R(E)) to a contextually derived
predicate, in this case E1-precede(E1,t7).
QLF is not committed to an event based treat-
ment of tense. An alternative that has also been
implemented is to treat the verbal predication
sleep( ...) as a temporal form, whose category
specifies tense and aspect information.
Ellipsis: A more complex example, involving el-
lipsis and quantification, is provided by
Each boy claimed he was clever, and so
did John.
A partially resolved QLF, but one in which the
ellipsis is still unresolved, might be as follows (ig-
noring tense and event variables):
and(
claim(term(+b,&lt;lex=every&gt;,
boy,exists,+b),
clever(term(+h,&lt;lex=he&gt;,
male,exists,+b))),
form(&lt;type=vpellipsis&gt;,
P-P(term(th&lt;type=name&gt;,J-name(J,&apos;John&apos;),
exists,john)),
_e)).
This is a conjunction of the QLF for the an-
tecedent clause (Each boy claimed he was clever
under a bound pronoun reading) with a form ex-
pression for the verb phrase ellipsis. Solutions for
instantiating the meta-variable _e for the ellipsis
are the result of applying a property P1, derived
from the antecedent clause, to the term with in-
dex +j. The sentence has two readings: a sloppy
reading where John claims that he is clever, and a
strict one where John claims that each of the boys
is clever. The choice between a strict or sloppy
reading depends on how the term he is reinter-
preted in the ellipsis resolution. Intuitively, strict
identity involves referring to the same object as
before, whereas sloppy identity involves referring
to a relevantly similar object.
In QLF, a strict reading results from re-
interpreting the ellipsis pronoun as co-indexed
with the original, i.e. taking P1 to be:
</bodyText>
<page confidence="0.990913">
34
</page>
<bodyText confidence="0.989282846153846">
X-c1aim(X,clever(+h)).
Constraints on legitimate scoping (Section 5) force
+b and +h to take wide scope over both the an-
tecedent and ellipsis. The sloppy reading results
from re-indexing the ellipsis pronoun so that it has
the same restriction and category as the original,
but is resolved to +j and has a new index +hl.
This corresponds to taking P1 to be:
X-claim(X,clever(term(+hl,&lt;lex=he&gt;,
male,exists,+j))).
More generally, in Crouch and Alshawi 1992 we
explore the claim that solutions to verb phrase el-
lipsis have the general form:
</bodyText>
<equation confidence="0.964909">
P1 = X1-..Xi-S[X1/s1,..,Xi/si,..,tn/sn].
</equation>
<bodyText confidence="0.9897437">
That is, P1 is formed out of an antecedent clause
QLF S by abstracting over the &apos;parallel elements&apos;
s ..si, perhaps with some additional substitu-
tions for terms si+1..sn in S (E[a/b] is the ex-
pression E with a substituted for b). This seems
to be sufficient to cover the range of examples
treated by Dalrymple, Shieber and Pereira (1991),
but that is a specific linguistic claim about verb
phrase ellipsis in English and not central to the
present paper.
</bodyText>
<sectionHeader confidence="0.992571" genericHeader="method">
4. SEMANTICS FOR QLF
</sectionHeader>
<bodyText confidence="0.999982888888889">
In this section we outline the semantics of the QLF
language in a way that is as close as possible to
classical approaches that provide the semantics in
terms of a function from models to truth values.
The main difference is that denotation functions
will be partial functions for some unresolved QLF
formulas, reflecting the intuition that these are
&apos;partial interpretations&apos;. The denotation of a QLF
expression will be extended monotonically as it is
further resolved, a fully resolved formula receiving
a total function as its denotation. The semantics
is not intended to describe the resolution process.
Before giving evaluation rules for the QLF lan-
guage, we first present a simplified version of the
semantics for fully instantiated QLF expressions.
This is for expository purposes only; the full QLF
semantics does not depend on the simplified ver-
sion.
</bodyText>
<subsectionHeader confidence="0.961338">
4.1 SIMPLIFIED SEMANTICS
</subsectionHeader>
<bodyText confidence="0.999486909090909">
We will use the notation [[E]]m for the truth value
of an expression E with respect to a model m (but
will leave m implicit). m includes an interpretation
function / for mapping constants and predicates
into domain individuals and relations. Also left
implicit is a function assigning values to variables,
which is required for the evaluation of lambda ab-
stracts as characteristic functions.
Constructs in the &apos;standard&apos; predicate logic sub-
set of QLF receive their semantics with the usual
evaluation rules, for example:
</bodyText>
<listItem confidence="0.97312625">
• RP(al, ,an)]] = 1 iff I(al) ...I(an) are in
the relation I(P), and 0 otherwise.
• ffand(F1,F2)11 = 1 if [[F1]]=1 and [[F2]]=1,
and 0 otherwise.
</listItem>
<bodyText confidence="0.9290446">
The evaluation rule for a formula F with a scop-
ing variable instantiated to [1,3, .] and con-
taining a term T=term(I,C,R,Q,A) is as follows:
•
[[[1)3,...] :F]]=1 iff [[Q(R&apos; ,F&apos;)]]=1, and 0
otherwise, where
Ft&apos; is X-(and(R(X),X=A))[X/I], and
F&apos; is X&amp;quot;( [3, .. .]:and(F,X=A))[X/T, X/I]
This evaluation rule states that a formula with a
scoping constraint list may be evaluated by &apos;dis-
charging&apos; the term for the first index on the list
with respect to a formula with a reduced scop-
ing constraint. The rule discharges the term by
abstracting over occurrences of the term and its
index, and applying the generalized quantifier Q
to the term&apos;s restriction and the abstract derived
from the formula. In Section 5 we will say more
about the ramifications of adopting this type of
quantifier evaluation rule. Note that this rule is
also applicable to resolved terms such as pronouns
for which Q has been resolved to exists and T is
a constant or a scoped variable.
The denotation assigned to a resolved formula
form(C,R,F&apos;) in which the resolution variable has
been instantiated to a formula F&apos; is simply:
</bodyText>
<listItem confidence="0.8673045">
• aform(C,R,F&apos;)]]=1 if [[r]j=1, and 0 other-
wise.
</listItem>
<subsectionHeader confidence="0.961862">
4.2 QLF SEMANTICS
</subsectionHeader>
<bodyText confidence="0.999976529411765">
As mentioned earlier, the denotation of a formula
F in the QLF language will be a possibly par-
tial function ([[...11) from models to truth values.
Again we use the notation [[F]]m for the truth
value of a formula F with respect to a model in
(explicit reference to a variable assignment func-
tion is again suppressed). For interpretation to be
monotonic, we want [[G] to be an extension of [[F]]
whenever G is a more resolved version of F, and in
particular for [[G]] to be total if G is fully resolved.
We will define [[.. .]] for QLFs in terms of a re-
lation W between formulas, models and truth val-
ues. Evaluation rules will be given for W(F,m,v),
but since more than one rule may apply (or a rule
may apply in more than one way), W will in gen-
eral be a relation. The relationship between [[...]]
and W for a formula F is as follows:
</bodyText>
<page confidence="0.989996">
35
</page>
<listItem confidence="0.999766">
• [[F]]m=1 if W(F,m,l) but not W(F,m,0);
• [[F]] m=0 if W(F,m,0) but not W(F,m,1);
• [[Film undefined if W(F,m,l) and W(F,m,0).
</listItem>
<bodyText confidence="0.999226666666667">
Henceforth we will leave the model argument m
implicit. The evaluation rules for W will generally
take the form
</bodyText>
<equation confidence="0.685862">
W(F,v) if W(F&apos;,v)
</equation>
<bodyText confidence="0.997867681818182">
where F&apos; contains one fewer unresolved expression
than F (so that it is possible for the process of rule
application to terminate). The use of if rather
than Orin these rules means that it is possible for
rules producing more than one value v to apply
and hence for [[F]] to be partial.
The model provides an interpretation function
I mapping constants and predicates to individual
and relations. We will also need to assume a rela-
tion S(C,H) (for &apos;salient&apos;) between QLF categories
C and QLF expressions H standing for individuals,
quantifiers, or predicates, but the precise nature of
the salience relation and the way it changes during
a discourse are not important for the evaluation
rules for QLF given here. The intuitive motiva-
tion for S is that the category in an unresolved
QLF expression restricts the set of possible refer-
ents for that expression. S is discussed further in
Section 5. We are now in position to present the
evaluation rules, which we number Qi, Q2, etc.
For standard connectives we have the obvious
evaluation rules, for example,
</bodyText>
<equation confidence="0.99863625">
Q1 Mand(F,G),1) if W(F,1) and W(G,1).
Q2 Mand(F,G),0) if W(F,O) or W(G,0).
Q3 Mnot(F),1) if W(F,0).
Q4 147(not(F),0) if W(F,1).
</equation>
<bodyText confidence="0.947141333333333">
Two rules applicable to a formula F containing a
term with uninstantiated referent and quantifier
meta-variables:
</bodyText>
<equation confidence="0.4010344">
Q5 W(F,v) if W(F[existsi_q,Ai_r],v) and
W(R(A),1),
where:
F is a formula containing the term
T=term(I ,C,R,_q,_r), and
</equation>
<bodyText confidence="0.5301414">
A is term such that S(C,A).
Q6 W(F,v) if W(F[Q/_q,
where:
F is a formula containing the term
T=term(I,C,R,_q,_r), and
Q is a quantifier such that S(C,Q).
(The substitutions for the meta-variables _r and
_q are to be read as part of the evaluation rule.)
A rule applicable to a formula F in which a (pos-
sibly unscoped) quantified term occurs:
</bodyText>
<figure confidence="0.934444571428572">
Q7 W(F,v) if W(Q(R),F)),v),
where:
F is a formula containing the term
T=term(I,C,R,Q,A),
R.&apos; is X&amp;quot; (and(R(X) ,X=A))[X/I], and
F&apos; is X&amp;quot; (and(F,X=A))[X/T, X/I1.
A rule applicable to a formula with an instantiated
scoping constraint
Q8 W(CI,J, :F,v) if W(Q(R&apos; ,F&apos;),v),
where:
F is a formula containing the term
T=term(I,C,R,Q,A),
R.&apos; is X-(and(R(X),X=A))[X/I], and
F&apos; is X&amp;quot;( EJ, ...] :and(F,X=A))[X/T, X/I].
</figure>
<bodyText confidence="0.854854666666667">
We also need a trivial rule for a formula with an
uninstantiated scoping constraint so that it re-
duces to application of other rules:
</bodyText>
<equation confidence="0.636404">
Q9 W(_s :F,v) if W(F,v).
</equation>
<bodyText confidence="0.990345666666667">
Two rules are applicable to form expressions, cor-
responding to the cases of an uninstantiated or
instantiated resolution meta-variable:
</bodyText>
<equation confidence="0.896848666666667">
Q10 W(F,v) if W(F[R(P)/_r],v)
where:
F is a formula form(C,R,_r)
P is a predicate such that S(C,P).
Q11 147(form(C,R,F0,v) if W(F1,v)
where r is a QLF formula.
</equation>
<bodyText confidence="0.9997665">
In a more complete description of the semantics
we would also have to state that the evaluation
rules provided give the only way of determining
membership of the relation W.
</bodyText>
<listItem confidence="0.784712833333333">
5. NOTES ON THE SEMANTICS
Monotonicity: In this paper we are using
monotonicity in two senses which (by design) turn
out to be consistent. The first is a syntactic no-
tion for QLF representations (instantiation rather
than destructive manipulation), while the second
is semantic:
1. Fl is a more resolved version of F2 if Fl can be
obtained by instantiating zero or more meta-
variables in F2.
2. Fl is a less partial interpretation than F2 if
[[Fl.]] is an extension of [[F2]).
</listItem>
<bodyText confidence="0.98630275">
The claim of monotonicity for QLF is that for for-
mulas Fl and F2, if Fl is a more resolved version
of F2 then Fl is a less partial interpretation than
F2.
</bodyText>
<page confidence="0.996111">
36
</page>
<bodyText confidence="0.997208076923077">
Scoping Constraints: The quantification
rules, (Q7) and (Q8), (i) select a term from a for-
mula, (ii) discharge all occurrences of the term and
its index in the formula and the term&apos;s restriction,
replacing them by a variable, and (iii) apply the
term&apos;s quantifier to the discharged restriction and
formula. The difference between (Q7) and (Q8) is
simply that the latter also discharges the head of
the scoping list, in this case by removing it rather
than by replacing it. (Keep in mind that the dis-
charge and replacement operations take place at
the level of the evaluation rules for QLF; they are
not applied to the QLF expressions representing
natural language meanings themselves).
As with Lewin&apos;s scoping algorithm, (Lewin
1990), there are no constraints built explicitly into
the QLF semantics on where a quantification rule
for a term may be applied, or indeed on the num-
ber of times it may be applied. However, several
constraints arise out of (a) the absence of any se-
mantic rules for evaluating isolated terms, term
indices or scope lists, and (b) the requirement that
a term be selected from a formula so that its quan-
tifier is known.
The emergent conditions on legitimate scoping
are
</bodyText>
<listItem confidence="0.682425821428571">
1. No term may be quantified-in more than once:
The first application of the quantifier rule dis-
charges the term. Subsequent applications of
the rule lower down in the evaluation would
fail to select an undischarged term.
2. When a term&apos;s index occurs in a scope list, the
quantifier rule for the term must be applied
at that point: It must be applied to discharge
the head of the scope list, and by (1) above
cannot additionally be applied anywhere else.
3. All occurrences of a term&apos;s index must oc-
cur within the scope of the application of the
term&apos;s quantifier rule: The quantification rule
will only discharge indices within the formula
to which it is applied. Any occurrences of
the index outside the formula will be undis-
charged, and hence unevaluable.
4. If a term R occurs within the restriction of
a term H, and R is to be given wide scope
over the restriction, then R must also be given
wide scope over H: Otherwise, suppose H is
given wide scope over R. Term H will first be
discharged, replacing the term, and with it its
restriction, in the formula to which the rule
is applied. Then the quantification rule for R
needs to be applied to the discharged formula,
but the formula will not contain an occurrence
of the term R, making the rule inapplicable.
</listItem>
<bodyText confidence="0.995297055555556">
The last two constraints have often been at-
tributed to restrictions on free variables and vacu-
ous quantification. The attribution is problematic
since open formulas and vacuously quantified for-
mulas are both logically well defined, and without
suspect appeal to the syntax of the logical formal-
ism they cannot be ruled out as linguistically ill-
formed. By contrast, QLF makes these violations
semantically unevaluable.
Unscoped Terms: When a term&apos;s index is not
mentioned in any scope list, the term may be
quantified in at any point within the formula. For
anaphoric terms whose referent has been resolved
to some individual constant, it does matter where
the quantification rule is applied; since the term
existentially quantifies over things identical to a
single object, the scope of the quantification is im-
material. It is thus convenient to leave anaphoric
terms like this unscoped in QLF. Although this
makes the QLF look (syntactically) as though it is
not fully resolved, semantically it is. For other un-
scoped terms, alternative applications of the quan-
tifier rule may well lead to distinct truth condi-
tions, and in these cases the QLF is genuinely un-
resolved.
Context Dependence: Fully resolved QLFs
are context-independent in the same sense that
holds for closed formulas in traditional predicate
logic (i.e. if the interpretation of the constant
symbols in the language is fixed). Unresolved
QLFs behave more like open formulas, and there is
an analogy between assignments to unbound vari-
ables in predicate logic and possible resolutions of
meta-variables admitted by the salience relation
S. S(C,H) should be thought of as providing QLF
expressions whose denotations are possible refer-
ents for unresolved expressions with category C.
(It would have been possible to define S as a direct
relation between categories and referents, but this
complicates the statement of its role in resolution
and in the semantic definitions.) We used S above
in the definition of QLF semantics, but it is also
central to NL processing: being able to compute S
can clearly play an important role in the process of
reference resolution during NL interpretation and
in the process of building descriptions during NL
synthesis. (The computational analogue of S was
implemented as a collection of &apos;resolution rules&apos; in
Alshawi 1990.)
An important question is what to allow as possi-
ble expressions in the range of S. One observation
is that as the range is widened, more NL resolu-
tion phenomena are covered. A rough summary is
as follows:
</bodyText>
<listItem confidence="0.967053">
• constants: intersentential pronouns
• predicate constants: compound nouns, prepo-
sitions
</listItem>
<page confidence="0.948025">
37
</page>
<listItem confidence="0.997523333333333">
• quantifiers: vague determiners
• indices: bound variable, intrasentential pro-
nouns
• predicates built from NP restrictions: one-
anaphora
• predicates built from previous QLFs: inter-
sentential ellipsis
• predicates built from current QLF: intrasen-
tential ellipsis
</listItem>
<sectionHeader confidence="0.857619" genericHeader="method">
6. RELATED APPROACHES
</sectionHeader>
<bodyText confidence="0.99995218627451">
Viewed from a slightly different perspective,
monotonic interpretation has a number of points
of contact with Pereira&apos;s categorial semantics
(Pereira 1990). Put briefly, in categorial seman-
tics, semantic evaluation is represented as deduc-
tion in a functional calculus that derives the mean-
ings of sentences from the meanings of their parts.
Considerable emphasis is placed on the nature of
these semantic derivations, as well as on the fi-
nal results of the derivations (the &apos;logical forms&apos;
of sentences).
One significant advantage of this approach is
that constraints on legitimate scoping emerge nat-
urally from a consideration of permissible deriva-
tions of sentence meaning, rather than arising arti-
ficially from syntactic constraints imposed on log-
ical forms. Derivations involving quantified terms
first introduce an assumption that allows one to
derive a simple term from a quantified term. This
assumption is later discharged by the application
of a quantifier. Conditions on the appropriate in-
troduction and discharge of assumptions in natu-
ral deduction systems impose restrictions on the
way that quantifiers may legitimately be applied.
For example, a quantifier assumption may not be
discharged if it depends on further assumptions
that have not themselves been discharged. This
prevents the occurrence of free variables in logical
form, but without appeal to the syntax of logical
form.
The discharge of terms and term indices when
evaluating QLF closely parallels the discharge of
quantifier assumptions in categorial semantics. In-
deed, the terms and the indices are precisely the
assumptions introduced by quantified expressions,
and which need to be discharged. Furthermore,
the different orders in which quantifier assump-
tions may be discharged in categorial derivation
correspond to the choices that the quantifier rules
permit for discharging quantified terms.
Where monotonic interpretation and categorial
semantics part company is on the degree of ex-
plicitness with which semantic derivations are rep-
resented. In categorial semantics, derivation is a
background process that builds up logical forms,
but is not explicitly represented in the semantic
formalism. By contrast, the annotation of QLFs
with scope lists provides an extra level of informa-
tion about how the derivations proceed. In partic-
ular, they indicate which evaluation rules should
be applied where.
QLF thus provides a (usually partial) specifica-
tion of a semantic derivation, showing (a) what the
initial &apos;premises&apos; are (roughly, lexical meanings, al-
though these too may only be partially specified),
and (b) the rules by which the &apos;premises&apos; are com-
bined. QLF resolution amounts to further instan-
tiating this specification. This view of QLF can be
contrasted with Logical Form as it is normally un-
derstood, which represents the results of carrying
out a semantic derivation.
The difference between specifying a derivation
and carrying it out is what makes resolution order
independent in monotonic interpretation. Making
a resolution to QLF only specifies when and how
an expression should be evaluated during seman-
tic derivation; it does not carry out that part of
the derivation. Where no distinction is drawn be-
tween making a resolution and carrying out the
corresponding step of the derivation, the order of
resolution can be important. Thus, for Dalrymple,
Shieber and Pereira (1991), where this distinction
is not drawn, the precise interleaving of scope and
ellipsis resolution determines the interpretation of
the sentence. In QLF, resolutions dictate the order
in which various steps of the derivation are carried
out, but the resolution order does not reflect the
derivation order.
Distinguishing between specifying and perform-
ing a derivation also means that a monotonic
treatment of ellipsis resolution does not need to
resort to higher-order unification. Dalrymple,
Shieber and Pereira use higher-order unification
to &apos;unpick&apos; the composition of constituent mean-
ings obtained in the semantic derivation from the
ellipsis antecedent. Some of these meanings are
then put back together to produce a predicate that
can be applied to the ellipsis arguments. Since
monotonic resolution does not carry out the final
composition of meanings, but merely sets out con-
ditions on how it is to take place, there is no need
to unpick composed meanings and put them back
together again.
It is worth pointing out that monotonic inter-
pretation is compatible with approaches to mean-
ing as a transition between contexts or information
states, and where the order in which transitions
are made is significant (e.g. Veltman 1991). In
such a framework, monotonic interpretation would
amount to making decisions about which transi-
tions to take when, but would not involve putting
those decisions into action. The monotonicity in
</bodyText>
<page confidence="0.996993">
38
</page>
<bodyText confidence="0.99980625">
monotonic interpretation thus refers to the way in
which alternative derivations of sentence meanings
may be chosen, but not to the semantic effects of
those sentence meanings.
</bodyText>
<sectionHeader confidence="0.941572" genericHeader="method">
7. IMPLEMENTATION BENEFITS
</sectionHeader>
<bodyText confidence="0.99344184057971">
A description of the language processing mecha-
nisms to which we have applied the monotonic
semantics model is beyond the scope of this pa-
per. However, we believe that the QLF represen-
tation presented here brings significant advantages
to implementing mechanisms for reference resolu-
tion, scoping, preference and generation.
Reference and Scoping: The order indepen-
dence of resolution operations allows for a variety
of control structures in implementing a resolution
mechanism. We find it convenient to make a bot-
tom up pass through QLFs making reference res-
olutions, followed by a stage of scoping resolution,
and to iterate over this should any of the resolu-
tions introduce further unresolved expressions.
The salience relation S can be implemented as
procedures that search for properties, objects or
indices in context. Scoping proceeds simply by
the non-deterministic instantiation of scoping con-
straints, subject to the restrictions imposed on
evaluable QLFs (Section 5), plus techniques for
ignoring logically equivalent scopings, as for ex-
ample described by Moran (1988).
Preference and Disambiguation: A resolved
QLF preserves all the information in the original
unresolved QLF, and also records the correspon-
dence between resolved and unresolved expres-
sions. This makes it possible to define preference
metrics that can be used for ranking alternative
interpretations independently of the search strate-
gies used to derive them. For example, in the case
of scoping, these metrics can combine information
about how far a quantifier was &apos;raised&apos; with infor-
mation about the surface form of its determiner.
Preference ranking over alternative resolutions fa-
cilitates automatic disambiguation of input. Inter-
active disambiguation can make use of generation
from resolved QLFs for confirmation by a user.
Generation: There is a strong connection be-
tween monotonicity and reversibility in language
processing systems. Monotonicity of unification
means that algorithms such as head-driven gener-
ation (Shieber et a/ 1990) can be applied to gram-
mars developed for analysis. We use a variant
of this algorithm for generating from QLFs, and
the monotonicity of semantic interpretation means
that the grammar used for generating from un-
resolved QLFs (the normal &apos;output&apos; of the gram-
mar) can also be used for generation from resolved
QLFs.
In parallel to the distinction between grammat-
ical analysis (of NL into unresolved QLFs) and
interpretation, we make the distinction between
grammatical synthesis (of NL from QLFs) and de-
scription. Description is the process of deriving
a QLF from which synthesis proceeds by taking
a fact (e.g. a database assertion) as input. We
hope to report on our approach to description else-
where. However, one of the principles of QLF-
based description is that while interpretation in-
stantiates referent fields in underspecified QLFs,
description involves instantiating category and re-
striction fields for QLFs in which referent fields
are already instantiated. The preference metrics
applied to rank alternative interpretations can be
applied equally well to ranking resolved QLFs pro-
duced by a nondeterministic description process,
so there is a sense in which the preference mecha-
nism can also be made reversible.
</bodyText>
<sectionHeader confidence="0.998892" genericHeader="references">
REFERENCES
</sectionHeader>
<reference confidence="0.9995741875">
Alshawi, H. 1990. &amp;quot;Resolving Quasi Logical Forms&amp;quot;.
Computational Linguistics 16:133-144.
Alshawi, H., ed. 1992 (in press). The Core Language
Engine. Cambridge, Massachusetts: The MIT
Press.
Bronneberg, W.J.H.J., H.C. Bunt, S.P.J. Landsber-
gen, R.J.H. Scha, W.J. Schoenmakers and E.P.C.
van Utteren. 1980. &amp;quot;The Question Answering
System PHLIQA1&amp;quot;. In L. Bolc (ed.), Natural
Language Question Answering Systems. Macmil-
lan.
Crouch, R. and H. Alshawi. 1992. &amp;quot;Ellipsis and Dis-
tributivity in Monotonic Interpretation&amp;quot;, Techni-
cal Report, SRI International, Cambridge, UK.
Dalrymple, M., S. M. Shieber, and F. C. N. Pereira.
1991. &amp;quot;Ellipsis and Higher-Order Unification&amp;quot;.
Linguistics and Philosophy, 14:399-452.
Lewin, I. 1990. &amp;quot;A Quantifier Scoping Algorithm with-
out a Free Variable Constraint&amp;quot;, Proceedings of
COLING 1990.
Moran, D. B. 1988. &amp;quot;Quantifier Scoping in the SRI
Core Language Engine&amp;quot;. Proceedings of the 26th
Annual Meeting of the Association for Computa-
tional Linguistics, 33-40.
Pereira, F. C. N. 1990. &amp;quot;Categorial Semantics and
Scoping&amp;quot;, Computational Linguistics 16:1 1-10.
Shieber, S. M., G. van Noord, F. C. N. Pereira, and
R. C. Moore. 1990. &amp;quot;Semantic-Head-Driven Gen-
eration&amp;quot;. Computational Linguistics 16:30-43.
Veltman, F. 1990. &amp;quot;Defaults in Update Semantics&amp;quot;, in
H. Kamp (ed), Conditionals, Defaults and Belief
Revision, DYANA deliverable R2.5.A.
</reference>
<page confidence="0.999529">
39
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.529349">
<title confidence="0.998418">MONOTONIC SEMANTIC INTERPRETATION*</title>
<author confidence="0.996978">Hiyan Alshawi</author>
<author confidence="0.996978">Richard Crouch</author>
<affiliation confidence="0.973615">SRI International Cambridge Computer Science Research Centre</affiliation>
<address confidence="0.991315">23 Millers Yard Cambridge CB2 1RQ, U.K.</address>
<abstract confidence="0.965493384615384">hiyan@cam. sri . corn ralcam. sri. corn ABSTRACT Aspects of semantic interpretation, such as quantifier scoping and reference resolution, are often realised computationally by non-monotonic operations involving loss of information and destructive manipulation of semantic representations. The paper describes how monotonic reference resolution and scoping can be carried out using a revised Quasi Logical Form (QLF) representation. Semantics for QLF are presented in which the denotations of formulas are extended monotonically as QLF expressions are resolved.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>H Alshawi</author>
</authors>
<title>Resolving Quasi Logical Forms&amp;quot;.</title>
<date>1990</date>
<journal>Computational Linguistics</journal>
<pages>16--133</pages>
<contexts>
<context position="2673" citStr="Alshawi 1990" startWordPosition="385" endWordPosition="386">in part by the UK Department of Trade and Industry. specified QLF expressions involves the instantiation of QLF meta-variables. The semantics for the QLF formalism makes the denotation of a QLF formula a partial function to truth-values, with resolution leading to a monotonic extension of the denotation function. We believe that there are several advantages to the approach taken, including: • Order independence of resolution operations • Production of partial interpretations • Simpler interactions between phenomena • Reversibility for synthesis/generation The QLF formalism is a development of Alshawi 1990. As before, underspecified QLFs are produced on the basis of a unification grammar. Previously, QLF resolution was only partially monotonic; full monotonicity required changes to the original QLF formalism and the resolution and scoping processes. These changes have been implemented in a further development of the Core Language Engine (Alshawi 1992), although we will ignore most implementation issues in the present paper. The paper is organized as follows. Section 2 provides the syntax of the QLF language and Section 3 gives some illustrative examples of monotonic QLF resolution. Sections 4 a</context>
<context position="6032" citStr="Alshawi 1990" startWordPosition="914" endWordPosition="915">within Formula. The degree to which a QLF is unresolved corresponds approximately to the extent to which meta-variables (appearing above as Quant, Ref t, Scope, and Resolution) are instantiated to the appropriate kind of object level expressions (though see Section 5 for an explicit characterization of unresolved QLFs and partial interpretations.) 3. EXAMPLE QLF RESOLUTIONS Resolution of QLFs through the instantiation of meta-variables has been applied to a wide range of phenomena. These include pronouns, definite descriptions, implicit or vague relations, ellipsis and temporal relations (see Alshawi 1990 for an account of some kinds of reference resolution in an earlier QLF formalism). For concreteness, we present a few illustrative examples of monotonic QLF resolution2. We do not attempt to describe the mechanism by which the resolutions are chosen. It will become evident that the notation is closer to (the syntactic structure of) natural language than is the case for traditional logical formalisms. For example, terms usually correspond to noun phrases, with information about whether e.g. they are pronominal, quantified or proper names included in the term&apos;s category. This makes the QLF repr</context>
<context position="8003" citStr="Alshawi 1990" startWordPosition="1209" endWordPosition="1210">n corresponds to f °ran (B , boy (B) , exists (G , and (girl (G) , tall (G)) meet (B ,G))) Anaphora: Every boy claims he met her illustrates the treatment of anaphora (in a context 2Although the QLF framework can support a variety of alternative semantic analyses for specific phenomena, to provide concrete illustrations one or other analysis needs to be chosen. In the following examples, it should be possible to separate particular analyses from the general points we wish to make about monotonic interpretation. 3The benefits of being able to resolve determiners to quantifiers are discussed in Alshawi 1990. For example, determiners like some (plural) could be resolved to collective or distributive quantifiers, three could be interpreted as meaning either &apos;exactly three&apos; or &apos;at least three&apos;, and if need be, bare plurals like dogs could be variously interpreted as meaning &apos;some dogs&apos;, &apos;all dogs&apos; or &apos;most dogs&apos;. 33 where Mary is assumed to be salientr Unresolved: _sl :claim( term(+b,&lt;type=q,lex=every&gt;,boy,_q1,_x), _s2:meet(term(+h1,&lt;type=pro,lex=he&gt;, male,_q2,_y), term(+h2,&lt;type=pro,lex=her&gt;, female,_q3,_z))). Resolved: [4-b] :claim( term(+b,&lt;type=q,lex=every&gt;, boy,forall,+b), [+h1]:meet(term(+h1,</context>
<context position="25240" citStr="Alshawi 1990" startWordPosition="4016" endWordPosition="4017">resolved expressions with category C. (It would have been possible to define S as a direct relation between categories and referents, but this complicates the statement of its role in resolution and in the semantic definitions.) We used S above in the definition of QLF semantics, but it is also central to NL processing: being able to compute S can clearly play an important role in the process of reference resolution during NL interpretation and in the process of building descriptions during NL synthesis. (The computational analogue of S was implemented as a collection of &apos;resolution rules&apos; in Alshawi 1990.) An important question is what to allow as possible expressions in the range of S. One observation is that as the range is widened, more NL resolution phenomena are covered. A rough summary is as follows: • constants: intersentential pronouns • predicate constants: compound nouns, prepositions 37 • quantifiers: vague determiners • indices: bound variable, intrasentential pronouns • predicates built from NP restrictions: oneanaphora • predicates built from previous QLFs: intersentential ellipsis • predicates built from current QLF: intrasentential ellipsis 6. RELATED APPROACHES Viewed from a </context>
</contexts>
<marker>Alshawi, 1990</marker>
<rawString>Alshawi, H. 1990. &amp;quot;Resolving Quasi Logical Forms&amp;quot;. Computational Linguistics 16:133-144.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Alshawi</author>
<author>ed</author>
</authors>
<date>1992</date>
<booktitle>The Core Language Engine.</booktitle>
<editor>(in press).</editor>
<publisher>The MIT Press.</publisher>
<location>Cambridge, Massachusetts:</location>
<marker>Alshawi, ed, 1992</marker>
<rawString>Alshawi, H., ed. 1992 (in press). The Core Language Engine. Cambridge, Massachusetts: The MIT Press.</rawString>
</citation>
<citation valid="true">
<title>The Question Answering System PHLIQA1&amp;quot;.</title>
<date>1980</date>
<editor>Bronneberg, W.J.H.J., H.C. Bunt, S.P.J. Landsbergen, R.J.H. Scha, W.J. Schoenmakers and E.P.C. van Utteren.</editor>
<publisher>Macmillan.</publisher>
<marker>1980</marker>
<rawString>Bronneberg, W.J.H.J., H.C. Bunt, S.P.J. Landsbergen, R.J.H. Scha, W.J. Schoenmakers and E.P.C. van Utteren. 1980. &amp;quot;The Question Answering System PHLIQA1&amp;quot;. In L. Bolc (ed.), Natural Language Question Answering Systems. Macmillan.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Crouch</author>
<author>H Alshawi</author>
</authors>
<title>Ellipsis and Distributivity in Monotonic Interpretation&amp;quot;,</title>
<date>1992</date>
<tech>Technical Report,</tech>
<institution>SRI International,</institution>
<location>Cambridge, UK.</location>
<contexts>
<context position="12618" citStr="Crouch and Alshawi 1992" startWordPosition="1880" endWordPosition="1883">ing to a relevantly similar object. In QLF, a strict reading results from reinterpreting the ellipsis pronoun as co-indexed with the original, i.e. taking P1 to be: 34 X-c1aim(X,clever(+h)). Constraints on legitimate scoping (Section 5) force +b and +h to take wide scope over both the antecedent and ellipsis. The sloppy reading results from re-indexing the ellipsis pronoun so that it has the same restriction and category as the original, but is resolved to +j and has a new index +hl. This corresponds to taking P1 to be: X-claim(X,clever(term(+hl,&lt;lex=he&gt;, male,exists,+j))). More generally, in Crouch and Alshawi 1992 we explore the claim that solutions to verb phrase ellipsis have the general form: P1 = X1-..Xi-S[X1/s1,..,Xi/si,..,tn/sn]. That is, P1 is formed out of an antecedent clause QLF S by abstracting over the &apos;parallel elements&apos; s ..si, perhaps with some additional substitutions for terms si+1..sn in S (E[a/b] is the expression E with a substituted for b). This seems to be sufficient to cover the range of examples treated by Dalrymple, Shieber and Pereira (1991), but that is a specific linguistic claim about verb phrase ellipsis in English and not central to the present paper. 4. SEMANTICS FOR QLF</context>
</contexts>
<marker>Crouch, Alshawi, 1992</marker>
<rawString>Crouch, R. and H. Alshawi. 1992. &amp;quot;Ellipsis and Distributivity in Monotonic Interpretation&amp;quot;, Technical Report, SRI International, Cambridge, UK.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Dalrymple</author>
<author>S M Shieber</author>
<author>F C N Pereira</author>
</authors>
<title>Ellipsis and Higher-Order Unification&amp;quot;. Linguistics and Philosophy,</title>
<date>1991</date>
<pages>14--399</pages>
<marker>Dalrymple, Shieber, Pereira, 1991</marker>
<rawString>Dalrymple, M., S. M. Shieber, and F. C. N. Pereira. 1991. &amp;quot;Ellipsis and Higher-Order Unification&amp;quot;. Linguistics and Philosophy, 14:399-452.</rawString>
</citation>
<citation valid="true">
<authors>
<author>I Lewin</author>
</authors>
<title>A Quantifier Scoping Algorithm without a Free Variable Constraint&amp;quot;,</title>
<date>1990</date>
<booktitle>Proceedings of COLING</booktitle>
<contexts>
<context position="21189" citStr="Lewin 1990" startWordPosition="3335" endWordPosition="3336">nces of the term and its index in the formula and the term&apos;s restriction, replacing them by a variable, and (iii) apply the term&apos;s quantifier to the discharged restriction and formula. The difference between (Q7) and (Q8) is simply that the latter also discharges the head of the scoping list, in this case by removing it rather than by replacing it. (Keep in mind that the discharge and replacement operations take place at the level of the evaluation rules for QLF; they are not applied to the QLF expressions representing natural language meanings themselves). As with Lewin&apos;s scoping algorithm, (Lewin 1990), there are no constraints built explicitly into the QLF semantics on where a quantification rule for a term may be applied, or indeed on the number of times it may be applied. However, several constraints arise out of (a) the absence of any semantic rules for evaluating isolated terms, term indices or scope lists, and (b) the requirement that a term be selected from a formula so that its quantifier is known. The emergent conditions on legitimate scoping are 1. No term may be quantified-in more than once: The first application of the quantifier rule discharges the term. Subsequent applications</context>
</contexts>
<marker>Lewin, 1990</marker>
<rawString>Lewin, I. 1990. &amp;quot;A Quantifier Scoping Algorithm without a Free Variable Constraint&amp;quot;, Proceedings of COLING 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D B Moran</author>
</authors>
<title>Quantifier Scoping in the SRI Core Language Engine&amp;quot;.</title>
<date>1988</date>
<booktitle>Proceedings of the 26th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>33--40</pages>
<contexts>
<context position="31916" citStr="Moran (1988)" startWordPosition="5041" endWordPosition="5042"> mechanism. We find it convenient to make a bottom up pass through QLFs making reference resolutions, followed by a stage of scoping resolution, and to iterate over this should any of the resolutions introduce further unresolved expressions. The salience relation S can be implemented as procedures that search for properties, objects or indices in context. Scoping proceeds simply by the non-deterministic instantiation of scoping constraints, subject to the restrictions imposed on evaluable QLFs (Section 5), plus techniques for ignoring logically equivalent scopings, as for example described by Moran (1988). Preference and Disambiguation: A resolved QLF preserves all the information in the original unresolved QLF, and also records the correspondence between resolved and unresolved expressions. This makes it possible to define preference metrics that can be used for ranking alternative interpretations independently of the search strategies used to derive them. For example, in the case of scoping, these metrics can combine information about how far a quantifier was &apos;raised&apos; with information about the surface form of its determiner. Preference ranking over alternative resolutions facilitates automa</context>
</contexts>
<marker>Moran, 1988</marker>
<rawString>Moran, D. B. 1988. &amp;quot;Quantifier Scoping in the SRI Core Language Engine&amp;quot;. Proceedings of the 26th Annual Meeting of the Association for Computational Linguistics, 33-40.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F C N Pereira</author>
</authors>
<title>Categorial Semantics and Scoping&amp;quot;,</title>
<date>1990</date>
<journal>Computational Linguistics</journal>
<volume>16</volume>
<pages>1--10</pages>
<contexts>
<context position="3438" citStr="Pereira 1990" startWordPosition="505" endWordPosition="506">onicity required changes to the original QLF formalism and the resolution and scoping processes. These changes have been implemented in a further development of the Core Language Engine (Alshawi 1992), although we will ignore most implementation issues in the present paper. The paper is organized as follows. Section 2 provides the syntax of the QLF language and Section 3 gives some illustrative examples of monotonic QLF resolution. Sections 4 and 5 present the semantics of the QLF formalism. Section 6 discusses the relationship between monotonic interpretation, Pereira&apos;s categorial semantics (Pereira 1990), and context change approaches to semantics. Section 7 mentions some benefits of using QLF-like representations in implementing natural language systems. 2. SYNTAX OF MONOTONIC QLF We give here a syntactic description of the QLF constructs for terms and formulasl. 1The notation we use in implementations is slightly different but equivalent to that presented here. 32 A QLF term must be one of the following • a term variable: X, Y, • a term index: +i, • a constant term: 7, maryl, • an expressions of the form: term(Idx,Cat,Restr,Quant,Reft) The term index, Idx, uniquely identifies the term expre</context>
<context position="25981" citStr="Pereira 1990" startWordPosition="4127" endWordPosition="4128">ened, more NL resolution phenomena are covered. A rough summary is as follows: • constants: intersentential pronouns • predicate constants: compound nouns, prepositions 37 • quantifiers: vague determiners • indices: bound variable, intrasentential pronouns • predicates built from NP restrictions: oneanaphora • predicates built from previous QLFs: intersentential ellipsis • predicates built from current QLF: intrasentential ellipsis 6. RELATED APPROACHES Viewed from a slightly different perspective, monotonic interpretation has a number of points of contact with Pereira&apos;s categorial semantics (Pereira 1990). Put briefly, in categorial semantics, semantic evaluation is represented as deduction in a functional calculus that derives the meanings of sentences from the meanings of their parts. Considerable emphasis is placed on the nature of these semantic derivations, as well as on the final results of the derivations (the &apos;logical forms&apos; of sentences). One significant advantage of this approach is that constraints on legitimate scoping emerge naturally from a consideration of permissible derivations of sentence meaning, rather than arising artificially from syntactic constraints imposed on logical </context>
</contexts>
<marker>Pereira, 1990</marker>
<rawString>Pereira, F. C. N. 1990. &amp;quot;Categorial Semantics and Scoping&amp;quot;, Computational Linguistics 16:1 1-10.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S M Shieber</author>
<author>G van Noord</author>
<author>F C N Pereira</author>
<author>R C Moore</author>
</authors>
<title>Semantic-Head-Driven Generation&amp;quot;.</title>
<date>1990</date>
<journal>Computational Linguistics</journal>
<pages>16--30</pages>
<marker>Shieber, van Noord, Pereira, Moore, 1990</marker>
<rawString>Shieber, S. M., G. van Noord, F. C. N. Pereira, and R. C. Moore. 1990. &amp;quot;Semantic-Head-Driven Generation&amp;quot;. Computational Linguistics 16:30-43.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Veltman</author>
</authors>
<title>Defaults in Update Semantics&amp;quot;,</title>
<date>1990</date>
<booktitle>in H. Kamp (ed), Conditionals, Defaults and Belief Revision, DYANA deliverable R2.5.A.</booktitle>
<marker>Veltman, 1990</marker>
<rawString>Veltman, F. 1990. &amp;quot;Defaults in Update Semantics&amp;quot;, in H. Kamp (ed), Conditionals, Defaults and Belief Revision, DYANA deliverable R2.5.A.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>