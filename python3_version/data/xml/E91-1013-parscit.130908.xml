<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<note confidence="0.9038922">
AN EXTENDED LR PARSING ALGORITHM
FOR GRAMMARS USING FEATURE-BASED SYNTACTIC CATEGORIES
Tsuneko Nakazawa
Beckman Institute for Advanced Science and Technology
and
</note>
<author confidence="0.618863">
Linguistics Department
</author>
<affiliation confidence="0.949371">
University of Illinois
</affiliation>
<address confidence="0.783872">
4088 FLB, 707 S. Mathews, Urbana, IL 61801, USA
</address>
<email confidence="0.972323">
tsuneko@grice.cogsci.uiuc.cdu
</email>
<sectionHeader confidence="0.987139" genericHeader="abstract">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.99996">
This paper proposes an LR parsing
algorithm modified for grammars with
feature-based categories. The proposed
algorithm does not instantiate categories
during preprocessing of a grammar as
proposed elsewhere. As a result, it
constructs a minimal size of GOTO/ACI1ON
table and eliminates the necessity of search
for GOTO table entries during parsing.
</bodyText>
<sectionHeader confidence="0.998426" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.998987709677419">
The LR method is known w be a very
efficient parsing algorithm that involves no
searching or backtracking. However, recent
formalisms for syntactic analyses of natural
language make maximal use of complex
feature-value systems, rather than atomic
categories that have been presupposed in the
LR method. This paper is an attempt to
incorporate feature-based categories into
Tomita&apos;s extended LR parsing algorithm
(Tom ta 1986).
A straightforward adaptation of feature-
based categories into the algorithm introduces
the necessity of partial instantiation of
categories during preprocessing of a grammar
as well as a nontermination problem.
Furthermore, the parser is forced to search
through instantiated categories for desired
GOTO table entries during parsing. The
major innovations of the proposed algorithm
include the construction of a minimal size of
GOTO table that does not require any
preliminary instantiation of categories or a
search for them, and a reduce action which
performs instantiation during parsing.
Some details of the LR parsing algorithm
are assumed from Aho and Ullman (1987)
and Aho and Johnson (1974), and more
formal definitions and notations of a feature-
based grammar formalism from Pollard and
Sag (1987) and Shieber (1986).
</bodyText>
<sectionHeader confidence="0.980975" genericHeader="introduction">
2 The LR Parsing Algorithm
</sectionHeader>
<bodyText confidence="0.990323390243902">
The LR parser is an efficient shift-reduce
parser with optional lookahead. Parse trees
for input strings are built bottom-up, while
predictions are made top-down prior to
parsing. The ACTION/GOTO table is
constructed during preprocessing of a
grammar and deterministically guides the
parser at each step during parsing. The
ACTION table determines whether the parser
should take a shift or a reduce action next.
The GOTO table determines the state the
parser should be in after each action.
Henceforth, entries for the ACTION/
GOTO table are referred to as the values of
functions, ACTION and GOTO. The
ACTION function takes a current state and an
input string to return a next action, and
GOTO takes a previous state and a syntactic
category to return a next state.
States of the LR parser are sets of dotted
productions called items. The state, i.e.
dotted productions, stored on top of the stack
is called current state and the dot positions on
the right hand side (rhs) of the productions
indicate how much of the rhs the parser has
found. Previous states are stored in the stack
until the entire rhs, or the left hand side (lhs),
of a production is found, at which time a
reduce action pops previous states and
pushes a new state in, i.e. the set of items
- 69 -
with a new dot position to the right, reflecting
the discovery of the his of the production.
If a grammar contains two productions
NP and NP—,Det N, for example, then
the state si in Fig.1(i) (the state numbers are
arbitrary) should contain the items &lt;VP—)V
NP&gt; and &lt;NP—).Det N&gt; among others, after
shifting an input string &amp;quot;saw&amp;quot; onto the stack.
The latter item predicts strings that may
follow in a top-down manner.
</bodyText>
<equation confidence="0.390393">
(i) (ii) (iii)
</equation>
<figureCaption confidence="0.993593">
Figure 1. Stacks
</figureCaption>
<bodyText confidence="0.999964176470588">
After two more strings are shifted, say &amp;quot;a
dog&amp;quot;, and the parser encounters the end-of-a-
sentence symbol &amp;quot;$&amp;quot; (Fig.1(ii)), the next
action, ACTION(s4,$), should be &amp;quot;reduce by
NP--)Det N&amp;quot;. The reduce action pops two
states off the stack, and builds a constituent
whose root is NP (Fig.] (iii)). At this point,
GOTO(s1,NP) should be a next state that
includes the item &lt;vP—A/ NP
The ACTION/GOTO table used in the
above example can be constructed using the
procedures given in Fig.2 (adapted from Aho
and Ullman (1987)). The procedure
CLOSURE computes all items in each state,
and the procedure NEXT-S, given a state and
a syntactic category, calculates the next state
the parser should be in.
</bodyText>
<equation confidence="0.676495352941176">
procedure CLOSURE(I);
begin
repeat
for each item &lt;A--4w.Bx&gt; in I, and each
production B-4y such that &lt;13-4.y&gt; is not
in I do
add &lt;B--).y&gt;to I;
unt it no more items can be added to I;
return I
end;
procedure NEXT-S(I,B)
;for each category B in grammar
begin
let J be the set of items &lt;A--)wB.x&gt;
such that &lt;A--,w.Bx&gt; is in I;
return CLOSURE(J)
end;
</equation>
<figureCaption confidence="0.8861495">
Figure 2. CLOSURE/NEXT-S Procedures
for Atomic Categories
</figureCaption>
<bodyText confidence="0.999934916666667">
It should be clear from the preceding
example that upon the completion of all the
constituents on the rhs of a production, the
GOTO table entry for the lhs is consulted.
Whether a category appears on the lhs or the
rhs of productions is a trivial question,
however, since in a grammar with atomic
categories, every category that appears on the
lhs also appears on the rhs and vice versa.
On the other hand, in a grammar with feature-
based categories, as proposed by most recent
syntactic theories, it is no longer the case.
</bodyText>
<sectionHeader confidence="0.787890666666667" genericHeader="method">
3 Construction of the GOTO Table
for Feature-Based Categories:
A Preliminary Modification
</sectionHeader>
<bodyText confidence="0.8971048">
Fig.3 is an example production using
feature-based syntactic categories. The
notations are adapted from Pollard and Sag
(1987) and Shieber (1986). The tags
roughly correspond to variables of
logic unification with a scope of single
productions: if one occurrence of a particular
tag is instantiated as a result of unification, so
are other occurrences of the same tag within
the production.
</bodyText>
<figure confidence="0.987876285714286">
CAT V
SUBCAT
TENSE
&apos;CAT V
SUBCAT [FIRST EINP
REST
_TENSE
</figure>
<figureCaption confidence="0.99281">
Figure 3. Example Production
</figureCaption>
<figure confidence="0.981010866666667">
NP(det(a)N(dog)) I
s
V(saw)
sl
V(saw)
s4
N(do)
s13
Det(a)
SI
V(saw)
NP
- 70 -
Recursive applications of the production &amp;quot;gave boys trees&amp;quot; in Fig.4. The assumed
assigns the constituent structure to strings lexical category for &amp;quot;gave&amp;quot; is given in Fig.5.
</figure>
<figureCaption confidence="0.980687">
Figure 4. Example Parse Tree
</figureCaption>
<figure confidence="0.998639548387097">
FST
Sc
RST E
ci
NP
[ FST NP11
RST NIL
RST
—TNS EPAST
boys toys
NP
[ FST NP j]]
RST NIL
Ii
El
NP
NP
I
s c •[RITNNIPL1]
TNS OPAST
SC
[ FST
RST
_TNS OPAST
ci
V
Sc[ RST [ ss NN PL
[FST NP
— FS T NP
V RST
—TNS PAST
</figure>
<figureCaption confidence="0.999854">
Figure 5. Lexical Categ,ory for &amp;quot;gave&amp;quot;
</figureCaption>
<bodyText confidence="0.999944">
In grammars that use feature-based
syntactic categories, categories in productions
are taken to be underspecified: that is, they
are further instantiated through the unification
operation during parsing as constituent
structures are built. The pretenninal category
for &amp;quot;gave&amp;quot; in Fig.4 is the result of unification
between the lexical category for &amp;quot;gave&amp;quot; in
Fig.5 and the first category on the rhs of the
production in Fig.3. This unification also
results in the instantiation of the lhs through
the tags. The category for the constituent
&amp;quot;gave boys&amp;quot; is Obtained by unifying the
instantiated lhs and the first category of the
rhs of the same production in Fig.3. In order
to accommodate the instantiation of
underspecified categories, the CLOSURE
and NEXT-S procedures in Fig.2 can be
modified as in Fig.6, where A is the
unification operator.
</bodyText>
<sectionHeader confidence="0.481084" genericHeader="method">
procedure CLOSURE(I);
begin
repeat
</sectionHeader>
<bodyText confidence="0.9982754">
for each item &lt;A--)w.Bx&gt; in I, and each
production C--)y such that C is unifiable
with B and &lt;CAB-4.y5 is not in I do
add &lt;CAB-4.y5 to I;
until no more items can be added to I;
</bodyText>
<sectionHeader confidence="0.4653015" genericHeader="method">
return I
end;
</sectionHeader>
<listItem confidence="0.555436">
•
</listItem>
<subsectionHeader confidence="0.600185">
Procedure NEXT-S(I,C)
</subsectionHeader>
<bodyText confidence="0.981747">
; for each category C that appears to the right
; of the dot in items
</bodyText>
<equation confidence="0.650958166666667">
begin
let J be the set of items &lt;A--)wB.x&gt; such
that &lt;A---)w.Bx&gt; is in I and B is unifiable
with C;
return CLOSURE(J)
end;
</equation>
<figureCaption confidence="0.887007">
Figure 6. Preliminary CLOSURE/NEXT-S
Procedures
</figureCaption>
<bodyText confidence="0.9751284">
The preliminary CLOSURE procedure
unifies the lhs of a predicted production, i.e.
- 71 -
C--)y, and the category the prediction is made
from, i.e. B. This approach is essentially
top-down propagation of instantiated features
and well documented by Shieber (1985) in
the context of Earley&apos;s algorithm. A new
item added to the state, &lt;CAB-4. y5, is not
the production C--)y, but its (partial)
instantiation. y is also instantiated to be y&apos; as
a result of the unification CAB if C and some
members of y share tags. Thus, given the
production in Fig.3 and a syntactic category
v [sc NIL] to make predictions from, for
example, the preliminary CLOSURE
procedure creates new items in Fig.7 among
others. The items in Fig.7 are all different
instantiations of the same production in
Fi g .3.
</bodyText>
<figure confidence="0.918438333333333">
FST NP 1
RST NIL]]
[FST 2 N P
. V SC
ti
m[FST NP1
RSTL]RST NIL.] NP&gt;
_TNS [3]
_TNS
</figure>
<figureCaption confidence="0.988176">
Figure 7. Items Created from the Same
Production in Figure 3
</figureCaption>
<bodyText confidence="0.999402214285714">
As can be seen in Fig.7, the procedure
will add an infinite number of different
instantiations of the same production to the
state. The list of items in Fig.7 is not
complete: each execution of the repeat-loop
adds a new item from which a new prediction
is made during the next execution. That is,
instantiation of productions introduces the
nontermination problem of left-recursive
productions to the procedure, as well as to
the Predictor Step of Earley&apos;s algorithm. To
overcome this problem, Shieber (1985)
proposes &amp;quot;restrictor&amp;quot;, which specifies a
maximum depth of feature-based categories.
When the depth of a category in a predicted
item exceeds the limit imposed by a restrictor,
further instantiation of the category in new
items is prohibited. The Predictor Step
eventually halts when it starts creating a new
item whose feature specification within the
depth allowed by the restrictor is identical to,
or subsumed by, a previous one.
In addition to the halting problem, the
incorporation of feature-based syntactic
categories to grammars poses a new problem
unique to the LR parser. After the parser
assigns a constituent structure in Fig.4 during
parsing, it would consult the GOTO table for
the next state with the root category of the
constituent, i.e. v [Sc [FST NP, RST NIL],
TNS PAST]. There is no entry in the table
under the root category, however, since the
category is distinct from any categories that
appear in the items partially intstantiated by
the CLOSURE procedure.
The problem sterns from the fact that the
categories which are partially instantiated by
the preliminary CLOSURE procedure and
consequently constitute the domain of the
GOTO function may be still underspecified as
compared with those that arise during
parsing. The feature specification
[TNS PAST] in the constituent structure in
Fig.4, for example, originates from the
lexical specification of &amp;quot;gave&amp;quot; in Fig.5, and
not from productions, and therefore does not
appear in any items in Fig.7. Note that it is
possible to create an item with the particular
feature instantiated, but there are a potentially
infinite number of instantiations for each
underspecified category.
Given the preliminary CLOSURE/
NEXT-S procedures, the parser would have
to search in the domain of the GOTO function
for a category that is unifiable with the root of
a constituent in order to obtain the next state,
</bodyText>
<figure confidence="0.869139071428572">
&lt;V sc E
TNS
NIL]
SC
_TNSJ.
. V RST I NIL E.
[ FST
NP&gt;
&lt;V Sc II
TNS 3
_TNS ft
_
FS1ft
NP
RST 1-11
RST [ FST NP1]
RST NIL
Sc
.v
NP
[ FST
NP&gt;
&lt;V
Sc
[ FST NP
[
RST RST NIL
FST NP1
</figure>
<bodyText confidence="0.950697135135135">
while a search operation is never required by
the original LR parsing algorithm.
Furthermore, there may be more than one
such category in the domain, giving rise to
nondeterminism to the algorithm.
4 Construction of the GOTO Table
for Feature-Based Categories:
A Final Modification
The final version of CLOSUREJNEXT-S
procedures in Fig.8 circumvents the
described problems. While the CLOSURE
procedure makes top-down predictions in the
same way as before, new items are added
without instantiation. Since only original
productions in a grammar appear as items,
productions are added as new items only
once and the nontermination problem does
not occur, as is the case of the LR parsing
algorithm with atomic categories. The
NEXT-S procedure constructs next states for
the lhs category of each production, rather
than the categories to the right of a dot.
Consequently, from the Ihs category of the
production used for a reduce action, the
parser can uniquely determine the GOTO
table entry for a next state, while constructing
a constituent structure by instantiating it. No
search for unifiable categories is involved
during parsing.
procedure CLOSURE(I);
begin
repeat
for each item &lt;A--)w.Bx&gt; in 1, and each
production C--)y such that C is unifiable
with B and &lt;C—).y&gt; is not in I do
add &lt;C---).y&gt; to I;
until no more items can be added to I;
</bodyText>
<equation confidence="0.6055237">
return 1
end;
procedure NEXT-S(I,C)
;for each category C on the lbs of productions
begin
let .1 be the set of items &lt;A--)wB.x&gt; such
that &lt;A--)w.Bx&gt; is in I and B is unifiable
with C;
return CLOSURE(J)
end;
</equation>
<figureCaption confidence="0.981196">
Figure 8, Final CLOSURE/NEXT-S
Procedures
</figureCaption>
<bodyText confidence="0.999944">
Note, furthermore, the size of GOTO
table produced by the final
CLOSURE/NEXT-S procedures is usually
smaller than the table produced by the
preliminary procedures for the same
grammar. It is because the preliminary
CLOSURE procedure creates one or more
instantiations out of a single category, each of
which the preliminary NEXT-S procedure
applies to, creating separate GOTO table
entries. Although a smaller GOTO table does
not necessarily imply less parsing time, since
there are entry retrieval algorithms that do not
depend on a table size, it does mean fewer
operations to construct such tables during
preprocessing.
</bodyText>
<sectionHeader confidence="0.996075" genericHeader="method">
5: Further Comparisons and
Conclusion
</sectionHeader>
<bodyText confidence="0.9500506">
The LR parsing algorithm for grammars
with atomic categories involves no category
matching during parsing. In Fig.1,
categories are pushed onto the stack only for
the purpose of constructing a parse tree, and
reduce actions are completely independent of
categories in the stack. In parsing with
feature-based categories, on the other hand,
the parser must perform unification
operations between the roots of constituents
and categories on the rhs of productions
during a reduce action. In addition to error
entries in the ACTION table, unification
failure should result in an en-or also. Since
categories cannot be completely instantiated
in every possible way during preprocessing,
unification operations during parsing cannot
be eliminated.
: What motivates partial instantiation of
productions during preprocessing as is done
by the preliminary CLOSURE procedure,
then? It can sometimes prevent wrong items
from being predicted and consequently
incorrect reduce actions from entering into an
ACTION table. Given a grammar that
consists of four productions in Fig.9, the
final CLOSURE procedure with an item
&lt;s—,. TIP a]&gt; in an input state will add items
&lt;T[F T[F[F ]] T[F[F b]]&gt;,
&lt;T[F[F a]]—). a&gt; and &lt;T[F[F b]]-4. b&gt; to the
state. After shift and reduce actions are
repeated twice, each to construct the
constituent in Fig.10(i), the ACTION table
will direct the parser to &amp;quot;reduce by p2&amp;quot; to
a
- 73 -
construct T[F Et)] (Fig.10(ii)), and then to
&amp;quot;reduce by pl&amp;quot;, at which time a unification
failure occurs, detecting an error only after all
these operations.
</bodyText>
<reference confidence="0.84432625">
p1: S---)T[F a)
p2: T[F fl ]--)T[F[F ]) T[F [F b])
p3: T[F[F a)]--)a
p4: T[F[F b])—)b
</reference>
<figureCaption confidence="0.998454">
Figure 9. Toy Grammar
</figureCaption>
<figure confidence="0.990143">
T[F Mb]
T[F[F b]] &apos;r[F[17 b]] T[F[F 13]) T[F[F b]]
bI
(i)
</figure>
<figureCaption confidence="0.999004">
Figure 10. Partial Parse Trees
</figureCaption>
<bodyText confidence="0.995387254237289">
On the other hand, the preliminary
CLOSURE procedure with some restrictor
will add partially instantiated items
&lt;T[F E T[F[F flail T[F[F b]1&gt; and
&lt;T[F[F a]]-4. a&gt;, but not &lt;T[F[F b]]-4. b&gt;.
From an error entry of the ACTION table, the
parser would detect an error as soon as the
first input string b is shifted.
Given the grammar in Fig.9, the
preliminary CLOSURE/NEXT-S procedures
outperform the final version. All grammars
that solicit this performance difference in
error detection have one property in common.
That is, in those grammars, some feature
specifications in productions which .assign
upper structures of a parse tree prohibit
particular feature instantiations in lower
structures. In the case of the above example,
the [F a] feature specification in pl prohibits
the first category on the rhs of p2 from being
instantiated as THF NJ. If the grammar
were modified to replace pl with pr:
for example, then the preliminary
CLOSURE/NEXT-S procedures will have
nothing to contribute for early detection of
errors, but rather create a larger GOTO/
ACTION table through which otherwise
unmotivated search must be conducted for
unifiable categories to find GOTO table
entries after every reduce action. (With a
restrictor [cAT][F[H], the size of ACTION/
GOTO table produced by the preliminary
procedures is 11(states)x9(categories) with a
total of 52 items, while that by the final
procedures is 8x7 with 38 items.)
The final output of the parser, whether
constructed by the preliminary or the final
procedures, is identical and correct. The
choice between two approaches depends
upon particular grammars and is an empirical
question. In general, however, a clear
tendency among grammars written in recent
linguistic theories is that productions tend to
be more general and permissive and lexical
specifications more specific and restrictive.
That is, information that regulates possible
configurations of parse trees for particular
input strings comes from the bottom of trees,
and not from the top, making top-down
instantiation useless.
With the recent linguistic trend of lexicon-
oriented grammars, partial instantiation of
categories while making predictions top-
down gives little to gain for added costs.
Given that run-time instantiation of
productions is unavoidable to build
constituents and to detect errors, the
advantages of eliminating an intei&apos;mediate
instantiation step should be evident.
</bodyText>
<sectionHeader confidence="0.995971" genericHeader="references">
REFERENCES
</sectionHeader>
<reference confidence="0.982955">
Aho, Alfred V. and Jeffrey D. Ullman
1987. Principles of Compiler Design.
Addison-Wesley Publishing Company.
Aho, Alfred V. and S. C. Johnson 1974.
&amp;quot;LR Parsing&amp;quot; Computing Surveys Vol.6
No.2.
Pollard, Carl and Ivan A. Sag 1987.
Information-Based Syntax and Semantics
Vol.l. CSLI Lecture Notes 13. Stanford:
CSLI.
Shieber, S. 1985. &amp;quot;Using Restriction to
Extend Parsing Algorithms for Complex-
Feature-Based Formalisms&amp;quot; 23rd ACL
Proceedings.
Shieber, S. 1986. An Introduction to
Unification-Based Approaches to Grammar.
CSLI Lecture Notes 4. Stanford: CSLI.
Tomita, Masaru 1986. Efficient Parsing
for Natural Language: A Fast Algorithm for
Practical Systems. Boston: Kluwer
Academic Publishers.
- 74 -
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.897069">
<title confidence="0.998257">AN EXTENDED LR PARSING ALGORITHM FOR GRAMMARS USING FEATURE-BASED SYNTACTIC CATEGORIES</title>
<author confidence="0.964527">Tsuneko Nakazawa</author>
<affiliation confidence="0.98962975">Beckman Institute for Advanced Science and Technology and Linguistics Department University of Illinois</affiliation>
<address confidence="0.999585">4088 FLB, 707 S. Mathews, Urbana, IL 61801, USA</address>
<email confidence="0.997723">tsuneko@grice.cogsci.uiuc.cdu</email>
<abstract confidence="0.9957787">This paper proposes an LR parsing algorithm modified for grammars with feature-based categories. The proposed algorithm does not instantiate categories during preprocessing of a grammar as proposed elsewhere. As a result, it a minimal size of table and eliminates the necessity of search for GOTO table entries during parsing.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<booktitle>p1: S---)T[F a) p2: T[F fl ]--)T[F[F ]) T[F [F b]) p3: T[F[F a)]--)a p4: T[F[F b])—)b</booktitle>
<marker></marker>
<rawString>p1: S---)T[F a) p2: T[F fl ]--)T[F[F ]) T[F [F b]) p3: T[F[F a)]--)a p4: T[F[F b])—)b</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alfred V Aho</author>
<author>Jeffrey D Ullman</author>
</authors>
<date>1987</date>
<booktitle>Principles of Compiler Design.</booktitle>
<publisher>Addison-Wesley Publishing Company.</publisher>
<contexts>
<context position="1757" citStr="Aho and Ullman (1987)" startWordPosition="250" endWordPosition="253">gories into the algorithm introduces the necessity of partial instantiation of categories during preprocessing of a grammar as well as a nontermination problem. Furthermore, the parser is forced to search through instantiated categories for desired GOTO table entries during parsing. The major innovations of the proposed algorithm include the construction of a minimal size of GOTO table that does not require any preliminary instantiation of categories or a search for them, and a reduce action which performs instantiation during parsing. Some details of the LR parsing algorithm are assumed from Aho and Ullman (1987) and Aho and Johnson (1974), and more formal definitions and notations of a featurebased grammar formalism from Pollard and Sag (1987) and Shieber (1986). 2 The LR Parsing Algorithm The LR parser is an efficient shift-reduce parser with optional lookahead. Parse trees for input strings are built bottom-up, while predictions are made top-down prior to parsing. The ACTION/GOTO table is constructed during preprocessing of a grammar and deterministically guides the parser at each step during parsing. The ACTION table determines whether the parser should take a shift or a reduce action next. The GO</context>
<context position="4168" citStr="Aho and Ullman (1987)" startWordPosition="665" endWordPosition="668">tack. The latter item predicts strings that may follow in a top-down manner. (i) (ii) (iii) Figure 1. Stacks After two more strings are shifted, say &amp;quot;a dog&amp;quot;, and the parser encounters the end-of-asentence symbol &amp;quot;$&amp;quot; (Fig.1(ii)), the next action, ACTION(s4,$), should be &amp;quot;reduce by NP--)Det N&amp;quot;. The reduce action pops two states off the stack, and builds a constituent whose root is NP (Fig.] (iii)). At this point, GOTO(s1,NP) should be a next state that includes the item &lt;vP—A/ NP The ACTION/GOTO table used in the above example can be constructed using the procedures given in Fig.2 (adapted from Aho and Ullman (1987)). The procedure CLOSURE computes all items in each state, and the procedure NEXT-S, given a state and a syntactic category, calculates the next state the parser should be in. procedure CLOSURE(I); begin repeat for each item &lt;A--4w.Bx&gt; in I, and each production B-4y such that &lt;13-4.y&gt; is not in I do add &lt;B--).y&gt;to I; unt it no more items can be added to I; return I end; procedure NEXT-S(I,B) ;for each category B in grammar begin let J be the set of items &lt;A--)wB.x&gt; such that &lt;A--,w.Bx&gt; is in I; return CLOSURE(J) end; Figure 2. CLOSURE/NEXT-S Procedures for Atomic Categories It should be clear </context>
</contexts>
<marker>Aho, Ullman, 1987</marker>
<rawString>Aho, Alfred V. and Jeffrey D. Ullman 1987. Principles of Compiler Design. Addison-Wesley Publishing Company.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alfred V Aho</author>
<author>S C Johnson</author>
</authors>
<title>LR Parsing&amp;quot; Computing Surveys Vol.6 No.2.</title>
<date>1974</date>
<contexts>
<context position="1784" citStr="Aho and Johnson (1974)" startWordPosition="255" endWordPosition="258">introduces the necessity of partial instantiation of categories during preprocessing of a grammar as well as a nontermination problem. Furthermore, the parser is forced to search through instantiated categories for desired GOTO table entries during parsing. The major innovations of the proposed algorithm include the construction of a minimal size of GOTO table that does not require any preliminary instantiation of categories or a search for them, and a reduce action which performs instantiation during parsing. Some details of the LR parsing algorithm are assumed from Aho and Ullman (1987) and Aho and Johnson (1974), and more formal definitions and notations of a featurebased grammar formalism from Pollard and Sag (1987) and Shieber (1986). 2 The LR Parsing Algorithm The LR parser is an efficient shift-reduce parser with optional lookahead. Parse trees for input strings are built bottom-up, while predictions are made top-down prior to parsing. The ACTION/GOTO table is constructed during preprocessing of a grammar and deterministically guides the parser at each step during parsing. The ACTION table determines whether the parser should take a shift or a reduce action next. The GOTO table determines the sta</context>
</contexts>
<marker>Aho, Johnson, 1974</marker>
<rawString>Aho, Alfred V. and S. C. Johnson 1974. &amp;quot;LR Parsing&amp;quot; Computing Surveys Vol.6 No.2.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Carl Pollard</author>
<author>Ivan A Sag</author>
</authors>
<title>Information-Based Syntax and Semantics Vol.l.</title>
<date>1987</date>
<booktitle>CSLI Lecture Notes 13.</booktitle>
<publisher>CSLI.</publisher>
<location>Stanford:</location>
<contexts>
<context position="1891" citStr="Pollard and Sag (1987)" startWordPosition="272" endWordPosition="275">s a nontermination problem. Furthermore, the parser is forced to search through instantiated categories for desired GOTO table entries during parsing. The major innovations of the proposed algorithm include the construction of a minimal size of GOTO table that does not require any preliminary instantiation of categories or a search for them, and a reduce action which performs instantiation during parsing. Some details of the LR parsing algorithm are assumed from Aho and Ullman (1987) and Aho and Johnson (1974), and more formal definitions and notations of a featurebased grammar formalism from Pollard and Sag (1987) and Shieber (1986). 2 The LR Parsing Algorithm The LR parser is an efficient shift-reduce parser with optional lookahead. Parse trees for input strings are built bottom-up, while predictions are made top-down prior to parsing. The ACTION/GOTO table is constructed during preprocessing of a grammar and deterministically guides the parser at each step during parsing. The ACTION table determines whether the parser should take a shift or a reduce action next. The GOTO table determines the state the parser should be in after each action. Henceforth, entries for the ACTION/ GOTO table are referred t</context>
<context position="5488" citStr="Pollard and Sag (1987)" startWordPosition="889" endWordPosition="892">tion, the GOTO table entry for the lhs is consulted. Whether a category appears on the lhs or the rhs of productions is a trivial question, however, since in a grammar with atomic categories, every category that appears on the lhs also appears on the rhs and vice versa. On the other hand, in a grammar with featurebased categories, as proposed by most recent syntactic theories, it is no longer the case. 3 Construction of the GOTO Table for Feature-Based Categories: A Preliminary Modification Fig.3 is an example production using feature-based syntactic categories. The notations are adapted from Pollard and Sag (1987) and Shieber (1986). The tags roughly correspond to variables of logic unification with a scope of single productions: if one occurrence of a particular tag is instantiated as a result of unification, so are other occurrences of the same tag within the production. CAT V SUBCAT TENSE &apos;CAT V SUBCAT [FIRST EINP REST _TENSE Figure 3. Example Production NP(det(a)N(dog)) I s V(saw) sl V(saw) s4 N(do) s13 Det(a) SI V(saw) NP - 70 - Recursive applications of the production &amp;quot;gave boys trees&amp;quot; in Fig.4. The assumed assigns the constituent structure to strings lexical category for &amp;quot;gave&amp;quot; is given in Fig.5</context>
</contexts>
<marker>Pollard, Sag, 1987</marker>
<rawString>Pollard, Carl and Ivan A. Sag 1987. Information-Based Syntax and Semantics Vol.l. CSLI Lecture Notes 13. Stanford: CSLI.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Shieber</author>
</authors>
<title>Using Restriction to Extend Parsing Algorithms for ComplexFeature-Based Formalisms&amp;quot; 23rd ACL Proceedings.</title>
<date>1985</date>
<contexts>
<context position="7964" citStr="Shieber (1985)" startWordPosition="1324" endWordPosition="1325">s not in I do add &lt;CAB-4.y5 to I; until no more items can be added to I; return I end; • Procedure NEXT-S(I,C) ; for each category C that appears to the right ; of the dot in items begin let J be the set of items &lt;A--)wB.x&gt; such that &lt;A---)w.Bx&gt; is in I and B is unifiable with C; return CLOSURE(J) end; Figure 6. Preliminary CLOSURE/NEXT-S Procedures The preliminary CLOSURE procedure unifies the lhs of a predicted production, i.e. - 71 - C--)y, and the category the prediction is made from, i.e. B. This approach is essentially top-down propagation of instantiated features and well documented by Shieber (1985) in the context of Earley&apos;s algorithm. A new item added to the state, &lt;CAB-4. y5, is not the production C--)y, but its (partial) instantiation. y is also instantiated to be y&apos; as a result of the unification CAB if C and some members of y share tags. Thus, given the production in Fig.3 and a syntactic category v [sc NIL] to make predictions from, for example, the preliminary CLOSURE procedure creates new items in Fig.7 among others. The items in Fig.7 are all different instantiations of the same production in Fi g .3. FST NP 1 RST NIL]] [FST 2 N P . V SC ti m[FST NP1 RSTL]RST NIL.] NP&gt; _TNS [3]</context>
</contexts>
<marker>Shieber, 1985</marker>
<rawString>Shieber, S. 1985. &amp;quot;Using Restriction to Extend Parsing Algorithms for ComplexFeature-Based Formalisms&amp;quot; 23rd ACL Proceedings.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Shieber</author>
</authors>
<title>An Introduction to Unification-Based Approaches to Grammar.</title>
<date>1986</date>
<booktitle>CSLI Lecture Notes 4.</booktitle>
<publisher>CSLI.</publisher>
<location>Stanford:</location>
<contexts>
<context position="1910" citStr="Shieber (1986)" startWordPosition="277" endWordPosition="278"> Furthermore, the parser is forced to search through instantiated categories for desired GOTO table entries during parsing. The major innovations of the proposed algorithm include the construction of a minimal size of GOTO table that does not require any preliminary instantiation of categories or a search for them, and a reduce action which performs instantiation during parsing. Some details of the LR parsing algorithm are assumed from Aho and Ullman (1987) and Aho and Johnson (1974), and more formal definitions and notations of a featurebased grammar formalism from Pollard and Sag (1987) and Shieber (1986). 2 The LR Parsing Algorithm The LR parser is an efficient shift-reduce parser with optional lookahead. Parse trees for input strings are built bottom-up, while predictions are made top-down prior to parsing. The ACTION/GOTO table is constructed during preprocessing of a grammar and deterministically guides the parser at each step during parsing. The ACTION table determines whether the parser should take a shift or a reduce action next. The GOTO table determines the state the parser should be in after each action. Henceforth, entries for the ACTION/ GOTO table are referred to as the values of </context>
<context position="5507" citStr="Shieber (1986)" startWordPosition="894" endWordPosition="895">for the lhs is consulted. Whether a category appears on the lhs or the rhs of productions is a trivial question, however, since in a grammar with atomic categories, every category that appears on the lhs also appears on the rhs and vice versa. On the other hand, in a grammar with featurebased categories, as proposed by most recent syntactic theories, it is no longer the case. 3 Construction of the GOTO Table for Feature-Based Categories: A Preliminary Modification Fig.3 is an example production using feature-based syntactic categories. The notations are adapted from Pollard and Sag (1987) and Shieber (1986). The tags roughly correspond to variables of logic unification with a scope of single productions: if one occurrence of a particular tag is instantiated as a result of unification, so are other occurrences of the same tag within the production. CAT V SUBCAT TENSE &apos;CAT V SUBCAT [FIRST EINP REST _TENSE Figure 3. Example Production NP(det(a)N(dog)) I s V(saw) sl V(saw) s4 N(do) s13 Det(a) SI V(saw) NP - 70 - Recursive applications of the production &amp;quot;gave boys trees&amp;quot; in Fig.4. The assumed assigns the constituent structure to strings lexical category for &amp;quot;gave&amp;quot; is given in Fig.5. Figure 4. Example</context>
</contexts>
<marker>Shieber, 1986</marker>
<rawString>Shieber, S. 1986. An Introduction to Unification-Based Approaches to Grammar. CSLI Lecture Notes 4. Stanford: CSLI.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Masaru Tomita</author>
</authors>
<title>Efficient Parsing for Natural Language: A Fast Algorithm for Practical Systems.</title>
<date>1986</date>
<publisher>Kluwer Academic Publishers.</publisher>
<location>Boston:</location>
<marker>Tomita, 1986</marker>
<rawString>Tomita, Masaru 1986. Efficient Parsing for Natural Language: A Fast Algorithm for Practical Systems. Boston: Kluwer Academic Publishers.</rawString>
</citation>
<citation valid="false">
<pages>74</pages>
<marker></marker>
<rawString>- 74 -</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>