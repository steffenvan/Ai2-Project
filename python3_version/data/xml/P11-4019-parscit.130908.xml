<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000824">
<title confidence="0.98811">
SystemT: A Declarative Information Extraction System
</title>
<author confidence="0.987145">
Yunyao Li
</author>
<affiliation confidence="0.886727">
IBM Research - Almaden
</affiliation>
<address confidence="0.9951505">
650 Harry Road
San Jose, CA 95120
</address>
<email confidence="0.998663">
yunyaoli@us.ibm.com
</email>
<author confidence="0.928558">
Frederick R. Reiss
</author>
<affiliation confidence="0.836262">
IBM Research - Almaden
</affiliation>
<address confidence="0.994242">
650 Harry Road
San Jose, CA 95120
</address>
<email confidence="0.997738">
frreiss@us.ibm.com
</email>
<author confidence="0.837634">
Laura Chiticariu
</author>
<affiliation confidence="0.757635">
IBM Research - Almaden
</affiliation>
<address confidence="0.993062">
650 Harry Road
San Jose, CA 95120
</address>
<email confidence="0.999199">
chiti@us.ibm.com
</email>
<sectionHeader confidence="0.995641" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999749294117647">
Emerging text-intensive enterprise applica-
tions such as social analytics and semantic
search pose new challenges of scalability and
usability to Information Extraction (IE) sys-
tems. This paper presents SystemT, a declar-
ative IE system that addresses these challenges
and has been deployed in a wide range of en-
terprise applications. SystemT facilitates the
development of high quality complex annota-
tors by providing a highly expressive language
and an advanced development environment.
It also includes a cost-based optimizer and a
high-performance, flexible runtime with mini-
mum memory footprint. We present SystemT
as a useful resource that is freely available,
and as an opportunity to promote research in
building scalable and usable IE systems.
</bodyText>
<sectionHeader confidence="0.998993" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999812479166667">
Information extraction (IE) refers to the extraction
of structured information from text documents. In
recent years, text analytics have become the driv-
ing force for many emerging enterprise applications
such as compliance and data redaction. In addition,
the inclusion of text has also been increasingly im-
portant for many traditional enterprise applications
such as business intelligence. Not surprisingly, the
use of information extraction has dramatically in-
creased within the enterprise over the years. While
the traditional requirement of extraction quality re-
mains critical, enterprise applications pose several
two challenges to IE systems:
1.Scalability: Enterprise applications operate
over large volumes of data, often orders of
magnitude larger than classical IE corpora. An
IE system should be able to operate at those
scales without compromising its execution ef-
ficiency or memory consumption.
2.Usability: Building an accurate IE system is
an inherently labor intensive process. There-
fore, the usability of an enterprise IE system in
terms of ease of development and maintenance
is crucial for ensuring healthy product cycle
and timely handling of customer complains.
Traditionally, IE systems have been built from in-
dividual extraction components consisting of rules
or machine learning models. These individual com-
ponents are then connected procedurally in a pro-
gramming language such as C++, Perl or Java. Such
procedural logic towards IE cannot meet the increas-
ing scalability and usability requirements in the en-
terprise (Doan et al., 2006; Chiticariu et al., 2010a).
Three decades ago, the database community faced
similar scalability and expressivity challenges in
accessing structured information. The community
addressed these problems by introducing a rela-
tional algebra formalism and an associated declar-
ative query language SQL. Borrowing ideas from
the database community, several systems (Doan and
others, 2008; Bohannon and others, 2008; Jain et al.,
2009; Krishnamurthy et al., 2008; Wang et al., 2010)
have been built in recent years taking an alternative
declarative approach to information extraction. In-
stead of using procedural logic to implement the ex-
traction task, declarative IE systems separate the de-
scription of what to extract from how to extract it,
allowing the IE developer to build complex extrac-
</bodyText>
<page confidence="0.982769">
109
</page>
<note confidence="0.4211745">
Proceedings of the ACL-HLT 2011 System Demonstrations, pages 109–114,
Portland, Oregon, USA, 21 June 2011. c�2011 Association for Computational Linguistics
</note>
<table confidence="0.8933292">
create view Phone as
extract regex /\d{3}-\d{4}/ on D.text as number
from Document D;
create view Person as
extract dictionary ‘firstNames.dict’ on D.text as name
from Document D;
create view PersonPhoneAll as
select CombineSpans(P.name, Ph.number) as match
from Person P, Phone Ph
where FollowsTok(P.name, Ph.number, 0, 5);
create view PersonPhone as
select R.name as name
from PersonPhoneAll R
consolidate on R.name;
output view PersonPhone;
</table>
<figure confidence="0.9981975">
Development Environment
Sample
Documents
Execution
Engine
User
Interface
Optimizer
Plan
(Algebra)
Rules
(XQL)
Annotated
Document
Stream
Input
Document
Stream
untie
Runtime
nvironent
Environment
</figure>
<figureCaption confidence="0.9934045">
Figure 2: An AQL program for a PersonPhone task.
Figure 1: Overview of SystemT
</figureCaption>
<bodyText confidence="0.995323909090909">
tion programs without worrying about performance
considerations.
In this demonstration, we showcase one such
declarative IE system called SystemT, designed
to address the scalability and usability challenges.
We illustrate how SystemT, currently deployed in
a multitude of real-world applications and com-
mercial products, can be used to develop and
maintain IE annotators for enterprise applica-
tions. A free version of SystemT is available at
http://www.alphaworks.ibm.com/tech/systemt.
</bodyText>
<sectionHeader confidence="0.839938" genericHeader="method">
2 Overview of SystemT
</sectionHeader>
<bodyText confidence="0.989317657142857">
Figure 1 depicts the architecture of SystemT. The sys-
tem consists of two major components: the Development
Environment and the Runtime Environment. The Sys-
temT Development Environment supports the iterative
process of constructing and refining rules for information
extraction. The rules are specified in a declarative lan-
guage called AQL (F.Reiss et al., 2008). The Develop-
ment Environment provides facilities for executing rules
over a given corpus of representative documents and vi-
sualizing the results of the execution. Once a developer
is satisfied with the results that her rules produce on these
documents, she can publish her annotator.
Publishing an annotator is a two-step process. First,
given an AQL annotator, there can be many possible
graphs of operators, or execution plans, each of which
faithfully implements the semantics of the annotator.
Some of the execution plans are much more efficient than
others. The SystemT Optimizer explores the space of
the possible execution plans to choose the most efficient
one. This execution plan is then given to the SystemT
Runtime to instantiate the corresponding physical oper-
ators. Once the physical operators are instantiated, the
SystemT Runtime feeds one document at a time through
the graph of physical operators and outputs a stream of
annotated documents.
The decoupling of the Development and Runtime en-
vironments is essential for the flexibility of the system. It
facilitates the incorporating of various sophisticated tools
to enable annotator development without sacrificing run-
time performance. Furthermore, the separation permits
the SystemT Runtime to be embedded into larger appli-
cations with minimum memory footprint. Next, we dis-
cuss individual components of SystemT in more details
(Sections 3 – 6), and summarize our experience with the
system in a variety of enterprise applications (Section 7).
</bodyText>
<sectionHeader confidence="0.961666" genericHeader="method">
3 The Extraction Language
</sectionHeader>
<bodyText confidence="0.9999025">
In SystemT, developers express an information extrac-
tion program using a language called AQL. AQL is a
declarative relational language similar in syntax to the
database language SQL, which was chosen as a basis for
our language due to its expressivity and familiarity. An
AQL program (or an AQL annotator) consists of a set of
AQL rules.
In this section, we describe the AQL language and
its underlying algebraic operators. In Section 4, we ex-
plain how the SystemT optimizer explores a large space
of possible execution plans for an AQL annotator and
chooses one that is most efficient.
</bodyText>
<subsectionHeader confidence="0.992437">
3.1 AQL
</subsectionHeader>
<bodyText confidence="0.997069666666667">
Figure 2 illustrates a (very) simplistic annotator of rela-
tionships between persons and their phone number. At a
high-level, the annotator identifies person names using a
simple dictionary of first names, and phone numbers us-
ing a regular expression. It then identifies pairs of Person
and Phone annotations, where the latter follows the
</bodyText>
<page confidence="0.962597">
110
</page>
<figure confidence="0.999448846153846">
Person
firstNames.dict
(‘Anna’, ‘John’, ‘Martin’, ...)
Input Tuple
Output Tuple 1
Output Tuple 2
Document Span 1
Document Span 2
Document
Dictionary
I’ve seen John
and Martin, ...
...
</figure>
<figureCaption confidence="0.999595">
Figure 3: Dictionary Extraction Operator
</figureCaption>
<bodyText confidence="0.9865895">
stricted context in order to support operations such
as validation or normalization. More details on AQL
can be found in the AQL manual (Chiticariu et al.,
2010b).
</bodyText>
<subsectionHeader confidence="0.998393">
3.2 Algebraic Operators in SystemT
</subsectionHeader>
<bodyText confidence="0.9963170625">
SystemT executes AQL rules using graphs of op-
erators. These operators are based on an algebraic
formalism that is similar to the relational algebra
formalism, but with extensions for text processing.
Each operator in the algebra implements a single
basic atomic IE operation, producing and consum-
ing sets of tuples (i.e., views).
Fig. 3 illustrates the dictionary extraction operator
in the algebra, which performs character-level dic-
tionary matching. A full description of the 12 differ-
ent operators of the algebra can be found in (F.Reiss
et al., 2008). Three of the operators are listed below.
• The Extract operator (£) performs character-
level operations such as regular expression and
dictionary matching over text, producing one tu-
ple for each match.
</bodyText>
<listItem confidence="0.75210775">
• The Select operator (σ) takes as input a set of
tuples and a predicate to apply to the tuples, and
outputs all tuples that satisfy the predicate.
• The Join operator (◃▹) takes as input two sets of
</listItem>
<bodyText confidence="0.994104808510638">
tuples and a predicate to apply to pairs of tuples.
It outputs all pairs satisfying the predicate.
Other operators include PartOfSpeech for part-
of-speech detection, Consolidate for removing
overlapping annotations, Block and Group for
grouping together similar annotations occurring
within close proximity to each other, as well as ex-
pressing more general types of aggregation, Sort for
sorting, and Union and Minus for expressing set
union and set difference, respectively.
former within 0 to 5 tokens, and marks the corre-
sponding region of text as a PersonPhoneAll annota-
tion. The final output PersonPhone is constructed by
removing overlapping PersonPhoneAll annotations.
AQL operates over a simple relational data model
with three data types: span, tuple, and view. In this
data model, a span is a region of text within a doc-
ument identified by its “begin” and “end” positions,
while a tuple is a list of spans of fixed size. A view
is a set of tuples. As can be seen from Figure 2,
each AQL rule defines a view. As such, a view is the
basic building block in AQL: it consists of a logical
description of a set of tuples in terms of the docu-
ment text, or the content of other views. The input
to the annotator is a special view called Document
containing a single tuple with the document text.
The AQL annotator tags some views as output views,
which specify the annotation types that are the final
results of the annotator.
The example in Figure 2 illustrates two of the
basic constructs of AQL. The extract statement
specifies basic character-level extraction primitives,
such as regular expressions or dictionaries (i.e.,
gazetteers), that are applied directly to the docu-
ment, or a region thereof. The select statement
is similar to the corresponding SQL statement, but
contains an additional consolidate on clause
for resolving overlapping annotations, along with an
extensive collection of text-specific predicates.
To keep rules compact, AQL also allows a short-
hand pattern notation similar to the syntax of the
CPSL grammar standard (Appelt and Onyshkevych,
1998). For example, the PersonPhoneAll view
in Figure 2 can also be expressed as shown below.
Internally, SystemT translates each of these extract
pattern statements into one or more select and ex-
tract statements.
</bodyText>
<table confidence="0.69012075">
create view PersonPhoneAll as
extract pattern
&lt;P.name&gt; &lt;Token&gt;{0,5} &lt;Ph.number&gt;
from Person P, Phone Ph;
</table>
<bodyText confidence="0.996885714285714">
SystemT has built-in multilingual support in-
cluding tokenization, part of speech and gazetteer
matching for over 20 languages using IBM Lan-
guageWare. Annotator developers can utilize the
multilingual support via AQL without having to con-
figure or manage any additional resources. In ad-
dition, AQL allows user-defined functions in a re-
</bodyText>
<page confidence="0.992718">
111
</page>
<figure confidence="0.730369">
Plan A
</figure>
<figureCaption confidence="0.8057765">
Find matches of Person and Phone, then identify
pairs that are within 0 to 5 tokens of each other
Figure 4: Execution strategies for PersonPhoneAll in
Fig. 2
</figureCaption>
<sectionHeader confidence="0.972243" genericHeader="method">
4 The Optimizer
</sectionHeader>
<bodyText confidence="0.99996509375">
Grammar-based IE engines such as (Boguraev,
2003; Cunningham et al., 2000) place rigid restric-
tions on the order in which rules can be executed.
Such systems that implement the CPSL standard or
extensions of it must use a finite state transducer to
evaluate each level of the cascade with one or more
left to right passes over the entire input token stream.
In contrast, SystemT uses a declarative approach
based on rules that specify what patterns to extract,
as opposed to how to extract them. In a declarative
IE system such as SystemT the specification of an
annotator is completely separate from its implemen-
tation. In particular, the system does not place ex-
plicit constraints on the order of rule evaluation, nor
does it require that intermediate results of an anno-
tator collapse to a fixed-size sequence.
As shown in Fig. 1, the SystemT engine does
not execute AQL directly; instead, the SystemT
Optimizer compiles AQL into a graph of operators.
Given a collection of AQL views, the optimizer gen-
erates a large number of different operator graphs,
all of which faithfully implement the semantics of
the original views. Even though these graphs always
produce the same results, the execution strategies
that they represent can have very different perfor-
mance characteristics. The optimizer incorporates
a cost model which, given an operator graph, esti-
mates the CPU time required to execute the graph
over an average document in the corpus. This cost
model allows the optimizer to estimate the cost of
each potential execution strategy and to choose the
one with the fastest predicted running time.
Fig. 4 presents three possible execution strategies
for the PersonPhoneAll rule in Fig. 2. If the opti-
mizer estimates that the evaluation cost of Person is
much lower than that of Phone, then it can determine
that Plan B has the lowest evaluation cost among
the three, because Plan B only evaluates Phone in
the “right” neighborhood for each instance of Per-
son. More details of our algorithms for enumerating
plans can be found in (F.Reiss et al., 2008).
The optimizer in SystemT chooses the best exe-
cution plan from a large number of different algebra
graphs available. Depending on the execution plan
generated by the optimizer, SystemT may evaluate
views out of order, or it may skip evaluating some
views entirely. It may share work among views or
combine multiple equivalent views together. Even
within the context of a single view, the system can
choose among several different execution strategies
without affecting the semantics of the annotator.
This decoupling is possible because of the declar-
ative approach in SystemT, where the AQL rules
specify only what patterns to extract and not how to
extract them. Notice that many of these strategies
cannot be implemented using a transducer. In fact,
we have formally proven that within this large search
space, there generally exists an execution strategy
that implements the rule semantics far more effi-
ciently than the fastest transducer could (Chiticariu
et al., 2010b). This approach also allows for greater
rule expressivity, because the rule language is not
constrained by the need to compile to a finite state
transducer, as in traditional CPSL-based systems.
</bodyText>
<sectionHeader confidence="0.927891" genericHeader="method">
5 The Runtime
</sectionHeader>
<bodyText confidence="0.999720882352941">
The SystemT Runtime is a compact, small memory
footprint, high-performance Java-based runtime en-
gine designed to be embedded in a larger system.
The runtime engine works in two steps. First, it
instantiates the physical operators in the compiled
operator graph generated by the optimizer. Second,
once the first step has been completed, the runtime
feeds documents through the operator graph one at a
time, producing annotations.
SystemT exposes a generic Java API for the inte-
gration of its runtime environment with other appli-
cations. Furthermore, SystemT provides two spe-
cific instantiations of the Java API: a UIMA API and
a Jaql function that allow the SystemT runtime to
be seamlessly embedded in applications using the
UIMA analytics framework (UIMA, 2010), or de-
ployed in a Hadoop-based environment. The latter
</bodyText>
<figure confidence="0.9931141">
σ
E dict
σ
E regex
⋈
Person Phone
Plan B Plan C
Find matches of Person, then Find matches of Phone, then
discard matches that are not discard matches that are not
followed by a Phone followed by a Person
</figure>
<page confidence="0.993382">
112
</page>
<bodyText confidence="0.997605">
allows SystemT to be embedded as a Map job in a
map-reduce framework, thus enabling the system to
scale up and process large volumes of documents in
parallel.
</bodyText>
<subsectionHeader confidence="0.994">
5.1 Memory Consumption
</subsectionHeader>
<bodyText confidence="0.999787">
Managing memory consumption is very important
in information extraction systems. Extracting struc-
tured information from unstructured text requires
generating and traversing large in-memory data
structures, and the size of these structures deter-
mines how large a document the system can process
with a given amount of memory.
Conventional rule-based IE systems cannot
garbage-collect their main-memory data structures
because the custom code embedded inside rules can
change these structures in arbitrary ways. As a re-
sult, the memory footprint of the rule engine grows
continuously throughout processing a given docu-
ment.
In SystemT, the AQL view definitions clearly
specify the data dependencies between rules. When
generating an execution plan for an AQL annota-
tor, the optimizer generates information about when
it is safe to discard a given set of intermediate re-
sults. The SystemT Runtime uses this information
to implement garbage collection based on reference-
counting. This garbage collection significantly re-
duces the system’s peak memory consumption, al-
lowing SystemT to handle much larger documents
than conventional IE systems.
</bodyText>
<sectionHeader confidence="0.997202" genericHeader="method">
6 The Development Environment
</sectionHeader>
<bodyText confidence="0.999562818181818">
The SystemT Development Environment assists a
developer in the iterative process of developing,
testing, debugging and refining AQL rules. Be-
sides standard editor features present in any well-
respected IDE for programming languages such as
syntax highlighting, the Development Environment
also provides facilities for visualizing the results of
executing the rules over a sample document collec-
tion as well as explaining in detail the provenance of
any output annotation as the sequence of rules that
have been applied in generating that output.
</bodyText>
<sectionHeader confidence="0.999091" genericHeader="evaluation">
7 Evaluation
</sectionHeader>
<bodyText confidence="0.9932425">
As discussed in Section 1, our goal in building Sys-
temT was to address the scalability and usability
</bodyText>
<figure confidence="0.5522815">
Application Type Type of Platform
brand management server-side
business insights server-side
client-side mashups client-side
compliance server-side
search (email, web, patent) server-side
security server-side
server-side mashups server-side
</figure>
<tableCaption confidence="0.996309">
Table 1: Types of applications using SystemT
</tableCaption>
<bodyText confidence="0.998765">
challenges posed by enterprise applications. As
such, our evaluation focuses on these two dimen-
sions.
</bodyText>
<subsectionHeader confidence="0.937109">
7.1 Scalability
</subsectionHeader>
<bodyText confidence="0.999972896551724">
Table 1 presents a diverse set of enterprise applica-
tions currently using SystemT. SystemT has been
deployed in both client-side applications with strict
memory constraints, as well as on applications on
the cloud, where it can process petabytes of data
in parallel. The focus on scalability in the design
of SystemT is essential for its flexible execution
model. First of all, efficient execution plans are
generated automatically by the SystemT Optimizer
based on sample document collections. This en-
sures that the same annotator can be executed effi-
ciently for different types of document collections.
In fact, our previous experimental study shows that
the execution plan generated by the SystemT opti-
mizer can be 20 times or more faster than a manu-
ally constructed plan (F.Reiss et al., 2008). Further-
more, the Runtime Environment of SystemT results
in compact memory footprint and allows SystemT
to be embedded in applications with strict memory
requirements as small as 10MB.
In our recent study over several document col-
lections of different sizes, we found that for the
same set of extraction tasks, the SystemT through-
put is at least an order of magnitude higher than
that of a state-of-the-art grammar-based IE system,
with much lower memory footprint (Chiticariu et al.,
2010b). The high throughput and low memory foot-
print of SystemT allows it to satisfy the scalability
requirement of enterprise applications.
</bodyText>
<subsectionHeader confidence="0.963232">
7.2 Usability
</subsectionHeader>
<bodyText confidence="0.864477">
Table 2 lists different types of annotators built us-
ing SystemT for a wide range of domains. Most,
</bodyText>
<page confidence="0.996584">
113
</page>
<table confidence="0.978987571428571">
Domain Sample Annotators Built
blog Sentiment,InformalReview
email ConferenceCall, Signature, Agenda, DrivingDirection, PersonPhone, PersonAddress, PersonEmailAddress
financial Merger, Acquisition, JointVenture, EarningsAnnouncement, AnalystEarningsEstimate, DirectorsOfficers, CorporateActions
generic Person, Location, Organization, PhoneNumber, EmailAddress, URL, Time, Date
healthcare Disease,Drug,ChemicalCompound
web Homepage,Geography,Title,Heading
</table>
<tableCaption confidence="0.998675">
Table 2: List of Sample Annotators Built Using SystemT for Different Domains
</tableCaption>
<bodyText confidence="0.999959">
if not all, of these annotators are already deployed
in commercial products. The emphasis on usability
in the design of SystemT has been critical for its
successful deployment in various domains. First of
all, the declarative approach taken by SystemT al-
lows developers to build complex annotators without
worrying about performance. Secondly, the expres-
siveness of the AQL language has greatly eased the
burden of annotator developers when building com-
plex annotators, as complex semantics such as dupli-
cate elimination and aggregation can be expressed in
a concise fashion (Chiticariu et al., 2010b). Finally,
the Development Environment further facilitates an-
notator development, where the clean semantics of
AQL can be exploited to automatically construct ex-
planations of incorrect results to help a developer in
identifying specific parts of the annotator responsi-
ble for a given mistake. SystemT has been suc-
cessfully used by enterprise application developers
in building high quality complex annotators, without
requiring extensive training or background in natural
language processing.
</bodyText>
<sectionHeader confidence="0.997998" genericHeader="conclusions">
8 Demonstration
</sectionHeader>
<bodyText confidence="0.999966666666667">
This demonstration will present the core function-
alities of SystemT. In particular, we shall demon-
strate the iterative process of building and debug-
ging an annotator in the Development Environment.
We will then showcase the execution plan automati-
cally generated by the Optimizer based on a sample
document collection, and present the output of the
Runtime Environment using the execution plan. In
our demonstration we will first make use of a simple
annotator, as the one shown in Fig. 2, to illustrate
the main constructs of AQL. We will then showcase
the generic state-of-the-art SystemT Named Enti-
ties Annotator Library (Chiticariu et al., 2010c) to
illustrate the quality of annotators that can be built
in our system.
</bodyText>
<sectionHeader confidence="0.999158" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.99966025">
D. E. Appelt and B. Onyshkevych. 1998. The common
pattern specification language. In TIPSTER workshop.
B. Boguraev. 2003. Annotation-based finite state pro-
cessing in a large-scale nlp arhitecture. In RANLP.
P. Bohannon et al. 2008. Purple SOX Extraction Man-
agement System. SIGMOD Record, 37(4):21–27.
L. Chiticariu, Y. Li, S. Raghavan, and F. Reiss. 2010a.
Enterprise information extraction: Recent develop-
ments and open challenges. In SIGMOD.
Laura Chiticariu, Rajasekar Krishnamurthy, Yunyao Li,
Sriram Raghavan, Frederick R. Reiss, and Shivaku-
mar Vaithyanathan. 2010b. Systemt: an algebraic ap-
proach to declarative information extraction. ACL.
Laura Chiticariu, Rajasekar Krishnamurthy, Yunyao
Li, Frederick Reiss, and Shivakumar Vaithyanathan.
2010c. Domain adaptation of rule-based annotators
for named-entity recognition tasks. EMNLP.
H. Cunningham, D. Maynard, and V. Tablan. 2000.
JAPE: a Java Annotation Patterns Engine (Second Edi-
tion). Research Memorandum CS–00–10, Department
of Computer Science, University of Sheffield.
A. Doan et al. 2008. Information extraction challenges
in managing unstructured data. SIGMOD Record,
37(4):14–20.
A. Doan, R. Ramakrishnan, and S. Vaithyanathan. 2006.
Managing Information Extraction: State of the Art and
Research Directions. In SIGMOD.
F.Reiss, S. Raghavan, R. Krishnamurthy, H. Zhu, and
S. Vaithyanathan. 2008. An algebraic approach to
rule-based information extraction. In ICDE.
A. Jain, P. Ipeirotis, and L. Gravano. 2009. Building
query optimizers for information extraction: the sqout
project. SIGMOD Rec., 37:28–34.
R. Krishnamurthy, Y. Li, S. Raghavan, F. Reiss,
S. Vaithyanathan, and H. Zhu. 2008. SystemT: a sys-
tem for declarative information extraction. SIGMOD
Record, 37(4):7–13.
D. Z. Wang, E. Michelakis, M. J. Franklin, M. Garo-
falakis, and J. M. Hellerstein. 2010. Probabilistic
declarative information extraction. In ICDE.
</reference>
<page confidence="0.998654">
114
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.692297">
<title confidence="0.999911">A Declarative Information Extraction System</title>
<author confidence="0.980116">Yunyao</author>
<affiliation confidence="0.999699">IBM Research -</affiliation>
<address confidence="0.9469625">650 Harry San Jose, CA</address>
<email confidence="0.999326">yunyaoli@us.ibm.com</email>
<author confidence="0.999377">R Frederick</author>
<affiliation confidence="0.999816">IBM Research -</affiliation>
<address confidence="0.9468245">650 Harry San Jose, CA</address>
<email confidence="0.999246">frreiss@us.ibm.com</email>
<author confidence="0.986648">Laura</author>
<affiliation confidence="0.99979">IBM Research -</affiliation>
<address confidence="0.953889">650 Harry San Jose, CA</address>
<email confidence="0.999284">chiti@us.ibm.com</email>
<abstract confidence="0.999375166666667">Emerging text-intensive enterprise applications such as social analytics and semantic search pose new challenges of scalability and usability to Information Extraction (IE) sys- This paper presents a declarative IE system that addresses these challenges and has been deployed in a wide range of enapplications. the development of high quality complex annotators by providing a highly expressive language and an advanced development environment. It also includes a cost-based optimizer and a high-performance, flexible runtime with minimemory footprint. We present as a useful resource that is freely available, and as an opportunity to promote research in building scalable and usable IE systems.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>D E Appelt</author>
<author>B Onyshkevych</author>
</authors>
<title>The common pattern specification language. In</title>
<date>1998</date>
<journal>SIGMOD Record,</journal>
<volume>37</volume>
<issue>4</issue>
<contexts>
<context position="11125" citStr="Appelt and Onyshkevych, 1998" startWordPosition="1710" endWordPosition="1713">gure 2 illustrates two of the basic constructs of AQL. The extract statement specifies basic character-level extraction primitives, such as regular expressions or dictionaries (i.e., gazetteers), that are applied directly to the document, or a region thereof. The select statement is similar to the corresponding SQL statement, but contains an additional consolidate on clause for resolving overlapping annotations, along with an extensive collection of text-specific predicates. To keep rules compact, AQL also allows a shorthand pattern notation similar to the syntax of the CPSL grammar standard (Appelt and Onyshkevych, 1998). For example, the PersonPhoneAll view in Figure 2 can also be expressed as shown below. Internally, SystemT translates each of these extract pattern statements into one or more select and extract statements. create view PersonPhoneAll as extract pattern &lt;P.name&gt; &lt;Token&gt;{0,5} &lt;Ph.number&gt; from Person P, Phone Ph; SystemT has built-in multilingual support including tokenization, part of speech and gazetteer matching for over 20 languages using IBM LanguageWare. Annotator developers can utilize the multilingual support via AQL without having to configure or manage any additional resources. In add</context>
</contexts>
<marker>Appelt, Onyshkevych, 1998</marker>
<rawString>D. E. Appelt and B. Onyshkevych. 1998. The common pattern specification language. In TIPSTER workshop. B. Boguraev. 2003. Annotation-based finite state processing in a large-scale nlp arhitecture. In RANLP. P. Bohannon et al. 2008. Purple SOX Extraction Management System. SIGMOD Record, 37(4):21–27.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Chiticariu</author>
<author>Y Li</author>
<author>S Raghavan</author>
<author>F Reiss</author>
</authors>
<title>Enterprise information extraction: Recent developments and open challenges.</title>
<date>2010</date>
<booktitle>In SIGMOD.</booktitle>
<contexts>
<context position="2685" citStr="Chiticariu et al., 2010" startWordPosition="395" endWordPosition="398">erently labor intensive process. Therefore, the usability of an enterprise IE system in terms of ease of development and maintenance is crucial for ensuring healthy product cycle and timely handling of customer complains. Traditionally, IE systems have been built from individual extraction components consisting of rules or machine learning models. These individual components are then connected procedurally in a programming language such as C++, Perl or Java. Such procedural logic towards IE cannot meet the increasing scalability and usability requirements in the enterprise (Doan et al., 2006; Chiticariu et al., 2010a). Three decades ago, the database community faced similar scalability and expressivity challenges in accessing structured information. The community addressed these problems by introducing a relational algebra formalism and an associated declarative query language SQL. Borrowing ideas from the database community, several systems (Doan and others, 2008; Bohannon and others, 2008; Jain et al., 2009; Krishnamurthy et al., 2008; Wang et al., 2010) have been built in recent years taking an alternative declarative approach to information extraction. Instead of using procedural logic to implement t</context>
<context position="8054" citStr="Chiticariu et al., 2010" startWordPosition="1206" endWordPosition="1209">er. At a high-level, the annotator identifies person names using a simple dictionary of first names, and phone numbers using a regular expression. It then identifies pairs of Person and Phone annotations, where the latter follows the 110 Person firstNames.dict (‘Anna’, ‘John’, ‘Martin’, ...) Input Tuple Output Tuple 1 Output Tuple 2 Document Span 1 Document Span 2 Document Dictionary I’ve seen John and Martin, ... ... Figure 3: Dictionary Extraction Operator stricted context in order to support operations such as validation or normalization. More details on AQL can be found in the AQL manual (Chiticariu et al., 2010b). 3.2 Algebraic Operators in SystemT SystemT executes AQL rules using graphs of operators. These operators are based on an algebraic formalism that is similar to the relational algebra formalism, but with extensions for text processing. Each operator in the algebra implements a single basic atomic IE operation, producing and consuming sets of tuples (i.e., views). Fig. 3 illustrates the dictionary extraction operator in the algebra, which performs character-level dictionary matching. A full description of the 12 different operators of the algebra can be found in (F.Reiss et al., 2008). Three</context>
<context position="14990" citStr="Chiticariu et al., 2010" startWordPosition="2341" endWordPosition="2344">thin the context of a single view, the system can choose among several different execution strategies without affecting the semantics of the annotator. This decoupling is possible because of the declarative approach in SystemT, where the AQL rules specify only what patterns to extract and not how to extract them. Notice that many of these strategies cannot be implemented using a transducer. In fact, we have formally proven that within this large search space, there generally exists an execution strategy that implements the rule semantics far more efficiently than the fastest transducer could (Chiticariu et al., 2010b). This approach also allows for greater rule expressivity, because the rule language is not constrained by the need to compile to a finite state transducer, as in traditional CPSL-based systems. 5 The Runtime The SystemT Runtime is a compact, small memory footprint, high-performance Java-based runtime engine designed to be embedded in a larger system. The runtime engine works in two steps. First, it instantiates the physical operators in the compiled operator graph generated by the optimizer. Second, once the first step has been completed, the runtime feeds documents through the operator gra</context>
<context position="19929" citStr="Chiticariu et al., 2010" startWordPosition="3107" endWordPosition="3110">cution plan generated by the SystemT optimizer can be 20 times or more faster than a manually constructed plan (F.Reiss et al., 2008). Furthermore, the Runtime Environment of SystemT results in compact memory footprint and allows SystemT to be embedded in applications with strict memory requirements as small as 10MB. In our recent study over several document collections of different sizes, we found that for the same set of extraction tasks, the SystemT throughput is at least an order of magnitude higher than that of a state-of-the-art grammar-based IE system, with much lower memory footprint (Chiticariu et al., 2010b). The high throughput and low memory footprint of SystemT allows it to satisfy the scalability requirement of enterprise applications. 7.2 Usability Table 2 lists different types of annotators built using SystemT for a wide range of domains. Most, 113 Domain Sample Annotators Built blog Sentiment,InformalReview email ConferenceCall, Signature, Agenda, DrivingDirection, PersonPhone, PersonAddress, PersonEmailAddress financial Merger, Acquisition, JointVenture, EarningsAnnouncement, AnalystEarningsEstimate, DirectorsOfficers, CorporateActions generic Person, Location, Organization, PhoneNumber</context>
<context position="21315" citStr="Chiticariu et al., 2010" startWordPosition="3288" endWordPosition="3291">T for Different Domains if not all, of these annotators are already deployed in commercial products. The emphasis on usability in the design of SystemT has been critical for its successful deployment in various domains. First of all, the declarative approach taken by SystemT allows developers to build complex annotators without worrying about performance. Secondly, the expressiveness of the AQL language has greatly eased the burden of annotator developers when building complex annotators, as complex semantics such as duplicate elimination and aggregation can be expressed in a concise fashion (Chiticariu et al., 2010b). Finally, the Development Environment further facilitates annotator development, where the clean semantics of AQL can be exploited to automatically construct explanations of incorrect results to help a developer in identifying specific parts of the annotator responsible for a given mistake. SystemT has been successfully used by enterprise application developers in building high quality complex annotators, without requiring extensive training or background in natural language processing. 8 Demonstration This demonstration will present the core functionalities of SystemT. In particular, we sh</context>
</contexts>
<marker>Chiticariu, Li, Raghavan, Reiss, 2010</marker>
<rawString>L. Chiticariu, Y. Li, S. Raghavan, and F. Reiss. 2010a. Enterprise information extraction: Recent developments and open challenges. In SIGMOD.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Laura Chiticariu</author>
<author>Rajasekar Krishnamurthy</author>
<author>Yunyao Li</author>
<author>Sriram Raghavan</author>
<author>Frederick R Reiss</author>
<author>Shivakumar Vaithyanathan</author>
</authors>
<title>Systemt: an algebraic approach to declarative information extraction.</title>
<date>2010</date>
<publisher>ACL.</publisher>
<contexts>
<context position="2685" citStr="Chiticariu et al., 2010" startWordPosition="395" endWordPosition="398">erently labor intensive process. Therefore, the usability of an enterprise IE system in terms of ease of development and maintenance is crucial for ensuring healthy product cycle and timely handling of customer complains. Traditionally, IE systems have been built from individual extraction components consisting of rules or machine learning models. These individual components are then connected procedurally in a programming language such as C++, Perl or Java. Such procedural logic towards IE cannot meet the increasing scalability and usability requirements in the enterprise (Doan et al., 2006; Chiticariu et al., 2010a). Three decades ago, the database community faced similar scalability and expressivity challenges in accessing structured information. The community addressed these problems by introducing a relational algebra formalism and an associated declarative query language SQL. Borrowing ideas from the database community, several systems (Doan and others, 2008; Bohannon and others, 2008; Jain et al., 2009; Krishnamurthy et al., 2008; Wang et al., 2010) have been built in recent years taking an alternative declarative approach to information extraction. Instead of using procedural logic to implement t</context>
<context position="8054" citStr="Chiticariu et al., 2010" startWordPosition="1206" endWordPosition="1209">er. At a high-level, the annotator identifies person names using a simple dictionary of first names, and phone numbers using a regular expression. It then identifies pairs of Person and Phone annotations, where the latter follows the 110 Person firstNames.dict (‘Anna’, ‘John’, ‘Martin’, ...) Input Tuple Output Tuple 1 Output Tuple 2 Document Span 1 Document Span 2 Document Dictionary I’ve seen John and Martin, ... ... Figure 3: Dictionary Extraction Operator stricted context in order to support operations such as validation or normalization. More details on AQL can be found in the AQL manual (Chiticariu et al., 2010b). 3.2 Algebraic Operators in SystemT SystemT executes AQL rules using graphs of operators. These operators are based on an algebraic formalism that is similar to the relational algebra formalism, but with extensions for text processing. Each operator in the algebra implements a single basic atomic IE operation, producing and consuming sets of tuples (i.e., views). Fig. 3 illustrates the dictionary extraction operator in the algebra, which performs character-level dictionary matching. A full description of the 12 different operators of the algebra can be found in (F.Reiss et al., 2008). Three</context>
<context position="14990" citStr="Chiticariu et al., 2010" startWordPosition="2341" endWordPosition="2344">thin the context of a single view, the system can choose among several different execution strategies without affecting the semantics of the annotator. This decoupling is possible because of the declarative approach in SystemT, where the AQL rules specify only what patterns to extract and not how to extract them. Notice that many of these strategies cannot be implemented using a transducer. In fact, we have formally proven that within this large search space, there generally exists an execution strategy that implements the rule semantics far more efficiently than the fastest transducer could (Chiticariu et al., 2010b). This approach also allows for greater rule expressivity, because the rule language is not constrained by the need to compile to a finite state transducer, as in traditional CPSL-based systems. 5 The Runtime The SystemT Runtime is a compact, small memory footprint, high-performance Java-based runtime engine designed to be embedded in a larger system. The runtime engine works in two steps. First, it instantiates the physical operators in the compiled operator graph generated by the optimizer. Second, once the first step has been completed, the runtime feeds documents through the operator gra</context>
<context position="19929" citStr="Chiticariu et al., 2010" startWordPosition="3107" endWordPosition="3110">cution plan generated by the SystemT optimizer can be 20 times or more faster than a manually constructed plan (F.Reiss et al., 2008). Furthermore, the Runtime Environment of SystemT results in compact memory footprint and allows SystemT to be embedded in applications with strict memory requirements as small as 10MB. In our recent study over several document collections of different sizes, we found that for the same set of extraction tasks, the SystemT throughput is at least an order of magnitude higher than that of a state-of-the-art grammar-based IE system, with much lower memory footprint (Chiticariu et al., 2010b). The high throughput and low memory footprint of SystemT allows it to satisfy the scalability requirement of enterprise applications. 7.2 Usability Table 2 lists different types of annotators built using SystemT for a wide range of domains. Most, 113 Domain Sample Annotators Built blog Sentiment,InformalReview email ConferenceCall, Signature, Agenda, DrivingDirection, PersonPhone, PersonAddress, PersonEmailAddress financial Merger, Acquisition, JointVenture, EarningsAnnouncement, AnalystEarningsEstimate, DirectorsOfficers, CorporateActions generic Person, Location, Organization, PhoneNumber</context>
<context position="21315" citStr="Chiticariu et al., 2010" startWordPosition="3288" endWordPosition="3291">T for Different Domains if not all, of these annotators are already deployed in commercial products. The emphasis on usability in the design of SystemT has been critical for its successful deployment in various domains. First of all, the declarative approach taken by SystemT allows developers to build complex annotators without worrying about performance. Secondly, the expressiveness of the AQL language has greatly eased the burden of annotator developers when building complex annotators, as complex semantics such as duplicate elimination and aggregation can be expressed in a concise fashion (Chiticariu et al., 2010b). Finally, the Development Environment further facilitates annotator development, where the clean semantics of AQL can be exploited to automatically construct explanations of incorrect results to help a developer in identifying specific parts of the annotator responsible for a given mistake. SystemT has been successfully used by enterprise application developers in building high quality complex annotators, without requiring extensive training or background in natural language processing. 8 Demonstration This demonstration will present the core functionalities of SystemT. In particular, we sh</context>
</contexts>
<marker>Chiticariu, Krishnamurthy, Li, Raghavan, Reiss, Vaithyanathan, 2010</marker>
<rawString>Laura Chiticariu, Rajasekar Krishnamurthy, Yunyao Li, Sriram Raghavan, Frederick R. Reiss, and Shivakumar Vaithyanathan. 2010b. Systemt: an algebraic approach to declarative information extraction. ACL.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Laura Chiticariu</author>
</authors>
<title>Rajasekar Krishnamurthy, Yunyao Li, Frederick Reiss, and Shivakumar Vaithyanathan. 2010c. Domain adaptation of rule-based annotators for named-entity recognition tasks.</title>
<publisher>EMNLP.</publisher>
<marker>Chiticariu, </marker>
<rawString>Laura Chiticariu, Rajasekar Krishnamurthy, Yunyao Li, Frederick Reiss, and Shivakumar Vaithyanathan. 2010c. Domain adaptation of rule-based annotators for named-entity recognition tasks. EMNLP.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Cunningham</author>
<author>D Maynard</author>
<author>V Tablan</author>
</authors>
<title>JAPE: a Java Annotation Patterns Engine (Second Edition). Research Memorandum CS–00–10,</title>
<date>2000</date>
<institution>Department of Computer Science, University of Sheffield.</institution>
<contexts>
<context position="12032" citStr="Cunningham et al., 2000" startWordPosition="1853" endWordPosition="1856">mber&gt; from Person P, Phone Ph; SystemT has built-in multilingual support including tokenization, part of speech and gazetteer matching for over 20 languages using IBM LanguageWare. Annotator developers can utilize the multilingual support via AQL without having to configure or manage any additional resources. In addition, AQL allows user-defined functions in a re111 Plan A Find matches of Person and Phone, then identify pairs that are within 0 to 5 tokens of each other Figure 4: Execution strategies for PersonPhoneAll in Fig. 2 4 The Optimizer Grammar-based IE engines such as (Boguraev, 2003; Cunningham et al., 2000) place rigid restrictions on the order in which rules can be executed. Such systems that implement the CPSL standard or extensions of it must use a finite state transducer to evaluate each level of the cascade with one or more left to right passes over the entire input token stream. In contrast, SystemT uses a declarative approach based on rules that specify what patterns to extract, as opposed to how to extract them. In a declarative IE system such as SystemT the specification of an annotator is completely separate from its implementation. In particular, the system does not place explicit con</context>
</contexts>
<marker>Cunningham, Maynard, Tablan, 2000</marker>
<rawString>H. Cunningham, D. Maynard, and V. Tablan. 2000. JAPE: a Java Annotation Patterns Engine (Second Edition). Research Memorandum CS–00–10, Department of Computer Science, University of Sheffield.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Doan</author>
</authors>
<title>Information extraction challenges in managing unstructured data.</title>
<date>2008</date>
<journal>SIGMOD Record,</journal>
<volume>37</volume>
<issue>4</issue>
<marker>Doan, 2008</marker>
<rawString>A. Doan et al. 2008. Information extraction challenges in managing unstructured data. SIGMOD Record, 37(4):14–20.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Doan</author>
<author>R Ramakrishnan</author>
<author>S Vaithyanathan</author>
</authors>
<title>Managing Information Extraction: State of the Art and Research Directions.</title>
<date>2006</date>
<booktitle>In SIGMOD.</booktitle>
<contexts>
<context position="2660" citStr="Doan et al., 2006" startWordPosition="391" endWordPosition="394">IE system is an inherently labor intensive process. Therefore, the usability of an enterprise IE system in terms of ease of development and maintenance is crucial for ensuring healthy product cycle and timely handling of customer complains. Traditionally, IE systems have been built from individual extraction components consisting of rules or machine learning models. These individual components are then connected procedurally in a programming language such as C++, Perl or Java. Such procedural logic towards IE cannot meet the increasing scalability and usability requirements in the enterprise (Doan et al., 2006; Chiticariu et al., 2010a). Three decades ago, the database community faced similar scalability and expressivity challenges in accessing structured information. The community addressed these problems by introducing a relational algebra formalism and an associated declarative query language SQL. Borrowing ideas from the database community, several systems (Doan and others, 2008; Bohannon and others, 2008; Jain et al., 2009; Krishnamurthy et al., 2008; Wang et al., 2010) have been built in recent years taking an alternative declarative approach to information extraction. Instead of using proced</context>
</contexts>
<marker>Doan, Ramakrishnan, Vaithyanathan, 2006</marker>
<rawString>A. Doan, R. Ramakrishnan, and S. Vaithyanathan. 2006. Managing Information Extraction: State of the Art and Research Directions. In SIGMOD.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Raghavan F Reiss</author>
<author>R Krishnamurthy</author>
<author>H Zhu</author>
<author>S Vaithyanathan</author>
</authors>
<title>An algebraic approach to rule-based information extraction.</title>
<date>2008</date>
<booktitle>In ICDE.</booktitle>
<contexts>
<context position="5192" citStr="Reiss et al., 2008" startWordPosition="754" endWordPosition="757">yed in a multitude of real-world applications and commercial products, can be used to develop and maintain IE annotators for enterprise applications. A free version of SystemT is available at http://www.alphaworks.ibm.com/tech/systemt. 2 Overview of SystemT Figure 1 depicts the architecture of SystemT. The system consists of two major components: the Development Environment and the Runtime Environment. The SystemT Development Environment supports the iterative process of constructing and refining rules for information extraction. The rules are specified in a declarative language called AQL (F.Reiss et al., 2008). The Development Environment provides facilities for executing rules over a given corpus of representative documents and visualizing the results of the execution. Once a developer is satisfied with the results that her rules produce on these documents, she can publish her annotator. Publishing an annotator is a two-step process. First, given an AQL annotator, there can be many possible graphs of operators, or execution plans, each of which faithfully implements the semantics of the annotator. Some of the execution plans are much more efficient than others. The SystemT Optimizer explores the s</context>
<context position="8647" citStr="Reiss et al., 2008" startWordPosition="1299" endWordPosition="1302">l (Chiticariu et al., 2010b). 3.2 Algebraic Operators in SystemT SystemT executes AQL rules using graphs of operators. These operators are based on an algebraic formalism that is similar to the relational algebra formalism, but with extensions for text processing. Each operator in the algebra implements a single basic atomic IE operation, producing and consuming sets of tuples (i.e., views). Fig. 3 illustrates the dictionary extraction operator in the algebra, which performs character-level dictionary matching. A full description of the 12 different operators of the algebra can be found in (F.Reiss et al., 2008). Three of the operators are listed below. • The Extract operator (£) performs characterlevel operations such as regular expression and dictionary matching over text, producing one tuple for each match. • The Select operator (σ) takes as input a set of tuples and a predicate to apply to the tuples, and outputs all tuples that satisfy the predicate. • The Join operator (◃▹) takes as input two sets of tuples and a predicate to apply to pairs of tuples. It outputs all pairs satisfying the predicate. Other operators include PartOfSpeech for partof-speech detection, Consolidate for removing overlap</context>
<context position="14017" citStr="Reiss et al., 2008" startWordPosition="2186" endWordPosition="2189">corpus. This cost model allows the optimizer to estimate the cost of each potential execution strategy and to choose the one with the fastest predicted running time. Fig. 4 presents three possible execution strategies for the PersonPhoneAll rule in Fig. 2. If the optimizer estimates that the evaluation cost of Person is much lower than that of Phone, then it can determine that Plan B has the lowest evaluation cost among the three, because Plan B only evaluates Phone in the “right” neighborhood for each instance of Person. More details of our algorithms for enumerating plans can be found in (F.Reiss et al., 2008). The optimizer in SystemT chooses the best execution plan from a large number of different algebra graphs available. Depending on the execution plan generated by the optimizer, SystemT may evaluate views out of order, or it may skip evaluating some views entirely. It may share work among views or combine multiple equivalent views together. Even within the context of a single view, the system can choose among several different execution strategies without affecting the semantics of the annotator. This decoupling is possible because of the declarative approach in SystemT, where the AQL rules sp</context>
<context position="19439" citStr="Reiss et al., 2008" startWordPosition="3028" endWordPosition="3031">ell as on applications on the cloud, where it can process petabytes of data in parallel. The focus on scalability in the design of SystemT is essential for its flexible execution model. First of all, efficient execution plans are generated automatically by the SystemT Optimizer based on sample document collections. This ensures that the same annotator can be executed efficiently for different types of document collections. In fact, our previous experimental study shows that the execution plan generated by the SystemT optimizer can be 20 times or more faster than a manually constructed plan (F.Reiss et al., 2008). Furthermore, the Runtime Environment of SystemT results in compact memory footprint and allows SystemT to be embedded in applications with strict memory requirements as small as 10MB. In our recent study over several document collections of different sizes, we found that for the same set of extraction tasks, the SystemT throughput is at least an order of magnitude higher than that of a state-of-the-art grammar-based IE system, with much lower memory footprint (Chiticariu et al., 2010b). The high throughput and low memory footprint of SystemT allows it to satisfy the scalability requirement o</context>
</contexts>
<marker>Reiss, Krishnamurthy, Zhu, Vaithyanathan, 2008</marker>
<rawString>F.Reiss, S. Raghavan, R. Krishnamurthy, H. Zhu, and S. Vaithyanathan. 2008. An algebraic approach to rule-based information extraction. In ICDE.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Jain</author>
<author>P Ipeirotis</author>
<author>L Gravano</author>
</authors>
<title>Building query optimizers for information extraction: the sqout project.</title>
<date>2009</date>
<journal>SIGMOD Rec.,</journal>
<pages>37--28</pages>
<contexts>
<context position="3086" citStr="Jain et al., 2009" startWordPosition="451" endWordPosition="454">ly in a programming language such as C++, Perl or Java. Such procedural logic towards IE cannot meet the increasing scalability and usability requirements in the enterprise (Doan et al., 2006; Chiticariu et al., 2010a). Three decades ago, the database community faced similar scalability and expressivity challenges in accessing structured information. The community addressed these problems by introducing a relational algebra formalism and an associated declarative query language SQL. Borrowing ideas from the database community, several systems (Doan and others, 2008; Bohannon and others, 2008; Jain et al., 2009; Krishnamurthy et al., 2008; Wang et al., 2010) have been built in recent years taking an alternative declarative approach to information extraction. Instead of using procedural logic to implement the extraction task, declarative IE systems separate the description of what to extract from how to extract it, allowing the IE developer to build complex extrac109 Proceedings of the ACL-HLT 2011 System Demonstrations, pages 109–114, Portland, Oregon, USA, 21 June 2011. c�2011 Association for Computational Linguistics create view Phone as extract regex /\d{3}-\d{4}/ on D.text as number from Documen</context>
</contexts>
<marker>Jain, Ipeirotis, Gravano, 2009</marker>
<rawString>A. Jain, P. Ipeirotis, and L. Gravano. 2009. Building query optimizers for information extraction: the sqout project. SIGMOD Rec., 37:28–34.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Krishnamurthy</author>
<author>Y Li</author>
<author>S Raghavan</author>
<author>F Reiss</author>
<author>S Vaithyanathan</author>
<author>H Zhu</author>
</authors>
<title>SystemT: a system for declarative information extraction.</title>
<date>2008</date>
<journal>SIGMOD Record,</journal>
<volume>37</volume>
<issue>4</issue>
<contexts>
<context position="3114" citStr="Krishnamurthy et al., 2008" startWordPosition="455" endWordPosition="458"> language such as C++, Perl or Java. Such procedural logic towards IE cannot meet the increasing scalability and usability requirements in the enterprise (Doan et al., 2006; Chiticariu et al., 2010a). Three decades ago, the database community faced similar scalability and expressivity challenges in accessing structured information. The community addressed these problems by introducing a relational algebra formalism and an associated declarative query language SQL. Borrowing ideas from the database community, several systems (Doan and others, 2008; Bohannon and others, 2008; Jain et al., 2009; Krishnamurthy et al., 2008; Wang et al., 2010) have been built in recent years taking an alternative declarative approach to information extraction. Instead of using procedural logic to implement the extraction task, declarative IE systems separate the description of what to extract from how to extract it, allowing the IE developer to build complex extrac109 Proceedings of the ACL-HLT 2011 System Demonstrations, pages 109–114, Portland, Oregon, USA, 21 June 2011. c�2011 Association for Computational Linguistics create view Phone as extract regex /\d{3}-\d{4}/ on D.text as number from Document D; create view Person as e</context>
</contexts>
<marker>Krishnamurthy, Li, Raghavan, Reiss, Vaithyanathan, Zhu, 2008</marker>
<rawString>R. Krishnamurthy, Y. Li, S. Raghavan, F. Reiss, S. Vaithyanathan, and H. Zhu. 2008. SystemT: a system for declarative information extraction. SIGMOD Record, 37(4):7–13.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Z Wang</author>
<author>E Michelakis</author>
<author>M J Franklin</author>
<author>M Garofalakis</author>
<author>J M Hellerstein</author>
</authors>
<title>Probabilistic declarative information extraction.</title>
<date>2010</date>
<booktitle>In ICDE.</booktitle>
<contexts>
<context position="3134" citStr="Wang et al., 2010" startWordPosition="459" endWordPosition="462">or Java. Such procedural logic towards IE cannot meet the increasing scalability and usability requirements in the enterprise (Doan et al., 2006; Chiticariu et al., 2010a). Three decades ago, the database community faced similar scalability and expressivity challenges in accessing structured information. The community addressed these problems by introducing a relational algebra formalism and an associated declarative query language SQL. Borrowing ideas from the database community, several systems (Doan and others, 2008; Bohannon and others, 2008; Jain et al., 2009; Krishnamurthy et al., 2008; Wang et al., 2010) have been built in recent years taking an alternative declarative approach to information extraction. Instead of using procedural logic to implement the extraction task, declarative IE systems separate the description of what to extract from how to extract it, allowing the IE developer to build complex extrac109 Proceedings of the ACL-HLT 2011 System Demonstrations, pages 109–114, Portland, Oregon, USA, 21 June 2011. c�2011 Association for Computational Linguistics create view Phone as extract regex /\d{3}-\d{4}/ on D.text as number from Document D; create view Person as extract dictionary ‘f</context>
</contexts>
<marker>Wang, Michelakis, Franklin, Garofalakis, Hellerstein, 2010</marker>
<rawString>D. Z. Wang, E. Michelakis, M. J. Franklin, M. Garofalakis, and J. M. Hellerstein. 2010. Probabilistic declarative information extraction. In ICDE.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>