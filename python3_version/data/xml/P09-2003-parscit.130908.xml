<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000005">
<title confidence="0.866112">
An Earley Parsing Algorithm for Range Concatenation Grammars
</title>
<author confidence="0.697141">
Laura Kallmeyer
</author>
<address confidence="0.640113">
SFB 441
Universit¨at T¨ubingen
72074 T¨ubingen, Germany
</address>
<email confidence="0.987735">
lk@sfs.uni-tuebingen.de
</email>
<author confidence="0.542199">
Wolfgang Maier
</author>
<address confidence="0.329563">
SFB 441
Universit¨at T¨ubingen
72074 T¨ubingen, Germany
</address>
<email confidence="0.475123">
wo.maier@uni-tuebingen.de
</email>
<author confidence="0.541506">
Yannick Parmentier
</author>
<affiliation confidence="0.332142">
CNRS - LORIA
Nancy Universit´e
</affiliation>
<address confidence="0.83836">
54506 Vandœuvre, France
</address>
<email confidence="0.995669">
parmenti@loria.fr
</email>
<sectionHeader confidence="0.997361" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999970916666667">
We present a CYK and an Earley-style
algorithm for parsing Range Concatena-
tion Grammar (RCG), using the deduc-
tive parsing framework. The characteris-
tic property of the Earley parser is that we
use a technique of range boundary con-
straint propagation to compute the yields
of non-terminals as late as possible. Ex-
periments show that, compared to previ-
ous approaches, the constraint propagation
helps to considerably decrease the number
of items in the chart.
</bodyText>
<sectionHeader confidence="0.999382" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.998756794117647">
RCGs (Boullier, 2000) have recently received a
growing interest in natural language processing
(Søgaard, 2008; Sagot, 2005; Kallmeyer et al.,
2008; Maier and Søgaard, 2008). RCGs gener-
ate exactly the class of languages parsable in de-
terministic polynomial time (Bertsch and Neder-
hof, 2001). They are in particular more pow-
erful than linear context-free rewriting systems
(LCFRS) (Vijay-Shanker et al., 1987). LCFRS is
unable to describe certain natural language phe-
nomena that RCGs actually can deal with. One
example are long-distance scrambling phenom-
ena (Becker et al., 1991; Becker et al., 1992).
Other examples are non-semilinear constructions
such as case stacking in Old Georgian (Michaelis
and Kracht, 1996) and Chinese number names
(Radzinski, 1991). Boullier (1999) shows that
RCGs can describe the permutations occurring
with scrambling and the construction of Chinese
number names.
Parsing algorithms for RCG have been intro-
duced by Boullier (2000), who presents a di-
rectional top-down parsing algorithm using pseu-
docode, and Barth´elemy et al. (2001), who add an
oracle to Boullier’s algorithm. The more restricted
class of LCFRS has received more attention con-
cerning parsing (Villemonte de la Clergerie, 2002;
Burden and Ljungl¨of, 2005). This article proposes
new CYK and Earley parsers for RCG, formulat-
ing them in the framework of parsing as deduction
(Shieber et al., 1995). The second section intro-
duces necessary definitions. Section 3 presents a
CYK-style algorithm and Section 4 extends this
with an Earley-style prediction.
</bodyText>
<sectionHeader confidence="0.995633" genericHeader="introduction">
2 Preliminaries
</sectionHeader>
<bodyText confidence="0.999653833333333">
The rules (clauses) of RCGs1 rewrite predicates
ranging over parts of the input by other predicates.
E.g., a clause 5(aXb) —* 5(X) signifies that 5 is
true for a part of the input if this part starts with an
a, ends with a b, and if, furthermore, 5 is also true
for the part between a and b.
</bodyText>
<construct confidence="0.854199111111111">
Definition 1. A RCG G = (N, T, V, P, 5) con-
sists of a) a finite set ofpredicates N with an arity
function dim: N —* N \ {0} where 5 E N is
the start predicate with dim(5) = 1, b) disjoint fi-
nite sets of terminals T and variables V, c) a finite
set P of clauses ψ0 —* ψ1 ... ψm, where m &gt; 0
and each of the ψi, 0 &lt; i &lt; m, is a predicate of
the form Ai(α1, ... , αdim(Ai)) with Ai E N and
αj E (T U V )∗ for 1 &lt; j &lt; dim(Ai).
</construct>
<bodyText confidence="0.679553">
Central to RCGs is the notion of ranges on
strings.
</bodyText>
<construct confidence="0.9745607">
Definition 2. For every w = w1 ... wn with
wi E T (1 &lt; i &lt; n), we define a) Pos(w) =
{0, ... , n}. b) (l, r) E Pos(w) x Pos(w) with
l &lt; r is a range in w. Its yield (l, r)(w) is the
substring wl+1 ... wr. c) For two ranges p1 =
(l1, r1), p2 = (l2, r2): if r1 = l2, then p1 p2 =
(l1, r2); otherwise p1 p2 is undefined. d) A vec-
tor φ = ((x1,y1), ... , (xk, yk)) is a range vector
of dimension k in w if (xi, yi) is a range in w for
1 &lt; i &lt; k. φ(i).l (resp. φ(i).r) denotes then the
</construct>
<footnote confidence="0.994948">
1In this paper, by RCG, we always mean positive RCG,
see Boullier (2000) for details.
</footnote>
<page confidence="0.906364">
9
</page>
<note confidence="0.929536">
Proceedings of the ACL-IJCNLP 2009 Conference Short Papers, pages 9–12,
Suntec, Singapore, 4 August 2009. c�2009 ACL and AFNLP
</note>
<bodyText confidence="0.993527285714286">
first (resp. second) component of the ith element
of 0, that is xi (resp. yi).
In order to instantiate a clause of the grammar,
we need to find ranges for all variables in the
clause and for all occurrences of terminals. For
convenience, we assume the variables in a clause
and the occurrences of terminals to be equipped
with distinct subscript indices, starting with 1 and
ordered from left to right (where for variables,
only the first occurrence is relevant for this order).
We introduce a function Υ : P → N that gives the
maximal index in a clause, and we define Υ(c, x)
for a given clause c and x a variable or an occur-
rence of a terminal as the index of x in c.
</bodyText>
<construct confidence="0.651363888888889">
Definition 3. An instantiation of a c ∈ P with
Υ(c) = j w.r.t. to some string w is given by a
range vector 0 of dimension j. Applying 0 to
a predicate A(a) in c maps all occurrences of
x ∈ (T ∪ V ) with Υ(c, x) = i in α� to 0(i). If
the result is defined (i.e., the images of adjacent
variables can be concatenated), it is called an in-
stantiated predicate and the result of applying 0 to
all predicates in c, if defined, is called an instanti-
</construct>
<bodyText confidence="0.889019905660378">
ated clause.
We also introduce range constraint vectors, vec-
tors of pairs of range boundary variables together
with a set of constraints on these variables.
Definition 4. Let Vr = {r1, r2,... } be a set
of range boundary variables. A range constraint
vector of dimension k is a pair hp, Ci where a)
p� ∈
(Vr2)k; we define Vr(pl as the set of range
boundary variables occurring in &apos;p. b) C is a set
of constraints cr that have one of the following
forms: r1 = r2, k = r1, r1 + k = r2,
k ≤ r1, r1 ≤ k, r1 ≤ r2 or r1 + k ≤ r2
for r1, r2 ∈ Vr(pJ and k ∈ N.
We say that a range vector 0 satisfies a range
constraint vector hp, Ci iff 0 and p are of the same
dimension k and there is a function f : Vr → N
that maps p(i).l to 0(i).l and p(i).r to 0(i).r for
all 1 ≤ i ≤ k such that all constraints in C are sat-
isfied. Furthermore, we say that a range constraint
vector hp, Ci is satisfiable iff there exists a range
vector 0 that satisfies it.
Definition 5. For every clause c, we define its
range constraint vector hp, Ci w.r.t. a w with |w |=
n as follows: a) p has dimension Υ(c) and all
range boundary variables in p are pairwise differ-
ent. b) For all hr1, r2i ∈ p: 0 ≤ r1, r1 ≤ r2,
r2 ≤ n ∈ C. For all occurrences x of terminals
in c with i = Υ(c, x): p(i).l+1 = p(i).r ∈ C. For
all x, y that are variables or occurrences of termi-
nals in c such that xy is a substring of one of the
arguments in c: p(Υ(c, x)).r = p(Υ(c, y)).l ∈ C.
These are all constraints in C.
The range constraint vector of a clause c cap-
tures all information about boundaries forming a
range, ranges containing only a single terminal,
and adjacent variables/terminal occurrences in c.
An RCG derivation consists of rewriting in-
stantiated predicates applying instantiated clauses,
i.e. in every derivation step Γ1 ⇒w Γ2, we re-
place the lefthand side of an instantiated clause
with its righthand side (w.r.t. a word w). The lan-
guage of an RCG G is the set of strings that can
be reduced to the empty word: L(G) = {w |
S(h0, |w|i) +⇒G,w E}.
The expressive power of RCG lies beyond mild
context-sensitivity. As an example, consider the
RCG from Fig. 3 that generates a language that is
not semilinear.
For simplicity, we assume in the following with-
out loss of generality that empty arguments (E)
occur only in clauses whose righthand sides are
empty.2
</bodyText>
<sectionHeader confidence="0.998512" genericHeader="method">
3 Directional Bottom-Up Chart Parsing
</sectionHeader>
<bodyText confidence="0.999985428571429">
In our directional CYK algorithm, we move a dot
through the righthand side of a clause. We there-
fore have passive items [A, 0] where A is a pred-
icate and 0 a range vector of dimension dim(A)
and active items. In the latter, while traversing
the righthand side of the clause, we keep a record
of the left and right boundaries already found
for variables and terminal occurrences. This is
achieved by subsequently enriching the range con-
straint vector of the clause. Active items have the
form [A(x) → Φ • Ψ, hp, Ci] with A(x) → ΦΨ a
clause, ΦΨ =6 E, Υ(A(x → ΦΨ)) = j and hp, Ci
a range constraint vector of dimension j. We re-
quire that hp, Ci be satisfiable.3
</bodyText>
<footnote confidence="0.889811">
2Any RCG can be easily transformed into an RCG satis-
fying this condition: Introduce a new unary predicate Eps
with a clause Eps(ε) → ε. Then, for every clause c with
righthand side not ε, replace every argument ε that occurs in
c with a new variable X (each time a distinct one) and add
the predicate Eps(X) to the righthand side of c.
3Items that are distinguished from each other only by a bi-
jection of the range variables are considered equivalent. I.e.,
if the application of a rule yields a new item such that an
equivalent one has already been generated, this new one is
not added to the set of partial results.
</footnote>
<page confidence="0.916494">
10
</page>
<equation confidence="0.993828411764706">
A(�x) → ε ∈ P with instantiation ψ
Scan:
[A, 0] such that ψ(A(x)) = A(0)
A(x) → Φ ∈ P with
Initialize: [A(x) → •Φ, hp, Ci] range constraint vector
hp, Ci, Φ =6 ε
Complete:
[B, 0B],
[A(x) → Φ • B(x1...y1, ..., xk...yk)Ψ, hp, Ci]
[A(x) → ΦB(x1...y1, ..., xk...yk) • Ψ, hp, C0i]
where C0 = C ∪ {0B(j).l = p(Υ(xj)).l, 0B(j).r =
p(Υ(yj)).r  |1 ≤ j ≤ k}.
A(x) → Ψ ∈ P with
an instantiation ψ that
satisfies hp, Ci,
ψ(A(x)) = A(0)
Goal: [S, (h0, ni)]
</equation>
<figureCaption confidence="0.998094">
Figure 1: CYK deduction rules
</figureCaption>
<bodyText confidence="0.999986571428571">
The deduction rules are shown in Fig. 1. The
first rule scans the yields of terminating clauses.
Initialize introduces clauses with the dot on the
left of the righthand side. Complete moves the dot
over a predicate provided a corresponding passive
item has been found. Convert turns an active item
with the dot at the end into a passive item.
</bodyText>
<sectionHeader confidence="0.988519" genericHeader="method">
4 The Earley Algorithm
</sectionHeader>
<bodyText confidence="0.985806972222222">
We now add top-down prediction to our algorithm.
Active items are as above. Passive items have
an additional flag p or c depending on whether
the item is predicted or completed, i.e., they ei-
ther have the form [A, (ρ, C), p] where (ρ, C) is a
range constraint vector of dimension dim(A), or
the form [A, 0, c] where 0 is a range vector of di-
mension dim(A).
axiom is the prediction of an 5 ranging over the
entire input (initialize). We have two predict op-
erations: Predict-rule predicts active items with
the dot on the left of the righthand side, for a
given predicted passive item. Predict-pred pre-
dicts a passive item for the predicate following the
dot in an active item. Scan is applied whenever a
predicted predicate can be derived by an e-clause.
The rules complete and convert are the ones from
the CYK algorithm except that we add flags c to
the passive items occurring in these rules. The
goal is again [5, ((0, n)), c].
To understand how this algorithm works, con-
sider the example in Fig. 3. The crucial property of
this algorithm, in contrast to previous approaches,
is the dynamic updating of a set of constraints on
range boundaries. We can leave range boundaries
unspecified and compute their values in a more in-
cremental fashion instead of guessing all ranges of
a clause at once at prediction.4
For evaluation, we have implemented a direc-
tional top-down algorithm where range bound-
aries are guessed at prediction (this is essentially
the algorithm described in Boullier (2000)), and
the new Earley-style algorithm. The algorithms
were tested on different words of the language
L = {a2n|n &lt; 01. Table 1 shows the number
of generated items.
</bodyText>
<figure confidence="0.978812666666667">
Word Earley TD
100 539
155 1666
185 1894
350 6969
Convert: [A, 0]
[A(x) → Ψ•, hp, Ci]
Word
Earley TD
a2
15 21
a4
30 55
as
55 164
a9
59 199
a16
a30
a32
a64
</figure>
<tableCaption confidence="0.998266">
Table 1: Items generated by both algorithms
</tableCaption>
<equation confidence="0.958892">
Initialize: [S, h(hr1, r2i), {0 = r1, n = r2}i, p]
Predict-rule:
[A, hp, Ci, p]
[A(x1 ... y1, ... , xk ... yk) → •Ψ, hp0, C0i]
</equation>
<bodyText confidence="0.994627333333333">
where hp0, C0i is obtained from the range constraint vector
of the clause A(x1 ... y1, ... , xk ... yk) → Ψ by taking all
constraints from C, mapping all p(i).l to p0(Υ(xi)).l and
all p(i).r to p0(Υ(yi)).r, and then adding the resulting con-
straints to the range constraint vector of the clause.
Predict-pred:
</bodyText>
<equation confidence="0.8616015">
[A(...) → Φ • B(x1...y1, ..., xk...yk)Ψ, hp, Ci]
[B, hp0, C0i, p]
</equation>
<bodyText confidence="0.697404">
where p0(i).l = p(Υ(xi)).l, p0(i).r = p(Υ(yi)).r for all
</bodyText>
<figure confidence="0.4980795">
1 ≤ i ≤ k and C0 = {c  |c ∈ C, c contains only range
variables from p0}.
Scan: [A, hp, Ci, p]
[A, 0, c]
</figure>
<figureCaption confidence="0.998122">
Figure 2: Earley deduction rules
</figureCaption>
<bodyText confidence="0.9971786">
The deduction rules are listed in Fig. 2. The
Clearly, range boundary constraint propagation
increases the amount of information transported
in single items and thereby decreases considerably
the number of generated items.
</bodyText>
<sectionHeader confidence="0.963591" genericHeader="conclusions">
5 Conclusion and future work
</sectionHeader>
<bodyText confidence="0.874054071428571">
We have presented a new CYK and Earley pars-
ing algorithms for the full class of RCG. The cru-
cial difference between previously proposed top-
down RCG parsers and the new Earley-style algo-
rithm is that while the former compute all clause
instantiations during predict operations, the latter
4Of course, the use of constraints makes comparisons be-
tween items more complex and more expensive which means
that for an efficient implementation, an integer-based repre-
sentation of the constraints and adequate techniques for con-
straint solving are required.
A(x) → ε ∈ P with an
instantiation ψ satisfying hp, Ci
such that ψ(A(x)) = A(0)
</bodyText>
<page confidence="0.83765">
11
</page>
<figure confidence="0.976507941176471">
Grammar for {a294  |n &gt; 0}: S(XY ) → S(X)eq(X, Y ), S(a1) → ε, eq(a1X, a2Y ) → eq(X, Y ), eq(a1, a2) → ε
Parsing trace for w = aa:
Item Rule
1 [S, h(hr1, r2i), {0 = r1, r1 ≤ r2, 2 = r2}i, p] initialize
2 [S(XY ) → •S(X)eq(X, Y ), {X.l ≤ X.r, X.r = Y.l, Y.l ≤ Y.r, 0 = X.l, 2 = Y.r}] predict-rule from 1
3 [S, h(hr1, r2i), {0 = r1, r1 ≤ r2}i, p] predict-pred from 2
4 [S, (h0, 1i), c] scan from 3
5 [S(XY ) → •S(X)eq(X, Y ), {X.l ≤ X.r, X.r = Y.l, Y.l ≤ Y.r, 0 = X.l, }] predict-rule from 3
6 [S(XY ) → S(X) • eq(X, Y ), {... ,0 = X.l, 2 = Y.r, 1 = X.r}] complete 2 with 4
7 [S(XY ) → S(X) • eq(X, Y ), {X.l ≤ X.r, X.r = Y.l, Y.l ≤ Y.r, 0 = X.l, 1 = X.r}] complete 5 with 4
8 [eq, h(hr1, r2i, hr3, rqi), {r1 ≤ r2, r2 = r3, r3 ≤ rq, 0 = r1, 2 = rq, 1 = r2}i] predict-pred from 6
9 [eq(a1X, a2Y ) → •eq(X, Y ), {a1.l + 1 = a1.r, a1.r = X.l, X.l ≤ X.r,
a2.l + 1 = a2.r, a2.r = Y.l, Y.l ≤ Y.r, X.r = a2.l, 0 = a1.l, 1 = X.r, 2 = Y.r}] predict-rule from 8
. . .
10 [eq, (h0, 1i, h1, 2i), c] scan 8
11 [S(XY ) → S(X)eq(X, Y )•, {... ,0 = X.l, 2 = Y.r, 1 = X.r, 1 = Y.l}] complete 6 with 10
12 [S, (h0, 2i), c] convert 11
</figure>
<figureCaption confidence="0.999974">
Figure 3: Trace of a sample Earley parse
</figureCaption>
<bodyText confidence="0.999969083333333">
avoids this using a technique of dynamic updating
of a set of constraints on range boundaries. Exper-
iments show that this significantly decreases the
number of generated items, which confirms that
range boundary constraint propagation is a viable
method for a lazy computation of ranges.
The Earley parser could be improved by allow-
ing to process the predicates of the righthand sides
of clauses in any order, not necessarily from left
to right. This way, one could process predicates
whose range boundaries are better known first. We
plan to include this strategy in future work.
</bodyText>
<sectionHeader confidence="0.999146" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999639054545454">
Franc¸ois Barth´elemy, Pierre Boullier, Philippe De-
schamp, and ´Eric de la Clergerie. 2001. Guided
parsing of Range Concatenation Languages. In Pro-
ceedings of ACL, pages 42–49.
Tilman Becker, Aravind K. Joshi, and Owen Rambow.
1991. Long-distance scrambling and tree adjoining
grammars. In Proceedings of EACL.
Tilman Becker, Owen Rambow, and Michael Niv.
1992. The Derivationel Generative Power of Formal
Systems or Scrambling is Beyond LCFRS. Tech-
nical Report IRCS-92-38, Institute for Research in
Cognitive Science, University of Pennsylvania.
E. Bertsch and M.-J. Nederhof. 2001. On the complex-
ity of some extensions of RCG parsing. In Proceed-
ings of IWPT 2001, pages 66–77, Beijing, China.
Pierre Boullier. 1999. Chinese numbers, mix, scram-
bling, and range concatenation grammars. In Pro-
ceedings of EACL, pages 53–60, Bergen, Norway.
Pierre Boullier. 2000. Range concatenation grammars.
In Proceedings of IWPT 2000, pages 53–64, Trento.
H˚akan Burden and Peter Ljungl¨of. 2005. Parsing lin-
ear context-free rewriting systems. In Proceedings
of IWPT 2005, pages 11–17, Vancouver.
Laura Kallmeyer, Timm Lichte, Wolfgang Maier, Yan-
nick Parmentier, and Johannes Dellert. 2008. De-
veloping an MCTAG for German with an RCG-
based parser. In Proceedings of LREC-2008, Mar-
rakech, Morocco.
Wolfgang Maier and Anders Søgaard. 2008. Tree-
banks and mild context-sensitivity. In Proceedings
of the 13th Conference on Formal Grammar 2008,
Hamburg, Germany.
Jens Michaelis and Marcus Kracht. 1996. Semilinear-
ity as a Syntactic Invariant. In Logical Aspects of
Computational Linguistics, Nancy.
Daniel Radzinski. 1991. Chinese number-names, tree
adjoining languages, and mild context-sensitivity.
Computational Linguistics, 17:277–299.
Benoit Sagot. 2005. Linguistic facts as predicates over
ranges of the sentence. In Proceedings of LACL 05,
number 3492 in Lecture Notes in Computer Science,
pages 271–286, Bordeaux, France. Springer.
Stuart M. Shieber, Yves Schabes, and Fernando C. N.
Pereira. 1995. Principles and implementation of
deductive parsing. Journal of Logic Programming,
24(1&amp; 2):3–36.
Anders Søgaard. 2008. Range concatenation gram-
mars for translation. In Proceedings of COLING,
Manchester, England.
K. Vijay-Shanker, David Weir, and Aravind Joshi.
1987. Characterising structural descriptions used by
various formalisms. In Proceedings of ACL.
Eric Villemonte de la Clergerie. 2002. Parsing mildly
context-sensitive languages with thread automata.
In Proceedings of COLING, Taipei, Taiwan.
</reference>
<page confidence="0.998455">
12
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.267540">
<title confidence="0.999776">An Earley Parsing Algorithm for Range Concatenation Grammars</title>
<author confidence="0.999806">Laura Kallmeyer</author>
<affiliation confidence="0.7860735">SFB 441 Universit¨at T¨ubingen</affiliation>
<address confidence="0.999675">72074 T¨ubingen, Germany</address>
<email confidence="0.999222">lk@sfs.uni-tuebingen.de</email>
<author confidence="0.977756">Wolfgang Maier</author>
<affiliation confidence="0.742394">SFB 441 Universit¨at T¨ubingen</affiliation>
<address confidence="0.999619">72074 T¨ubingen, Germany</address>
<email confidence="0.999054">wo.maier@uni-tuebingen.de</email>
<author confidence="0.9975">Yannick Parmentier</author>
<affiliation confidence="0.990289">CNRS - LORIA Nancy Universit´e</affiliation>
<address confidence="0.999274">54506 Vandœuvre, France</address>
<email confidence="0.997209">parmenti@loria.fr</email>
<abstract confidence="0.996985307692308">We present a CYK and an Earley-style algorithm for parsing Range Concatenation Grammar (RCG), using the deductive parsing framework. The characteristic property of the Earley parser is that we use a technique of range boundary constraint propagation to compute the yields of non-terminals as late as possible. Experiments show that, compared to previous approaches, the constraint propagation helps to considerably decrease the number of items in the chart.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Franc¸ois Barth´elemy</author>
<author>Pierre Boullier</author>
<author>Philippe Deschamp</author>
<author>´Eric de la Clergerie</author>
</authors>
<title>Guided parsing of Range Concatenation Languages.</title>
<date>2001</date>
<booktitle>In Proceedings of ACL,</booktitle>
<pages>42--49</pages>
<marker>Barth´elemy, Boullier, Deschamp, Clergerie, 2001</marker>
<rawString>Franc¸ois Barth´elemy, Pierre Boullier, Philippe Deschamp, and ´Eric de la Clergerie. 2001. Guided parsing of Range Concatenation Languages. In Proceedings of ACL, pages 42–49.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tilman Becker</author>
<author>Aravind K Joshi</author>
<author>Owen Rambow</author>
</authors>
<title>Long-distance scrambling and tree adjoining grammars.</title>
<date>1991</date>
<booktitle>In Proceedings of EACL.</booktitle>
<contexts>
<context position="1405" citStr="Becker et al., 1991" startWordPosition="200" endWordPosition="203">ber of items in the chart. 1 Introduction RCGs (Boullier, 2000) have recently received a growing interest in natural language processing (Søgaard, 2008; Sagot, 2005; Kallmeyer et al., 2008; Maier and Søgaard, 2008). RCGs generate exactly the class of languages parsable in deterministic polynomial time (Bertsch and Nederhof, 2001). They are in particular more powerful than linear context-free rewriting systems (LCFRS) (Vijay-Shanker et al., 1987). LCFRS is unable to describe certain natural language phenomena that RCGs actually can deal with. One example are long-distance scrambling phenomena (Becker et al., 1991; Becker et al., 1992). Other examples are non-semilinear constructions such as case stacking in Old Georgian (Michaelis and Kracht, 1996) and Chinese number names (Radzinski, 1991). Boullier (1999) shows that RCGs can describe the permutations occurring with scrambling and the construction of Chinese number names. Parsing algorithms for RCG have been introduced by Boullier (2000), who presents a directional top-down parsing algorithm using pseudocode, and Barth´elemy et al. (2001), who add an oracle to Boullier’s algorithm. The more restricted class of LCFRS has received more attention concer</context>
</contexts>
<marker>Becker, Joshi, Rambow, 1991</marker>
<rawString>Tilman Becker, Aravind K. Joshi, and Owen Rambow. 1991. Long-distance scrambling and tree adjoining grammars. In Proceedings of EACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tilman Becker</author>
<author>Owen Rambow</author>
<author>Michael Niv</author>
</authors>
<title>The Derivationel Generative Power of Formal Systems or Scrambling is Beyond LCFRS.</title>
<date>1992</date>
<tech>Technical Report IRCS-92-38,</tech>
<institution>Institute for Research in Cognitive Science, University of Pennsylvania.</institution>
<contexts>
<context position="1427" citStr="Becker et al., 1992" startWordPosition="204" endWordPosition="207">hart. 1 Introduction RCGs (Boullier, 2000) have recently received a growing interest in natural language processing (Søgaard, 2008; Sagot, 2005; Kallmeyer et al., 2008; Maier and Søgaard, 2008). RCGs generate exactly the class of languages parsable in deterministic polynomial time (Bertsch and Nederhof, 2001). They are in particular more powerful than linear context-free rewriting systems (LCFRS) (Vijay-Shanker et al., 1987). LCFRS is unable to describe certain natural language phenomena that RCGs actually can deal with. One example are long-distance scrambling phenomena (Becker et al., 1991; Becker et al., 1992). Other examples are non-semilinear constructions such as case stacking in Old Georgian (Michaelis and Kracht, 1996) and Chinese number names (Radzinski, 1991). Boullier (1999) shows that RCGs can describe the permutations occurring with scrambling and the construction of Chinese number names. Parsing algorithms for RCG have been introduced by Boullier (2000), who presents a directional top-down parsing algorithm using pseudocode, and Barth´elemy et al. (2001), who add an oracle to Boullier’s algorithm. The more restricted class of LCFRS has received more attention concerning parsing (Villemon</context>
</contexts>
<marker>Becker, Rambow, Niv, 1992</marker>
<rawString>Tilman Becker, Owen Rambow, and Michael Niv. 1992. The Derivationel Generative Power of Formal Systems or Scrambling is Beyond LCFRS. Technical Report IRCS-92-38, Institute for Research in Cognitive Science, University of Pennsylvania.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Bertsch</author>
<author>M-J Nederhof</author>
</authors>
<title>On the complexity of some extensions of RCG parsing.</title>
<date>2001</date>
<booktitle>In Proceedings of IWPT</booktitle>
<pages>66--77</pages>
<location>Beijing, China.</location>
<contexts>
<context position="1117" citStr="Bertsch and Nederhof, 2001" startWordPosition="155" endWordPosition="159">e characteristic property of the Earley parser is that we use a technique of range boundary constraint propagation to compute the yields of non-terminals as late as possible. Experiments show that, compared to previous approaches, the constraint propagation helps to considerably decrease the number of items in the chart. 1 Introduction RCGs (Boullier, 2000) have recently received a growing interest in natural language processing (Søgaard, 2008; Sagot, 2005; Kallmeyer et al., 2008; Maier and Søgaard, 2008). RCGs generate exactly the class of languages parsable in deterministic polynomial time (Bertsch and Nederhof, 2001). They are in particular more powerful than linear context-free rewriting systems (LCFRS) (Vijay-Shanker et al., 1987). LCFRS is unable to describe certain natural language phenomena that RCGs actually can deal with. One example are long-distance scrambling phenomena (Becker et al., 1991; Becker et al., 1992). Other examples are non-semilinear constructions such as case stacking in Old Georgian (Michaelis and Kracht, 1996) and Chinese number names (Radzinski, 1991). Boullier (1999) shows that RCGs can describe the permutations occurring with scrambling and the construction of Chinese number na</context>
</contexts>
<marker>Bertsch, Nederhof, 2001</marker>
<rawString>E. Bertsch and M.-J. Nederhof. 2001. On the complexity of some extensions of RCG parsing. In Proceedings of IWPT 2001, pages 66–77, Beijing, China.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Pierre Boullier</author>
</authors>
<title>Chinese numbers, mix, scrambling, and range concatenation grammars.</title>
<date>1999</date>
<booktitle>In Proceedings of EACL,</booktitle>
<pages>53--60</pages>
<location>Bergen,</location>
<contexts>
<context position="1603" citStr="Boullier (1999)" startWordPosition="230" endWordPosition="231">gaard, 2008). RCGs generate exactly the class of languages parsable in deterministic polynomial time (Bertsch and Nederhof, 2001). They are in particular more powerful than linear context-free rewriting systems (LCFRS) (Vijay-Shanker et al., 1987). LCFRS is unable to describe certain natural language phenomena that RCGs actually can deal with. One example are long-distance scrambling phenomena (Becker et al., 1991; Becker et al., 1992). Other examples are non-semilinear constructions such as case stacking in Old Georgian (Michaelis and Kracht, 1996) and Chinese number names (Radzinski, 1991). Boullier (1999) shows that RCGs can describe the permutations occurring with scrambling and the construction of Chinese number names. Parsing algorithms for RCG have been introduced by Boullier (2000), who presents a directional top-down parsing algorithm using pseudocode, and Barth´elemy et al. (2001), who add an oracle to Boullier’s algorithm. The more restricted class of LCFRS has received more attention concerning parsing (Villemonte de la Clergerie, 2002; Burden and Ljungl¨of, 2005). This article proposes new CYK and Earley parsers for RCG, formulating them in the framework of parsing as deduction (Shie</context>
</contexts>
<marker>Boullier, 1999</marker>
<rawString>Pierre Boullier. 1999. Chinese numbers, mix, scrambling, and range concatenation grammars. In Proceedings of EACL, pages 53–60, Bergen, Norway.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Pierre Boullier</author>
</authors>
<title>Range concatenation grammars.</title>
<date>2000</date>
<booktitle>In Proceedings of IWPT 2000,</booktitle>
<pages>53--64</pages>
<location>Trento.</location>
<contexts>
<context position="849" citStr="Boullier, 2000" startWordPosition="117" endWordPosition="118">er@uni-tuebingen.de Yannick Parmentier CNRS - LORIA Nancy Universit´e 54506 Vandœuvre, France parmenti@loria.fr Abstract We present a CYK and an Earley-style algorithm for parsing Range Concatenation Grammar (RCG), using the deductive parsing framework. The characteristic property of the Earley parser is that we use a technique of range boundary constraint propagation to compute the yields of non-terminals as late as possible. Experiments show that, compared to previous approaches, the constraint propagation helps to considerably decrease the number of items in the chart. 1 Introduction RCGs (Boullier, 2000) have recently received a growing interest in natural language processing (Søgaard, 2008; Sagot, 2005; Kallmeyer et al., 2008; Maier and Søgaard, 2008). RCGs generate exactly the class of languages parsable in deterministic polynomial time (Bertsch and Nederhof, 2001). They are in particular more powerful than linear context-free rewriting systems (LCFRS) (Vijay-Shanker et al., 1987). LCFRS is unable to describe certain natural language phenomena that RCGs actually can deal with. One example are long-distance scrambling phenomena (Becker et al., 1991; Becker et al., 1992). Other examples are n</context>
<context position="3711" citStr="Boullier (2000)" startWordPosition="658" endWordPosition="659">&lt; dim(Ai). Central to RCGs is the notion of ranges on strings. Definition 2. For every w = w1 ... wn with wi E T (1 &lt; i &lt; n), we define a) Pos(w) = {0, ... , n}. b) (l, r) E Pos(w) x Pos(w) with l &lt; r is a range in w. Its yield (l, r)(w) is the substring wl+1 ... wr. c) For two ranges p1 = (l1, r1), p2 = (l2, r2): if r1 = l2, then p1 p2 = (l1, r2); otherwise p1 p2 is undefined. d) A vector φ = ((x1,y1), ... , (xk, yk)) is a range vector of dimension k in w if (xi, yi) is a range in w for 1 &lt; i &lt; k. φ(i).l (resp. φ(i).r) denotes then the 1In this paper, by RCG, we always mean positive RCG, see Boullier (2000) for details. 9 Proceedings of the ACL-IJCNLP 2009 Conference Short Papers, pages 9–12, Suntec, Singapore, 4 August 2009. c�2009 ACL and AFNLP first (resp. second) component of the ith element of 0, that is xi (resp. yi). In order to instantiate a clause of the grammar, we need to find ranges for all variables in the clause and for all occurrences of terminals. For convenience, we assume the variables in a clause and the occurrences of terminals to be equipped with distinct subscript indices, starting with 1 and ordered from left to right (where for variables, only the first occurrence is rele</context>
<context position="10935" citStr="Boullier (2000)" startWordPosition="2035" endWordPosition="2036"> in these rules. The goal is again [5, ((0, n)), c]. To understand how this algorithm works, consider the example in Fig. 3. The crucial property of this algorithm, in contrast to previous approaches, is the dynamic updating of a set of constraints on range boundaries. We can leave range boundaries unspecified and compute their values in a more incremental fashion instead of guessing all ranges of a clause at once at prediction.4 For evaluation, we have implemented a directional top-down algorithm where range boundaries are guessed at prediction (this is essentially the algorithm described in Boullier (2000)), and the new Earley-style algorithm. The algorithms were tested on different words of the language L = {a2n|n &lt; 01. Table 1 shows the number of generated items. Word Earley TD 100 539 155 1666 185 1894 350 6969 Convert: [A, 0] [A(x) → Ψ•, hp, Ci] Word Earley TD a2 15 21 a4 30 55 as 55 164 a9 59 199 a16 a30 a32 a64 Table 1: Items generated by both algorithms Initialize: [S, h(hr1, r2i), {0 = r1, n = r2}i, p] Predict-rule: [A, hp, Ci, p] [A(x1 ... y1, ... , xk ... yk) → •Ψ, hp0, C0i] where hp0, C0i is obtained from the range constraint vector of the clause A(x1 ... y1, ... , xk ... yk) → Ψ by </context>
</contexts>
<marker>Boullier, 2000</marker>
<rawString>Pierre Boullier. 2000. Range concatenation grammars. In Proceedings of IWPT 2000, pages 53–64, Trento.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H˚akan Burden</author>
<author>Peter Ljungl¨of</author>
</authors>
<title>Parsing linear context-free rewriting systems.</title>
<date>2005</date>
<booktitle>In Proceedings of IWPT</booktitle>
<pages>11--17</pages>
<location>Vancouver.</location>
<marker>Burden, Ljungl¨of, 2005</marker>
<rawString>H˚akan Burden and Peter Ljungl¨of. 2005. Parsing linear context-free rewriting systems. In Proceedings of IWPT 2005, pages 11–17, Vancouver.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Laura Kallmeyer</author>
<author>Timm Lichte</author>
<author>Wolfgang Maier</author>
<author>Yannick Parmentier</author>
<author>Johannes Dellert</author>
</authors>
<title>Developing an MCTAG for German with an RCGbased parser.</title>
<date>2008</date>
<booktitle>In Proceedings of LREC-2008,</booktitle>
<location>Marrakech, Morocco.</location>
<contexts>
<context position="974" citStr="Kallmeyer et al., 2008" startWordPosition="133" endWordPosition="136">ct We present a CYK and an Earley-style algorithm for parsing Range Concatenation Grammar (RCG), using the deductive parsing framework. The characteristic property of the Earley parser is that we use a technique of range boundary constraint propagation to compute the yields of non-terminals as late as possible. Experiments show that, compared to previous approaches, the constraint propagation helps to considerably decrease the number of items in the chart. 1 Introduction RCGs (Boullier, 2000) have recently received a growing interest in natural language processing (Søgaard, 2008; Sagot, 2005; Kallmeyer et al., 2008; Maier and Søgaard, 2008). RCGs generate exactly the class of languages parsable in deterministic polynomial time (Bertsch and Nederhof, 2001). They are in particular more powerful than linear context-free rewriting systems (LCFRS) (Vijay-Shanker et al., 1987). LCFRS is unable to describe certain natural language phenomena that RCGs actually can deal with. One example are long-distance scrambling phenomena (Becker et al., 1991; Becker et al., 1992). Other examples are non-semilinear constructions such as case stacking in Old Georgian (Michaelis and Kracht, 1996) and Chinese number names (Radz</context>
</contexts>
<marker>Kallmeyer, Lichte, Maier, Parmentier, Dellert, 2008</marker>
<rawString>Laura Kallmeyer, Timm Lichte, Wolfgang Maier, Yannick Parmentier, and Johannes Dellert. 2008. Developing an MCTAG for German with an RCGbased parser. In Proceedings of LREC-2008, Marrakech, Morocco.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Wolfgang Maier</author>
<author>Anders Søgaard</author>
</authors>
<title>Treebanks and mild context-sensitivity.</title>
<date>2008</date>
<booktitle>In Proceedings of the 13th Conference on Formal Grammar</booktitle>
<location>Hamburg, Germany.</location>
<contexts>
<context position="1000" citStr="Maier and Søgaard, 2008" startWordPosition="137" endWordPosition="140">an Earley-style algorithm for parsing Range Concatenation Grammar (RCG), using the deductive parsing framework. The characteristic property of the Earley parser is that we use a technique of range boundary constraint propagation to compute the yields of non-terminals as late as possible. Experiments show that, compared to previous approaches, the constraint propagation helps to considerably decrease the number of items in the chart. 1 Introduction RCGs (Boullier, 2000) have recently received a growing interest in natural language processing (Søgaard, 2008; Sagot, 2005; Kallmeyer et al., 2008; Maier and Søgaard, 2008). RCGs generate exactly the class of languages parsable in deterministic polynomial time (Bertsch and Nederhof, 2001). They are in particular more powerful than linear context-free rewriting systems (LCFRS) (Vijay-Shanker et al., 1987). LCFRS is unable to describe certain natural language phenomena that RCGs actually can deal with. One example are long-distance scrambling phenomena (Becker et al., 1991; Becker et al., 1992). Other examples are non-semilinear constructions such as case stacking in Old Georgian (Michaelis and Kracht, 1996) and Chinese number names (Radzinski, 1991). Boullier (19</context>
</contexts>
<marker>Maier, Søgaard, 2008</marker>
<rawString>Wolfgang Maier and Anders Søgaard. 2008. Treebanks and mild context-sensitivity. In Proceedings of the 13th Conference on Formal Grammar 2008, Hamburg, Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jens Michaelis</author>
<author>Marcus Kracht</author>
</authors>
<title>Semilinearity as a Syntactic Invariant.</title>
<date>1996</date>
<booktitle>In Logical Aspects of Computational Linguistics,</booktitle>
<location>Nancy.</location>
<contexts>
<context position="1543" citStr="Michaelis and Kracht, 1996" startWordPosition="220" endWordPosition="223">essing (Søgaard, 2008; Sagot, 2005; Kallmeyer et al., 2008; Maier and Søgaard, 2008). RCGs generate exactly the class of languages parsable in deterministic polynomial time (Bertsch and Nederhof, 2001). They are in particular more powerful than linear context-free rewriting systems (LCFRS) (Vijay-Shanker et al., 1987). LCFRS is unable to describe certain natural language phenomena that RCGs actually can deal with. One example are long-distance scrambling phenomena (Becker et al., 1991; Becker et al., 1992). Other examples are non-semilinear constructions such as case stacking in Old Georgian (Michaelis and Kracht, 1996) and Chinese number names (Radzinski, 1991). Boullier (1999) shows that RCGs can describe the permutations occurring with scrambling and the construction of Chinese number names. Parsing algorithms for RCG have been introduced by Boullier (2000), who presents a directional top-down parsing algorithm using pseudocode, and Barth´elemy et al. (2001), who add an oracle to Boullier’s algorithm. The more restricted class of LCFRS has received more attention concerning parsing (Villemonte de la Clergerie, 2002; Burden and Ljungl¨of, 2005). This article proposes new CYK and Earley parsers for RCG, for</context>
</contexts>
<marker>Michaelis, Kracht, 1996</marker>
<rawString>Jens Michaelis and Marcus Kracht. 1996. Semilinearity as a Syntactic Invariant. In Logical Aspects of Computational Linguistics, Nancy.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Daniel Radzinski</author>
</authors>
<title>Chinese number-names, tree adjoining languages, and mild context-sensitivity.</title>
<date>1991</date>
<journal>Computational Linguistics,</journal>
<pages>17--277</pages>
<contexts>
<context position="1586" citStr="Radzinski, 1991" startWordPosition="228" endWordPosition="229">2008; Maier and Søgaard, 2008). RCGs generate exactly the class of languages parsable in deterministic polynomial time (Bertsch and Nederhof, 2001). They are in particular more powerful than linear context-free rewriting systems (LCFRS) (Vijay-Shanker et al., 1987). LCFRS is unable to describe certain natural language phenomena that RCGs actually can deal with. One example are long-distance scrambling phenomena (Becker et al., 1991; Becker et al., 1992). Other examples are non-semilinear constructions such as case stacking in Old Georgian (Michaelis and Kracht, 1996) and Chinese number names (Radzinski, 1991). Boullier (1999) shows that RCGs can describe the permutations occurring with scrambling and the construction of Chinese number names. Parsing algorithms for RCG have been introduced by Boullier (2000), who presents a directional top-down parsing algorithm using pseudocode, and Barth´elemy et al. (2001), who add an oracle to Boullier’s algorithm. The more restricted class of LCFRS has received more attention concerning parsing (Villemonte de la Clergerie, 2002; Burden and Ljungl¨of, 2005). This article proposes new CYK and Earley parsers for RCG, formulating them in the framework of parsing a</context>
</contexts>
<marker>Radzinski, 1991</marker>
<rawString>Daniel Radzinski. 1991. Chinese number-names, tree adjoining languages, and mild context-sensitivity. Computational Linguistics, 17:277–299.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Benoit Sagot</author>
</authors>
<title>Linguistic facts as predicates over ranges of the sentence.</title>
<date>2005</date>
<booktitle>In Proceedings of LACL 05, number 3492 in Lecture Notes in Computer Science,</booktitle>
<pages>271--286</pages>
<publisher>Springer.</publisher>
<location>Bordeaux, France.</location>
<contexts>
<context position="950" citStr="Sagot, 2005" startWordPosition="131" endWordPosition="132">ria.fr Abstract We present a CYK and an Earley-style algorithm for parsing Range Concatenation Grammar (RCG), using the deductive parsing framework. The characteristic property of the Earley parser is that we use a technique of range boundary constraint propagation to compute the yields of non-terminals as late as possible. Experiments show that, compared to previous approaches, the constraint propagation helps to considerably decrease the number of items in the chart. 1 Introduction RCGs (Boullier, 2000) have recently received a growing interest in natural language processing (Søgaard, 2008; Sagot, 2005; Kallmeyer et al., 2008; Maier and Søgaard, 2008). RCGs generate exactly the class of languages parsable in deterministic polynomial time (Bertsch and Nederhof, 2001). They are in particular more powerful than linear context-free rewriting systems (LCFRS) (Vijay-Shanker et al., 1987). LCFRS is unable to describe certain natural language phenomena that RCGs actually can deal with. One example are long-distance scrambling phenomena (Becker et al., 1991; Becker et al., 1992). Other examples are non-semilinear constructions such as case stacking in Old Georgian (Michaelis and Kracht, 1996) and Ch</context>
</contexts>
<marker>Sagot, 2005</marker>
<rawString>Benoit Sagot. 2005. Linguistic facts as predicates over ranges of the sentence. In Proceedings of LACL 05, number 3492 in Lecture Notes in Computer Science, pages 271–286, Bordeaux, France. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
<author>Yves Schabes</author>
<author>Fernando C N Pereira</author>
</authors>
<title>Principles and implementation of deductive parsing.</title>
<date>1995</date>
<journal>Journal of Logic Programming,</journal>
<volume>24</volume>
<issue>1</issue>
<pages>2--3</pages>
<contexts>
<context position="2220" citStr="Shieber et al., 1995" startWordPosition="325" endWordPosition="328">999) shows that RCGs can describe the permutations occurring with scrambling and the construction of Chinese number names. Parsing algorithms for RCG have been introduced by Boullier (2000), who presents a directional top-down parsing algorithm using pseudocode, and Barth´elemy et al. (2001), who add an oracle to Boullier’s algorithm. The more restricted class of LCFRS has received more attention concerning parsing (Villemonte de la Clergerie, 2002; Burden and Ljungl¨of, 2005). This article proposes new CYK and Earley parsers for RCG, formulating them in the framework of parsing as deduction (Shieber et al., 1995). The second section introduces necessary definitions. Section 3 presents a CYK-style algorithm and Section 4 extends this with an Earley-style prediction. 2 Preliminaries The rules (clauses) of RCGs1 rewrite predicates ranging over parts of the input by other predicates. E.g., a clause 5(aXb) —* 5(X) signifies that 5 is true for a part of the input if this part starts with an a, ends with a b, and if, furthermore, 5 is also true for the part between a and b. Definition 1. A RCG G = (N, T, V, P, 5) consists of a) a finite set ofpredicates N with an arity function dim: N —* N \ {0} where 5 E N </context>
</contexts>
<marker>Shieber, Schabes, Pereira, 1995</marker>
<rawString>Stuart M. Shieber, Yves Schabes, and Fernando C. N. Pereira. 1995. Principles and implementation of deductive parsing. Journal of Logic Programming, 24(1&amp; 2):3–36.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Anders Søgaard</author>
</authors>
<title>Range concatenation grammars for translation.</title>
<date>2008</date>
<booktitle>In Proceedings of COLING,</booktitle>
<location>Manchester, England.</location>
<contexts>
<context position="937" citStr="Søgaard, 2008" startWordPosition="129" endWordPosition="130">nce parmenti@loria.fr Abstract We present a CYK and an Earley-style algorithm for parsing Range Concatenation Grammar (RCG), using the deductive parsing framework. The characteristic property of the Earley parser is that we use a technique of range boundary constraint propagation to compute the yields of non-terminals as late as possible. Experiments show that, compared to previous approaches, the constraint propagation helps to considerably decrease the number of items in the chart. 1 Introduction RCGs (Boullier, 2000) have recently received a growing interest in natural language processing (Søgaard, 2008; Sagot, 2005; Kallmeyer et al., 2008; Maier and Søgaard, 2008). RCGs generate exactly the class of languages parsable in deterministic polynomial time (Bertsch and Nederhof, 2001). They are in particular more powerful than linear context-free rewriting systems (LCFRS) (Vijay-Shanker et al., 1987). LCFRS is unable to describe certain natural language phenomena that RCGs actually can deal with. One example are long-distance scrambling phenomena (Becker et al., 1991; Becker et al., 1992). Other examples are non-semilinear constructions such as case stacking in Old Georgian (Michaelis and Kracht,</context>
</contexts>
<marker>Søgaard, 2008</marker>
<rawString>Anders Søgaard. 2008. Range concatenation grammars for translation. In Proceedings of COLING, Manchester, England.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shanker</author>
<author>David Weir</author>
<author>Aravind Joshi</author>
</authors>
<title>Characterising structural descriptions used by various formalisms.</title>
<date>1987</date>
<booktitle>In Proceedings of ACL.</booktitle>
<contexts>
<context position="1235" citStr="Vijay-Shanker et al., 1987" startWordPosition="173" endWordPosition="176">compute the yields of non-terminals as late as possible. Experiments show that, compared to previous approaches, the constraint propagation helps to considerably decrease the number of items in the chart. 1 Introduction RCGs (Boullier, 2000) have recently received a growing interest in natural language processing (Søgaard, 2008; Sagot, 2005; Kallmeyer et al., 2008; Maier and Søgaard, 2008). RCGs generate exactly the class of languages parsable in deterministic polynomial time (Bertsch and Nederhof, 2001). They are in particular more powerful than linear context-free rewriting systems (LCFRS) (Vijay-Shanker et al., 1987). LCFRS is unable to describe certain natural language phenomena that RCGs actually can deal with. One example are long-distance scrambling phenomena (Becker et al., 1991; Becker et al., 1992). Other examples are non-semilinear constructions such as case stacking in Old Georgian (Michaelis and Kracht, 1996) and Chinese number names (Radzinski, 1991). Boullier (1999) shows that RCGs can describe the permutations occurring with scrambling and the construction of Chinese number names. Parsing algorithms for RCG have been introduced by Boullier (2000), who presents a directional top-down parsing a</context>
</contexts>
<marker>Vijay-Shanker, Weir, Joshi, 1987</marker>
<rawString>K. Vijay-Shanker, David Weir, and Aravind Joshi. 1987. Characterising structural descriptions used by various formalisms. In Proceedings of ACL.</rawString>
</citation>
<citation valid="true">
<title>Eric Villemonte de la Clergerie.</title>
<date>2002</date>
<booktitle>In Proceedings of COLING,</booktitle>
<location>Taipei, Taiwan.</location>
<marker>2002</marker>
<rawString>Eric Villemonte de la Clergerie. 2002. Parsing mildly context-sensitive languages with thread automata. In Proceedings of COLING, Taipei, Taiwan.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>