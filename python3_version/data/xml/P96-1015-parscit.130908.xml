<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.935087">
Directed Replacement
</title>
<author confidence="0.994161">
Lauri Karttunen
</author>
<affiliation confidence="0.986183">
Rank Xerox Research Centre Grenoble
</affiliation>
<address confidence="0.966256">
6, chemin de Maupertuis
F-38240 MEYLAN, FRANCE
</address>
<email confidence="0.970584">
lauri.karttunenfterox.fr
</email>
<sectionHeader confidence="0.977507" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.99987628">
This paper introduces to the finite-state
calculus a family of directed replace op-
erators. In contrast to the simple re-
place expression, UPPER -&gt; LOWER, defined
in Karttunen (1995), the new directed ver-
sion, UPPER 0-&gt; LOWER, yields an unam-
biguous transducer if the lower language
consists of a single string. It transduces
the input string from left to right, mak-
ing only the longest possible replacement
at each point.
A new type of replacement expression,
UPPER 0-&gt; PREFIX ... SUFFIX, yields a
transducer that inserts text around strings
that are instances of UPPER. The symbol
... denotes the matching part of the input
which itself remains unchanged. PREFIX
and SUFFIX are regular expressions describ-
ing the insertions.
Expressions of the type UPPER 0-&gt; PREFIX
... SUFFIX may be used to compose a de-
terministic parser for a &amp;quot;local grammar&amp;quot; in
the sense of Gross (1989). Other useful ap-
plications of directed replacement include
tokenization and filtering of text streams.
</bodyText>
<sectionHeader confidence="0.997736" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999827714285714">
Transducers compiled from simple replace expres-
sions UPPER -&gt; LOWER (Karttunen 1995, Kempe and
Karttunen 1996) are generally nondeterministic in
the sense that they may yield multiple results even
if the lower language consists of a single string. For
example, let us consider the transducer in Figure 1,
representing ab I b I b a I ab a -&gt; x.1
</bodyText>
<footnote confidence="0.834985666666667">
iThe regular expression formalism and other nota-
tional ainventions used in the paper are explained in the
Appendix at the end.
</footnote>
<figureCaption confidence="0.674349">
Figure 1: ablblbal aba-&gt;x. The
four paths with &amp;quot;aba&amp;quot; on the upper side are:
&lt;0 a 0 b:x 2 a 0&gt;, &lt;0 a 0 b:x 2 a:0 0&gt;,
&lt;0 a:x 1 b:0 2 a 0&gt;, and &lt;0 a:x 1 b:0 2 a:0 0&gt;.
</figureCaption>
<bodyText confidence="0.93797275">
The application of this transducer to the input
&amp;quot;aba&amp;quot; produces four alternate results, &amp;quot;axa&amp;quot;, &amp;quot;ax&amp;quot;,
&amp;quot;xa&amp;quot;, and &amp;quot;x&amp;quot;, as shown in Figure 1, since there are
four paths in the network that contain &amp;quot;aba&amp;quot; on the
upper side with different strings on the lower side.
This nondeterminism arises in two ways. First
of all, a replacement can start at any point. Thus
we get different results for the &amp;quot;oho&amp;quot; depending on
whether we start at the beginning of the string or in
the middle at the &amp;quot;b&amp;quot;. Secondly, there may be alter-
native replacements with the same starting point. In
the beginning of &amp;quot;aba&amp;quot;, we can replace either &amp;quot;ab&amp;quot;
or &amp;quot;aba&amp;quot;. Starting in the middle, we can replace ei-
ther &amp;quot;b&amp;quot; or &amp;quot;ba&amp;quot;. The underlining in Figure 2 shows
aba a ba aba aba
a x a a x x a
</bodyText>
<figureCaption confidence="0.990347">
Figure 2: Four factorizations of &amp;quot;aba&amp;quot;.
</figureCaption>
<bodyText confidence="0.956293166666667">
the four alternate factorizations of the input string,
that is, the four alternate ways to partition the string
&amp;quot;oho&amp;quot; with respect to the upper language of the re-
placement expression. The corresponding paths in
the transducer are listed in Figure 1.
For many applications, it is useful to define an-
</bodyText>
<page confidence="0.998501">
108
</page>
<bodyText confidence="0.9988757">
other version of replacement that produces a unique
outcome whenever the lower language of the rela-
tion consists of a single string. To limit the number
of alternative results to one in such cases, we must
impose a unique factorization on every input.
The desired effect can be obtained by constrain-
ing the directionality and the length of the replace-
ment. Directionality means that the replacement
sites in the input string are selected starting from
the left or from the right, not allowing any overlaps.
The length constraint forces us always to choose the
longest or the shortest replacement whenever there
are multiple candidate strings starting at a given lo-
cation. We use the term directed replacement to
describe a replacement relation that is constrained
by directionality and length of match. (See the end
of Section 2 for a discussion about the choice of the
term.)
With these two kinds of constraints we can define
four types of directed replacement, listed in Figure
</bodyText>
<figure confidence="0.6947188">
3.
longest short est
mat ch match
left-to-right
right-to-left -&gt;@ &gt;02
</figure>
<figureCaption confidence="0.99966">
Figure 3: Directed replacement operators
</figureCaption>
<bodyText confidence="0.996937">
For reasons of space, we discuss here only the left-
to-right, longest-match version. The other cases are
similar.
The effect of the directionality and length con-
straints is that some possible replacements are ig-
nored. For example,ab lb I hal aba(0-&gt;
x maps &amp;quot;aba&amp;quot; uniquely into &amp;quot;x&amp;quot;, Figure 4.
</bodyText>
<figureCaption confidence="0.910061666666667">
Figure 4: abIblbalaba(0-&gt;x. The
single path with &amp;quot;oho&amp;quot; on the upper side is:
&lt;0 a:x 1 b:0 2 a:0 0&gt;.
</figureCaption>
<bodyText confidence="0.999035076923077">
Because we must start from the left and have to
choose the longest match, &amp;quot;aba&amp;quot; must be replaced,
ignoring the possible replacements for &amp;quot;b&amp;quot;, &amp;quot;ba&amp;quot;,
and &amp;quot;ab&amp;quot;. The (4-&gt; operator allows only the last
factorization of &amp;quot;oho&amp;quot; in Figure 2.
Left-to-right, longest-match replacement can be
thought of as a procedure that rewrites an input
string sequentially from left to right. It copies the in-
put until it finds an instance of UPPER. At that point
it selects the longest matching substring, which is
rewritten as LOWER, and proceeds from the end of
that substring without considering any other alter-
natives. Figure 5 illustrates the idea.
</bodyText>
<figureCaption confidence="0.991491">
Figure 5: Left-to-right, longest-match replacement
</figureCaption>
<bodyText confidence="0.999923466666667">
It is not obvious at the outset that the operation
can in fact be encoded as a finite-state transducer
for arbitrary regular patterns. Although a unique
substring is selected for replacement at each point, in
general the transduction is not unambiguous because
LOWER is not required to be a single string; it can be
any regular language.
The idea of treating phonological rewrite rules in
this way was the starting point of Kaplan and Kay
(1994). Their notion of obligatory rewrite rule in-
corporates a directionality constraint. They observe
(p. 358), however, that this constraint does not by
itself guarantee a single output. Kaplan and Kay
suggest that additional restrictions, such as longest-
match, could be imposed to further constrain rule
application.&apos; We consider this issue in more detail.
The crucial observation is that the two con-
straints, left-to-right and longest-match, force a
unique factorization on the input string thus making
the transduction unambiguous if the LOWER language
consists of a single string. In effect, the input string
is unambiguously parsed with respect to the UPPER
language. This property turns out to be important
for a number of applications. Thus it is useful to pro-
vide a replacement operator that implements these
constraints directly.
The definition of the UPPER (0-&gt; LOWER relation is
presented in the next section. Section 3 introduces
a novel type of replace expression for constructing
transducers that unambiguously recognize and mark
</bodyText>
<footnote confidence="0.909859666666667">
2The tentative formulation of the longest-match con-
straint in (Kaplan and Kay, 1994, p. 358) is too weak.
It does not cover all the cases.
</footnote>
<figure confidence="0.982248222222222">
Scan Scan Scan
V
Longest
Match
Copy Replace Copy
Replace Copy
&gt;1 VI
Longest
Match
</figure>
<page confidence="0.99678">
109
</page>
<bodyText confidence="0.998068666666667">
instances of a regular language without actually re-
placing them. Section 4 identifies some useful appli-
cations of the new replacement expressions.
</bodyText>
<sectionHeader confidence="0.970485" genericHeader="method">
2 Directed Replacement
</sectionHeader>
<bodyText confidence="0.99989075">
We define directed replacement by means of a com-
position of regular relations. As in Kaplan and Kay
(1994), Karttunen (1995), and other previous works
on related topics, the intermediate levels of the com-
position introduce auxiliary symbols to express and
enforce constraints on the replacement relation. Fig-
ure 6 shows the component relations and how they
are composed with the input.
</bodyText>
<figure confidence="0.985275777777778">
Input string
.o.
Initial match
.o.
Left-to-right constraint
.o.
Longest-match constraint
.o.
Replacement
</figure>
<figureCaption confidence="0.999995">
Figure 6: Composition of directed replacement
</figureCaption>
<bodyText confidence="0.999831823529412">
If the four relations on the bottom of Figure 6 are
composed in advance, as our compiler does, the ap-
plication of the replacement to an input string takes
place in one step without any intervening levels and
with no auxiliary symbols. But it helps to under-
stand the logic to see where the auxiliary marks
would be in the hypothetical intermediate results.
Let us consider the case of a b I bIbalab
a 0-&gt; x applying to the string &amp;quot;aba&amp;quot; and see in de-
tail how the mapping implemented by the transducer
in Figure 4 is composed from the four component re-
lations. We use three auxiliary symbols, caret (&amp;quot;),
left bracket (&lt;) and right bracket (&gt;), assuming here
that they do not occur in any input. The first step,
shown in Figure 7, composes the input string with a
transducer that inserts a caret, in the beginning of
every substring that belongs to the upper language.
</bodyText>
<figure confidence="0.867824">
a b a
&amp;quot;a&amp;quot; b a
</figure>
<figureCaption confidence="0.627440333333333">
Figure 7: Initial match. Each caret marks the be-
ginning of a substring that matches &amp;quot;ab&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;ba&amp;quot;,
or &amp;quot;aba&amp;quot;.
</figureCaption>
<bodyText confidence="0.995086466666667">
Note that only one is inserted even if there are
several candidate strings starting at the same loca-
tion.
In the left-to-right step, we enclose in angle brack-
ets all the substrings starting at a location marked
by a caret that are instances of the upper language.
The initial caret is replaced by a &lt;, and a closing
&gt; is inserted to mark the end of the match. We
permit carets to appear freely while matching. No
carets are permitted outside the matched substrings
and the ignored internal carets are eliminated. In
this case, there are four possible outcomes, shown
in Figure 8, but only two of them are allowed under
the constraint that there can be no carets outside
the brackets.
</bodyText>
<figure confidence="0.971842">
ALLOWED
&amp;quot;ab a &amp;quot;ab a
&lt;a b &gt; a &lt;a b a&gt;
NOT ALLOWED
&amp;quot;a &amp;quot;b a &amp;quot;ab a
&amp;quot;a &lt;b&gt;a &amp;quot; a &lt; b a&gt;
</figure>
<figureCaption confidence="0.947661">
Figure 8: Left-to-right constraint. No caret outside
a bracketed region.
</figureCaption>
<bodyText confidence="0.97297725">
In effect, no starting location for a replacement
can be skipped over except in the context of an-
other replacement starting further left in the input
string. (Roche and Schabes (1995) introduce a sim-
ilar technique for imposing the left-to-right order on
the transduction.) Note that the four alternatives in
Figure 8 represent the four factorizations in Figure
2.
The longest-match constraint is the identity rela-
tion on a certain set of strings. It forbids any re-
placement that starts at the same location as an-
other, longer replacement. In the case at hand, it
means that the internal &gt; is disallowed in the context
&lt; a b &gt; a. Because &amp;quot;aba&amp;quot; is in the upper language,
there is a longer, and therefore preferred, &lt; a b a &gt;
alternative at the same starting location, Figure 9.
</bodyText>
<sectionHeader confidence="0.675063" genericHeader="method">
ALLOWED NOT ALLOWED
</sectionHeader>
<figure confidence="0.568233">
&lt;a b a&gt; &lt;a b &gt; a
</figure>
<figureCaption confidence="0.680946">
Figure 9: Longest match constraint. No upper lan-
guage string with an initial &lt; and a nonfinal &gt; in
the middle.
</figureCaption>
<bodyText confidence="0.999845833333333">
In the final replacement step, the bracketed re-
gions of the input string, in the case at hand, just
&lt;aba&gt;, are replaced by the strings of the lower
language, yielding &amp;quot;x&amp;quot; as the result for our example.
Note that longest match constraint ignores any
internal brackets. For example, the bracketing &lt; a
</bodyText>
<page confidence="0.876412">
110
</page>
<bodyText confidence="0.967372126760563">
&gt; &lt; a &gt; is not allowed if the upper language con- length-of-match constraints can be encoded with
tains &amp;quot;aa&amp;quot; as well as &amp;quot;a&amp;quot;. Similarly, the left-to-right fewer diacritics. (We believe that the conditional
constraint ignores any internal carets. case can also be handled in a simpler way than in
As the first step towards a formal definition of Kaplan and Kay (1994).) The number of auxiliary
UPPER 0-&gt; LOWER it is useful to make the notion of markers is an important consideration for some of
&amp;quot;ignoring internal brackets&amp;quot; more precise. Figure 10 the applications discussed below.
contains the auxiliary definitions. For the details of In a phonological or morphological rewrite rule,
the formalism (briefly explained in the Appendix), the center part of the rule is typically very small:
please consult Karttunen (1995), Kempe and Kart- a modification, deletion or insertion of a single seg-
tunen (1996).3 ment. On the other hand, in our text processing ap-
UPPER&apos; = UPPER/[&apos;/.] - [?* %-] plications, the upper language may involve a large
UPPER&amp;quot; = UPPER/ [7.&lt;1%&gt;] - C.?* [/&lt;(&apos;/,&gt;J] network representing, for example, a lexicon of mul-
Figure 10: Versions of UPPER that freely allow non- tiword tokens. Practical experience shows that the
final diacritics. presence of many auxiliary diacritics makes it diffi-
The precise definition of the UPPER 0-&gt; LOWER re- cult or impossible to compute the left-to-right and
lation is given in Figure 11. It is a composition of longest-match constraints in such cases. The size of
many auxiliary relations. We label the major com- intermediate states of the computation becomes a
ponents in accordance with the outline in Figure 6. critical issue, while it is irrelevant for simple phono-
The formulation of the longest-match constraint is logical rules. We will return to this issue in the dis-
based on a suggestion by Ronald M. Kaplan (p.c.). cussion of tokenizing transducers in Section 4.
Initial match The transducers derived from the definition in
-SC Y.- I Y.&lt; I %&gt; 3 Figure 11 have the property that they unambigu-
.0. ously parse the input string into a sequence of sub-
C. .3 —&gt; I _UPPER strings that are either copied to the output un-
.o. changed or replaced by some other strings. How-
Left to right ever they do not fall neatly into any standard class
C-$C%-] C%-:%&lt; UPPER&apos; O:7.&gt;]]* -$ Cr] of transducers discussed in the literature (Eilenberg
.o 1974, Schiitzenberger 1977, Berstel 1979). If the
%.** -&gt; 0 LOWER language consists of a single string, then the
.o. relation encoded by the transducer is in Berstel&apos;s
Longest match terms a rational function, and the network is an
-IN&lt; [UPPER&amp;quot; &amp; $EY.&gt;]]] unambigous transducer, even though it may con-
tain states with outgoing transitions to two or more
destinations for the same input symbol. An unam-
biguous transducer may also be sequentiable, in
which case it can be turned into an equivalent se-
quential transducer (Mohri, 1994), which can in
turn be minimized. A transducer is sequential just
in case there are no states with more than one transi-
tion for the same input symbol. Roche and Schabes
(1995) call such transducers deterministic.
Our replacement transducers in general are not
unambiguous because we allow LOWER to be any reg-
ular language. It may well turn out that, in all cases
that are of practical interest, the lower language is in
fact a singleton, or at least some finite set, but it is
not so by definition. Even if the replacement trans-
ducer is unambiguous, it may well be unsequentiable
if UPPER is an infinite language. For example, the
simple transducer for a+ b 0-&gt; x in Figure 12 can-
not be sequentialized. It has to replace any string of
&amp;quot;a&amp;quot;s by &amp;quot;x&amp;quot; or copy it to the output unchanged de-
pending on whether the string eventually terminates
at &amp;quot;b&amp;quot;. It is obviously impossible for any finite-state
.o.
Replacement
Y.&lt; -$[%&gt;] 11.&gt; —&gt; LOWER ;
Figure 11: Definition of UPPER 0-&gt; LOWER
The logic of 0--&gt; replacement could be encoded in
many other ways, for example, by using the three
pairs of auxiliary brackets, &lt;i, &gt;i, &lt;c, &gt;c, and &lt;a,
&gt;a, introduced in Kaplan and Kay (1994). We take
here a more minimalist approach. One reason is
that we prefer to think of the simple unconditional
(uncontexted) replacement as the basic case, as in
Karttunen (1995). Without the additional complex-
ities introduced by contexts, the directionality and
3UPPER&apos; is the same language as UPPER except that
carets may appear freely in all nonfinal positions. Simi-
larly, UPPER&amp;quot; accepts any nonfinal brackets.
111
</bodyText>
<figureCaption confidence="0.7055345">
Figure 12: a+ b 0-&gt; x. This transducer is unam-
biguous but cannot be sequentialized.
</figureCaption>
<bodyText confidence="0.9979212">
device to accumulate an unbounded amount of de-
layed output. On the other hand, the transducer
in Figure 4 is sequentiable because there the choice
between a and a: x just depends on the next input
symbol.
Because none of the classical terms fits exactly, we
have chosen a novel term, directed transduction,
to describe a relation induced by the definition in
Figure 11. It is meant to suggest that the mapping
from the input into the output strings is guided by
the directionality and length-of-match constraints.
Depending on the characteristics of the UPPER and
LOWER languages, the resulting transducers may be
unambiguous and even sequential, but that is not
guaranteed in the general case.
</bodyText>
<sectionHeader confidence="0.998492" genericHeader="method">
3 Insertion
</sectionHeader>
<bodyText confidence="0.999467033333333">
The effect of the left-to-right and longest-match con-
straint is to factor any input string uniquely with
respect to the upper language of the replace expres-
sion, to parse it into a sequence of substrings that
either belong or do not belong to the language. In-
stead of replacing the instances of the upper lan-
guage in the input by other strings, we can also take
advantage of the unique factorization in other ways.
For example, we may insert a string before and after
each substring that is an instance of the language in
question simply to mark it as such.
To implement this idea, we introduce the special
symbol ... on the right-hand side of the replacement
expression to mark the place around which the in-
sertions are to be made. Thus we allow replace-
ment expressions of the form UPPER 0-&gt; PREFIX
... SUFFIX. The corresponding transducer locates
the instances of UPPER in the input string under the
left-to-right, longest-match regimen just described.
But instead of replacing the matched strings, the
transducer just copies them, inserting the specified
prefix and suffix. For the sake of generality, we allow
PREFIX and SUFFIX to denote any regular language.
The definition of UPPER 0-&gt; PREFIX ... SUFFIX
is just as in Figure 11 except that the Replacement
expression is replaced by the Insertion formula in
Figure 13, a simple parallel replacement of the two
auxiliary brackets that mark the selected regions.
Because the placement of &lt; and &gt; is strictly con-
trolled, they do not occur anywhere else.
</bodyText>
<figure confidence="0.615671">
Insertion
%&lt; -&gt; PREFIX, %&gt; -&gt; SUFFIX ;
</figure>
<figureCaption confidence="0.998134">
Figure 13: Insertion expression in the definition of
UPPER 0-&gt; PREFIX ... SUFFIX.
</figureCaption>
<bodyText confidence="0.9996883">
With the ... expressions we can construct trans-
ducers that mark maximal instances of a regular
language. For example, let us assume that noun
phrases consist of an optional determiner, (d), any
number of adjectives, a*, and one or more nouns, n+.
The expression (d) a* n+ 0-&gt; %[ &apos;is] com-
piles into a transducer that inserts brackets around
maximal instances of the noun phrase pattern. For
example, it maps &amp;quot;dannvaan&amp;quot; into &amp;quot; [damn] v[aan]&amp;quot;,
as shown in Figure 14.
</bodyText>
<figure confidence="0.7925135">
dann v aan
[clann] v [a an]
</figure>
<figureCaption confidence="0.9903085">
Figure 14: Application of (d) a* n+ 0-&gt; %E. ..%)
to &amp;quot;dannvaan&amp;quot;
</figureCaption>
<bodyText confidence="0.997297857142857">
Although the input string &amp;quot;dannvaan&amp;quot; contains
many other instances of the noun phrase pattern,
&amp;quot;n&amp;quot;, &amp;quot;an&amp;quot;, &amp;quot;nn&amp;quot;, etc., the left-to-right and longest-
match constraints pick out just the two maximal
ones. The transducer is displayed in Figure 15. Note
that? here matches symbols, such as v, that are not
included in the alphabet of the network.
</bodyText>
<figureCaption confidence="0.828055">
Figure 15: (d) a* n+ 0-&gt; &apos;A C.. . The one path
</figureCaption>
<bodyText confidence="0.8782905">
with &amp;quot;dannvaan&amp;quot; on the upper side is: &lt;0 0: [ 7 d 3
a3n4n40:] 5v00:C7a3a3n40:7 5&gt;.
</bodyText>
<page confidence="0.998272">
112
</page>
<sectionHeader confidence="0.993123" genericHeader="method">
4 Applications
</sectionHeader>
<bodyText confidence="0.999962833333333">
The directed replacement operators have many use-
ful applications. We describe some of them. Al-
though the same results could often be achieved
by using lex and yacc, sed, awk, pen, and other
Unix utilities, there is an advantage in using finite-
state transducers for these tasks because they can
then be smoothly integrated with other finite-state
processes, such as morphological analysis by lexi-
cal transducers (Karttunen et al 1992, Karttunen
1994) and rule-based part-of-speech disambiguation
(Chanod and Tapanainen 1995, Roche and Schabes
1995).
</bodyText>
<subsectionHeader confidence="0.908516">
4.1 Tokenization
</subsectionHeader>
<bodyText confidence="0.9992535">
A tokenizer is a device that segments an input string
into a sequence of tokens. The insertion of end-of-
token marks can be accomplished by a finite-state
transducer that is compiled from tokenization rules.
The tokenization rules may be of several types. For
example, [WFIITE_SPACE+ SPACE] is a normal-
izing transducer that reduces any sequence of tabs,
spaces, and newlines to a single space. [LETTER+
0-&gt; ... END_OF_TOKEN] inserts a special mark,
e.g. a newline, at the end of a letter sequence.
Although a space generally counts as a token
boundary, it can also be part of a multiword to-
ken, as in expressions like &amp;quot;at least&amp;quot;, &amp;quot;head over
heels&amp;quot;, &amp;quot;in spite of&amp;quot;, etc. Thus the rule that intro-
duces the END_OF_TOKEN symbol needs to combine
the LETTER+ pattern with a list of multiword tokens
which may include spaces, periods and other delim-
iters.
</bodyText>
<figureCaption confidence="0.3242665">
Figure 16 outlines the construction of a simple
tokenizing transducer for English.
</figureCaption>
<figure confidence="0.502130444444444">
WHITE%_SPACE+ 0-&gt; SPACE
.o
[ LETTER+ I
at% least I
head% over&apos;!. heels I
in% spit e% ]
END%_OF%_TOKEN
.0.
SPACE -&gt; I I .#. I END%_OF%_TOKEN
</figure>
<figureCaption confidence="0.99774">
Figure 16: A simple tokenizer
</figureCaption>
<bodyText confidence="0.999919717948718">
The tokenizer in Figure 16 is composed of three
transducers. The first reduces strings of whitespace
characters to a single space. The second transducer
inserts an END_OF_TOKEN mark after simple words
and the, listed multiword expressions. The third re-
moves the spaces that are not part of some multi-
word token. The percent sign here means that the
following blank is to be taken literally, that is, parsed
as a symbol.
Without the left-to-right, longest-match con-
straints, the tokenizing transducer would not pro-
duce deterministic output. Note that it must intro-
duce an END_OF_TOKEN mark after a sequence of let-
ters just in case the word is not part of some longer
multiword token. This problem is complicated by
the fact that the list of multiword tokens may con-
tain overlapping expressions. A tokenizer for French,
for example, needs to recognize &amp;quot;de plus&amp;quot; (more-
over), &amp;quot;en plus&amp;quot; (more), &amp;quot;en plus de&amp;quot; (in addition
to), and &amp;quot;de plus en plus&amp;quot; (more and more) as sin-
gle tokens. Thus there is a token boundary after
&amp;quot;de plus&amp;quot; in de plus on ne le fait plus (moreover one
doesn&apos;t do it anymore) but not in on le fait de plus
en plus (one does it more and more) where &amp;quot;de plus
en plus&amp;quot; is a single token.
If the list of multiword tokens contains hundreds
of expressions, it may require a lot of time and space
to compile the tokenizer even if the final result is not
too large. The number of auxiliary symbols used to
encode the constraints has a critical effect on the ef-
ficiency of that computation. We first observed this
phenomenon in the course of building a tokenizer for
the British National Corpus according to the specifi-
cations of the BNC Users Guide (Leech, 1995), which
lists around 300 multiword tokens and 260 foreign
phrases. With the current definition of the directed
replacement we have now been able to compute sim-
ilar tokenizers for several other languages (French,
Spanish, Italian, Portuguese, Dutch, German).
</bodyText>
<subsectionHeader confidence="0.982005">
4.2 Filtering
</subsectionHeader>
<bodyText confidence="0.999985692307692">
Some text processing applications involve a prelimi-
nary stage in which the input stream is divided into
regions that are passed on to the calling process and
regions that are ignored. For example, in processing
an SGML-coded document, we may wish to delete all
the material that appears or does not appear in a
region bounded by certain SGML tags, say &lt;A&gt; and
&lt;/A&gt;.
Both types of filters can easily be constructed us-
ing the directed replace operator. A negative filter
that deletes all the material between the two SGML
codes, including the codes themselves, is expressed
as in Figure 17.
</bodyText>
<figure confidence="0.426095">
&amp;quot;&lt;A&gt;&amp;quot; &amp;quot;$[&amp;quot;&lt;A&gt;&amp;quot; I &amp;quot;&lt;/A&gt;&amp;quot;] &amp;quot;&lt;/A&gt;&amp;quot; @-&gt; ;
</figure>
<figureCaption confidence="0.998478">
Figure 17: A negative filter
</figureCaption>
<bodyText confidence="0.995507">
A positive filter that excludes everything else can
be expressed as in Figure 18.
</bodyText>
<page confidence="0.995821">
113
</page>
<figure confidence="0.9980842">
-$&amp;quot;&lt;/A&gt;&amp;quot; &amp;quot;&lt;A&gt;&amp;quot; 0-&gt; &amp;quot;&lt;A&gt;&amp;quot;
.o.
&amp;quot;&lt;/A&gt;&amp;quot; -$&amp;quot;&lt;A&gt;&amp;quot; 0-&gt; &amp;quot;&lt;/A&gt;&amp;quot; ;
d a. n n V a a n
[NP d a nn] [VP v DIP a a n ] ]
</figure>
<figureCaption confidence="0.999248">
Figure 18: A positive filter
</figureCaption>
<bodyText confidence="0.9998885">
The positive filter is composed of two transducers.
The first reduces to &lt;A&gt; any string that ends with
it and does not contain the &lt;/A&gt; tag. The second
transducer does a similar transduction on strings
that begin with &lt;/A&gt;. Figure 12 illustrates the effect
of the positive filter.
</bodyText>
<figure confidence="0.757633">
&lt;B&gt;one&lt;/B&gt;&lt;A&gt;two&lt;/A&gt;&lt;C&gt;three&lt;/C&gt;&lt;A&gt;four&lt;/A&gt;
</figure>
<figureCaption confidence="0.995743">
Figure 21: Application of an NP-VP parser
</figureCaption>
<bodyText confidence="0.9909435">
By means of this simple &amp;quot;bottom-up&amp;quot; technique,
it is possible to compile finite-state transducers that
approximate a context-free parser up to a chosen
depth of embedding. Of course, the left-to-right,
longest-match regimen implies that some possible
analyses are ignored. To produce all possible parses,
we may introduce the ... notation to the simple re-
place expressions in Karttunen (1995).
</bodyText>
<figure confidence="0.978817">
&lt;A&gt; two &lt;/A&gt; &lt;A&gt;four&lt;/A&gt; 5 Extensions
</figure>
<figureCaption confidence="0.999856">
Figure 19: Application of a positive filter
</figureCaption>
<bodyText confidence="0.9997828">
The idea of filtering by finite-state transduction
of course does not depend on SGML codes. It can
be applied to texts where the interesting and unin-
teresting regions are defined by any kind of regular
pattern.
</bodyText>
<subsectionHeader confidence="0.992815">
4.3 Marking
</subsectionHeader>
<bodyText confidence="0.938824083333333">
As we observed in section 3, by using the ... symbol
on the lower side of the replacement expression, we
can construct transducers that mark instances of a
regular language without changing the text in any
other way. Such transducers have a wide range of
applications. They can be used to locate all kinds of
expressions that can be described by a regular pat-
tern, such as proper names, dates, addresses, social
security and phone numbers, and the like. Such a
marking transducer can be viewed as a deterministic
parser for a &amp;quot;local grammar&amp;quot; in the sense of Gross
(1989), Roche (1993), Silberztein (1993) and others.
By composing two or more marking transduc-
ers, we can also construct a single transducer that
builds nested syntactic structures, up to any desired
depth. To make the construction simpler, we can
start by defining auxiliary symbols for the basic reg-
ular patterns. For example, we may define NP as
[(d) a* n+] . With that abbreviatory convention,
a composition of a simple NP and VP spotter can be
defined as in Figure 20.
NP 0-&gt; &apos;/.[NP ... %]
.o.
v %[NP NP %] @-&gt; &apos;/,[VP ... %] ;
</bodyText>
<figureCaption confidence="0.979013">
Figure 20: Composition of an NP and a VP spotter
</figureCaption>
<bodyText confidence="0.926564538461539">
Figure 21 shows the effect of applying this com-
posite transducer to the string &amp;quot;dannvaan&amp;quot;.
The definition of the left-to-right, longest-match re-
placement can easily be modified for the three other
directed replace operators mentioned in Figure 3.
Another extension, already implemented, is a di-
rected version of parallel replacement (Kempe and
Karttunen 1996), which allows any number of re-
placements to be done simultaneously without in-
terfering with each other. Figure 22 is an example
of a directed parallel replacement. It yields a trans-
ducer that maps a string of &amp;quot;a&amp;quot;s into a single &amp;quot;b&amp;quot;
and a string of &amp;quot;b&amp;quot;s into a single &amp;quot;a&amp;quot;.
</bodyText>
<figure confidence="0.414411">
a+ 0-&gt; b, b+ 0-&gt; a ;
</figure>
<figureCaption confidence="0.981647">
Figure 22: Directed, parallel replacement
</figureCaption>
<bodyText confidence="0.999559333333333">
The definition of directed parallel replacement re-
quires no additions to the techniques already pre-
sented. In the near future we also plan to allow direc-
tional and length-of-match constraints in the more
complicated case of conditional context-constrained
replacement.
</bodyText>
<sectionHeader confidence="0.999215" genericHeader="method">
6 Acknowledgements
</sectionHeader>
<bodyText confidence="0.999931153846154">
I would like to thank Ronald M. Kaplan, Martin
Kay, Andre Kempe, John Maxwell, and Annie Za-
enen for helpful discussions at the beginning of the
project, as well as Paula Newman and Kenneth R.
Beesley for editorial advice on the first draft of the
paper. The work on tokenizers and phrasal analyz-
ers by Anne Schiller and Gregory Grefenstette re-
vealed the need for a more efficient implementation
of the idea. The final version of the paper has bene-
fited from detailed comments by Ronald M. Kaplan
and two anonymous reviewers, who convinced me to
discard the ill-chosen original title (&amp;quot;Deterministic
Replacement&amp;quot;) in favor of the present one.
</bodyText>
<footnote confidence="0.421234">
1 1 4
</footnote>
<sectionHeader confidence="0.651518" genericHeader="conclusions">
7 Appendix: Notational conventions
</sectionHeader>
<bodyText confidence="0.999988931818182">
The regular expression formalism used in this paper
is essentially the same as in Kaplan and Kay (1994),
in Karttunen (1995), and in Kempe and Karttunen
(1996). Upper-case strings, such as UPPER, represent
regular languages, and lower-case letters, such as x,
represent symbols. We recognize two types of sym-
bols: unary symbols (a, b, c, etc) and symbol pairs
(a: x, b:0, etc. ),
A symbol pair a:x may be thought of as the
crossproduct of a and x, the minimal relation con-
sisting of a (the upper symbol) and x (the lower
symbol). To make the notation less cumbersome,
we systematically ignore the distinction between the
language A and the identity relation that maps every
string of A into itself. Consequently, we also write
a:a as just a.
Three special symbols are used in regular expres-
sions: 0 (zero) represents the empty string (often de-
noted by e); ? stands for any symbol in the known
alphabet and its extensions; in replacement expres-
sions, .#. marks the start (left context) or the end
(right context) of a string. The percent sign, %, is
used as an escape character. It allows letters that
have a special meaning in the calculus to be used
as ordinary symbols. Thus %[ denotes the literal
square bracket as opposed to C, which has a special
meaning as a grouping symbol; %0 is the ordinary
zero symbol.
The following simple expressions appear freqently
in the formulas: 0 the empty string language, ?*
the universal (&amp;quot;sigma star&amp;quot;) language.
The regular expression operators used in the pa-
per are: * zero or more (Kleene star), + one or more
(Kleene plus), not (complement), $ contains, /
ignore, I or (union), &amp; and (intersection), - minus
(relative complement), .x . crossproduct, .0. com-
position, -&gt; simple replace.
In the transducer diagrams (Figures 1,4, etc.), the
nonfinal states are represented by single circles, final
states by double circles. State 0 is the initial state.
The symbol ? represents any symbols that are not
explicitly present in the network. Transitions that
differ only with respect to the label are collapsed
into a single multiply labelled arc.
</bodyText>
<sectionHeader confidence="0.999527" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999787690909091">
Jean Berstel. 1979. Transductions and Context-Free
Languages. B.G. Teubner, Stuttgart, Germany.
Jean-Pierre Chanod and Pasi Tapanainen. 1995.
Tagging French—comparing a statistical and a
constraint-based model. In The Proceedings of
the Seventh Conference of the European Chapter
of the Association for Computational Linguistics,
Dublin, Ireland.
Samuel Eilenberg. 1974. Automata, Languages, and
Machines. Academic Press.
Maurice Gross. 1989. The Use of Finite Automata
in the Lexical Representation of Natural Lan-
guage. In Lecture Notes in Computer Science,
pages 34-50, Springer-Verlag, Berlin, Germany.
Ronald M. Kaplan and Martin Kay. 1994. Regular
Models of Phonological Rule Systems. Computa-
tional Linguistics, 20:3, pages 331-378.
Lauri Karttunen, Kimmo Koskenniemi, and Ronald
M. Kaplan. 1987. A Compiler for Two-level
Phonological Rules. In Report No. CSLI-87-108.
Center for the Study of Language and Informa-
tion, Stanford University. Palo Alto, California.
Lauri Karttunen. 1994. Constructing Lexical Trans-
ducers. In The Proceedings of the Fifteenth Inter-
national Conference on Computational Linguis-
tics. Coling 94, I, pages 406-411, Kyoto, Japan.
Lauri Karttunen. 1995, The Replace Operator. In
The Proceedings of the 33rd Annual Meeting of the
Association for Computational Linguistics. ACL-
94, pages 16-23, Boston, Massachusetts.
Andre Kempe and Lauri Karttunen. 1996. Parallel
Replacement in the Finite-State Calculus. In The
Proceedings of the Sixteenth International Con-
ference on Computational Linguistics. Coling 96.
Copenhagen, Denmark.
Geoffrey Leech. 1995. User&apos;s Guide to the British
National Corpus. Lancaster University.
Mehryar Mohri. 1994. On Some Applications of
Finite-State Automata Theory to Natural Lan-
guage Processing. Technical Report 94-22. L&apos;In-
stitute Gaspard Mange. Universite de Marne-la-
Vallee. Noisy Le Grand.
Emmanuel Roche. 1993. Analyse syntaxique trans-
fornzationelle du francais par transducteurs et
lexique-gramrnaire. Doctoral dissertation, Univer-
site Paris 7.
Emmanuel Roche and Yves Schabes. 1995. Deter-
ministic Part-of-Speech Tagging. Computational
Linguistics, 21:2, pages 227-53.
Marcel Paul Schiitzenberger. 1977. Sur une variante
des fonctions sequentielles. Theoretical Computer
Science, 4, pages 47-57.
Max Silberztein. 1993. Dictionnaires Electroniques
et Analyse Lexicale du Francais—Le Systeme IN-
TEX, Masson, Paris, France.
</reference>
<page confidence="0.999025">
115
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.642182">
<title confidence="0.984146">Directed Replacement</title>
<author confidence="0.999821">Lauri Karttunen</author>
<affiliation confidence="0.874081">Rank Xerox Research Centre Grenoble</affiliation>
<address confidence="0.8536935">6, chemin de Maupertuis F-38240 MEYLAN, FRANCE</address>
<email confidence="0.999337">lauri.karttunenfterox.fr</email>
<abstract confidence="0.999363576923077">This paper introduces to the finite-state calculus a family of directed replace operators. In contrast to the simple reexpression, -&gt; LOWER, in Karttunen (1995), the new directed ver- 0-&gt; LOWER, an unambiguous transducer if the lower language consists of a single string. It transduces the input string from left to right, making only the longest possible replacement at each point. A new type of replacement expression, 0-&gt; PREFIX ... SUFFIX, a transducer that inserts text around strings are instances of symbol ... denotes the matching part of the input itself remains unchanged. regular expressions describing the insertions. of the type 0-&gt; PREFIX SUFFIX be used to compose a deterministic parser for a &amp;quot;local grammar&amp;quot; in the sense of Gross (1989). Other useful applications of directed replacement include tokenization and filtering of text streams.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Jean Berstel</author>
</authors>
<title>Transductions and Context-Free Languages.</title>
<date>1979</date>
<publisher>B.G. Teubner,</publisher>
<location>Stuttgart, Germany.</location>
<contexts>
<context position="12934" citStr="Berstel 1979" startWordPosition="2208" endWordPosition="2209">sue in the disbased on a suggestion by Ronald M. Kaplan (p.c.). cussion of tokenizing transducers in Section 4. Initial match The transducers derived from the definition in -SC Y.- I Y.&lt; I %&gt; 3 Figure 11 have the property that they unambigu.0. ously parse the input string into a sequence of subC. .3 —&gt; I _UPPER strings that are either copied to the output un.o. changed or replaced by some other strings. HowLeft to right ever they do not fall neatly into any standard class C-$C%-] C%-:%&lt; UPPER&apos; O:7.&gt;]]* -$ Cr] of transducers discussed in the literature (Eilenberg .o 1974, Schiitzenberger 1977, Berstel 1979). If the %.** -&gt; 0 LOWER language consists of a single string, then the .o. relation encoded by the transducer is in Berstel&apos;s Longest match terms a rational function, and the network is an -IN&lt; [UPPER&amp;quot; &amp; $EY.&gt;]]] unambigous transducer, even though it may contain states with outgoing transitions to two or more destinations for the same input symbol. An unambiguous transducer may also be sequentiable, in which case it can be turned into an equivalent sequential transducer (Mohri, 1994), which can in turn be minimized. A transducer is sequential just in case there are no states with more than on</context>
</contexts>
<marker>Berstel, 1979</marker>
<rawString>Jean Berstel. 1979. Transductions and Context-Free Languages. B.G. Teubner, Stuttgart, Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jean-Pierre Chanod</author>
<author>Pasi Tapanainen</author>
</authors>
<title>Tagging French—comparing a statistical and a constraint-based model.</title>
<date>1995</date>
<booktitle>In The Proceedings of the Seventh Conference of the European Chapter of the Association for Computational Linguistics,</booktitle>
<location>Dublin, Ireland.</location>
<contexts>
<context position="18991" citStr="Chanod and Tapanainen 1995" startWordPosition="3239" endWordPosition="3242">h with &amp;quot;dannvaan&amp;quot; on the upper side is: &lt;0 0: [ 7 d 3 a3n4n40:] 5v00:C7a3a3n40:7 5&gt;. 112 4 Applications The directed replacement operators have many useful applications. We describe some of them. Although the same results could often be achieved by using lex and yacc, sed, awk, pen, and other Unix utilities, there is an advantage in using finitestate transducers for these tasks because they can then be smoothly integrated with other finite-state processes, such as morphological analysis by lexical transducers (Karttunen et al 1992, Karttunen 1994) and rule-based part-of-speech disambiguation (Chanod and Tapanainen 1995, Roche and Schabes 1995). 4.1 Tokenization A tokenizer is a device that segments an input string into a sequence of tokens. The insertion of end-oftoken marks can be accomplished by a finite-state transducer that is compiled from tokenization rules. The tokenization rules may be of several types. For example, [WFIITE_SPACE+ SPACE] is a normalizing transducer that reduces any sequence of tabs, spaces, and newlines to a single space. [LETTER+ 0-&gt; ... END_OF_TOKEN] inserts a special mark, e.g. a newline, at the end of a letter sequence. Although a space generally counts as a token boundary, it c</context>
</contexts>
<marker>Chanod, Tapanainen, 1995</marker>
<rawString>Jean-Pierre Chanod and Pasi Tapanainen. 1995. Tagging French—comparing a statistical and a constraint-based model. In The Proceedings of the Seventh Conference of the European Chapter of the Association for Computational Linguistics, Dublin, Ireland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Samuel Eilenberg</author>
</authors>
<title>Automata, Languages, and Machines.</title>
<date>1974</date>
<publisher>Academic Press.</publisher>
<marker>Eilenberg, 1974</marker>
<rawString>Samuel Eilenberg. 1974. Automata, Languages, and Machines. Academic Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Maurice Gross</author>
</authors>
<title>The Use of Finite Automata in the Lexical Representation of Natural Language.</title>
<date>1989</date>
<booktitle>In Lecture Notes in Computer Science,</booktitle>
<pages>34--50</pages>
<publisher>Springer-Verlag,</publisher>
<location>Berlin, Germany.</location>
<contexts>
<context position="1026" citStr="Gross (1989)" startWordPosition="162" endWordPosition="163"> the lower language consists of a single string. It transduces the input string from left to right, making only the longest possible replacement at each point. A new type of replacement expression, UPPER 0-&gt; PREFIX ... SUFFIX, yields a transducer that inserts text around strings that are instances of UPPER. The symbol ... denotes the matching part of the input which itself remains unchanged. PREFIX and SUFFIX are regular expressions describing the insertions. Expressions of the type UPPER 0-&gt; PREFIX ... SUFFIX may be used to compose a deterministic parser for a &amp;quot;local grammar&amp;quot; in the sense of Gross (1989). Other useful applications of directed replacement include tokenization and filtering of text streams. 1 Introduction Transducers compiled from simple replace expressions UPPER -&gt; LOWER (Karttunen 1995, Kempe and Karttunen 1996) are generally nondeterministic in the sense that they may yield multiple results even if the lower language consists of a single string. For example, let us consider the transducer in Figure 1, representing ab I b I b a I ab a -&gt; x.1 iThe regular expression formalism and other notational ainventions used in the paper are explained in the Appendix at the end. Figure 1:</context>
<context position="24589" citStr="Gross (1989)" startWordPosition="4200" endWordPosition="4201"> any kind of regular pattern. 4.3 Marking As we observed in section 3, by using the ... symbol on the lower side of the replacement expression, we can construct transducers that mark instances of a regular language without changing the text in any other way. Such transducers have a wide range of applications. They can be used to locate all kinds of expressions that can be described by a regular pattern, such as proper names, dates, addresses, social security and phone numbers, and the like. Such a marking transducer can be viewed as a deterministic parser for a &amp;quot;local grammar&amp;quot; in the sense of Gross (1989), Roche (1993), Silberztein (1993) and others. By composing two or more marking transducers, we can also construct a single transducer that builds nested syntactic structures, up to any desired depth. To make the construction simpler, we can start by defining auxiliary symbols for the basic regular patterns. For example, we may define NP as [(d) a* n+] . With that abbreviatory convention, a composition of a simple NP and VP spotter can be defined as in Figure 20. NP 0-&gt; &apos;/.[NP ... %] .o. v %[NP NP %] @-&gt; &apos;/,[VP ... %] ; Figure 20: Composition of an NP and a VP spotter Figure 21 shows the effec</context>
</contexts>
<marker>Gross, 1989</marker>
<rawString>Maurice Gross. 1989. The Use of Finite Automata in the Lexical Representation of Natural Language. In Lecture Notes in Computer Science, pages 34-50, Springer-Verlag, Berlin, Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ronald M Kaplan</author>
<author>Martin Kay</author>
</authors>
<title>Regular Models of Phonological Rule Systems.</title>
<date>1994</date>
<journal>Computational Linguistics,</journal>
<volume>20</volume>
<pages>331--378</pages>
<contexts>
<context position="5483" citStr="Kaplan and Kay (1994)" startWordPosition="932" endWordPosition="935">OWER, and proceeds from the end of that substring without considering any other alternatives. Figure 5 illustrates the idea. Figure 5: Left-to-right, longest-match replacement It is not obvious at the outset that the operation can in fact be encoded as a finite-state transducer for arbitrary regular patterns. Although a unique substring is selected for replacement at each point, in general the transduction is not unambiguous because LOWER is not required to be a single string; it can be any regular language. The idea of treating phonological rewrite rules in this way was the starting point of Kaplan and Kay (1994). Their notion of obligatory rewrite rule incorporates a directionality constraint. They observe (p. 358), however, that this constraint does not by itself guarantee a single output. Kaplan and Kay suggest that additional restrictions, such as longestmatch, could be imposed to further constrain rule application.&apos; We consider this issue in more detail. The crucial observation is that the two constraints, left-to-right and longest-match, force a unique factorization on the input string thus making the transduction unambiguous if the LOWER language consists of a single string. In effect, the inpu</context>
<context position="7024" citStr="Kaplan and Kay (1994)" startWordPosition="1176" endWordPosition="1179">tion 3 introduces a novel type of replace expression for constructing transducers that unambiguously recognize and mark 2The tentative formulation of the longest-match constraint in (Kaplan and Kay, 1994, p. 358) is too weak. It does not cover all the cases. Scan Scan Scan V Longest Match Copy Replace Copy Replace Copy &gt;1 VI Longest Match 109 instances of a regular language without actually replacing them. Section 4 identifies some useful applications of the new replacement expressions. 2 Directed Replacement We define directed replacement by means of a composition of regular relations. As in Kaplan and Kay (1994), Karttunen (1995), and other previous works on related topics, the intermediate levels of the composition introduce auxiliary symbols to express and enforce constraints on the replacement relation. Figure 6 shows the component relations and how they are composed with the input. Input string .o. Initial match .o. Left-to-right constraint .o. Longest-match constraint .o. Replacement Figure 6: Composition of directed replacement If the four relations on the bottom of Figure 6 are composed in advance, as our compiler does, the application of the replacement to an input string takes place in one s</context>
<context position="10877" citStr="Kaplan and Kay (1994)" startWordPosition="1864" endWordPosition="1867">ions of the input string, in the case at hand, just &lt;aba&gt;, are replaced by the strings of the lower language, yielding &amp;quot;x&amp;quot; as the result for our example. Note that longest match constraint ignores any internal brackets. For example, the bracketing &lt; a 110 &gt; &lt; a &gt; is not allowed if the upper language con- length-of-match constraints can be encoded with tains &amp;quot;aa&amp;quot; as well as &amp;quot;a&amp;quot;. Similarly, the left-to-right fewer diacritics. (We believe that the conditional constraint ignores any internal carets. case can also be handled in a simpler way than in As the first step towards a formal definition of Kaplan and Kay (1994).) The number of auxiliary UPPER 0-&gt; LOWER it is useful to make the notion of markers is an important consideration for some of &amp;quot;ignoring internal brackets&amp;quot; more precise. Figure 10 the applications discussed below. contains the auxiliary definitions. For the details of In a phonological or morphological rewrite rule, the formalism (briefly explained in the Appendix), the center part of the rule is typically very small: please consult Karttunen (1995), Kempe and Kart- a modification, deletion or insertion of a single segtunen (1996).3 ment. On the other hand, in our text processing apUPPER&apos; = U</context>
<context position="14590" citStr="Kaplan and Kay (1994)" startWordPosition="2498" endWordPosition="2501">us, it may well be unsequentiable if UPPER is an infinite language. For example, the simple transducer for a+ b 0-&gt; x in Figure 12 cannot be sequentialized. It has to replace any string of &amp;quot;a&amp;quot;s by &amp;quot;x&amp;quot; or copy it to the output unchanged depending on whether the string eventually terminates at &amp;quot;b&amp;quot;. It is obviously impossible for any finite-state .o. Replacement Y.&lt; -$[%&gt;] 11.&gt; —&gt; LOWER ; Figure 11: Definition of UPPER 0-&gt; LOWER The logic of 0--&gt; replacement could be encoded in many other ways, for example, by using the three pairs of auxiliary brackets, &lt;i, &gt;i, &lt;c, &gt;c, and &lt;a, &gt;a, introduced in Kaplan and Kay (1994). We take here a more minimalist approach. One reason is that we prefer to think of the simple unconditional (uncontexted) replacement as the basic case, as in Karttunen (1995). Without the additional complexities introduced by contexts, the directionality and 3UPPER&apos; is the same language as UPPER except that carets may appear freely in all nonfinal positions. Similarly, UPPER&amp;quot; accepts any nonfinal brackets. 111 Figure 12: a+ b 0-&gt; x. This transducer is unambiguous but cannot be sequentialized. device to accumulate an unbounded amount of delayed output. On the other hand, the transducer in Fig</context>
<context position="26933" citStr="Kaplan and Kay (1994)" startWordPosition="4595" endWordPosition="4598">aula Newman and Kenneth R. Beesley for editorial advice on the first draft of the paper. The work on tokenizers and phrasal analyzers by Anne Schiller and Gregory Grefenstette revealed the need for a more efficient implementation of the idea. The final version of the paper has benefited from detailed comments by Ronald M. Kaplan and two anonymous reviewers, who convinced me to discard the ill-chosen original title (&amp;quot;Deterministic Replacement&amp;quot;) in favor of the present one. 1 1 4 7 Appendix: Notational conventions The regular expression formalism used in this paper is essentially the same as in Kaplan and Kay (1994), in Karttunen (1995), and in Kempe and Karttunen (1996). Upper-case strings, such as UPPER, represent regular languages, and lower-case letters, such as x, represent symbols. We recognize two types of symbols: unary symbols (a, b, c, etc) and symbol pairs (a: x, b:0, etc. ), A symbol pair a:x may be thought of as the crossproduct of a and x, the minimal relation consisting of a (the upper symbol) and x (the lower symbol). To make the notation less cumbersome, we systematically ignore the distinction between the language A and the identity relation that maps every string of A into itself. Cons</context>
</contexts>
<marker>Kaplan, Kay, 1994</marker>
<rawString>Ronald M. Kaplan and Martin Kay. 1994. Regular Models of Phonological Rule Systems. Computational Linguistics, 20:3, pages 331-378.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
<author>Kimmo Koskenniemi</author>
<author>Ronald M Kaplan</author>
</authors>
<title>A Compiler for Two-level Phonological Rules. In</title>
<date>1987</date>
<tech>Report No. CSLI-87-108.</tech>
<institution>Center for the Study of Language and Information, Stanford University.</institution>
<location>Palo Alto, California.</location>
<marker>Karttunen, Koskenniemi, Kaplan, 1987</marker>
<rawString>Lauri Karttunen, Kimmo Koskenniemi, and Ronald M. Kaplan. 1987. A Compiler for Two-level Phonological Rules. In Report No. CSLI-87-108. Center for the Study of Language and Information, Stanford University. Palo Alto, California.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
</authors>
<title>Constructing Lexical Transducers.</title>
<date>1994</date>
<booktitle>In The Proceedings of the Fifteenth International Conference on Computational Linguistics. Coling 94, I,</booktitle>
<pages>406--411</pages>
<location>Kyoto, Japan.</location>
<contexts>
<context position="18918" citStr="Karttunen 1994" startWordPosition="3233" endWordPosition="3234"> of the network. Figure 15: (d) a* n+ 0-&gt; &apos;A C.. . The one path with &amp;quot;dannvaan&amp;quot; on the upper side is: &lt;0 0: [ 7 d 3 a3n4n40:] 5v00:C7a3a3n40:7 5&gt;. 112 4 Applications The directed replacement operators have many useful applications. We describe some of them. Although the same results could often be achieved by using lex and yacc, sed, awk, pen, and other Unix utilities, there is an advantage in using finitestate transducers for these tasks because they can then be smoothly integrated with other finite-state processes, such as morphological analysis by lexical transducers (Karttunen et al 1992, Karttunen 1994) and rule-based part-of-speech disambiguation (Chanod and Tapanainen 1995, Roche and Schabes 1995). 4.1 Tokenization A tokenizer is a device that segments an input string into a sequence of tokens. The insertion of end-oftoken marks can be accomplished by a finite-state transducer that is compiled from tokenization rules. The tokenization rules may be of several types. For example, [WFIITE_SPACE+ SPACE] is a normalizing transducer that reduces any sequence of tabs, spaces, and newlines to a single space. [LETTER+ 0-&gt; ... END_OF_TOKEN] inserts a special mark, e.g. a newline, at the end of a let</context>
</contexts>
<marker>Karttunen, 1994</marker>
<rawString>Lauri Karttunen. 1994. Constructing Lexical Transducers. In The Proceedings of the Fifteenth International Conference on Computational Linguistics. Coling 94, I, pages 406-411, Kyoto, Japan.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
</authors>
<title>The Replace Operator.</title>
<date>1995</date>
<booktitle>In The Proceedings of the 33rd Annual Meeting of the Association for Computational Linguistics. ACL94,</booktitle>
<pages>16--23</pages>
<location>Boston, Massachusetts.</location>
<contexts>
<context position="1228" citStr="Karttunen 1995" startWordPosition="190" endWordPosition="191">PER 0-&gt; PREFIX ... SUFFIX, yields a transducer that inserts text around strings that are instances of UPPER. The symbol ... denotes the matching part of the input which itself remains unchanged. PREFIX and SUFFIX are regular expressions describing the insertions. Expressions of the type UPPER 0-&gt; PREFIX ... SUFFIX may be used to compose a deterministic parser for a &amp;quot;local grammar&amp;quot; in the sense of Gross (1989). Other useful applications of directed replacement include tokenization and filtering of text streams. 1 Introduction Transducers compiled from simple replace expressions UPPER -&gt; LOWER (Karttunen 1995, Kempe and Karttunen 1996) are generally nondeterministic in the sense that they may yield multiple results even if the lower language consists of a single string. For example, let us consider the transducer in Figure 1, representing ab I b I b a I ab a -&gt; x.1 iThe regular expression formalism and other notational ainventions used in the paper are explained in the Appendix at the end. Figure 1: ablblbal aba-&gt;x. The four paths with &amp;quot;aba&amp;quot; on the upper side are: &lt;0 a 0 b:x 2 a 0&gt;, &lt;0 a 0 b:x 2 a:0 0&gt;, &lt;0 a:x 1 b:0 2 a 0&gt;, and &lt;0 a:x 1 b:0 2 a:0 0&gt;. The application of this transducer to the input</context>
<context position="7042" citStr="Karttunen (1995)" startWordPosition="1180" endWordPosition="1181">el type of replace expression for constructing transducers that unambiguously recognize and mark 2The tentative formulation of the longest-match constraint in (Kaplan and Kay, 1994, p. 358) is too weak. It does not cover all the cases. Scan Scan Scan V Longest Match Copy Replace Copy Replace Copy &gt;1 VI Longest Match 109 instances of a regular language without actually replacing them. Section 4 identifies some useful applications of the new replacement expressions. 2 Directed Replacement We define directed replacement by means of a composition of regular relations. As in Kaplan and Kay (1994), Karttunen (1995), and other previous works on related topics, the intermediate levels of the composition introduce auxiliary symbols to express and enforce constraints on the replacement relation. Figure 6 shows the component relations and how they are composed with the input. Input string .o. Initial match .o. Left-to-right constraint .o. Longest-match constraint .o. Replacement Figure 6: Composition of directed replacement If the four relations on the bottom of Figure 6 are composed in advance, as our compiler does, the application of the replacement to an input string takes place in one step without any in</context>
<context position="11331" citStr="Karttunen (1995)" startWordPosition="1936" endWordPosition="1937">l constraint ignores any internal carets. case can also be handled in a simpler way than in As the first step towards a formal definition of Kaplan and Kay (1994).) The number of auxiliary UPPER 0-&gt; LOWER it is useful to make the notion of markers is an important consideration for some of &amp;quot;ignoring internal brackets&amp;quot; more precise. Figure 10 the applications discussed below. contains the auxiliary definitions. For the details of In a phonological or morphological rewrite rule, the formalism (briefly explained in the Appendix), the center part of the rule is typically very small: please consult Karttunen (1995), Kempe and Kart- a modification, deletion or insertion of a single segtunen (1996).3 ment. On the other hand, in our text processing apUPPER&apos; = UPPER/[&apos;/.] - [?* %-] plications, the upper language may involve a large UPPER&amp;quot; = UPPER/ [7.&lt;1%&gt;] - C.?* [/&lt;(&apos;/,&gt;J] network representing, for example, a lexicon of mulFigure 10: Versions of UPPER that freely allow non- tiword tokens. Practical experience shows that the final diacritics. presence of many auxiliary diacritics makes it diffiThe precise definition of the UPPER 0-&gt; LOWER re- cult or impossible to compute the left-to-right and lation is giv</context>
<context position="14766" citStr="Karttunen (1995)" startWordPosition="2529" endWordPosition="2530">ring of &amp;quot;a&amp;quot;s by &amp;quot;x&amp;quot; or copy it to the output unchanged depending on whether the string eventually terminates at &amp;quot;b&amp;quot;. It is obviously impossible for any finite-state .o. Replacement Y.&lt; -$[%&gt;] 11.&gt; —&gt; LOWER ; Figure 11: Definition of UPPER 0-&gt; LOWER The logic of 0--&gt; replacement could be encoded in many other ways, for example, by using the three pairs of auxiliary brackets, &lt;i, &gt;i, &lt;c, &gt;c, and &lt;a, &gt;a, introduced in Kaplan and Kay (1994). We take here a more minimalist approach. One reason is that we prefer to think of the simple unconditional (uncontexted) replacement as the basic case, as in Karttunen (1995). Without the additional complexities introduced by contexts, the directionality and 3UPPER&apos; is the same language as UPPER except that carets may appear freely in all nonfinal positions. Similarly, UPPER&amp;quot; accepts any nonfinal brackets. 111 Figure 12: a+ b 0-&gt; x. This transducer is unambiguous but cannot be sequentialized. device to accumulate an unbounded amount of delayed output. On the other hand, the transducer in Figure 4 is sequentiable because there the choice between a and a: x just depends on the next input symbol. Because none of the classical terms fits exactly, we have chosen a nove</context>
<context position="23712" citStr="Karttunen (1995)" startWordPosition="4049" endWordPosition="4050">e second transducer does a similar transduction on strings that begin with &lt;/A&gt;. Figure 12 illustrates the effect of the positive filter. &lt;B&gt;one&lt;/B&gt;&lt;A&gt;two&lt;/A&gt;&lt;C&gt;three&lt;/C&gt;&lt;A&gt;four&lt;/A&gt; Figure 21: Application of an NP-VP parser By means of this simple &amp;quot;bottom-up&amp;quot; technique, it is possible to compile finite-state transducers that approximate a context-free parser up to a chosen depth of embedding. Of course, the left-to-right, longest-match regimen implies that some possible analyses are ignored. To produce all possible parses, we may introduce the ... notation to the simple replace expressions in Karttunen (1995). &lt;A&gt; two &lt;/A&gt; &lt;A&gt;four&lt;/A&gt; 5 Extensions Figure 19: Application of a positive filter The idea of filtering by finite-state transduction of course does not depend on SGML codes. It can be applied to texts where the interesting and uninteresting regions are defined by any kind of regular pattern. 4.3 Marking As we observed in section 3, by using the ... symbol on the lower side of the replacement expression, we can construct transducers that mark instances of a regular language without changing the text in any other way. Such transducers have a wide range of applications. They can be used to loca</context>
<context position="26954" citStr="Karttunen (1995)" startWordPosition="4600" endWordPosition="4601"> Beesley for editorial advice on the first draft of the paper. The work on tokenizers and phrasal analyzers by Anne Schiller and Gregory Grefenstette revealed the need for a more efficient implementation of the idea. The final version of the paper has benefited from detailed comments by Ronald M. Kaplan and two anonymous reviewers, who convinced me to discard the ill-chosen original title (&amp;quot;Deterministic Replacement&amp;quot;) in favor of the present one. 1 1 4 7 Appendix: Notational conventions The regular expression formalism used in this paper is essentially the same as in Kaplan and Kay (1994), in Karttunen (1995), and in Kempe and Karttunen (1996). Upper-case strings, such as UPPER, represent regular languages, and lower-case letters, such as x, represent symbols. We recognize two types of symbols: unary symbols (a, b, c, etc) and symbol pairs (a: x, b:0, etc. ), A symbol pair a:x may be thought of as the crossproduct of a and x, the minimal relation consisting of a (the upper symbol) and x (the lower symbol). To make the notation less cumbersome, we systematically ignore the distinction between the language A and the identity relation that maps every string of A into itself. Consequently, we also wri</context>
</contexts>
<marker>Karttunen, 1995</marker>
<rawString>Lauri Karttunen. 1995, The Replace Operator. In The Proceedings of the 33rd Annual Meeting of the Association for Computational Linguistics. ACL94, pages 16-23, Boston, Massachusetts.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andre Kempe</author>
<author>Lauri Karttunen</author>
</authors>
<title>Parallel Replacement in the Finite-State Calculus.</title>
<date>1996</date>
<booktitle>In The Proceedings of the Sixteenth International Conference on Computational Linguistics. Coling 96.</booktitle>
<location>Copenhagen, Denmark.</location>
<contexts>
<context position="1255" citStr="Kempe and Karttunen 1996" startWordPosition="192" endWordPosition="195">.. SUFFIX, yields a transducer that inserts text around strings that are instances of UPPER. The symbol ... denotes the matching part of the input which itself remains unchanged. PREFIX and SUFFIX are regular expressions describing the insertions. Expressions of the type UPPER 0-&gt; PREFIX ... SUFFIX may be used to compose a deterministic parser for a &amp;quot;local grammar&amp;quot; in the sense of Gross (1989). Other useful applications of directed replacement include tokenization and filtering of text streams. 1 Introduction Transducers compiled from simple replace expressions UPPER -&gt; LOWER (Karttunen 1995, Kempe and Karttunen 1996) are generally nondeterministic in the sense that they may yield multiple results even if the lower language consists of a single string. For example, let us consider the transducer in Figure 1, representing ab I b I b a I ab a -&gt; x.1 iThe regular expression formalism and other notational ainventions used in the paper are explained in the Appendix at the end. Figure 1: ablblbal aba-&gt;x. The four paths with &amp;quot;aba&amp;quot; on the upper side are: &lt;0 a 0 b:x 2 a 0&gt;, &lt;0 a 0 b:x 2 a:0 0&gt;, &lt;0 a:x 1 b:0 2 a 0&gt;, and &lt;0 a:x 1 b:0 2 a:0 0&gt;. The application of this transducer to the input &amp;quot;aba&amp;quot; produces four altern</context>
<context position="25523" citStr="Kempe and Karttunen 1996" startWordPosition="4357" endWordPosition="4360"> For example, we may define NP as [(d) a* n+] . With that abbreviatory convention, a composition of a simple NP and VP spotter can be defined as in Figure 20. NP 0-&gt; &apos;/.[NP ... %] .o. v %[NP NP %] @-&gt; &apos;/,[VP ... %] ; Figure 20: Composition of an NP and a VP spotter Figure 21 shows the effect of applying this composite transducer to the string &amp;quot;dannvaan&amp;quot;. The definition of the left-to-right, longest-match replacement can easily be modified for the three other directed replace operators mentioned in Figure 3. Another extension, already implemented, is a directed version of parallel replacement (Kempe and Karttunen 1996), which allows any number of replacements to be done simultaneously without interfering with each other. Figure 22 is an example of a directed parallel replacement. It yields a transducer that maps a string of &amp;quot;a&amp;quot;s into a single &amp;quot;b&amp;quot; and a string of &amp;quot;b&amp;quot;s into a single &amp;quot;a&amp;quot;. a+ 0-&gt; b, b+ 0-&gt; a ; Figure 22: Directed, parallel replacement The definition of directed parallel replacement requires no additions to the techniques already presented. In the near future we also plan to allow directional and length-of-match constraints in the more complicated case of conditional context-constrained replacem</context>
<context position="26989" citStr="Kempe and Karttunen (1996)" startWordPosition="4604" endWordPosition="4607">vice on the first draft of the paper. The work on tokenizers and phrasal analyzers by Anne Schiller and Gregory Grefenstette revealed the need for a more efficient implementation of the idea. The final version of the paper has benefited from detailed comments by Ronald M. Kaplan and two anonymous reviewers, who convinced me to discard the ill-chosen original title (&amp;quot;Deterministic Replacement&amp;quot;) in favor of the present one. 1 1 4 7 Appendix: Notational conventions The regular expression formalism used in this paper is essentially the same as in Kaplan and Kay (1994), in Karttunen (1995), and in Kempe and Karttunen (1996). Upper-case strings, such as UPPER, represent regular languages, and lower-case letters, such as x, represent symbols. We recognize two types of symbols: unary symbols (a, b, c, etc) and symbol pairs (a: x, b:0, etc. ), A symbol pair a:x may be thought of as the crossproduct of a and x, the minimal relation consisting of a (the upper symbol) and x (the lower symbol). To make the notation less cumbersome, we systematically ignore the distinction between the language A and the identity relation that maps every string of A into itself. Consequently, we also write a:a as just a. Three special sym</context>
</contexts>
<marker>Kempe, Karttunen, 1996</marker>
<rawString>Andre Kempe and Lauri Karttunen. 1996. Parallel Replacement in the Finite-State Calculus. In The Proceedings of the Sixteenth International Conference on Computational Linguistics. Coling 96. Copenhagen, Denmark.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Geoffrey Leech</author>
</authors>
<title>User&apos;s Guide to the British National Corpus.</title>
<date>1995</date>
<institution>Lancaster University.</institution>
<contexts>
<context position="21804" citStr="Leech, 1995" startWordPosition="3731" endWordPosition="3732">reover one doesn&apos;t do it anymore) but not in on le fait de plus en plus (one does it more and more) where &amp;quot;de plus en plus&amp;quot; is a single token. If the list of multiword tokens contains hundreds of expressions, it may require a lot of time and space to compile the tokenizer even if the final result is not too large. The number of auxiliary symbols used to encode the constraints has a critical effect on the efficiency of that computation. We first observed this phenomenon in the course of building a tokenizer for the British National Corpus according to the specifications of the BNC Users Guide (Leech, 1995), which lists around 300 multiword tokens and 260 foreign phrases. With the current definition of the directed replacement we have now been able to compute similar tokenizers for several other languages (French, Spanish, Italian, Portuguese, Dutch, German). 4.2 Filtering Some text processing applications involve a preliminary stage in which the input stream is divided into regions that are passed on to the calling process and regions that are ignored. For example, in processing an SGML-coded document, we may wish to delete all the material that appears or does not appear in a region bounded by</context>
</contexts>
<marker>Leech, 1995</marker>
<rawString>Geoffrey Leech. 1995. User&apos;s Guide to the British National Corpus. Lancaster University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mehryar Mohri</author>
</authors>
<title>On Some Applications of Finite-State Automata Theory to Natural Language Processing. Technical Report 94-22. L&apos;Institute Gaspard Mange. Universite de Marne-laVallee. Noisy Le Grand.</title>
<date>1994</date>
<contexts>
<context position="13423" citStr="Mohri, 1994" startWordPosition="2291" endWordPosition="2292">&lt; UPPER&apos; O:7.&gt;]]* -$ Cr] of transducers discussed in the literature (Eilenberg .o 1974, Schiitzenberger 1977, Berstel 1979). If the %.** -&gt; 0 LOWER language consists of a single string, then the .o. relation encoded by the transducer is in Berstel&apos;s Longest match terms a rational function, and the network is an -IN&lt; [UPPER&amp;quot; &amp; $EY.&gt;]]] unambigous transducer, even though it may contain states with outgoing transitions to two or more destinations for the same input symbol. An unambiguous transducer may also be sequentiable, in which case it can be turned into an equivalent sequential transducer (Mohri, 1994), which can in turn be minimized. A transducer is sequential just in case there are no states with more than one transition for the same input symbol. Roche and Schabes (1995) call such transducers deterministic. Our replacement transducers in general are not unambiguous because we allow LOWER to be any regular language. It may well turn out that, in all cases that are of practical interest, the lower language is in fact a singleton, or at least some finite set, but it is not so by definition. Even if the replacement transducer is unambiguous, it may well be unsequentiable if UPPER is an infin</context>
</contexts>
<marker>Mohri, 1994</marker>
<rawString>Mehryar Mohri. 1994. On Some Applications of Finite-State Automata Theory to Natural Language Processing. Technical Report 94-22. L&apos;Institute Gaspard Mange. Universite de Marne-laVallee. Noisy Le Grand.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Emmanuel Roche</author>
</authors>
<title>Analyse syntaxique transfornzationelle du francais par transducteurs et lexique-gramrnaire. Doctoral dissertation, Universite Paris 7.</title>
<date>1993</date>
<contexts>
<context position="24603" citStr="Roche (1993)" startWordPosition="4202" endWordPosition="4203">egular pattern. 4.3 Marking As we observed in section 3, by using the ... symbol on the lower side of the replacement expression, we can construct transducers that mark instances of a regular language without changing the text in any other way. Such transducers have a wide range of applications. They can be used to locate all kinds of expressions that can be described by a regular pattern, such as proper names, dates, addresses, social security and phone numbers, and the like. Such a marking transducer can be viewed as a deterministic parser for a &amp;quot;local grammar&amp;quot; in the sense of Gross (1989), Roche (1993), Silberztein (1993) and others. By composing two or more marking transducers, we can also construct a single transducer that builds nested syntactic structures, up to any desired depth. To make the construction simpler, we can start by defining auxiliary symbols for the basic regular patterns. For example, we may define NP as [(d) a* n+] . With that abbreviatory convention, a composition of a simple NP and VP spotter can be defined as in Figure 20. NP 0-&gt; &apos;/.[NP ... %] .o. v %[NP NP %] @-&gt; &apos;/,[VP ... %] ; Figure 20: Composition of an NP and a VP spotter Figure 21 shows the effect of applying </context>
</contexts>
<marker>Roche, 1993</marker>
<rawString>Emmanuel Roche. 1993. Analyse syntaxique transfornzationelle du francais par transducteurs et lexique-gramrnaire. Doctoral dissertation, Universite Paris 7.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Emmanuel Roche</author>
<author>Yves Schabes</author>
</authors>
<title>Deterministic Part-of-Speech Tagging.</title>
<date>1995</date>
<journal>Computational Linguistics,</journal>
<volume>21</volume>
<pages>227--53</pages>
<contexts>
<context position="9467" citStr="Roche and Schabes (1995)" startWordPosition="1611" endWordPosition="1614">e matching. No carets are permitted outside the matched substrings and the ignored internal carets are eliminated. In this case, there are four possible outcomes, shown in Figure 8, but only two of them are allowed under the constraint that there can be no carets outside the brackets. ALLOWED &amp;quot;ab a &amp;quot;ab a &lt;a b &gt; a &lt;a b a&gt; NOT ALLOWED &amp;quot;a &amp;quot;b a &amp;quot;ab a &amp;quot;a &lt;b&gt;a &amp;quot; a &lt; b a&gt; Figure 8: Left-to-right constraint. No caret outside a bracketed region. In effect, no starting location for a replacement can be skipped over except in the context of another replacement starting further left in the input string. (Roche and Schabes (1995) introduce a similar technique for imposing the left-to-right order on the transduction.) Note that the four alternatives in Figure 8 represent the four factorizations in Figure 2. The longest-match constraint is the identity relation on a certain set of strings. It forbids any replacement that starts at the same location as another, longer replacement. In the case at hand, it means that the internal &gt; is disallowed in the context &lt; a b &gt; a. Because &amp;quot;aba&amp;quot; is in the upper language, there is a longer, and therefore preferred, &lt; a b a &gt; alternative at the same starting location, Figure 9. ALLOWED</context>
<context position="13598" citStr="Roche and Schabes (1995)" startWordPosition="2321" endWordPosition="2324">ts of a single string, then the .o. relation encoded by the transducer is in Berstel&apos;s Longest match terms a rational function, and the network is an -IN&lt; [UPPER&amp;quot; &amp; $EY.&gt;]]] unambigous transducer, even though it may contain states with outgoing transitions to two or more destinations for the same input symbol. An unambiguous transducer may also be sequentiable, in which case it can be turned into an equivalent sequential transducer (Mohri, 1994), which can in turn be minimized. A transducer is sequential just in case there are no states with more than one transition for the same input symbol. Roche and Schabes (1995) call such transducers deterministic. Our replacement transducers in general are not unambiguous because we allow LOWER to be any regular language. It may well turn out that, in all cases that are of practical interest, the lower language is in fact a singleton, or at least some finite set, but it is not so by definition. Even if the replacement transducer is unambiguous, it may well be unsequentiable if UPPER is an infinite language. For example, the simple transducer for a+ b 0-&gt; x in Figure 12 cannot be sequentialized. It has to replace any string of &amp;quot;a&amp;quot;s by &amp;quot;x&amp;quot; or copy it to the output unc</context>
<context position="19016" citStr="Roche and Schabes 1995" startWordPosition="3243" endWordPosition="3246">er side is: &lt;0 0: [ 7 d 3 a3n4n40:] 5v00:C7a3a3n40:7 5&gt;. 112 4 Applications The directed replacement operators have many useful applications. We describe some of them. Although the same results could often be achieved by using lex and yacc, sed, awk, pen, and other Unix utilities, there is an advantage in using finitestate transducers for these tasks because they can then be smoothly integrated with other finite-state processes, such as morphological analysis by lexical transducers (Karttunen et al 1992, Karttunen 1994) and rule-based part-of-speech disambiguation (Chanod and Tapanainen 1995, Roche and Schabes 1995). 4.1 Tokenization A tokenizer is a device that segments an input string into a sequence of tokens. The insertion of end-oftoken marks can be accomplished by a finite-state transducer that is compiled from tokenization rules. The tokenization rules may be of several types. For example, [WFIITE_SPACE+ SPACE] is a normalizing transducer that reduces any sequence of tabs, spaces, and newlines to a single space. [LETTER+ 0-&gt; ... END_OF_TOKEN] inserts a special mark, e.g. a newline, at the end of a letter sequence. Although a space generally counts as a token boundary, it can also be part of a mult</context>
</contexts>
<marker>Roche, Schabes, 1995</marker>
<rawString>Emmanuel Roche and Yves Schabes. 1995. Deterministic Part-of-Speech Tagging. Computational Linguistics, 21:2, pages 227-53.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Marcel Paul Schiitzenberger</author>
</authors>
<title>Sur une variante des fonctions sequentielles.</title>
<date>1977</date>
<journal>Theoretical Computer Science,</journal>
<volume>4</volume>
<pages>47--57</pages>
<contexts>
<context position="12919" citStr="Schiitzenberger 1977" startWordPosition="2206" endWordPosition="2207">will return to this issue in the disbased on a suggestion by Ronald M. Kaplan (p.c.). cussion of tokenizing transducers in Section 4. Initial match The transducers derived from the definition in -SC Y.- I Y.&lt; I %&gt; 3 Figure 11 have the property that they unambigu.0. ously parse the input string into a sequence of subC. .3 —&gt; I _UPPER strings that are either copied to the output un.o. changed or replaced by some other strings. HowLeft to right ever they do not fall neatly into any standard class C-$C%-] C%-:%&lt; UPPER&apos; O:7.&gt;]]* -$ Cr] of transducers discussed in the literature (Eilenberg .o 1974, Schiitzenberger 1977, Berstel 1979). If the %.** -&gt; 0 LOWER language consists of a single string, then the .o. relation encoded by the transducer is in Berstel&apos;s Longest match terms a rational function, and the network is an -IN&lt; [UPPER&amp;quot; &amp; $EY.&gt;]]] unambigous transducer, even though it may contain states with outgoing transitions to two or more destinations for the same input symbol. An unambiguous transducer may also be sequentiable, in which case it can be turned into an equivalent sequential transducer (Mohri, 1994), which can in turn be minimized. A transducer is sequential just in case there are no states wi</context>
</contexts>
<marker>Schiitzenberger, 1977</marker>
<rawString>Marcel Paul Schiitzenberger. 1977. Sur une variante des fonctions sequentielles. Theoretical Computer Science, 4, pages 47-57.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Max Silberztein</author>
</authors>
<date>1993</date>
<booktitle>Dictionnaires Electroniques et Analyse Lexicale du Francais—Le Systeme INTEX,</booktitle>
<location>Masson, Paris, France.</location>
<contexts>
<context position="24623" citStr="Silberztein (1993)" startWordPosition="4204" endWordPosition="4205">. 4.3 Marking As we observed in section 3, by using the ... symbol on the lower side of the replacement expression, we can construct transducers that mark instances of a regular language without changing the text in any other way. Such transducers have a wide range of applications. They can be used to locate all kinds of expressions that can be described by a regular pattern, such as proper names, dates, addresses, social security and phone numbers, and the like. Such a marking transducer can be viewed as a deterministic parser for a &amp;quot;local grammar&amp;quot; in the sense of Gross (1989), Roche (1993), Silberztein (1993) and others. By composing two or more marking transducers, we can also construct a single transducer that builds nested syntactic structures, up to any desired depth. To make the construction simpler, we can start by defining auxiliary symbols for the basic regular patterns. For example, we may define NP as [(d) a* n+] . With that abbreviatory convention, a composition of a simple NP and VP spotter can be defined as in Figure 20. NP 0-&gt; &apos;/.[NP ... %] .o. v %[NP NP %] @-&gt; &apos;/,[VP ... %] ; Figure 20: Composition of an NP and a VP spotter Figure 21 shows the effect of applying this composite trans</context>
</contexts>
<marker>Silberztein, 1993</marker>
<rawString>Max Silberztein. 1993. Dictionnaires Electroniques et Analyse Lexicale du Francais—Le Systeme INTEX, Masson, Paris, France.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>