<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.002659">
<title confidence="0.98034">
Foma: a finite-state compiler and library
</title>
<author confidence="0.988396">
Mans Hulden
</author>
<affiliation confidence="0.996843">
University of Arizona
</affiliation>
<email confidence="0.98964">
mhulden@email.arizona.edu
</email>
<sectionHeader confidence="0.994583" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999766466666667">
Foma is a compiler, programming lan-
guage, and C library for constructing
finite-state automata and transducers for
various uses. It has specific support for
many natural language processing appli-
cations such as producing morphologi-
cal and phonological analyzers. Foma is
largely compatible with the Xerox/PARC
finite-state toolkit. It also embraces Uni-
code fully and supports various differ-
ent formats for specifying regular expres-
sions: the Xerox/PARC format, a Perl-like
format, and a mathematical format that
takes advantage of the ‘Mathematical Op-
erators’ Unicode block.
</bodyText>
<sectionHeader confidence="0.998783" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999203574468085">
Foma is a finite-state compiler, programming lan-
guage, and regular expression/finite-state library
designed for multi-purpose use with explicit sup-
port for automata theoretic research, construct-
ing lexical analyzers for programming languages,
and building morphological/phonological analyz-
ers, as well as spellchecking applications.
The compiler allows users to specify finite-state
automata and transducers incrementally in a simi-
lar fashion to AT&amp;T’s fsm (Mohri et al., 1997) and
Lextools (Sproat, 2003), the Xerox/PARC finite-
state toolkit (Beesley and Karttunen, 2003) and
the SFST toolkit (Schmid, 2005). One of Foma’s
design goals has been compatibility with the Xe-
rox/PARC toolkit. Another goal has been to al-
low for the ability to work with n-tape automata
and a formalism for expressing first-order logi-
cal constraints over regular languages and n-tape-
transductions.
Foma is licensed under the GNU general pub-
lic license: in keeping with traditions of free soft-
ware, the distribution that includes the source code
comes with a user manual and a library of exam-
ples.
The compiler and library are implemented in C
and an API is available. The API is in many ways
similar to the standard C library &lt;regex.h&gt;, and
has similar calling conventions. However, all the
low-level functions that operate directly on au-
tomata/transducers are also available (some 50+
functions), including regular expression primitives
and extended functions as well as automata deter-
minization and minimization algorithms. These
may be useful for someone wanting to build a sep-
arate GUI or interface using just the existing low-
level functions. The API also contains, mainly for
spell-checking purposes, functionality for finding
words that match most closely (but not exactly) a
path in an automaton. This makes it straightfor-
ward to build spell-checkers from morphological
transducers by simply extracting the range of the
transduction and matching words approximately.
Unicode (UTF8) is fully supported and is in
fact the only encoding accepted by Foma. It has
been successfully compiled on Linux, Mac OS X,
and Win32 operating systems, and is likely to be
portable to other systems without much effort.
</bodyText>
<sectionHeader confidence="0.896835" genericHeader="method">
2 Basic Regular Expressions
</sectionHeader>
<bodyText confidence="0.998401714285714">
Retaining backwards compatibility with Xe-
rox/PARC and at the same time extending the for-
malism means that one is often able to construct
finite-state networks in equivalent various ways,
either through ASCII-based operators or through
the Unicode-based extensions. For example, one
can either say:
</bodyText>
<equation confidence="0.99734775">
ContainsX = E* X E*;
MyWords = {cat}|{dog}|{mouse};
MyRule = n -&gt; m  ||p;
ShortWords = [MyLex1]1 n Eˆ&lt;6;
</equation>
<bodyText confidence="0.391204666666667">
or:
Proceedings of the EACL 2009 Demonstrations Session, pages 29–32,
Athens, Greece, 3 April 2009. c�2009 Association for Computational Linguistics
</bodyText>
<page confidence="0.995202">
29
</page>
<subsectionHeader confidence="0.269339">
Operators Compatibility variant Function
</subsectionHeader>
<equation confidence="0.9790260625">
[ ] O [ ] O grouping parentheses, optionality
V I N/A quantifiers
\ ` term negation, substitution/homomorphism
: :cross-product
+ * + * Kleene closures
&amp;quot;&lt;n &amp;quot;&gt;n &amp;quot;{m,n} &amp;quot;&lt;n &amp;quot;&gt;n &amp;quot;{m,n} iterations
1 2 .1 .2 .u .l domain &amp; range
.f N/A eliminate all unification flags
� $ $. $? ˜ $ $. $? complement, containment operators
/ ./. /// \\\ /\// ./. N/A N/A ‘ignores’, left quotient, right quotient, ‘inside’ quotient
E E/ = =� N/A language membership, position equivalence
� �&lt; &gt; precedes, follows
V U n n - .P..p. I &amp; − .P. .p. union, intersection, set minus, priority unions
=&gt; -&gt; (-&gt;) @-&gt; =&gt; -&gt; (-&gt;) @-&gt; context restriction, replacement rules
11 &lt;&gt; shuffle (asynchronous product)
X o .x. .o. cross-product, composition
</equation>
<tableCaption confidence="0.959692">
Table 1: The regular expressions available in Foma from highest to lower precedence. Horizontal lines
separate precedence classes.
</tableCaption>
<page confidence="0.993818">
30
</page>
<bodyText confidence="0.975172692307693">
define ContainsX ?* X ?*;
define MyWords {cat}|{dog}|{mouse};
define MyRule n -&gt; m  ||_ p;
define ShortWords Mylex.i.l &amp; ?ˆ&lt;6;
In addition to the basic regular expression oper-
ators shown in table 1, the formalism is extended
in various ways. One such extension is the abil-
ity to use of a form of first-order logic to make
existential statements over languages and trans-
ductions (Hulden, 2008). For instance, suppose
we have defined an arbitrary regular language L,
and want to further define a language that contains
only one factor of L, we can do so by:
</bodyText>
<equation confidence="0.9901895">
OneL = (∃x)(x ∈ L ∧ ¬(∃y)(y ∈ L
∧ ¬(x = y)));
</equation>
<bodyText confidence="0.999951466666667">
Here, quantifiers apply to substrings, and we at-
tribute the usual meaning to ∈ and ∧, and a kind of
concatenative meaning to the predicate 5(t1, t2).
Hence, in the above example, OneL defines the
language where there exists a string x such that
x is a member of the language L and there does
not exist a string y, also in L, such that y would
occur in a different position than x. This kind
of logical specification of regular languages can
be very useful for building some languages that
would be quite cumbersome to express with other
regular expression operators. In fact, many of the
internally complex operations of Foma are built
through a reduction to this type of logical expres-
sions.
</bodyText>
<sectionHeader confidence="0.901273" genericHeader="method">
3 Building morphological analyzers
</sectionHeader>
<bodyText confidence="0.9998895">
As mentioned, Foma supports reading and writ-
ing of the LEXC file format, where morphological
categories are divided into so-called continuation
classes. This practice stems back from the earliest
two-level compilers (Karttunen et al., 1987). Be-
low is a simple example of the format:
</bodyText>
<table confidence="0.659637777777778">
Multichar_Symbols +Pl +Sing
LEXICON Root
Nouns;
LEXICON Nouns
cat Plural;
church Plural;
LEXICON Plural
+Pl:%ˆs #;
+Sing #;
</table>
<sectionHeader confidence="0.78341" genericHeader="method">
4 An API example
</sectionHeader>
<bodyText confidence="0.9960926">
The Foma API gives access to basic functions,
such as constructing a finite-state machine from
a regular expression provided as a string, per-
forming a transduction, and exhaustively matching
against a given string starting from every position.
The following basic snippet illustrates how to
use the C API instead of the main interface of
Foma to construct a finite-state machine encod-
ing the language a+b+ and check whether a string
matches it:
</bodyText>
<listItem confidence="0.99676775">
1. void check_word(char *s) {
2. fsm_t *network;
3. fsm_match_result *result;
5. network = fsm_regex(&amp;quot;a+ b+&amp;quot;);
6. result = fsm_match(fsm, s);
7. if (result-&gt;num_matches &gt; 0)
8. printf(&amp;quot;Regex matches&amp;quot;);
10 }
</listItem>
<bodyText confidence="0.999553117647059">
Here, instead of calling the fsm regex() function to
construct the machine from a regular expressions,
we could instead have accessed the beforemen-
tioned low-level routines and built the network en-
tirely without regular expressions by combining
low-level primitives, as follows, replacing line 5
in the above:
network = fsm_concat(
fsm_kleene_plus(
fsm_symbol(&amp;quot;a&amp;quot;)),
fsm_kleene_plus(
fsm_symbol(&amp;quot;b&amp;quot;)));
The API is currently under active develop-
ment and future functionality is likely to include
conversion of networks to 8-bit letter transduc-
ers/automata for maximum speed in regular ex-
pression matching and transduction.
</bodyText>
<subsectionHeader confidence="0.732911">
5 Automata visualization and
educational use
</subsectionHeader>
<bodyText confidence="0.9998322">
Foma has support for visualization of the ma-
chines it builds through the AT&amp;T Graphviz li-
brary. For educational purposes and to illustrate
automata construction methods, there is some sup-
port for changing the behavior of the algorithms.
</bodyText>
<page confidence="0.99972">
31
</page>
<bodyText confidence="0.999905384615385">
For instance, by default, for efficiency reasons,
Foma determinizes and minimizes automata be-
tween nearly every incremental operation. Oper-
ations such as unions of automata are also con-
structed by default with the product construction
method that directly produces deterministic au-
tomata. However, this on-the-fly minimization
and determinization can be relaxed, and a Thomp-
son construction method chosen in the interface so
that automata remain non-deterministic and non-
minimized whenever possible—non-deterministic
automata naturally being easier to inspect and an-
alyze.
</bodyText>
<sectionHeader confidence="0.997272" genericHeader="evaluation">
6 Efficiency
</sectionHeader>
<bodyText confidence="0.999976952380953">
Though the main concern with Foma has not
been that of efficiency, but of compatibility and
extendibility, from a usefulness perspective it is
important to avoid bottlenecks in the underly-
ing algorithms that can cause compilation times
to skyrocket, especially when constructing and
combining large lexical transducers. With this
in mind, some care has been taken to attempt
to optimize the underlying primitive algorithms.
Table 2 shows a comparison with some exist-
ing toolkits that build deterministic, minimized
automata/transducers. One the whole, Foma
seems to perform particularly well with patho-
logical cases that involve exponential growth in
the number of states when determinizing non-
deterministic machines. For general usage pat-
terns, this advantage is not quite as dramatic, and
for average use Foma seems to perform compa-
rably with e.g. the Xerox/PARC toolkit, perhaps
with the exception of certain types of very large
lexicon descriptions (&gt;100,000 words).
</bodyText>
<sectionHeader confidence="0.998191" genericHeader="conclusions">
7 Conclusion
</sectionHeader>
<bodyText confidence="0.999416083333333">
The Foma project is multipurpose multi-mode
finite-state compiler geared toward practical con-
struction of large-scale finite-state machines such
as may be needed in natural language process-
ing as well as providing a framework for re-
search in finite-state automata. Several wide-
coverage morphological analyzers specified in the
LEXC/xfst format have been compiled success-
fully with Foma. Foma is free software and will
remain under the GNU General Public License.
As the source code is available, collaboration is
encouraged.
</bodyText>
<table confidence="0.999362333333333">
Foma xfst GNU AT&amp;T
flex fsm 4
E*aE15 0.216s 16.23s 17.17s 1.884s
E*aE20 8.605s nf nf 153.7s
North Sami 14.23s 4.264s N/A N/A
8queens 0.188s 1.200s N/A N/A
sudoku2x3 5.040s 5.232s N/A N/A
lexicon.lex 1.224s 1.428s N/A N/A
3sat30 0.572s 0.648s N/A N/A
</table>
<tableCaption confidence="0.984062">
Table 2: A relative comparison of running a se-
</tableCaption>
<bodyText confidence="0.9062356">
lection of regular expressions and scripts against
other finite-state toolkits. The first and second en-
tries are short regular expressions that exhibit ex-
ponential behavior. The second results in a FSM
with 221 states and 222 arcs. The others are scripts
that can be run on both Xerox/PARC and Foma.
The file lexicon.lex is a LEXC format English dic-
tionary with 38418 entries. North Sami is a large
lexicon (lexc file) for the North Sami language
available from http://divvun.no.
</bodyText>
<sectionHeader confidence="0.997725" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999296347826087">
Beesley, K. and Karttunen, L. (2003). Finite-State
Morphology. CSLI, Stanford.
Hulden, M. (2008). Regular expressions and pred-
icate logic in finite-state language processing.
In Piskorski, J., Watson, B., and Yli-Jyr¨a, A.,
editors, Proceedings of FSMNLP 2008.
Karttunen, L., Koskenniemi, K., and Kaplan,
R. M. (1987). A compiler for two-level phono-
logical rules. In Dalrymple, M., Kaplan, R.,
Karttunen, L., Koskenniemi, K., Shaio, S., and
Wescoat, M., editors, Tools for Morphological
Analysis. CSLI, Palo Alto, CA.
Mohri, M., Pereira, F., Riley, M., and Allauzen, C.
(1997). AT&amp;T FSM Library-Finite State Ma-
chine Library. AT&amp;T Labs—Research.
Schmid, H. (2005). A programming language for
finite-state transducers. In Yli-Jyr¨a, A., Kart-
tunen, L., and Karhum¨aki, J., editors, Finite-
State Methods and Natural Language Process-
ing FSMNLP 2005.
Sproat, R. (2003). Lextools: a toolkit for
finite-state linguistic analysis. AT&amp;T Labs—
Research.
</reference>
<page confidence="0.999287">
32
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.769362">
<title confidence="0.998085">Foma: a finite-state compiler and library</title>
<author confidence="0.999534">Mans Hulden</author>
<affiliation confidence="0.999938">University of Arizona</affiliation>
<email confidence="0.99984">mhulden@email.arizona.edu</email>
<abstract confidence="0.9853678125">Foma is a compiler, programming language, and C library for constructing finite-state automata and transducers for various uses. It has specific support for many natural language processing applications such as producing morphological and phonological analyzers. Foma is largely compatible with the Xerox/PARC finite-state toolkit. It also embraces Unicode fully and supports various different formats for specifying regular expressions: the Xerox/PARC format, a Perl-like format, and a mathematical format that takes advantage of the ‘Mathematical Operators’ Unicode block.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>K Beesley</author>
<author>L Karttunen</author>
</authors>
<title>Finite-State Morphology.</title>
<date>2003</date>
<publisher>CSLI, Stanford.</publisher>
<contexts>
<context position="1272" citStr="Beesley and Karttunen, 2003" startWordPosition="172" endWordPosition="175">e ‘Mathematical Operators’ Unicode block. 1 Introduction Foma is a finite-state compiler, programming language, and regular expression/finite-state library designed for multi-purpose use with explicit support for automata theoretic research, constructing lexical analyzers for programming languages, and building morphological/phonological analyzers, as well as spellchecking applications. The compiler allows users to specify finite-state automata and transducers incrementally in a similar fashion to AT&amp;T’s fsm (Mohri et al., 1997) and Lextools (Sproat, 2003), the Xerox/PARC finitestate toolkit (Beesley and Karttunen, 2003) and the SFST toolkit (Schmid, 2005). One of Foma’s design goals has been compatibility with the Xerox/PARC toolkit. Another goal has been to allow for the ability to work with n-tape automata and a formalism for expressing first-order logical constraints over regular languages and n-tapetransductions. Foma is licensed under the GNU general public license: in keeping with traditions of free software, the distribution that includes the source code comes with a user manual and a library of examples. The compiler and library are implemented in C and an API is available. The API is in many ways si</context>
</contexts>
<marker>Beesley, Karttunen, 2003</marker>
<rawString>Beesley, K. and Karttunen, L. (2003). Finite-State Morphology. CSLI, Stanford.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Hulden</author>
</authors>
<title>Regular expressions and predicate logic in finite-state language processing.</title>
<date>2008</date>
<booktitle>Proceedings of FSMNLP</booktitle>
<editor>In Piskorski, J., Watson, B., and Yli-Jyr¨a, A., editors,</editor>
<contexts>
<context position="4748" citStr="Hulden, 2008" startWordPosition="738" endWordPosition="739">ement rules 11 &lt;&gt; shuffle (asynchronous product) X o .x. .o. cross-product, composition Table 1: The regular expressions available in Foma from highest to lower precedence. Horizontal lines separate precedence classes. 30 define ContainsX ?* X ?*; define MyWords {cat}|{dog}|{mouse}; define MyRule n -&gt; m ||_ p; define ShortWords Mylex.i.l &amp; ?ˆ&lt;6; In addition to the basic regular expression operators shown in table 1, the formalism is extended in various ways. One such extension is the ability to use of a form of first-order logic to make existential statements over languages and transductions (Hulden, 2008). For instance, suppose we have defined an arbitrary regular language L, and want to further define a language that contains only one factor of L, we can do so by: OneL = (∃x)(x ∈ L ∧ ¬(∃y)(y ∈ L ∧ ¬(x = y))); Here, quantifiers apply to substrings, and we attribute the usual meaning to ∈ and ∧, and a kind of concatenative meaning to the predicate 5(t1, t2). Hence, in the above example, OneL defines the language where there exists a string x such that x is a member of the language L and there does not exist a string y, also in L, such that y would occur in a different position than x. This kind</context>
</contexts>
<marker>Hulden, 2008</marker>
<rawString>Hulden, M. (2008). Regular expressions and predicate logic in finite-state language processing. In Piskorski, J., Watson, B., and Yli-Jyr¨a, A., editors, Proceedings of FSMNLP 2008.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Karttunen</author>
<author>K Koskenniemi</author>
<author>R M Kaplan</author>
</authors>
<title>A compiler for two-level phonological rules.</title>
<date>1987</date>
<editor>In Dalrymple, M., Kaplan, R., Karttunen, L., Koskenniemi, K., Shaio, S., and Wescoat, M., editors,</editor>
<location>Palo Alto, CA.</location>
<contexts>
<context position="5926" citStr="Karttunen et al., 1987" startWordPosition="942" endWordPosition="945">cur in a different position than x. This kind of logical specification of regular languages can be very useful for building some languages that would be quite cumbersome to express with other regular expression operators. In fact, many of the internally complex operations of Foma are built through a reduction to this type of logical expressions. 3 Building morphological analyzers As mentioned, Foma supports reading and writing of the LEXC file format, where morphological categories are divided into so-called continuation classes. This practice stems back from the earliest two-level compilers (Karttunen et al., 1987). Below is a simple example of the format: Multichar_Symbols +Pl +Sing LEXICON Root Nouns; LEXICON Nouns cat Plural; church Plural; LEXICON Plural +Pl:%ˆs #; +Sing #; 4 An API example The Foma API gives access to basic functions, such as constructing a finite-state machine from a regular expression provided as a string, performing a transduction, and exhaustively matching against a given string starting from every position. The following basic snippet illustrates how to use the C API instead of the main interface of Foma to construct a finite-state machine encoding the language a+b+ and check </context>
</contexts>
<marker>Karttunen, Koskenniemi, Kaplan, 1987</marker>
<rawString>Karttunen, L., Koskenniemi, K., and Kaplan, R. M. (1987). A compiler for two-level phonological rules. In Dalrymple, M., Kaplan, R., Karttunen, L., Koskenniemi, K., Shaio, S., and Wescoat, M., editors, Tools for Morphological Analysis. CSLI, Palo Alto, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Mohri</author>
<author>F Pereira</author>
<author>M Riley</author>
<author>C Allauzen</author>
</authors>
<date>1997</date>
<booktitle>AT&amp;T FSM Library-Finite State Machine Library. AT&amp;T Labs—Research.</booktitle>
<contexts>
<context position="1178" citStr="Mohri et al., 1997" startWordPosition="159" endWordPosition="162">PARC format, a Perl-like format, and a mathematical format that takes advantage of the ‘Mathematical Operators’ Unicode block. 1 Introduction Foma is a finite-state compiler, programming language, and regular expression/finite-state library designed for multi-purpose use with explicit support for automata theoretic research, constructing lexical analyzers for programming languages, and building morphological/phonological analyzers, as well as spellchecking applications. The compiler allows users to specify finite-state automata and transducers incrementally in a similar fashion to AT&amp;T’s fsm (Mohri et al., 1997) and Lextools (Sproat, 2003), the Xerox/PARC finitestate toolkit (Beesley and Karttunen, 2003) and the SFST toolkit (Schmid, 2005). One of Foma’s design goals has been compatibility with the Xerox/PARC toolkit. Another goal has been to allow for the ability to work with n-tape automata and a formalism for expressing first-order logical constraints over regular languages and n-tapetransductions. Foma is licensed under the GNU general public license: in keeping with traditions of free software, the distribution that includes the source code comes with a user manual and a library of examples. The</context>
</contexts>
<marker>Mohri, Pereira, Riley, Allauzen, 1997</marker>
<rawString>Mohri, M., Pereira, F., Riley, M., and Allauzen, C. (1997). AT&amp;T FSM Library-Finite State Machine Library. AT&amp;T Labs—Research.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Schmid</author>
</authors>
<title>A programming language for finite-state transducers.</title>
<date>2005</date>
<booktitle>FiniteState Methods and Natural Language Processing FSMNLP</booktitle>
<editor>In Yli-Jyr¨a, A., Karttunen, L., and Karhum¨aki, J., editors,</editor>
<contexts>
<context position="1308" citStr="Schmid, 2005" startWordPosition="180" endWordPosition="181">ction Foma is a finite-state compiler, programming language, and regular expression/finite-state library designed for multi-purpose use with explicit support for automata theoretic research, constructing lexical analyzers for programming languages, and building morphological/phonological analyzers, as well as spellchecking applications. The compiler allows users to specify finite-state automata and transducers incrementally in a similar fashion to AT&amp;T’s fsm (Mohri et al., 1997) and Lextools (Sproat, 2003), the Xerox/PARC finitestate toolkit (Beesley and Karttunen, 2003) and the SFST toolkit (Schmid, 2005). One of Foma’s design goals has been compatibility with the Xerox/PARC toolkit. Another goal has been to allow for the ability to work with n-tape automata and a formalism for expressing first-order logical constraints over regular languages and n-tapetransductions. Foma is licensed under the GNU general public license: in keeping with traditions of free software, the distribution that includes the source code comes with a user manual and a library of examples. The compiler and library are implemented in C and an API is available. The API is in many ways similar to the standard C library &lt;reg</context>
</contexts>
<marker>Schmid, 2005</marker>
<rawString>Schmid, H. (2005). A programming language for finite-state transducers. In Yli-Jyr¨a, A., Karttunen, L., and Karhum¨aki, J., editors, FiniteState Methods and Natural Language Processing FSMNLP 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Sproat</author>
</authors>
<title>Lextools: a toolkit for finite-state linguistic analysis.</title>
<date>2003</date>
<journal>AT&amp;T Labs— Research.</journal>
<contexts>
<context position="1206" citStr="Sproat, 2003" startWordPosition="165" endWordPosition="166">nd a mathematical format that takes advantage of the ‘Mathematical Operators’ Unicode block. 1 Introduction Foma is a finite-state compiler, programming language, and regular expression/finite-state library designed for multi-purpose use with explicit support for automata theoretic research, constructing lexical analyzers for programming languages, and building morphological/phonological analyzers, as well as spellchecking applications. The compiler allows users to specify finite-state automata and transducers incrementally in a similar fashion to AT&amp;T’s fsm (Mohri et al., 1997) and Lextools (Sproat, 2003), the Xerox/PARC finitestate toolkit (Beesley and Karttunen, 2003) and the SFST toolkit (Schmid, 2005). One of Foma’s design goals has been compatibility with the Xerox/PARC toolkit. Another goal has been to allow for the ability to work with n-tape automata and a formalism for expressing first-order logical constraints over regular languages and n-tapetransductions. Foma is licensed under the GNU general public license: in keeping with traditions of free software, the distribution that includes the source code comes with a user manual and a library of examples. The compiler and library are im</context>
</contexts>
<marker>Sproat, 2003</marker>
<rawString>Sproat, R. (2003). Lextools: a toolkit for finite-state linguistic analysis. AT&amp;T Labs— Research.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>