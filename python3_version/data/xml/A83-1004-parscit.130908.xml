<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.997087">
A Robust Portable Natural Language Data Base Interface
</title>
<author confidence="0.805015">
Jerrold M. Ginsparg
</author>
<affiliation confidence="0.467412">
Bell Laboratories
Murray Hill, New Jersey 07974
</affiliation>
<email confidence="0.55048">
ABSTRACT
</email>
<bodyText confidence="0.9998799">
This paper describes a NL data base interface
which consists of two parts: a Natural Language Pro-
cessor (NLP) and a data base application program
(DBAP). The NLP is a general purpose language pro-
cessor which builds a formal representation of the
meaning of the English utterances it is given. The
DBAP is an algorithm with builds a query in a aug-
mented relational algebra from the output of the NIP.
This approach yields an interface which is both
extremely robust and portable.
</bodyText>
<sectionHeader confidence="0.99521" genericHeader="abstract">
1. Introduction
</sectionHeader>
<bodyText confidence="0.999981764705883">
This paper describes an extremely robust and portable NL data
base interface which consists of two parts: a Natural Language
Processor (NLP) and a data base application program (DBAP).
The NLP is a general purpose language processor which builds a
formal representation of the meaning of the English utterances it
is given. The DBAP is an algorithm with builds a query in an
augmented relational algebra from the output of the NLP.
The system is portable, or data base independent, because all that
is needed to set up a new data base interface are definitions for
concepts the NLP doesn&apos;t have, plus what I will call the &amp;quot;data
base connection&amp;quot;, i.e., the connection between the relations in the
data base and the NLP&apos;s concepts. Demonstrating the portability
and the robustness gained from using a general purpose NLP are
the main subjects of this paper Discussion of the NLP will be
limited to its interaction with the DBAP and the data base con-
nection, which by design, is minimal. (Ginsparg 51 contains a
description of the NIP parsing algorithm.
</bodyText>
<sectionHeader confidence="0.974588" genericHeader="method">
2. NLP overview
</sectionHeader>
<bodyText confidence="0.943288142857143">
The formal language the NLP uses to represent meaning is a vari-
ant of semantic nets (QuiMan 81. For example, the utterances
&amp;quot;The color of the house is green.&amp;quot;
&amp;quot;The house&apos;s color is green.&amp;quot;
&amp;quot;Green is the color that the house is.&amp;quot;
would all be transformed to:
g 1 lsa: &apos;colored
</bodyText>
<footnote confidence="0.500283857142857">
Tense: present
Colored: g2
Color g3
g2 lsa: &apos;house
Definite: the
g3 lsa: &apos;color
Value: green
</footnote>
<bodyText confidence="0.98073124">
where &amp;quot;colored&amp;quot;, &amp;quot;Color&amp;quot; and &amp;quot;house&amp;quot; are system primitives
called concepts. Each concept is an extended case frame.
(Fillmore 21. The meaning of each concept to the system is
implicit in its relation to the other system concepts and the way
the system manipulates it.
Each concept has case preferences associated with its cases. For
example, the case preference of color is &apos;color and the case prefer-
ence of colored is &apos;physical-object.
The case preferences induce a network among the concepts. For
example, &apos;color is connected to &apos;physical-object via the path:
(&amp;quot;physical-object co/oreecolored color &apos;colon. In addition. &apos;color
is connected to &apos;writing-implement, a refinement of &apos;physical&apos;
object, by a path whose meaning is that the writing implement
writes with that color. This network is used by the NLP to deter-
mine the meaning of many modifications. For example. &amp;quot;red pen-
cil&amp;quot; is either a pencil which is red or a pencil that writes red,
depending on which path is chosen. In the absence of contextual
information, the NLP chooses the shortest path.
In normal usage, case preferences are often broken. The meaning
of the broken preference involves coercing the offending concept
to another one via a path in the network. Examples are:
&amp;quot;Turn on the soup.&amp;quot;
&amp;quot;Turn on the burner that has soup on it.&amp;quot;
&amp;quot;My car will drink beer.&amp;quot;
&amp;quot;The passengers in my car will drink beer.&amp;quot;
</bodyText>
<sectionHeader confidence="0.968929" genericHeader="method">
3. The Data Base Connection
</sectionHeader>
<bodyText confidence="0.966388">
Consider the data base given by the following scheme:
</bodyText>
<equation confidence="0.6735005">
Suppliers(sno.sname.scity)
Projects(jno.jname,jcity)
Parts(pno,pname.color.cost,weight)
Spj(sno.pnodno.quantity,m,y1
</equation>
<bodyText confidence="0.8502895">
Suppliers and protects have a number. name and city Parts ha■t:
a number, name, color, cost and weight Supplier %in, supplies
quantity of parts 11170 to protect mo in month ■PI 01 year
The data base connection has four parts:
</bodyText>
<footnote confidence="0.9728388">
1 Connecting each relation to the appropriate concept:
Suppliers -&gt; &apos;supplier
Projects -&gt; &apos;protect
Parts -&gt; &apos;part
Spj -&gt; &apos;supply
</footnote>
<page confidence="0.998735">
25
</page>
<bodyText confidence="0.767770333333333">
Spjlsno,pno.jno.cost.quantity)) in which the cost of a part
depended on the supplier.
2. Connecting each attribute to the appropriate concept:
</bodyText>
<equation confidence="0.986450375">
sno.pno.jno -&gt; &apos;indexing-number
sname.pname.jname -&gt; •name
jcity.scity -&gt; &apos;city
m -&gt; &apos;month
y -&gt; &apos;year
cost -&gt; &apos;cost
weight -&gt; &apos;weight
quantity -&gt; &apos;quantity
</equation>
<listItem confidence="0.48572">
3. Capturing the information implicit in each relation:
</listItem>
<equation confidence="0.997834042553191">
Parts(pno.pname.color.cost.weight)
&apos;indexnumberp
indexnumber -&gt; pno
numbered -&gt; Parts
&apos;named
name -&gt; pname
named -&gt; Parts
&apos;colored
color -&gt; color
colored .&gt; Parts
&apos;costs
cost -&gt; cost
costobj -&gt; Parts
&apos;weighs
weight -&gt; weight
weightobj -&gt; Parts
Projects(jno.jnamejcity)
&apos;indexnumberp
indexnumber -&gt; jno
numbered -&gt; Projects
&apos;named
name -&gt; jname
named -&gt; Projects
located
location -&gt; jcity
located -&gt; Protects
Suppliers(sno.sname,scity)
&apos;indexnumberp
indexnumber -&gt; sno
numbered -&gt; Suppliers
•named
name -&gt; sname
named -&gt; Suppliers
located
location -&gt; icily
located -&gt; Suppliers
Spitsno.pno.ino.quantity.m.y)
&apos;supply
supplier -&gt; sno
supplied -&gt; poo
suppliee -&gt; no
icardinality-of ono) • &gt; quantity
iime -&gt; cm,/
&amp;quot;spend
spender -&gt; init
spendfor -&gt; pno
amount 1- cost quantity)
</equation>
<bodyText confidence="0.977593407407407">
The amount case of &apos;spend maps to a computation rather than a
single attribute. If all the attributes in the computation are not
present in the relation being defined, the query building program
loins in the necessary extra relations. So the definition of &apos;spend
%orks equally well in the example scheme as well as in a scheme
4. Creating pseudo relations
Pseudo Cities jcity.scity
This creates a pseudo relation. Citiestcnamel, so that the query
building algorithm can treat all attributes as if they belong to a
relation. The query produced by the system will refer to the
Cities relation. A postprocessor is used to remove references to
pseudo relations from the final query. Pseudo relations are
important because they ensure uniform handling of attributes.
With the pseudo Cities relation, questions like Who supplies
every city?&amp;quot; and &amp;quot;List the cities.&amp;quot; can be treated identically to
&amp;quot;Who supplies every project?&amp;quot; and &amp;quot;List the suppliers.&amp;quot;
The remainder of the data base connection is a set of switches
which provide information on how to print out the relations.
whether all proper nouns have been defined or are to be inferred.
whether relations are multivalued. etc. The switch settings and
the four components above constitute the entire data base con-
nection. Nothing else is needed.
The network of concepts in the NLP should only be augmented
for a particular data base: never changed. Yet different data base
schemes will require different representations for the same word.
For example. depending on the data base scheme. it could be
correct to represent &amp;quot;box&amp;quot; as either.
</bodyText>
<equation confidence="0.711221">
g I Isa: &apos;part
Conditions: •namedtgl.boxi
g2 Isa: &apos;container
Conditions: •namedIg2.box)
g3 Isa: &apos;box
</equation>
<bodyText confidence="0.9998555">
The solution is to define each word to map to the lowest possible
concept. When a concept is encountered that has a data base rela-
tion associated with it. there is no problem. If there is no relation
associated with a concept. the NLP searchs for a concept that does
correspond to a relation and is also a generalization of the concept
in question. If one is found, it is used with an appropriate condi-
tion, usually &apos;titled or &apos;named. So &amp;quot;box&amp;quot; has a definition which
maps to &apos;box. In the data base connection given above. &amp;quot;box&amp;quot;
would be instantiated as a &amp;quot;&apos;part&amp;quot; since &amp;quot;&apos;box&amp;quot; is a refinement of
&amp;quot;&apos;part&amp;quot; and no relation maps to &amp;quot;box.&amp;quot;
</bodyText>
<sectionHeader confidence="0.525483" genericHeader="method">
4. Using the Connection
</sectionHeader>
<bodyText confidence="0.999802333333333">
The information in the data base connection is primarily used in
building the query (section 5.). But it is also used to augment the
knowledge base of the NLP.
The data base connection is used to overwrite the NLP&apos;s ease
preferences. Since located -&gt; Suppliers or Proiects, the preference
of located is specified to &apos;suppliers or &apos;protects. Thts enables the
NLP to interpret the first noun group in &amp;quot;Do am suppliers that
supply widgets located in london tits° supply screws &apos;&amp;quot; as &amp;quot;suppliers
in London that supply widgets&amp;quot; rather than &amp;quot;suppliers that suppl%
London widgets&amp;quot;. This is in contrast to 1Gawron 31 which uses
separate &amp;quot;disambiguator&amp;quot; phase to eliminate parses that in not
make sense in the conceptual scheme of the data base.
The additional preference information supplied bv the data base
connection is used to induce coercions (section 2.) that would not
be made in the absence of the connection or under another data
</bodyText>
<page confidence="0.972554">
26
</page>
<bodyText confidence="0.997654314285714">
base scheme. &apos;Who supplies London&amp;quot; does not break any real
world preferences, but does break one of the preferences induced
by this data base scheme, namely that Suppliee is a &apos;project. Lon-
don. a &apos;city, is coerced to &apos;project via the path (*project located
&apos;located location &apos;cityl and the question is understood to mean
&amp;quot;Who supplies projects which are in London.&amp;quot;
As mentioned in Section 2.. the NLP determines the meanings of
many modifications by searching for connections in a semantic
net. The data base connection is used to augment and highlight
the existing network of the NLP. If the user says, &amp;quot;What colors
do parts come in?&apos;, the NLP can infer that the meaning of
&amp;quot;come-in&amp;quot; intended by the user is &apos;colored since the only path
through the net between &apos;color and &apos;part derived from the case
preferences induced by the data base connection is
[&apos;part colored &apos;colored color &apos;colon1
Similarly, when given the noun group &amp;quot;London suppliers&amp;quot; the
meaning is determined by tracing the shortest path through the
highlighted net,
(*supplier located &apos;located location &apos;city&apos;
The longer path connecting &apos;supplier and &apos;city,
[&apos;supplier supplier &apos;supply suppliee &apos;project located &apos;location loca-
tion &apos;cityi
which means &amp;quot;the suppliers that supply to london projects&amp;quot; is
found when the NLP rejects the first meaning because of context.
If the user says &amp;quot;What are the locations of the London suppliers&amp;quot;
the system assumes the second meaning since the first lin the
domain of this data base scheme) leads to a tautological reading.
The NLP is able to infer that &amp;quot;The locations of the suppliers
located in London&amp;quot; is tautological while &amp;quot;The locations of the sup-
pliers located in England&apos; is not, because the data base connection
has specified &apos;located to be a single valued concept with its loca-
tion case typed to &apos;city. If the system were asked for the locations
of suppliers in England. and it knew England was a country, the
question would be interpreted as &amp;quot;the cities of the suppliers that
are located in cities located in England.&amp;quot;
</bodyText>
<sectionHeader confidence="0.848102" genericHeader="method">
5. A trace of the query building algorithm.
</sectionHeader>
<bodyText confidence="0.99580225">
The query building algorithm is illustrated by tracing its operation
on the question. &amp;quot;Does blake supply any projects in london?&amp;quot;
The NLP&apos;s meaning representation for this question is shown
below.
</bodyText>
<tableCaption confidence="0.799495928571429">
g9 Isa: &apos;named
Tense: present
Named: g3
Name: g5
g 10 !sic &apos;located
Tense: present
Located: g6
Location: g7
g I I !sic &apos;named
Tense: present
Named: g7
Name: g12
gI2 Isa: &apos;name
Value: london
</tableCaption>
<bodyText confidence="0.811062411764706">
The NLP treats most true-false questions with indefinites JS
requests for the data which would make the statement true. The
question&apos;s meaning is &amp;quot;to show the subset of london projects that
are supplied by Blake.&amp;quot;
The query building algorithm builds up the query recursively.
Given an instantiated concept with cases, it expands the contents
of each case and links the results together with the relation
corresponding to the concept. Given an instantiated concept with
conditions, it expands each condition. For the example, we have.
1&gt; Expand gl
2&gt; Expand g2, the Element of gl
3&gt; Expand g8, the Condition of g2.
4&gt; Expand g.3, the Supplier case of g8.
5 Expand g9, the Condition of g3. From the data base con-
nection, a &apos;named whose named case is a &apos;supplier is real-
ized by the Suppliers relation using the sname attribute So
we have.
</bodyText>
<equation confidence="0.842703">
4&lt; g9 .0 select from Suppliers where sname — blake
</equation>
<bodyText confidence="0.96329025">
3&lt; From the data base connection. a &apos;supply is realized by the
Spj relation. This results in,
g8a .■ project jno from join Spj to g9
2&lt; g8 = join g8a to Projects
g8 is the projects supplied by Blake.
2&gt; Expand g4, the set gl is a subset of. by expanding its ele-
ment, g6
3&gt; Expand g10. the Condition of g6
4 Expand g7. the location case of g10 yielding
gl 1 = select .from Cities where cname london
3&lt; A &apos;located with a &apos;project in the located case is realized by
the Projects relation using the jcity attribute. So we have.
glOa join Projects to gl 1 where jetty cname
glOb = project jno from glOa
2&lt; join glOb to Projects
gl0 is the projects in London.
I &lt; Intersect the expansions of g2 and g4 and project the project
names.
513 project Mame from intersection g8 g 10
The entire query is.
g9 select from Suppliers where sname = blake
g8a protect jno from join Spj to g9
g8 join g8a to Projects
g 10 select from Projects where icity london
gI3 = prowl iname from intersection g8 a I 0
where the extra tom resulting from the pseudo Cities relation has
been removed by the post processor (section 3.)
Entirely as a side effect of the way the query is generated, the s
ss-
tern can easily correct any false assumptions made by [he user
(Kaplan 71. For example, if there were no projects in London. gin
would be empty and system would respond, generatine from the
instantiated concept gi0 (i.e.. the names used in query correspond
to the names used in the knowledge representation). &amp;quot;There .ire
no suppliers located in London.&amp;quot; No additional &amp;quot;totaled
presupposition&amp;quot; mechanism is required.
</bodyText>
<table confidence="0.979497769230769">
g0 Isa: &apos;show g5 Isa: &apos;name
Tense: present Value: blake
Toshow: at go Isa: &apos;project
tl Isa: •set Element-of: a4
Element: g2 Conditions: g10
Subset-of: g4 g7 Isa: city
g2 Isa: &apos;protect Conditions: g I I
Conditions: g8 g8 Isa: &apos;supply
g3 Isa: &apos;supplier Tense: Present
Conditions: g9 Suppler: g3
e‘l Isa: &apos;set Suppliee: g2
Subsets: gl
Element: g6
</table>
<page confidence="0.998327">
27
</page>
<bodyText confidence="0.9995374">
The remainder of this section discusses several aspects of the
query building process that the trace does not show.
Negations are handled by introducing a set difference when neces-
sary If the example query were &amp;quot;Does Blake supply any projects
that aren&apos;t in London?&amp;quot;, the expansion of g7 would have been.
</bodyText>
<equation confidence="0.562503">
Expand g7, the location case of g10 yielding
glia = select front Cities where cname london
g I I = difference ofCities and gl la
</equation>
<bodyText confidence="0.976340666666667">
Conjunctions are handled by introducing an an intersection or
union. If the example query were &amp;quot;Does Blake supply any pro-
jects in London or Paris?&amp;quot;, the location case of g10 would have
</bodyText>
<figure confidence="0.936157916666667">
•
been the conjunction g13.
gI3 isa &apos;conjunction
Type: or
Conjoins: g7 g14
g14 Isa: &apos;city
Conditions: g15
gI5 Isa: *named
Named: gl5
Name: g16
g16 Isa: &apos;name
Value: paris
</figure>
<bodyText confidence="0.613757">
The result of expanding gI3 would be.
</bodyText>
<equation confidence="0.768117">
gl 1 = select from Cities where cname = london
e 1 5 = select from Cities where cname = pares
g 13 = Union ofgl I and g15
</equation>
<bodyText confidence="0.999908785714286">
In general. &amp;quot;or&amp;quot; becomes a union and &amp;quot;and&amp;quot; becomes an intersec-
tion. However, if an &amp;quot;and&amp;quot; conjunction is in a single valued case
(information obtained from the data base connection), a union is
used instead. Thus &amp;quot;Who supplies london and paris?&amp;quot; is inter-
preted as &amp;quot;Who supplies both London and Paris?&amp;quot; and &amp;quot;Who is in
London and Pans?&amp;quot; is interpreted as &amp;quot;Who is in London and who
is in Paris?&amp;quot; in the example data base scheme.
Quantifiers are handled by a post processing phase. &amp;quot;Does blake
supply every project in London?&amp;quot; is handled identically to &apos;Does
Blake supply a protect in London?&amp;quot; except that the expansion of
&amp;quot;projects in London&amp;quot; is marked so that the post processor will be
called. The post processor adds on a set of commands which
check that the set difference of London projects and London pro-
eels that Blake supplies is empty. The resulting query is.
</bodyText>
<equation confidence="0.976364666666667">
gl — select front Suppliers where sname = blake
g2 — select from Projects where jcity london
g3 = /oin Spj to g I
</equation>
<bodyText confidence="0.882291111111111">
g4 join g3 to g2
protect mo from g2
protect mo from g4
g7 ddierence ofg5 and g6
g8 emprvg7
The first four commands are the query for &amp;quot;Does Blake supply a
protect in London?&amp;quot;. The last four check that no project in Lon-
don is not supplied by Blake.
A minor modification is needed to cover cases in which the query
building algorithm is expanding an instantiated concept that refer-
ences an instantiated concept that is being expanded in a higher
recursive call. The following examples illustrate this. Consider
the data base scheme below, taken from [Ullman 91.
Frequents(drinker.bar)
Serves(bar,beer)
Likes(drinker,beer)
If we ask. &amp;quot;Who frequents a bar that serves a beer John likes&amp;quot;.
we get the following query.
</bodyText>
<equation confidence="0.4254344">
gl = select from Likes where drinker = john
g2 project beer from g 1
g3 join Serves to g2
g4 project bar from g3
g5 = join Frequents to g4
</equation>
<bodyText confidence="0.9940435">
If we ask &amp;quot;Who frequents a bar that serves a beer that he likes?&amp;quot;
the correct query is.
</bodyText>
<equation confidence="0.9809432">
gl = select from Likes
g2 = project beer.drinker from g I
g3 = join Serves to g2
•• PrOject drinker.bar from g3
g5 = join Frequents to g4
</equation>
<bodyText confidence="0.999439125">
In the first query &amp;quot;beer&amp;quot; was the only attribute projected from g I
In the second, the system projected both &amp;quot;beer&amp;quot; and &amp;quot;drinker&amp;quot;.
because in expanding &amp;quot;a beer he likes&amp;quot; it needed to expand an
instantiated concept (the one representing &amp;quot;who&amp;quot;) that was already
being expanded.
All of these cases interact gracefully with one another. For exam-
ple, there is no problem in handling &amp;quot;Who supplies every project
that is not supplied by blake and bowies&amp;quot;.
</bodyText>
<sectionHeader confidence="0.620305" genericHeader="method">
6. Advantages of this approach
</sectionHeader>
<bodyText confidence="0.999568161290322">
The system can understand anything it has a concept about.
regardless of whether the concept is attached to a relation in the
data base scheme. In the Suppliers data base from Section 4..
parts had costs and weights associated with them, but not sizes. If
a user asks &amp;quot;How big are each of the parts?&amp;quot; and the interface has
a &apos;size primitive (which it does), the query building process will
attempt to find the relation which &amp;quot;size maps to and on failing will
report back to the user. &amp;quot;There is no information in the data base
about the size of the parts.&amp;quot; This gives the user some information
about the what the data base contains. An answer like &amp;quot;I don&apos;i
know what &amp;quot;big&amp;quot; means.&amp;quot; would leave the user wondering whether
size information was in the data base and obtainable if only the
&amp;quot;right&amp;quot; word was used.
The system can interpret user statements that are not queries. If
the user says &amp;quot;A big supplier is a supplier that supplies more than
3 projects&amp;quot; the NLP can use, the definition in answering later
queries. The definition is not made on a &amp;quot;string&amp;quot; basis e.g.. substi-
tuting the words of one side of the definition for the other
Instead, whenever the query building algorithm encounters an
instantiated concept that is a supplier with the condition &apos;size( x.
big) it builds a query substituting the condition from the
definition that it can expand as a data base query Thus the sys-
tem can handle &amp;quot;big london suppliers&amp;quot; and answer &amp;quot;Which sup-
pliers are big&amp;quot; which it couldn&apos;t if it were doing strict string substi-
tution.
This facility can be used to bootstrap common definitions. In a
commercial flights application, with data base scheme.
Flights( fl#.carrier.from.to,departure,arrival.stops.cost
the word &amp;quot;nonstop&amp;quot; is defined to the system in English as. &amp;quot;A non-
stop flight is a flight that does not make any stops&apos; and then
saved along with the rest of the system&apos;s definitions.
</bodyText>
<page confidence="0.996432">
28
</page>
<bodyText confidence="0.998514425531915">
Coercions (section 2.) can be used solve problems that may
require inferences in other systems. (Grosz 61 discusses the
query &amp;quot;Is there a doctor within 200 miles of Philadelphia&amp;quot; in the
context of a scheme in which doctors are on ships and ships have
distances from cities, and asserts that a system which handles this
query must be able to infer that if a doctor is on a ship, and the
ship is with 200 miles of Philadelphia, then the doctor is within
200 miles of Philadelphia. Using coercions, the query would be
understood as &amp;quot;is there a ship with a doctor on it that is within
200 miles of Philadelphia?&amp;quot;, which solves the problem immedi-
ately.
Since the preference information is only used to choose among
competing interpretations, broken preferences can still be under-
stood and responded to. The preference for the supplier case is
specified to &apos;supplier but if the user says &amp;quot;How many parts does
the sorter project supply?&amp;quot; the NLP will find the only interpreta-
tion and respond &amp;quot;projects do not supply parts, suppliers do.&amp;quot;
Ambiguities inherent in attribute values are handled using the
same methods which handles words with multiple definitions. For
example. 1980 may be an organization number, a telephone
extension, a number, or a year.
The NLP has a rudimentary (so far) expert system inference
mechanism which can easily be used by the DBAP. One of the
rules it uses is &amp;quot;If x is a precondition of y and z knows y is true
then z knows x was and may still be true&amp;quot; One of the facts in the
NLP knowledge base is that being married is a precondition of
being divorced or widowed. If a user asks &amp;quot;Did Fred Smith used
to be married?&amp;quot; in a data base with the relation Employees(name,
marital-status) the system can answer correctly by using its infer-
ence mechanism. The exact method is as follows. The data base
application receives the true-false question:
&apos;Fred Smith was married and Fred Smith is no longer married&apos;
Since the data base includes only current marital status informa-
tion, the only way to answer the first part of the question is to
infer it from some other information in the data base. The data
base application sends the query to the NLP inference mechanism
which would ordinarily attempt to answer it by matching it against
its knowledge base or by finding a theorem which would gives it
something else to match for When called by the data base appli-
cation, the inference mechanism simply uses its rules base to
decide what it should match for, and then returns to the data base
program. In this, example, the inference mechanism receives
Fred Smith was married&amp;quot; and using the precondition rule men-
tioned above, returns to the data base program, &amp;quot;Is Fred Smith
divorced&amp;quot; or is Fred Smith widowed&amp;quot;, which can be answered by
the data base. The DBAP can call the inference mechanism
recursively if necessary.
</bodyText>
<sectionHeader confidence="0.37285" genericHeader="method">
7. Implementation Status and Details
</sectionHeader>
<bodyText confidence="0.999960333333333">
The DBAP is fully implemented and debugged. The NLP is
implemented and still growing. Both are implemented in Franz
Lisp. a dialect of LISP. Language processing and query genera-
tion are performed in virtually real time (average 1-3 cpu
seconds) on a Vax 11-780.
The system is intended to be used with a Data Base Management
system. The interface between the DBAP and the DBMS is a
stralehtforward translator from relational algebra to the query
language of the DBMS. I have written a translator for Polaris
lGielan 41.
The system handles all the examples in this paper as well as a
wide range of others (Appendix A.). Several different data bases
schemes have been connected to the system for demonstrations,
including one &amp;quot;real data base&amp;quot; abstracted from the on-line listing
of the Bell Laboratories Company Directory.
</bodyText>
<sectionHeader confidence="0.817103" genericHeader="method">
8. References
</sectionHeader>
<reference confidence="0.979507307692308">
I. Cohen, P., Perrault C. and Allen J., Beyond Question-
Answering, Report No. 4644, Bolt Beranek and Newman
Inc., May 1981.
2. Fillmore C., The Case for Case, in Universals In Linguistic
Theory, Eds.. Bach E. and Harms. R., Holt. Rineheart and
Winston, New York, 1968.
3. Gawron M. G.. et. al., Processing English with a Generaked
Phrase Structure Grammar, 20th Annual Meeting of the
Association for Computational Linguistics. June 1982.
4. Gielan D., Polaris User Manual. New York Telephone
Company, January 1981.
5. Ginspargi., Natural Language Processing in an Automatic
Programming Domain, Memo 316. Stanford Artificial Intelli-
gence Laboratory, Stanford University, 1978.
6. Grosz, 8.. Transportable Natural-Language Interlaces: Prob-
lems and Techniques. 20th Annual Meeting of the Associa-
tion for Computational Linguistics, June 1982.
7. Kaplan, S. J., Cooperative Responses from a Portable Natural
Language Data Base Query System. Ph.D. dissertation,
Department of Computer and Information Sciences, Univer-
sity of Pennsylvania. Phila.. Pa.. 1979.
8. Quillian, M. R., Semantic Memory. in Minsky, M.. Ed..
Semantic Information Processing, The M.I.T. Press. 1968.
9. Ullman, J., Principles of Database Systems. Computer Sci-
ence Press, Potomac. Maryland, 1980.
Appendix A: Sample Questions and Answers
</reference>
<listItem confidence="0.539663">
• does every department head in 1135 have an office in holmdel?
No. all heads that work for center number 1135 are not located
in an office in ho
• who isn&apos;t
</listItem>
<bodyText confidence="0.9594455">
alles,h g is the head not located in an office in ho that works for
center number 1135
</bodyText>
<listItem confidence="0.839488">
• who has been with us for longer than fred smith?
</listItem>
<bodyText confidence="0.995255">
There are no employees that have worked for you or more than
the length of the time Fred smith has worked for you
</bodyText>
<listItem confidence="0.708308">
• list the employees who used to be married and are not married
now.
</listItem>
<bodyText confidence="0.842645">
paul rochester, verlon biggs and willie davis are the emploYees
that were married and that are not married now.
</bodyText>
<page confidence="0.99623">
29
</page>
<reference confidence="0.7090802">
production between February 1979 and april 1981 &apos; how much does the mixer project spend on widgets from blake
1352- 768 - widget - march 1981
1352 - 888 - widget - april 1981
1352 - 133 - screw - an 1980
1354- 133 - widget - an 1980
</reference>
<listItem confidence="0.508335">
• who flies between london and paris
</listItem>
<bodyText confidence="0.973885897435897">
twa and pan am are the airlines that fly from london into paris
&apos; get me a flight to paris from london before 3pm
a flight before 1500 into paris from london:
11# airline departure arrival plane stops price
2 pan am 1400 1800 del° 0 180
&apos; the latest flight out of london
the latest flight from london:
11# airline to departure arrival plane stops price
1 twa paris 1500 1700 dc10 3 280 •
&apos; who supplies more than two projects
bowies and blake are the suppliers that supply to more than 2 pro-
tects
• who supplies more than the boss project
the suppliers that supply to the projects besides the boss project
are:
decker. blake. bowies and white
• who supplies more projects than Decker
bowies and blake are the suppliers that supply to more projects
than the number of he projects that are supplied to by decker
&apos; list the suppliers who supply projects in cities they are not in
the suppliers that supply to the projects located in the cities in
which they are not located in are:
decker. blake. bowies and white
&apos; how mato, parts does white supply
There are 9 parts supplied by white
&amp;quot; how many different parts does white supply
There are 2 kinds of parts supplied by white
&apos; what are they
hos and screw ,ire the kinds ot parts supplied by while
&apos; who supplies the most kinds or parts
howl es is the supplier that supplies the most kinds of parts
&apos; how many does it supply
There are 4 kinds of parts supplied by the suppliers that supply
ihe most kinds of parts
440 is how much was spent by the mixer project on widgets sup-
plied by blake to it
&apos; how much did the mixer project spend on each part
widget - 649
box - 3
</bodyText>
<listItem confidence="0.6735345">
• print the drinkers that frequent only bars that serve some beer
that they like
</listItem>
<bodyText confidence="0.6551785">
george and john are the drinkers that frequent only bars that
serve some beers liked by them
</bodyText>
<page confidence="0.997321">
30
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.889078">
<title confidence="0.999089">A Robust Portable Natural Language Data Base Interface</title>
<author confidence="0.999992">Jerrold M Ginsparg</author>
<affiliation confidence="0.998833">Bell Laboratories</affiliation>
<address confidence="0.99981">Murray Hill, New Jersey 07974</address>
<abstract confidence="0.981237454545455">This paper describes a NL data base interface which consists of two parts: a Natural Language Processor (NLP) and a data base application program (DBAP). The NLP is a general purpose language processor which builds a formal representation of the meaning of the English utterances it is given. The DBAP is an algorithm with builds a query in a augmented relational algebra from the output of the NIP. This approach yields an interface which is both extremely robust and portable.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>I Cohen</author>
<author>C P Perrault</author>
<author>J Allen</author>
<author>Beyond QuestionAnswering</author>
</authors>
<date>1981</date>
<tech>Report No. 4644,</tech>
<institution>Bolt Beranek and Newman Inc.,</institution>
<marker>Cohen, Perrault, Allen, QuestionAnswering, 1981</marker>
<rawString> I. Cohen, P., Perrault C. and Allen J., Beyond QuestionAnswering, Report No. 4644, Bolt Beranek and Newman Inc., May 1981.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Fillmore</author>
</authors>
<title>The Case for Case, in Universals</title>
<date>1968</date>
<booktitle>In Linguistic Theory, Eds.. Bach</booktitle>
<location>New York,</location>
<marker>2.</marker>
<rawString>Fillmore C., The Case for Case, in Universals In Linguistic Theory, Eds.. Bach E. and Harms. R., Holt. Rineheart and Winston, New York, 1968.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M G Gawron</author>
</authors>
<date>1982</date>
<booktitle>Processing English with a Generaked Phrase Structure Grammar, 20th Annual Meeting of the Association for Computational Linguistics.</booktitle>
<marker>3.</marker>
<rawString>Gawron M. G.. et. al., Processing English with a Generaked Phrase Structure Grammar, 20th Annual Meeting of the Association for Computational Linguistics. June 1982.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Gielan</author>
</authors>
<title>Polaris User Manual.</title>
<date>1981</date>
<location>New York Telephone Company,</location>
<marker>4.</marker>
<rawString>Gielan D., Polaris User Manual. New York Telephone Company, January 1981.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ginspargi</author>
</authors>
<title>Natural Language Processing in an Automatic Programming Domain, Memo 316.</title>
<date>1978</date>
<institution>Stanford Artificial Intelligence Laboratory, Stanford University,</institution>
<marker>5.</marker>
<rawString>Ginspargi., Natural Language Processing in an Automatic Programming Domain, Memo 316. Stanford Artificial Intelligence Laboratory, Stanford University, 1978.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Grosz</author>
</authors>
<title>Transportable Natural-Language Interlaces: Problems and Techniques.</title>
<date>1982</date>
<booktitle>20th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<marker>6.</marker>
<rawString>Grosz, 8.. Transportable Natural-Language Interlaces: Problems and Techniques. 20th Annual Meeting of the Association for Computational Linguistics, June 1982.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S J Kaplan</author>
</authors>
<title>Cooperative Responses from a Portable Natural Language Data Base Query System.</title>
<date>1979</date>
<tech>Ph.D. dissertation,</tech>
<publisher>Phila.. Pa..</publisher>
<institution>Department of Computer and Information Sciences, University of Pennsylvania.</institution>
<marker>7.</marker>
<rawString>Kaplan, S. J., Cooperative Responses from a Portable Natural Language Data Base Query System. Ph.D. dissertation, Department of Computer and Information Sciences, University of Pennsylvania. Phila.. Pa.. 1979.</rawString>
</citation>
<citation valid="true">
<authors>
<author>in Minsky</author>
<author>M Ed</author>
</authors>
<title>Semantic Information Processing,</title>
<date>1968</date>
<publisher>The M.I.T. Press.</publisher>
<marker>8.</marker>
<rawString>Quillian, M. R., Semantic Memory. in Minsky, M.. Ed.. Semantic Information Processing, The M.I.T. Press. 1968.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Ullman</author>
</authors>
<title>Principles of Database Systems.</title>
<date>1980</date>
<booktitle>1352 - 888 - widget -</booktitle>
<publisher>Computer Science Press,</publisher>
<location>Potomac. Maryland,</location>
<marker>9.</marker>
<rawString>Ullman, J., Principles of Database Systems. Computer Science Press, Potomac. Maryland, 1980. Appendix A: Sample Questions and Answers production between February 1979 and april 1981 &apos; how much does the mixer project spend on widgets from blake 1352- 768 - widget - march 1981 1352 - 888 - widget - april 1981 1352 - 133 - screw - an 1980 1354- 133 - widget - an 1980</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>