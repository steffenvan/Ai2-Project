<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.033647">
<title confidence="0.931342">
Finite-State Non-Con.caten.ative Morphotactics
</title>
<author confidence="0.879478">
Kenneth R. Beesley and Lauri Karttunen
</author>
<affiliation confidence="0.8781225">
Xerox Research Centre Europe
Grenoble Laboratory
</affiliation>
<address confidence="0.9402965">
6, chemin de Maupertuis
38240 MEYLAN France
</address>
<email confidence="0.998748">
beesley@xrce.xerox.com, karttunenftrce.xerox.com
</email>
<sectionHeader confidence="0.995652" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9998675">
We describe a new technique for con-
structing finite-state transducers that in-
volves reapplying the regular-expression
compiler to its own output. Imple-
mented in an algorithm called compile-
replace, this technique has proved useful
for handling non-concatenative phenom-
ena; and we demonstrate it on Malay
full-stem reduplication and Arabic stem
interdigitation.
</bodyText>
<sectionHeader confidence="0.997904" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.996589685185185">
Most natural languages construct words by con-
catenating morphemes together in strict orders.
Such concatenative morphotactics can be impres-
sively productive, especially in agglutinative lan-
guages like Aymara or Turkish, and in aggluti-
native/polysynthetic languages like Inuktitut. In
such languages a single word may contain as
many morphemes as an average-length English
sentence.&apos;
Finite-state morphology in the tradition of
the Two-Level (Koskenniemi, 1983) and Xerox
implementations (Beesley and Karttunen, 2000)
has been very successful in implementing large-
scale, robust and efficient morphological analyzer-
generators for concatenative languages, including
the commercially important European languages
and non-Indo-European examples like Finnish,
Turkish and Hungarian. However, Koskenniemi
himself understood that his initial implementa-
tion had significant limitations in handling non-
concatenative morphotactic processes:
&amp;quot;Only restricted infixation and redupli-
cation can be handled adequately with
the present system. Some extensions or
&apos;Aymara utarnankaprarakiwa = &amp;quot;also they are in
your house:&amp;quot; Inuktitut: Parimunnyaujurnaniralauqsi-
manngittunga= &amp;quot;I never said I wanted to go to Paris.&amp;quot;
revisions will be necessary for an ade-
quate description of languages possess-
ing extensive infixation or reduplication&amp;quot;
(Koskenniemi, 1983, 27).
This limitation has of course not escaped the no-
tice of various reviewers, e.g. Sproat(1992). We
shall argue that the morphotactic limitations of
the traditional implementations are the direct re-
sult of relying solely on the concatenation opera-
tion in morphotactic description.
We describe a technique, within the Xerox im-
plementation of finite-state morphology, that cor-
rects the limitations at the source, going beyond
concatenation to allow the full range of finite-state
operations to be used in morphotactic description.
Regular-expression descriptions are compiled into
finite-state automata or transducers (collectively
called networks) as usual, and then the compiler
is re-applied to its own output, producing a modi-
fied but still finite-state network. This technique,
implemented in an algorithm called COMPILE-
REPLACE, has already proved useful for handling
Malay full-stem reduplication and Arabic stem in-
terdigitation, which will be described below. Be-
fore illustrating these applications, we will first
outline our general approach to finite-state mor-
phology.
</bodyText>
<sectionHeader confidence="0.994343" genericHeader="method">
2 Finite-State Morphology
</sectionHeader>
<subsectionHeader confidence="0.990436">
2.1 Analysis and Generation
</subsectionHeader>
<bodyText confidence="0.999951909090909">
In the most theory- and implementation-neutral
form, morphological analysis/generation of writ-
ten words can be modeled as a relation between
the words themselves and analyses of those words.
The basic claim or hope of the finite-state ap-
proach to natural-language morphology is that the
mapping from words to their analyses (and vice
versa) constitutes a regular relation, i.e. a relation
that can be represented by a finite-state trans-
ducer. The language to be analyzed consists of
strings (= words = sequences of symbols) writ-
</bodyText>
<figure confidence="0.996435925">
Analysis Strings
Regular Compiler ANALYSIS/
Expression GENERATION
Word Strings
Lexicon FST
Lexicon
Regular Expression
.o.
Lexical Transducer
(a single FST)
Rule FST
Rule
Regular Expression
i
b
0
9
0 +Comp
+Adj
b
r
i
9
e
0
9
Compiler
0:^[a * 0:^]
0:aa
*a
*:a
a
a
*:0
0
0
Lexical: b a g i +Noun +Plural
Surface: -[ {bagi} - 2 -]
Lexical: pelabuhan +Noun +Plural
Surface: -C{pelabuhan} - 2 -7
</figure>
<figureCaption confidence="0.97668">
Figure 8: Two Paths in the Initial Malay Transducer Defined via Concatenation
</figureCaption>
<figure confidence="0.89857175">
Lexical: bagi +Noun +Plural
Surface: bagibagi
Lexical: pelabuhan +Noun +Plural
Surface: pelabuhanpelabuhan
</figure>
<figureCaption confidence="0.999969">
Figure 9: The Malay FST After the Application of Compile-Replace to the Lower-Side Language
</figureCaption>
<bodyText confidence="0.989723518518518">
in L. We will show a simple and elegant way to do
this using strictly finite-state operations.
To understand the solution to full-stem redu-
plication using the compile-replace algorithm re-
quires a bit of background. In the Xerox regular-
expression calculus there are several operators
that involve concatenation. For example, if A is a
regular expression denoting a language or a rela-
tion, A* denotes zero or more and A+ denotes one
or more concatenations of A with itself. There are
also operators that express a fixed number of con-
catenations. Expressions of the form An, where n
is an integer, denote u concatenations of A. {abc}
denotes the concatenation of symbols a, b, and c.
We employ -[and -] as delimiter symbols around
regular-expression substrings.
The reduplication of any string w can then be
notated as {w}-2, and we start by defining a net-
work where the lower-side strings are built by sim-
ple concatenation of a prefix - [,a root enclosed in
braces, and an overt-plural suffix -2 followed by
the closing -] . Figure 8 shows the paths for two
Malay plurals in the initial network.
The compile-replace algorithm, applied to the
lower side of this network, recognizes each indi-
vidual delimited regular-expression substring like
C{bagi.}-21, compiles it, and replaces it with
the result of the compilation, here bagibagi. The
same process applies to the entire lower-side lan-
guage, resulting in a network that relates pairs of
strings such as the ones in Figure 9. This provides
the desired solution, still finite-state, for analyzing
and generating full-stem reduplication in Malay.3
3It is well-known (McCarthy and Prince, 1995)
that reduplication can be a more complex phe-
nomenon than it is in Malay. In some languages only
a part of the stem is reduplicated, and there may be
systematic differences between the reduplicate and the
base form. We believe that our approach to redupli-
cation can account for these complex phenomena as
well, but we cannot discuss the issue here due to lack
of space.
The special delimiters -[ and -] can be used to
surround any appropriate regular-expression sub-
string, using any necessary regular-expression op-
erators, and compile-replace may be applied to
the lower-side and/or upper-side of the network
as desired. There is nothing to stop the lin-
guist from inserting delimiters multiple times, in-
cluding via composition, and reapplying compile-
replace multiple times. The technique imple-
mented in compile-replace is a general way of al-
lowing the regular-expression compiler to reapply
to and modify its own output.
</bodyText>
<subsectionHeader confidence="0.9965605">
3.2 Semitic Stem Interdigitation
3.2.1 Review of Earlier Work
</subsectionHeader>
<bodyText confidence="0.999664153846154">
Much of the work in non-concatenative finite-
state morphotactics has been dedicated to han-
dling Semitic stem interdigitation. An example of
interdigitation occurs with the Arabic stem katab,
which means &amp;quot;wrote&amp;quot;. According to an influ-
ential autosegmental analysis (McCarthy, 1981),
this stem consists of an all-consonant root ktb
whose general meaning has to do with writing, an
abstract consonant-vowel template CVCVC, and a
voweling or vocalization that he symbolized sim-
ply as a, signifying perfect aspect and active voice.
The root consonants are associated with the C
slots of the template and the vowel or vowels
with the V slots, producing a complete stem katab.
If the root and the vocalization are thought of
as morphemes, neither morpheme occurs contin-
uously in the stem. The same root ktb can com-
bine with the template CVCVC and a different vo-
calization ui, signifying perfect aspect and pas-
sive voice, producing the stem kutib, which means
&amp;quot;was written&amp;quot;. Similarly, the root ktb can com-
bine with template CVVCVC and ui to produce
kuutib, the root drs can combine with CVCVC and
ui to form duris, and so forth.
Kay (1987) reformalized the autosegmental
tiers of McCarthy (1981) as projections of a
</bodyText>
<figure confidence="0.996604333333333">
C V V C V C
d r s
i
u
d V V r V s
d u u r i s
Lexical: ktb=RootCVCVC=Templatea+ =Voc
Surface: -Ektb .m&gt;. CVCVC .&lt;m. a+
Lexical: d r s =Root CVVCVC =Template u * i =Voc
</figure>
<figureCaption confidence="0.6314355">
Surface: -Edr s .m&gt;. CVVCVC u *
Figure 13: Initial paths
</figureCaption>
<figure confidence="0.9946505">
Lexical: k t b =Root CV CV C =Template a + =Voc
Surface: katab
Lexical: drs=RootCVVCVC=Templateu*i=Voc
Surface: duuris
</figure>
<figureCaption confidence="0.998842">
Figure 14: After Applying Compile-Replace to the Lower Side
</figureCaption>
<sectionHeader confidence="0.991394" genericHeader="conclusions">
5 Conclusion
</sectionHeader>
<bodyText confidence="0.999987">
The well-founded criticism of traditional imple-
mentations of finite-state morphology, that they
are limited to handling concatenative morpho-
tactics, is a direct result of their dependence on
the concatenation operation in morphotactic de-
scription. The technique described here, imple-
mented in the compile-replace algorithm, allows
the regular-expression compiler to reapply to and
modify its own output, effectively freeing mor-
photactic description to use any finite-state op-
eration. Significant experiments with Malay and
a much larger application in Arabic have shown
the value of this technique in handling two clas-
sic examples of non-concatenative morphotactics:
full-stem reduplication and Semitic stem interdig-
itation. Work remains to be done in applying
the technique to other known varieties of non-
concatenative morphotactics.
The compile-replace algorithm and the merge
operator introduced in this paper are general tech-
niques not limited to handling the specific mor-
photactic problems we have discussed. We expect
that they will have many other useful applications.
</bodyText>
<sectionHeader confidence="0.984496" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.932135063829787">
Evan L. Antworth. 1990. PC-KIMMO: a two-
level processor for morphological analysis. Sum-
mer Institute of Linguistics, Dallas.
Kenneth R. Beesley and Lauri Karttunen. 2000.
Finite-State Morphology: Xerox Tools and
Techniques. Cambridge University Press.
Forthcoming.
Kenneth R. Beesley. 1991. Computer analysis of
Arabic morphology: A two-level approach with
detours. In Perspectives on Arabic Linguistics
III: Papers from the Third Annual Symposium
on Arabic Linguistics, pages 155-172. Amster-
dam.
Kenneth R. Beesley. 1996. Arabic finite-state
morphological analysis and generation. In
COLING&apos;96, volume 1, pages 89-94.
Kenneth R. Beesley. 1998. Arabic morphology
using only finite-state operations. In Com-
putational Approaches to Semitic Languages:
Proceedings of the Workshop, pages 50-57,
Montreal, Quebec.
Lauri Karttunen, Ronald M. Kaplan, and Annie
Zaenen. 1992. Two-level morphology with com-
position. In COLING&apos;92, pages 141-148.
Laura Kataja and Kimmo Koskenniemi. 1988.
Finite-state description of Semitic morphology:
A case study of Ancient Akkadian. In COL-
ING &apos;88, pages 313-315.
Martin Kay. 1987. Nonconcatenative finite-state
morphology. In EACL &apos;87, pages 2-10.
George Anton Kiraz. 2000. Multi-tiered non-
linear morphology: A case study on Semitic.
Computational Linguistics, 26(1).
Kimmo Koskenniemi. 1983. Two-level mor-
phology: A general computational model for
word-form recognition and production. Publi-
cation 11, University of Helsinki, Department
of General Linguistics, Helsinki.
John J. McCarthy and Alan Prince. 1995. Faith-
fulness and reduplicative identity. Occasional
papers in Linguistics 18, University of Mas-
sachusetts, Amherst, MA. ROA-60.
John J. McCarthy. 1981. A prosodic theory of
nonconcatenative morphology. Linguistic In-
quiry, 12(3):373-418.
Richard Sproat. 1992. Morphology and Computa-
tion. MIT Press, Cambridge, MA.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.630766">
<title confidence="0.999433">Finite-State Non-Con.caten.ative Morphotactics</title>
<author confidence="0.99992">Kenneth R Beesley</author>
<author confidence="0.99992">Lauri Karttunen</author>
<affiliation confidence="0.964463">Xerox Research Centre Europe Grenoble Laboratory</affiliation>
<address confidence="0.882239">6, chemin de Maupertuis 38240 MEYLAN France</address>
<email confidence="0.999843">beesley@xrce.xerox.com,karttunenftrce.xerox.com</email>
<abstract confidence="0.989097">We describe a new technique for constructing finite-state transducers that involves reapplying the regular-expression compiler to its own output. Implemented in an algorithm called compilereplace, this technique has proved useful for handling non-concatenative phenomena; and we demonstrate it on Malay full-stem reduplication and Arabic stem interdigitation.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Evan L Antworth</author>
</authors>
<title>PC-KIMMO: a twolevel processor for morphological analysis. Summer Institute of Linguistics,</title>
<date>1990</date>
<location>Dallas.</location>
<marker>Antworth, 1990</marker>
<rawString>Evan L. Antworth. 1990. PC-KIMMO: a twolevel processor for morphological analysis. Summer Institute of Linguistics, Dallas.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth R Beesley</author>
<author>Lauri Karttunen</author>
</authors>
<title>Finite-State Morphology: Xerox Tools and Techniques.</title>
<date>2000</date>
<publisher>Cambridge University Press. Forthcoming.</publisher>
<contexts>
<context position="1128" citStr="Beesley and Karttunen, 2000" startWordPosition="144" endWordPosition="147">enomena; and we demonstrate it on Malay full-stem reduplication and Arabic stem interdigitation. 1 Introduction Most natural languages construct words by concatenating morphemes together in strict orders. Such concatenative morphotactics can be impressively productive, especially in agglutinative languages like Aymara or Turkish, and in agglutinative/polysynthetic languages like Inuktitut. In such languages a single word may contain as many morphemes as an average-length English sentence.&apos; Finite-state morphology in the tradition of the Two-Level (Koskenniemi, 1983) and Xerox implementations (Beesley and Karttunen, 2000) has been very successful in implementing largescale, robust and efficient morphological analyzergenerators for concatenative languages, including the commercially important European languages and non-Indo-European examples like Finnish, Turkish and Hungarian. However, Koskenniemi himself understood that his initial implementation had significant limitations in handling nonconcatenative morphotactic processes: &amp;quot;Only restricted infixation and reduplication can be handled adequately with the present system. Some extensions or &apos;Aymara utarnankaprarakiwa = &amp;quot;also they are in your house:&amp;quot; Inuktitut:</context>
</contexts>
<marker>Beesley, Karttunen, 2000</marker>
<rawString>Kenneth R. Beesley and Lauri Karttunen. 2000. Finite-State Morphology: Xerox Tools and Techniques. Cambridge University Press. Forthcoming.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth R Beesley</author>
</authors>
<title>Computer analysis of Arabic morphology: A two-level approach with detours.</title>
<date>1991</date>
<booktitle>In Perspectives on Arabic Linguistics III: Papers from the Third Annual Symposium on Arabic Linguistics,</booktitle>
<pages>155--172</pages>
<location>Amsterdam.</location>
<marker>Beesley, 1991</marker>
<rawString>Kenneth R. Beesley. 1991. Computer analysis of Arabic morphology: A two-level approach with detours. In Perspectives on Arabic Linguistics III: Papers from the Third Annual Symposium on Arabic Linguistics, pages 155-172. Amsterdam.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth R Beesley</author>
</authors>
<title>Arabic finite-state morphological analysis and generation.</title>
<date>1996</date>
<booktitle>In COLING&apos;96,</booktitle>
<volume>1</volume>
<pages>89--94</pages>
<marker>Beesley, 1996</marker>
<rawString>Kenneth R. Beesley. 1996. Arabic finite-state morphological analysis and generation. In COLING&apos;96, volume 1, pages 89-94.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth R Beesley</author>
</authors>
<title>Arabic morphology using only finite-state operations.</title>
<date>1998</date>
<booktitle>In Computational Approaches to Semitic Languages: Proceedings of the Workshop,</booktitle>
<pages>50--57</pages>
<location>Montreal, Quebec.</location>
<marker>Beesley, 1998</marker>
<rawString>Kenneth R. Beesley. 1998. Arabic morphology using only finite-state operations. In Computational Approaches to Semitic Languages: Proceedings of the Workshop, pages 50-57, Montreal, Quebec.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
<author>Ronald M Kaplan</author>
<author>Annie Zaenen</author>
</authors>
<title>Two-level morphology with composition.</title>
<date>1992</date>
<booktitle>In COLING&apos;92,</booktitle>
<pages>141--148</pages>
<marker>Karttunen, Kaplan, Zaenen, 1992</marker>
<rawString>Lauri Karttunen, Ronald M. Kaplan, and Annie Zaenen. 1992. Two-level morphology with composition. In COLING&apos;92, pages 141-148.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Laura Kataja</author>
<author>Kimmo Koskenniemi</author>
</authors>
<title>Finite-state description of Semitic morphology: A case study of Ancient Akkadian.</title>
<date>1988</date>
<booktitle>In COLING &apos;88,</booktitle>
<pages>313--315</pages>
<marker>Kataja, Koskenniemi, 1988</marker>
<rawString>Laura Kataja and Kimmo Koskenniemi. 1988. Finite-state description of Semitic morphology: A case study of Ancient Akkadian. In COLING &apos;88, pages 313-315.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Martin Kay</author>
</authors>
<title>Nonconcatenative finite-state morphology.</title>
<date>1987</date>
<booktitle>In EACL &apos;87,</booktitle>
<pages>2--10</pages>
<contexts>
<context position="8028" citStr="Kay (1987)" startWordPosition="1227" endWordPosition="1228">ice. The root consonants are associated with the C slots of the template and the vowel or vowels with the V slots, producing a complete stem katab. If the root and the vocalization are thought of as morphemes, neither morpheme occurs continuously in the stem. The same root ktb can combine with the template CVCVC and a different vocalization ui, signifying perfect aspect and passive voice, producing the stem kutib, which means &amp;quot;was written&amp;quot;. Similarly, the root ktb can combine with template CVVCVC and ui to produce kuutib, the root drs can combine with CVCVC and ui to form duris, and so forth. Kay (1987) reformalized the autosegmental tiers of McCarthy (1981) as projections of a C V V C V C d r s i u d V V r V s d u u r i s Lexical: ktb=RootCVCVC=Templatea+ =Voc Surface: -Ektb .m&gt;. CVCVC .&lt;m. a+ Lexical: d r s =Root CVVCVC =Template u * i =Voc Surface: -Edr s .m&gt;. CVVCVC u * Figure 13: Initial paths Lexical: k t b =Root CV CV C =Template a + =Voc Surface: katab Lexical: drs=RootCVVCVC=Templateu*i=Voc Surface: duuris Figure 14: After Applying Compile-Replace to the Lower Side 5 Conclusion The well-founded criticism of traditional implementations of finite-state morphology, that they are limite</context>
</contexts>
<marker>Kay, 1987</marker>
<rawString>Martin Kay. 1987. Nonconcatenative finite-state morphology. In EACL &apos;87, pages 2-10.</rawString>
</citation>
<citation valid="true">
<authors>
<author>George Anton Kiraz</author>
</authors>
<title>Multi-tiered nonlinear morphology: A case study on Semitic.</title>
<date>2000</date>
<journal>Computational Linguistics,</journal>
<volume>26</volume>
<issue>1</issue>
<marker>Kiraz, 2000</marker>
<rawString>George Anton Kiraz. 2000. Multi-tiered nonlinear morphology: A case study on Semitic. Computational Linguistics, 26(1).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kimmo Koskenniemi</author>
</authors>
<title>Two-level morphology: A general computational model for word-form recognition and production.</title>
<date>1983</date>
<journal>Publication</journal>
<volume>11</volume>
<institution>University of Helsinki, Department of General Linguistics,</institution>
<location>Helsinki.</location>
<contexts>
<context position="1072" citStr="Koskenniemi, 1983" startWordPosition="139" endWordPosition="140">roved useful for handling non-concatenative phenomena; and we demonstrate it on Malay full-stem reduplication and Arabic stem interdigitation. 1 Introduction Most natural languages construct words by concatenating morphemes together in strict orders. Such concatenative morphotactics can be impressively productive, especially in agglutinative languages like Aymara or Turkish, and in agglutinative/polysynthetic languages like Inuktitut. In such languages a single word may contain as many morphemes as an average-length English sentence.&apos; Finite-state morphology in the tradition of the Two-Level (Koskenniemi, 1983) and Xerox implementations (Beesley and Karttunen, 2000) has been very successful in implementing largescale, robust and efficient morphological analyzergenerators for concatenative languages, including the commercially important European languages and non-Indo-European examples like Finnish, Turkish and Hungarian. However, Koskenniemi himself understood that his initial implementation had significant limitations in handling nonconcatenative morphotactic processes: &amp;quot;Only restricted infixation and reduplication can be handled adequately with the present system. Some extensions or &apos;Aymara utarna</context>
</contexts>
<marker>Koskenniemi, 1983</marker>
<rawString>Kimmo Koskenniemi. 1983. Two-level morphology: A general computational model for word-form recognition and production. Publication 11, University of Helsinki, Department of General Linguistics, Helsinki.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John J McCarthy</author>
<author>Alan Prince</author>
</authors>
<title>Faithfulness and reduplicative identity. Occasional papers in Linguistics 18,</title>
<date>1995</date>
<institution>University of Massachusetts,</institution>
<location>Amherst, MA. ROA-60.</location>
<contexts>
<context position="5915" citStr="McCarthy and Prince, 1995" startWordPosition="878" endWordPosition="881">ing -] . Figure 8 shows the paths for two Malay plurals in the initial network. The compile-replace algorithm, applied to the lower side of this network, recognizes each individual delimited regular-expression substring like C{bagi.}-21, compiles it, and replaces it with the result of the compilation, here bagibagi. The same process applies to the entire lower-side language, resulting in a network that relates pairs of strings such as the ones in Figure 9. This provides the desired solution, still finite-state, for analyzing and generating full-stem reduplication in Malay.3 3It is well-known (McCarthy and Prince, 1995) that reduplication can be a more complex phenomenon than it is in Malay. In some languages only a part of the stem is reduplicated, and there may be systematic differences between the reduplicate and the base form. We believe that our approach to reduplication can account for these complex phenomena as well, but we cannot discuss the issue here due to lack of space. The special delimiters -[ and -] can be used to surround any appropriate regular-expression substring, using any necessary regular-expression operators, and compile-replace may be applied to the lower-side and/or upper-side of the</context>
</contexts>
<marker>McCarthy, Prince, 1995</marker>
<rawString>John J. McCarthy and Alan Prince. 1995. Faithfulness and reduplicative identity. Occasional papers in Linguistics 18, University of Massachusetts, Amherst, MA. ROA-60.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John J McCarthy</author>
</authors>
<title>A prosodic theory of nonconcatenative morphology.</title>
<date>1981</date>
<journal>Linguistic Inquiry,</journal>
<pages>12--3</pages>
<contexts>
<context position="7176" citStr="McCarthy, 1981" startWordPosition="1079" endWordPosition="1080">the linguist from inserting delimiters multiple times, including via composition, and reapplying compilereplace multiple times. The technique implemented in compile-replace is a general way of allowing the regular-expression compiler to reapply to and modify its own output. 3.2 Semitic Stem Interdigitation 3.2.1 Review of Earlier Work Much of the work in non-concatenative finitestate morphotactics has been dedicated to handling Semitic stem interdigitation. An example of interdigitation occurs with the Arabic stem katab, which means &amp;quot;wrote&amp;quot;. According to an influential autosegmental analysis (McCarthy, 1981), this stem consists of an all-consonant root ktb whose general meaning has to do with writing, an abstract consonant-vowel template CVCVC, and a voweling or vocalization that he symbolized simply as a, signifying perfect aspect and active voice. The root consonants are associated with the C slots of the template and the vowel or vowels with the V slots, producing a complete stem katab. If the root and the vocalization are thought of as morphemes, neither morpheme occurs continuously in the stem. The same root ktb can combine with the template CVCVC and a different vocalization ui, signifying </context>
</contexts>
<marker>McCarthy, 1981</marker>
<rawString>John J. McCarthy. 1981. A prosodic theory of nonconcatenative morphology. Linguistic Inquiry, 12(3):373-418.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Richard Sproat</author>
</authors>
<title>Morphology and Computation.</title>
<date>1992</date>
<publisher>MIT Press,</publisher>
<location>Cambridge, MA.</location>
<marker>Sproat, 1992</marker>
<rawString>Richard Sproat. 1992. Morphology and Computation. MIT Press, Cambridge, MA.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>