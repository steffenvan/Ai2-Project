<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000487">
<note confidence="0.6129245">
Technical Correspondence On the Logic of Category Definitions
ON THE LOGIC OF CATEGORY DEFINITIONS
</note>
<bodyText confidence="0.997972679245283">
In their paper on category structures, Gazdar et al.
(1988) define a constraint language Lc for categories and
a logic Ac of admissible category structures.&apos; The
intuitive idea is that for a constraint 4) expressed in Lc,
4) is a nontrivial constraint if and only if Ac 4); and it
is a satisfiable constraint if and only if Ac --4). From a
practical point of view it is therefore important to know
whether Ac is decidable and even better that the deci-
sion can be given in a time bounded by a recursive
function on the length of 4). However, the remarks made
in their paper only suffice to show that the modal
fragment of Ac2 contains S4.Grz = K(Op —&gt; p, Op ---&gt;
00p, 0(0(p —&gt; Op) —&gt; p) —&gt; p), which does not show
that this fragment is decidable. In this note, I will
establish both that the modal fragment of Ac and Ac
itself are decidable, and I will prove it in that order. As
a result, I will also axiomatize A. Thus I show first that
the modal reduct of Ac, which I call Am, is decidable.
This paper will be rather hardgoing for anyone not
acquainted with modal logic. We advise the reader to
have Gazdar et al. (1988) at hand while reading this
paper, or better still, to read it once through before-
hand. For the modal logics we refer the reader to Boolos
(1979), Harel (1984), and Segerberg (1971), but in prin-
ciple any introduction to modal logic will provide
enough background to be able to understand the gist of
the arguments.
Without going into too many details of the construc-
tion, I will show that there is an easy way to give a proof
that in fact shows that Am = S4.Grz using the structure
of the models those logics admit. Intuitively, categories
correspond to Kripke models. For let a be a category.
Then a defines a set of categories W, which is obtained
by successively applying type 13 features to a. An
accessibility relation &lt;1 is defined via a &lt;1 p ifffla) = /3
for some type 1 feature f. This accessibility relation is
irreflexive, intransitive, finite, and defines a tree-struc-
ture on W. Most importantly, it is cycle free. Thus, if we
look at the reflexive and transitive closure &lt;1+ of &lt;1, it is
again finite and has no non-trivial cycles. It therefore is
an S4.Grz structure (see, e.g., Boolos 1979). Con-
versely, an S4.Grz structure &lt;W, 1±&gt; which is a tree
can be represented as a category. If we then take a
model &lt;W, val&gt; based on that frame, where
val: X—&gt; 2w maps a finite set of propositional variables
into 2w, we can code this model by adding a type 0
feature fp for each p E X that takes values T or I. Thus
the resulting category a not only codes the successor
function by means of type 1 features, but also the
valuation val. W is in one-to-one correspondence 4) with
the set F of categories generated by a. We then make
the following definitions:
Let /3 be in F:
</bodyText>
<equation confidence="0.966">
i./3 : T iff (1)(13) E val(p) iff 0(p) lp
ii. 13 fp : 1 iff 4)(/3)E val(p) iff O(/3)
</equation>
<bodyText confidence="0.988186444444444">
It is easy to see that for any modal formula P with
variables in X, the corresponding translation T induced
by p 4-0f : T satisfies /3 = 7(P) if cti(p) = P. The logic
of &lt;W,&lt;&gt; therefore coincides with the logic of all
categories that differ from a only in the assignment of
type 0 features. To conclude, the logic of categories as
defined in Gazdar et al. (1988) coincides with the logic
of all finite, reflexive, transitive trees. It is easily seen
that the finite, reflexive, transitive trees generate the
class of finite models for S4.Grz. Thus the logic of
categories is the logic of the finite models of S4.Grz
which, since S4.Grz has the finite model property, is
identical to S4.Grz (end of proof).
A few remarks are in order:
I. I used a purely semantical argument, which in this
case is the most direct way, because it is fairly
easy to see why we get just the models we get,
though there is some footwork to be done.
</bodyText>
<listItem confidence="0.994925222222222">
2. Alternatively I could have built a canonical model
out of a category structure 1, whose worlds are
the categories that admits and whose accessibil-
ity relation is as defined above for categories. The
proof is essentially the same.
3. The idea of encoding frames and valuations into a
single structure has also been explored in Fagin
(1985).
4. In Rautenberg (1983) a simple tableau calculus for
</listItem>
<bodyText confidence="0.940431216216216">
S4.Grz is given which shows that S4.Grz consis-
tency is effectively decidable, and that the deci-
sion procedure is primitive recursive. Further-
more, the size of a tableau is bounded by a
function of the number a(P) of subformulas of P,
or, more precisely, the theoremhood of P can be
decided with a tableau of length 27+6cf(P). Given
the proof, the same holds for Am, since the
translation procedure reduces the size of a for-
mula. So we have the same bound for Ac.
5. In Gazdar et al. (1988) another logic is mentioned
which arises from restricting the number of type 1
features to 1. The resulting logic is equal to
S4.3.Grz = S4.Grz(Op A 0q. —&gt; .0(p A 0q)
0(q A 0 p) V0.(p A q)), the logic of all finite
linear orders, as can be seen in the same way.
Since finitely generated S4.3.Grz models are fi-
nite, this logic is decidable as well.
I will now proceed to the full case. Before I embark on
the proof, let me remark on a few things. First, although
each particular category structure contains only a finite
number of features and values, Lc contains infinitely
many of them. As regards the type 0 features, this
causes no problem, since we treat f : a as a proposition
and we allow ourselves infinitely many of those. How-
ever, type 1 features will create some problems that are
not very serious but have to be dealt with carefully.
Second, as we defined a translation of Lc into modal
logic, we will now define a translation of Lc into
elementary propositional dynamic logic (EPDL) so that
every type 1 feature has a program associated with it
0362-613X/89/010111-113-$03.00 111
Computational Linguistics, Volume 15, Number 2, June 1989
Technical Correspondence On the Logic of Category Definitions
whose interpretation is an accessibility relation between
categories. This translation is harmless and allows us to
forget about type 0 features altogether.
</bodyText>
<equation confidence="0.998661333333333">
(f:i.T a) = p&lt;f:a&gt; where f is of type 0
ii.r(f; : 0) = &lt;yi&gt; c4&gt; where f, is of type 1
E14) = [44&gt;
</equation>
<bodyText confidence="0.976514349206349">
a is a program that by definition contains all other
programs; that is, if two categories are related by y„
they are also related by a. However, although the
intuition is that a is the reflexive and transitive closure
of all the yi&apos;s, this fact is not expressible in EPDL nor in
Lc because it requires a formula of infinite length. But,
as it turns out, this is a harmless deficiency of our
language. The translation of Ac into EPDL will be
called E,.
I will now give a full axiomatization of E. As we saw
earlier, the axioms governing the behaviour of [a] are
exactly the axioms for S4.Grz, since [a] is the old O.
Similar reasoning will reveal that the [y,] behave alike,
and the corresponding logic is the logic otherwise
known as K.A1t1, which stands for &amp;quot;only one alterna-
tive&amp;quot;. The accessibility relation for K.Alt, allows a
world to have at most one successor. Although it has
more models, K.Alt, is the logic of all irreflexive, linear
and finite frames, which shows that it is the logic we are
looking for. If we take all this together with the obser-
vation that a includes yi, we get the following axioms
for &apos;E:
Grza 1-[a]([a](0 —› [a]4&gt;) —&gt; 4)) 4&gt;
A/t1,7 E I-&lt;y,&gt; (4) A tp) &lt;-&gt; (&lt;71&gt;4&gt;.A.&lt;ye&gt;t/4, i E co
Mix E I-&lt;yi&gt; 4)—&gt; &lt;a&gt; 49
Note that E is not finitely axiomatizable and so Ac isn&apos;t
either. Note also that if it weren&apos;t for the axiom(s) called
Mix, life would be very easy for us now. Since the
axioms for the various programs are independent, the
finite model property for each of those programs indi-
vidually would yield the finite model property for the
whole logic by simple induction on the number of
programs. Thus let us call the logic without MixE).
Also, since we have a tableau calculus for S4.Grz and a
tableau calculus for K.Alt, , we have a calculus for Ee
as well, simply by putting all tableau rules together. The
tableau rule for yi would look as follows: from F; &lt;y,&gt;
0 step to F&lt;&gt;; 4&gt;, where F&lt;&gt; := &lt;)&gt; E r or [yi]tii
E I shall spare the reader an exact specification of
the tableau rules and refer him to Rautenberg (1983)
again. Note that the length of the tableaus for K.Alt, is
bounded by the size of 4&gt; so that the actual size of the
tableau is at most 2&amp;quot;`&amp;quot;), where n is the length of 4&gt; and
or(4&gt;) the number of subformulas of 4&gt;. This bound could
be sharpened somewhat but we ignore this point. What
I want to show is how the fact that Ee can be shown to
have all those properties can be made to explain why E
must have those properties, too. What the reader should
understand at this point is that tableaus are a way of
systematically constructing a model for a formula (if it is
consistent) and showing inconsistency by exhausting all
possible choices, of which there are only finitely many.
What I do now is boost up a model construction
procedure for Ee to a model construction procedure for
E. This is done as follows: Suppose we want to con-
struct a E-model for 4&gt;. Since we do not know how to do
this we construct a Ee-model instead. However, this
model might be deficient by not respecting Mix. There-
fore we add a finite set 0# of instances of Mix which will
ensure that Mix is respected for subformulas of 4&gt;. The
E&apos;e model can then safely be turned into an 5 model.
Let me therefore define the modal degree d of a
formula.
</bodyText>
<equation confidence="0.9989648">
d(44 = 0, if (1) is a propositional variable or constant
d(70) = d(0)
d(4) A tp) = max(d(4)),d(0)
d([«]4)) = d(4)) + 1
d([71]0) = d(4)) + 1
</equation>
<bodyText confidence="0.886534333333333">
Furthermore, let sj(4&gt;) be the set of subformulas of 4&gt;.
Then define
= U &lt; y, y, occurs in 4&gt;&gt; Ua
</bodyText>
<equation confidence="0.995087666666667">
‘I =
=
(P# = 1[4&amp;quot;](&lt;yi&gt; x—&gt; &lt;a&gt; x) I x E sflOn
</equation>
<bodyText confidence="0.998069866666667">
Then we say that an tableau for 4&gt; is simply an Ee
tableau for 0;0#. Let us see how di makes everything
right for us. The failure of Ee is to allow models for
&lt;yi&gt; A [a]-10. For suppose we build a simple Zie
tableau for 0 and we encounter a line F; &lt;yi&gt; 0A [a]-10.
In the next step we get F; &lt;)&gt; tidal—Hiland then F°;0.
But if we added 4&gt;#, then F would necessarily contain a
formula yielding &lt;ye&gt; tit ---&gt; &lt;a&gt; 4r, which would close
this branch of the tableau. Thus an Ee tableau for 4&gt;;0#
results in a model &lt;W, 1, val&gt; in which, though a is an
independent program, for every subformula ip of 0, if
s,val &lt;yi&gt; tit, then also s,val &lt;a&gt; Thus it is
easy to see that if we now reinterpret the a relation &lt;la
as the reflexive, transitive closure of a and the yi, we get
an Z-.1&apos; model &lt;W, 1, val&gt; for 4&gt;, which obviously is of
the same size. Thus, if Ee has the finite model property,
E has the finite model property, and if the decision
procedure for &apos;Ee is bounded a priori by a function on
the length of 0, the same holds for Obviously, the
bound is much higher than for Ele because of the 4&gt;#,
but this is the price we have to pay (end of proof).
Given the above proof we can now change the
tableau calculus for E by redefining the rule for yi to the
following: from F; &lt;yi&gt; 4&gt; infer F; r :4&gt; where r° :=
10 I &lt;yi&gt; E F or [ yi] fir E r} and F° := {[a]0 I [a]0
E U {0 I [a]tfr E r}. The proof method I used for
proving decidability for E (Ar) from the decidability of
Ee is explained in full detail in Kracht (1988). The same
method applies to the case when we only allow a single
type 1 feature, since it only requires the base logic—in
</bodyText>
<page confidence="0.904525">
112 Computational Linguistics, Volume 15, Number 2, June 1989
</page>
<bodyText confidence="0.8549455">
Technical Correspondence On the Logic of Category Definitions
this case S4.3.Grz—to have the finite model property.
The resulting logic 5.3 can be (finitely) axiomatized as
follows:
</bodyText>
<equation confidence="0.948615">
Grza [a]([a](45 —&gt; [a]4)) —&gt; 4)) —&gt; 4)
.3a E.3 (&lt;a&gt; 0.A.&lt;a&gt;tp) —0
&lt;a&gt;(4)A&lt;a&gt;0)\/&lt;a&gt;(t/JA&lt;a&gt; cp&gt;
V &lt;a&gt; (0) A cu)
</equation>
<bodyText confidence="0.944272">
A111,1, E.3 &lt;71&gt; OA &lt;71&gt; tfr &lt;--o &lt;71&gt; (4) A i/r)
Mix E.3 &lt;71&gt; 4)—› &lt;a&gt; 4)
The model construction requires some care since we do
not have an unlimited resort of extra features, but it can
be done in the same spirit. This shows decidability for
E.3 and hence for the corresponding logic mentioned in
the paper. An alternative formulation of E.3 could be
given with the help of propositional dynamic logic using
the star operator *. We would then simply have an
axiom &lt;yr&gt; 4) &lt;--o &lt;a&gt; 4) that says nothing else, but
that a is the reflexive and transitive closure of yl. This
trick would also work if we restrict E to any finite
number of features. But the star does not gain us much
for E itself since we still could not express the fact that
a is the reflexive and transitive closure of the yi&apos;s
because we have infinitely many of them.
</bodyText>
<figure confidence="0.73432225">
Marcus Kracht II
Mathematisches Institut
FU Berlin
1000 Berlin 33, Germany
</figure>
<sectionHeader confidence="0.986856" genericHeader="acknowledgments">
ACKNOWLEDGMENTS
</sectionHeader>
<bodyText confidence="0.999643">
This paper was written while I was at the Centre for Cognitive Science
in Edinburgh. I wish to thank Jaap van der Does for encouraging me
to write this proof down and for proofreading it. I also wish to thank
G. Gazdar for remarks on an earlier version of the paper and an
anonymous referee for further suggestions.
</bodyText>
<sectionHeader confidence="0.994416" genericHeader="references">
REFERENCES
</sectionHeader>
<reference confidence="0.723228275862069">
Boolos, G. 1979 The Unprovability of Consistency. Cambridge Uni-
versity Press, Cambridge, England.
Fagin, R. and Vardi, M. 1985 An Internal Semantics for Modal
Logics: Preliminary Report, CSLI-Report No. 85-25.
Gazdar, G.; Pullum, G.; Carpenter, R.; Klein, E.H.; Hukari, T.E.;
and Levine, R.D. 1988 Category Structures, Computational Lin-
guistics 14.1: 1-19.
Harel, D. 1984 Dynamic Logic. in Gabbay, D. and Guenthner, F.
(eds.) Handbook of Philosophical Logic. Reidel, Dordecht, Hol-
land.
Kracht, M. 1988 Splittings and the Finite Model Property (forth-
coming).
Rautenberg, W. 1983 Modal Tableau Calculi and Interpolation, in
Journal of Philosophical Logic 12: 403-423.
Segerberg, K. 1971 An Essay in Classical Modal Logic. Uppsala.
NOTES
I. Unfortunately, they do not distinguish between the language Lc
and the logic, which defines a subset of that language, namely the
set of its theorems. We make this distinction here by calling the
logic as well as the set of theorems it defines A.
2. We define a logic as a set of rules, which are pairs A/0, where A
is the set of premises of that rule and q5 its consequence. Modus
Ponens thus takes the form 0,0 --0 iphp. Rules are closed under
substitution. Axioms are rules because we can take A = 0. The
modal fragment of Ac. is then simply the subpart of rules that only
involve modal formulas, i.e. no type 1 features.
3. Remember that type 1 features take propositions as values,
whereas type 0 features only take atoms.
Computational Linguistics, Volume 15, Number 2, June 1989 113
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.355356">
<title confidence="0.9019555">Technical Correspondence On the Logic of Category Definitions ON THE LOGIC OF CATEGORY DEFINITIONS</title>
<abstract confidence="0.972950041666667">In their paper on category structures, Gazdar et al. define a constraint language for categories and logic of admissible category structures.&apos; The idea is that for a constraint in a if and only if 4); it a satisfiable constraint if and only if a practical point of view it is therefore important to know is decidable and even better that the decision can be given in a time bounded by a recursive on the length of the remarks made in their paper only suffice to show that the modal of contains S4.Grz = K(Op —&gt; ---&gt; 0(0(p —&gt; Op) —&gt; —&gt; p), does not show that this fragment is decidable. In this note, I will both that the modal fragment of and itself are decidable, and I will prove it in that order. As a result, I will also axiomatize A. Thus I show first that modal reduct of which I call is decidable. This paper will be rather hardgoing for anyone not acquainted with modal logic. We advise the reader to have Gazdar et al. (1988) at hand while reading this paper, or better still, to read it once through beforehand. For the modal logics we refer the reader to Boolos (1979), Harel (1984), and Segerberg (1971), but in prin-</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>G Boolos</author>
</authors>
<title>The Unprovability of Consistency.</title>
<date>1979</date>
<publisher>Cambridge University Press,</publisher>
<location>Cambridge, England.</location>
<contexts>
<context position="1366" citStr="Boolos (1979)" startWordPosition="253" endWordPosition="254">Op ---&gt; 00p, 0(0(p —&gt; Op) —&gt; p) —&gt; p), which does not show that this fragment is decidable. In this note, I will establish both that the modal fragment of Ac and Ac itself are decidable, and I will prove it in that order. As a result, I will also axiomatize A. Thus I show first that the modal reduct of Ac, which I call Am, is decidable. This paper will be rather hardgoing for anyone not acquainted with modal logic. We advise the reader to have Gazdar et al. (1988) at hand while reading this paper, or better still, to read it once through beforehand. For the modal logics we refer the reader to Boolos (1979), Harel (1984), and Segerberg (1971), but in principle any introduction to modal logic will provide enough background to be able to understand the gist of the arguments. Without going into too many details of the construction, I will show that there is an easy way to give a proof that in fact shows that Am = S4.Grz using the structure of the models those logics admit. Intuitively, categories correspond to Kripke models. For let a be a category. Then a defines a set of categories W, which is obtained by successively applying type 13 features to a. An accessibility relation &lt;1 is defined via a &lt;</context>
</contexts>
<marker>Boolos, 1979</marker>
<rawString>Boolos, G. 1979 The Unprovability of Consistency. Cambridge University Press, Cambridge, England.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Fagin</author>
<author>M Vardi</author>
</authors>
<title>An Internal Semantics for Modal Logics:</title>
<date>1985</date>
<tech>Preliminary Report, CSLI-Report No. 85-25.</tech>
<marker>Fagin, Vardi, 1985</marker>
<rawString>Fagin, R. and Vardi, M. 1985 An Internal Semantics for Modal Logics: Preliminary Report, CSLI-Report No. 85-25.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Gazdar</author>
<author>G Pullum</author>
<author>R Carpenter</author>
<author>E H Klein</author>
<author>T E Hukari</author>
<author>R D Levine</author>
</authors>
<date>1988</date>
<journal>Category Structures, Computational Linguistics</journal>
<volume>14</volume>
<pages>1--19</pages>
<contexts>
<context position="1221" citStr="Gazdar et al. (1988)" startWordPosition="224" endWordPosition="227">function on the length of 4). However, the remarks made in their paper only suffice to show that the modal fragment of Ac2 contains S4.Grz = K(Op —&gt; p, Op ---&gt; 00p, 0(0(p —&gt; Op) —&gt; p) —&gt; p), which does not show that this fragment is decidable. In this note, I will establish both that the modal fragment of Ac and Ac itself are decidable, and I will prove it in that order. As a result, I will also axiomatize A. Thus I show first that the modal reduct of Ac, which I call Am, is decidable. This paper will be rather hardgoing for anyone not acquainted with modal logic. We advise the reader to have Gazdar et al. (1988) at hand while reading this paper, or better still, to read it once through beforehand. For the modal logics we refer the reader to Boolos (1979), Harel (1984), and Segerberg (1971), but in principle any introduction to modal logic will provide enough background to be able to understand the gist of the arguments. Without going into too many details of the construction, I will show that there is an easy way to give a proof that in fact shows that Am = S4.Grz using the structure of the models those logics admit. Intuitively, categories correspond to Kripke models. For let a be a category. Then a</context>
<context position="3347" citStr="Gazdar et al. (1988)" startWordPosition="624" endWordPosition="627">tures, but also the valuation val. W is in one-to-one correspondence 4) with the set F of categories generated by a. We then make the following definitions: Let /3 be in F: i./3 : T iff (1)(13) E val(p) iff 0(p) lp ii. 13 fp : 1 iff 4)(/3)E val(p) iff O(/3) It is easy to see that for any modal formula P with variables in X, the corresponding translation T induced by p 4-0f : T satisfies /3 = 7(P) if cti(p) = P. The logic of &lt;W,&lt;&gt; therefore coincides with the logic of all categories that differ from a only in the assignment of type 0 features. To conclude, the logic of categories as defined in Gazdar et al. (1988) coincides with the logic of all finite, reflexive, transitive trees. It is easily seen that the finite, reflexive, transitive trees generate the class of finite models for S4.Grz. Thus the logic of categories is the logic of the finite models of S4.Grz which, since S4.Grz has the finite model property, is identical to S4.Grz (end of proof). A few remarks are in order: I. I used a purely semantical argument, which in this case is the most direct way, because it is fairly easy to see why we get just the models we get, though there is some footwork to be done. 2. Alternatively I could have built</context>
<context position="4798" citStr="Gazdar et al. (1988)" startWordPosition="883" endWordPosition="886">d valuations into a single structure has also been explored in Fagin (1985). 4. In Rautenberg (1983) a simple tableau calculus for S4.Grz is given which shows that S4.Grz consistency is effectively decidable, and that the decision procedure is primitive recursive. Furthermore, the size of a tableau is bounded by a function of the number a(P) of subformulas of P, or, more precisely, the theoremhood of P can be decided with a tableau of length 27+6cf(P). Given the proof, the same holds for Am, since the translation procedure reduces the size of a formula. So we have the same bound for Ac. 5. In Gazdar et al. (1988) another logic is mentioned which arises from restricting the number of type 1 features to 1. The resulting logic is equal to S4.3.Grz = S4.Grz(Op A 0q. —&gt; .0(p A 0q) 0(q A 0 p) V0.(p A q)), the logic of all finite linear orders, as can be seen in the same way. Since finitely generated S4.3.Grz models are finite, this logic is decidable as well. I will now proceed to the full case. Before I embark on the proof, let me remark on a few things. First, although each particular category structure contains only a finite number of features and values, Lc contains infinitely many of them. As regards t</context>
</contexts>
<marker>Gazdar, Pullum, Carpenter, Klein, Hukari, Levine, 1988</marker>
<rawString>Gazdar, G.; Pullum, G.; Carpenter, R.; Klein, E.H.; Hukari, T.E.; and Levine, R.D. 1988 Category Structures, Computational Linguistics 14.1: 1-19.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Harel</author>
</authors>
<title>Dynamic Logic.</title>
<date>1984</date>
<booktitle>Handbook of Philosophical Logic.</booktitle>
<editor>in Gabbay, D. and Guenthner, F. (eds.)</editor>
<location>Reidel, Dordecht, Holland.</location>
<contexts>
<context position="1380" citStr="Harel (1984)" startWordPosition="255" endWordPosition="256">0(p —&gt; Op) —&gt; p) —&gt; p), which does not show that this fragment is decidable. In this note, I will establish both that the modal fragment of Ac and Ac itself are decidable, and I will prove it in that order. As a result, I will also axiomatize A. Thus I show first that the modal reduct of Ac, which I call Am, is decidable. This paper will be rather hardgoing for anyone not acquainted with modal logic. We advise the reader to have Gazdar et al. (1988) at hand while reading this paper, or better still, to read it once through beforehand. For the modal logics we refer the reader to Boolos (1979), Harel (1984), and Segerberg (1971), but in principle any introduction to modal logic will provide enough background to be able to understand the gist of the arguments. Without going into too many details of the construction, I will show that there is an easy way to give a proof that in fact shows that Am = S4.Grz using the structure of the models those logics admit. Intuitively, categories correspond to Kripke models. For let a be a category. Then a defines a set of categories W, which is obtained by successively applying type 13 features to a. An accessibility relation &lt;1 is defined via a &lt;1 p ifffla) = </context>
</contexts>
<marker>Harel, 1984</marker>
<rawString>Harel, D. 1984 Dynamic Logic. in Gabbay, D. and Guenthner, F. (eds.) Handbook of Philosophical Logic. Reidel, Dordecht, Holland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Kracht</author>
</authors>
<title>Splittings and the Finite Model Property (forthcoming).</title>
<date>1988</date>
<contexts>
<context position="11334" citStr="Kracht (1988)" startWordPosition="2133" endWordPosition="2134">el property, and if the decision procedure for &apos;Ee is bounded a priori by a function on the length of 0, the same holds for Obviously, the bound is much higher than for Ele because of the 4&gt;#, but this is the price we have to pay (end of proof). Given the above proof we can now change the tableau calculus for E by redefining the rule for yi to the following: from F; &lt;yi&gt; 4&gt; infer F; r :4&gt; where r° := 10 I &lt;yi&gt; E F or [ yi] fir E r} and F° := {[a]0 I [a]0 E U {0 I [a]tfr E r}. The proof method I used for proving decidability for E (Ar) from the decidability of Ee is explained in full detail in Kracht (1988). The same method applies to the case when we only allow a single type 1 feature, since it only requires the base logic—in 112 Computational Linguistics, Volume 15, Number 2, June 1989 Technical Correspondence On the Logic of Category Definitions this case S4.3.Grz—to have the finite model property. The resulting logic 5.3 can be (finitely) axiomatized as follows: Grza [a]([a](45 —&gt; [a]4)) —&gt; 4)) —&gt; 4) .3a E.3 (&lt;a&gt; 0.A.&lt;a&gt;tp) —0 &lt;a&gt;(4)A&lt;a&gt;0)\/&lt;a&gt;(t/JA&lt;a&gt; cp&gt; V &lt;a&gt; (0) A cu) A111,1, E.3 &lt;71&gt; OA &lt;71&gt; tfr &lt;--o &lt;71&gt; (4) A i/r) Mix E.3 &lt;71&gt; 4)—› &lt;a&gt; 4) The model construction requires some care sinc</context>
</contexts>
<marker>Kracht, 1988</marker>
<rawString>Kracht, M. 1988 Splittings and the Finite Model Property (forthcoming).</rawString>
</citation>
<citation valid="true">
<authors>
<author>W Rautenberg</author>
</authors>
<title>Modal Tableau Calculi and Interpolation,</title>
<date>1983</date>
<journal>in Journal of Philosophical Logic</journal>
<volume>12</volume>
<pages>403--423</pages>
<contexts>
<context position="4278" citStr="Rautenberg (1983)" startWordPosition="790" endWordPosition="791">cal to S4.Grz (end of proof). A few remarks are in order: I. I used a purely semantical argument, which in this case is the most direct way, because it is fairly easy to see why we get just the models we get, though there is some footwork to be done. 2. Alternatively I could have built a canonical model out of a category structure 1, whose worlds are the categories that admits and whose accessibility relation is as defined above for categories. The proof is essentially the same. 3. The idea of encoding frames and valuations into a single structure has also been explored in Fagin (1985). 4. In Rautenberg (1983) a simple tableau calculus for S4.Grz is given which shows that S4.Grz consistency is effectively decidable, and that the decision procedure is primitive recursive. Furthermore, the size of a tableau is bounded by a function of the number a(P) of subformulas of P, or, more precisely, the theoremhood of P can be decided with a tableau of length 27+6cf(P). Given the proof, the same holds for Am, since the translation procedure reduces the size of a formula. So we have the same bound for Ac. 5. In Gazdar et al. (1988) another logic is mentioned which arises from restricting the number of type 1 f</context>
<context position="8319" citStr="Rautenberg (1983)" startWordPosition="1525" endWordPosition="1526">ams are independent, the finite model property for each of those programs individually would yield the finite model property for the whole logic by simple induction on the number of programs. Thus let us call the logic without MixE). Also, since we have a tableau calculus for S4.Grz and a tableau calculus for K.Alt, , we have a calculus for Ee as well, simply by putting all tableau rules together. The tableau rule for yi would look as follows: from F; &lt;y,&gt; 0 step to F&lt;&gt;; 4&gt;, where F&lt;&gt; := &lt;)&gt; E r or [yi]tii E I shall spare the reader an exact specification of the tableau rules and refer him to Rautenberg (1983) again. Note that the length of the tableaus for K.Alt, is bounded by the size of 4&gt; so that the actual size of the tableau is at most 2&amp;quot;`&amp;quot;), where n is the length of 4&gt; and or(4&gt;) the number of subformulas of 4&gt;. This bound could be sharpened somewhat but we ignore this point. What I want to show is how the fact that Ee can be shown to have all those properties can be made to explain why E must have those properties, too. What the reader should understand at this point is that tableaus are a way of systematically constructing a model for a formula (if it is consistent) and showing inconsisten</context>
</contexts>
<marker>Rautenberg, 1983</marker>
<rawString>Rautenberg, W. 1983 Modal Tableau Calculi and Interpolation, in Journal of Philosophical Logic 12: 403-423.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Segerberg</author>
</authors>
<title>An Essay in Classical Modal Logic.</title>
<date>1971</date>
<publisher>NOTES</publisher>
<location>Uppsala.</location>
<contexts>
<context position="1402" citStr="Segerberg (1971)" startWordPosition="258" endWordPosition="259">&gt; p), which does not show that this fragment is decidable. In this note, I will establish both that the modal fragment of Ac and Ac itself are decidable, and I will prove it in that order. As a result, I will also axiomatize A. Thus I show first that the modal reduct of Ac, which I call Am, is decidable. This paper will be rather hardgoing for anyone not acquainted with modal logic. We advise the reader to have Gazdar et al. (1988) at hand while reading this paper, or better still, to read it once through beforehand. For the modal logics we refer the reader to Boolos (1979), Harel (1984), and Segerberg (1971), but in principle any introduction to modal logic will provide enough background to be able to understand the gist of the arguments. Without going into too many details of the construction, I will show that there is an easy way to give a proof that in fact shows that Am = S4.Grz using the structure of the models those logics admit. Intuitively, categories correspond to Kripke models. For let a be a category. Then a defines a set of categories W, which is obtained by successively applying type 13 features to a. An accessibility relation &lt;1 is defined via a &lt;1 p ifffla) = /3 for some type 1 fea</context>
</contexts>
<marker>Segerberg, 1971</marker>
<rawString>Segerberg, K. 1971 An Essay in Classical Modal Logic. Uppsala. NOTES</rawString>
</citation>
<citation valid="false">
<authors>
<author>I Unfortunately</author>
</authors>
<title>they do not distinguish between the language Lc and the logic, which defines a subset of that language, namely the set of its theorems. We make this distinction here by calling the logic as well as the set of theorems it defines A.</title>
<marker>Unfortunately, </marker>
<rawString>I. Unfortunately, they do not distinguish between the language Lc and the logic, which defines a subset of that language, namely the set of its theorems. We make this distinction here by calling the logic as well as the set of theorems it defines A.</rawString>
</citation>
<citation valid="false">
<title>We define a logic as a set of rules, which are pairs A/0, where A is the set of premises of that rule and q5 its consequence. Modus Ponens thus takes the form 0,0 --0 iphp. Rules are closed under substitution. Axioms are rules because we can take A = 0. The modal fragment of Ac. is then simply the subpart of rules that only involve modal formulas, i.e. no type 1 features.</title>
<marker></marker>
<rawString>2. We define a logic as a set of rules, which are pairs A/0, where A is the set of premises of that rule and q5 its consequence. Modus Ponens thus takes the form 0,0 --0 iphp. Rules are closed under substitution. Axioms are rules because we can take A = 0. The modal fragment of Ac. is then simply the subpart of rules that only involve modal formulas, i.e. no type 1 features.</rawString>
</citation>
<citation valid="false">
<title>Remember that type 1 features take propositions as values, whereas type 0 features only take atoms.</title>
<marker></marker>
<rawString>3. Remember that type 1 features take propositions as values, whereas type 0 features only take atoms.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Computational Linguistics</author>
</authors>
<date>1989</date>
<volume>15</volume>
<pages>113</pages>
<marker>Linguistics, 1989</marker>
<rawString>Computational Linguistics, Volume 15, Number 2, June 1989 113</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>