<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000001">
<title confidence="0.99786">
Extracting Formal Specifications from Natural
Language Regulatory Documents
</title>
<author confidence="0.999508">
Nikhil Dinesh, Aravind Joshi, and Insup Lee
</author>
<affiliation confidence="0.999452">
Department of Computer Science, Univeristy of Pennsylvania,
</affiliation>
<address confidence="0.807356">
Philadelphia, PA - 19104 USA
</address>
<email confidence="0.859571">
nikhild,joshi,lee@cis. upenn. edu
</email>
<author confidence="0.993993">
Bonnie Webber
</author>
<affiliation confidence="0.999518">
University of Edinburgh, Edinburgh, EH8 9LW Scotland
</affiliation>
<email confidence="0.341728">
bonnie@inf. ed. ac. uk
</email>
<sectionHeader confidence="0.802972" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.99649">
Formal verification techniques provide a way to determine whether regulatory doc-
uments are consistent and whether implementations conform to them. To apply
these techniques a formal description of the regulation needs to be extracted. We
present a framework, under which NLP techniques can be brought to bear, to aid
a requirements engineer in extracting the formal description.
</bodyText>
<sectionHeader confidence="0.999117" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.997031363636364">
Regulatory documents, which include the vast bodies of legislation, operating
procedures and organizational policy, are meant to be accessible to the people
affected by them. Hence, they have to be in natural language (NL). On
the other hand, regulations are expected to be consistent, and the governed
entities/events are expected to conform to the regulation.
For example, the Food and Drug Administration’s Code of Federal Reg-
ulations (FDA CFR) governs the bloodbanks in America.&apos; The bloodbanks
perform safety-critical functions like the testing of blood for communicable
disease agents (like HIV). It is highly desirable to determine whether (a) the
CFR is consistent, and (b) a bloodbank’s implementation of such a function
conforms to the CFR.
</bodyText>
<footnote confidence="0.99182">
* This research was supported in part by NSF CCF-0429948 and ARO 911NF-05-1-0158
1 http://www.gpoaccess.gov/cfr/index.html
</footnote>
<bodyText confidence="0.999312433333333">
The problem of creating descriptions of regulation which can be checked
for consistency has been explored by several authors [1,8], but the challenge of
checking an implementation for conformance has not been addressed, and this
is the main goal of our work. The conformance guarantees can be obtained
if formal descriptions of regulation and implementations are available, and if
verification techniques [4] can be applied to these descriptions. But extracting
a formal description of regulation is expensive, as regulatory bases like the
CFR are large (about a million words) and complex.
Formal descriptions of regulation are usually extracted by an individual
who has a background in logic, e.g., [1,8]. We will call this individual the
requirements engineer. In this paper, we describe a framework to assist a
requirements engineer in extracting a formal description of regulation for use
in conformance checking.
An overview of the framework, the theoretical background and the various
constraints that apply is given in Section 2. This lets us determine the nature
of the description that needs to be extracted from the regulation. We then
turn to the question of how these descriptions might be composed. In Section
3, we attempt to map the denotations of sentences assigned by Kratzer [12]
to a form that can be used for the task at hand. Some difficulties arise in
this mapping, mainly because notions of obligation (that which is required)
and permission (that which is allowed) are not captured in the denotations.
We argue that an account of these notions is essential to the task at hand.
Section 4 describes a semantic representation, and composition procedure to
assist the requirements engineer in extracting the required description. By
treating obligations and permissions as different dimensions of the description
computed, the difficulties encountered in Section 3 are addressed.
The approach is motivated by our case study of the FDA CFR, and we
use (1) and (2) as examples through the course of this paper.2 (1) conveys
an obligation to perform a test for HIV and Hepatitis B, and (2) conveys a
permission not to test source plasma (a blood component) for Hepatitis B.
</bodyText>
<listItem confidence="0.981249">
(1) Except as specified in (2), you must test each donation of human blood or blood
component, for evidence of infection due to the Human immunodeficiency virus,
and the Hepatitis B virus.
(2) You are not required to test donations of Source Plasma for evidence of infection
due to the Hepatitis B virus.
</listItem>
<sectionHeader confidence="0.990329" genericHeader="method">
2 A Framework
</sectionHeader>
<bodyText confidence="0.981349888888889">
To determine whether an implementation (bloodbank) conforms to the regu-
lation (CFR), we extract specifications in the Computation Tree Logic (CTL)
from the CFR. Then, given a description of a bloodbank’s procedure (as a
finite transition system, or model) there is an efficient search procedure to
2 (1) and (2) are modified versions of sentences that appear in the FDA CFR 610.40. The
actual sentences are very long, and the modifications are made in the interests of space.
determine if the model conforms to the CTL specification [3]. This is known
as temporal model checking [2,13]. The problem of conformance checking is
thus split into three steps:
</bodyText>
<listItem confidence="0.98669175">
(1) Extract CTL specifications from the regulation - This is done by a
requirements engineer, and our goal is to assist her. We use CTL as the
specification language, because it allows for efficient model checking [3].
(2) Obtain a model of an implementation - We assume the availability of
models. There are tools that aid in extracting models from software [5], and
in creating models if they cannot be extracted directly [11].
(3) Apply model checking to determine if the model conforms to the CTL
specification.
</listItem>
<bodyText confidence="0.523228">
Formally, a model can be defined as follows:
</bodyText>
<figure confidence="0.837312833333333">
Definition 2.1 A model M is the five-tuple (S, I, S, 7r,11), where:
(a) S is a set of states, I C S is a non-empty set of initial states,
(b) S C S x S is a total transition relation (that is, ds E S : [Elt E S : (s, t) E S]),
(c) 7r is a set of propositions (with power set 2&apos;), and
(d) 11 : S —&gt; 2&apos; is a function from states to sets of propositions. 11(s) for s E S can be
thought of as the propositions true at s.
</figure>
<figureCaption confidence="0.455035">
Figure 1(a) and 1(b) show models of two different bloodbanks. The left-
</figureCaption>
<bodyText confidence="0.978236571428572">
most state is the initial state. Each state is labeled with H(s). The propo-
sitions have the following interpretation: d&apos; is true (d&apos; E H(s)) iff a donation
of blood or blood component is being processed, sp&apos; is true iff a donation of
source plasma is being processed, thin&apos; is true iff a test for HIV has been per-
formed, and thepb&apos; is true iff a test for Hepatitis B has been performed. The
use of the propositions deo (denoting deontic accessibility) and app1 (denoting
the application of a permission) is explained in later sections.
</bodyText>
<figure confidence="0.4455035">
(a) A model of a bloodbank (b) A model of a bloodbank
which tests all donations which does not test dona-
tions of source plasma for
Hepatitis B
</figure>
<figureCaption confidence="0.8473">
Fig. 1. Two models of bloodbanks
</figureCaption>
<construct confidence="0.9396315">
Definition 2.2 Given a finite set of propositions 7r, CTL formulas are defined induc-
tively as follows:
</construct>
<figure confidence="0.535215">
(a) p E 7r is a formula,
(b) Boolean combinations and negations of formulas are formulas,
</figure>
<figureCaption confidence="0.5399815">
(c) if 0, and o are formulas, then AG(0) (on all paths, globally 0), AX(0) (on all
paths, at the next state 0), and 0AUo) (on all paths, 0 until o) are formulas.
</figureCaption>
<bodyText confidence="0.995880875">
deo, d&apos;,
sp&apos;,
thiv&apos;,
thepb&apos;
deo, d&apos;,
thiv&apos;,
thepb&apos;
deo, d&apos;,
sp&apos;,
thiv&apos;,
apps
deo, d&apos;,
thiv&apos;,
thepb&apos;
The only temporal operator in CTL that we use is AG (for reasons that
we describe below), and hence rather than define the interpretation formally,
we will give some examples. Let M1 be the model in Figure 1(a), and M2 be
the model in Figure 1(b). The CTL specification AG(deo —&gt; (d&apos; —&gt; thiv&apos;)) holds
of both models, since on all paths (from the initial state, the leftmost one in
Figures 1(a), and 1(b)), globally, in all deontically accessible states deo, if a
donation of blood or blood component is being processed d&apos;, it is tested for HIV
thiv&apos;. Hence, we write M1 h AG(deo —&gt; (d&apos; —&gt; thiv&apos;)), and M2 h AG(deo —&gt; (d&apos; —&gt;
thiv&apos;)). Also, M1 h AG(deo —&gt; (sp&apos; —&gt; thepb&apos;)). But, M2 h� AG(deo —&gt; (sp&apos; —&gt; thepb&apos;))
(since there is a state s with sp&apos; E H(s), and thepb&apos; E� H(s)).
</bodyText>
<subsubsectionHeader confidence="0.511063">
2.1 Approaches to extracting specifications
</subsubsectionHeader>
<bodyText confidence="0.999933296296296">
The central problem we face is that CTL and other temporal logics that lend
themselves to model checking are not expressive enough for a compositional
semantic procedure to be defined for natural language. One reason is that
CTL, like propositional logic, cannot express relations between entities.
There are several routes one might take to address this problem, i.e., design
more expressive logics that allow for tractable model checking, focus on a
subset of NL from which an automatic translation is guaranteed, or make
the procedure machine-assisted. While the design of more expressive logics
makes the composition of specifications easier, using them for model checking
needs the creation of more expressive models (which requires more effort).
As a result, there is a trade-off between amount of effort spent in obtaining
models, and that in obtaining the specifications. Our decision to work with
less expressive models is motivated by the extensive tool support available
for creating and extracting such models [5,11]. Further, subsets of NL for
which automatic translation is guaranteed, such as the one derived by Holt
and Klein [10], assume (among other things) that references are resolved and
hence cannot be directly applied to regulatory documents. We are thus left
with the choice of making the procedure machine-assisted.
There have been two kinds of machine-assisted approaches to extracting
temporal logic specifications: (a) composing the semantics in a general seman-
tic framework which is then mapped to temporal logic [7], and (b) attempting
to compose the semantics in the temporal logic directly [6]. In the latter ap-
proach, a human specifies denotations for a portion of the sentence, and the
rest of the composition happens automatically. We attempt to compose the
semantics in a temporal logic directly like [6], as it lends itself to defining
semantic representations with which a requirements engineer can interact in
well-defined ways.
</bodyText>
<subsubsectionHeader confidence="0.688148">
2.2 Constraints on the CTL specifications
</subsubsectionHeader>
<bodyText confidence="0.999792">
We apply two constraints to the CTL specifications:
(i) The specifications extracted should hold of all and only the valid mod-
els. There may be several implementations that aim to conform to a single
base of regulation. Given (1) and (2), the models in Figures 1(a) and 1(b) are
both valid. This is an important difference from the NL sentences considered
in previous approaches, which were elicited from appropriate users by pre-
senting them with a single model. For example, Holt and Klein [10] obtained
specifications by asking users to describe a particular timing diagram.
(ii) To account for the variation between models, all temporal information
about the governed entities/events is modelled through propositions. The only
use of the temporal operators in CTL is to obtain a quantification over paths
and states. A mapping will need to be performed so that the propositions
used in the specifications can be evaluated at a states in different models, and
the critical assumption is that this mapping will be very easy to specify.
</bodyText>
<sectionHeader confidence="0.981302" genericHeader="method">
3 From Sets of Worlds to Sets of Models
</sectionHeader>
<bodyText confidence="0.9996594">
Several approaches in formal semantics take sentences to denote sets of worlds.
For normative statements, we assume (following Kratzer [12]) that worlds are
connected by an accessibility relation. Consider (1) in Section 1 which among
other things requires a test for Hepatitis B if no exceptions apply. A denotation
of this requirement is given in (3), and is the set of worlds wo, such that for
every deontically accessible world w, for every entity x such that x is a donation
in that world d&apos;(x,w), if no exception holds of that donation ¬e&apos;(x,w), a test
for Hepatitis B is carried out for that donation thepb&apos;(x, w). We will assume
that negation has the highest precedence. Therefore ¬a  b  (¬a)  b, and
brackets are used to resolve other ambiguities.
</bodyText>
<listItem confidence="0.961883">
(3) Aw0.w : (w  deo(wo)  (x : (d&apos;(x, w)  (¬e&apos;(x, w)  thepb&apos;(x, w)))))
</listItem>
<bodyText confidence="0.999820714285714">
A difference between worlds in Kratzer’s denotations and states in a model
is that: in a state there is no notion of entities and relations between them.
All that is available at a state s is the set of propositions which are true at
that state H(s). To map (3) to a form that is useful for checking conformance,
we need two assumptions.
First, we assume that regulation denotes the set of models that conform to
it. Intuitively speaking, wo in (3) can be thought of as a model in its entirety,
and w E deo(wo) correspond to special states in the model. A universal quan-
tification over accessible worlds can be replaced with the CTL AG operator.
We then obtain the denotation in (4), read as : on every path in M, if a state is
deontically accessible, for each donation x at that state, if no exception holds,
a test is carried out. In a model, only special states (like when the bloodbank
has finished processing all the donations it has received) need to conform to
the regulation, and deo can be thought of as marking those states.
</bodyText>
<listItem confidence="0.830842">
(4) AM. M h AG(deo  (x : (d&apos;(x)  (¬e&apos;(x)  thepb&apos;(x)))))
(4) is still not in CTL because of the universal quantification over enti-
ties x at a state. The universal quantifier can be eliminated by assuming a
</listItem>
<bodyText confidence="0.999171857142857">
serial processing model. This has the effect that at the deontically accessible
states, exactly one donation is under consideration (e.g. the models in Fig-
ures 1(a) and 1(b)). In the sections of the CFR that we examined, a universal
quantification over entities is absolutely essential when these entities corre-
spond to inputs of an implemenation. This assumption lets us tie the inputs
to states, and use the quantification over states to achieve the quantification
over entities. Thus (4) can be reduced to (5).
</bodyText>
<listItem confidence="0.791067">
(5) AM. M h AG(deo  (d  (¬e  thepb)))
</listItem>
<bodyText confidence="0.999894">
A problem that is encountered in taking this approach is that there is no
distinction between obligations, and permissions (both of which stem from the
Hohfeldian legal conceptions of right, duty, privilege, and no right [9]). While
this did not cause a problem for the obligation in (1), if one were to follow the
same procedure for the permission in (2), we would get the denotation in (6).
</bodyText>
<listItem confidence="0.775486">
(6) AM. M h ¬(AG(deo  (sp  thepb)))
</listItem>
<bodyText confidence="0.999254733333333">
A model satisfies (6) only if there is some path in which there is a state that
is deontically accessible, and if a donation of source plasma is being processed
it is not tested. This is too strong a requirement, because an organization may
choose not to do what it is permitted to do. The model in Figure 1(a) is a
valid model, which would be declared invalid if (6) were required of it.
Another problem is that it is not clear how one would use (6) in interpreting
the exemption e&apos; in (5). A reasonable candidate is e  deo  (sp  ¬thepb).
But this is not the exemption because it is true in every deontically accessible
state in which a donation of source plasma is not being processed. Consider a
state s at which sp = false (sp  II(s)). At s, e  (deo  (false  ¬thepb)) 
(deo  true)  true. The specification in (5), at s is: AG(deo  (¬e  ¬thepb)) 
AG(deo  (¬true  ¬thepb))  AG(deo  true)  AG(true)  true . Therefore, a
model that doesn’t test any donation for Hepatitis B would conform to (5).
We now turn to the task of addressing these problems by revising how the
specifications are composed.
</bodyText>
<sectionHeader confidence="0.987601" genericHeader="method">
4 Extracting the specifications
</sectionHeader>
<bodyText confidence="0.999842">
To aid the requirements engineer in extracting the specifications, the idea
is to present her with intermediate semantic representations of the sentence
with which she interacts. The intermediate representations that we use fall
into the category of abstract syntax trees (ASTs). ASTs are generally used as
intermediate representations in compiling code in a high-level programming
language to machine dependant code. The internal nodes in ASTs are oper-
ators (predicates/meta-predicates), the subtrees they dominate are operands
(arguments), and leaf nodes correspond to variables or constants (the require-
ments engineer specifies the denotation of the leaves). An AST encodes the
resolution of scope ambiguities, i.e., if p1 dominates p2 in the AST, then p1
outscopes p2.
Section 4.1 describes some phenomena in natural language that can be
used in the construction of the ASTs, and how these ASTs can be interpreted.
In Section 4.2, we describe how the ASTs and their interpretation for (1) and
(2) (in Figures 3 and 4) address the problems described in Section 3. 3
</bodyText>
<subsectionHeader confidence="0.94246">
4.1 Abstract Syntax Trees (ASTs) and their interpretation
</subsectionHeader>
<bodyText confidence="0.905452090909091">
To capture the distinction between obligations and permissions, the denotation
of each node N in an AST is given by the 3-tuple: [[N]] = (PN)ON , where ON
is a set of propositional logic formulas which correspond to the obligations
that have been satisified, and PN is a set of propositional logic formulas that
correspond to the permissions that have been taken, and ON is a propositional
logic formula which can be thought of as indicating whether N is true at a
state. The set of obligations O obtained from the policy base is the union
of the obligations obtained at the root of the AST for each sentence. The
denotation of the policy base is then given by: AM. M �= ac 0deo --*^ 0l . We
OEO )
now identify various linguistic constructions that can be used to obtain ASTs.
</bodyText>
<figureCaption confidence="0.999955">
Fig. 2. Semantics of the Copy meta-predicate
Fig. 3. AST and its interpretation for (1)
</figureCaption>
<bodyText confidence="0.9185305">
Distributive readings and the Copy meta-predicate: (1) is ambigu-
ous between a collective reading (where there is a single test for both the
3 We assume that obligation and permission denoting categories, e.g. must, do not occur
in contexts like antecedent clauses of subordinating conjunctions (like if), and restrictors of
determiners. Handling these cases requires an extension to CTL which is beyond the scope
of this paper.
</bodyText>
<equation confidence="0.9900516">
Copy
p i z T l1,l2....ln
p
[ � [ �
T : z  l1, i  1 ... T : z  ln, i  n
</equation>
<bodyText confidence="0.833300666666667">
x is a donation of hu-
man blood or blood com-
ponent (1). i .1
</bodyText>
<figure confidence="0.77814365">
and
i
specified in (2) -
must
(1). i .2
z each
Copy
the Human immuno-
deficiency vius
the Hepatitis B virus
except as
you, test x , for evi-
dence of infection due
to z - (1). i .3
and
�(1).1.1 (¬(1).1.2  (1).1.3)
� {(1).1.1  (¬(1).1.2  (1).1.3)}
{}
�
�
...
�(1).1.1
� {}
{}
� � �
¬(1).1.2  (1).1.3
� � {¬(1).1.2  (1).1.3} �
{}
�(1).1.2
� {}
{}
� � �
(1).1.3
� �{(1).1.3} �
{}
�(1).1.3
� {}
{}
�
�
</figure>
<figureCaption confidence="0.998412">
Fig. 4. AST and its interpretation for (2)
</figureCaption>
<bodyText confidence="0.942761142857143">
diseases), and a distributive reading (where there are separate tests for each
disease). However, (2) gives an exemption to a test for one of the diseases, and
this suggests that a distributive reading may be more appropriate in the spec-
ifications extracted, and that the distributivity has scope over the exception.
Hence Copy dominates except in Figure 3.
The interpretation of the Copy meta-predicate is given in Figure 2. It is
called a meta-predicate because it is a function from an AST to another AST,
by simple variable substitution. For the AST for (1) shown in Figure 3, this
results in an AST rooted with and with subtrees corresponding to each of the
tests. The interpretation of and in this context is given by:
are required
you to test x for evidence of
infection due to the Hepatitis B
virus z of this section - 02.2
</bodyText>
<figure confidence="0.972376411764706">
every
x is a donation of Source not
Plasma - 02.1
0(2).1  app1  ¬0(2).2
{}
({0(2).1  app1  ¬0(2).2}
�(app1 {} 0(2).2 �
{app1  ¬0(2).2}
�0(2).2
�{0(2).2}
{}
�0(2).2
� {}
{}
�
�
�0(2).1
� {}
{}
�
�
�
�
0 O1
A
and @O1 A
P1
A
ni=1O
= ni=1OA
i a
(Po&apos;lq) n p1 A
1
A
</figure>
<bodyText confidence="0.983893833333333">
The RHS of the equation corresponds to the denotation of the node labeled
and in the AST (shaded in gray in Figure 3).
Universally Quantified NPs correponding to inputs: As mentioned
in Section 3, the universal quantification over inputs (donations) is achieved
by associating states with unique inputs. The interpretation of the determiner
each is designed with idea that the obligations will be evaluated at each state.
</bodyText>
<equation confidence="0.989173333333333">
1OB OA  OB 1
COB) ( = {OA  OBO.j|OBO.j  OB}A
PB {OA  OBP.j|OBP.j  PB}
</equation>
<bodyText confidence="0.974874181818182">
The interpretation of the determiner no is similar to that of each/every,
except that a negation needs to be applied to the nuclear scope. We discuss
the interpretation of negation in what follows.
Conditional and Exceptive constructions: There are several predi-
cates that denote conditions and exceptions. For example, the subordinat-
ing conjunctions if, unless, and except as, coordinating conjunctions like
except that or but. The interpretation of if is the same as that for every. The
interpretation of predicates like except as, and unless are similar, the only
difference being that ¬OA is used instead of OA in the RHS.
Modals and Negation: The semantics of modals and negation are given
below:
</bodyText>
<figure confidence="0.707121444444444">
0
each @
OA
{}
{}
0 OA 1 0 1 0 1OA OA appi  OA
must @ {} A = {OA} may {} = {}
{} {} {} Gappi  OA}
 AJ appj  ¬IPA IPA  IPAO. j  OA
</figure>
<bodyText confidence="0.9936224">
must(A) results in the interpretation that OA is an obligation. may(A)
results in the interpretation that appi A OA is a permission, where appi is
a variable introduced which the implementation must set to true when the
permission is applied (we discuss its use in Section 4.2). And intuitively, the
interpretation of negation captures the idea that may(¬A) - not(must(A)).
</bodyText>
<subsectionHeader confidence="0.707667">
4.2 Discussion
</subsectionHeader>
<bodyText confidence="0.983626296296296">
There are two obligations obtained at the root of the AST for (1): 0(1).1.1 
(¬0(1).1.2  0(1).1.3)  d  (¬e1  thiv) and 0(1).2.1  (¬0(1).2.2  0(1).2.3) 
d  (¬e2  thepb) , where d is true iff the donation is one of blood or blood
component, e, and e2 are the exceptions to the required test for each disease,
and thiv and thepb are true iff tests for HIV and Hepatitis B respectively
have been performed. The computation of the second obligation is not shown
in Figure 3, and is obtained from the second child of and (in the AST shaded
in gray). Note that the individual propositions like d need to be specified by
the requirements engineer at the leaf nodes of the AST.
Figure 4 shows the AST and its interpretation for (2). The permission
obtained at the root node is : 0(2).1 app1 ¬0(2).2  sp app1 ¬thepb where sp
is true iff a donation of source plasma is being processed, and thepb is true iff
a test for the Hepatitis B virus has been carried out.
The use of the app, proposition is as follows. It is possible for the regula-
tion to cancel the permission given in (2), but there may be several cases in
which permission not to test a donation of source plasma for Hepatitis B is
given. Suppose the case under consideration is one where the permission in
(2) is cancelled, but the organization doesn’t test a donation of source plasma
for Hepatitis B because a different permission can be applied. Since the per-
mission being applied sets thepb to false, and sp is true, the only way for the
implementation to indicate that the permission in (2) is not being applied is
by setting app, to false. Setting e1  false, and e2  sp  app1  ¬thepb:
0O.1  d  (¬false  thiv), and 0O.2  d  (¬(sp  app1  ¬thepb)  thepb)
Considering just these obligations, the denotation of the regulatory doc-
ument would be: AM. M h AG(deo  (0O.1  0O.2)) . Therefore, a bloodbank
could decide not to test a donation of source plasma for Hepatitis B, but they
would always have to test a donation for HIV.
</bodyText>
<sectionHeader confidence="0.998573" genericHeader="conclusions">
5 Conclusions and Future Work
</sectionHeader>
<bodyText confidence="0.999612">
We have described a framework to assist a requirements engineer in extracting
CTL specifications from regulatory documents. An account of obligations and
permissions turns out to be essential in composing the specifications. The
composition procedure (defined in Section 4) was applied to a large part of
</bodyText>
<figure confidence="0.983584">
(PA
IPA
not OA
A A l ¬IPA otherwise
{a
j
j |IPO.j  OA}
pp
 ¬IPO
1IP l 1
J= {¬IPAP j |IP j E PAI ) where IPA =
</figure>
<bodyText confidence="0.9992704">
the FDA CFR 610.40. While it does seem to scale well, providing tool support
to extract and interact with the ASTs is vital. To this end, we plan to conduct
a small scale annotation of ASTs which will let us determine the accuracy with
which these representations can be computed. On the user interface side, we
are working on ways of presenting the ASTs to the requirements engineer.
</bodyText>
<sectionHeader confidence="0.999193" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999949060606061">
[1] Breuker, J. and N. den Haan, Separating world and regulation knowledge: where is the
logic?, in: M. Sergot, editor, Proceedings of the third international conference on AI
and Law (1991), pp. 41–51.
[2] Clarke, E. M. and E. A. Emerson, Synthesis of synchronization skeletons for branching
time temporal logic, in: Logic of Programs: Workshop, 1981.
[3] Clarke, E. M., E. A. Emerson and A. P. Sistla, Automatic verification of finite-
state concurrent systems using temporal logic specifications, ACM Transactions on
Programming Languages and Systems 8 (1986), pp. 244–263.
[4] Clarke, E. M. and J. M. Wing, Formal methods: State of the art and future directions,
ACM Computing Surveys 28 (1996), pp. 626–643.
[5] Corbett, J. C., M. B. Dwyer, J. Hatcliff, S. Laubach, C. S. Pasareanu, Robby and
H. Zheng, Bandera: Extracting finite-state models from java source code, in: Proceedings
of the International Conference on Software Engineering (ICSE), 2000.
[6] Fantechi, A., S. Gnesi, G. Ristori, M. Carenini, M. Marino and M. Moreschini, Assisting
requirements formalization by means of natural language translation, Formal Methods
in System Design 4 (1994), pp. 243–263.
[7] Fuchs, N. and R. Schwitter, Attempto controlled english (ace), in: First International
Workshop on Controlled Language Applications, 1996.
[8] Glasse, E., T. V. Engers and A. Jacobs, Power: An integrated method for legislation and
regulations from their design to their use in e-government services and law enforcement,
in: M.-F. Moens, editor, Digitale Wetgeving, Digital Legislation, Die Keure Brugge, 2003
pp. 175–204, iSBN 90 5958 039 7.
[9] Hohfeld, W. N., Fundamental legal conceptions as applied in judicial reasoning, Yale
Law Journal 23 (1913), pp. 16–59.
[10] Holt, A. and E. Klein, A semantically-derived subset of English for hardware
verification, in: 37th Annual Meeting of the ACL, 1999.
[11] Holzmann, G., The Spin model checker, IEEE Trans. on Software Engineering 23
(1997), pp. 279–295.
[12] Kratzer, A., The notational category of modality, in: H.-J. Eikmeyer and H. Rieser,
editors, Words, Worlds, and Contexts. New approaches to Word Semantics, deGruyter,
Berlin, 1981 .
[13] Queille, J. P. and J. Sifakis, Specification and verification of concurrent systems in
CAESAR, in: Proceeding of the Fifth ISP, 1981.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.276710">
<title confidence="0.999609">Extracting Formal Specifications from Natural Language Regulatory Documents</title>
<author confidence="0.991311">Nikhil Dinesh</author>
<author confidence="0.991311">Aravind Joshi</author>
<author confidence="0.991311">Insup Lee</author>
<affiliation confidence="0.999155">Department of Computer Science, Univeristy of</affiliation>
<address confidence="0.995611">Philadelphia, PA - 19104</address>
<author confidence="0.8992145">upenn edu Bonnie Webber</author>
<affiliation confidence="0.874829">University of Edinburgh, Edinburgh, EH8 9LW</affiliation>
<email confidence="0.406508">bonnie@inf.ed.ac.uk</email>
<abstract confidence="0.996178333333333">Formal verification techniques provide a way to determine whether regulatory documents are consistent and whether implementations conform to them. To apply these techniques a formal description of the regulation needs to be extracted. We present a framework, under which NLP techniques can be brought to bear, to aid a requirements engineer in extracting the formal description.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>J Breuker</author>
<author>N den Haan</author>
</authors>
<title>Separating world and regulation knowledge: where is the logic?,</title>
<date>1991</date>
<booktitle>Proceedings of the third international conference on AI and Law</booktitle>
<pages>41--51</pages>
<editor>in: M. Sergot, editor,</editor>
<contexts>
<context position="1740" citStr="[1,8]" startWordPosition="252" endWordPosition="252">stration’s Code of Federal Regulations (FDA CFR) governs the bloodbanks in America.&apos; The bloodbanks perform safety-critical functions like the testing of blood for communicable disease agents (like HIV). It is highly desirable to determine whether (a) the CFR is consistent, and (b) a bloodbank’s implementation of such a function conforms to the CFR. * This research was supported in part by NSF CCF-0429948 and ARO 911NF-05-1-0158 1 http://www.gpoaccess.gov/cfr/index.html The problem of creating descriptions of regulation which can be checked for consistency has been explored by several authors [1,8], but the challenge of checking an implementation for conformance has not been addressed, and this is the main goal of our work. The conformance guarantees can be obtained if formal descriptions of regulation and implementations are available, and if verification techniques [4] can be applied to these descriptions. But extracting a formal description of regulation is expensive, as regulatory bases like the CFR are large (about a million words) and complex. Formal descriptions of regulation are usually extracted by an individual who has a background in logic, e.g., [1,8]. We will call this indi</context>
</contexts>
<marker>[1]</marker>
<rawString>Breuker, J. and N. den Haan, Separating world and regulation knowledge: where is the logic?, in: M. Sergot, editor, Proceedings of the third international conference on AI and Law (1991), pp. 41–51.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E M Clarke</author>
<author>E A Emerson</author>
</authors>
<title>Synthesis of synchronization skeletons for branching time temporal logic, in: Logic of Programs: Workshop,</title>
<date>1981</date>
<contexts>
<context position="4707" citStr="[2,13]" startWordPosition="737" endWordPosition="737">virus. 2 A Framework To determine whether an implementation (bloodbank) conforms to the regulation (CFR), we extract specifications in the Computation Tree Logic (CTL) from the CFR. Then, given a description of a bloodbank’s procedure (as a finite transition system, or model) there is an efficient search procedure to 2 (1) and (2) are modified versions of sentences that appear in the FDA CFR 610.40. The actual sentences are very long, and the modifications are made in the interests of space. determine if the model conforms to the CTL specification [3]. This is known as temporal model checking [2,13]. The problem of conformance checking is thus split into three steps: (1) Extract CTL specifications from the regulation - This is done by a requirements engineer, and our goal is to assist her. We use CTL as the specification language, because it allows for efficient model checking [3]. (2) Obtain a model of an implementation - We assume the availability of models. There are tools that aid in extracting models from software [5], and in creating models if they cannot be extracted directly [11]. (3) Apply model checking to determine if the model conforms to the CTL specification. Formally, a mo</context>
</contexts>
<marker>[2]</marker>
<rawString>Clarke, E. M. and E. A. Emerson, Synthesis of synchronization skeletons for branching time temporal logic, in: Logic of Programs: Workshop, 1981.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E M Clarke</author>
<author>E A Emerson</author>
<author>A P Sistla</author>
</authors>
<title>Automatic verification of finitestate concurrent systems using temporal logic specifications,</title>
<date>1986</date>
<journal>ACM Transactions on Programming Languages and Systems</journal>
<volume>8</volume>
<pages>244--263</pages>
<contexts>
<context position="4658" citStr="[3]" startWordPosition="729" endWordPosition="729"> evidence of infection due to the Hepatitis B virus. 2 A Framework To determine whether an implementation (bloodbank) conforms to the regulation (CFR), we extract specifications in the Computation Tree Logic (CTL) from the CFR. Then, given a description of a bloodbank’s procedure (as a finite transition system, or model) there is an efficient search procedure to 2 (1) and (2) are modified versions of sentences that appear in the FDA CFR 610.40. The actual sentences are very long, and the modifications are made in the interests of space. determine if the model conforms to the CTL specification [3]. This is known as temporal model checking [2,13]. The problem of conformance checking is thus split into three steps: (1) Extract CTL specifications from the regulation - This is done by a requirements engineer, and our goal is to assist her. We use CTL as the specification language, because it allows for efficient model checking [3]. (2) Obtain a model of an implementation - We assume the availability of models. There are tools that aid in extracting models from software [5], and in creating models if they cannot be extracted directly [11]. (3) Apply model checking to determine if the model </context>
</contexts>
<marker>[3]</marker>
<rawString>Clarke, E. M., E. A. Emerson and A. P. Sistla, Automatic verification of finitestate concurrent systems using temporal logic specifications, ACM Transactions on Programming Languages and Systems 8 (1986), pp. 244–263.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E M Clarke</author>
<author>J M Wing</author>
</authors>
<title>Formal methods: State of the art and future directions,</title>
<date>1996</date>
<journal>ACM Computing Surveys</journal>
<volume>28</volume>
<pages>626--643</pages>
<contexts>
<context position="2018" citStr="[4]" startWordPosition="294" endWordPosition="294">b) a bloodbank’s implementation of such a function conforms to the CFR. * This research was supported in part by NSF CCF-0429948 and ARO 911NF-05-1-0158 1 http://www.gpoaccess.gov/cfr/index.html The problem of creating descriptions of regulation which can be checked for consistency has been explored by several authors [1,8], but the challenge of checking an implementation for conformance has not been addressed, and this is the main goal of our work. The conformance guarantees can be obtained if formal descriptions of regulation and implementations are available, and if verification techniques [4] can be applied to these descriptions. But extracting a formal description of regulation is expensive, as regulatory bases like the CFR are large (about a million words) and complex. Formal descriptions of regulation are usually extracted by an individual who has a background in logic, e.g., [1,8]. We will call this individual the requirements engineer. In this paper, we describe a framework to assist a requirements engineer in extracting a formal description of regulation for use in conformance checking. An overview of the framework, the theoretical background and the various constraints that</context>
</contexts>
<marker>[4]</marker>
<rawString>Clarke, E. M. and J. M. Wing, Formal methods: State of the art and future directions, ACM Computing Surveys 28 (1996), pp. 626–643.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J C Corbett</author>
<author>M B Dwyer</author>
<author>J Hatcliff</author>
<author>S Laubach</author>
<author>C S Pasareanu</author>
<author>Robby</author>
<author>H Zheng</author>
</authors>
<title>Bandera: Extracting finite-state models from java source code, in:</title>
<date>2000</date>
<booktitle>Proceedings of the International Conference on Software Engineering (ICSE),</booktitle>
<contexts>
<context position="5139" citStr="[5]" startWordPosition="810" endWordPosition="810">ng, and the modifications are made in the interests of space. determine if the model conforms to the CTL specification [3]. This is known as temporal model checking [2,13]. The problem of conformance checking is thus split into three steps: (1) Extract CTL specifications from the regulation - This is done by a requirements engineer, and our goal is to assist her. We use CTL as the specification language, because it allows for efficient model checking [3]. (2) Obtain a model of an implementation - We assume the availability of models. There are tools that aid in extracting models from software [5], and in creating models if they cannot be extracted directly [11]. (3) Apply model checking to determine if the model conforms to the CTL specification. Formally, a model can be defined as follows: Definition 2.1 A model M is the five-tuple (S, I, S, 7r,11), where: (a) S is a set of states, I C S is a non-empty set of initial states, (b) S C S x S is a total transition relation (that is, ds E S : [Elt E S : (s, t) E S]), (c) 7r is a set of propositions (with power set 2&apos;), and (d) 11 : S —&gt; 2&apos; is a function from states to sets of propositions. 11(s) for s E S can be thought of as the proposit</context>
<context position="8838" citStr="[5,11]" startWordPosition="1476" endWordPosition="1476">le model checking, focus on a subset of NL from which an automatic translation is guaranteed, or make the procedure machine-assisted. While the design of more expressive logics makes the composition of specifications easier, using them for model checking needs the creation of more expressive models (which requires more effort). As a result, there is a trade-off between amount of effort spent in obtaining models, and that in obtaining the specifications. Our decision to work with less expressive models is motivated by the extensive tool support available for creating and extracting such models [5,11]. Further, subsets of NL for which automatic translation is guaranteed, such as the one derived by Holt and Klein [10], assume (among other things) that references are resolved and hence cannot be directly applied to regulatory documents. We are thus left with the choice of making the procedure machine-assisted. There have been two kinds of machine-assisted approaches to extracting temporal logic specifications: (a) composing the semantics in a general semantic framework which is then mapped to temporal logic [7], and (b) attempting to compose the semantics in the temporal logic directly [6]. </context>
</contexts>
<marker>[5]</marker>
<rawString>Corbett, J. C., M. B. Dwyer, J. Hatcliff, S. Laubach, C. S. Pasareanu, Robby and H. Zheng, Bandera: Extracting finite-state models from java source code, in: Proceedings of the International Conference on Software Engineering (ICSE), 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Fantechi</author>
<author>S Gnesi</author>
<author>G Ristori</author>
<author>M Carenini</author>
<author>M Marino</author>
<author>M Moreschini</author>
</authors>
<title>Assisting requirements formalization by means of natural language translation,</title>
<date>1994</date>
<booktitle>Formal Methods in System Design</booktitle>
<volume>4</volume>
<pages>243--263</pages>
<contexts>
<context position="9436" citStr="[6]" startWordPosition="1569" endWordPosition="1569">5,11]. Further, subsets of NL for which automatic translation is guaranteed, such as the one derived by Holt and Klein [10], assume (among other things) that references are resolved and hence cannot be directly applied to regulatory documents. We are thus left with the choice of making the procedure machine-assisted. There have been two kinds of machine-assisted approaches to extracting temporal logic specifications: (a) composing the semantics in a general semantic framework which is then mapped to temporal logic [7], and (b) attempting to compose the semantics in the temporal logic directly [6]. In the latter approach, a human specifies denotations for a portion of the sentence, and the rest of the composition happens automatically. We attempt to compose the semantics in a temporal logic directly like [6], as it lends itself to defining semantic representations with which a requirements engineer can interact in well-defined ways. 2.2 Constraints on the CTL specifications We apply two constraints to the CTL specifications: (i) The specifications extracted should hold of all and only the valid models. There may be several implementations that aim to conform to a single base of regulat</context>
</contexts>
<marker>[6]</marker>
<rawString>Fantechi, A., S. Gnesi, G. Ristori, M. Carenini, M. Marino and M. Moreschini, Assisting requirements formalization by means of natural language translation, Formal Methods in System Design 4 (1994), pp. 243–263.</rawString>
</citation>
<citation valid="true">
<authors>
<author>N Fuchs</author>
<author>R Schwitter</author>
</authors>
<title>Attempto controlled english (ace), in:</title>
<date>1996</date>
<booktitle>First International Workshop on Controlled Language Applications,</booktitle>
<contexts>
<context position="9356" citStr="[7]" startWordPosition="1556" endWordPosition="1556">y the extensive tool support available for creating and extracting such models [5,11]. Further, subsets of NL for which automatic translation is guaranteed, such as the one derived by Holt and Klein [10], assume (among other things) that references are resolved and hence cannot be directly applied to regulatory documents. We are thus left with the choice of making the procedure machine-assisted. There have been two kinds of machine-assisted approaches to extracting temporal logic specifications: (a) composing the semantics in a general semantic framework which is then mapped to temporal logic [7], and (b) attempting to compose the semantics in the temporal logic directly [6]. In the latter approach, a human specifies denotations for a portion of the sentence, and the rest of the composition happens automatically. We attempt to compose the semantics in a temporal logic directly like [6], as it lends itself to defining semantic representations with which a requirements engineer can interact in well-defined ways. 2.2 Constraints on the CTL specifications We apply two constraints to the CTL specifications: (i) The specifications extracted should hold of all and only the valid models. Ther</context>
</contexts>
<marker>[7]</marker>
<rawString>Fuchs, N. and R. Schwitter, Attempto controlled english (ace), in: First International Workshop on Controlled Language Applications, 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Glasse</author>
<author>T V Engers</author>
<author>A Jacobs</author>
</authors>
<title>Power: An integrated method for legislation and regulations from their design to their use in e-government services and law enforcement,</title>
<date>2003</date>
<booktitle>Digitale Wetgeving, Digital Legislation, Die Keure</booktitle>
<pages>175--204</pages>
<editor>in: M.-F. Moens, editor,</editor>
<location>Brugge,</location>
<contexts>
<context position="1740" citStr="[1,8]" startWordPosition="252" endWordPosition="252">stration’s Code of Federal Regulations (FDA CFR) governs the bloodbanks in America.&apos; The bloodbanks perform safety-critical functions like the testing of blood for communicable disease agents (like HIV). It is highly desirable to determine whether (a) the CFR is consistent, and (b) a bloodbank’s implementation of such a function conforms to the CFR. * This research was supported in part by NSF CCF-0429948 and ARO 911NF-05-1-0158 1 http://www.gpoaccess.gov/cfr/index.html The problem of creating descriptions of regulation which can be checked for consistency has been explored by several authors [1,8], but the challenge of checking an implementation for conformance has not been addressed, and this is the main goal of our work. The conformance guarantees can be obtained if formal descriptions of regulation and implementations are available, and if verification techniques [4] can be applied to these descriptions. But extracting a formal description of regulation is expensive, as regulatory bases like the CFR are large (about a million words) and complex. Formal descriptions of regulation are usually extracted by an individual who has a background in logic, e.g., [1,8]. We will call this indi</context>
</contexts>
<marker>[8]</marker>
<rawString>Glasse, E., T. V. Engers and A. Jacobs, Power: An integrated method for legislation and regulations from their design to their use in e-government services and law enforcement, in: M.-F. Moens, editor, Digitale Wetgeving, Digital Legislation, Die Keure Brugge, 2003 pp. 175–204, iSBN 90 5958 039 7.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W N Hohfeld</author>
</authors>
<title>Fundamental legal conceptions as applied in judicial reasoning,</title>
<date>1913</date>
<journal>Yale Law Journal</journal>
<volume>23</volume>
<pages>16--59</pages>
<contexts>
<context position="13760" citStr="[9]" startWordPosition="2316" endWordPosition="2316">the sections of the CFR that we examined, a universal quantification over entities is absolutely essential when these entities correspond to inputs of an implemenation. This assumption lets us tie the inputs to states, and use the quantification over states to achieve the quantification over entities. Thus (4) can be reduced to (5). (5) AM. M h AG(deo  (d  (¬e  thepb))) A problem that is encountered in taking this approach is that there is no distinction between obligations, and permissions (both of which stem from the Hohfeldian legal conceptions of right, duty, privilege, and no right [9]). While this did not cause a problem for the obligation in (1), if one were to follow the same procedure for the permission in (2), we would get the denotation in (6). (6) AM. M h ¬(AG(deo  (sp  thepb))) A model satisfies (6) only if there is some path in which there is a state that is deontically accessible, and if a donation of source plasma is being processed it is not tested. This is too strong a requirement, because an organization may choose not to do what it is permitted to do. The model in Figure 1(a) is a valid model, which would be declared invalid if (6) were required of it. An</context>
</contexts>
<marker>[9]</marker>
<rawString>Hohfeld, W. N., Fundamental legal conceptions as applied in judicial reasoning, Yale Law Journal 23 (1913), pp. 16–59.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Holt</author>
<author>E Klein</author>
</authors>
<title>A semantically-derived subset of English for hardware verification, in:</title>
<date>1999</date>
<booktitle>37th Annual Meeting of the ACL,</booktitle>
<contexts>
<context position="8956" citStr="[10]" startWordPosition="1496" endWordPosition="1496">ine-assisted. While the design of more expressive logics makes the composition of specifications easier, using them for model checking needs the creation of more expressive models (which requires more effort). As a result, there is a trade-off between amount of effort spent in obtaining models, and that in obtaining the specifications. Our decision to work with less expressive models is motivated by the extensive tool support available for creating and extracting such models [5,11]. Further, subsets of NL for which automatic translation is guaranteed, such as the one derived by Holt and Klein [10], assume (among other things) that references are resolved and hence cannot be directly applied to regulatory documents. We are thus left with the choice of making the procedure machine-assisted. There have been two kinds of machine-assisted approaches to extracting temporal logic specifications: (a) composing the semantics in a general semantic framework which is then mapped to temporal logic [7], and (b) attempting to compose the semantics in the temporal logic directly [6]. In the latter approach, a human specifies denotations for a portion of the sentence, and the rest of the composition h</context>
<context position="10316" citStr="[10]" startWordPosition="1713" endWordPosition="1713">h which a requirements engineer can interact in well-defined ways. 2.2 Constraints on the CTL specifications We apply two constraints to the CTL specifications: (i) The specifications extracted should hold of all and only the valid models. There may be several implementations that aim to conform to a single base of regulation. Given (1) and (2), the models in Figures 1(a) and 1(b) are both valid. This is an important difference from the NL sentences considered in previous approaches, which were elicited from appropriate users by presenting them with a single model. For example, Holt and Klein [10] obtained specifications by asking users to describe a particular timing diagram. (ii) To account for the variation between models, all temporal information about the governed entities/events is modelled through propositions. The only use of the temporal operators in CTL is to obtain a quantification over paths and states. A mapping will need to be performed so that the propositions used in the specifications can be evaluated at a states in different models, and the critical assumption is that this mapping will be very easy to specify. 3 From Sets of Worlds to Sets of Models Several approaches</context>
</contexts>
<marker>[10]</marker>
<rawString>Holt, A. and E. Klein, A semantically-derived subset of English for hardware verification, in: 37th Annual Meeting of the ACL, 1999.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Holzmann</author>
</authors>
<title>The Spin model checker,</title>
<date>1997</date>
<journal>IEEE Trans. on Software Engineering</journal>
<volume>23</volume>
<pages>279--295</pages>
<contexts>
<context position="5205" citStr="[11]" startWordPosition="821" endWordPosition="821">ermine if the model conforms to the CTL specification [3]. This is known as temporal model checking [2,13]. The problem of conformance checking is thus split into three steps: (1) Extract CTL specifications from the regulation - This is done by a requirements engineer, and our goal is to assist her. We use CTL as the specification language, because it allows for efficient model checking [3]. (2) Obtain a model of an implementation - We assume the availability of models. There are tools that aid in extracting models from software [5], and in creating models if they cannot be extracted directly [11]. (3) Apply model checking to determine if the model conforms to the CTL specification. Formally, a model can be defined as follows: Definition 2.1 A model M is the five-tuple (S, I, S, 7r,11), where: (a) S is a set of states, I C S is a non-empty set of initial states, (b) S C S x S is a total transition relation (that is, ds E S : [Elt E S : (s, t) E S]), (c) 7r is a set of propositions (with power set 2&apos;), and (d) 11 : S —&gt; 2&apos; is a function from states to sets of propositions. 11(s) for s E S can be thought of as the propositions true at s. Figure 1(a) and 1(b) show models of two different </context>
<context position="8838" citStr="[5,11]" startWordPosition="1476" endWordPosition="1476">le model checking, focus on a subset of NL from which an automatic translation is guaranteed, or make the procedure machine-assisted. While the design of more expressive logics makes the composition of specifications easier, using them for model checking needs the creation of more expressive models (which requires more effort). As a result, there is a trade-off between amount of effort spent in obtaining models, and that in obtaining the specifications. Our decision to work with less expressive models is motivated by the extensive tool support available for creating and extracting such models [5,11]. Further, subsets of NL for which automatic translation is guaranteed, such as the one derived by Holt and Klein [10], assume (among other things) that references are resolved and hence cannot be directly applied to regulatory documents. We are thus left with the choice of making the procedure machine-assisted. There have been two kinds of machine-assisted approaches to extracting temporal logic specifications: (a) composing the semantics in a general semantic framework which is then mapped to temporal logic [7], and (b) attempting to compose the semantics in the temporal logic directly [6]. </context>
</contexts>
<marker>[11]</marker>
<rawString>Holzmann, G., The Spin model checker, IEEE Trans. on Software Engineering 23 (1997), pp. 279–295.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Kratzer</author>
</authors>
<title>The notational category of modality,</title>
<date>1981</date>
<pages>.</pages>
<editor>in: H.-J. Eikmeyer and H. Rieser, editors, Words, Worlds, and</editor>
<location>Berlin,</location>
<contexts>
<context position="2908" citStr="[12]" startWordPosition="437" endWordPosition="437"> e.g., [1,8]. We will call this individual the requirements engineer. In this paper, we describe a framework to assist a requirements engineer in extracting a formal description of regulation for use in conformance checking. An overview of the framework, the theoretical background and the various constraints that apply is given in Section 2. This lets us determine the nature of the description that needs to be extracted from the regulation. We then turn to the question of how these descriptions might be composed. In Section 3, we attempt to map the denotations of sentences assigned by Kratzer [12] to a form that can be used for the task at hand. Some difficulties arise in this mapping, mainly because notions of obligation (that which is required) and permission (that which is allowed) are not captured in the denotations. We argue that an account of these notions is essential to the task at hand. Section 4 describes a semantic representation, and composition procedure to assist the requirements engineer in extracting the required description. By treating obligations and permissions as different dimensions of the description computed, the difficulties encountered in Section 3 are address</context>
<context position="11037" citStr="[12]" startWordPosition="1828" endWordPosition="1828">etween models, all temporal information about the governed entities/events is modelled through propositions. The only use of the temporal operators in CTL is to obtain a quantification over paths and states. A mapping will need to be performed so that the propositions used in the specifications can be evaluated at a states in different models, and the critical assumption is that this mapping will be very easy to specify. 3 From Sets of Worlds to Sets of Models Several approaches in formal semantics take sentences to denote sets of worlds. For normative statements, we assume (following Kratzer [12]) that worlds are connected by an accessibility relation. Consider (1) in Section 1 which among other things requires a test for Hepatitis B if no exceptions apply. A denotation of this requirement is given in (3), and is the set of worlds wo, such that for every deontically accessible world w, for every entity x such that x is a donation in that world d&apos;(x,w), if no exception holds of that donation ¬e&apos;(x,w), a test for Hepatitis B is carried out for that donation thepb&apos;(x, w). We will assume that negation has the highest precedence. Therefore ¬a  b  (¬a)  b, and brackets are used to resolv</context>
</contexts>
<marker>[12]</marker>
<rawString>Kratzer, A., The notational category of modality, in: H.-J. Eikmeyer and H. Rieser, editors, Words, Worlds, and Contexts. New approaches to Word Semantics, deGruyter, Berlin, 1981 .</rawString>
</citation>
<citation valid="true">
<authors>
<author>J P Queille</author>
<author>J Sifakis</author>
</authors>
<title>Specification and verification of concurrent systems</title>
<date>1981</date>
<booktitle>in CAESAR, in: Proceeding of the Fifth ISP,</booktitle>
<contexts>
<context position="4707" citStr="[2,13]" startWordPosition="737" endWordPosition="737">virus. 2 A Framework To determine whether an implementation (bloodbank) conforms to the regulation (CFR), we extract specifications in the Computation Tree Logic (CTL) from the CFR. Then, given a description of a bloodbank’s procedure (as a finite transition system, or model) there is an efficient search procedure to 2 (1) and (2) are modified versions of sentences that appear in the FDA CFR 610.40. The actual sentences are very long, and the modifications are made in the interests of space. determine if the model conforms to the CTL specification [3]. This is known as temporal model checking [2,13]. The problem of conformance checking is thus split into three steps: (1) Extract CTL specifications from the regulation - This is done by a requirements engineer, and our goal is to assist her. We use CTL as the specification language, because it allows for efficient model checking [3]. (2) Obtain a model of an implementation - We assume the availability of models. There are tools that aid in extracting models from software [5], and in creating models if they cannot be extracted directly [11]. (3) Apply model checking to determine if the model conforms to the CTL specification. Formally, a mo</context>
</contexts>
<marker>[13]</marker>
<rawString>Queille, J. P. and J. Sifakis, Specification and verification of concurrent systems in CAESAR, in: Proceeding of the Fifth ISP, 1981.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>