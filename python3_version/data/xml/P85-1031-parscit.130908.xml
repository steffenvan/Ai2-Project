<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000123">
<title confidence="0.7859875">
AN ECLECTIC APPROACH TO
BUILDING NATURAL LANGUAGE INTERFACES
</title>
<note confidence="0.742679">
Brian Phillips. Michael I. Freiling, James II. Alexander,
Steven L. Messick, Steve Rehfuss, Sheldon Nichollt
</note>
<sectionHeader confidence="0.53327825" genericHeader="abstract">
Tektronix, Inc.
P.O. Box 500, M/S 50-662
Beaverton, OR 97077
ABSTRACT
</sectionHeader>
<bodyText confidence="0.999672692307692">
INKA is a natural language interface to facilitate
knowledge acquisition during expert system development for
electronic instrument trouble-shooting. The expert system
design methodology develops a domain definition, called
GLIB, in the form of a semantic grammar. This grammar for-
mat enables GLIB to be used with the INGLISH interface,
which constrains users to create statements within a subset of
English. Incremental parsing in 1NGLISH allows immediate
remedial information to be generated if a user deviates from
the sublanguage. Sentences are translated into production rules
using the methodology of lexical-functional grammar. The sys-
tem is written in Smalltalk and, in INKA, produces rules for a
Prolog inference engine.
</bodyText>
<sectionHeader confidence="0.997666" genericHeader="introduction">
INTRODUCTION
</sectionHeader>
<bodyText confidence="0.99925931884058">
The ideal natural language interface would let any user,
without any prior training, interact with a computer. Such an
interface would be useful in the knowledge acquisition phase
of expert system development where the diagnostic knowledge
of a skilled practitioner has to be elicited. As technicians are
not familiar with formal knowledge representation schemes, a
trained intermediary, a knowledge engineer, is generally
employed to handcraft the internal format. This process is
time-consuming and expensive.
INKA (INglish Knowledge Acquisition) permits task
experts to express their knowledge in a subset of English, and
have it automatically translated into the appropriate represen-
tational formalism. In particular, the version of INKA to be
discussed here accepts input in a sublanguage called GLIB
which permits the statement of facts and rules relevant to the
troubleshooting of electronic systems (Freiling et al., 1984),
and translates these statements into Prolog unit clauses for later
processing by a specialized inference mechanism. Experiments
with INKA to date have enabled us to construct sufficient
troubleshooting rules to build a localizing troubleshooter for a
simple circuit.
INKA is designed as one of the tools of DETEKTR, an
environment for building knowledge based electronic instru-
ment troubleshooters (Freiling &amp; Alexander, 1984).
DETEKTR supports an expert system development methodol-
ogy which is outlined below. The design goal of INKA is that
it serve as a natural language input system to facilitate transfer
of knowledge during the knowledge acquisition phase of expert
system development. INKA is not intended to stand alone as
the sole mechanism for knowledge transfer, but to be sup-
t A summer intern at Tektronix, currently at the Univer-
sity of Illinois, Champaign-Urbana.
ported by components capable of managing a coherent dialo-
gue with the task expert. McKeown (1984) has pointed out a
number of important aspects of the pragmatics that relate to
the usage phase of an expert system. Similar pragmatics are
required to insure adequate construction of the system&apos;s
knowledge base during the knowledge acquisition phase of an
expert system&apos;s development. The most important pragmatic
facility is one to estimate the degree of epistemic coverage of
the knowledge acquired so far, and to prompt the task expert
for more knowledge in areas where the coverage is weak. It is
unfeasible to assume that any task expert can simply perform a
&amp;quot;memory dump&amp;quot; of expertise into some natural language
interface and be done with it.
This paper discusses the natural language technology used
in building INKA. The system incorporates a diverse collec-
tion of natural language technologies in its construction.
Specifically, DMA utilizes a semantic grammar (Burton, 1976)
to characterize the domain sublanguage, le.xical-functional
semantics (Kaplan &amp; Bresnan, 1982) to translate to the internal
form of representation, and an interface that includes left-
corner parsing with in-line guidance to address the linguistic
coverage problem that arises with sublanguages. We feel this
eclectic approach is a useful for building application-oriented
natural language interfaces. Although we are describing a
knowledge acquisition application, the methodology can be
used for any application whose sublanguage can be stated in
the prescribed grammar formalism.
Tereisias (Davis, 1977) provides a natural language
environment for debugging a knowledge base. INKA at
present contains no facilities to modify an existing rule or to
test the evolving knowledge base for some level of integrity;
these are to be future additions.
INKA is written in Smalltalk (Goldberg &amp; Robson, 1983)
and runs on both the Tektronix Magnolia Workstation and the
4404 Artificial Intelligence System. INKA makes extensive
use of the bit-mapped display and three-button mouse on these
systems.
</bodyText>
<subsectionHeader confidence="0.530492">
LANGUAGE AS A KNOWLEDGE ENGINEERING TOOL
</subsectionHeader>
<bodyText confidence="0.999813111111111">
The major bottlenecks in building knowledge based sys-
tems have proven to be related to the definition and acquisi-
tion of knowledge to be processed.
The first bottleneck occurs in the knowledge definition
phase of system development, where symbolic structures are
defined that represent the knowledge necessary to accomplish
a particular task. A bottleneck arises because of the shortage
of knowledge engineers, who are skilled in defining these struc-
tures and using them to express relevant knowledge.
</bodyText>
<page confidence="0.99673">
254
</page>
<bodyText confidence="0.999984235294118">
The second bottleneck occurs in the knowledge acquisition
phase, which involves the codification of the knowledge neces-
sary for a system to function correctly. A bottleneck arises
here because in current practice, the presence of the
knowledge engineer is required throughout this time-
consuming process.
In the course of defining a viable methodology for the
construction of expert systems (Freiling &amp; Alexander 1984;
Alexander et al. 1985), we have identified certain classes of
problems where the task of defining the knowledge structures
and the task of actually building them can be effectively
separated, with only the former being performed by a trained
knowledge engineer. The problem of building a large collec-
tion of knowledge-based troubleshooters for electronic instru-
ments is an example. In order to support the construction of a
large class of such systems, it makes sense to perform the
knowledge definition step for the overall domain initially, and
to build domain-specific development tools, which include
problem-oriented subsets of English and special purpose graph-
ical displays, that can be reused in the development of each
individual knowledge-based system.
Even in the context of such an approach, we have found
that there is usually a shortage of capable knowledge engineers
to carry out the knowledge definition phase, and that a well-
defined methodology can be of great value here in aiding non-
linguistically oriented computer scientists to carry out this ver-
bal elicitation task. The major issue is how to get started
defining the forms into which knowledge is to be cast.
We have found it an effective technique to begin this pro-
cess by recording statements made by task experts on tape, and
transcribing these to fairly natural English. When enough
recording has been done, the statements begin to take on
recognizable patterns. It is then possible to build a formal
grammar for much of the relevant utterances, using linguistic
engineering techniques such as semantic grammars The sym-
bols of this grammar and the task specific vocabulary provide
convenient points for defining formal sub-structures, which are
pieced together to define a complete symbolic representation.
Once the grammar is reasonably well-defined, the mapping to
symbolic representation can be carried out with mapping tech-
niques such as the f-structure constraints of lexical-functional
grammar.
Up to this point, we can imagine that the entire task has
been carried out on paper, or some machine-readable
equivalent. Even in such a rudimentary form, the exercise is
useful, because it provides a conveniently formal documenta-
tion for the knowledge representation decisions that have been
made. However, it is also the case that these formal defini-
tions, if appropriately constructed, provide all that is necessary
to construct a problem specific interface for acquiring utter-
ances expressed in this sublanguage. In fact, the idea of using
this technique to build acquisition interfaces. using INGLISH,
actually occurred as a result of wondering what to do with a
grammar we had constructed simply in order to document our
representation structures (Freiling et al. 1984).
We do not intend to imply that it is possible in complex
knowledge based system applications to simply build a gram-
mar and immediately begin acquiring knowledge. Often the
process leading to construction of the grammar can be quite
complex. In our case, it even involved building a simple proto-
type troubleshooting system before we had gained sufficient
confidence in our representation structures to attempt a
knowledge acquisition interface.
Nor do we intend to claim that all the knowledge neces-
sary to build a complete expert system need be computed in
this fashion. Systems such as INKA can be justified on an
economic basis if they make possible only the transfer of a sig-
nificant fraction of the relevant knowledge.
</bodyText>
<subsectionHeader confidence="0.47701">
GLIB — A PROBLEM SPECIFIC SUBLANGUAGE
</subsectionHeader>
<bodyText confidence="0.990203882352941">
The knowledge acquisition language developed for elec-
tronic device troubleshooting is called GLIB (General
Language for Instrument Behavior), and is aimed primarily at
describing observations of the static and dynamic behavior of
electrical signals as measured with oscilloscopes, voltmeters,
and other standard electronic test instruments (Freiling et al.
1984). The grammatical structure of GLIB is that of a seman-
tic grammar, where non-terminal symbols represent units of
interest to the problem domain rather than recognizable
linguistic categories.
This semantic grammar formalism is an important part of
the DETEKTR methodology because the construction of
semantic grammars is a technique that is easily learned by the
apprentice knowledge engineer. It also males possible the
establishment of very strong constraints on the formal language
developed by this process. Two of the design constraints we
find it advisable to impose are that the language be unambigu-
ous (in the formal sense of a unique derivation for each legal
sentence) and that it be context-free. These constraints, as will
be seen, make possible features of the interface which cannot
normally be delivered in other contexts, such as menus from
which to select all legal next terminal tokens. While increasing
complexity of the acquisition sublanguage may make these
goals unfeasible past a certain point, in simple systems they are
features to be cherished.
Figure 1 shows a fragment of the GLIB grammar. In the
DETEKTR version of INKA, sentences in this language are
accepted, and mapped into Prolog terms for processing by a
Prolog based diagnostic inference engine. At present, the elici-
tation is unguided: responsibility resides with the user to ensure
that all relevant statements are generated. We are still studying
the issues involved in determining completeness of a
knowledge base and assimilating new knowledge. One out-
come of these studies should be means of guiding the user to
areas of the knowledge base that are incomplete and warrant
further elaboration. Future enhancements to the system will
include explanation and modification facilities, so that
knowledge may be added or changed after testing the infer-
ence engine.
THE NATURAL LANGUAGE INTERFACE DESIGN
INGLISH - INterface enGLISH (Phillips &amp; Nicholl,
1984) - allows a user to create sentences either by menu selec-
tion, by typing, or by a mixture of the two. This allows the
self-paced transition from menu-driven to a typed mode of
interaction. In-line help is available. To assist the typist,
automatic spelling correction, word completion, and automatic
phrase completion are provided. INGLISH constrains users to
create statements within a subset of English, here GLIB.
A statement can be entered as a sequence of menu-
selections using only the mouse. A mouse-click brings up a
menu of words and phrases that are valid extensions of the
</bodyText>
<page confidence="0.988739">
255
</page>
<figure confidence="0.983646419354839">
&lt;rule&gt;
W &lt;condition&gt; THEN &lt;conclusion&gt;
&lt;condition&gt;
&lt;context independent predicate&gt; I
&lt;context independent predicate&gt; WHEN &lt;structural context&gt;
&lt;conclusion&gt;
&lt;functional context&gt;
&lt;atomic functional context&gt;
&lt;device&gt; HAS FAILED I
&lt;device&gt; IS OK
&lt;functional context&gt;
&lt;atomic functional context&gt; I
&lt;atomic functional context&gt; AND &lt;functional context&gt; I
&lt;atomic functional context&gt; OR &lt;functional context&gt;
&lt;atomic structural context&gt;
&lt;device&gt; IS REMOVED
&lt;structural context&gt;
&lt;atomic structural context&gt;
&lt;atomic structural context&gt; AND &lt;structural context&gt;
&lt;context independent predicate&gt;
&lt;value predicate&gt;
&lt;value predicate&gt;
&lt;value expression&gt; IS &lt;value expression&gt; I
&lt;value expression&gt; &lt;comparator&gt; &lt;value expression&gt;
&lt;comparator&gt;
IS EQUAL TO I = I
IS GREATER THAN I &gt;
IS LESS THAN I &lt;I
IS LESS THAN OR EQUAL TO I &lt;= I
IS GREATER THAN OR EQUAL TO I
IS NOT EQUAL TO I !=
</figure>
<figureCaption confidence="0.999805">
Figure 1: A fragment of GLIB
</figureCaption>
<bodyText confidence="0.997087655172414">
current sentence fragment. Once a selection is made from the
menu using the mouse, the fragment is extended. This
sequence can be repeated until the sentence is completed.
Creating a sentence in this manner compares with the
NLMENU system (Tennant et al., 1983). Unlike NLMENU,
keyboard entry is also possible with INGLISH. Gilfoil (1982)
found that users prefer a command form of entry to menu-
driven dialogue as their experience increases. When typing, a
user who is unsure of the coverage can invoke a menu, either
by a mouse-click or by typing a second space character, to find
out what INGLISH expects next without aborting the current
statement. Similarly, any unacceptable word causes the menu
to appear, giving immediate feedback of a deviation and
suggestions for correct continuation. A choice from the menu
can be typed or selected using the mouse. INGLISH in fact
allows all actions to be performed from the keyboard or with
the mouse and for them to be freely intermingled. As only
valid words are accepted, all completed sentences are well-
formed and can be translated into the internal representation.
Figure 5, in the &amp;quot;INGLISH&amp;quot; window, shows a complete
sentence and its translation, and a partial sentence with a menu
of continuations. The numbers associated with each menu
item provide a shorthand for entry, i.e., &amp;quot;*12&amp;quot; can be typed
instead of &amp;quot;RESISTANCE&amp;quot;. As menu entries can be phrases,
this can save significant typing effort.
Input is processed on a word-by-word basis. Single spaces
and punctuation characters serve as word terminators. Words
are echoed as typed and overwritten in uppercase when
accepted. Thus, if lowercase is used for typing, the progress of
the sentence is easily followed. An invalid entry remains visi-
ble along with the menu of acceptable continuations then is
replaced when a selection is made.
The spelling corrector (a Smalltalk system routine is used)
only corrects to words that would be acceptable in the current
syntactic/semantic context. As Carbonell and Hayes (1983)
point out, this is more efficient and accurate than attempting
to correct against the whole application dictionary.
Word completion is provided with the &amp;quot;escape&amp;quot; character
(cf. DEC, 1971). When this is used, INGLISH attempts to
complete the word on the basis of the characters so far typed.
If there are several possibilities, they are displayed in a menu.
Automatic phrase completion occurs whenever the con-
text permits no choice. The completion will extend as far as
possible In an extreme case a single word could yield a whole
sentence! The system will &amp;quot;soak-up&amp;quot; any words in the comple-
tion that have also been typed.
The spelling corrector and automatic phrase completion
can interact in a disturbing manner. Any word that is outside
the coverage will be treated as an error and an attempt will be
made to correct it. If there is a viable correction, it will be
made. Should phrase completion then be possible, a portion of
a sentence could be constructed that is quite different from the
one intended by the user. Such behavior will probably be less
evident in large grammars. Nevertheless, it may be necessary
to have a &amp;quot;cautious&amp;quot; and &amp;quot;trusting&amp;quot; mode, as in Interlisp&apos;s
DWIM (Xerox, 1983), for users who resent the precocious
impatience of the interface.
The system does not support anaphora, and ellipsis is
offered indirectly. The interface has two modes: &amp;quot;ENTRY&amp;quot;
and &amp;quot;EDIT&amp;quot; (Figure 5). These are selected by clicking the
mouse while in the pane at the top right of the interface win-
dow. Rules are normally entered in the Enter mode. When in
Edit mode, the window gives access to the Smalltalk editor.
This allows any text in the window to be modified to create a
new statement. After editing, a menu command is used to
pass the sentence to the parser as if it were being typed. Any
error in the constructed sentence causes a remedial menu to be
displayed and the tail of the edited sentence to be thrown
away.
The 1NGL1SH interface alleviates the problem of linguis-
tic coverage for designers and users of natural language inter-
faces. A natural language interface user composes his entries
bearing in mind a model of the interface&apos;s capabilities. If his
model is not accurate, his interactions will be error-prone. He
may excerd the coverage of the system and have his entry
rejected. If this happens frequently, use of the interface may
be abandoned in frustration. On the other hand he may form
an overly conservative model of the system and fail to utilize
the full capabilities of the interface (Tennant, 1980). An inter-
face designer is confronted by many linguistic phenomena.
e.g., noun groups, relative clauses, ambiguity, reference,
ellipsis, anaphora, and paraphrases. Oct account of perfor-
mance requirements or on a lack of a theoretical understand-
ing, many of these constructions will not be in the interface.
INGLISH allows designers to rest more comfortably with the
compromises they have made, knowing that users can sys-
tematically discover the coverage of the interface.
</bodyText>
<page confidence="0.995364">
256
</page>
<sectionHeader confidence="0.903848" genericHeader="method">
THE IMPLEMENTATION OF ENGLISH
</sectionHeader>
<bodyText confidence="0.99845578">
ENGLISH parses incrementally from left to right and per-
forms all checking on each word as it is entered. The parser
follows the Left-Corner Algorithm (Griffiths &amp; Petrick, 1965),
modified to a pseudo-parallel format so that it can follow all
parses simultaneously (Phillips, 1984). This algorithm builds
phrases bottom-up from the left-corner, i.e., rules are selected
by the first symbol of their right-hand-sides. For example,
given a phrase initial category c, a rule of the form X c —
will be chosen. The remaining rule segments of the right-hand
side are predictions about the structure of the remainder of the
phrase and are processed left-to-right. Subsequent inputs will
directly match successive rule segments if the latter are termi-
nal symbols of the grammar. When a non-terminal symbol is
encountered, a subparse is initiated. The subparse is also con-
structed bottom-up from the left-corner, following the rule
selection process just described. When an embedded rule is
completed, the phrase formed may have the structure of the
non-terminal category that originated the subparse and so com-
plete the subparse. If there is no match, it will become the
left-corner of a phrase that will eventually match the originat-
ing category.
The parser includes a Reachability Matrix (Griffiths &amp;
Petrick, 1965) to provide top-down filtering of rule selection.
The tnntrix indicates when a category A can have a category B
as a left-most descendant in a parse tree. The matrix is static
and can be derived from the grammar in advance of any pars-
ing. It is computable as the transitive closure under multiplica-
tion of the boolean matrix of left daughters of non-terminal
categories in the grammar. It is used as a further constraint on
rule selection. For example, when the goal is to construct a
sentence and the category of the rust word of input is e, then
rule selection, giving X — will also be constrained to have
the property S * X — The filtering is applicable whenever a
rule is selected: during subparses the constraint is to reach the
category originating the subparse.
A semantic grammar formalism is used in ENGLISH,
which make the grammar application dependent. As was men-
tioned earlier, this format was independently chosen as part of
the knowledge engineering methodology for describing the
application domain. The rationale for the choice for
INGLISH was that the simultaneous syntactic and semantic
checking assists in achieving real-time processing. A fragment
of the grammar is shown in Figure 1.
Pre-processing on the grammar constructs the terminal
and non-terminal vocabularies of the grammar, the teachability
matrix, and an inverse dictionary. The set of all possible initial
words and phrases for sentences can also be precomputed.
The Smalltalk system contains controllers that manage
activity on a variety of input devices and from these a con-
troller was readily constructed&apos; to coordinate mouse and key-
</bodyText>
<listItem confidence="0.585382428571429">
• Smalltalk is an object-oriented language. Instead of
creating a procedure that controls system operation, the
user creates an object (usually a data structure), and a
set of methods (operations that transform, and commun-
icate with the object). Smalltalk programs create objects
or send messages to other objects. Once received, mes-
sages result in the execution of a method.
</listItem>
<bodyText confidence="0.994506714285715">
Programmers do not create each object and its
methods individually. Instead, classes of objects are de-
board activity in INGLISH. Either form of entry increments
an intermediate buffer which is inspected by the parser. When
a complete word is found in the buffer it is parsed.
Every phrase in an on-going analysis is contained in a
Smalltalk object. The final parse is a tree of objects. The
intermediate state of a parse is represented by a set of objects
containing partially instantiated phrases. After the rust word
has established an initial set of phrase objects, they are polled
by the parser for their next segments. From these and the
reverse dictionary, a &amp;quot;lookahead dictionary&amp;quot; is established that
associates expected words with the phrasal objects that would
accept them. Using this dictionary an incoming word will only
be sent to those objects that will accept it. If the word in not
in the set of expected words, the dictionary keys are used to
attempt spelling correction and, if correction fails, to make the
menu to be displayed. If the dictionary contains only a single
word, this indicates that automatic phrase completion should
take place. A new lookahead dictionary is then formed from
the updated phrase objects, and so on.
</bodyText>
<sectionHeader confidence="0.959602" genericHeader="method">
KNOWLEDGE TRANSLATION
</sectionHeader>
<bodyText confidence="0.9964245">
The internal form of a diagnostic rule is a clause in Pro-
log. Sentences are translated using functional schemata, as in
lexical-functional grammar. The functional schemata are
attached to the phrase structure rules of GLIB (Figure 2).
</bodyText>
<figure confidence="0.951509777777778">
FORM)...rulo(t COND FORM), (.04CL FORMD&gt;
COND)m• C.CNCL).•
&lt;rule&gt; —&gt; IF &lt;condition&gt; THEN &lt;conclusion&gt;
FORM)...caors((, DID). STATED&gt;
(r 1740)... (&apos;STAT!)-.
&lt;condition&gt; —› &lt;indicator&gt; IS &lt;stag&gt;
Foaso—cgouct oar, swap.
onv)-s
&lt;conclusion&gt;--&gt; &lt;device&gt; HAS FAILED
</figure>
<figureCaption confidence="0.999803">
Figure 2: GLIB rules with attached schemata
</figureCaption>
<bodyText confidence="0.99922875">
Unlike lexical-functional grammar, the schemata do not set up
constraint equations as the interface and the semantic grammar
ensure the well-formedness and unambiguity of the sentence.
As a result, propagation of functional structure is handled very
quickly in a post-processing step since the applicable grammati-
cal rules have already been chosen by the parsing process.
Further, by restricting the input to strictly prescribed sub-
language GLIB, not English in general, the translation process
is simplified.
fined. A class definition describes an object and the
methods that it understands. Classes are structured
hierarchically, and any clam automatically inherits
methods from its superclass.
As a result of this hierarchy and code inheritance,
applications may be written by adapting previously con-
structed code to the task at hand. Much of the applica-
tion code can be inherited from previously defined
Smalltalk code. The programmer need only redefine
differences by overriding the inappropriate code with
customized code. (Alexander &amp; Freiling, 1985).
</bodyText>
<page confidence="0.990319">
257
</page>
<bodyText confidence="0.967288935483871">
The parser constructs a parse tree with attached sche-
mata, referred to as a constituent-structure, or c-structure.
Translation proceeds by instantiating the meta-variables of the
schemata of the c-structure created by 1NGLISH to form func-
tional equations which are solved to produce a functional struc-
ture (f-structure). The final rule form is obtained from the f-
structure of the sentence when its sub-structures are recursively
transformed according to the contents of each &amp;structure.
As an example, given the lexical-functional form of the
semantic grammar in Figure 2 and the following sentence:
IF LED-2 IS ON THEN TRANSISTOR-17 HAS FAILED
the c-structure in Figure 3 would be produced. This shows
that a rule has a condition part, COND, and a conclusion pan,
CNCL, that should become a clausal-form &amp;quot;rule(COND,
CNCL).&amp;quot; The meta-symbol t refers to the parent node and t
to the node to which the schema is attached.
The final phase of INKA interprets the &amp;structures to
produce Prolog clauses. All of the information required to
produce the clauses is contained in the FORM property in this
example. The FORM property is printed, with all variables
instantiated, to produce the final rule in the form of a Prolog
clause. The &amp;structure of Figure 4 produces the Prolog clause
rule(state(led-2, on), status(transistor-17, failed)
KNOWLEDGE USE
Translated rules are sent to a diagnostic engine that has
been implemented in Prolog. The diagnostic engine uses
GLIB statements about the hierarchical structure of the device
to build a strategy for successive localization of failurcs. Start-
ing at the highest level (&amp;quot;the circuit&amp;quot; in GLIB terminology),
named sub-circuits are examined in turn, and diagnostic rules
retrieved to determine correctness or failure of the sub-circuit
</bodyText>
<figureCaption confidence="0.997227">
Figure 3: C-structure
</figureCaption>
<figure confidence="0.991337272727273">
&lt;rule&gt;
FOR11)..esoK0 On*
0 STATED:.
STATE)-.
&lt;indicator&gt; IS &lt;state&gt;
I
LED-2 ON
ratit)■&lt;sis.0 DEVL tald)›.
DeIV).
&lt;device&gt; HAS FAILED
TRANSISTOR-17
</figure>
<bodyText confidence="0.99971">
The functional specifications of the example may be
solved by instantiating the meta-symbols with actual nodes and
assigning properties and values to the nodes according to the
specifications. In the example given, most specifications are of
the form &amp;quot;(t property)=value&amp;quot; where &amp;quot;value&amp;quot; is most often 1.
This form indicates that the node graphically indicated by in
the c-structure is the specified property of the parent node
(pointed to by t). Specifications are left-associative and have a
functional semantic interpretation. A specification of (t
COND FORM) refers to the FORM property of the parent
node&apos;s COND property. The &amp;structure for the example is
given in Figure 4.
in question. If no specific determination can be made, the
sub-circuit is assumed to be functioning properly.
A sample setaion including acquisition of a rule and run-
ning of a test diagnosis is shown in Figure 5. The circuit used
in this example consists of an oscillator which drives a light
emitting diode (LED-2 in the schematic) and a power supply
(LED-1 indicates when the power supply is on). The
schematic diagram of the circuit is in the upper pane of the
&amp;quot;Instrument Data&amp;quot; window; the circuit board layout is in the
lower pane. Rules for diagnosing problems in the circuit
</bodyText>
<figure confidence="0.850714833333333">
IND led-2
CONDI STATE on
I FORM &lt;state((t IND FORM), (t STATE FORM))&gt;
CNCL I DEV transistor-17
I. FORM &lt;status(((t DEV), failed)&gt;
FORM &lt;rule((t COND), CNCL))&gt;
</figure>
<figureCaption confidence="0.884333">
Figure 4: F-structure
</figureCaption>
<table confidence="0.913481294117647">
INGUSHI
GUS Knowledge Acquisition Entry
IF NODE 4 VOLTAGE IS EQUAL TO NODE 5 VOLTAGE THEN RESISTOR 2 HAS FAILED. **PARSED
rule(comp(eq,voltage(node(4)),voltage(nods(5))),status(component(resistor(2)),failed),.).
IF POWER SUF&apos;PLY 1. AMFUl UDE (01)
CAPACITANCE (#2)
CURRENT (03)
FREQUENCY (04)
HAS FAILED (05)
IMPEDANCE (06)
IS (#71
)
PHASE (#10)
POWER (#11)
RESISTANCE (#12)
VOLTAGE (#13)
&amp;quot;ABORT (#141
</table>
<figure confidence="0.998365128205128">
Instrument
NODE-
RECTIFIER-1
NODE-4
NODE -5
C4
CO0001311:1100Cle
MCCICC11312:1 El CC
MCOCCICEI ord
▪ 12 0
aIIIII.0012CCICOCI
CEICIE:100C 11111 CU= C :3 0 112C
1:1 CI C 0 0 • _3 C 0 0 0 CI C C C
CCOCCCICit r1 fr., 0 rl
CICEICtICEI C 7;77. 711 MCC a
0 CI CI CI 12 0 CI
O 0 0 0 0 El 0
C10000013
mioirtriPrin
1131:1 C CI 0 0 CIE
&amp;quot;&amp;quot; 130C1 0 El
EMI 1313C
CI CI 0 C
COCICE
OCCCIL
aacar
aanaL
a an 0 COCCE
1:1 0 0 0 0 113 C CI E
COO C C C C CI CI C
nnoommmenonnumnommr
Prolog
Is led number 2 not flashing? yes
What is the voltage of node number 21 15
Is led number 1 dim? no
Is It true that the voltage of node number 4 is equal to the
voltage of node number 5? yes
Oscillator number 1 is failing.
Resistor number 2 is failing.
</figure>
<figureCaption confidence="0.999166">
Figure 5: An INKA session
</figureCaption>
<bodyText confidence="0.999677368421052">
(&amp;quot;troubleshooting&amp;quot; rules) are added to the system in the win-
dow labeled &amp;quot;INGLISH.&amp;quot; The interface to the diagnostic
engine is in the &amp;quot;Proiog&amp;quot; window. The &amp;quot;INC LISII&amp;quot; window
shows a recently added rule, with its Prolog translation
immediately below it. It also shows a partially completed rule
along with a menu of acceptable sentence continuations. The
user may select one of the menu items (either a word or
phrase) to be appendcd to the current sentence. The &apos;Prolog&amp;quot;
window displays the results of a recent test diagnosis. This test
was run after the first rule in the &amp;quot;INGLISH&amp;quot; window was
added, but before the addition of the second rule was begun.
The last question asked during the diagnosis corresponds to the
rust rule. Resistor 2, in both the schematic and board
diagrams of the &amp;quot;Instrument Data&amp;quot; window, is highlighted as a
result of running the diagnosis: whenever the diagnostic engine
selects a specific component for consideration that component
is highlighted on the display. Some 20 statements and rules
have been collected or diagnosing the circuit; Figure 6 lists a
portion of them with their Prolog translation.
</bodyText>
<page confidence="0.997167">
259
</page>
<reference confidence="0.9196130625">
THE CIRCUIT CONTAINS OSCILLATOR-1 AND POWERSUPPLY-1.
has_component(block(circuit), block(oscifiator(1))).
has.component(block(circuit), block(powersupply(1))).
RESISTOR-1 IS PART OF OSCILLATOR-1.
has_component(block(oscillator(1)), component(resistor(1))).
IF LED-2 IS NOT FLASHING AND THE VOLTAGE OF NODE-2 IS EQUAL
TO 15 VOLTS THEN OSCILLATOR-1 HAS FAILED.
rule(and(not(state(led(2), flashing))),
comp(voltage(node(2)), 15)),
status(block(oscillator(1)), failed),
[1)-
IF LED-1 IS DIM AND LED-2 IS OFF THEN RESISTOR-1 HAS FAILED.
rule(and(state(led(1), dim),
state(led(2), off)),
status(component(resistor(1)), failed),
0).
</reference>
<figureCaption confidence="0.971225">
Figure 6: GLIB rules with Prolog translations
</figureCaption>
<sectionHeader confidence="0.997419" genericHeader="discussions">
DISCUSSION
</sectionHeader>
<bodyText confidence="0.999983909090909">
Informal observations show that subjects generally need
only a few minutes of instruction to start using INGLISH. Ini-
tially there is a preference to use the mouse to explore the cov-
erage and then to begin to incorporate some typing. We have
not had any long-term users to observe their trends.
Users could react negatively to limited language systems;
even when the coverage is well-engineered users will occasion-
ally encounter the boundaries. Fortunately, Hendler ft
Michaelis (1983) found that subjects were able to adapt to lim-
ited language systems.
ENGLISH does not let the designer off the hook! A user
can still have a statement in mind and not easily find a way to
express it through the grammar. Diligent engineering is still
needed to prepare a grammar that will allow a user to be
guided to a paraphrase of his original thought. Nevertheless,
the grammar design problem is simplified: when guidance is
provided fewer paraphrases need be incorporated.
The use of a semantic grammar to define the fragment of
English to be processed does impose limitations on the com-
plexity of acceptable input. In the INICA system as it is
currently constructed, however, there are two distinct ways in
which the semantic correctness of an input can be enforced,
first in the parsing of the of the semantically constrained
grammar, and second in the translation process, as the func-
tional structures are built.
In short, the our approach to building practical natural
language interfaces does not depend on a semantic grammar to
constrain input. In the future we intend to explore the use of
a wider class of grammars that include a domain-independent
kernel and a domain-specific component, like GLIB. In this
approach we are in substantial agreement with Winograd
(1984) who advocates a similar approach as an effective direc-
tion for further natural language research.
</bodyText>
<sectionHeader confidence="0.999577" genericHeader="references">
REFERENCES
</sectionHeader>
<reference confidence="0.999177470588235">
Alexander, J.H., &amp; Freiling, MJ. Building an Expert System
in Smalltalk-80 (R). Systems and Software, 1985, 4, 111-118,
Alexander, J.H., Freiling, MJ., Messick, S.L., &amp; Rehfuss, S.
Efficient Expert System Development Through Domain-
Specific Tools. Proceedings of the Fifth International Workshop
on Expert Systems and their Applications, Avignon, France,
1985.
Burton, R.R. Semantic Grammar: An Engineering Technique for
Constructing Natural Language Understanding Systems (Techni-
cal Report No. 3453). Cambridge, MA: Bolt, Beranek, 8c
Newman Inc., 1976.
Carbonell, J.G., St Hayes, PJ. Recovery Strategies for Pars-
ing Extragrammatical Language. American Journal of Computa-
tional Linguistics, 1983, 3-4, 123.146.
Davis, R. Interactive Transfer of Expertise: Acquisition of
New Inference Rules. Proceedings of the Fifth International
Joint Conference on Artificial Intelligence. Cambridge, MA,
1977, 321-328.
[DEC] TOPS-20 Reference Manual. Maynard, MA: Digital
Equipment Corporation, 1971.
Freiling, MJ., ek Alexander, J.H. Diagrams and Grammars:
Tools for the Mass Production of Expert Systems. IEEE First
Conference on Artificial Intelligence Applications. Denver,
Colorado, 1984.
Freiling, M., Alexander, .1., Feucht, D., &amp; Stubbs, D. GLIB —
A Language for Representing the Behavior of Electronic Devices
(Technical Report CR-84-12). Beaverton, OR: Tektronix,
Inc., 1984.
Gilled, D.M. Warming up to Computers: A Study of Cogni-
tive and Affective Interaction over Time. Proceedings of the
Human Factors in Computer Systems Conference, Gaithersburg,
MD, 1982, 245-250.
Goldberg, A. &amp; Robson, D. Snialltalk 80: The Language and
its Implementation. Reading, MA: Addison-Wesley, 1983.
</reference>
<page confidence="0.951599">
260
</page>
<reference confidence="0.999495878787879">
Griffiths, T., &amp; Petrick, S.R. &apos;On the relative efficiency of
context-free grammar recognizers.&apos; Comm. ACM, 1965, 8,
289-300.
Headier, JA., &amp; Michaelis, P.R. The Effects of Limited
Grammar on Interactive Natural Language. Proceedings of the
Human Factors in Computer Systems Conference, Boston, MA,
1983, 190492.
Kaplan, R.M., &amp; Bresnan, J.W. Lexical-Functional Grammar
A Formal System for Grammatical Representation. In J.
Breman (Ed.), The Mental Representation of Grammatical Rela-
tions. Cambridge, MA: MIT Press, 1982.
McKeown, K.R. Natural Language for Expert Systems: Com-
parison with database systems. Proceedings of the International
Conference on Computational Linguistics, Stanford, CA, 1984,
190-193.
Phillips, B. An Object-oriented Parser. In B.G. Barn &amp; G.
Guida (Eds.), Computational Models of Natural language Pro-
cessing. Amsterdam: North-Holland, 1984.
Phillips, B., &amp; NichoU, S. INGLISH: A Natural Language Inter-
face (Technical Report CR-84-27). Beaverton, OR: Tek-
tronix, Inc., 1984.
Tennant, H.R. Evaluation of Natural Language Processors
(Technical Report T-103). Coordinated Science Laboratory,
University of Illinois, Urbana, IL, 1980.
Tennant, H.R., Ross, K.M., &amp; Thompson, C.W. Usable
Natural Language Interfaces Through Menu-Based Natural
Language Understanding. Proceedings of the Human Factors in
Computer systems Conference, Boston, MA, 1983, 190-192.
Winograd, T. Moving the Semantic Fulcrum (Technical Report
84-17). Center for the Study of Language and Information,
Stanford, CA, 1984.
[Xerox] Interlisp Reference Manual. Palo Alto, CA: Xerox
Palo Alto Research Center, 1983.
</reference>
<page confidence="0.99783">
261
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.888068">
<title confidence="0.998505">AN ECLECTIC APPROACH TO BUILDING NATURAL LANGUAGE INTERFACES</title>
<author confidence="0.995189">Michael I Freiling</author>
<author confidence="0.995189">James Alexander</author>
<author confidence="0.995189">Steven L Messick</author>
<author confidence="0.995189">Steve Rehfuss</author>
<author confidence="0.995189">Sheldon Nichollt</author>
<affiliation confidence="0.938126">Tektronix, Inc.</affiliation>
<address confidence="0.9993295">P.O. Box 500, M/S 50-662 Beaverton, OR 97077</address>
<abstract confidence="0.996798">INKA is a natural language interface to facilitate knowledge acquisition during expert system development for electronic instrument trouble-shooting. The expert system design methodology develops a domain definition, called GLIB, in the form of a semantic grammar. This grammar format enables GLIB to be used with the INGLISH interface, which constrains users to create statements within a subset of English. Incremental parsing in 1NGLISH allows immediate remedial information to be generated if a user deviates from the sublanguage. Sentences are translated into production rules using the methodology of lexical-functional grammar. The system is written in Smalltalk and, in INKA, produces rules for a Prolog inference engine.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<booktitle>THE CIRCUIT CONTAINS OSCILLATOR-1 AND POWERSUPPLY-1. has_component(block(circuit), block(oscifiator(1))). has.component(block(circuit), block(powersupply(1))). RESISTOR-1 IS PART OF OSCILLATOR-1. has_component(block(oscillator(1)), component(resistor(1))). IF LED-2 IS NOT FLASHING AND THE VOLTAGE OF NODE-2 IS EQUAL TO 15 VOLTS THEN OSCILLATOR-1 HAS FAILED. rule(and(not(state(led(2), flashing))), comp(voltage(node(2)), 15)), status(block(oscillator(1)), failed), [1)-IF LED-1 IS DIM AND LED-2 IS OFF THEN RESISTOR-1 HAS FAILED. rule(and(state(led(1), dim), state(led(2), off)), status(component(resistor(1)),</booktitle>
<volume>0</volume>
<marker></marker>
<rawString>THE CIRCUIT CONTAINS OSCILLATOR-1 AND POWERSUPPLY-1. has_component(block(circuit), block(oscifiator(1))). has.component(block(circuit), block(powersupply(1))). RESISTOR-1 IS PART OF OSCILLATOR-1. has_component(block(oscillator(1)), component(resistor(1))). IF LED-2 IS NOT FLASHING AND THE VOLTAGE OF NODE-2 IS EQUAL TO 15 VOLTS THEN OSCILLATOR-1 HAS FAILED. rule(and(not(state(led(2), flashing))), comp(voltage(node(2)), 15)), status(block(oscillator(1)), failed), [1)-IF LED-1 IS DIM AND LED-2 IS OFF THEN RESISTOR-1 HAS FAILED. rule(and(state(led(1), dim), state(led(2), off)), status(component(resistor(1)), failed), 0).</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>