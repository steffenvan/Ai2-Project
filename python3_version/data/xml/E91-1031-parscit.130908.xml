<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000002">
<title confidence="0.997752">
Prediction in Chart Parsing Algorithms for
Categorial Unification Grammar
</title>
<author confidence="0.977285">
Gosse Bouma
</author>
<affiliation confidence="0.9472565">
Computational Linguistics Department
University of Groningen, P.O. box 716
</affiliation>
<address confidence="0.516636">
NL-9700 AS Groningen, The Netherlands
</address>
<email confidence="0.669343">
e-mail:gosse©let.rug.n1
</email>
<sectionHeader confidence="0.938928" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999743090909091">
Natural language systems based on Categorial Unifica-
tion Grammar (CUG) have mainly employed bottom-
up parsing algorithms for processing. Conventional
prediction techniques to improve the efficiency of the
parsing process, appear to fall short when parsing CUG.
Nevertheless, prediction seems necessary when parsing
grammars with highly ambiguous lexicons or with non-
canonical categorial rules. In this paper we present a
lexicalist prediction technique for CUG and show that
this may lead to considerable gains in efficiency for both
bottom-up and top-down parsing.
</bodyText>
<sectionHeader confidence="0.947987" genericHeader="keywords">
1 Preliminaries
</sectionHeader>
<bodyText confidence="0.990897428571429">
CATEGORIAL UNIFICATION GRAMMAR. Unification-
based versions of Categorial Grammar, known as CUG
or UCG, have attracted considerable attention recently
(see, for instance, Uszkoreit, 1986, Karttunen, 1986,
Bouma, 1988, Bouma et al., 1988, and Calder et al.,
1988). The categories of Categorial Grammar (CG)
can be encoded easily as feature-structures, in which
the attribute &lt; cat &gt; dominates either an atomic value
(in case of an atomic category) or a structure with at-
tributes &lt; v al &gt;, &lt; dir &gt; and &lt; arg &gt; (in case of
a complex category). Morphosyntactic information can
be added by introducing additional labels. An example
of such a category represented as attribute-value matrix
is presented below.
</bodyText>
<construct confidence="0.808922428571429">
N P[-f-nom]l N [-Fnom , -Fsg] =
val : { cat : np
case : nom
dir: right
cat : [cat : n
arg: case : nom
num : sg
</construct>
<bodyText confidence="0.99492025">
The combinatory rules of classical CG, A — AIB B
(rightward application) and A B B\A (leftward ap-
plication), can be encoded as highly schematic rewrite
rules associated with an attribute-value graph:
</bodyText>
<sectionHeader confidence="0.614223" genericHeader="introduction">
Rightward Application Rule:
</sectionHeader>
<equation confidence="0.992213166666667">
X0 --* xi x2
[ X0:&lt; 1&gt;
X1 : [cat :
X2 :&lt; 2&gt;
Leftward Application Rule:
)co -_+x1 x2
X0 :&lt; 1&gt;
X1 :&lt; 2&gt;
[[ val :&lt; 1 &gt;
cat :I I
X2 : dir : left
arg :&lt; 2&gt;
</equation>
<bodyText confidence="0.999617">
CUG is a lexicalist theory: language specific in-
formation about word order, subcategorization, agree-
ment, case-assignment, etc., is stored primarily in the
lexicon. Whereas in classical CG functor-argument
structure is the only means available for describing ling-
uistic phenomena, in CUG additional features may be
used to account for phenomena such as agreement and
case-marking (see Bouma 1988). Also, whereas in clas-
sical CG all rules are in principle universal (i.e. not
language-specific), in CUG there is a tendency to sup-
plement generic categorial rules with language or con-
struction specific rules For instance, a rule
</bodyText>
<equation confidence="0.672838">
NP --+ N [-Fplu]
</equation>
<bodyText confidence="0.971061">
may be added to account for the occurence of bare
plural NPs, and specific rules may be added to ac-
count for unbounded dependency constructions (Bouma
</bodyText>
<equation confidence="0.9940925">
val :&lt; 1 &gt;
dir: rig ht
arg :&lt; 2 &gt;
- 179 -
</equation>
<bodyText confidence="0.997760857142857">
1987). Finally, instead of fully instantiated category-
structures, one may choose to work with polymorphic
categories (Karttunen 1989, Zeevat et al. 1987). Con-
sequently, CUG not only shows resemblances with tra-
ditional categorial grammar, but also with Head-driven
Phrase Structure Grammar (Pollard St Sag, 1987), an-
other lexicalist and unification-based framework.
</bodyText>
<sectionHeader confidence="0.765675" genericHeader="method">
CHART PARSING OF UNIFICATION GRAMMAR
</sectionHeader>
<bodyText confidence="0.977091375">
(UG). Parsing methods for context-free grammar can
be extended to unification-based grammar formalisms
(see Shieber, 1985 or Haas, 1989), and therefore they
can in principle be used to parse CUG. A chart-parser
scans a sentence from left to right, while entering
items, representing (partial) derivations, in a chart.
Assume that items are represented as Prolog terms
of the form item(Begin, End, LH S,Parsed,ToParse),
where LHS is a feature-structure and Parsed
and ToParse contain lists of feature-structures.
An itern(0 , 1, [S], [NP], [V, NP]) represents a partial
derivation ranging from position 0 to 1 of a constituent
with feature-structure S, of which a daughter NP has
been found and of which daughters V and NP are
still to be parsed. A word with lexical entry Word :
Cat at position Begin, leads to addition of an item
</bodyText>
<construct confidence="0.854595857142857">
item(Begin, Begin + 1,Cat,[W ord],[ ]). Next, com-
pletion and prediction steps are called until no further
items can be added to the chart.
Completion step: 1 For each item(B, E, LHS,
Parsed, [NextIToParse]) and item(E, End, Next,
Parsed, [D, add an itern(B, End, LHS,
Parsed+ Next, ToParse).
</construct>
<subsectionHeader confidence="0.38964">
Bottom-up Prediction step: For each item(B, E,
</subsectionHeader>
<bodyText confidence="0.75330275">
Next, Parsed, []), and each rule (LHS [Next I
RHS]), add item(B, E, LHS, [Next], RHS).
The prediction step causes the algorithm to work
bottom-up.
</bodyText>
<sectionHeader confidence="0.983484" genericHeader="method">
2 The Problem
</sectionHeader>
<bodyText confidence="0.994509538461538">
In a bottom-up chart parser, applicable rules are pre-
dicted bottom-up, and thus, lexical information is used
to constrain the addition of active items (i.e. items
representing partial derivations). At first sight, this
method appears to be ideal for CUG, as in CUG
the lexical items contain syntactic information which
is language and grammar specific, whereas the rules
are generic in nature. Note, however, that although
, &apos;In these and following definitions, we assume, unless other-
wise indicated, that feature-structures denoted by identical prolog
variables are unified by means of feature-unification.
bottom-up parsing is certainly attractive for CUG,
there are also a number of potential inefficiencies:
</bodyText>
<listItem confidence="0.97979904">
• In many cases useless items will be predicted.
Consider, for instance, a grammar with a lexi-
con containing only the categories NPIN,N, and
N P\S, and with application as the only combina-
tory rules. When encountering a determiner, pre-
diction of an itern(i, i, X, [iip/n), [(np/n)\X]) is
superfluous, since there is simply no way that the
grammar could ever produce a category (np/n)\ X
2.
• If the lexicon is highly ambiguous, many useless
(partial) derivations may take place. Consider,
for instance, the syntax of NPs in German, where
determiners and adjectives are ambiguous with
respect to case, declension pattern, gender and
number (see Zwicky, 1986, for an analysis in terms
of GPSG). The sentence die junge Frau schldft has
only one derivation, but a bottom-up parser has to
consider 11 possible analyses for the word junge,
6 for the phrase junge Frau, 4 for die and 2 for
die junge Frau. This example shows that even in
a pure categorial system, there may be situations
where top-down prediction has its merits.
• If the grammar contains language or construction
specific rules, bottom-up prediction may be less
efficient. Relevant examples are the rule for form-
</listItem>
<bodyText confidence="0.8946175">
ing bare plurals mentioned in the previous section
and rules which implement a categorial version of
gap-threading (see Pereira Si Shieber, 1986 : 119
if). The rule shemata below allow for the deriva-
tion of sentences with a preposed element and for
the extraction of arguments:
</bodyText>
<equation confidence="0.715977">
Gap-elimination: S X S[gap : X]
Gap-introduction: X[gap :Y] — X IY
X[gap : Y] Y\X
</equation>
<bodyText confidence="0.772588909090909">
Gap-introduction will be used every time a func-
tor category is encountered. Again, some form of
top-down prediction could improve this situation.
In the following sections, we will consider top-down
parsing, as an alternative for the bottom-up approach,
and we will consider the possibility of improving the
predictive capabilities of a bottom-up parser.
2The example may suggest that prediction should be elimi-
nated all together. This option is feasible only if the rule set is
restricted to application.
- 180 -
</bodyText>
<sectionHeader confidence="0.968758" genericHeader="method">
3 Top-down Parsing
</sectionHeader>
<bodyText confidence="0.987388">
Top-down chart parsing differs from the algorithm de-
scribed above only in the prediction-step, which pre-
dicts applicable rules top-down. Contrary to bottom-
up parsing, however, the adaptation of a top-down al-
gorithm for UG requires some special care. For UGs
which lack a so-called context-free back-bone, such as
CUG, the top-down prediction step can only be guar-
anteed to terminate if we make use of restriction, as
defined in Shieber (1985).
Top-down prediction with a restrictor R (where R
is a (finite) set of paths through a feature-structure)
amounts to the following:
Restriction The restriction of a feature-structure F
relative to a restrictor R is the most specific
feature-structure F&apos; E F, such that every path
in F&apos; has either an atomic value or is an element
of R.
Predictor Step For each item(_ , End, LHS, Parsed,
[Next I ToParse]) such that RNext is the re-
striction of Next relative to R, and each rule
RNext —4 RHS, add ifern(i,i, RNC, RHS).
Restriction can be used to develop a top-down chart
parser for CUG in which the (top-down) prediction step
terminates. The result is unsatisfactory, however, for
the following two reasons. First, as a consequence of
the generic and language independent nature of cate-
gorial rules, the role of top-down prediction as a con-
straint on possible derivation steps is lost completely.
Second, many useless items will be predicted due to
the fact that the LHS of both rightward and leftward
application always match with RNexg in the prediction
step (note that a bottom-up parser has a similar inef-
ficiency for leftward application only). Therefore, the
overhead which is introduced by top-down prediction
does not pay-off. We conclude that, eventhough the in-
troduction of restriction make it possible to parse CUG
top-down, in practice, such a method has no advantages
over a bottom-up approach.
</bodyText>
<sectionHeader confidence="0.991764" genericHeader="method">
4 Lexicalist Prediction
</sectionHeader>
<bodyText confidence="0.999936090909091">
Instead of customizing existing top-down parsing algo-
rithms for CUG, we can also try to take the opposite
track. That is, we will try to represent a CUG in such
a way that non-trivial forms of top-down prediction are
possible.
Top-down prediction, as described in the previous
section, relies wholly on the syntactic information en-
coded in the syntactic rules. For CUG, this is an akward
situation, as most syntactic information which could be
relevant for top-down prediction is located in the lexi-
con. In order to make this information accessible to the
parser, we precompile the grammatical rules into a set
of instantiated rules. The instantiated rules are more re-
strictive than the generic categorial rules, as they take
lexical information into account.
The following algorithm computes a set of instanti-
ated syntactic rules, given a set of generic rules and a
lexicon.
Compilation For every category C, where C is either
a lexical category or the LIIS of an instantiated
rule, and every (generic) rule CR, if C is unifiable
with the head-daughter of GR, add CR&apos; (the re-
sult of the unification) to the set of instantiated
rules. 3
We assume that there is some way of distinguishing
head-daughters from non-head daughters (for instance,
by means of a feature). The head daughter should he
the daughter which has the most influence on the in-
stantiation of the rule. For the application rules, for
instance, the functor is the most natural choice, as the
functor both determines the instantiation of the resul-
tant category and of the argument category.
The compilation step is correct and complete for
arbitrary UGs, that is, a string is derivable using the
instantiated rules if and only if it is derivable using
the generic rules. Note, however, that the compila-
tion procedure does not necessarily terminate. Con-
sider for instance a categorial grammar with category
raising (XI(Y\X)--.Y). In such a grammar, arbitrar-
ily complex instantiations of this rule can be compiled.
To avoid the creation of an infinite set of rules, we may
again employ restriction:
Compilation with restriction Let R be a restrictor.
For every category C, where C is either a lexical
category or the LHS of art instantiated rule, and
every (generic) rule GR, if the restriction of C
relative to R is unifiable with the head-daughter
of GR, add GR&apos; (the result of the unification) to
the set of instantiated rules.
The compilation step is guaranteed to terminate as
long as R is finite (cf. Shieber, 1985). The compi-
lation procedure is not specific to a certain grammar
formalism or rule set, and thus can be used to compile
arbitrary UGs. Such a compilation step will give rise
to a substantially more instantiated rule set in all cases
</bodyText>
<footnote confidence="0.629509666666667">
3Note that for classical CG, an algorithm of this kind can
be used to compute the phrase-structure equivalent of the input
grammar.
</footnote>
<page confidence="0.932421">
181 -
</page>
<bodyText confidence="0.99994425925926">
where schematic grammar rules are used in combination
with highly structured lexical items.
For the compiled grammar, a standard top-down al-
gorithm (such as the one in section 3) can be used. Pre-
diction for CUG is now significant, as only rules which
have a functor category that is actually derivable by the
grammar will be predicted. So, starting from a category
S, we will not predict leftmost categories such as SINP,
(SINP)INP, if no such categories can be derived from
the lexical categories. Also, a leftmost argument cate-
gory A will only be predicted if the grammar contains
a matching functor category A\S. Finally, since we are
working with the instantiated rules, morphosyntactic
information can effectively be predicted top-down.
Restriction is not only useful to guarantee termi-
nation of the compilation procedure. The precompi-
lation procedure can in principle lead to an instanti-
ated grammar that is considerably larger than the input
grammar. For instance, given a grammar which distin-
guishes between plural and singular and between first,
second and third person NPs, six versions of the rule
S NP NP\S might be derivable. Such a multipli-
cation is unnecessary, however, as it does not provide
any information which is useful for the top-down pre-
diction step. Choosing a restrictor which filters out all
distinctions that are irrelevant to top-down prediction,
can prevent an explosion of the rule set.
</bodyText>
<sectionHeader confidence="0.993884" genericHeader="method">
5 Bottom-Up Parsing with Pre-
diction
</sectionHeader>
<bodyText confidence="0.999816317073171">
The compilation procedure described in section 4 was
developed to improve the performance of top-down
parsing-algorithms for lexicalist grammars of the CUG-
variety. In this section, we argue that replacing a
generic CUG with its instantiated. equivalent also has
advantages for bottom-up parsing. There are two rea-
sons to believe that this is so: first, predictions based on
leftward application will be less frequent and second, to
an instantiated grammar non-trivial forms of top-down
prediction can be added.
In section 2 we pointed out that a bottom-up parser
will predict many useless instances of leftward applica-
tion. This is due to the fact that the leftmost daughter
of leftward application is completely general and thus,
given an item(&apos;B, E, Cat,Parsed,(]), an item(B,E, X,
[Cat], [Cat\X]) will always be predicted. The compi-
lation procedure presented in the previous section re-
places leftward application with instantiated versions
of this rule, in which the leftmost argument of the rule
is instantiated. Although the instantiated rule set of a
grammar is bound to be larger than the original rule
set, which is a potential disadvantage, the chart will
grow less fast if we use the instantiated grammar. It is
therefore worthwhile to investigate the performance of
a bottom-up parser which uses a compiled grammar as
opposed to a bottom-up parser working with a generic
rule set.
There is a second reason for considering instan-
tiated grammars. It is possible in bottom-up pars-
ing to speed up the parsing process by adding top-
down prediction. Top-down prediction is implemented
with the help of a table containing items of the
form le ft _corner(Ancestor, Le f tCorner), which lists
the left-corner relation for the grammar at hand. The
left-corner relation is defined as follows:
Left-corner Category C1 is a left-corner of an ancestor
category A if there is a rule A —0 C1.. ..C,,. The
relation is transitive: if A is a left-corner of B and
B a left-corner of C, A is a left-corner of C.
Top-down filtering is now achieved by modifying the
prediction step as follows :
</bodyText>
<subsectionHeader confidence="0.6708045">
Bottom-up Prediction with Top-down Filtering:
For each item(B, E, Cat, Parsed, g), and each
</subsectionHeader>
<bodyText confidence="0.954467095238095">
rule (X0 [Cat I RHS]), such that there is an
item(_, B, INextiToParseD with X0 a left-
corner of Next, add item(B, E, X0, Iraq, RHS)4.
For CUG it makes little sense to compute a left-
corner relation according to this definition, since any
category X is a left-corner of any category Y (accord-
ing to leftward application), and thus the left-corner
relation can never have any predictive power.
For an instantiated grammar, the situation is more
promising. For instance, given the fact that only nom-
inative NPs occur as left-corner of S, and that every
determiner which is the left-corner of NP, has a case
feature which is compatible (unifiable) with that NP, it
can be concluded that only nominative determiners can
be left-corners of S.
Computing the left-corner relation mechanichally
for a UG will not always lead to the most economic-
al representation of the left-corner table. For exam-
ple, in German the left-corner of an NP with case and
number features X will be a determiner with identi-
cal features. If we compute this, using a sufficiently
</bodyText>
<footnote confidence="0.572520875">
4The bottom-up parsing algorithm extended with left-corner
prediction is closely related to the B UP-parser of Matsumoto et
al. (1983). The BUP-parser is based on definite clause grammar
and thus, may backtrack. Minimal use is made of a chart (in
which successful and failed parse attempts are stored). Our algo-
rithm assigns a more important role to the chart and thus avoids
backtracking.
- 182-
</footnote>
<bodyText confidence="0.999979571428571">
instantiated grammar, we get 8 versions (i.e. 4 cases
times 2 possible values for number) of this relation.
Similar observations can be made for adjectives that
are left-corners of N (where things are even worse, as
we would like to take declension classes into account
as well). This multiplication may lead to a needlessly
large left-corner table, which, if used in the prediction
step, may in fact lead to sharp decreases in parsing per-
formance (see also Haas, 1989, who encountered sim-
ilar problems). Note that checking a left-corner table
containing feature-structures is in general expensive, as
unification, rather than identity-tests, have to be car-
ried out.
To avoid this problem we have found it necessary to
construct the left-corner table by hand, using linguistic
meta-knowledge about what is relevant, given a particu-
lar left-corner relation, to top-down prediction to com-
press the table to an absolute minimum. It turns out to
be the case that only in this way the effect of top-down
filtering will pay-off against the increased overhead of
having to check the left-corner table.
</bodyText>
<sectionHeader confidence="0.961684" genericHeader="method">
6 Some Results
</sectionHeader>
<bodyText confidence="0.999372727272727">
The performance of the parsing algorithms discussed
in the preceding sections (a bottom-up parser for UG
(BU), a top-down parser for UG (cf Shieber, 1985)
(TD), a top-down parser operating on an instantiated
grammar (TD/I), and a bottom-up parser with top-
down filtering operating on an instantiated grammar
(BU/LC)) were tested on two experimental CUGs, one
implementing the morphosyntactic features of German
NPs, and one implementing the syntax of WH-questions
in Dutch by means of a gap-threading mechanism.
Some illustrative results are listed in Tables 1 and 2.
</bodyText>
<table confidence="0.9992925">
Sente icel Sentence2
items secs items secs
TD: 93 5.9 160 10.5
TD/I: 45 2.0 68 2.5
BU : 68 2.0 120 3.0
BU/LC: 12 0.6 23 0.9
</table>
<tableCaption confidence="0.998968">
Table l: German
</tableCaption>
<bodyText confidence="0.998967275862069">
For German, an ideal restrictor R was f&lt; 1* &gt; 11 =
cat, val, arg , or dir). This restrictor effectively filters
out all morphosyntactic information, in as far as it is not
repeated in the categorial rules. The resulting precom-
piled grammar is much smaller than in the case where
no restriction was used or where morphosyntactic in-
formation was not completely filtered out. A categorial
lexicon for German, for instance, containing only deter-
miners, adjectives, nouns, and transitive and intransi-
tive verbs, will give rise to more than 60 instantiated
rules if precompiled without restriction, whereas only
four rules are computed if R is used (i.e. only two more
than in the uncompiled (categorial) grammar). The
improvement in efficiency of TD/I over TD is due to
the fact that no useless instances of leftward applica-
tion are predicted and to the fact that no restriction is
needed during parsing with an instantiated grammar.
Thus, prediction based on already processed material
can be maximal. As soon as we have parsed a cate-
gory N PI 1■1[+sg ,+wk, +dat , + f em], for instance, top-
down prediction will add only those items that have
N[+sg,+wk,+dat,+ f em] as LHS.
BU is almost. as efficient as TD/I, eventhough it
works with a generic grammar, and thus produces
(significantly) more chart-items. Once we replace the
generic grammar by an instantiated grammar, and add
left-corner relationships (BU/LC), the predictive capac-
ities of the parser are maximal, and a sharp decrease in
the number of chart items and parse times occurs.
</bodyText>
<table confidence="0.998853">
Sentencel Sentence2 Sentence3
items secs items secs items secs
TD: 255 32.2 225 27.9 358 47.2
TD/I: 48 3.2 71 6.0 129 11.9
BU : 78 1.8 74 1.7 131 3.6
BU/LC: 40 1.7 45 2.1 69 3.9
</table>
<tableCaption confidence="0.540132">
Tablel: Gap-threading
</tableCaption>
<bodyText confidence="0.986197388888889">
For the grammar with gap-threading (table 2),
we used a restrictor R f&lt; 1* &gt; 11 =
cat, val, arg dir, gap, in or out). The TD parser en-
counters serious difficulties in this case, whereas TD/1
performs significantly better, but still is rather ineffi-
cient. There is a distinct difference between BU and
BU/LC if we look at the number of chart items, al-
though the difference is less marked than in the case of
German. In terms of parse times the two algorithms
are almost equivalent.
Comparing our results with those of Shieber (1985)
and Haas (1989), we see that in all cases top-down fil-
tering may reduce the size of the chart significantly.
Whereas Haas (1989) found that top-down filtering
never helps to actually decrease parse times in a
bottom-up parser, we have found at least one example
(German) where top-down filtering is useful.
- 183 -
</bodyText>
<sectionHeader confidence="0.998968" genericHeader="conclusions">
7 Conclusions
</sectionHeader>
<bodyText confidence="0.999986944444444">
There is a trend in modern linguistics to replace gram-
mars that are completely language specific by grammars
which combine universal rules and principles with lan-
guage specific parameter settings, lexicons, etc. This
trend can be observed in such diverse frameworks
as Lexical Functional Grammar, Government-Binding
Theory, Head-driven Phrase Structure Grammar and
Categorial Grammar. In parsing with such formalisms,
especially those formalisms that are unification-based,
we find that traditional parsing-techniques, eventhough
they may be applicable to UG, are no longer satisfac-
tory. In particular, prediction techniques which may
be efficient for phrase structure grammar do not always
carry over easily to UG. The present paper shows that if
a grammar uses only schematic combinatory principles
instead of phrase-structure rules, prediction is only pos-
sible if we replace the generic rules by grammar-specific
instances of these rules.
</bodyText>
<sectionHeader confidence="0.999549" genericHeader="references">
8 Literature
</sectionHeader>
<reference confidence="0.993161744680851">
Houma, G. 1987. A Unification-based Analysis of Un-
bounded Dependencies in Categorial Grammar, in J.
Groenendijk, M. Stokhof, &amp; F. Veltman (eds.) Proceed-
ings of the sixth Amsterdam Colloquium, University of
Amsterdam, Amsterdam, 1-19.
Houma, G., 1988, Modifiers and Specifiers in Categorial
Unification Grammar, Linguistics, vol 26, 21-46.
Houma, G., E. Konig, &amp; H. Uszkbreit, 1988. A Flexi-
ble Graph-Unification Formalism and its Application to
Natural Language Processing, IBM Journal of Research
and Development, 32, 170-184.
Calder, J., E. Klein, &amp; H. Zeevat 1988. Unification
Categorial Grammar: a concise, extendable grammar
for natural language processing. Proceedings of Coling
1988, Hungarian Academy of Sciences, Budapest, 83-
86.
Haas, A. 1989. A Parsing Algorithm for Unification
Grammar. Computational Linguistics 15-4, 219-232.
Karttunen, L. 1989. Radical Lexicalism. In M. Baltin
&amp; A. Kroch (eds.), Alternative Conceptions of Phrase
Structure, Chicago University Press, Chicago, 43-66.
Matsumoto, Y., H. Tanaka, H. Hirakawa, II. Miyoshi,
&amp; H. Yasukawa, 1983, BUP : A Bottom-Up Parser em-
bedded in Prolog. New Generation Computing, vol 1,
145-158.
Pereira, F., &amp; S. Shieber (1986). Prolog and Natural
Language Analysis. CSLI Lecture Notes 10, University
of Chicago Press, Chicago.
Pollard, C. &amp; I. Sag, 1987, Information-Based Syntax
and Semantics, vol 1 : Fundamentals, CSLI Lecture
Notes 13, University of Chicago Press, Chicago.
Shieber, S. 1985. Using Restriction to Extend Pars-
ing Algorithms for Complex-Feature-Based Algorithms.
Proceedings of the 22nd Annual Meeting of the As-
sociation for Computational Linguistics, University of
Chicago, Chicago, 145-152.
Uszkoreit, H. 1986. Categorial Unification Grammars.
Proceedings of COLING 1986. Institut fiir angewandte
Kommunikations- und Sprachforschung, Bonn, 187-194.
Zeevat, H., E. Klein, &amp; J. Calder, 1987. An Introduc-
tion to Unification Categorial Grammar. In N. Had-
dock, E. Klein, &amp; G. Morill (eds.), Categorial Grammar,
Unification grammar, and Parsing, Edinburgh Working
Papers in Cognitive Science, Vol. 1.
Zwicky, A. 1986. German Adjective Agreement in
GPSG. Linguistics, vol 24, 957-990.
- 184 -
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.045971">
<title confidence="0.980453">Prediction in Chart Parsing Algorithms for Categorial Unification Grammar</title>
<author confidence="0.99376">Gosse Bouma</author>
<affiliation confidence="0.9046505">Computational Linguistics Department University of Groningen, P.O. box 716</affiliation>
<address confidence="0.995102">NL-9700 AS Groningen, The Netherlands</address>
<email confidence="0.785127">e-mail:gosse©let.rug.n1</email>
<abstract confidence="0.988351783505155">Natural language systems based on Categorial Unification Grammar (CUG) have mainly employed bottomup parsing algorithms for processing. Conventional prediction techniques to improve the efficiency of the parsing process, appear to fall short when parsing CUG. Nevertheless, prediction seems necessary when parsing grammars with highly ambiguous lexicons or with noncanonical categorial rules. In this paper we present a lexicalist prediction technique for CUG and show that this may lead to considerable gains in efficiency for both bottom-up and top-down parsing. 1 Preliminaries UNIFICATION GRAMMAR. Unificationbased versions of Categorial Grammar, known as CUG or UCG, have attracted considerable attention recently instance, Uszkoreit, 1986, Karttunen, 1986, Bouma, 1988, Bouma et al., 1988, and Calder et al., 1988). The categories of Categorial Grammar (CG) can be encoded easily as feature-structures, in which attribute &lt; &gt; either an atomic value (in case of an atomic category) or a structure with at- &lt; al &gt;, &lt; dir &gt; &lt; arg &gt; (in case of a complex category). Morphosyntactic information can be added by introducing additional labels. An example of such a category represented as attribute-value matrix is presented below. N P[-f-nom]l N [-Fnom , -Fsg] = val : { cat : np case : nom dir: right cat : [cat : n arg: case : nom num : sg combinatory rules of classical CG, — AIB B application) and B B\A plication), can be encoded as highly schematic rewrite rules associated with an attribute-value graph: Rightward Application Rule: --* x2 : [cat : :&lt; Leftward Application Rule: x2 X0 :&lt; 1&gt; :&lt; [[ val :&lt; 1 &gt; I : : left :&lt; CUG is a lexicalist theory: language specific information about word order, subcategorization, agreement, case-assignment, etc., is stored primarily in the lexicon. Whereas in classical CG functor-argument structure is the only means available for describing linguistic phenomena, in CUG additional features may be used to account for phenomena such as agreement and case-marking (see Bouma 1988). Also, whereas in classical CG all rules are in principle universal (i.e. not language-specific), in CUG there is a tendency to supplement generic categorial rules with language or construction specific rules For instance, a rule NP --+ N [-Fplu] may be added to account for the occurence of bare plural NPs, and specific rules may be added to account for unbounded dependency constructions (Bouma val :&lt; 1 &gt; dir: rig ht :&lt; &gt; - 179 - 1987). Finally, instead of fully instantiated categorystructures, one may choose to work with polymorphic categories (Karttunen 1989, Zeevat et al. 1987). Consequently, CUG not only shows resemblances with traditional categorial grammar, but also with Head-driven Phrase Structure Grammar (Pollard St Sag, 1987), another lexicalist and unification-based framework. CHART PARSING OF UNIFICATION GRAMMAR (UG). Parsing methods for context-free grammar can be extended to unification-based grammar formalisms (see Shieber, 1985 or Haas, 1989), and therefore they can in principle be used to parse CUG. A chart-parser scans a sentence from left to right, while entering items, representing (partial) derivations, in a chart. Assume that items are represented as Prolog terms the form End, LH S,Parsed,ToParse), a feature-structure and lists of feature-structures. , 1, [S], [NP], [V, NP]) a partial derivation ranging from position 0 to 1 of a constituent feature-structure which a daughter found and of which daughters to be parsed. A word with lexical entry : position to addition of an item Begin + 1,Cat,[W ord],[ ]). completion and prediction steps are called until no further items can be added to the chart.</abstract>
<keyword confidence="0.722263">step: 1For each E, LHS, [NextIToParse]) End, Next, [D, an End, LHS, Parsed+ Next, ToParse). Prediction step: For each E, Parsed, []), each rule [Next I E, LHS, [Next], RHS).</keyword>
<abstract confidence="0.979249291666667">The prediction step causes the algorithm to work bottom-up. 2 The Problem In a bottom-up chart parser, applicable rules are predicted bottom-up, and thus, lexical information is used to constrain the addition of active items (i.e. items representing partial derivations). At first sight, this method appears to be ideal for CUG, as in CUG the lexical items contain syntactic information which is language and grammar specific, whereas the rules are generic in nature. Note, however, that although , &apos;In these and following definitions, we assume, unless otherwise indicated, that feature-structures denoted by identical prolog variables are unified by means of feature-unification. bottom-up parsing is certainly attractive for CUG, there are also a number of potential inefficiencies: • In many cases useless items will be predicted. Consider, for instance, a grammar with a lexicontaining only the categories P\S, with application as the only combinatory rules. When encountering a determiner, preof an itern(i, X, [(np/n)\X]) is superfluous, since there is simply no way that the could ever produce a category (np/n)\ • If the lexicon is highly ambiguous, many useless (partial) derivations may take place. Consider, for instance, the syntax of NPs in German, where determiners and adjectives are ambiguous with respect to case, declension pattern, gender and number (see Zwicky, 1986, for an analysis in terms GPSG). The sentence junge Frau schldft only one derivation, but a bottom-up parser has to consider 11 possible analyses for the word junge, for the phrase Frau, for 2 for Frau. example shows that even in a pure categorial system, there may be situations where top-down prediction has its merits. • If the grammar contains language or construction specific rules, bottom-up prediction may be less efficient. Relevant examples are the rule for forming bare plurals mentioned in the previous section and rules which implement a categorial version of Pereira Si Shieber, 1986 : 119 if). The rule shemata below allow for the derivation of sentences with a preposed element and for the extraction of arguments: X S[gap : X] :Y] — X</abstract>
<intro confidence="0.762139">Y</intro>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>G Houma</author>
</authors>
<title>A Unification-based Analysis of Unbounded Dependencies in Categorial Grammar,</title>
<date>1987</date>
<booktitle>Proceedings of the sixth Amsterdam Colloquium, University of</booktitle>
<pages>1--19</pages>
<editor>in J. Groenendijk, M. Stokhof, &amp; F. Veltman (eds.)</editor>
<location>Amsterdam, Amsterdam,</location>
<marker>Houma, 1987</marker>
<rawString>Houma, G. 1987. A Unification-based Analysis of Unbounded Dependencies in Categorial Grammar, in J. Groenendijk, M. Stokhof, &amp; F. Veltman (eds.) Proceedings of the sixth Amsterdam Colloquium, University of Amsterdam, Amsterdam, 1-19.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Houma</author>
</authors>
<title>Modifiers and Specifiers in</title>
<date>1988</date>
<journal>Categorial Unification Grammar, Linguistics,</journal>
<volume>26</volume>
<pages>21--46</pages>
<marker>Houma, 1988</marker>
<rawString>Houma, G., 1988, Modifiers and Specifiers in Categorial Unification Grammar, Linguistics, vol 26, 21-46.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Houma</author>
<author>E Konig</author>
<author>H Uszkbreit</author>
</authors>
<title>A Flexible Graph-Unification Formalism and its Application to Natural Language Processing,</title>
<date>1988</date>
<journal>IBM Journal of Research and Development,</journal>
<volume>32</volume>
<pages>170--184</pages>
<marker>Houma, Konig, Uszkbreit, 1988</marker>
<rawString>Houma, G., E. Konig, &amp; H. Uszkbreit, 1988. A Flexible Graph-Unification Formalism and its Application to Natural Language Processing, IBM Journal of Research and Development, 32, 170-184.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Calder</author>
<author>E Klein</author>
<author>H Zeevat</author>
</authors>
<title>Unification Categorial Grammar: a concise, extendable grammar for natural language processing.</title>
<date>1988</date>
<booktitle>Proceedings of Coling 1988, Hungarian Academy of Sciences,</booktitle>
<pages>83--86</pages>
<location>Budapest,</location>
<contexts>
<context position="1073" citStr="Calder et al., 1988" startWordPosition="144" endWordPosition="147">appear to fall short when parsing CUG. Nevertheless, prediction seems necessary when parsing grammars with highly ambiguous lexicons or with noncanonical categorial rules. In this paper we present a lexicalist prediction technique for CUG and show that this may lead to considerable gains in efficiency for both bottom-up and top-down parsing. 1 Preliminaries CATEGORIAL UNIFICATION GRAMMAR. Unificationbased versions of Categorial Grammar, known as CUG or UCG, have attracted considerable attention recently (see, for instance, Uszkoreit, 1986, Karttunen, 1986, Bouma, 1988, Bouma et al., 1988, and Calder et al., 1988). The categories of Categorial Grammar (CG) can be encoded easily as feature-structures, in which the attribute &lt; cat &gt; dominates either an atomic value (in case of an atomic category) or a structure with attributes &lt; v al &gt;, &lt; dir &gt; and &lt; arg &gt; (in case of a complex category). Morphosyntactic information can be added by introducing additional labels. An example of such a category represented as attribute-value matrix is presented below. N P[-f-nom]l N [-Fnom , -Fsg] = val : { cat : np case : nom dir: right cat : [cat : n arg: case : nom num : sg The combinatory rules of classical CG, A — AIB </context>
</contexts>
<marker>Calder, Klein, Zeevat, 1988</marker>
<rawString>Calder, J., E. Klein, &amp; H. Zeevat 1988. Unification Categorial Grammar: a concise, extendable grammar for natural language processing. Proceedings of Coling 1988, Hungarian Academy of Sciences, Budapest, 83-86.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Haas</author>
</authors>
<title>A Parsing Algorithm for Unification Grammar.</title>
<date>1989</date>
<journal>Computational Linguistics</journal>
<pages>15--4</pages>
<contexts>
<context position="3380" citStr="Haas, 1989" startWordPosition="543" endWordPosition="544">ependency constructions (Bouma val :&lt; 1 &gt; dir: rig ht arg :&lt; 2 &gt; - 179 - 1987). Finally, instead of fully instantiated categorystructures, one may choose to work with polymorphic categories (Karttunen 1989, Zeevat et al. 1987). Consequently, CUG not only shows resemblances with traditional categorial grammar, but also with Head-driven Phrase Structure Grammar (Pollard St Sag, 1987), another lexicalist and unification-based framework. CHART PARSING OF UNIFICATION GRAMMAR (UG). Parsing methods for context-free grammar can be extended to unification-based grammar formalisms (see Shieber, 1985 or Haas, 1989), and therefore they can in principle be used to parse CUG. A chart-parser scans a sentence from left to right, while entering items, representing (partial) derivations, in a chart. Assume that items are represented as Prolog terms of the form item(Begin, End, LH S,Parsed,ToParse), where LHS is a feature-structure and Parsed and ToParse contain lists of feature-structures. An itern(0 , 1, [S], [NP], [V, NP]) represents a partial derivation ranging from position 0 to 1 of a constituent with feature-structure S, of which a daughter NP has been found and of which daughters V and NP are still to b</context>
<context position="17619" citStr="Haas, 1989" startWordPosition="2903" endWordPosition="2904">ccessful and failed parse attempts are stored). Our algorithm assigns a more important role to the chart and thus avoids backtracking. - 182- instantiated grammar, we get 8 versions (i.e. 4 cases times 2 possible values for number) of this relation. Similar observations can be made for adjectives that are left-corners of N (where things are even worse, as we would like to take declension classes into account as well). This multiplication may lead to a needlessly large left-corner table, which, if used in the prediction step, may in fact lead to sharp decreases in parsing performance (see also Haas, 1989, who encountered similar problems). Note that checking a left-corner table containing feature-structures is in general expensive, as unification, rather than identity-tests, have to be carried out. To avoid this problem we have found it necessary to construct the left-corner table by hand, using linguistic meta-knowledge about what is relevant, given a particular left-corner relation, to top-down prediction to compress the table to an absolute minimum. It turns out to be the case that only in this way the effect of top-down filtering will pay-off against the increased overhead of having to ch</context>
<context position="21251" citStr="Haas (1989)" startWordPosition="3521" endWordPosition="3522">4 1.7 131 3.6 BU/LC: 40 1.7 45 2.1 69 3.9 Tablel: Gap-threading For the grammar with gap-threading (table 2), we used a restrictor R f&lt; 1* &gt; 11 = cat, val, arg dir, gap, in or out). The TD parser encounters serious difficulties in this case, whereas TD/1 performs significantly better, but still is rather inefficient. There is a distinct difference between BU and BU/LC if we look at the number of chart items, although the difference is less marked than in the case of German. In terms of parse times the two algorithms are almost equivalent. Comparing our results with those of Shieber (1985) and Haas (1989), we see that in all cases top-down filtering may reduce the size of the chart significantly. Whereas Haas (1989) found that top-down filtering never helps to actually decrease parse times in a bottom-up parser, we have found at least one example (German) where top-down filtering is useful. - 183 - 7 Conclusions There is a trend in modern linguistics to replace grammars that are completely language specific by grammars which combine universal rules and principles with language specific parameter settings, lexicons, etc. This trend can be observed in such diverse frameworks as Lexical Functiona</context>
</contexts>
<marker>Haas, 1989</marker>
<rawString>Haas, A. 1989. A Parsing Algorithm for Unification Grammar. Computational Linguistics 15-4, 219-232.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Karttunen</author>
</authors>
<title>Radical Lexicalism.</title>
<date>1989</date>
<booktitle>Alternative Conceptions of Phrase Structure,</booktitle>
<pages>43--66</pages>
<editor>In M. Baltin &amp; A. Kroch (eds.),</editor>
<publisher>Chicago University Press,</publisher>
<location>Chicago,</location>
<contexts>
<context position="2974" citStr="Karttunen 1989" startWordPosition="486" endWordPosition="487">reement and case-marking (see Bouma 1988). Also, whereas in classical CG all rules are in principle universal (i.e. not language-specific), in CUG there is a tendency to supplement generic categorial rules with language or construction specific rules For instance, a rule NP --+ N [-Fplu] may be added to account for the occurence of bare plural NPs, and specific rules may be added to account for unbounded dependency constructions (Bouma val :&lt; 1 &gt; dir: rig ht arg :&lt; 2 &gt; - 179 - 1987). Finally, instead of fully instantiated categorystructures, one may choose to work with polymorphic categories (Karttunen 1989, Zeevat et al. 1987). Consequently, CUG not only shows resemblances with traditional categorial grammar, but also with Head-driven Phrase Structure Grammar (Pollard St Sag, 1987), another lexicalist and unification-based framework. CHART PARSING OF UNIFICATION GRAMMAR (UG). Parsing methods for context-free grammar can be extended to unification-based grammar formalisms (see Shieber, 1985 or Haas, 1989), and therefore they can in principle be used to parse CUG. A chart-parser scans a sentence from left to right, while entering items, representing (partial) derivations, in a chart. Assume that </context>
</contexts>
<marker>Karttunen, 1989</marker>
<rawString>Karttunen, L. 1989. Radical Lexicalism. In M. Baltin &amp; A. Kroch (eds.), Alternative Conceptions of Phrase Structure, Chicago University Press, Chicago, 43-66.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Miyoshi</author>
<author>H Yasukawa</author>
</authors>
<title>BUP : A Bottom-Up Parser embedded in Prolog.</title>
<date>1983</date>
<journal>New Generation Computing,</journal>
<volume>1</volume>
<pages>145--158</pages>
<marker>Miyoshi, Yasukawa, 1983</marker>
<rawString>Matsumoto, Y., H. Tanaka, H. Hirakawa, II. Miyoshi, &amp; H. Yasukawa, 1983, BUP : A Bottom-Up Parser embedded in Prolog. New Generation Computing, vol 1, 145-158.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Pereira</author>
<author>S Shieber</author>
</authors>
<title>Prolog and Natural Language Analysis.</title>
<date>1986</date>
<journal>CSLI Lecture Notes</journal>
<volume>10</volume>
<institution>University of Chicago Press,</institution>
<location>Chicago.</location>
<marker>Pereira, Shieber, 1986</marker>
<rawString>Pereira, F., &amp; S. Shieber (1986). Prolog and Natural Language Analysis. CSLI Lecture Notes 10, University of Chicago Press, Chicago.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Pollard</author>
<author>I Sag</author>
</authors>
<title>Information-Based Syntax and Semantics,</title>
<date>1987</date>
<journal>Fundamentals, CSLI Lecture Notes</journal>
<volume>1</volume>
<institution>University of Chicago Press,</institution>
<location>Chicago.</location>
<marker>Pollard, Sag, 1987</marker>
<rawString>Pollard, C. &amp; I. Sag, 1987, Information-Based Syntax and Semantics, vol 1 : Fundamentals, CSLI Lecture Notes 13, University of Chicago Press, Chicago.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Shieber</author>
</authors>
<title>Using Restriction to Extend Parsing Algorithms for Complex-Feature-Based Algorithms.</title>
<date>1985</date>
<booktitle>Proceedings of the 22nd Annual Meeting of the Association</booktitle>
<pages>145--152</pages>
<institution>for Computational Linguistics, University of Chicago,</institution>
<location>Chicago,</location>
<contexts>
<context position="3365" citStr="Shieber, 1985" startWordPosition="540" endWordPosition="541">t for unbounded dependency constructions (Bouma val :&lt; 1 &gt; dir: rig ht arg :&lt; 2 &gt; - 179 - 1987). Finally, instead of fully instantiated categorystructures, one may choose to work with polymorphic categories (Karttunen 1989, Zeevat et al. 1987). Consequently, CUG not only shows resemblances with traditional categorial grammar, but also with Head-driven Phrase Structure Grammar (Pollard St Sag, 1987), another lexicalist and unification-based framework. CHART PARSING OF UNIFICATION GRAMMAR (UG). Parsing methods for context-free grammar can be extended to unification-based grammar formalisms (see Shieber, 1985 or Haas, 1989), and therefore they can in principle be used to parse CUG. A chart-parser scans a sentence from left to right, while entering items, representing (partial) derivations, in a chart. Assume that items are represented as Prolog terms of the form item(Begin, End, LH S,Parsed,ToParse), where LHS is a feature-structure and Parsed and ToParse contain lists of feature-structures. An itern(0 , 1, [S], [NP], [V, NP]) represents a partial derivation ranging from position 0 to 1 of a constituent with feature-structure S, of which a daughter NP has been found and of which daughters V and NP</context>
<context position="7795" citStr="Shieber (1985)" startWordPosition="1265" endWordPosition="1266">xample may suggest that prediction should be eliminated all together. This option is feasible only if the rule set is restricted to application. - 180 - 3 Top-down Parsing Top-down chart parsing differs from the algorithm described above only in the prediction-step, which predicts applicable rules top-down. Contrary to bottomup parsing, however, the adaptation of a top-down algorithm for UG requires some special care. For UGs which lack a so-called context-free back-bone, such as CUG, the top-down prediction step can only be guaranteed to terminate if we make use of restriction, as defined in Shieber (1985). Top-down prediction with a restrictor R (where R is a (finite) set of paths through a feature-structure) amounts to the following: Restriction The restriction of a feature-structure F relative to a restrictor R is the most specific feature-structure F&apos; E F, such that every path in F&apos; has either an atomic value or is an element of R. Predictor Step For each item(_ , End, LHS, Parsed, [Next I ToParse]) such that RNext is the restriction of Next relative to R, and each rule RNext —4 RHS, add ifern(i,i, RNC, RHS). Restriction can be used to develop a top-down chart parser for CUG in which the (t</context>
<context position="11710" citStr="Shieber, 1985" startWordPosition="1920" endWordPosition="1921"> raising (XI(Y\X)--.Y). In such a grammar, arbitrarily complex instantiations of this rule can be compiled. To avoid the creation of an infinite set of rules, we may again employ restriction: Compilation with restriction Let R be a restrictor. For every category C, where C is either a lexical category or the LHS of art instantiated rule, and every (generic) rule GR, if the restriction of C relative to R is unifiable with the head-daughter of GR, add GR&apos; (the result of the unification) to the set of instantiated rules. The compilation step is guaranteed to terminate as long as R is finite (cf. Shieber, 1985). The compilation procedure is not specific to a certain grammar formalism or rule set, and thus can be used to compile arbitrary UGs. Such a compilation step will give rise to a substantially more instantiated rule set in all cases 3Note that for classical CG, an algorithm of this kind can be used to compute the phrase-structure equivalent of the input grammar. 181 - where schematic grammar rules are used in combination with highly structured lexical items. For the compiled grammar, a standard top-down algorithm (such as the one in section 3) can be used. Prediction for CUG is now significant</context>
<context position="18415" citStr="Shieber, 1985" startWordPosition="3030" endWordPosition="3031"> be carried out. To avoid this problem we have found it necessary to construct the left-corner table by hand, using linguistic meta-knowledge about what is relevant, given a particular left-corner relation, to top-down prediction to compress the table to an absolute minimum. It turns out to be the case that only in this way the effect of top-down filtering will pay-off against the increased overhead of having to check the left-corner table. 6 Some Results The performance of the parsing algorithms discussed in the preceding sections (a bottom-up parser for UG (BU), a top-down parser for UG (cf Shieber, 1985) (TD), a top-down parser operating on an instantiated grammar (TD/I), and a bottom-up parser with topdown filtering operating on an instantiated grammar (BU/LC)) were tested on two experimental CUGs, one implementing the morphosyntactic features of German NPs, and one implementing the syntax of WH-questions in Dutch by means of a gap-threading mechanism. Some illustrative results are listed in Tables 1 and 2. Sente icel Sentence2 items secs items secs TD: 93 5.9 160 10.5 TD/I: 45 2.0 68 2.5 BU : 68 2.0 120 3.0 BU/LC: 12 0.6 23 0.9 Table l: German For German, an ideal restrictor R was f&lt; 1* &gt; 1</context>
<context position="21235" citStr="Shieber (1985)" startWordPosition="3518" endWordPosition="3519"> 11.9 BU : 78 1.8 74 1.7 131 3.6 BU/LC: 40 1.7 45 2.1 69 3.9 Tablel: Gap-threading For the grammar with gap-threading (table 2), we used a restrictor R f&lt; 1* &gt; 11 = cat, val, arg dir, gap, in or out). The TD parser encounters serious difficulties in this case, whereas TD/1 performs significantly better, but still is rather inefficient. There is a distinct difference between BU and BU/LC if we look at the number of chart items, although the difference is less marked than in the case of German. In terms of parse times the two algorithms are almost equivalent. Comparing our results with those of Shieber (1985) and Haas (1989), we see that in all cases top-down filtering may reduce the size of the chart significantly. Whereas Haas (1989) found that top-down filtering never helps to actually decrease parse times in a bottom-up parser, we have found at least one example (German) where top-down filtering is useful. - 183 - 7 Conclusions There is a trend in modern linguistics to replace grammars that are completely language specific by grammars which combine universal rules and principles with language specific parameter settings, lexicons, etc. This trend can be observed in such diverse frameworks as L</context>
</contexts>
<marker>Shieber, 1985</marker>
<rawString>Shieber, S. 1985. Using Restriction to Extend Parsing Algorithms for Complex-Feature-Based Algorithms. Proceedings of the 22nd Annual Meeting of the Association for Computational Linguistics, University of Chicago, Chicago, 145-152.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Uszkoreit</author>
</authors>
<title>Categorial Unification Grammars.</title>
<date>1986</date>
<booktitle>Proceedings of COLING 1986. Institut fiir angewandte Kommunikations- und Sprachforschung,</booktitle>
<pages>187--194</pages>
<location>Bonn,</location>
<contexts>
<context position="997" citStr="Uszkoreit, 1986" startWordPosition="133" endWordPosition="134">rediction techniques to improve the efficiency of the parsing process, appear to fall short when parsing CUG. Nevertheless, prediction seems necessary when parsing grammars with highly ambiguous lexicons or with noncanonical categorial rules. In this paper we present a lexicalist prediction technique for CUG and show that this may lead to considerable gains in efficiency for both bottom-up and top-down parsing. 1 Preliminaries CATEGORIAL UNIFICATION GRAMMAR. Unificationbased versions of Categorial Grammar, known as CUG or UCG, have attracted considerable attention recently (see, for instance, Uszkoreit, 1986, Karttunen, 1986, Bouma, 1988, Bouma et al., 1988, and Calder et al., 1988). The categories of Categorial Grammar (CG) can be encoded easily as feature-structures, in which the attribute &lt; cat &gt; dominates either an atomic value (in case of an atomic category) or a structure with attributes &lt; v al &gt;, &lt; dir &gt; and &lt; arg &gt; (in case of a complex category). Morphosyntactic information can be added by introducing additional labels. An example of such a category represented as attribute-value matrix is presented below. N P[-f-nom]l N [-Fnom , -Fsg] = val : { cat : np case : nom dir: right cat : [cat </context>
</contexts>
<marker>Uszkoreit, 1986</marker>
<rawString>Uszkoreit, H. 1986. Categorial Unification Grammars. Proceedings of COLING 1986. Institut fiir angewandte Kommunikations- und Sprachforschung, Bonn, 187-194.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Zeevat</author>
<author>E Klein</author>
<author>J Calder</author>
</authors>
<title>An Introduction to Unification Categorial Grammar. In</title>
<date>1987</date>
<booktitle>Categorial Grammar, Unification grammar, and Parsing, Edinburgh Working Papers in Cognitive Science,</booktitle>
<volume>1</volume>
<editor>N. Haddock, E. Klein, &amp; G. Morill (eds.),</editor>
<contexts>
<context position="2995" citStr="Zeevat et al. 1987" startWordPosition="488" endWordPosition="491">-marking (see Bouma 1988). Also, whereas in classical CG all rules are in principle universal (i.e. not language-specific), in CUG there is a tendency to supplement generic categorial rules with language or construction specific rules For instance, a rule NP --+ N [-Fplu] may be added to account for the occurence of bare plural NPs, and specific rules may be added to account for unbounded dependency constructions (Bouma val :&lt; 1 &gt; dir: rig ht arg :&lt; 2 &gt; - 179 - 1987). Finally, instead of fully instantiated categorystructures, one may choose to work with polymorphic categories (Karttunen 1989, Zeevat et al. 1987). Consequently, CUG not only shows resemblances with traditional categorial grammar, but also with Head-driven Phrase Structure Grammar (Pollard St Sag, 1987), another lexicalist and unification-based framework. CHART PARSING OF UNIFICATION GRAMMAR (UG). Parsing methods for context-free grammar can be extended to unification-based grammar formalisms (see Shieber, 1985 or Haas, 1989), and therefore they can in principle be used to parse CUG. A chart-parser scans a sentence from left to right, while entering items, representing (partial) derivations, in a chart. Assume that items are represented</context>
</contexts>
<marker>Zeevat, Klein, Calder, 1987</marker>
<rawString>Zeevat, H., E. Klein, &amp; J. Calder, 1987. An Introduction to Unification Categorial Grammar. In N. Haddock, E. Klein, &amp; G. Morill (eds.), Categorial Grammar, Unification grammar, and Parsing, Edinburgh Working Papers in Cognitive Science, Vol. 1.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Zwicky</author>
</authors>
<title>German Adjective Agreement in</title>
<date>1986</date>
<journal>GPSG. Linguistics,</journal>
<volume>24</volume>
<pages>957--990</pages>
<contexts>
<context position="5943" citStr="Zwicky, 1986" startWordPosition="958" endWordPosition="959">ted. Consider, for instance, a grammar with a lexicon containing only the categories NPIN,N, and N P\S, and with application as the only combinatory rules. When encountering a determiner, prediction of an itern(i, i, X, [iip/n), [(np/n)\X]) is superfluous, since there is simply no way that the grammar could ever produce a category (np/n)\ X 2. • If the lexicon is highly ambiguous, many useless (partial) derivations may take place. Consider, for instance, the syntax of NPs in German, where determiners and adjectives are ambiguous with respect to case, declension pattern, gender and number (see Zwicky, 1986, for an analysis in terms of GPSG). The sentence die junge Frau schldft has only one derivation, but a bottom-up parser has to consider 11 possible analyses for the word junge, 6 for the phrase junge Frau, 4 for die and 2 for die junge Frau. This example shows that even in a pure categorial system, there may be situations where top-down prediction has its merits. • If the grammar contains language or construction specific rules, bottom-up prediction may be less efficient. Relevant examples are the rule for forming bare plurals mentioned in the previous section and rules which implement a cate</context>
</contexts>
<marker>Zwicky, 1986</marker>
<rawString>Zwicky, A. 1986. German Adjective Agreement in GPSG. Linguistics, vol 24, 957-990.</rawString>
</citation>
<citation valid="false">
<pages>184</pages>
<marker></marker>
<rawString>- 184 -</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>