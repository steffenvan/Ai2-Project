<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000123">
<title confidence="0.974558">
GF Parallel Resource Grammars and Russian
</title>
<author confidence="0.997365">
Janna Khegai
</author>
<affiliation confidence="0.999333">
Department of Computer Science
Chalmers University of Technology
</affiliation>
<address confidence="0.896954">
SE-41296 Gothenburg, Sweden
</address>
<email confidence="0.998255">
janna@cs.chalmers.se
</email>
<sectionHeader confidence="0.993873" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999936466666667">
A resource grammar is a standard library
for the GF grammar formalism. It raises
the abstraction level of writing domain-
specific grammars by taking care of the
general grammatical rules of a language.
GF resource grammars have been built in
parallel for eleven languages and share a
common interface, which simplifies multi-
lingual applications. We reflect on our ex-
perience with the Russian resource gram-
mar trying to answer the questions: how
well Russian fits into the common inter-
face and where the line between language-
independent and language-specific should
be drawn.
</bodyText>
<sectionHeader confidence="0.998989" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999927105263158">
Grammatical Framework (GF) (Ranta, 2004) is a
grammar formalism designed in particular to serve
as an interlingua platform for natural language ap-
plications in sublanguage domains. A domain can
be described using the GF grammar formalism and
then processed by GF. Such descriptions are called
application grammars.
A resource grammar (Ranta, to appear) is a
general-purpose grammar that forms a basis for
application grammars. Resource grammars have
so far been implemented for eleven languages in
parallel. The structural division into abstract and
concrete descriptions, advocated in GF, is used
to separate the language-independent common in-
terface or Application Programming Interface
(API) from corresponding language-specific im-
plementations. Consulting the abstract part is suf-
ficient for writing an application grammar without
descending to implementation details. This ap-
proach raises the level of application grammar de-
velopment and supports multilinguality, thus, pro-
viding both linguistic and computational advan-
tages.
The current coverage is comparable with the
Core Language Engine (CLE) project (Rayner
et al., 2000). Other well-known multilingual
general-purpose grammar projects that GF can
be related to, are LFG grammars (Butt et al.,
1999) and HPSG grammars (Pollard and Sag,
1994), although their parsing-oriented unification-
based formalisms are very different from the
GF generation-oriented type-theoretical formal-
ism (Ranta, 2004).
A Russian resource grammar was added after
similar grammars for English, Swedish, French
and German (Arabic, Italian, Finnish, Norwegian,
Danish and Spanish are also supported in GF). A
language-independent API representing the cover-
age of the resource library, therefore, was already
available. The task was to localize modules for
Russian.
A resource grammar has morphological and
syntactic modules. Morphological modules in-
clude a description of word classes, inflectional
paradigms and a lexicon. Syntactic modules com-
prise a description of phrasal structures for ana-
lyzing bigger than one-word entities and various
combination rules. Note, that semantics, defining
the meanings of words and syntactic structures,
is constructed in application grammars. This is
because semantics is rather domain-specific, and,
thus, it is much easier to construct a language-
independent semantic model for a particular do-
main than a general-purpose resource semantics.
In the following sections we consider typical
definitions from different resource modules focus-
ing on aspects specific to Russian. We will also
</bodyText>
<page confidence="0.987705">
475
</page>
<note confidence="0.72641">
Proceedings of the COLING/ACL 2006 Main Conference Poster Sessions, pages 475–482,
Sydney, July 2006. c�2006 Association for Computational Linguistics
</note>
<bodyText confidence="0.989629">
demonstrate the library usage in a sample applica-
tion grammar.
</bodyText>
<sectionHeader confidence="0.96396" genericHeader="method">
2 Word Classes
</sectionHeader>
<bodyText confidence="0.998930307692308">
Every resource grammar starts with a descrip-
tion of word classes. Their names belong to
the language-independent API, although their im-
plementations are language-specific. Russian fits
quite well into the common API here, since like
all other languages it has nouns, verbs, adjectives
etc. The type system for word classes of a lan-
guage is the most stable part of the resource gram-
mar library, since it follows traditional linguis-
tic descriptions (Shelyakin, 2000; Wade, 2000;
Starostin, 2005). For example, let us look at
the implementation of the Russian adjective type
AdjDegree:
</bodyText>
<equation confidence="0.9955626">
param
Degree = Pos  |Comp  |Super;
Case = Nom|Gen|Dat|Acc|Inst|Prep;
Animacy = Animate  |Inanimate;
Gender = Masc  |Fem  |Neut;
GenNum = ASingular Gender|APlural;
AdjForm = AF Case Animacy GenNum;
oper
AdjDegree : Type =
{s : Degree =&gt; AdjForm =&gt; Str};
</equation>
<bodyText confidence="0.982006166666667">
First, we need to specify parameters (param) on
which inflection forms depend. A vertical slash
(|) separates different parameter values. While in
English the only parameter would be comparison
degree (Degree), in Russian we have many more
parameters:
</bodyText>
<listItem confidence="0.979791785714286">
• Case, for example: bolьxie doma –
bolьxih domov (big houses – big houses’).
• Animacy only plays a role in the ac-
cusative case (Acc) in masculine (Masc)
singular (ASingular) and in plural forms
(APlural), namely, accusative animate
form is the same as genitive (Gen) form,
while accusative inanimate form is the same
as nominative (Nom): JI loblo bolьxie
doma – ,w loblo bolьxih muжqin (I love
big houses – I love big men).
• Gender only plays role in singular:
bolьxou dom – bolьxasf maxina (big
house – big car). The plural never makes
</listItem>
<bodyText confidence="0.930113333333333">
a gender distinction, thus, Gender and
number are combined in the GenNum pa-
rameter to reduce redundant inflection table
items. The possible values of GenNum are
ASingular Masc, ASingular Fem,
ASingular Neut and APlural.
</bodyText>
<listItem confidence="0.9967782">
• Number, for instance: bolьxo17 dom –
bolьxie doma (a big house – big houses).
• Degree can be more complex, since most
Russian adjectives have two comparative
(Comp) forms: declinable attributive and
indeclinable predicative1: bolee vysokiU
(more high) – vyxe (higher), and more
than one superlative (Super) forms: samyU
vysokiU (the most high) – naivysxiU (the
highest).
</listItem>
<bodyText confidence="0.999833741935484">
Even another parameter can be added, since
Russian adjectives in the positive (Pos) degree
have long and short forms: spokou`nasf reka (the
calm river) – reka – spokoUna (the river is
calm). The short form has no case declension,
thus, it can be considered as an additional case
(Starostin, 2005). Note, that although the predica-
tive usage of the long form is perfectly grammat-
ical, it can have a slightly different meaning com-
pared to the short form. For example: long, pred-
icative on – bolьnou (”he is crazy”) vs. short,
predicative on – bolen (”he is ill”).
An oper judgement combines the name of
the defined operation, its type, and an expres-
sion defining it. The type for degree adjec-
tive (AdjDegree) is a table of strings (s: ..
=&gt; ..=&gt; Str) that has two main dimensions:
Degree and AdjForm, where the last one is a
combination of the parameters listed above. The
reason to have the Degree parameter as a sepa-
rate dimension is that a special type of adjectives
Adj that just have positive forms is useful. It in-
cludes both non-degree adjective classes: posses-
sive, like mamin (mother’s), lisiU (fox’es), and
relative, like russkiU (Russian).
As a part of the language-independent API, the
name AdjDegree denotes the adjective degree
type for all languages, although each language has
its own implementation. Maintaining parallelism
among languages is rather straightforward at this
stage, since the only thing shared is the name of
</bodyText>
<footnote confidence="0.9770185">
1The English -er/more and -est/most variations are exclu-
sive, while in Russian both forms are valid.
</footnote>
<page confidence="0.998879">
476
</page>
<bodyText confidence="0.999433">
a part of speech. A possible complication is that
parsing with inflectionally rich languages can be
less efficient compared to, for instance, English.
This is because in GF all forms of a word are kept
in the same declension table, which is convenient
for generation, since GF is a generation-oriented
grammar formalism. Therefore, the more forms
there are, the bigger tables we have to store in
memory, which can become an issue as the gram-
mars grow and more languages are added (Dada
and Ranta, 2006).
</bodyText>
<sectionHeader confidence="0.969802" genericHeader="method">
3 Inflection Paradigms and Lexicon
</sectionHeader>
<bodyText confidence="0.999908272727273">
Besides word class declarations, morphology
modules also contain functions defining common
inflectional patterns (paradigms) and a lexicon.
This information is language-specific, so fitting
into the common API is not a consideration here.
Paradigms are used to build the lexicon incremen-
tally as new words are used in applications. A lex-
icon can also be extracted from other sources.
Unlike syntactic descriptions, morphological
descriptions for many languages have been al-
ready developed in other projects. Thus, consid-
erable efforts can be saved by reusing existing
code. How easy we can perform the transforma-
tion depends on how similar the input and output
formats are. For example, the Swedish morphol-
ogy module is generated automatically from the
code of another project, called Functional Mor-
phology (Forsberg and Ranta, 2004). In this case
the formats are very similar, so extracting is rather
straightforward. However, this might not be the
case if we build the lexicon from a very different
representation or even from corpora, where post-
modification by hand is simply inevitable.
A paradigm function usually takes one or more
string arguments and forms a lexical entry. For
example, the function nGolova describes the in-
flectional pattern for feminine inanimate nouns
ending with -a in Russian. It takes the basic form
of a word as a string (Str) and returns a noun (CN
stands for Common Noun, see definition in sec-
tion 4). Six cases times two numbers gives twelve
forms, plus two inherent parameters Animacy
and Gender (defined in section 2):
</bodyText>
<listItem confidence="0.673386">
oper
nGolova: Str -&gt; CN = \golova -&gt;
let golov = init golova in {
s = table {
SF Sg Nom =&gt; golov+&amp;quot;a&amp;quot;;
</listItem>
<table confidence="0.917687636363636">
SF Sg Gen =&gt; golov+&amp;quot;y&amp;quot;;
SF Sg Dat =&gt; golov+&amp;quot;e&amp;quot;;
SF Sg Acc =&gt; golov+&amp;quot;u&amp;quot;;
SF Sg Inst =&gt; golov+&amp;quot;o*&amp;quot;;
SF Sg Prepos =&gt; golov+&amp;quot;e&amp;quot;;
SF Pl Nom =&gt; golov+&amp;quot;y&amp;quot;;
SF Pl Gen =&gt; golov;
SF Pl Dat =&gt; golov+&amp;quot;am&amp;quot;;
SF Pl Acc =&gt; golov+&amp;quot;y&amp;quot;;
SF Pl Inst =&gt; golov+&amp;quot;ami&amp;quot;;
SF Pl Prepos =&gt; golov+&amp;quot;ah&amp;quot; };
</table>
<equation confidence="0.981384">
g = Fem;
anim = Inanimate };
</equation>
<bodyText confidence="0.997682621621622">
where \golova is a A-abstraction, which means
that the function argument of the type Str will be
denoted as golova in the definition. The con-
struction let...in is used to extract the word
stem (golov), in this case, by cutting off the last
letter (init). Of course, one could supply the
stem directly, however, it is easier for the gram-
marian to just write the whole word without wor-
rying what stem it has and let the function take
care of the stem automatically. The table structure
is simple – each line corresponds to one parame-
ter value. The sign =&gt; separates parameter values
from corresponding inflection forms. Plus sign de-
notes string concatenation.
The type signature (nGolova: Str -&gt;
CN) and maybe a comment telling that the
paradigm describes feminine inanimate nouns
ending with -a are the only things the grammar-
ian needs to know, in order to use the func-
tion nGolova. Implementation details (the in-
flection table) are hidden. The name nGolova
is actually a transliteration of the Russian word
zo✓toea (head) that represents nouns conforming
to the pattern. Therefore, the grammarian can just
compare a new word to the word zo✓toea in or-
der to decide whether nGolova is appropriate.
For example, we can define the word mashina
(maxina) corresponding to the English word car.
Maxina is a feminine, inanimate noun ending
with -a. Therefore, a new lexical entry for the
word maxina can be defined by:
oper mashina = nGolova &amp;quot;maxina&amp;quot; ;
Access via type signature becomes especially
helpful with more complex parts of speech like
verbs.
Lexicon and inflectional paradigms are
language-specific, although, an attempt to build
</bodyText>
<page confidence="0.992007">
477
</page>
<bodyText confidence="0.999844035714286">
a general-purpose interlingua lexicon in GF has
been made. Multilingual dictionary can work
for words denoting unique objects like the sun
etc., but otherwise, having a common lexicon
interface does not sound like a very good idea or
at least something one would like to start with.
Normally, multilingual dictionaries have bilingual
organization (Kellogg, 2005).
At the moment the resource grammar has an
interlingua dictionary for, so called, closed word
classes like pronouns, prepositions, conjunctions
and numerals. But even there, a number of dis-
crepancies occurs. For example, the impersonal
pronoun one (OnePron) has no direct corre-
spondence in Russian. Instead, to express the
same meaning Russian uses the infinitive: esli
oqenь zahotetь, moжno v kosmos uletetь
(if one really wants, one can fly into the space).
Note, that the modal verb can is transformed
into the adverb moжno (it is possible). The
closest pronoun to one is the personal pronoun
ty (you), which is omitted in the final sen-
tence: esli oqenь zahoqexь, moжexь v kos-
mos uletetь. The Russian implementation of
OnePron uses the later construction, skipping the
string (s), but preserving number (n), person (p)
and animacy (anim) parameters, which are nec-
essary for agreement:
</bodyText>
<equation confidence="0.986538">
oper OnePron: Pronoun = {
s = &amp;quot;&amp;quot;;
n = Singular;
p = P2;
anim = Animate };
</equation>
<sectionHeader confidence="0.993305" genericHeader="method">
4 Syntax
</sectionHeader>
<bodyText confidence="0.999739966666667">
Syntax modules describe rules for combining
words into phrases and sentences. Designing a
language-independent syntax API is the most dif-
ficult part: several revisions have been made as the
resource coverage has grown. Russian is very dif-
ferent from other resource languages, therefore, it
sometimes fits poorly into the common API.
Several factors have influenced the API struc-
ture so far: application domains, parsing algo-
rithms and supported languages. In general, the
resource syntax is built bottom-up, starting with
rules for forming noun phrases and verb phrases,
continuing with relative clauses, questions, imper-
atives, and coordination. Some textual and dia-
logue features might be added, such as contrast-
ing, topicalization, and question-answer relations.
On the way from dictionary entries towards
complete sentences, categories loose declension
forms and, consequently, get more parameters that
”memorize” what forms are kept, which is neces-
sary to arrange agreement later on. Closer to the
end of the journey string fields are getting longer
as types contain more complex phrases, while pa-
rameters are used for agreement and then left be-
hind. Sentence types are the ultimate types that
just contain one string and no parameters, since
everything is decided and agreed on by that point.
Let us take a look at Russian nouns as an exam-
ple. A noun lexicon entry type (CN) mentioned in
section 3 is defined like the following:
</bodyText>
<equation confidence="0.584313571428572">
param
SubstForm = SF Number Case;
oper
CN: Type = {
s: SubstForm =&gt; Str;
g: Gender;
anim: Animacy };
</equation>
<bodyText confidence="0.998286571428571">
As we have seen in section 3, the string table field
s contains twelve forms. On the other hand, to
use a noun in a sentence we need only one form
and several parameters for agreement. Thus, the
ultimate noun type to be used in a sentence as an
object or a subject looks more like Noun Phrase
(NP):
</bodyText>
<listItem confidence="0.999179142857143">
oper NP : Type = {
s: Case =&gt; Str;
Agreement: {
n: Number;
p: Person;
g: Gender;
anim: Animacy} };
</listItem>
<bodyText confidence="0.9972564">
which besides Gender and Animacy also con-
tains Number and Person parameters (defined
in section 2), while the table field s only contains
six forms: one for each Case value.
The transition from CN to NP can be done via
various intermediate types. A noun can get modi-
fiers like adjectives – krasnax komnata (the red
room), determiners – mnogo xuma (much ado),
genitive constructions – gerou` naxego vremeni
(a hero of our time), relative phrases – qelovek,
kotory7 smeetssr (the man who laughs). Thus,
the string field (s) can eventually contain more
than one word. A noun can become a part of other
phrases, e.g. a predicate in a verb phrase – znanie
– sila (knowledge is power) or a complement
</bodyText>
<page confidence="0.99525">
478
</page>
<bodyText confidence="0.990134666666667">
in a prepositional phrase – za reko�, v teni
derevьev (across the river and into the trees).
The language-independent API has an hierarchy
of intermediate types all the way from dictionary
entries to sentences. All supported languages fol-
low this structure, although in some cases this does
not happen naturally. For example, the division
between definite and indefinite noun phrases is not
relevant for Russian, since Russian does not have
any articles, while being an important issue about
nouns in many European languages. The common
API contains functions supporting such division,
which are all conflated into one in the Russian im-
plementation. This is a simple case, where Rus-
sian easily fits into the common API, although a
corresponding phenomenon does not really exist.
Sometimes, a problem does not arise until the
joining point, where agreement has to be made.
For instance, in Russian, numeral modification
uses different cases to form a noun phrase in nom-
inative case: tri tovariwa (three comrades),
where the noun is in nominative, but p9ftь to-
variweu` (five comrades), where the noun is in
genitive! Two solutions are possible. An extra
non-linguistic parameter bearing the semantics of
a numeral can be included in the Numeral type.
Alternatively, an extra argument (NumberVal),
denoting the actual number value, can be in-
troduced into the numeral modification function
(IndefNumNP) to tell apart numbers with the last
digit between 2 and 4 from other natural numbers:
oper IndefNumNP: NumberVal -&gt;
Numeral -&gt; CN -&gt; NP;
Unfortunately, this would require changing
the language-independent API (adding the
NumberVal argument) and consequent adjust-
ments in all other languages that do not need
this information. Note, that IndefNumNP,
Numeral, CN (Common Noun) and NP (Noun
Phrase) belong to the language-independent
API, i.e. they have different implementations in
different languages. We prefer the encapsulation
version, since the other option will make the
function more error-prone.
Nevertheless, one can argue for both solutions,
which is rather typical while designing a com-
mon interface. One has to decide what should
be kept language-specific and what belongs to the
language-independent API. Often this decision is
more or less a matter of taste. Since Russian is
not the main language in the GF resource library,
the tendency is to keep things language-specific at
least until the common API becomes too restric-
tive for a representative number of languages.
The example above demonstrates a syntactic
construction, which exist both in the language-
independent API and in Russian although the com-
mon version is not as universal as expected. There
are also cases, where Russian structures are not
present in the common interface at all, since there
is no direct analogy in other supported languages.
For instance, a short adjective form is used in
phrases like mne nuжna pomowь (I need help)
and eii interesno iskusstvo (she is interested
in art). In Russian, the expressions do not have
any verb, so they sound like to me needed help
and to her interesting art, respectively. Here is the
function predShortAdj describing such adjec-
tive predication2 specific to Russian:
</bodyText>
<equation confidence="0.996845333333333">
oper predShortAdj: NP -&gt; Adj -&gt;
NP -&gt; S = \I, Needed, Help -&gt; {
s = let {
toMe = I.s ! Dat;
needed = Needed.s !
AF Short Help.g Help.n;
help = Help.s ! Nom
} in
toMe ++ needed ++ help };
</equation>
<bodyText confidence="0.999990318181818">
predShortAdj takes three arguments: a non-
degree adjective (Adj) and two noun phrases (NP)
that work as a predicate, a subject and an object in
the returned sentence (S). The third line indicates
that the arguments will be denoted as Needed, I
and Help, respectively (A-abstraction). The sen-
tence type (S) only contains one string field s. The
construction let...in is used to first form the
individual words (toMe, needed and help) to
put them later into a sentence. Each word is pro-
duced by taking appropriate forms from inflection
tables of corresponding arguments (Needed.s,
Help.s and I.s). In the noun arguments I
and Help dative and nominative cases, respec-
tively, are taken (!-sign denotes the selection op-
eration). The adjective Needed agrees with the
noun Help, so Help’s gender (g) and number
(n) are used to build an appropriate adjective form
(AF Short Help.g Help.n). This is ex-
actly where we finally use the parameters from
Help argument of the type NP defined above.
We only use the declension tables from the argu-
</bodyText>
<footnote confidence="0.9973245">
2In this example we disregard adjective past/future tense
markers bylo/budet.
</footnote>
<page confidence="0.998558">
479
</page>
<bodyText confidence="0.9992176">
ments I and Needed – other parameters are just
thrown away. Note, that predShortAdj uses
the type Adj for non-degree adjectives instead of
AdjDegree presented in section 2. We also use
the Short adjective form as an extra Case-value.
</bodyText>
<sectionHeader confidence="0.809007" genericHeader="method">
5 An Example Application Grammar
</sectionHeader>
<bodyText confidence="0.998415111111111">
The purpose of the example is to show similarities
between the same grammar written for different
languages using the resource library. Such similar-
ities increase the reuse of previously written code
across languages: once written for one language
a grammar can be ported to another language
relatively easy and fast. The more language-
independent API functions (names conventionally
starting with a capital letter) a grammar contains,
the more efficient the porting becomes.
We will consider a fragment of Health – a
small phrase-book grammar written using the re-
source grammar library in English, French, Ital-
ian, Swedish and Russian. It can form phrases like
she has a cold and she needs a painkiller. The fol-
lowing categories (cat) and functions (fun) con-
stitute language-independent abstract syntax (do-
main semantics):
</bodyText>
<table confidence="0.956684666666667">
cat
Patient; Condition;
Medicine; Prop;
fun
ShePatient: Patient;
CatchCold: Condition;
PainKiller: Medicine;
BeInCondition: Patient -&gt;
Condition -&gt; Prop;
NeedMedicine: Patient -&gt;
Medicine -&gt; Prop;
And: Prop -&gt; Prop -&gt; Prop;
</table>
<bodyText confidence="0.970656">
Abstract syntax determines the class of statements
we are able to build with the grammar. The cat-
egory Prop denotes complete propositions like
she has a cold. We also have separate categories
of smaller units like Patient, Medicine and
Condition. To produce a proposition one can,
for instance, use the function BeInCondition,
which takes two arguments of the types Patient
and Condition and returns the result of the type
Prop. For example, we can form the phrase she
has a cold by combining three functions above:
BeInCondition
ShePatient CatchCold
where ShePatient and CatchCold are
constants used as arguments to the function
BeInCondition.
Concrete syntax translates abstract syntax into
natural language strings. Thus, concrete syntax is
language-specific. However, having the language-
independent resource API helps to make even a
part of concrete syntax shared among the lan-
guages:
</bodyText>
<equation confidence="0.996596111111111">
lincat
Patient = NP;
Condition = VP;
Medicine = CN;
Prop = S;
lin
And = ConjS;
ShePatient = SheNP;
BeInCondition = PredVP;
</equation>
<bodyText confidence="0.999871">
The first group (lincat) tells that the semantic
categories Patient, Condition, Medicine
and Prop are expressed by the resource linguis-
tic categories: noun phrase (NP), verb phrase
(VP), common noun (CN) and sentence (S), re-
spectively. The second group (lin) tells that the
function And is the same as the resource coordina-
tion function ConjS, the function ShePatient
is expressed by the resource pronoun SheNP
and the function BeInCondition is expressed
by the resource function PredVP (the classic
NP VP-&gt;S rule). Exactly the same rules work for
all five languages, which makes the porting triv-
ial3. However, this is not always the case.
Writing even a small grammar in an inflection-
ally rich language like Russian requires a lot of
work on morphology. This is the part where us-
ing the resource grammar library may help, since
resource functions for adding new lexical entries
are relatively easy to use. For instance, the word
painkiller is defined similarly in five languages by
taking a corresponding basic word form as an ar-
gument to an inflection paradigm function:
</bodyText>
<table confidence="0.996412166666667">
-- English:
PainKiller = regN &amp;quot;painkiller&amp;quot;;
-- French:
PainKiller = regN &amp;quot;calmant&amp;quot;;
-- Italian:
PainKiller = regN &amp;quot;calmante&amp;quot;;
</table>
<footnote confidence="0.9166335">
3Different languages can actually share the same code us-
ing GF parameterized modules (Ranta, to appear)
</footnote>
<page confidence="0.984432">
480
</page>
<table confidence="0.4973828">
pat (IndefOneNP med);
-- Swedish:
PainKiller = regGenN
&amp;quot;sm¨artstillande&amp;quot; Neut;
-- Russian:
</table>
<bodyText confidence="0.998779923076923">
PainKiller = nEe &amp;quot;o6e36oJI Haiomee&amp;quot;;
The Gender parameter (Neut) is provided for
Swedish.
In the remaining functions we see bigger dif-
ferences: the idiomatic expressions I have a cold
in French, Swedish and Russian is formed by ad-
jective predication, while a transitive verb con-
struction is used in English and Italian. There-
fore, different functions (PosA and PosTV) are
applied. tvHave and tvAvere denote transitive
verb to have in English and Italian, respectively.
IndefOneNP is used for forming an indefinite
noun phrase from a noun in English and Italian:
</bodyText>
<equation confidence="0.751873428571429">
-- English:
CatchCold = PosTV tvHave
(IndefOneNP (regN &amp;quot;cold&amp;quot;));
-- Italian:
CatchCold = PosTV tvAvere
(IndefOneNP (regN &amp;quot;raffreddore&amp;quot;));
-- French:
CatchCold = PosA (regA &amp;quot;enrhum´e&amp;quot;)
-- Swedish:
CatchCold = PosA
(mk2A &amp;quot;f¨orkyld&amp;quot; &amp;quot;f¨orkylt&amp;quot;);
-- Russian:
CatchCold = PosA
(adj yj &amp;quot;HpocTyxceH&amp;quot;);
</equation>
<bodyText confidence="0.987427047619048">
In the next example the Russian version is rather
different from the other languages. The phrase
I need a painkiller is a transitive verb predica-
tion together with complementation rule in En-
glish and Swedish. In French and Italian we need
to use the idiomatic expressions avoir besoin and
aver bisogno. Therefore, a classic NP VP rule
(PredVP) is used. In Russian the same meaning
is expressed by using adjective predication defined
in section 4:
--English:
NeedMedicine pat med = predV2
(dirV2 (regV &amp;quot;need&amp;quot;))
-- Swedish:
NeedMedicine pat med = predV2
(dirV2 (regV &amp;quot;beh¨over&amp;quot;))
pat (DetNP nullDet med);
-- French:
NeedMedicine pat med = PredVP
pat (avoirBesoin med);
-- Italian:
NeedMedicine pat med = PredVP
pat (averBisogno med);
-- Russian:
NeedMedicine pat med =
predShortAdj pat
(adj yj &amp;quot;HyxceH&amp;quot;) med;
Note, that the medicine argument (med) is used
with indefinite article in the English version
(IndefOneNP), but without articles in Swedish,
French and Italian. As we have mentioned
in section 4, Russian does not have any arti-
cles, although the corresponding operations ex-
ist for the sake of consistency with the language-
independent API.
Health grammar shows that the more similar
languages are, the easier porting will be. How-
ever, as with traditional translation the grammar-
ian needs to know the target language, since it is
not clear whether a particular construction is cor-
rect in both languages, especially, when the lan-
guages seem to be very similar in general.
</bodyText>
<sectionHeader confidence="0.999249" genericHeader="conclusions">
6 Conclusion
</sectionHeader>
<bodyText confidence="0.999923785714286">
GF resource grammars are general-purpose gram-
mars used as a basis for building domain-specific
application grammars. Among pluses of using
such grammar library are guaranteed grammatical-
ity, code reuse (both within and across languages)
and higher abstraction level for writing application
grammars. According to the ”division of labor”
principle, resource grammars comprise the nec-
essary linguistic knowledge allowing application
grammarians to concentrate on domain semantics.
Following Chomsky’s universal grammar hy-
pothesis (Chomsky, 1981), GF multilingual re-
source grammars maintain a common API for all
supported languages. This is implemented using
</bodyText>
<page confidence="0.996356">
481
</page>
<bodyText confidence="0.999932958333334">
GF’s mechanism of separating between abstract
and concrete syntax. Abstract syntax declares uni-
versal principles, while language-specific parame-
ters are set in concrete syntax. We are not trying to
answer the general question what constitutes uni-
versal grammar and what beyond universal gram-
mar differentiates languages from one another. We
look at GF parallel resource grammars as a way to
simplify multilingual applications.
The implementation of the Russian resource
grammar proves that GF grammar formalism al-
lows us to use the language-independent API for
describing sometimes rather peculiar grammatical
variations in different languages. However, main-
taining parallelism across languages has its lim-
its. From the beginning we were trying to put as
much as possible into a common interface, shared
among all the supported languages. Word classes
seem to be rather universal at least for the eleven
supported languages. Syntactic types and some
combination rules are more problematic. For ex-
ample, some Russian rules only make sense as
a part of language-specific modules while some
rules that were considered universal at first are not
directly applicable to Russian.
Having a universal resource API and grammars
for other languages has made developing Rus-
sian grammar much easier comparing to doing it
from scratch. The abstract syntax part was simply
reused. Some concrete syntax implementations
like adverb description, coordination and subor-
dination required only minor changes. Even for
more language-specific rules it helps a lot to have
a template implementation that demonstrates what
kind of phenomena should be taken into account.
The GF resource grammar development is
mostly driven by application domains like soft-
ware specifications (Burke and Johannisson,
2005), math problems (Caprotti, 2006) or trans-
port network dialog systems (Bringert et al.,
2005). The structure of the resource grammar li-
brary is continually influenced by new domains
and languages. The possible direction of GF par-
allel resource grammars’ development is extend-
ing the universal interface by domain-specific and
language-specific parts. Such adaptation seems to
be necessary as the coverage of GF resource gram-
mars grows.
</bodyText>
<sectionHeader confidence="0.992143" genericHeader="acknowledgments">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.9998854">
Thanks to Professor Arto Mustajoki for fruitful
discussions and to Professor Robin Cooper for
reading and editing the final version of the paper.
Special thanks to Professor Aarne Ranta, my su-
pervisor and the creator of GF.
</bodyText>
<sectionHeader confidence="0.999192" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999937476190476">
B. Bringert, R. Cooper, P. Ljungl¨of, and A. Ranta.
2005. Multimodal Dialogue System Grammars. In
DIALOR’05, Nancy, France.
D.A. Burke and K. Johannisson. 2005. Translating
Formal Software Specifications to Natural Language
/ A Grammar-Based Approach. In LACL 2005,
LNAI 3402, pages 51–66. Springer.
M. Butt, T. H. King, M.-E. Ni no, and F. Segond, edi-
tors. 1999. A Grammar Writer’s Cookbook. Stan-
ford: CSLI Publications.
O. Caprotti. 2006. WebALT! Deliver Mathematics Ev-
erywhere. In SITE 2006, Orlando, USA.
N. Chomsky. 1981. Lectures on Government and
Binding: The Pisa Lectures. Dordrecht, Holland:
Foris Publications.
A. E. Dada and A. Ranta. 2006. Implement-
ing an arabic resource grammar in grammatical
framework. At 20th Arabic Linguistics Sym-
posium, Kalamazoo, Michigan. URL: www.md
stud.chalmers.se/˜eldada/paper.pdf.
M. Forsberg and A. Ranta. 2004. Functional morphol-
ogy. In ICFP’04, pages 213–223. ACM Press.
M. Kellogg. 2005. Online french, italian and spanish
dictionary. URL: www.wordreference.com.
C. Pollard and I. Sag. 1994. Head-Driven Phrase
Structure Grammar. University of Chicago Press.
A. Ranta. 2004. Grammatical Framework: A Type-
theoretical Grammar Formalism. The Journal of
Functional Programming, 14(2):145–189.
A. Ranta. to appear. Modular Grammar Engineer-
ing in GF. Research in Language and Computa-
tion. URL: www.cs.chalmers.se/˜aarne/
articles/ar-multieng.pdf
M. Rayner, D. Carter, P. Bouillon, V. Digalakis, and
M. Wir´en. 2000. The spoken language translator.
Cambridge University Press.
M.A. Shelyakin. 2000. Spravochnik po russkoj gram-
matike (in Russian). Russky Yazyk, Moscow.
S. Starostin. 2005. Russian morpho-engine on-line.
URL:starling.rinet.ru/morph.htm.
T. Wade. 2000. A Comprehensive Russian Grammar.
Blackwell Publishing.
</reference>
<page confidence="0.998467">
482
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.943000">
<title confidence="0.994935">GF Parallel Resource Grammars and Russian</title>
<author confidence="0.999968">Janna Khegai</author>
<affiliation confidence="0.999874">Department of Computer Science Chalmers University of Technology</affiliation>
<address confidence="0.997885">SE-41296 Gothenburg, Sweden</address>
<email confidence="0.991673">janna@cs.chalmers.se</email>
<abstract confidence="0.99733875">A resource grammar is a standard library for the GF grammar formalism. It raises the abstraction level of writing domainspecific grammars by taking care of the general grammatical rules of a language. GF resource grammars have been built in parallel for eleven languages and share a common interface, which simplifies multilingual applications. We reflect on our experience with the Russian resource grammar trying to answer the questions: how well Russian fits into the common interface and where the line between languageindependent and language-specific should be drawn.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>B Bringert</author>
<author>R Cooper</author>
<author>P Ljungl¨of</author>
<author>A Ranta</author>
</authors>
<title>Multimodal Dialogue System Grammars.</title>
<date>2005</date>
<booktitle>In DIALOR’05,</booktitle>
<location>Nancy, France.</location>
<marker>Bringert, Cooper, Ljungl¨of, Ranta, 2005</marker>
<rawString>B. Bringert, R. Cooper, P. Ljungl¨of, and A. Ranta. 2005. Multimodal Dialogue System Grammars. In DIALOR’05, Nancy, France.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D A Burke</author>
<author>K Johannisson</author>
</authors>
<title>Translating Formal Software Specifications to Natural Language / A Grammar-Based Approach.</title>
<date>2005</date>
<booktitle>In LACL 2005, LNAI 3402,</booktitle>
<pages>51--66</pages>
<publisher>Springer.</publisher>
<contexts>
<context position="28420" citStr="Burke and Johannisson, 2005" startWordPosition="4552" endWordPosition="4555">plicable to Russian. Having a universal resource API and grammars for other languages has made developing Russian grammar much easier comparing to doing it from scratch. The abstract syntax part was simply reused. Some concrete syntax implementations like adverb description, coordination and subordination required only minor changes. Even for more language-specific rules it helps a lot to have a template implementation that demonstrates what kind of phenomena should be taken into account. The GF resource grammar development is mostly driven by application domains like software specifications (Burke and Johannisson, 2005), math problems (Caprotti, 2006) or transport network dialog systems (Bringert et al., 2005). The structure of the resource grammar library is continually influenced by new domains and languages. The possible direction of GF parallel resource grammars’ development is extending the universal interface by domain-specific and language-specific parts. Such adaptation seems to be necessary as the coverage of GF resource grammars grows. Acknowledgements Thanks to Professor Arto Mustajoki for fruitful discussions and to Professor Robin Cooper for reading and editing the final version of the paper. Sp</context>
</contexts>
<marker>Burke, Johannisson, 2005</marker>
<rawString>D.A. Burke and K. Johannisson. 2005. Translating Formal Software Specifications to Natural Language / A Grammar-Based Approach. In LACL 2005, LNAI 3402, pages 51–66. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Butt</author>
<author>T H</author>
</authors>
<title>A Grammar Writer’s Cookbook.</title>
<date>1999</date>
<editor>King, M.-E. Ni no, and F. Segond, editors.</editor>
<publisher>CSLI Publications.</publisher>
<location>Stanford:</location>
<marker>Butt, H, 1999</marker>
<rawString>M. Butt, T. H. King, M.-E. Ni no, and F. Segond, editors. 1999. A Grammar Writer’s Cookbook. Stanford: CSLI Publications.</rawString>
</citation>
<citation valid="true">
<authors>
<author>O Caprotti</author>
</authors>
<title>WebALT! Deliver Mathematics Everywhere.</title>
<date>2006</date>
<booktitle>In SITE 2006,</booktitle>
<location>Orlando, USA.</location>
<contexts>
<context position="28452" citStr="Caprotti, 2006" startWordPosition="4558" endWordPosition="4559">rce API and grammars for other languages has made developing Russian grammar much easier comparing to doing it from scratch. The abstract syntax part was simply reused. Some concrete syntax implementations like adverb description, coordination and subordination required only minor changes. Even for more language-specific rules it helps a lot to have a template implementation that demonstrates what kind of phenomena should be taken into account. The GF resource grammar development is mostly driven by application domains like software specifications (Burke and Johannisson, 2005), math problems (Caprotti, 2006) or transport network dialog systems (Bringert et al., 2005). The structure of the resource grammar library is continually influenced by new domains and languages. The possible direction of GF parallel resource grammars’ development is extending the universal interface by domain-specific and language-specific parts. Such adaptation seems to be necessary as the coverage of GF resource grammars grows. Acknowledgements Thanks to Professor Arto Mustajoki for fruitful discussions and to Professor Robin Cooper for reading and editing the final version of the paper. Special thanks to Professor Aarne </context>
</contexts>
<marker>Caprotti, 2006</marker>
<rawString>O. Caprotti. 2006. WebALT! Deliver Mathematics Everywhere. In SITE 2006, Orlando, USA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>N Chomsky</author>
</authors>
<title>Lectures on Government and Binding: The Pisa Lectures.</title>
<date>1981</date>
<publisher>Foris Publications.</publisher>
<location>Dordrecht, Holland:</location>
<contexts>
<context position="26522" citStr="Chomsky, 1981" startWordPosition="4268" endWordPosition="4269">y, when the languages seem to be very similar in general. 6 Conclusion GF resource grammars are general-purpose grammars used as a basis for building domain-specific application grammars. Among pluses of using such grammar library are guaranteed grammaticality, code reuse (both within and across languages) and higher abstraction level for writing application grammars. According to the ”division of labor” principle, resource grammars comprise the necessary linguistic knowledge allowing application grammarians to concentrate on domain semantics. Following Chomsky’s universal grammar hypothesis (Chomsky, 1981), GF multilingual resource grammars maintain a common API for all supported languages. This is implemented using 481 GF’s mechanism of separating between abstract and concrete syntax. Abstract syntax declares universal principles, while language-specific parameters are set in concrete syntax. We are not trying to answer the general question what constitutes universal grammar and what beyond universal grammar differentiates languages from one another. We look at GF parallel resource grammars as a way to simplify multilingual applications. The implementation of the Russian resource grammar prove</context>
</contexts>
<marker>Chomsky, 1981</marker>
<rawString>N. Chomsky. 1981. Lectures on Government and Binding: The Pisa Lectures. Dordrecht, Holland: Foris Publications.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A E Dada</author>
<author>A Ranta</author>
</authors>
<title>Implementing an arabic resource grammar in grammatical framework.</title>
<date>2006</date>
<booktitle>At 20th Arabic Linguistics Symposium,</booktitle>
<location>Kalamazoo, Michigan. URL:</location>
<note>www.md stud.chalmers.se/˜eldada/paper.pdf.</note>
<contexts>
<context position="7819" citStr="Dada and Ranta, 2006" startWordPosition="1214" endWordPosition="1217">s the name of 1The English -er/more and -est/most variations are exclusive, while in Russian both forms are valid. 476 a part of speech. A possible complication is that parsing with inflectionally rich languages can be less efficient compared to, for instance, English. This is because in GF all forms of a word are kept in the same declension table, which is convenient for generation, since GF is a generation-oriented grammar formalism. Therefore, the more forms there are, the bigger tables we have to store in memory, which can become an issue as the grammars grow and more languages are added (Dada and Ranta, 2006). 3 Inflection Paradigms and Lexicon Besides word class declarations, morphology modules also contain functions defining common inflectional patterns (paradigms) and a lexicon. This information is language-specific, so fitting into the common API is not a consideration here. Paradigms are used to build the lexicon incrementally as new words are used in applications. A lexicon can also be extracted from other sources. Unlike syntactic descriptions, morphological descriptions for many languages have been already developed in other projects. Thus, considerable efforts can be saved by reusing exis</context>
</contexts>
<marker>Dada, Ranta, 2006</marker>
<rawString>A. E. Dada and A. Ranta. 2006. Implementing an arabic resource grammar in grammatical framework. At 20th Arabic Linguistics Symposium, Kalamazoo, Michigan. URL: www.md stud.chalmers.se/˜eldada/paper.pdf.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Forsberg</author>
<author>A Ranta</author>
</authors>
<title>Functional morphology.</title>
<date>2004</date>
<booktitle>In ICFP’04,</booktitle>
<pages>213--223</pages>
<publisher>ACM Press.</publisher>
<contexts>
<context position="8689" citStr="Forsberg and Ranta, 2004" startWordPosition="1346" endWordPosition="1349">I is not a consideration here. Paradigms are used to build the lexicon incrementally as new words are used in applications. A lexicon can also be extracted from other sources. Unlike syntactic descriptions, morphological descriptions for many languages have been already developed in other projects. Thus, considerable efforts can be saved by reusing existing code. How easy we can perform the transformation depends on how similar the input and output formats are. For example, the Swedish morphology module is generated automatically from the code of another project, called Functional Morphology (Forsberg and Ranta, 2004). In this case the formats are very similar, so extracting is rather straightforward. However, this might not be the case if we build the lexicon from a very different representation or even from corpora, where postmodification by hand is simply inevitable. A paradigm function usually takes one or more string arguments and forms a lexical entry. For example, the function nGolova describes the inflectional pattern for feminine inanimate nouns ending with -a in Russian. It takes the basic form of a word as a string (Str) and returns a noun (CN stands for Common Noun, see definition in section 4)</context>
</contexts>
<marker>Forsberg, Ranta, 2004</marker>
<rawString>M. Forsberg and A. Ranta. 2004. Functional morphology. In ICFP’04, pages 213–223. ACM Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Kellogg</author>
</authors>
<title>Online french, italian and spanish dictionary.</title>
<date>2005</date>
<location>URL: www.wordreference.com.</location>
<contexts>
<context position="11815" citStr="Kellogg, 2005" startWordPosition="1886" endWordPosition="1887"> maxina can be defined by: oper mashina = nGolova &amp;quot;maxina&amp;quot; ; Access via type signature becomes especially helpful with more complex parts of speech like verbs. Lexicon and inflectional paradigms are language-specific, although, an attempt to build 477 a general-purpose interlingua lexicon in GF has been made. Multilingual dictionary can work for words denoting unique objects like the sun etc., but otherwise, having a common lexicon interface does not sound like a very good idea or at least something one would like to start with. Normally, multilingual dictionaries have bilingual organization (Kellogg, 2005). At the moment the resource grammar has an interlingua dictionary for, so called, closed word classes like pronouns, prepositions, conjunctions and numerals. But even there, a number of discrepancies occurs. For example, the impersonal pronoun one (OnePron) has no direct correspondence in Russian. Instead, to express the same meaning Russian uses the infinitive: esli oqenь zahotetь, moжno v kosmos uletetь (if one really wants, one can fly into the space). Note, that the modal verb can is transformed into the adverb moжno (it is possible). The closest pronoun to one is the personal pronoun ty </context>
</contexts>
<marker>Kellogg, 2005</marker>
<rawString>M. Kellogg. 2005. Online french, italian and spanish dictionary. URL: www.wordreference.com.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Pollard</author>
<author>I Sag</author>
</authors>
<title>Head-Driven Phrase Structure Grammar.</title>
<date>1994</date>
<publisher>University of Chicago Press.</publisher>
<contexts>
<context position="2068" citStr="Pollard and Sag, 1994" startWordPosition="299" endWordPosition="302">Interface (API) from corresponding language-specific implementations. Consulting the abstract part is sufficient for writing an application grammar without descending to implementation details. This approach raises the level of application grammar development and supports multilinguality, thus, providing both linguistic and computational advantages. The current coverage is comparable with the Core Language Engine (CLE) project (Rayner et al., 2000). Other well-known multilingual general-purpose grammar projects that GF can be related to, are LFG grammars (Butt et al., 1999) and HPSG grammars (Pollard and Sag, 1994), although their parsing-oriented unificationbased formalisms are very different from the GF generation-oriented type-theoretical formalism (Ranta, 2004). A Russian resource grammar was added after similar grammars for English, Swedish, French and German (Arabic, Italian, Finnish, Norwegian, Danish and Spanish are also supported in GF). A language-independent API representing the coverage of the resource library, therefore, was already available. The task was to localize modules for Russian. A resource grammar has morphological and syntactic modules. Morphological modules include a description</context>
</contexts>
<marker>Pollard, Sag, 1994</marker>
<rawString>C. Pollard and I. Sag. 1994. Head-Driven Phrase Structure Grammar. University of Chicago Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Ranta</author>
</authors>
<title>Grammatical Framework: A Typetheoretical Grammar Formalism.</title>
<date>2004</date>
<journal>The Journal of Functional Programming,</journal>
<volume>14</volume>
<issue>2</issue>
<contexts>
<context position="807" citStr="Ranta, 2004" startWordPosition="118" endWordPosition="119">r is a standard library for the GF grammar formalism. It raises the abstraction level of writing domainspecific grammars by taking care of the general grammatical rules of a language. GF resource grammars have been built in parallel for eleven languages and share a common interface, which simplifies multilingual applications. We reflect on our experience with the Russian resource grammar trying to answer the questions: how well Russian fits into the common interface and where the line between languageindependent and language-specific should be drawn. 1 Introduction Grammatical Framework (GF) (Ranta, 2004) is a grammar formalism designed in particular to serve as an interlingua platform for natural language applications in sublanguage domains. A domain can be described using the GF grammar formalism and then processed by GF. Such descriptions are called application grammars. A resource grammar (Ranta, to appear) is a general-purpose grammar that forms a basis for application grammars. Resource grammars have so far been implemented for eleven languages in parallel. The structural division into abstract and concrete descriptions, advocated in GF, is used to separate the language-independent commo</context>
<context position="2221" citStr="Ranta, 2004" startWordPosition="319" endWordPosition="320">ing to implementation details. This approach raises the level of application grammar development and supports multilinguality, thus, providing both linguistic and computational advantages. The current coverage is comparable with the Core Language Engine (CLE) project (Rayner et al., 2000). Other well-known multilingual general-purpose grammar projects that GF can be related to, are LFG grammars (Butt et al., 1999) and HPSG grammars (Pollard and Sag, 1994), although their parsing-oriented unificationbased formalisms are very different from the GF generation-oriented type-theoretical formalism (Ranta, 2004). A Russian resource grammar was added after similar grammars for English, Swedish, French and German (Arabic, Italian, Finnish, Norwegian, Danish and Spanish are also supported in GF). A language-independent API representing the coverage of the resource library, therefore, was already available. The task was to localize modules for Russian. A resource grammar has morphological and syntactic modules. Morphological modules include a description of word classes, inflectional paradigms and a lexicon. Syntactic modules comprise a description of phrasal structures for analyzing bigger than one-word</context>
<context position="8689" citStr="Ranta, 2004" startWordPosition="1348" endWordPosition="1349">nsideration here. Paradigms are used to build the lexicon incrementally as new words are used in applications. A lexicon can also be extracted from other sources. Unlike syntactic descriptions, morphological descriptions for many languages have been already developed in other projects. Thus, considerable efforts can be saved by reusing existing code. How easy we can perform the transformation depends on how similar the input and output formats are. For example, the Swedish morphology module is generated automatically from the code of another project, called Functional Morphology (Forsberg and Ranta, 2004). In this case the formats are very similar, so extracting is rather straightforward. However, this might not be the case if we build the lexicon from a very different representation or even from corpora, where postmodification by hand is simply inevitable. A paradigm function usually takes one or more string arguments and forms a lexical entry. For example, the function nGolova describes the inflectional pattern for feminine inanimate nouns ending with -a in Russian. It takes the basic form of a word as a string (Str) and returns a noun (CN stands for Common Noun, see definition in section 4)</context>
</contexts>
<marker>Ranta, 2004</marker>
<rawString>A. Ranta. 2004. Grammatical Framework: A Typetheoretical Grammar Formalism. The Journal of Functional Programming, 14(2):145–189.</rawString>
</citation>
<citation valid="false">
<authors>
<author>A Ranta</author>
</authors>
<title>to appear. Modular Grammar Engineering in GF.</title>
<booktitle>Research in Language and Computation. URL: www.cs.chalmers.se/˜aarne/ articles/ar-multieng.pdf</booktitle>
<marker>Ranta, </marker>
<rawString>A. Ranta. to appear. Modular Grammar Engineering in GF. Research in Language and Computation. URL: www.cs.chalmers.se/˜aarne/ articles/ar-multieng.pdf</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Rayner</author>
<author>D Carter</author>
<author>P Bouillon</author>
<author>V Digalakis</author>
<author>M Wir´en</author>
</authors>
<title>The spoken language translator.</title>
<date>2000</date>
<publisher>Cambridge University Press.</publisher>
<marker>Rayner, Carter, Bouillon, Digalakis, Wir´en, 2000</marker>
<rawString>M. Rayner, D. Carter, P. Bouillon, V. Digalakis, and M. Wir´en. 2000. The spoken language translator. Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M A Shelyakin</author>
</authors>
<title>Spravochnik po russkoj grammatike (in Russian). Russky Yazyk,</title>
<date>2000</date>
<location>Moscow.</location>
<contexts>
<context position="4020" citStr="Shelyakin, 2000" startWordPosition="586" endWordPosition="587">–482, Sydney, July 2006. c�2006 Association for Computational Linguistics demonstrate the library usage in a sample application grammar. 2 Word Classes Every resource grammar starts with a description of word classes. Their names belong to the language-independent API, although their implementations are language-specific. Russian fits quite well into the common API here, since like all other languages it has nouns, verbs, adjectives etc. The type system for word classes of a language is the most stable part of the resource grammar library, since it follows traditional linguistic descriptions (Shelyakin, 2000; Wade, 2000; Starostin, 2005). For example, let us look at the implementation of the Russian adjective type AdjDegree: param Degree = Pos |Comp |Super; Case = Nom|Gen|Dat|Acc|Inst|Prep; Animacy = Animate |Inanimate; Gender = Masc |Fem |Neut; GenNum = ASingular Gender|APlural; AdjForm = AF Case Animacy GenNum; oper AdjDegree : Type = {s : Degree =&gt; AdjForm =&gt; Str}; First, we need to specify parameters (param) on which inflection forms depend. A vertical slash (|) separates different parameter values. While in English the only parameter would be comparison degree (Degree), in Russian we have ma</context>
</contexts>
<marker>Shelyakin, 2000</marker>
<rawString>M.A. Shelyakin. 2000. Spravochnik po russkoj grammatike (in Russian). Russky Yazyk, Moscow.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Starostin</author>
</authors>
<date>2005</date>
<note>Russian morpho-engine on-line. URL:starling.rinet.ru/morph.htm.</note>
<contexts>
<context position="4050" citStr="Starostin, 2005" startWordPosition="590" endWordPosition="591">06 Association for Computational Linguistics demonstrate the library usage in a sample application grammar. 2 Word Classes Every resource grammar starts with a description of word classes. Their names belong to the language-independent API, although their implementations are language-specific. Russian fits quite well into the common API here, since like all other languages it has nouns, verbs, adjectives etc. The type system for word classes of a language is the most stable part of the resource grammar library, since it follows traditional linguistic descriptions (Shelyakin, 2000; Wade, 2000; Starostin, 2005). For example, let us look at the implementation of the Russian adjective type AdjDegree: param Degree = Pos |Comp |Super; Case = Nom|Gen|Dat|Acc|Inst|Prep; Animacy = Animate |Inanimate; Gender = Masc |Fem |Neut; GenNum = ASingular Gender|APlural; AdjForm = AF Case Animacy GenNum; oper AdjDegree : Type = {s : Degree =&gt; AdjForm =&gt; Str}; First, we need to specify parameters (param) on which inflection forms depend. A vertical slash (|) separates different parameter values. While in English the only parameter would be comparison degree (Degree), in Russian we have many more parameters: • Case, fo</context>
<context position="6070" citStr="Starostin, 2005" startWordPosition="920" endWordPosition="921"> big house – big houses). • Degree can be more complex, since most Russian adjectives have two comparative (Comp) forms: declinable attributive and indeclinable predicative1: bolee vysokiU (more high) – vyxe (higher), and more than one superlative (Super) forms: samyU vysokiU (the most high) – naivysxiU (the highest). Even another parameter can be added, since Russian adjectives in the positive (Pos) degree have long and short forms: spokou`nasf reka (the calm river) – reka – spokoUna (the river is calm). The short form has no case declension, thus, it can be considered as an additional case (Starostin, 2005). Note, that although the predicative usage of the long form is perfectly grammatical, it can have a slightly different meaning compared to the short form. For example: long, predicative on – bolьnou (”he is crazy”) vs. short, predicative on – bolen (”he is ill”). An oper judgement combines the name of the defined operation, its type, and an expression defining it. The type for degree adjective (AdjDegree) is a table of strings (s: .. =&gt; ..=&gt; Str) that has two main dimensions: Degree and AdjForm, where the last one is a combination of the parameters listed above. The reason to have the Degree </context>
</contexts>
<marker>Starostin, 2005</marker>
<rawString>S. Starostin. 2005. Russian morpho-engine on-line. URL:starling.rinet.ru/morph.htm.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Wade</author>
</authors>
<title>A Comprehensive Russian Grammar.</title>
<date>2000</date>
<publisher>Blackwell Publishing.</publisher>
<contexts>
<context position="4032" citStr="Wade, 2000" startWordPosition="588" endWordPosition="589">y 2006. c�2006 Association for Computational Linguistics demonstrate the library usage in a sample application grammar. 2 Word Classes Every resource grammar starts with a description of word classes. Their names belong to the language-independent API, although their implementations are language-specific. Russian fits quite well into the common API here, since like all other languages it has nouns, verbs, adjectives etc. The type system for word classes of a language is the most stable part of the resource grammar library, since it follows traditional linguistic descriptions (Shelyakin, 2000; Wade, 2000; Starostin, 2005). For example, let us look at the implementation of the Russian adjective type AdjDegree: param Degree = Pos |Comp |Super; Case = Nom|Gen|Dat|Acc|Inst|Prep; Animacy = Animate |Inanimate; Gender = Masc |Fem |Neut; GenNum = ASingular Gender|APlural; AdjForm = AF Case Animacy GenNum; oper AdjDegree : Type = {s : Degree =&gt; AdjForm =&gt; Str}; First, we need to specify parameters (param) on which inflection forms depend. A vertical slash (|) separates different parameter values. While in English the only parameter would be comparison degree (Degree), in Russian we have many more para</context>
</contexts>
<marker>Wade, 2000</marker>
<rawString>T. Wade. 2000. A Comprehensive Russian Grammar. Blackwell Publishing.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>