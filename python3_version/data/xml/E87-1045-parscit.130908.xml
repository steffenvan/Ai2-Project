<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<sectionHeader confidence="0.555911" genericHeader="abstract">
FRAGMENTATION AND PART OF SPEECH DISAMBIGUATION&apos;
</sectionHeader>
<bodyText confidence="0.2237275">
Jean-Louis Binot
B.I.M.
Kwilcstraat, 4
83078 Everberg, Belgium
</bodyText>
<sectionHeader confidence="0.696888" genericHeader="keywords">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.999038111111111">
That at least some syntax is necessary to support semantic process-
ing is fairly obvious. To know exactly how much syntax is needed,
however, and how and when to apply it, is still an open and crucial,
albeit old, question. This paper discusses the solutions used in a
semantic analyser of French called SABA, developed at the Uni-
versity of Liege, Belgium. Specifically, we shall argue in favor of the
usefulness of two syntactic processes: fragmentation, which can be
interleaved with semantic processing, and part-of-speech
disambiguation, which can be performed as a preprocessing step.
</bodyText>
<sectionHeader confidence="0.969754" genericHeader="introduction">
I. Introduction
</sectionHeader>
<bodyText confidence="0.997287277777778">
The role of syntax is one of these issues in natural language proc-
essing which, albeit old and often (hotly) debated, have yet to re-
ceive a definitive answer. (Lytinen 86) distinguishes two approaches
to NI, processing. Followers of the &amp;quot;modular&amp;quot; approach believe
usually in the autonomy of syntax and in the usefulness and cost-
effectiveness of a purely syntactic stage of processing. Results of this
approach include the development of new grammatical formalisms
(Weir et al. 86) (Ristad 86), and of large syntactic grammars (Jensen
et al. 86).
Followers of the &amp;quot;integrated&apos; approach, on the contrary, believe
that semantics should be used as soon as possible in the parsing
process. An &amp;quot;integrated&amp;quot; system would have no discernable stages
of parsing, and would build directly a meaning representation with-
out building an intermediate syntactic structure. How much syntax
is needed to support this semantic processing, however, and how
should the integration between syntax and semantics be done are
still open and crucial questions. Some integrated systems, such as
IPP (Schank et al. 80) and Wilks&apos; Preference Semantics system
(Wilks 75), were trying to reduce the role of syntax as much as
possible. Lytinen proposes a more moderate option in which sepa-
rate syntactic and semantic rules are dynamically combined at
parsing time. Another kind of integration is used in (Boguraev 79),
where an ATN is combined with Wilks&apos; style semantic procedures.
And, lastly, one might consider that unification-based grammars
(Shieber 86) offer yet another approach where syntactic and se-
mantic constraints can be specified simultaneously in functional
structures and satisfied in parallel.
The research presented in this paper was entirely performed while the
author was working at the Computer Sciences department of University
of I,iege, Belgium.
In this paper, we wish to present our arguments in favors of in-
tegration, and then to discuss two specific technical proposals. Our
general position can be stated as follows:
I. That at least some form of syntax is necessary for natural lan-
guage processing should be by now fairly obvious and should
need no further argumentation.
</bodyText>
<listItem confidence="0.755017466666667">
2. Syntax, however, is not a goal per se. The basic goal of NLP,
at least from the point of view of Al, is to give a computer a
way to &amp;quot;understand&amp;quot; natural language input, and this clearly
requires a semantic component. The utility or necessity of
syntax should only be evaluated in the light of the help it can
provide to this semantic component.
3. Grammaticality is not an essential issue, except in language
generation and in specific applications like CRITIQUE (Jensen
et al. 86), where the purpose is to correct the syntax and the
style of a writer. For the general task of understanding,
achieving comprehension, even in the face of incorrect or unu-
sual input, is more important than enforcing some grammatical
standards. And we believe that robustness is more easily
achieved in the context of a semantic system than in the pre-
dictive paradigm of the grammatical approach.
</listItem>
<bodyText confidence="0.9999734">
If we want to avoid the use of a full scale grammar, the syntactic
processes necessary to support the semantic module must be im-
plemented by special dedicated procedures. This paper describe the
solutions used in a semantic analyser of French called SABA, de-
veloped at the Computer Sciences department of University of
Liege, Belgium. Specifically, we shall argue in favor of two syntactic
processes: fragmentation, which can be interleaved with semantic
processing, and part of speech disambiguation, which is usefully
performed in a preprocessing step. We shall start by a brief de-
scription of the SABA system.
</bodyText>
<sectionHeader confidence="0.513607" genericHeader="method">
2. Overview of the SABA system.
</sectionHeader>
<bodyText confidence="0.991727444444444">
SABA (&amp;quot;Semantic Analyser, Backward Approach&amp;quot;, (Binot, 1985),
(Binot et al., 1986)) is a robust and portable semantic parser of
written French sentences. A prototype of this parser is running in
MACI,ISP and in ZETALISP; it has been tested successfully on a
corpus of about 125 French sentences. This system is not based
on a French grammar, but on semantic procedures which, with
some syntactic support, build directly a semantic dependency graph
from the natural language input. The following example is typical
of the level of complexity that can be handled by the system:
</bodyText>
<footnote confidence="0.43424225">
(I) Le pont que le convoi a passe quand il a quitie New York re
matin etait fort long.
(The bridge that the convoy crossed when it left New York
this morning was very long.)
</footnote>
<page confidence="0.997048">
284
</page>
<bodyText confidence="0.999496857142857">
To allow for portability, the SABA parser translates its natural
language input into an intermediate &amp;quot; semantic network formalism
called SF (for &amp;quot;Sentence Formalism&amp;quot;), presented in details in (Binot,
1984, 1985). Before generating the SF output, SABA builds a
simplified semantic graph expressing all the scmantic dependencies
established between the meaningful terms of the sentence. The
graph established for sentence (1) is shown in figure (2).
</bodyText>
<listItem confidence="0.272882">
(2)
</listItem>
<table confidence="0.9113486">
BENEFICIARY VALUE INTENSITY
pont 0 * *
*
QUAL long fort
LR
que OBJECT AGENT *
convoi
passer
MOMENT
AGENT OBJECT
</table>
<sectionHeader confidence="0.211961" genericHeader="method">
ii
</sectionHeader>
<bodyText confidence="0.999874636363636">
These kinds of dependencies are established by using the &amp;quot;dual
frames&amp;quot; method described in (Binot and Ribbens 86). Dual frames
is a general method for establishing binary semantic dependencies
between all possible types of meaningfull terms. This method sup-
ports also a hierarchy of semantic classes and an inheritance mech-
anism allowing the designer to specify generic semantic frames at a
general level. However, we are not concerned here by the specifics
of a particular semantic method, but by the kind of syntactic sup-
port necessary to establish such dependencies (or, to put it another
way, by the kind of syntactic support needed to identify accurately
the arguments filling the role slots of various meaningfull terms).
</bodyText>
<sectionHeader confidence="0.992978" genericHeader="method">
3. Fragmentation
</sectionHeader>
<subsectionHeader confidence="0.999295">
3.1 General discussion
</subsectionHeader>
<bodyText confidence="0.999991314814815">
Consider again sentence (1) and suppose that a purely semantic
system were to understand it by establishing semantic dependencies
between words. There would be no reason for such a system to re-
frain from attempting to connect &amp;quot;was long&amp;quot; to &amp;quot;convoy&amp;quot;, for ex-
ample. And, if the attempt is made, no amount of semantic or
pragmatic knowledge will be able to prevent the connection, which
is perfectly valid as such. Note also that a simple proximity principle
would not work in this case.
Thus, any natural language processing system must take into
account, in some way, the structure of a sentence. However, we
don&apos;t necessarily need to build an intermediate syntactic structure,
such as a parse tree, showing the detailed &amp;quot;phrase structure&amp;quot; of the
input. The most crucial structural information needed for an accu-
rate semantic processing concerns &amp;quot;boundaries&amp;quot; across which se-
mantic processing should not be allowed to relate words. These
boundaries can be identified by a fragmentation process which will
cut a sentence into useful fragments by looking for specific types of
words.
Except maybe in Wilks&apos; system fragmentation has not received
the attention it deserves as a faster alternative to full syntactic pars-
ing. Wilks&apos; fragmentation process, however, was by his own ad-
mission too simple. In his system, fragmentation was performed
only once as a preprocessing step, and was designed around the size
of his notion of &apos;template&amp;quot;. Both of these characteristics, we think,
give rise to problems.
Performing fragmentation as a single preprocessing step is obvi-
ously insufficient for garden path sentences and for all the structural
ambiguities that cannot be solved without the help of the semantic
module. Although Wilks said something about involving some se-
mantic processing at the fragmentation stage, notably for handling
the ambiguity about &amp;quot;that&amp;quot;, he never presented, to our knowledge,
a systematic procedure to integrate fragmentation and semantics.
On the other hand, we believe that template sized fragments are
more troublesome and less usefull than clause sized fragments. Even
in straightforward active declarative sentences, two distinct mech-
anisms must be provided to establish semantic dependencies in
Wilks system: template matching, which identifies &amp;quot;agent-action-
object&amp;quot; triples, and paraplates, which are used to tie these templates
together. A prepositional phrase constitutes a separate template.
One problem with that approach is that in sentences such as The
old man / in the corner / left&amp;quot;, fragmented by Wilks as shown by the
7, the agent ends up in a different fragment than the action and
an additionnal step will be required to relate the two. The same
problem seems to arise in passive structures (&amp;quot;John is loved / by
Mary&amp;quot;). To avoid these kinds of problems, we decided to use clause
sized fragments and to establish semantic dependencies directly at
the clause level.
A third difference between the two approaches is that, while
Wilks never provided a systematic method to solve part of speech
ambiguities, SABA makes use of a part of speech disambiguation
preprocessor, which will be described in the second part of this pa-
per. This module being applied before fragmentation, we shall as-
sume in the following discussion of the fragmentation mechanism
that each word has a single part of speech.
</bodyText>
<subsectionHeader confidence="0.992977">
3.2 The fragmentation mechanism.
</subsectionHeader>
<bodyText confidence="0.999964285714286">
We have implemented in the SABA system a fragmentation mech-
anism which uses the clause as the fundamental fragmentation unit
and which is repetitively applied and interleaved with the semantic
processing. We start by presenting the basic algorithm, then, in the
next sections, we shall discuss some more difficult problems and
show how the introduction of two additionnal mechanisms, ejection
and backtracking, can solve them.
</bodyText>
<subsectionHeader confidence="0.746523">
Fragmentation algorithm:
</subsectionHeader>
<bodyText confidence="0.976738">
Repeat the following until success or dead end
</bodyText>
<listItem confidence="0.6500249">
I. Fragment the sentence into clauses;
2. Select the innermost clause;
3. Process the selected clause, which includes:
a. The fragmentation of the clause into groups;
b. The establishement of semantic dependancies inside each
group;
c. The establishement of semantic dcpendancies at the clause
level;
4. If the processing is successful], erase the text of the clause from
the input and replace it by a special non terminal symbol.
</listItem>
<bodyText confidence="0.99980225">
This algorithm follows a bottom-up strategy in which the in-
nermost clause (the most dependent one) is always processed first.
Ties are resolved by a left to right preference rule. The special sym-
bols used in step 4 are PP (&amp;quot;Proposition Principale&amp;quot;) for a main
clause, PR for a relative clause, PC for a conjunctive subordinate
clause and PINT&apos; for an infinitive clause. Participe clauses are proc-
essed as special lcinds of relatives, as we explain in section 4.2.
Success in the above algorithm means that the input has been
reduced to the PP symbol or to a string of such symbols and con-
junctions. A dead end is reached if fragmentation can find no new
clause or if the selected clause cannot be processed. What happens
then will be discussed in the next sections.
</bodyText>
<figure confidence="0.989106333333333">
11 quitter New York
MOMENT
* matin
</figure>
<page confidence="0.99386">
285
</page>
<bodyText confidence="0.999794117647059">
As can be seen in the above algorithm, fragmentation in SARA
is in fact a two level process: sentences are fragmented into clauses
and clauses into groups. Fragmentation into groups, wich gives far
less problems than fragmentation into clauses, will not be discussed
at all in this paper.
Fragmentation of a sentence into clauses proceeds by extending
to the left and to the right of each verb&apos; and checking each en-
countered word looking for clause delimiters. The checks are per-
formed by heuristic rules based on the part of speech of each word.
Other rules will then look at the delimiters to find the innermost
clause.
The rules checking if a given word is a delimiter are given below.
The term &apos;&apos;explicit clause boundaries&amp;quot; used in the rules denotes the
following kinds of words: relative or interrogative pronouns, rela-
tive or interrogative adjectives, subordinate conjunctions and coor-
dinate conjunctions. Coordinate conjunctions, which raise special
problems, will not be discussed before section 3.5.
</bodyText>
<subsubsectionHeader confidence="0.688553">
Clause fragmentation rules.
</subsubsectionHeader>
<listItem confidence="0.8855695">
1. Explicit clause boundaries other than coordinate conjunctions
are always clause delimiters; they are included in the clause on
the left and excluded on the right.&apos;
2. The special symbols PR, PC, PINF are never clause delimiters.
3. Sentence boundaries are always clause delimiters.
4. Another verb and the symbol PP are always clause delimiters,
and are always excluded from the clause.
5. Negation particles (&amp;quot;ne&amp;quot;, &amp;quot;n&amp;quot;) are considered as (excluded)
clause delimiters when expanding to the right of the verb of the
clause.
</listItem>
<bodyText confidence="0.996287823529412">
Rules 1 to 4 are rather immediate. Rule 5 takes into account the fact
that negation particles in French are always placed before the ne-
gated verb.
The basic clause selection rules (for choosing the innermost
clause) are equally simple. A clause is subordinate if its left bound
is a relative or interrogative pronoun (or adjective), or a subordinate
conjunction, or if its verb is an infinitive. A clause is said to be free
(meaning that it is not qualified by other subordinate clauses which
should be processed first) if its right bound is not one of these terms.
The leftmost free and subordinate clause, or, if none, the leftmost
free clause will be chosen.
Let us illustrate the effect of the above rules on example (1). The
figure (3) below shows the successive states of the input text. In
each state, the last fragmentation result is indicated by underlining
the identified clauses. The semantic processing of the innermost
clause selected at each step leads to the building of the correspond-
ing part of the graph of figure (2).
</bodyText>
<listItem confidence="0.8168425">
(3) Le pont,(Kue le convoi a passe ,quand il a quitte New-York ce
matin etait fort long.
</listItem>
<bodyText confidence="0.815681272727273">
Le pont ,que le convoi a passe IPC,etait fort long..
,Le pont PR etait fort long.
PP
As can be seen, a single fragmentation pass will often yield
imperfect results. There will be holes (sentence fragments which are
not included in any clause, like &amp;quot;Le pont&amp;quot; in the first two steps) and
overlappings (fragments which could be included in two clauses, like
New-York cc matin&amp;quot; in the first step). This is where the repetitive
nature of the fragmentation process comes into play. Successive
2
Except auxiliaries that are part of a compound verbal form.
</bodyText>
<page confidence="0.931979">
3
</page>
<bodyText confidence="0.993332428571429">
If the left clause bound is a relative pronoun preceeded by a preposi-
tion, the preposition will also be included in the clause.
erasing of the innermost clauses from the input text, once they have
been processed by the semantic module, will gradually cause the
holes to disappear, and thus reveal the content of the main clause(s).
Terms in overlapping areas will be automatically tried first in the
innermost clause to which they could belong, in effect implementing
a kind of deepest attachment preference. What happens when that
first try is semantically inacceptable is discussed in the next section.
Another interesting feature of the bottom-up algorithm is that the
special symbol representing a processed subordinate clause will be
naturally included, in later fragmentation steps, in the clause quali-
fied by this subordinate, thus permitting to process correctly inter
clause dependencies.
</bodyText>
<subsectionHeader confidence="0.778643">
3.3 The ejection mechanism.
</subsectionHeader>
<bodyText confidence="0.5103545">
A first class of problems for which the above fragmentation algo-
rithm is not sufficient concerns cases when the deepest attachment
preference fails. This problem occurs typically when a clause has
no explicit clause boundary on one side, as in the examples (4) and
</bodyText>
<listItem confidence="0.971257">
(5) below:
(4) ,J&apos;aime fhomme„que le presente a mon pere.,
(I love the man whom I introduce to my father)
(5) ,Je presente fhomme ique faime a mon pere.,
(I introduce the man whom I love to my father)
</listItem>
<bodyText confidence="0.998753285714286">
In both cases the relative clause has no explicit right boundary, and
the attachment problem concerns the group &amp;quot;a mon pere&amp;quot;. The
fragmentation result (shown by underlines) will in both cases in-
clude this group in the relative clause, which is wrong for (5). In
such cases, the fragmentation will be automatically corrected, after
the semantic processing of the relative clause, by a &amp;quot;right-ejection&amp;quot;
mechanism:
</bodyText>
<subsectionHeader confidence="0.453976">
Right ejection mechanism
</subsectionHeader>
<bodyText confidence="0.947395071428571">
If a group G on the right of the verb remains unconnected
after the semantic processing of a clause, and if there is no
other term on the right of G which has been connected to a
term on its left, then G and all terms on its right will be ex-
cluded from the current clause.
In the case of example (5), assuming reasonnably that no semantic
dependency can be established between &amp;quot;aime&amp;quot; and &amp;quot;a mon pere&amp;quot;,
this last group will be ejected from n the relative clause, giving the
situation shown in (6):
(6) pie presente fhornme,que j&apos;aime a mon pere.
Since fragmentation is interleaved with the semantic processing, the
next fragmentation step will automatically pick up the discarded
term after the processing of the relative clause, and insert it at the
correct level:
</bodyText>
<listItem confidence="0.8100408">
(7) le presente thomme PR a mon pere,
The same mechanism applies to overlapping cases, such as in ex-
ample (8):
(8) L&apos;homme,que fai rencontrelsur la place m:a offer( un cafe.I
(The man that I met in the square bought me a coffee)
</listItem>
<bodyText confidence="0.999936166666667">
Here, two groups appear in the overlapping fragment. The first one,
&amp;quot;sur la place&amp;quot; (&amp;quot;on the square&amp;quot;), can easily be connected to the rel-
ative verb (as a location argument) and will remain in the relative
clause. The second, &amp;quot;m&amp;quot; (&amp;quot;me&amp;quot;) cannot be connected to &amp;quot;rencontre&amp;quot;
(&amp;quot;men, the object slot of that verb being already filled by the rela-
tive pronoun &amp;quot;que&amp;quot;. &amp;quot;m&amp;quot; will thus be ejected from the relative
clause, and included correctly in the main clause during the next
fragmentation step.
It is worth mentiorming that this mechanism involves no back-
tracking and is extremely cheap in computational ressources. The
only processing required is the displacement of the right clause
boundary before erasing the text of the processed clause.
</bodyText>
<page confidence="0.987903">
286
</page>
<subsectionHeader confidence="0.921106">
3.4. Infinitive clauses and backtracking.
</subsectionHeader>
<bodyText confidence="0.9997435">
Infinitive clauses without an explicit left boundary (such as a sub-
ordinate conjunction) give rise to several interesting problems con-
cerning both fragmentation itself and the selection of the innermost
clause. Consider the following examples:
</bodyText>
<listItem confidence="0.532466666666667">
(9) ,.1&apos; irai &apos;Ce soir a Paris,voir l&apos;exposition.
(I will go this evening to Paris to see the exposition)
(10) tle n&apos;ai jamais vu .11acques1travailler!
</listItem>
<bodyText confidence="0.966742310344828">
(I never saw Jacques working)
In both cases, there is an attachment problem for the terms in the
overlapping area. In (9), all the terms in that area belong to the
relative clause, while in (10) Jacques is the subject of the infinitive
clause. One might want to define here a left-ejection&amp;quot; mechanism
similar to the one described in the last section; however it would
almost never work properly. Indeed, if terms such as this evening&amp;quot;
or &amp;quot;to Paris&amp;quot; are tried in the infinitive clause first, there would be
no reason to reject them during the semantic processing of that
clause, and they will never be ejected. Things work out better if
we try first the terms in balance in the main clause. This choice will
be wrong when one of these terms is in fact the subject of the
infinitive verb; but in that case, as we shall see, this term will conflict
with the infinitive verb for fang the OBJECT slot of the main verb,
and the system will have a reason to reject the wrong choice. Ac-
cordingly, we apply the following strategy:
1, try first to place the terms of the overlapping area in the main
clause; in effect, this consists in preventing the infinitive clause
to extend to the left of its verb;
2. if the choice made at point 1 fails, use a backtracking mech-
anism that will restore the proper state of the analysis and try
to extend, one group at a time, the left bound of the infinitive
clause.
With this strategy, (9) will be processed correctly at the first try. (10)
will lead to the following (erroneous) state of the analysis:
( II) ,Je n&apos;ai jamais vu Jacques PINE,
where &amp;quot;Jacques&amp;quot; and PINF compete for the object slot of the main
verb. The term PINE will then be ejected by the mechanism of the
last section, giving the following state:
</bodyText>
<listItem confidence="0.645189">
(12) PP PINF
</listItem>
<bodyText confidence="0.9991794">
This is a dead end state, since the sentence is not reduced to a PP
symbol, and yet no further clause to process can be found. The
backtracking mechanism will then restore the state shown in (10)
with the following fragmentation, which leads to a successfull anal-
ysis:
</bodyText>
<listItem confidence="0.540355">
(13) , Je n&apos;ai jamais vulacques travailler.)
</listItem>
<bodyText confidence="0.896699">
Infinitive clauses raise also problems concerning the selection of the
innermost clause. Consider the following examples:
</bodyText>
<listItem confidence="0.747527">
(14) ,J&apos;ai vu un homme.qui voulaic dormir sur le trottoir.,
(I saw a man who wanted to sleep on the street)
(15) ,J&apos;ai vu un homme,pui avail buadormir sur le trottoir.,
</listItem>
<bodyText confidence="0.964421714285714">
(I saw a man who was drunk sleep on the street)
In both cases, the selection rules will choose to process the infinitive
clause first. This choice is wrong for (15): if the relative relative
clause is not processed fust, its presence will prevent the system to
find out that the group &amp;quot;un homme&amp;quot; is in fact the subject of the
infinitive clause. Processing the infinitive first, the system will reach
a dead end after the following steps:
</bodyText>
<listItem confidence="0.989345666666667">
(16) Ifai vu un homme.,qui avail bu PINF, (ejection of PINF)
vu un homme PR PMF,(ejection of PINE)
PP PINF (dead end)
</listItem>
<bodyText confidence="0.999665125">
This problem is again handled by backtracking. Let us note first that
the problem arises only when the subject of the infinitive verb is
separated from that verb by a relative clause. In such a case, the
system will try to process the infinitive first, but will save the current
state of the analysis so that it can later backtrack and process the
relative first. In the case of our example, backtracking to (15) from
the dead end state in (16), and processing the relative clause first,
we obtain a correct analysis, as shown in (17):
</bodyText>
<listItem confidence="0.88097">
(17) J&apos;ai vu un homme PRidormir sur le trottoir..
J&apos;ai vu PINF
</listItem>
<subsectionHeader confidence="0.972099">
3.5 Coordinate conjunctions
</subsectionHeader>
<bodyText confidence="0.933638">
Fragmenting sentences with coordinate conjunctions requires to
make a decision regarding the scope of these conjunctions; specif-
ically we need to distinguish between the conjunctions which coor-
dinate clauses and the ones which coordinate groups inside a same
clause. The following rules are used:
Clause delimiter rules for coordinate conjunctions
</bodyText>
<listItem confidence="0.9408393">
1. If the word to the right of the conjunction is a right de-
limiter, or if next word in the current direction is the
special symbol PP, the conjunction is taken as delimiter
(excluded).
2. If the next clause delimiter in the current direction is an
explicit clause boundary or a sentence boundary, the
conjunction is not taken as delimiter.
3. Otherwise choose to consider first the conjunction as a
delimiter (excluded); this choice can be undone by back-
tracking.
</listItem>
<bodyText confidence="0.9993136">
Rule 1 is based on the fact that there must always be at least one
conjunct to each side of a conjunction. If a delimiter is found im-
mediately to the right, then the conjunction must connect clauses.
The same is true if the conjunction is adjacent to the PP symbol.
The following example illustrates the use of this rule:
</bodyText>
<figure confidence="0.6630058">
(18) d&apos;aime les chien.;,qui m&apos;obeissent,et qui ne mordent pas,.
(I love the dogs which obey me and which do not bite)
ilaime les chiens PR, el eui ne mordent pas,
•faime les chiens PR et PR.
PP
</figure>
<bodyText confidence="0.9989305">
If the next delimitor is an explicit clause boundary, then there is no
verb between the conjunction and this delimiter, and thus the
conjuncts cannot be clauses. This fact, captured by rule 2, can be
illustrated by the following example:
</bodyText>
<listItem confidence="0.9676595">
(19) ,J&apos;ai appris„que les pommes et les poires etaient cheres.,
(I learned that apples and pears were expensive)
</listItem>
<subsubsectionHeader confidence="0.646949">
J&apos;ai appris PC
</subsubsectionHeader>
<bodyText confidence="0.999381333333333">
Finaly, if the next delimitor is a verb, the scope ambiguity cannot
be resolved at this stage. The conjunction could be a clause delim-
iter, as in (20), or not, as in (21):
</bodyText>
<listItem confidence="0.662946">
(20) Connors a vaincu Lend! et McEnroe a vaincu Connors.
(Connors defeated Lendl and McEnroe defeated Connors)
</listItem>
<page confidence="0.988005">
287
</page>
<bodyText confidence="0.970481272727273">
(21) Les hommes qui aiment les pommes et les poires aiment aussi
les oranges.
(People who like apples and pears like also oranges)
In such cases, the system will choose to take the conjunction as a
delimiter, and record the state of the analysis, so that the choice can
be modified by backtracking. The choice will be correct for sen-
tence (20). For sentence (21), the incorrect choice will lead to a dead
end, as shown in (22), when the semantic module will try to coor-
dinate &amp;quot;hommes&amp;quot; and &amp;quot;poires&amp;quot; as agents of &amp;quot;aiment&amp;quot;. Backtracking
to the choice point, followed by a new fragmentation, leads to the
correct solution.
</bodyText>
<figure confidence="0.316485666666667">
(22) Les hommes qui aiment les pommesiet poires aiment aussi
les oranges.
iLes hommes PR et les poires aiment aussi les oranges.
BACKTRACKING
Les hommes ,qui aiment les pommes et les poires aiment aussi
les oranges.
Les hommes PR aiment aussi les oranges.1
PP
4. Part of speech disambiguation
</figure>
<subsectionHeader confidence="0.97009">
4.1 General discussion
</subsectionHeader>
<bodyText confidence="0.997933735294117">
Many lexically ambiguous words can have different parts of speech
(hereafter POS). The following table enumerates the main POS
ambiguities for example (I).
Le (occurs twice): article or personal pronoun (the, him, it)
que: subordinate conjunction, relative or interrogative pronoun,
particle (that, which, what, than)
quand: subordinate conjunction or adverb (when)
fort: noun or adverb (castle, very).
The ambiguity problem is further compounded by an accentuation
problem. &amp;quot;Passe&amp;quot;, third person of the present of the indicative of
the verb &amp;quot;passer&amp;quot;, is quite different in French from &amp;quot;passe&amp;quot;, past
participle of the same verb.4 Similarly, &amp;quot;a&amp;quot;, indicative of avoir (&amp;quot;to
have&amp;quot;), has nothing to do with the preposition &amp;quot;a&amp;quot;. However, for-
getting an accent is one of the most common spelling mistakes. A
robust system such as SABA must consider words such as &apos;a&amp;quot;,
&amp;quot;passe&amp;quot; and &amp;quot;quitte&amp;quot; as ambiguous. This would give at least 1024
possible POS combinations for example ( I)!
Part of speech ambiguity is, of course, part of the more general
problem of lexical ambiguity. Thus, one could argue that it doesn&apos;t
need an independent solution. However, in the context of a frag-
mentation system such as the one presented here, a POS
disarnbiguation preprocessor is necessary. To give a simple example,
the relative pronoun and subordinate conjunction senses of &amp;quot;que&amp;quot;
are clause boundaries, while the (comparative or restrictive) particle
sense is not. Many other problems of semantic processing need a
prior decision regarding the POS of the words involved. Thus the
French word &amp;quot;or&amp;quot; can be a noun (&amp;quot;gold&amp;quot;), and as such can fill a se-
mantic role slot of some verb, or can be a coordinate conjunction
(&amp;quot;however&amp;quot;); le&amp;quot; can be pronoun (&amp;quot;him&amp;quot;, &amp;quot;it&amp;quot;) and as such induce a
search for a pronoun reference, or can be a determiner (&amp;quot;the&amp;quot;).
Many other examples could easily be found.
Other works have already investigated the usefullness of a POS.
disambiguation preprocessor, but for syntactic parsers. (Klein and
Simmons 63) presented very early a table based system for English
</bodyText>
<page confidence="0.940905">
4
</page>
<bodyText confidence="0.9580822">
Verb mood ambiguities can usefully be considered at the same level as
POS ambiguities.
where the emphasis was on the capability to classify &amp;quot;unknown
words&apos;, and thereby to reduce the size of the dictionnary. Much
more recently, (Merle 82) described a rule based POS disarnbiguator
for French, its main objective being a gain of performance obtained
by the reduction of combinatorial explosion during syntatic parsing.
Merle&apos;s rules, however, were rather unwieldy for two reasons:
I. each rule must make a final decision regarding thc POS of one
word; the designer must ensure himself the absence of contra-
dictions between the rules.
2. The rules permitted only to test for fixed patterns in the input.
In contrast to that, we have developped a method permitting the
use of cumulative rules and providing the possibility to test variable
patterns through the use of a search function.
</bodyText>
<subsectionHeader confidence="0.7300135">
4.2. The part of speech preprocessor for the SABA
system.
</subsectionHeader>
<bodyText confidence="0.999978666666667">
We have developped a part of speech disambiguation preprocessor
for French, which is used as the first stage of the SABA system.
This preprocessor consists of heuristic rules which are applied to
each word in order to assign to every possible part of speech a cer-
tainty factor. The different combinations of possible parts of
speechs are then tried in decreasing order of likeliness.
The heuristic rules are based on the well known fact that it is not
necessary to scan the entire sentence to choose correctly the appro-
priate part of speech for most words. The local context&amp;quot; (i.e. the
few surrounding words) proves often enough to provide an accurate
indication. Thus, if a word like &amp;quot;passe&amp;quot; is closely preceeded by an
auxiliary, it is almost certainly a participe. As another example,
&amp;quot;fort&amp;quot;, if closely preceeded by a determiner, is more likely to be a
noun than an adverb.
We have captured such insights into heuristic rules which assign to
each possible part of speech a certainty factor, according to the local
context. Two of these rules, relating to the examples just
mentionned, are given in natural language form below:
</bodyText>
<subsectionHeader confidence="0.586104">
Rule 2
</subsectionHeader>
<bodyText confidence="0.989755">
If the current word can be a past participe and has other
possible POS, then
</bodyText>
<listItem confidence="0.866871285714286">
1. If the current word is preceeded by a word that could
be an auxiliary, and is only separated from that word
by words that could be adverbs, personal pronouns
or particles, then
past participle CF = 0.7; other possibles POS
CF = 0.3;
2. Else:
</listItem>
<bodyText confidence="0.892505">
relative participes CF = 0.7; other possible POS
CF = 0.3.
</bodyText>
<subsectionHeader confidence="0.429567">
Rule 5
</subsectionHeader>
<bodyText confidence="0.916491714285714">
If the current word can be a noun and has other possible
POS, then
I. If it is preceeded by a word that could be a
determiner, and is only separated from it by words
that could be adjectives or adverbs, then
noun CF = 0.9; other possible POS CF = 0.1;
2. else:
noun CF = 0.4; other possible POS CF = 0.6;
We distinguish between a participe used in a complex verbal form and
a participe clause, as in —I he man defeated by Connors was ill&amp;quot;. In the
later case, the participe will receive a POS called PPAREL (&amp;quot;relative
participe&apos;) because the participe clause is then processed exactly like a
relative clause: in fact, when the POS Pl&apos;AREL is assigned to a
participe, a relative pronoun is inserted just before it.
</bodyText>
<page confidence="0.991033">
288
</page>
<bodyText confidence="0.90066164516129">
These rules need several comments:
1. Each rule can be seen as a production rule with a condition and
an action. The condition is the clause starting with the first -e
of the rule; if it is not satisfied, this particular rule is not applied
to the current word. The action is often itself a conditionnal
statement, each branch of which must include a certainty factor
assigment statement.
2. The certainty factors that we are using range from 0 (absolute
uncertainty) to 1 (absolute certainty). They can be compared
to the belief factors used in the MYCIN system (Shortliffe 76).
3. The application of any rule must result in one assigment of
certainty factors to all possible POS of the current word.
However, a given word could possess other possible POS than
those that need to be explicitly mentionned in a given rule.
These are refered to by the formal expression &amp;quot;other possible
parts of speech&amp;quot;.
4. The intermediate words tested by a rule can also have several
possible parts of speech. The expression &amp;quot;if such word could
be of part of speech x &amp;quot; denotes a test bearing on all possible
parts of speech of that word.
5. We must be able to specify rules at varying levels of details.
Sometimes, we will need to test if a word is a personal pro-
noun; at another time, knowing that it is a pronoun of any kind
is sufficient. The system offers the possibility to specify a hier-
archy of parts of speech, which is taken into account by the
rules.
The part of speech disambiguation preprocessor works in the fol-
lowing way. It processes successively all the words of the input. For
each word, it checks the conditions of all rules and fires all applica-
ble rules. If several rules are applied to a same word, certainty fac-
tors are combined by the following formula:
</bodyText>
<equation confidence="0.591085">
CF = 1 - ((i - CF1)■(1 - CF2))
</equation>
<bodyText confidence="0.999987285714286">
where CF I and CF2 are the certainty factors to be combined. When
this is done, possible POS combinations are ordered by decreasing
order of likeliness. The likeliness of a combination is simply defined
as the product of the certainty factors of the parts of speech included
in that combination.
Although each rule is considered for every word, the resulting
process is very fast. The first reason for that is that there are very few
rules: 14 in the current implementation. This is nothing compared
to the size of the rule base needed for a large granunar, and yet these
few rules are sufficient to choose the correct POS at the first try in
more than 80% of our test sentences. The second reason is that
each rule is garded by a short, easy to check and very selective
condition, so that most of the rules are immediately discarded for a
given word.
</bodyText>
<subsectionHeader confidence="0.949063">
4.3. Implementation of the rules.
</subsectionHeader>
<bodyText confidence="0.999285153846154">
The rules are implemented in a &apos;&apos;semi-declarative&amp;quot; way: they can be
specified separately, each being described as a condition-action pair.
However, both condition and action can be any evaluable LISP
form. In order to ease the task of rule specification, we have defined
a set of primitive operations. The figure (23) gives the formal
specification of Rule 2.
HOMOGRAPH checks if a word has more than one possible parts
of speech. POSSIBLE-STYPE checks if the specified part of
speech is one of the possible parts of speech of the word.
DEFINE-PTYPEL1ST assigns to each part of speech of the word
a specific certainty factor. EX ISTWORD, lastly, is a highly pa-
rametered function performing searches in the input sentence. Its
parameters are:
</bodyText>
<listItem confidence="0.985646476190476">
I. POSITION: the starting word for the search;
2. DIRECTION: the direction of the search (LEFT or RIGIIT);
3. LIMIT: the ending word, beyond which the search should be
stopped;
4. GOAL-NAMES: admissible names for the target word
5. GOAL-TYPES: admissibles parts of speech for the target
word;
6. GOAL-CLASSES: admissible semantic classes for the target
word;
7. BETWEEN-NAMES: admissible names for intermediate
words
8. BETWEEN-TYPES: admissible parts of speech for intermedi-
ate words;
9. BETWEEN-CLASSES: admissible semantic classes for inter-
mediate words;
10. EXCLUDED-NAMES: excluded names for intermediate
words;
11. EXCLUDED-TYPES: excluded parts of speech for interme-
diate words;
12. EXCLUDED-CLASSES: excluded semantic classes for inter-
mediate words.
</listItem>
<bodyText confidence="0.9998806">
Parameters 3 through 12 are optional. The default value for LIMIT
is the sentence boundary. The default value for parameters 4
through 9 is &amp;quot;(ALL)&amp;quot;, denoting that all values are accepted. The
default value for parameters 10 through 12 is NIL (no value is ex-
cluded).
</bodyText>
<sectionHeader confidence="0.991923" genericHeader="method">
5. Results and conclusions
</sectionHeader>
<bodyText confidence="0.9537246">
We have presented two syntactic processes which offer useful and
necessary support for semantic processing. syntactic parser. Both
are based on simple heuristic rules assisted by a backtracking
mechanism. Both have been implemented in the SABA system and
tested on a corpus of about 125 sentences. Less than 5% of these
required a backtracking of the fragmentation process. Since we tried
to characterize precisely the situations in which a backtracking could
arise, in most sentences there is not only no backtracking, but also
no bookkeeping of the intermediate steps.
( 23)
</bodyText>
<sectionHeader confidence="0.9817772" genericHeader="method">
(ADD-SYNT-RULE R R2
Condition
(AND (POSSIBLE-STYPE WORD) &apos;PPA) (HOMOGRAPH WORD))
Action
(COND ((EXISTWORD position (LEFT WORD)
direction &apos;LEFT
goal-classes &apos;(AUX)
between-types &apos;(PR ADV PT))
(DEFINE-PTYPELIST WORD &apos;((PPA . .7)(0THERS . .3))))
(T (DEFINE-PTYPELIST WORD &apos;UPPAREL . .7)(0THERS . .3))))))
</sectionHeader>
<page confidence="0.991798">
289
</page>
<bodyText confidence="0.999994222222222">
As for the part of speech disambiguation preprocessor, the 14 rules
that we implemented were sufficient to make the right choice in
more than 80% of the cases. The very small size of this preprocessor
is an important advantage if we think at the high human and com-
putational costs involved in developing and using large size gram.
mars.
Although the specific rules that we implemented were designed far
French, we believe that the approach could be applied to other
languages as well.
</bodyText>
<sectionHeader confidence="0.997397" genericHeader="acknowledgments">
ACKNOWLEDGMENTS
</sectionHeader>
<bodyText confidence="0.999791">
Thanks arc due to Professor D. Ribbens for his numerous helpfull
comments and for his active support.
</bodyText>
<sectionHeader confidence="0.998599" genericHeader="references">
REFERENCES
</sectionHeader>
<reference confidence="0.999970414634146">
1. Binot, J-L. 1984. A Set-oriented semantic network formalism
for the representation of sentence meaning. In Proc. ECA 184,
Pisa, September 1984.
2. Binot, J-L. 1985. SARA: vers un systeme portable d&apos;analyse du
francais ecrit. Ph.D. dissertation, University of Liege, Belgium.
3. Binot J-L. and Ribbens D. 1986. Dual frames: a new tool for
semantic parsing. In Proc. A AA186, Philadelphia, August 1986.
4. Binot J-L, Gaily P-J. and Ribbens D. 1986. Elements d&apos;unc
interface portable et robuste pour le francais ecrit. In Proc.
Huitiemes Journees de !Informatique Francophone, Grenoble,
January 1986.
5. Boguraev B.K. 1979. Automatic resolution of linguistic ambi-
guities. Ph.D. thesis, University of Cambridge, England, 1979.
6. Jensen K., Heidom G.E., Richardson S. and Haas N., PLNLP,
PEG and CRITIQUE: three contributions to computing in the
Humanities. In Proc. of the conf on Computers and Humani-
ties, Toronto, April 1986.
7. Klein S. and Simmons R.F. A computational approach to
grammatical coding of English words. Journal of the ACM. 10,
March 1963.
8. Lytinen S.L. 1986. Dynamically combining syntax and seman-
tics in natural language processing. In Proc. of AAAI86,
Philadelphia, August 1986.
9. Merle A. 1982. Un analyseur presyntazique pour la levee des
ambiguites dans des documents ecrits en langue naturelle: ap-
plication a !indexation automatique&amp;quot;.Ph.D. thesis, Institut Na-
tional Polytechnique de Grenoble.
10. Ristad E.. 1986. Defining natural language grammars in GPSG.
In Proc. of the 24th meeting of the ACL, New-York, June 1986.
11. Schank R.C., Leibowitz M. and Birnbaum L. 1980. An inte-
grated understander. In Journal of the ACL, 6:1.
12. Shieber S. 1986. An introduction to unification-based ap-
proaches to grammar, University of Chicago Press.
13. Shortliffe E.11. 1976. Computer-based medical consultation:
MYCIN Elsevier.
14. Weir DJ., Vijay-Shanker K. and Joshi A.K. 1986. The re-
lationship between Tree adjoining grammars and head gram-
mars. In Proc. of the 24th meeting of the ACL, New-York, June
1986.
15. Wilks Y. 1975. An intelligent analyser and understander of
English. CACM 18:5, May 1975.
</reference>
<page confidence="0.997137">
290
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.828486">
<title confidence="0.998767">FRAGMENTATION AND PART OF SPEECH DISAMBIGUATION&apos;</title>
<author confidence="0.982091">Jean-Louis Binot</author>
<affiliation confidence="0.861298">B.I.M.</affiliation>
<address confidence="0.9885345">Kwilcstraat, 4 83078 Everberg, Belgium</address>
<abstract confidence="0.9981151">That at least some syntax is necessary to support semantic processing is fairly obvious. To know exactly how much syntax is needed, however, and how and when to apply it, is still an open and crucial, albeit old, question. This paper discusses the solutions used in a semantic analyser of French called SABA, developed at the University of Liege, Belgium. Specifically, we shall argue in favor of the usefulness of two syntactic processes: fragmentation, which can be interleaved with semantic processing, and part-of-speech disambiguation, which can be performed as a preprocessing step.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>J-L Binot</author>
</authors>
<title>A Set-oriented semantic network formalism for the representation of sentence meaning.</title>
<date>1984</date>
<booktitle>In Proc. ECA 184,</booktitle>
<location>Pisa,</location>
<contexts>
<context position="5598" citStr="(1)" startWordPosition="899" endWordPosition="899">: (I) Le pont que le convoi a passe quand il a quitie New York re matin etait fort long. (The bridge that the convoy crossed when it left New York this morning was very long.) 284 To allow for portability, the SABA parser translates its natural language input into an intermediate &amp;quot; semantic network formalism called SF (for &amp;quot;Sentence Formalism&amp;quot;), presented in details in (Binot, 1984, 1985). Before generating the SF output, SABA builds a simplified semantic graph expressing all the scmantic dependencies established between the meaningful terms of the sentence. The graph established for sentence (1) is shown in figure (2). (2) BENEFICIARY VALUE INTENSITY pont 0 * * * QUAL long fort LR que OBJECT AGENT * convoi passer MOMENT AGENT OBJECT ii These kinds of dependencies are established by using the &amp;quot;dual frames&amp;quot; method described in (Binot and Ribbens 86). Dual frames is a general method for establishing binary semantic dependencies between all possible types of meaningfull terms. This method supports also a hierarchy of semantic classes and an inheritance mechanism allowing the designer to specify generic semantic frames at a general level. However, we are not concerned here by the specific</context>
<context position="13892" citStr="(1)" startWordPosition="2248" endWordPosition="2248"> before the negated verb. The basic clause selection rules (for choosing the innermost clause) are equally simple. A clause is subordinate if its left bound is a relative or interrogative pronoun (or adjective), or a subordinate conjunction, or if its verb is an infinitive. A clause is said to be free (meaning that it is not qualified by other subordinate clauses which should be processed first) if its right bound is not one of these terms. The leftmost free and subordinate clause, or, if none, the leftmost free clause will be chosen. Let us illustrate the effect of the above rules on example (1). The figure (3) below shows the successive states of the input text. In each state, the last fragmentation result is indicated by underlining the identified clauses. The semantic processing of the innermost clause selected at each step leads to the building of the corresponding part of the graph of figure (2). (3) Le pont,(Kue le convoi a passe ,quand il a quitte New-York ce matin etait fort long. Le pont ,que le convoi a passe IPC,etait fort long.. ,Le pont PR etait fort long. PP As can be seen, a single fragmentation pass will often yield imperfect results. There will be holes (sentence fra</context>
</contexts>
<marker>1.</marker>
<rawString>Binot, J-L. 1984. A Set-oriented semantic network formalism for the representation of sentence meaning. In Proc. ECA 184, Pisa, September 1984.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J-L Binot</author>
</authors>
<title>SARA: vers un systeme portable d&apos;analyse du francais ecrit.</title>
<date>1985</date>
<institution>University of Liege, Belgium.</institution>
<note>Ph.D. dissertation,</note>
<contexts>
<context position="5621" citStr="(2)" startWordPosition="904" endWordPosition="904">nvoi a passe quand il a quitie New York re matin etait fort long. (The bridge that the convoy crossed when it left New York this morning was very long.) 284 To allow for portability, the SABA parser translates its natural language input into an intermediate &amp;quot; semantic network formalism called SF (for &amp;quot;Sentence Formalism&amp;quot;), presented in details in (Binot, 1984, 1985). Before generating the SF output, SABA builds a simplified semantic graph expressing all the scmantic dependencies established between the meaningful terms of the sentence. The graph established for sentence (1) is shown in figure (2). (2) BENEFICIARY VALUE INTENSITY pont 0 * * * QUAL long fort LR que OBJECT AGENT * convoi passer MOMENT AGENT OBJECT ii These kinds of dependencies are established by using the &amp;quot;dual frames&amp;quot; method described in (Binot and Ribbens 86). Dual frames is a general method for establishing binary semantic dependencies between all possible types of meaningfull terms. This method supports also a hierarchy of semantic classes and an inheritance mechanism allowing the designer to specify generic semantic frames at a general level. However, we are not concerned here by the specifics of a particular seman</context>
<context position="14203" citStr="(2)" startWordPosition="2300" endWordPosition="2300"> that it is not qualified by other subordinate clauses which should be processed first) if its right bound is not one of these terms. The leftmost free and subordinate clause, or, if none, the leftmost free clause will be chosen. Let us illustrate the effect of the above rules on example (1). The figure (3) below shows the successive states of the input text. In each state, the last fragmentation result is indicated by underlining the identified clauses. The semantic processing of the innermost clause selected at each step leads to the building of the corresponding part of the graph of figure (2). (3) Le pont,(Kue le convoi a passe ,quand il a quitte New-York ce matin etait fort long. Le pont ,que le convoi a passe IPC,etait fort long.. ,Le pont PR etait fort long. PP As can be seen, a single fragmentation pass will often yield imperfect results. There will be holes (sentence fragments which are not included in any clause, like &amp;quot;Le pont&amp;quot; in the first two steps) and overlappings (fragments which could be included in two clauses, like New-York cc matin&amp;quot; in the first step). This is where the repetitive nature of the fragmentation process comes into play. Successive 2 Except auxiliaries t</context>
</contexts>
<marker>2.</marker>
<rawString>Binot, J-L. 1985. SARA: vers un systeme portable d&apos;analyse du francais ecrit. Ph.D. dissertation, University of Liege, Belgium.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J-L Binot</author>
<author>D Ribbens</author>
</authors>
<title>Dual frames: a new tool for semantic parsing.</title>
<date>1986</date>
<booktitle>In Proc. A AA186,</booktitle>
<location>Philadelphia,</location>
<contexts>
<context position="13908" citStr="(3)" startWordPosition="2251" endWordPosition="2251">ted verb. The basic clause selection rules (for choosing the innermost clause) are equally simple. A clause is subordinate if its left bound is a relative or interrogative pronoun (or adjective), or a subordinate conjunction, or if its verb is an infinitive. A clause is said to be free (meaning that it is not qualified by other subordinate clauses which should be processed first) if its right bound is not one of these terms. The leftmost free and subordinate clause, or, if none, the leftmost free clause will be chosen. Let us illustrate the effect of the above rules on example (1). The figure (3) below shows the successive states of the input text. In each state, the last fragmentation result is indicated by underlining the identified clauses. The semantic processing of the innermost clause selected at each step leads to the building of the corresponding part of the graph of figure (2). (3) Le pont,(Kue le convoi a passe ,quand il a quitte New-York ce matin etait fort long. Le pont ,que le convoi a passe IPC,etait fort long.. ,Le pont PR etait fort long. PP As can be seen, a single fragmentation pass will often yield imperfect results. There will be holes (sentence fragments which are</context>
</contexts>
<marker>3.</marker>
<rawString>Binot J-L. and Ribbens D. 1986. Dual frames: a new tool for semantic parsing. In Proc. A AA186, Philadelphia, August 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J-L Binot</author>
<author>P-J Gaily</author>
<author>D Ribbens</author>
</authors>
<title>Elements d&apos;unc interface portable et robuste pour le francais ecrit.</title>
<date>1986</date>
<booktitle>In Proc. Huitiemes Journees de !Informatique Francophone,</booktitle>
<location>Grenoble,</location>
<contexts>
<context position="16031" citStr="(4)" startWordPosition="2599" endWordPosition="2599"> in the next section. Another interesting feature of the bottom-up algorithm is that the special symbol representing a processed subordinate clause will be naturally included, in later fragmentation steps, in the clause qualified by this subordinate, thus permitting to process correctly inter clause dependencies. 3.3 The ejection mechanism. A first class of problems for which the above fragmentation algorithm is not sufficient concerns cases when the deepest attachment preference fails. This problem occurs typically when a clause has no explicit clause boundary on one side, as in the examples (4) and (5) below: (4) ,J&apos;aime fhomme„que le presente a mon pere., (I love the man whom I introduce to my father) (5) ,Je presente fhomme ique faime a mon pere., (I introduce the man whom I love to my father) In both cases the relative clause has no explicit right boundary, and the attachment problem concerns the group &amp;quot;a mon pere&amp;quot;. The fragmentation result (shown by underlines) will in both cases include this group in the relative clause, which is wrong for (5). In such cases, the fragmentation will be automatically corrected, after the semantic processing of the relative clause, by a &amp;quot;right-eje</context>
</contexts>
<marker>4.</marker>
<rawString>Binot J-L, Gaily P-J. and Ribbens D. 1986. Elements d&apos;unc interface portable et robuste pour le francais ecrit. In Proc. Huitiemes Journees de !Informatique Francophone, Grenoble, January 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B K Boguraev</author>
</authors>
<title>Automatic resolution of linguistic ambiguities.</title>
<date>1979</date>
<tech>Ph.D. thesis,</tech>
<institution>University of Cambridge,</institution>
<location>England,</location>
<contexts>
<context position="16039" citStr="(5)" startWordPosition="2601" endWordPosition="2601">next section. Another interesting feature of the bottom-up algorithm is that the special symbol representing a processed subordinate clause will be naturally included, in later fragmentation steps, in the clause qualified by this subordinate, thus permitting to process correctly inter clause dependencies. 3.3 The ejection mechanism. A first class of problems for which the above fragmentation algorithm is not sufficient concerns cases when the deepest attachment preference fails. This problem occurs typically when a clause has no explicit clause boundary on one side, as in the examples (4) and (5) below: (4) ,J&apos;aime fhomme„que le presente a mon pere., (I love the man whom I introduce to my father) (5) ,Je presente fhomme ique faime a mon pere., (I introduce the man whom I love to my father) In both cases the relative clause has no explicit right boundary, and the attachment problem concerns the group &amp;quot;a mon pere&amp;quot;. The fragmentation result (shown by underlines) will in both cases include this group in the relative clause, which is wrong for (5). In such cases, the fragmentation will be automatically corrected, after the semantic processing of the relative clause, by a &amp;quot;right-ejection&amp;quot; m</context>
</contexts>
<marker>5.</marker>
<rawString>Boguraev B.K. 1979. Automatic resolution of linguistic ambiguities. Ph.D. thesis, University of Cambridge, England, 1979.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Jensen</author>
<author>G E Heidom</author>
<author>S Richardson</author>
<author>N Haas</author>
<author>PEG PLNLP</author>
</authors>
<title>CRITIQUE: three contributions to computing in the Humanities.</title>
<date>1986</date>
<booktitle>In Proc. of the conf on Computers and Humanities,</booktitle>
<location>Toronto,</location>
<contexts>
<context position="17169" citStr="(6)" startWordPosition="2802" endWordPosition="2802">r the semantic processing of the relative clause, by a &amp;quot;right-ejection&amp;quot; mechanism: Right ejection mechanism If a group G on the right of the verb remains unconnected after the semantic processing of a clause, and if there is no other term on the right of G which has been connected to a term on its left, then G and all terms on its right will be excluded from the current clause. In the case of example (5), assuming reasonnably that no semantic dependency can be established between &amp;quot;aime&amp;quot; and &amp;quot;a mon pere&amp;quot;, this last group will be ejected from n the relative clause, giving the situation shown in (6): (6) pie presente fhornme,que j&apos;aime a mon pere. Since fragmentation is interleaved with the semantic processing, the next fragmentation step will automatically pick up the discarded term after the processing of the relative clause, and insert it at the correct level: (7) le presente thomme PR a mon pere, The same mechanism applies to overlapping cases, such as in example (8): (8) L&apos;homme,que fai rencontrelsur la place m:a offer( un cafe.I (The man that I met in the square bought me a coffee) Here, two groups appear in the overlapping fragment. The first one, &amp;quot;sur la place&amp;quot; (&amp;quot;on the square&amp;quot;),</context>
</contexts>
<marker>6.</marker>
<rawString>Jensen K., Heidom G.E., Richardson S. and Haas N., PLNLP, PEG and CRITIQUE: three contributions to computing in the Humanities. In Proc. of the conf on Computers and Humanities, Toronto, April 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Klein</author>
<author>R F Simmons</author>
</authors>
<title>A computational approach to grammatical coding of English words.</title>
<date>1963</date>
<journal>Journal of the ACM.</journal>
<volume>10</volume>
<contexts>
<context position="17442" citStr="(7)" startWordPosition="2844" endWordPosition="2844">onnected to a term on its left, then G and all terms on its right will be excluded from the current clause. In the case of example (5), assuming reasonnably that no semantic dependency can be established between &amp;quot;aime&amp;quot; and &amp;quot;a mon pere&amp;quot;, this last group will be ejected from n the relative clause, giving the situation shown in (6): (6) pie presente fhornme,que j&apos;aime a mon pere. Since fragmentation is interleaved with the semantic processing, the next fragmentation step will automatically pick up the discarded term after the processing of the relative clause, and insert it at the correct level: (7) le presente thomme PR a mon pere, The same mechanism applies to overlapping cases, such as in example (8): (8) L&apos;homme,que fai rencontrelsur la place m:a offer( un cafe.I (The man that I met in the square bought me a coffee) Here, two groups appear in the overlapping fragment. The first one, &amp;quot;sur la place&amp;quot; (&amp;quot;on the square&amp;quot;), can easily be connected to the relative verb (as a location argument) and will remain in the relative clause. The second, &amp;quot;m&amp;quot; (&amp;quot;me&amp;quot;) cannot be connected to &amp;quot;rencontre&amp;quot; (&amp;quot;men, the object slot of that verb being already filled by the relative pronoun &amp;quot;que&amp;quot;. &amp;quot;m&amp;quot; will thus be</context>
</contexts>
<marker>7.</marker>
<rawString>Klein S. and Simmons R.F. A computational approach to grammatical coding of English words. Journal of the ACM. 10, March 1963.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S L Lytinen</author>
</authors>
<title>Dynamically combining syntax and semantics in natural language processing.</title>
<date>1986</date>
<booktitle>In Proc. of AAAI86,</booktitle>
<location>Philadelphia,</location>
<contexts>
<context position="17548" citStr="(8)" startWordPosition="2864" endWordPosition="2864">. In the case of example (5), assuming reasonnably that no semantic dependency can be established between &amp;quot;aime&amp;quot; and &amp;quot;a mon pere&amp;quot;, this last group will be ejected from n the relative clause, giving the situation shown in (6): (6) pie presente fhornme,que j&apos;aime a mon pere. Since fragmentation is interleaved with the semantic processing, the next fragmentation step will automatically pick up the discarded term after the processing of the relative clause, and insert it at the correct level: (7) le presente thomme PR a mon pere, The same mechanism applies to overlapping cases, such as in example (8): (8) L&apos;homme,que fai rencontrelsur la place m:a offer( un cafe.I (The man that I met in the square bought me a coffee) Here, two groups appear in the overlapping fragment. The first one, &amp;quot;sur la place&amp;quot; (&amp;quot;on the square&amp;quot;), can easily be connected to the relative verb (as a location argument) and will remain in the relative clause. The second, &amp;quot;m&amp;quot; (&amp;quot;me&amp;quot;) cannot be connected to &amp;quot;rencontre&amp;quot; (&amp;quot;men, the object slot of that verb being already filled by the relative pronoun &amp;quot;que&amp;quot;. &amp;quot;m&amp;quot; will thus be ejected from the relative clause, and included correctly in the main clause during the next fragmentation</context>
</contexts>
<marker>8.</marker>
<rawString>Lytinen S.L. 1986. Dynamically combining syntax and semantics in natural language processing. In Proc. of AAAI86, Philadelphia, August 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Merle</author>
</authors>
<title>Un analyseur presyntazique pour la levee des ambiguites dans des documents ecrits en langue naturelle: application a !indexation automatique&amp;quot;.Ph.D. thesis,</title>
<date>1982</date>
<institution>Institut National Polytechnique de Grenoble.</institution>
<contexts>
<context position="18696" citStr="(9)" startWordPosition="3049" endWordPosition="3049">rectly in the main clause during the next fragmentation step. It is worth mentiorming that this mechanism involves no backtracking and is extremely cheap in computational ressources. The only processing required is the displacement of the right clause boundary before erasing the text of the processed clause. 286 3.4. Infinitive clauses and backtracking. Infinitive clauses without an explicit left boundary (such as a subordinate conjunction) give rise to several interesting problems concerning both fragmentation itself and the selection of the innermost clause. Consider the following examples: (9) ,.1&apos; irai &apos;Ce soir a Paris,voir l&apos;exposition. (I will go this evening to Paris to see the exposition) (10) tle n&apos;ai jamais vu .11acques1travailler! (I never saw Jacques working) In both cases, there is an attachment problem for the terms in the overlapping area. In (9), all the terms in that area belong to the relative clause, while in (10) Jacques is the subject of the infinitive clause. One might want to define here a left-ejection&amp;quot; mechanism similar to the one described in the last section; however it would almost never work properly. Indeed, if terms such as this evening&amp;quot; or &amp;quot;to Paris&amp;quot; ar</context>
<context position="20263" citStr="(9)" startWordPosition="3334" endWordPosition="3334">l see, this term will conflict with the infinitive verb for fang the OBJECT slot of the main verb, and the system will have a reason to reject the wrong choice. Accordingly, we apply the following strategy: 1, try first to place the terms of the overlapping area in the main clause; in effect, this consists in preventing the infinitive clause to extend to the left of its verb; 2. if the choice made at point 1 fails, use a backtracking mechanism that will restore the proper state of the analysis and try to extend, one group at a time, the left bound of the infinitive clause. With this strategy, (9) will be processed correctly at the first try. (10) will lead to the following (erroneous) state of the analysis: ( II) ,Je n&apos;ai jamais vu Jacques PINE, where &amp;quot;Jacques&amp;quot; and PINF compete for the object slot of the main verb. The term PINE will then be ejected by the mechanism of the last section, giving the following state: (12) PP PINF This is a dead end state, since the sentence is not reduced to a PP symbol, and yet no further clause to process can be found. The backtracking mechanism will then restore the state shown in (10) with the following fragmentation, which leads to a successfull ana</context>
</contexts>
<marker>9.</marker>
<rawString>Merle A. 1982. Un analyseur presyntazique pour la levee des ambiguites dans des documents ecrits en langue naturelle: application a !indexation automatique&amp;quot;.Ph.D. thesis, Institut National Polytechnique de Grenoble.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Ristad</author>
</authors>
<title>Defining natural language grammars in GPSG.</title>
<date>1986</date>
<booktitle>In Proc. of the 24th meeting of the ACL,</booktitle>
<location>New-York,</location>
<contexts>
<context position="18803" citStr="(10)" startWordPosition="3068" endWordPosition="3068">involves no backtracking and is extremely cheap in computational ressources. The only processing required is the displacement of the right clause boundary before erasing the text of the processed clause. 286 3.4. Infinitive clauses and backtracking. Infinitive clauses without an explicit left boundary (such as a subordinate conjunction) give rise to several interesting problems concerning both fragmentation itself and the selection of the innermost clause. Consider the following examples: (9) ,.1&apos; irai &apos;Ce soir a Paris,voir l&apos;exposition. (I will go this evening to Paris to see the exposition) (10) tle n&apos;ai jamais vu .11acques1travailler! (I never saw Jacques working) In both cases, there is an attachment problem for the terms in the overlapping area. In (9), all the terms in that area belong to the relative clause, while in (10) Jacques is the subject of the infinitive clause. One might want to define here a left-ejection&amp;quot; mechanism similar to the one described in the last section; however it would almost never work properly. Indeed, if terms such as this evening&amp;quot; or &amp;quot;to Paris&amp;quot; are tried in the infinitive clause first, there would be no reason to reject them during the semantic process</context>
<context position="20314" citStr="(10)" startWordPosition="3343" endWordPosition="3343"> verb for fang the OBJECT slot of the main verb, and the system will have a reason to reject the wrong choice. Accordingly, we apply the following strategy: 1, try first to place the terms of the overlapping area in the main clause; in effect, this consists in preventing the infinitive clause to extend to the left of its verb; 2. if the choice made at point 1 fails, use a backtracking mechanism that will restore the proper state of the analysis and try to extend, one group at a time, the left bound of the infinitive clause. With this strategy, (9) will be processed correctly at the first try. (10) will lead to the following (erroneous) state of the analysis: ( II) ,Je n&apos;ai jamais vu Jacques PINE, where &amp;quot;Jacques&amp;quot; and PINF compete for the object slot of the main verb. The term PINE will then be ejected by the mechanism of the last section, giving the following state: (12) PP PINF This is a dead end state, since the sentence is not reduced to a PP symbol, and yet no further clause to process can be found. The backtracking mechanism will then restore the state shown in (10) with the following fragmentation, which leads to a successfull analysis: (13) , Je n&apos;ai jamais vulacques travailler.)</context>
</contexts>
<marker>10.</marker>
<rawString>Ristad E.. 1986. Defining natural language grammars in GPSG. In Proc. of the 24th meeting of the ACL, New-York, June 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R C Schank</author>
<author>M Leibowitz</author>
<author>L Birnbaum</author>
</authors>
<title>An integrated understander.</title>
<date>1980</date>
<journal>In Journal of the ACL,</journal>
<volume>6</volume>
<marker>11.</marker>
<rawString>Schank R.C., Leibowitz M. and Birnbaum L. 1980. An integrated understander. In Journal of the ACL, 6:1.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Shieber</author>
</authors>
<title>An introduction to unification-based approaches to grammar,</title>
<date>1986</date>
<publisher>Press.</publisher>
<institution>University of Chicago</institution>
<contexts>
<context position="20592" citStr="(12)" startWordPosition="3393" endWordPosition="3393">finitive clause to extend to the left of its verb; 2. if the choice made at point 1 fails, use a backtracking mechanism that will restore the proper state of the analysis and try to extend, one group at a time, the left bound of the infinitive clause. With this strategy, (9) will be processed correctly at the first try. (10) will lead to the following (erroneous) state of the analysis: ( II) ,Je n&apos;ai jamais vu Jacques PINE, where &amp;quot;Jacques&amp;quot; and PINF compete for the object slot of the main verb. The term PINE will then be ejected by the mechanism of the last section, giving the following state: (12) PP PINF This is a dead end state, since the sentence is not reduced to a PP symbol, and yet no further clause to process can be found. The backtracking mechanism will then restore the state shown in (10) with the following fragmentation, which leads to a successfull analysis: (13) , Je n&apos;ai jamais vulacques travailler.) Infinitive clauses raise also problems concerning the selection of the innermost clause. Consider the following examples: (14) ,J&apos;ai vu un homme.qui voulaic dormir sur le trottoir., (I saw a man who wanted to sleep on the street) (15) ,J&apos;ai vu un homme,pui avail buadormir sur </context>
</contexts>
<marker>12.</marker>
<rawString>Shieber S. 1986. An introduction to unification-based approaches to grammar, University of Chicago Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Shortliffe E 11</author>
</authors>
<title>Computer-based medical consultation:</title>
<date>1976</date>
<publisher>MYCIN Elsevier.</publisher>
<contexts>
<context position="20874" citStr="(13)" startWordPosition="3444" endWordPosition="3444">e processed correctly at the first try. (10) will lead to the following (erroneous) state of the analysis: ( II) ,Je n&apos;ai jamais vu Jacques PINE, where &amp;quot;Jacques&amp;quot; and PINF compete for the object slot of the main verb. The term PINE will then be ejected by the mechanism of the last section, giving the following state: (12) PP PINF This is a dead end state, since the sentence is not reduced to a PP symbol, and yet no further clause to process can be found. The backtracking mechanism will then restore the state shown in (10) with the following fragmentation, which leads to a successfull analysis: (13) , Je n&apos;ai jamais vulacques travailler.) Infinitive clauses raise also problems concerning the selection of the innermost clause. Consider the following examples: (14) ,J&apos;ai vu un homme.qui voulaic dormir sur le trottoir., (I saw a man who wanted to sleep on the street) (15) ,J&apos;ai vu un homme,pui avail buadormir sur le trottoir., (I saw a man who was drunk sleep on the street) In both cases, the selection rules will choose to process the infinitive clause first. This choice is wrong for (15): if the relative relative clause is not processed fust, its presence will prevent the system to find ou</context>
</contexts>
<marker>13.</marker>
<rawString>Shortliffe E.11. 1976. Computer-based medical consultation: MYCIN Elsevier.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Weir DJ</author>
<author>K Vijay-Shanker</author>
<author>A K Joshi</author>
</authors>
<title>The relationship between Tree adjoining grammars and head grammars.</title>
<date>1986</date>
<booktitle>In Proc. of the 24th meeting of the ACL,</booktitle>
<location>New-York,</location>
<contexts>
<context position="21041" citStr="(14)" startWordPosition="3467" endWordPosition="3467">INF compete for the object slot of the main verb. The term PINE will then be ejected by the mechanism of the last section, giving the following state: (12) PP PINF This is a dead end state, since the sentence is not reduced to a PP symbol, and yet no further clause to process can be found. The backtracking mechanism will then restore the state shown in (10) with the following fragmentation, which leads to a successfull analysis: (13) , Je n&apos;ai jamais vulacques travailler.) Infinitive clauses raise also problems concerning the selection of the innermost clause. Consider the following examples: (14) ,J&apos;ai vu un homme.qui voulaic dormir sur le trottoir., (I saw a man who wanted to sleep on the street) (15) ,J&apos;ai vu un homme,pui avail buadormir sur le trottoir., (I saw a man who was drunk sleep on the street) In both cases, the selection rules will choose to process the infinitive clause first. This choice is wrong for (15): if the relative relative clause is not processed fust, its presence will prevent the system to find out that the group &amp;quot;un homme&amp;quot; is in fact the subject of the infinitive clause. Processing the infinitive first, the system will reach a dead end after the following step</context>
</contexts>
<marker>14.</marker>
<rawString>Weir DJ., Vijay-Shanker K. and Joshi A.K. 1986. The relationship between Tree adjoining grammars and head grammars. In Proc. of the 24th meeting of the ACL, New-York, June</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Wilks</author>
</authors>
<title>An intelligent analyser and understander of English.</title>
<date>1975</date>
<journal>CACM</journal>
<volume>18</volume>
<contexts>
<context position="21149" citStr="(15)" startWordPosition="3488" endWordPosition="3488"> last section, giving the following state: (12) PP PINF This is a dead end state, since the sentence is not reduced to a PP symbol, and yet no further clause to process can be found. The backtracking mechanism will then restore the state shown in (10) with the following fragmentation, which leads to a successfull analysis: (13) , Je n&apos;ai jamais vulacques travailler.) Infinitive clauses raise also problems concerning the selection of the innermost clause. Consider the following examples: (14) ,J&apos;ai vu un homme.qui voulaic dormir sur le trottoir., (I saw a man who wanted to sleep on the street) (15) ,J&apos;ai vu un homme,pui avail buadormir sur le trottoir., (I saw a man who was drunk sleep on the street) In both cases, the selection rules will choose to process the infinitive clause first. This choice is wrong for (15): if the relative relative clause is not processed fust, its presence will prevent the system to find out that the group &amp;quot;un homme&amp;quot; is in fact the subject of the infinitive clause. Processing the infinitive first, the system will reach a dead end after the following steps: (16) Ifai vu un homme.,qui avail bu PINF, (ejection of PINF) vu un homme PR PMF,(ejection of PINE) PP PIN</context>
</contexts>
<marker>15.</marker>
<rawString>Wilks Y. 1975. An intelligent analyser and understander of English. CACM 18:5, May 1975.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>