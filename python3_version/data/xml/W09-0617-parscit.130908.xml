<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.011474">
<title confidence="0.986504">
Generating Natural Language Descriptions of Ontology Concepts
</title>
<author confidence="0.994592">
Niels Sch¨utte
</author>
<affiliation confidence="0.998224">
Dublin Institute of Technology
</affiliation>
<address confidence="0.65608">
Dublin, Ireland
</address>
<email confidence="0.989085">
niels.schutte@student.dit.ie
</email>
<sectionHeader confidence="0.993649" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999980818181818">
This paper gives an overview of ongo-
ing work on a system for the generation
of NL descriptions of classes defined in
OWL ontologies. We present a general
structuring approach for such descriptions.
Since OWL ontologies do not by default
contain the information necessary for lex-
icalization, lexical information has to be
added to the data via annotations. A rule-
based mechanism for automatically deriv-
ing these annotations is presented.
</bodyText>
<sectionHeader confidence="0.994324" genericHeader="keywords">
1 Overview
</sectionHeader>
<bodyText confidence="0.999961">
There exists a body of works regarding the ver-
balization of content from RDF data or ontologies
like OWL. Some approaches (such as (Galanis and
Androutsopoulos, 2007)) rely on rich domain de-
pendent resources, while other approaches try to
do away with such resources as much as possible
and derive information such as lexicalization data
that is not explicitly included in the ontology from
the available data.
</bodyText>
<sectionHeader confidence="0.962592" genericHeader="introduction">
2 Data Model and Message Definition
</sectionHeader>
<bodyText confidence="0.9999024">
The goal of the system is to generate natural lan-
guage texts from class definitions in an OWL on-
tology that serve as a description of the class.
To generate textual descriptions, linguistic rep-
resentations for the contents of the ontology have
to be found. Since OWL ontologies do not by de-
fault contain the information necessary for lexical-
ization, lexical information has to be added to the
data. In the current system, classes are assumed
to represent simple objects of the world and there-
fore to be realizable as noun phrases that can be
lexicalized with the name of the class.
Attributes of classes are described in OWL by
defining restrictions that apply to so called prop-
erties. Properties are binary relations among on-
tology objects. They are realized as syntactic
structures that connect objects. During annotation,
each property is assigned a certain relation type
that determines the syntactic structure that is used
to realize the property.
</bodyText>
<subsectionHeader confidence="0.979608">
2.1 Relation types
</subsectionHeader>
<bodyText confidence="0.972936638888889">
The relation types form an abstraction over the
possible structural realizations of properties by
providing a specification of a surface structure that
can be used to realize the property. Depending
on the type of the relation, a number of other at-
tributes of the relation may be specified to deter-
mine details of the realization, such as lexical-
izations for some elements of the structure and a
specification about how to fill the parameters of
the configuration with the parameters of the prop-
erty. At the moment there exists a small set of re-
lation types that covers most of the relations in the
example ontologies that were considered for the
system. This approach corresponds with the re-
sults presented in (Hewlett et al, 2005) where the
authors affirm to have found a small set of patterns
that covers most of the properties in a number of
major ontologies.
The relation type of a property also determines
whether a property can be expressed as an adjec-
tive modifier. This information can be exploited
in aggregation operations to create more concise
text.
The two most important relation types are the
ones called simple and roleplaying.
simple specifies that the properties should be
realized as a simple configuration of two partici-
pants that are connected with a verb in the active
form. This type fits preferably for properties like
“eats” or “produces”. The objects in the domain
and range position of the property are most often
mapped straight to domain and range parameters
of the relation. Apart from this, it has to be deter-
mined which word to use to lexicalize the verb that
Proceedings of the 12th European Workshop on Natural Language Generation, pages 106–109,
Athens, Greece, 30 – 31 March 2009. c�2009 Association for Computational Linguistics
</bodyText>
<page confidence="0.997893">
106
</page>
<bodyText confidence="0.9978016875">
appears in the realization of the property. A typ-
ical sentence formed with a property of this type
(in this example the property “eats”) would be
A mouse eats only cheese.
roleplaying specifies that the property should be
realized as a configuration in which one partici-
pant fulfills a certain role for another participants.
This relation is typically used to realize proper-
ties like “hasColor” or “hasHabitat”, since even
though the property itself is a binary relation, its
name suggests to express it as a configuration that
involves, apart from the domain and range objects,
a third object whose lexicalization is derived from
the name of the property. A sentence for the prop-
erty “hasParent” of this type would be:
A child has at most 2 humans as parent.
</bodyText>
<subsectionHeader confidence="0.993809">
2.2 Automatic Annotation
</subsectionHeader>
<bodyText confidence="0.998844888888889">
In this section we describe our approach to auto-
matically generating annotations using rules based
on a part of speech analysis of the property name.
A rule consists of a pattern and a specification of
the relation that is to be used to realize the prop-
erty. The pattern is a sequence of part of speech
elements. A pattern fits a property, if the property
name can be split into words whose part of speech
are equal to the sequence specified by the pattern
</bodyText>
<listItem confidence="0.323962">
1.
</listItem>
<bodyText confidence="0.9769591875">
If the pattern fits, the relation is instantiated ac-
cording to the specification associated in the rule
with the pattern. Keywords can be used to assign
the objects in the domain or range position to the
domain or range slot of the relation. Names of
parts of speech detected in the pattern can also be
used to assign parts of the property name as lexi-
calization to elements of the relation. The follow-
ing rule is currently used in the system:
VP -&gt; Simple (SUBJ, OBJ, VP)
It assigns properties like “eats” to simple rela-
tions that use the domain object of the property as
domain object and the range subject likewise. The
element of the property name “VP” (in the exam-
ple for “eats”, simply “eats”) is used to lexicalize
the verb of the relation. Detected elements are al-
ways reduced to their stem before assigning lexi-
calizations (e.g. “eat” is actually assigned instead
of “eats”). The following rule currently assigns
properties like “hasColor” to roleplaying relations.
1We are currently exploring if this approach should be ex-
tended to regular expressions instead of sequences.
The COND part specifies an additional condi-
tion where certain parts of the pattern have to be
filled with special words. The inclusion of special
conditions for the rules allows it to create more
specific patterns.
At this stage, the automatic assignment is only
performed for annotating properties. It is however
possible to extend this approach to classnames to
create linguistically more complex lexicalizations
for classes.
</bodyText>
<sectionHeader confidence="0.997641" genericHeader="method">
3 Structuring
</sectionHeader>
<bodyText confidence="0.987092142857143">
The description texts generated by our system are
structured based on analysis of texts from encyclo-
pedia entries and the possible relations among the
available pieces of information. The information
available in the definition is dissected into discrete
message objects. Before structuring begins, the
system attempts to summarize some of the infor-
mation from the definition.For example it is possi-
ble to combine cardinality restrictions without los-
ing information.
The structure of the descriptions consists of an
introductory passage, whose main purpose it is
to give a quick burst of information about the
class, and a sequence of subsequent sections that
presents the remaining information about the class
structured according to the properties of the class.
The description is closed with the presentation of
the classes the subject class is disjoint with. In
general each element is realized as one complex
sentence.
The introduction starts off with information
about what kind of thing the class is. This is re-
alized by introducing the messages presenting the
immediate superclasses of the class. To set the
class apart from the superclasses the introduction
is enriched with as much additional information
as possible and textually sensible. This informa-
tion is linked as closely as possible to the super-
class message. This is realized by adding mes-
sages that can be transformed into adjective modi-
fiers to the reference to the subject class in the first
sentence, and adding more information as a rela-
tive sentence. This results in sentences such as:
A grizzly bear is a large bear that lives only in
North America.
</bodyText>
<note confidence="0.3845205">
VP NP -&gt; RolePlaying(SUBJ, OBJ, VP, NP)
COND has(VP)
</note>
<page confidence="0.994494">
107
</page>
<bodyText confidence="0.999978052631579">
This phrase consists of three distinct pieces of
information from the ontology: the immediate su-
perclass of the class “grizzly bear” and two re-
strictions for a property named “hasSize” (e.g. I
hasSize {Large}) and “livesIn” (e.g. V livesIn
NorthAmerica). The first restriction was chosen
for this position because it can be expressed as
an adjective. Whether and how a message can be
transformed into an adjective is determined by the
attributes of the relation type of the property of
the restriction that is the source of the message. In
this case, a manual annotator has decided that the
values of the “hasSize” property can be alterna-
tively be directly used as adjectives of the subject
of the description instead of using the default re-
alization of the roleplaying relation. This decision
can just as well be made heuristically in the auto-
matic annotation generation process. The criterion
here would be that the word “Size” that specifies
the role played by the range object refers to an
immediate quality of the class. Other candidates
for a class of such words are “Color” or “Gender”.
However there exists a great number of properties
that fit the roleplaying pattern for which such a
transformation would not be appropriate. Exam-
ples include the properties “hasParents” or “has-
Maker”. In these properties the role refers to an
object external to the class rather than to an imme-
diate quality of it.
The rest of the available information is ordered
into groups according to the property (property
groups) that is restricted by the restriction that is
contained in the message. This produces groups
of messages that all pertain to the same property.
Those property groups are the first step towards
text sections that deal with one particular attribute
of the class that is described through restrictions
on each property addressed.
</bodyText>
<sectionHeader confidence="0.981244" genericHeader="method">
4 Microplanning
</sectionHeader>
<bodyText confidence="0.9998996875">
In the next step, microplanning is performed to
derive complete text specifications. Most of the
structuring that is left to be done is performed in
the property groups and is linked with microplan-
ning operations such as aggregation and is there-
fore performed at this stage.
Depending on the types of the restrictions in the
messages, rhetorical structures are formed inside
each group. Figure 1 gives an overview of pos-
sible structures inside a group. The boxes repre-
sent complexes of messages based on groups of
restrictions. The names refer to the names for re-
striction types used in the Manchester Syntax for
OWL, with CARD summarizing all cardinality re-
strictions. The labels on the arcs represent rhetor-
ical relations that connect the complexes.
</bodyText>
<figureCaption confidence="0.999568">
Figure 1: Structure inside groups
</figureCaption>
<bodyText confidence="0.9999072">
The SOME restrictions and CARD restrictions
can be combined, since both make statements
about the positive existence of objects. This com-
bination is linked to the ONLY restrictions via an
elaboration. VALUE restrictions finally can be
connected to this complex via an exemplification
relation since they make a statement about con-
crete objects as opposed to the statements about
possible objects made by the other restrictions.
An example for a statement generated from
a moderately complex structure containing an
ONLY restriction and an EXACTLY restriction
would be this sentence:
A gizzly bear has only bears as parents and it has
exactly two bears as parents.
The semantic content behind this sentence is a
group of messages concerning the property “has-
Parent”, that contains messages derived from the
restrictions V parent bear and = hasParent 2. Fig-
ure 2 presents the structure that is formed inside
the group. The SOME block formed from the
cardinality restrictions and the SOME restrictions
which are not present in this example. The result-
ing block is then connected to the ONLY block. It
should be noted that the ONLY restriction is ex-
ploited to determine the term that is used to lex-
icalize the range object of the message from the
cardinality restriction, since the restrictions given
through it are normally more specific than the nor-
mal range defined for the property.
</bodyText>
<page confidence="0.997705">
108
</page>
<figureCaption confidence="0.961644">
Figure 2: Example of structure inside a group in
action
</figureCaption>
<bodyText confidence="0.9999015">
The task of Referring Expression Generation
stage in this system currently only makes sure an
appropiate pronoun is used in subsequent refer-
ence to the subject of the description. In general
the neutral pronoun “it” is used, unless a restric-
tion is found that can be interpreted as an informa-
tion about the gender of the class.
A complete description text for the concept of a
grizzly bear taking reference expressions into ac-
count may be:
A grizzly bear is a large bear that lives only in
north america. It has only bears as parents and it
has exactly two bears as parents. A grizzly bear
can not be an ice bear or a brown bear.
The first sentence is the introduction of the de-
scription. The second sentence is the realization
of the property group of the property “hasParent”.
The last sentence finally presents the classes the
subject class is disjoint with and closes the de-
scription.
Surface Generation is performed by the KPML
language generation system (Bateman, 1997). The
structural relations of the text plan, the linguistic
relations inside the messages and the representa-
tions of classes are enriched with SPL plan frag-
ments that combine to form a complete specifica-
tion for a text. The type of a restriction is realized
as a modification of the message.
</bodyText>
<sectionHeader confidence="0.999277" genericHeader="conclusions">
5 Conclusion
</sectionHeader>
<bodyText confidence="0.999987035714286">
The system generates sensible texts for a number
of classes in a number of ontologies. The proposed
schema for the structure of the text appears to pro-
duce natural sounding introductions to the text as
well a sensible organization for the remaining bulk
of the information. We are not aware of a sys-
tem that performs the same task to the same de-
gree without relying on more domain specific re-
sources. The system does not and can not cover all
imaginable ontologies. Problems especially arise
from complex class definitions that contain nested
class definitions, since they can require quite com-
plex linguistic structures. For evaluation, testers
familiar with the OWL formalism will be asked to
judge whether the produced texts accurately rep-
resent the specified information, and whether the
texts appear natural.
The structure-based annotation mechanism
profits from well organized approaches to naming
classes and properties, but runs into problems if
names cannot be fitted into the expected patterns.
In this case, the generated annotations have to be
checked manually and need to be corrected. If for-
mal patterns like simple grammars for naming can
be agreed upon during the design of the ontology,
these patterns can be exploited directly to generate
annotations. This might be worth considering as a
step in ontology development.
</bodyText>
<sectionHeader confidence="0.996039" genericHeader="acknowledgments">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.999884">
The author would like to thank John Bateman for
his input to the work and his help with this pa-
per, and John Kelleher for his reviewing and com-
ments.
</bodyText>
<sectionHeader confidence="0.999227" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.998025705882353">
Dimitrios Galanis and Ion Androutsopoulos 2007.
Generating Multilingual Personalized Descriptions
from OWL Ontologies on the Semantic Web: the Nat-
uralOWL System
Xiantang Sun and Chris Mellish 2006. Domain Inde-
pendent Sentence Generation from RDF Represen-
tations for the Semantic Web
Daniel Hewlett and Aditya Kalyanpur and Vladimir
Kolovski and Christian Halaschek-Wiener 2005.
Effective NL Paraphrasing of Ontologies on the Se-
mantic Web.
Ehud Reiter and Robert Dale 2000. Building natural
language generation systems. Cambridge Press.
Bateman, J. A. 1997. Enabling technology for mul-
tilingual natural language generation: the KPML
development environment Journal of Natural Lan-
guage Engineering 3(1)
</reference>
<page confidence="0.998947">
109
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.441314">
<title confidence="0.999283">Generating Natural Language Descriptions of Ontology Concepts</title>
<author confidence="0.784294">Niels</author>
<affiliation confidence="0.8266095">Dublin Institute of Dublin,</affiliation>
<email confidence="0.982473">niels.schutte@student.dit.ie</email>
<abstract confidence="0.99904979375">This paper gives an overview of ongoing work on a system for the generation of NL descriptions of classes defined in OWL ontologies. We present a general structuring approach for such descriptions. Since OWL ontologies do not by default contain the information necessary for lexicalization, lexical information has to be added to the data via annotations. A rulebased mechanism for automatically deriving these annotations is presented. 1 Overview There exists a body of works regarding the verbalization of content from RDF data or ontologies like OWL. Some approaches (such as (Galanis and Androutsopoulos, 2007)) rely on rich domain dependent resources, while other approaches try to do away with such resources as much as possible and derive information such as lexicalization data that is not explicitly included in the ontology from the available data. 2 Data Model and Message Definition The goal of the system is to generate natural language texts from class definitions in an OWL ontology that serve as a description of the class. To generate textual descriptions, linguistic representations for the contents of the ontology have to be found. Since OWL ontologies do not by default contain the information necessary for lexicalization, lexical information has to be added to the data. In the current system, classes are assumed to represent simple objects of the world and therefore to be realizable as noun phrases that can be lexicalized with the name of the class. Attributes of classes are described in OWL by apply to so called prop- Properties are binary relations among ontology objects. They are realized as syntactic structures that connect objects. During annotation, property is assigned a certain type that determines the syntactic structure that is used to realize the property. 2.1 Relation types The relation types form an abstraction over the possible structural realizations of properties by providing a specification of a surface structure that can be used to realize the property. Depending on the type of the relation, a number of other attributes of the relation may be specified to determine details of the realization, such as lexicalizations for some elements of the structure and a specification about how to fill the parameters of the configuration with the parameters of the property. At the moment there exists a small set of relation types that covers most of the relations in the example ontologies that were considered for the system. This approach corresponds with the results presented in (Hewlett et al, 2005) where the authors affirm to have found a small set of patterns that covers most of the properties in a number of major ontologies. The relation type of a property also determines whether a property can be expressed as an adjective modifier. This information can be exploited in aggregation operations to create more concise text. The two most important relation types are the called that the properties should be realized as a simple configuration of two participants that are connected with a verb in the active form. This type fits preferably for properties like “eats” or “produces”. The objects in the domain and range position of the property are most often mapped straight to domain and range parameters of the relation. Apart from this, it has to be determined which word to use to lexicalize the verb that of the 12th European Workshop on Natural Language pages Greece, 30 – 31 March 2009. Association for Computational Linguistics 106 appears in the realization of the property. A typical sentence formed with a property of this type (in this example the property “eats”) would be A mouse eats only cheese. that the property should be realized as a configuration in which one participant fulfills a certain role for another participants. This relation is typically used to realize properties like “hasColor” or “hasHabitat”, since even though the property itself is a binary relation, its name suggests to express it as a configuration that involves, apart from the domain and range objects, a third object whose lexicalization is derived from the name of the property. A sentence for the property “hasParent” of this type would be: A child has at most 2 humans as parent. 2.2 Automatic Annotation In this section we describe our approach to automatically generating annotations using rules based on a part of speech analysis of the property name. A rule consists of a pattern and a specification of the relation that is to be used to realize the property. The pattern is a sequence of part of speech elements. A pattern fits a property, if the property name can be split into words whose part of speech are equal to the sequence specified by the pattern If the pattern fits, the relation is instantiated according to the specification associated in the rule with the pattern. Keywords can be used to assign the objects in the domain or range position to the domain or range slot of the relation. Names of parts of speech detected in the pattern can also be used to assign parts of the property name as lexicalization to elements of the relation. The following rule is currently used in the system: VP -&gt; Simple (SUBJ, OBJ, VP) assigns properties like “eats” to relations that use the domain object of the property as domain object and the range subject likewise. The element of the property name “VP” (in the example for “eats”, simply “eats”) is used to lexicalize the verb of the relation. Detected elements are always reduced to their stem before assigning lexicalizations (e.g. “eat” is actually assigned instead of “eats”). The following rule currently assigns like “hasColor” to are currently exploring if this approach should be extended to regular expressions instead of sequences. specifies an additional condition where certain parts of the pattern have to be filled with special words. The inclusion of special conditions for the rules allows it to create more specific patterns. At this stage, the automatic assignment is only performed for annotating properties. It is however possible to extend this approach to classnames to create linguistically more complex lexicalizations for classes. 3 Structuring The description texts generated by our system are structured based on analysis of texts from encyclopedia entries and the possible relations among the available pieces of information. The information available in the definition is dissected into discrete message objects. Before structuring begins, the system attempts to summarize some of the information from the definition.For example it is possible to combine cardinality restrictions without losing information. The structure of the descriptions consists of an introductory passage, whose main purpose it is to give a quick burst of information about the class, and a sequence of subsequent sections that presents the remaining information about the class structured according to the properties of the class. The description is closed with the presentation of the classes the subject class is disjoint with. In general each element is realized as one complex sentence.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Dimitrios Galanis</author>
<author>Ion Androutsopoulos</author>
</authors>
<date>2007</date>
<booktitle>Generating Multilingual Personalized Descriptions from OWL Ontologies on the Semantic Web: the NaturalOWL System</booktitle>
<contexts>
<context position="776" citStr="Galanis and Androutsopoulos, 2007" startWordPosition="112" endWordPosition="115">ent.dit.ie Abstract This paper gives an overview of ongoing work on a system for the generation of NL descriptions of classes defined in OWL ontologies. We present a general structuring approach for such descriptions. Since OWL ontologies do not by default contain the information necessary for lexicalization, lexical information has to be added to the data via annotations. A rulebased mechanism for automatically deriving these annotations is presented. 1 Overview There exists a body of works regarding the verbalization of content from RDF data or ontologies like OWL. Some approaches (such as (Galanis and Androutsopoulos, 2007)) rely on rich domain dependent resources, while other approaches try to do away with such resources as much as possible and derive information such as lexicalization data that is not explicitly included in the ontology from the available data. 2 Data Model and Message Definition The goal of the system is to generate natural language texts from class definitions in an OWL ontology that serve as a description of the class. To generate textual descriptions, linguistic representations for the contents of the ontology have to be found. Since OWL ontologies do not by default contain the information</context>
</contexts>
<marker>Galanis, Androutsopoulos, 2007</marker>
<rawString>Dimitrios Galanis and Ion Androutsopoulos 2007. Generating Multilingual Personalized Descriptions from OWL Ontologies on the Semantic Web: the NaturalOWL System</rawString>
</citation>
<citation valid="true">
<authors>
<author>Xiantang Sun</author>
<author>Chris Mellish</author>
</authors>
<title>Domain Independent Sentence Generation from RDF Representations for the Semantic Web</title>
<date>2006</date>
<marker>Sun, Mellish, 2006</marker>
<rawString>Xiantang Sun and Chris Mellish 2006. Domain Independent Sentence Generation from RDF Representations for the Semantic Web</rawString>
</citation>
<citation valid="true">
<authors>
<author>Daniel Hewlett</author>
<author>Aditya Kalyanpur</author>
<author>Vladimir Kolovski</author>
<author>Christian Halaschek-Wiener</author>
</authors>
<date>2005</date>
<booktitle>Effective NL Paraphrasing of Ontologies on the Semantic Web.</booktitle>
<contexts>
<context position="2761" citStr="Hewlett et al, 2005" startWordPosition="444" endWordPosition="447">ecification of a surface structure that can be used to realize the property. Depending on the type of the relation, a number of other attributes of the relation may be specified to determine details of the realization, such as lexicalizations for some elements of the structure and a specification about how to fill the parameters of the configuration with the parameters of the property. At the moment there exists a small set of relation types that covers most of the relations in the example ontologies that were considered for the system. This approach corresponds with the results presented in (Hewlett et al, 2005) where the authors affirm to have found a small set of patterns that covers most of the properties in a number of major ontologies. The relation type of a property also determines whether a property can be expressed as an adjective modifier. This information can be exploited in aggregation operations to create more concise text. The two most important relation types are the ones called simple and roleplaying. simple specifies that the properties should be realized as a simple configuration of two participants that are connected with a verb in the active form. This type fits preferably for prop</context>
</contexts>
<marker>Hewlett, Kalyanpur, Kolovski, Halaschek-Wiener, 2005</marker>
<rawString>Daniel Hewlett and Aditya Kalyanpur and Vladimir Kolovski and Christian Halaschek-Wiener 2005. Effective NL Paraphrasing of Ontologies on the Semantic Web.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ehud Reiter</author>
<author>Robert Dale</author>
</authors>
<title>Building natural language generation systems.</title>
<date>2000</date>
<publisher>Cambridge Press.</publisher>
<marker>Reiter, Dale, 2000</marker>
<rawString>Ehud Reiter and Robert Dale 2000. Building natural language generation systems. Cambridge Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J A Bateman</author>
</authors>
<title>Enabling technology for multilingual natural language generation: the KPML development environment</title>
<date>1997</date>
<journal>Journal of Natural Language Engineering</journal>
<volume>3</volume>
<issue>1</issue>
<contexts>
<context position="13315" citStr="Bateman, 1997" startWordPosition="2203" endWordPosition="2204">he concept of a grizzly bear taking reference expressions into account may be: A grizzly bear is a large bear that lives only in north america. It has only bears as parents and it has exactly two bears as parents. A grizzly bear can not be an ice bear or a brown bear. The first sentence is the introduction of the description. The second sentence is the realization of the property group of the property “hasParent”. The last sentence finally presents the classes the subject class is disjoint with and closes the description. Surface Generation is performed by the KPML language generation system (Bateman, 1997). The structural relations of the text plan, the linguistic relations inside the messages and the representations of classes are enriched with SPL plan fragments that combine to form a complete specification for a text. The type of a restriction is realized as a modification of the message. 5 Conclusion The system generates sensible texts for a number of classes in a number of ontologies. The proposed schema for the structure of the text appears to produce natural sounding introductions to the text as well a sensible organization for the remaining bulk of the information. We are not aware of a</context>
</contexts>
<marker>Bateman, 1997</marker>
<rawString>Bateman, J. A. 1997. Enabling technology for multilingual natural language generation: the KPML development environment Journal of Natural Language Engineering 3(1)</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>