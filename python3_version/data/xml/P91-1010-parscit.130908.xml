<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<note confidence="0.933593">
TYPE-RAISING AND DIRECTIONALITY IN COMBINATORY GRAMMAR*
</note>
<author confidence="0.856872">
Mark Steedman
</author>
<affiliation confidence="0.811937">
Computer and Information Science, University of Pennsylvania
</affiliation>
<bodyText confidence="0.554436">
200 South 33n1 Street
Philadelphia PA 19104-6389, USA
(Internet: st eedma n@cis . upenn . edu)
</bodyText>
<sectionHeader confidence="0.880323" genericHeader="abstract">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.999369642857143">
The form of rules in combinatory categorial grammars
(CCG) is constrained by three principles, called &amp;quot;adja-
cency&amp;quot;, &amp;quot;consistency&amp;quot; and &amp;quot;inheritance&amp;quot;. These principles
have been claimed elsewhere to constrain the combinatory
rules of composition and type raising in such a way as to
make certain linguistic universals concerning word order
under coordination follow immediately. The present paper
shows that the three principles have a natural expression
in a unification-based interpretation of CCG in which di-
rectional information is an attribute of the arguments of
functions grounded in string position. The universals can
thereby be derived as consequences of elementary assump-
tions. Some desirable results for grammars and parsers fol-
low, concerning type-raising rules.
</bodyText>
<sectionHeader confidence="0.674594" genericHeader="keywords">
PRELIMINARIES
</sectionHeader>
<bodyText confidence="0.999620375">
In Categorial Grammar (CG), elements like verbs are
associated with a syntactic &amp;quot;category&amp;quot;, which identi-
fies their functional type. I shall use a notation in
which the argument or domain category always ap-
pears to the right of the slash, and the result or range
category to the left. A forward slash / means that the
argument in question must appear on the right, while
a backward slash \ means it must appear on the left.
</bodyText>
<equation confidence="0.534561">
(1) enjoys := (S\NP)/NP
</equation>
<bodyText confidence="0.999699875">
The category (S\NP)/NP can be regarded as both
a syntactic and a semantic object, in which symbols
like S are abbreviations for graphs or terms including
interpretations, as in the unification-based categorial
grammars of Zeevat et al. [8] and others (and cf. [6]).
Such functions can combine with arguments of the
appropriate type and position by rules of functional
application, written as follows:
</bodyText>
<figure confidence="0.853803666666667">
(2) The Functional Application Rules:
a. X1Y Y =X(&gt;)
b. Y X\Y = X (&lt;)
</figure>
<bodyText confidence="0.523713">
Such rules are also both syntactic and semantic rules
</bodyText>
<note confidence="0.817549">
*Thanks to Michael Niv and Sui Shieber. Support from: NSF
Grant CISE HP CDA 88-22719, DARPA grant no. N0014-90-J-
1863, and ARO grant no. DAAL03-89-00031.
</note>
<bodyText confidence="0.9705004">
of combination in which X and Y are abbreviations
for more complex objects which combine via unifi-
cation. They allow context-free derivations like the
following (the application of rules is indicated by in-
dices &gt;, &lt; on the underlines:
</bodyText>
<figure confidence="0.355652">
(3) Mary enjoys musicals
NP (S\NP)/NP NP
S \ NP
</figure>
<bodyText confidence="0.9886812">
The derivation can be assumed to build a composi-
tional interpretation, (enjoy&apos; musicals&apos;) mary&apos;, say.
Coordination can be included in CG via the follow-
ing rule, allowing constituents of like type to conjoin
to yield a single constituent of the same type:
</bodyText>
<listItem confidence="0.7864445">
(4) X conj X = X
(5) I love and admire musicals
</listItem>
<sectionHeader confidence="0.422338" genericHeader="introduction">
NP (S\NP)/NP conj (S\NP)/NP NP
</sectionHeader>
<bodyText confidence="0.943895285714286">
(s\tiP)/1113
The rest of the derivation is exactly as in (3).
In order to allow coordination of contiguous strings
that do not constitute constituents, CCG allows certain
operations on functions related to Curry&apos;s combina-
tors [1]. Functions may compose, as well as apply,
under rules like the following:
</bodyText>
<listItem confidence="0.70482">
(6) Forward Composition:
</listItem>
<sectionHeader confidence="0.647409" genericHeader="method">
XIY YIZ B XIZ (&gt;B)
</sectionHeader>
<bodyText confidence="0.998498222222222">
The rule corresponds to Curry&apos;s combinator B, as
the subscripted arrow indicates. It allows sentences
like Mary admires, and may enjoy, musicals to be ac-
cepted, via the functional composition of two verbs
(indexed as &gt;13), to yield a composite of the same
category as a transitive verb. Crucially, composition
also yields the appropriate interpretation for the com-
posite verb may prefer in this sentence (the rest of the
derivation is as in (3)):
</bodyText>
<page confidence="0.994989">
71
</page>
<figure confidence="0.957677833333333">
(7) admires and may enjoy
(S\NP)/NP conj (S\NP)/VP VP/NP
&gt;B
(S\NP)/NP
a
(S\NP)/NP
</figure>
<bodyText confidence="0.9973267">
CCG also allows type-raising rules, related to the
combinator T, which turn arguments into functions
over functions-over-such-arguments. These rules al-
low arguments to compose, and thereby take part in
coordinations like I dislike, and Mary enjoys, musi-
cals. They too have an invariant compositional se-
mantics which ensures that the result has an appro-
priate interpretation. For example, the following rule
allows such conjuncts to form as below (again, the
remainder of the derivation is omitted):
</bodyText>
<figure confidence="0.971211111111111">
(8) Subject Type-raising:
NP : T SI(S\N P) (&gt;T)
(9) I dislike and Nary enjoys
NP (N\IP)/NP conj IP (S\NP)/BP
&gt;T
S/(S\IP) S/(S\IP)
&gt;B &gt;13
Slip
a
</figure>
<subsectionHeader confidence="0.901451">
Slip
</subsectionHeader>
<bodyText confidence="0.999906238095238">
This apparatus has been applied to a wide variety of
phenomena of long-range dependency and coordinate
structure (cf. [2], [5], [6]).1 For example, Dowty pro-
posed to account for the notorious &amp;quot;non-constituent&amp;quot;
coordination in (10) by adding two rules that are sim-
ply the backward mirror-image versions of the com-
position and type raising rules already given (they are
indicated in the derivation by &lt;B and &lt;T).2 This is a
welcome result: not only do we capture a construction
that has been resistant to other formalisms. We also
satisfy a prediction of the theory, for the two back-
ward rules are clearly expected once we have chosen
to introduce their mirror image originals. The ear-
lier papers show that, provided type raising is limited
to the two &amp;quot;order preserving&amp;quot; varieties exemplified in
these examples, the above reduction is the only one
permitted by the lexicon of English. A number of
related cross-linguistic regularities in the dependency
of gapping upon basic word order follow ([2], [6]).
The construction also strongly suggests that all NPs
(etc.) should be considered as type raised, preferably
</bodyText>
<footnote confidence="0.774339">
1 One further class of rules, corresponding to the combinator
S. has been proposed. This combinator is not discussed here, but
all the present results transfer to those rules as well.
2This and other long examples have been &amp;quot;floated&amp;quot; to later po-
sitions in the text.
</footnote>
<bodyText confidence="0.9998565">
in the lexicon, and that categories like NP should not
reduce at all. However, this last proposal seems to
implies a puzzling extra ambiguity in the lexicon, and
for the moment we will continue to view type-raising
as a syntactic rule.
The universal claim depends upon type-raising be-
ing limited to the following schemata, which do not
of themselves induce new constituent orders:
</bodyText>
<equation confidence="0.9955925">
(11) X T/(T\X)
X T T\(T/X)
</equation>
<bodyText confidence="0.9920302">
If the following patterns (which allow constituent or-
ders that are not otherwise permitted) were allowed,
the regularity would be unexplained, and without fur-
ther restrictions, grammars would collapse into free
order:
</bodyText>
<equation confidence="0.8995525">
(12) X T/(T/X)
X T\(T\X)
</equation>
<bodyText confidence="0.999947">
But what are the principles that limit combinatory
rules of grammar, to include (11) and exclude (12)?
The earlier papers claim that all CCG rules must
conform to three principles. The first is called the
Principle of Adjacency [5, p.405], and says that rules
may only apply to string-adjacent non-empty cate-
gories. It amounts to the assumption that combina-
tors will do the job. The second is called the Prin-
ciple of Directional Consistency. Informally stated, it
says that rules may not override the directionality on
the &amp;quot;cancelling&amp;quot; Y category in the combination. For
example, the following rule is excluded:
</bodyText>
<listItem confidence="0.444706">
(13) * X \Y Y .-=&gt; X
</listItem>
<bodyText confidence="0.999820666666667">
The third is the Principle of Directional Inheritance,
which says that the directionality of any argument in
the result of a combinatory rule must be the same as
the directionality on the corresponding argument(s) in
the original functions. For example, the following
composition rule is excluded:
</bodyText>
<listItem confidence="0.582377">
(14) * XIY Y =&gt; X\Z
</listItem>
<bodyText confidence="0.832605">
However, rules lace the following are permitted:
</bodyText>
<listItem confidence="0.679363">
(15) Y/Z X \Y =&gt; X I Z (&lt; Bx)
</listItem>
<bodyText confidence="0.837916">
This rule (which is not a theorem in the Lambek cal-
culus) is used in [5] to account for examples like
I shall buy today and read tomorrow, the collected
works of Proust, the crucial combination being the
following:
(16) ... read tomorrow ...
VP/NP VP\VP
</bodyText>
<subsectionHeader confidence="0.610128">
&lt;Bx
</subsectionHeader>
<bodyText confidence="0.657279666666667">
VP/NP
The principles of consistency and inheritance amount
SOP
</bodyText>
<page confidence="0.986414">
72
</page>
<bodyText confidence="0.999627545454545">
to the simple statement that combinatory rules may
not contradict the directionality specified in the lexi-
con. But how is this observation to be formalised,
and how does it bear on the type-raising rules? The
next section answers these questions by proposing an
interpretation, grounded in string positions, for the
symbols / and \ in CCG. The notation will temporar-
ily become rather heavy going, so it should be clearly
understood that this is not a proposal for a new CCG
notation. It is a semantics for the metagrammar of
the old CCG notation.
</bodyText>
<sectionHeader confidence="0.989207" genericHeader="method">
DIRECTIONALITY IN CCG
</sectionHeader>
<bodyText confidence="0.999820685393259">
The fact that directionality of arguments is inher-
ited under combinatory rules, under the third of the
principles, strongly suggests that it is a property of
arguments themselves, just like their categorial type,
NP or whatever, as in the work of Zeevat et al.
[8][91. However, the feature in question will here
be grounded in a different representation, with signif-
icantly different consequences, as follows. The basic
form of a combinatory rule under the principle of ad-
jacency is a fi 7. However, this notation leaves
the linear order of a and implicit. We therefore
temporarily expand the notation, replacing categories
like NP by 4-tuples, of the form {a, DPa, La, Ra},
comprising: a) a type such as NP; b) a Distinguished
Position, which we will come to in a minute; c) a Left-
end position; and d) a Right-end position. The Prin-
ciple of Adjacency finds expression in the fact that
all legal combinatory rules must have the the form in
(17), in which the right-end of a is the same as the
left-end of #: We will call the position P2, to which
the two categories are adjacent, the juncture.
The Distinguished Position of a category is simply
the one of its two ends that coincides with the junc-
ture when it is the &amp;quot;cancelling&amp;quot; term Y. A rightward
combining function, such as the transitive verb enjoy,
specifies the distinguished position of its argument
(here underlined for salience) as being that argument&apos;s
left-end. So this category is written in full as in (18)a,
using a non-directional slash I. The notation in (a) is
rather overwhelming. When positional features are of
no immediate relevance in such categories, they will
be suppressed. For example, when we are thinking of
such a function as a function, rather than as an argu-
ment, we will write it as in (18)b, where VP stands
for {VP,DPvp, Lvp, Rvp}, and the distinguished
position of the verb is omitted. It is important to note
that while the binding of the NP argument&apos;s Distin-
guished Position to its left hand end L,,p means that
enjoy is a rightward function, the distinguished posi-
tion is not bound to the right hand end of the verb,
Ryer+. It follows that the verb can potentially com-
bine with an argument elsewhere, just so long as it is
to the right. This property was crucial to the earlier
analysis of heavy NP shift. Coupled with the parallel
independence in the position of the result from the
position of the verb, it is the point at which CCG
parts company with the directional Lambek calculus,
as we shall see below.
In the expanded notation the rule of forward ap-
plication is written as in (19). The fact that the dis-
tinguished position must be one of the two ends of
an argument category, coupled with the requirement
of the principle of Adjacency, means that only the
two order-preserving instances of functional applica-
tion shown in (2) can exist, and only consistent cate-
gories can unify with those rules.
A combination under this rule proceeds as follows.
Consider example (20), the VP enjoy musicals. The
derivation continues as follows. First the positional
variables of the categories are bound by the positions
in which the words occur in the string, as in (21),
which in the first place we will represent explicitly,
as numbered string positions.3 Next the combinatory
rule (19) applies, to unify the argument term of the
function with the real argument, binding the remain-
ing positional variables including the distinguished
position, as in (22) and (23). At the point when the
combinatory rule applies, the constraint implicit in the
distinguished position must actually hold. That is, the
distinguished position must be adjacent to the functor.
Thus the Consistency property of combinatory rules
follows from the principle of Adjacency, embodied in
the fact that all such rules identify the distinguished
position of the argument terms with the juncture P2,
the point to which the two combinands are adjacent,
as in the application example (19).
The principle of Inheritance also follows directly
from these assumptions. The fact that rules corre-
spond to combinators like composition forces direc-
tionality to be inherited, like any other property of an
argument such as being an NP. It follows that only
instances of the two very general rules of compo-
sition shown in (24) are allowed, as a consequence
of the three Principles. To conform to the principle
of consistency, it is necessary that Ly and Ry , the
ends of the cancelling category Y, be distinct posi-
tions — that is, that Y not be coerced to the empty
string. This condition is implicit in the Principle of
Adjacency (see above), although in the notation of
</bodyText>
<footnote confidence="0.59751025">
3 Declaritivising position like this may seem laborious, but it is
a tactic familiar from the DCG literature, from which we shall later
borrow the elegant device of encoding such positions implicitly in
difference-lists.
</footnote>
<page confidence="0.991457">
73
</page>
<figure confidence="0.96523396969697">
(10) give a policeman a flower and a dog a bone
(VP/NP)/NP NP NP conj NP NP
&lt;T &lt;T &lt;T &lt;T
(VP/NP) \ ( (VP/NP) /11P) VP\(VP/NP) (VP/NP)\((VP/NP)/NP) VP\(VP/NP)
&lt;B &lt;13
VP\(VP/NP) VP\(VP/NP)
&lt;k&gt;
VP\(VP/NP)
&lt;
VP
(17) {a, DPa, Pi, P2} {13, DPp, P2, Psi {7i D P-y , Pi , P3}
(18) a. enjoy := {{VP, DPv p, Lv p, RvP}I{N P,Liat, Lnp)Rnp}) D-Pverb) —kerb) Ruerb}
b. enjoy := {V PI IN P, Le.: , Lap, Rnp}, Lverin Rverb}
(19) {{X, DP, Pl, P3) I {Y, P2, P2, P3), P1, P2} {Y, P2, P2, P3} {X, DP, P1, P3}
(20) 1 enjoy 2 musicals 3
IVP/{NP, Lars, Lars, Rars} , L fun, Alan) {NP, DPnp, La,, Rnp}
(21) 1 enjoy 2 musicals 3
{VP/{NP, Lary, Lars, Rars},1,2) {N P,DPnp,2, 3)
(22) 1 enjoy 2 musicals 3
{V P I {N P, Lars, Lars, Raps} ,1,2} {NP,DPn, 2, 3}
{X I {Y, P2, P2, P3) , P1, P2) {Y, P2, P2, P3)
(23) 1 enjoy 2 musicals 3
{V P/{N P,2,2,3),1,2) {NP, 2, 2, 3}
{V P,1, 3}
(24) a. {{X, DP, L, RORY, P2, P2, Ry}, P1, P2} {{Y, P2, P2, ROI {Z , DPI, L,, Rz}, P2, P3}
{{X, DP, Lx, R,}/{Z, DP, , L,, R,}, P1, P3}
b. {{Y, P2, 4, P2} I {Z , DPI, L,, R,}, P1, P2) {{X, DP, Lx, Rs} I {Y, P2, Ly, P2), P2, P3)
{{X , D Ps , Lc, 14}1{Z , D P, , Lz, R,}, Pl, P3)
(25) The Possible Composition Rules:
a. X/Y YIZ B XIZ (&gt;B)
b. X IY Y\Z =B X\Z (&gt; Bx)
c. Y\Z X \Y B X\Z (&lt;B)
d. Y I Z X\Y *13 X/Z (&lt; Bx)
</figure>
<page confidence="0.996781">
74
</page>
<bodyText confidence="0.999975376623377">
the appendix it has to be explicitly imposed. These
schemata permit only the four instances of the rules
of composition proposed in [5] [6], given in (25) in
the basic CCG notation. &amp;quot;Crossed&amp;quot; rules like (15)
are still allowed (because of the non-identity noted in
the discussion of (18) between the distinguished posi-
tion of arguments of functions and the position of the
function itself). They are distinguished from the cor-
responding non-crossing rules by further specifying
DPI, the distinguished position on Z. However, no
rule violating the Principle of Inheritance, like (14), is
allowed: such a rule would require a different distin-
guished position on the two Zs, and would therefore
not be functional composition at all. This is a desir-
able result: the example (16) and the earlier papers
show that the non-order-preserving instances (b, d)
are required for the grammar of English and Dutch.
In configurational languages like English they must
of course be carefully restricted as to the categories
that may unify with Y.
The implications of the present formalism for the
type-raising rules are less obvious. Type raising rules
are unary, and probably lexical, so the principle of
adjacency does not apply. However, we noted earlier
that we only want the order-preserving instances (11),
in which the directionality of the raised category is
the reverse of that of its argument. But how can this
reversal be anything but an arbitrary property?
Because the directionality constraints are grounded
out in string positions, the distinguished position of
the subject argument of a predicate walks — that is,
the right-hand edge of that subject — is equivalent to
the distinguished position of the predicate that consti-
tutes the argument of an order-preserving raised sub-
ject Gilbert that is, the left-hand edge of that pred-
icate. It follows that both of the order-preserving
rules are instances of the single rule (26) in the ex-
tended notation: The crucial property of this rule,
which forces its instances to be order-preserving, is
that the distinguished position variable DP„g on the
argument of the predicate in the raised category is the
same as that on the argument of the raised category
itself. (The two distinguished positions are underlined
in (26)). Of course, the position is unspecified at the
time of applying the rule, and is simply represented
as an unbound unification variable with an arbitrary
mnemonic identifier. However, when the category
combines with a predicate, this variable will be bound
by the directionality specified in the predicate itself.
Since this condition will be transmitted to the raised
category, it will have to coincide with the juncture of
the combination. Combination of the categories in
the non-grammatical order will therefore fail, just as
if the original categories were combining without the
mediation of type-raising.
Consider the following example. Under the above
rule, the categories of the words in the sentence
Gilbert walks are as shown in (27), before binding.
Binding of string positional variables yields the cat-
egories in (28). The combinatory rule of forward
application (19) applies as in example (29), binding
further variables by unification. In particular, DPg,
Rng, DP, and P2, are all bound to the juncture po-
sition 2, as in (30). By contrast, the same categories
in the opposite linear order fail to unify with any
combinatory rule. In particular, the backward appli-
cation rule fails, as in (31). (Combination is blocked
because 2 cannot unify with 3).
On the assumption implicit in (26), the only permit-
ted instances of type raising are the two rules given
earlier as (11). The earlier results concerning word-
order universals under coordination are therefore cap-
tured. Moreover, we can now think of these two rules
as a single underspecified order-preserving rule di-
rectly corresponding to (26), which we might write
less long-windedly as follows, augmenting the origi-
nal simplest notation with a non-directional slash:
</bodyText>
<subsubsectionHeader confidence="0.371632">
(33) The Order-preserving Type-raising Rule:
</subsubsectionHeader>
<equation confidence="0.979112">
X = TKTIX) (T)
</equation>
<bodyText confidence="0.999945230769231">
The category that results from this rule can combine in
either direction, but will always preserve order. Such
a property is extremely desirable in a language like
English, whose verb requires some arguments to the
right, and some to the left, but whose NPs do not bear
case. The general raised category can combine in both
directions, but will still preserve word order. It thus
eliminates what was earlier noted as a worrying extra
degree of categorial ambiguity. The way is now clear
to incorporate type raising directly into the lexicon,
substituting categories of the form TI (TI X), where X
is a category like NP or PP, directly into the lexicon
in place of the basic categories, or (more readably, but
less efficiently), to keep the basic categories and the
rule (33), and exclude the base categories from all
combination.
The related proposal of Zeevat et al. [8],[9] also
has the property of allowing a single lexical raised
category for the English NP. However, because of
the way in which the directional constraints are here
grounded in relative string position, rather than being
primitive to the system, the present proposal avoids
certain difficulties in the earlier treatment. Zeevat&apos;s
type-raised categories are actually order-changing,
and require the lexical category for the English pred-
icate to be S/NP instead of S\NP. (Cf. [9, pp.
</bodyText>
<page confidence="0.992175">
75
</page>
<figure confidence="0.922512625">
(26) {X, DPary, L„g Rarg} {TRT/{X, DP„g, Larg, R„g}, DParg, Lpred, RFred, —argR
arg ,
(27) 1 Gilbert 2 walks 3
{SI {SI {N P, DPg, Lg, Rs}, DPg, Lpred) --TR—red}, Lg,Rg} {N P,Rnp, Lnp, Rnp}, DPw, Lw, Rw}
(28) 1 Gilbert 2 walks 3
{SI {SI {N DPg,1, DPg, Lpred, ed}1,21 {SI{NP, Rnp Lnp, Rnp}, DP, 2,3)
(29) 1 Gilbert 2 walks 3
{SI {SI {N DPg, 1,2), DPg, Lpred, --FR—red} , 1,21 {S/{NP, Rrip, Lnp, Rnp},DPw, 2,3}
{X I {Y, P2, P2, P3}, P1, P2} {Y, P2, P2, P3}
(30) 1 Gilbert 2 walks 3
{57 {SI {N P, 2,2,3), 1,2} {SANP, 2,1,2), 2,2,3}
{S, 1,31
(31) 1 *Walks 2 Gilbert 3
{SI IN P, Rap, Lnp, RnP}, 1,2) IS I IS {N P, DPg 2,3}, DPg Lpred, Rpred}, 2,3)
{Y, P2, Pl, P21 {X/{Y, P2, P1, P2}, P2, P3}
(32) *{X DParg,Larg, Rarg} {T / / {X, DParg., Larg, Rarg} , DPprect, Lpred, ,red} , Larg, Rarg}
</figure>
<page confidence="0.961669">
76
</page>
<bodyText confidence="0.999982255319149">
207-210]). They are thereby prevented from captur-
ing a number of generalisations of CCGs, and in fact
exclude functional composition entirely.
It is important to be clear that, while the order
preserving constraint is very simply imposed, it is
nevertheless an additional stipulation, imposed by the
form of the type raising rule (26). We could have
used a unique variable, DPp„d say, in the crucial
position in (26), unrelated to the positional condi-
tion DP„9 on the argument of the predicate itself,
to define the distinguished position of the predicate
argument of the raised category, as in example (32).
However, this tactic would yield a completely uncon-
strained type raising rule, whose result category could
not merely be substituted throughout the lexicon for
ground categories like NP without grammatical col-
lapse. (Such categories immediately induce totally
free word-order, for example permitting (31) on the
English lexicon). It seems likely that type raising is
universally confined to the order-preserving kind, and
that the sources of so-called free word order lie else-
where. Such a constraint can therefore be understood
in terms of the present proposal simply as a require-
ment for the lexicon itself to be consistent. It should
also be observed that a uniformly order-changing cat-
egory of the 1Cmd proposed by Zeevat et al. is not
possible under this theory.
The above argument translates directly into
unification-based frameworks such as PATR or Pro-
log. A small Prolog program, shown in an appendix,
can be used to exemplify and check the argument.4
The program makes no claim to practicality or ef-
ficiency as a CCG parser, a question on which the
reader is refered to [7]. Purely for explanatory sim-
plicity, it uses type raising as a syntactic rule, rather
than as an offline lexical rule. While a few English
lexical categories and an English sentence are given
by way of illustration, the very general combinatory
rules that are included will of course require further
constraints if they are not to overgenerate with larger
fragments. (For example, &gt;12. and &gt;Bx must be dis-
tinguished as outlined above, and the latter must be
greatly constrained for English.) One very general
constraint, excluding all combinations with or into
NP, is included in the program, in order to force
type-raising and exemplify the way in which further
constrained rule-instances may be specified.
</bodyText>
<sectionHeader confidence="0.993633" genericHeader="conclusions">
CONCLUSION
</sectionHeader>
<bodyText confidence="0.907826">
We can now safely revert to the original CCG nota-
</bodyText>
<footnote confidence="0.634005333333333">
4The program is based on a simple shift-reduce
parser/recogniser, using &amp;quot;difference list&amp;quot;-encoding of string posi-
tion (cf. [4], [3]).
</footnote>
<bodyText confidence="0.9999665">
tion described in the preliminaries to the paper, mod-
ified only by the introduction of the general order-
preserving type raising rule (26), having established
the following results. First, the earlier claims con-
cerning word-order universals follow from first prin-
ciples in a unification-based CCG in which direction-
ality is an attribute of arguments, grounded out in
string position. The Principles of Consistency and In-
heritance follow as theorems, rather than stipulations.
A single general-purpose order-preserving type-raised
category can be assigned to arguments, simplifying
the grammar and the parser.
</bodyText>
<sectionHeader confidence="0.998449" genericHeader="references">
REFERENCES
</sectionHeader>
<reference confidence="0.999425558823529">
[1] Curry, Haskell and Robert Feys: 1958, Combi-
natory Logic, North Holland, Amsterdam.
[2] Dowty, David: 1988, Type raising, functional
composition, and non-constituent coordination, in
Richard T. Oehrle, E. Bach and D. Wheeler,
(eds), Categorial Grammars and Natural Lan-
guage Structures, Reidel, Dordrecht, 153-198.
[3] Gerdeman, Dale and Hinrichs, Erhard: 1990.
Functor-driven Natural Language Generation with
Categorial Unification Grammars. Proceedings of
COLING 90, Helsinki, 145-150.
[4] Pereira, Fernando, and Stuart Shieber: 1987, Pro-
log and Natural Language Analysis, CSLI/Univ.
of Chicago Press.
[5] Steedman, Mark: 1987. Combinatory grammars
and parasitic gaps. Natural Language &amp; Linguis-
tic Theory, 5, 403-439.
[6] Steedman, Mark: 1990, Gapping as Constitu-
tent Coordination, Linguistics and Philosophy, 13,
207-263.
[7] Vijay-Shankar, K and David Weir: 1990, &apos;Poly-
nomial Time Parsing of Combinatory Categorial
Grammars&apos;, Proceedings of the 28th Annual Con-
ference of the ACL, Pittsburgh, June 1990.
[8] Zeevat, Henk, Ewan Klein, and Jo Calder: 1987,
&apos;An Introduction to Unification Categorial Gram-
mar&apos;, in N. Haddock et al. (eds.), Edinburgh
Working Papers in Cognitive Science, 1: Catego-
rial Grammar, Unification Grammar, and Pars-
ing.
[9] Zeevat, Henk: 1988, &apos;Combining Categorial
Grammar and Unification&apos;, in U. Reyle and C.
Rohrer (eds.), Natural Language Parsing and Lin-
guistic Theories, Dordrecht, Reidel, 202-229.
</reference>
<page confidence="0.999467">
77
</page>
<sectionHeader confidence="0.989792" genericHeader="references">
APPENDIX
</sectionHeader>
<reference confidence="0.967802951219512">
%% A Lexical Fragment: parse will bind position (via list-encoding):
category(gilbert, cat(np, Pi, P2)).
category(brigitte, cat(np, Pi, P2)).
category(walks,cat(cat(s,_,_,_)/cat(np,P2,_,P2),_,P3,P4)).
category(love, cat(cat(vp,_,_,_)/cat(np,P3,P3,_),_,P1,P2)).
category(must,cat(cat(cat(s,-,-,_)/cat(np,P2,_,P2),_._,_)/cat(vp,P6,P5,_),_,P3,P4)).
category(madly, cat(cat(vP,-,-,_)/cat(vp,P2,_,P2),_,P3,P4)).
%% Application and (overgeneral) Composition: Partial evaluation of DPy with the actual Juncture P2
%% imposes Adjacency. DPy (=P2) must not be == Y&apos;s other end (see &lt;B and &gt;B). Antecedent \+ Y=np
X% disallows ALL combination with unraised NPs.
reduce(cat(cat(X,DPx,P1,P3)/cat(Y,P2,P2,P3),_,P1,P2),
cat(Y, P2, P2,P3),
cat(X,DPx,P1,P3)) \+ Y=np. %&gt;
reduce(cat(Y,P2,P1,P2),
cat(cat(X,DPx,P1,P3)/cat(r,P2,P1,P2),_,P2,P3),
cat(X,DPx,P1,P3)) \+ Y=np.
reduce(cat(cat(X,DPx,X1,12)/cat(Y,P2,P2,Y2),_,P1,P2),
cat(cat(Y,P2,P2,Y2)/cat(Z,DPz,Z1,Z2),_,P2,P3),
cat(cat(I,DPx,X1,12)/cat(Z,DPz,Z1,Z2),_,P1,P3)) \+ Y=np,\+ Y2==P2. %&gt;B, cf. ex. 24a
reduce(cat(cat(Y,P2,Y1,P2)/cat(Z,DPz,Z1,Z2),_,P1,P2),
cat(cat(I,DPx,X1,X2)/cat(Y,P2,Y1,P2),_,P2,P3).
cat(cat(I,DPx,X1,12)/cat(Z,DPz,Z1,Z2),_,P1,P3)) \+ Y=np,\+ Y1==P2. %&lt;B, cf. ex. 24b
X% Order Preserving Type Raising: the rule np -&gt; TI(TInp).
raise(cat(np,DPnp,P1,P2), % Binds Pi, P2
cat(cat(T,DPt,T1,T2)/cat(cat(T,DPt,T1,T2)/cat(np,DPnp,P1,P2),DPnp,_,_), % cf. ex. 26
-,P1,P2)).
%% Parse simulates reduce-first shift-reduce recogniser with backtracking (inefficiently)
parse([Result], 0, Result). % Halt
parse([Cati1Stack], Buffer, Result) :- % Raise (syntactic)
raise(Cat1, Cat2),
parse((Cat2IStack], Buffer, Result).
parse([Cat2, CatiIStack], Buffer, Result) :- % Reduce
reduce(Catl, Cat2, Cat3),
parse((Cat3IStack], Buffer, Result).
parse(Stack, NordIBuffer], Result) :- % Shift
category(Vord, cat(V,DPw,NordIBuffer],Buffer)), % Position is list-encoded
parseacat(V,DPedVordIBufferl,Buffer)IStack], Buffer, Result).
%% Example crucially involving bidirectional T (twice) and &lt;Bx:
% I ?- parse(0,[gilbert,must,love,madly,brigitte],R).
% R = cat(s,_37,Egilbert,must,love,madly,brigittel,0) % ; -- plus 4 more equivalent derivations
% yes
</reference>
<page confidence="0.998402">
78
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.000086">
<title confidence="0.99862">TYPE-RAISING AND DIRECTIONALITY IN COMBINATORY GRAMMAR*</title>
<author confidence="0.999998">Mark Steedman</author>
<affiliation confidence="0.992446">Computer and Information Science, University of Pennsylvania</affiliation>
<address confidence="0.9958285">200 South 33n1 Street Philadelphia PA 19104-6389, USA</address>
<abstract confidence="0.972218996551725">st eedma n@cis . . edu) ABSTRACT The form of rules in combinatory categorial grammars (CCG) is constrained by three principles, called &amp;quot;adjacency&amp;quot;, &amp;quot;consistency&amp;quot; and &amp;quot;inheritance&amp;quot;. These principles have been claimed elsewhere to constrain the combinatory rules of composition and type raising in such a way as to make certain linguistic universals concerning word order under coordination follow immediately. The present paper shows that the three principles have a natural expression in a unification-based interpretation of CCG in which directional information is an attribute of the arguments of functions grounded in string position. The universals can thereby be derived as consequences of elementary assumptions. Some desirable results for grammars and parsers follow, concerning type-raising rules. PRELIMINARIES In Categorial Grammar (CG), elements like verbs are associated with a syntactic &amp;quot;category&amp;quot;, which identifies their functional type. I shall use a notation in which the argument or domain category always appears to the right of the slash, and the result or range category to the left. A forward slash / means that the argument in question must appear on the right, while a backward slash \ means it must appear on the left. enjoys := category be regarded as both a syntactic and a semantic object, in which symbols abbreviations for graphs or terms including interpretations, as in the unification-based categorial grammars of Zeevat et al. [8] and others (and cf. [6]). Such functions can combine with arguments of the appropriate type and position by rules of functional application, written as follows: Functional Application Rules: a. X1Y Y =X(&gt;) b. Y X\Y = X (&lt;) Such rules are also both syntactic and semantic rules *Thanks to Michael Niv and Sui Shieber. Support from: NSF Grant CISE HP CDA 88-22719, DARPA grant no. N0014-90-J- 1863, and ARO grant no. DAAL03-89-00031. combination in which Y are abbreviations for more complex objects which combine via unification. They allow context-free derivations like the following (the application of rules is indicated by indices &gt;, &lt; on the underlines: musicals NP (S\NP)/NP NP S \ NP The derivation can be assumed to build a composiinterpretation, musicals&apos;) mary&apos;, Coordination can be included in CG via the following rule, allowing constituents of like type to conjoin to yield a single constituent of the same type: (4) X conj X = X I and admire musicals The rest of the derivation is exactly as in (3). In order to allow coordination of contiguous strings that do not constitute constituents, CCG allows certain operations on functions related to Curry&apos;s combina- [1]. Functions may well as apply, under rules like the following: (6) Forward Composition: YIZ BXIZ rule corresponds to Curry&apos;s combinator the subscripted arrow indicates. It allows sentences admires, and may enjoy, musicals be accepted, via the functional composition of two verbs (indexed as &gt;13), to yield a composite of the same category as a transitive verb. Crucially, composition also yields the appropriate interpretation for the comverb may this sentence (the rest of the derivation is as in (3)): 71 and may enjoy conj VP/NP &gt;B a (S\NP)/NP CCG also allows type-raising rules, related to the turn arguments into functions over functions-over-such-arguments. These rules allow arguments to compose, and thereby take part in like dislike, and Mary enjoys, musitoo have an invariant compositional semantics which ensures that the result has an appropriate interpretation. For example, the following rule allows such conjuncts to form as below (again, the remainder of the derivation is omitted): (8) Subject Type-raising: NP : T SI(S\N P) (&gt;T) (9) I dislike and Nary enjoys (N\IP)/NP IP (S\NP)/BP &gt;T Slip a Slip This apparatus has been applied to a wide variety of phenomena of long-range dependency and coordinate (cf. [2], [5], For example, Dowty proposed to account for the notorious &amp;quot;non-constituent&amp;quot; coordination in (10) by adding two rules that are simply the backward mirror-image versions of the composition and type raising rules already given (they are in the derivation by This is a welcome result: not only do we capture a construction that has been resistant to other formalisms. We also satisfy a prediction of the theory, for the two backward rules are clearly expected once we have chosen to introduce their mirror image originals. The earpapers show that, type raising is limited to the two &amp;quot;order preserving&amp;quot; varieties exemplified in examples, above reduction is the only one permitted by the lexicon of English. A number of related cross-linguistic regularities in the dependency of gapping upon basic word order follow ([2], [6]). construction also strongly suggests that NPs (etc.) should be considered as type raised, preferably 1One further class of rules, corresponding to the combinator S. has been proposed. This combinator is not discussed here, but all the present results transfer to those rules as well. and other long examples have been &amp;quot;floated&amp;quot; to later positions in the text. the lexicon, and that categories like not reduce at all. However, this last proposal seems to implies a puzzling extra ambiguity in the lexicon, and for the moment we will continue to view type-raising as a syntactic rule. The universal claim depends upon type-raising being limited to the following schemata, which do not of themselves induce new constituent orders: X T/(T\X) TT\(T/X) the following (which allow constituent orare not permitted) were allowed, regularity would unexplained, and without furwould collapse into free order: X T/(T/X) But what are the principles that limit combinatory rules of grammar, to include (11) and exclude (12)? The earlier papers claim that all CCG rules must conform to three principles. The first is called the of Adjacency p.405], and says that rules only apply to non-empty cateamounts to the assumption that combinawill do the job. The second is called the Prinof Directional Consistency. stated, it that may not override the directionality on &amp;quot;cancelling&amp;quot; Y category in the combination. example, the following rule is excluded: * Y .-=&gt; third is the of Directional Inheritance, says that directionality of any argument in the result of a combinatory rule must be the same as the directionality on the corresponding argument(s) in original functions. example, the following composition rule is excluded: * Y =&gt; X\Z rules lace the following Y/Z \Y =&gt; X I Z Bx) This rule (which is not a theorem in the Lambek calculus) is used in [5] to account for examples like I shall buy today and read tomorrow, the collected of Proust, crucial combination being the following: ... tomorrow ... VP/NP VP\VP &lt;Bx VP/NP of consistency and inheritance amount SOP 72 the simple statement that rules may not contradict the directionality specified in the lexihow is this observation to be formalised, and how does it bear on the type-raising rules? The next section answers these questions by proposing an interpretation, grounded in string positions, for the symbols / and \ in CCG. The notation will temporarily become rather heavy going, so it should be clearly that is not a proposal for a new CCG It is a for the metagrammar of notation. DIRECTIONALITY IN CCG The fact that directionality of arguments is inherited under combinatory rules, under the third of the principles, strongly suggests that it is a property of arguments themselves, just like their categorial type, whatever, as in the work of Zeevat et al. [8][91. However, the feature in question will here be grounded in a different representation, with significantly different consequences, as follows. The basic of a combinatory rule under the principle of adis fi 7. this notation leaves linear order of a and We temporarily expand the notation, replacing categories 4-tuples, of the form a) a as b) a Distinguished we will come to in a minute; c) a Leftand d) a The Principle of Adjacency finds expression in the fact that all legal combinatory rules must have the the form in in which the right-end of the same as the of will call the position which two categories are adjacent, the The Distinguished Position of a category is simply the one of its two ends that coincides with the juncwhen it is the &amp;quot;cancelling&amp;quot; term rightward function, such as the transitive verb specifies the distinguished position of its argument (here underlined for salience) as being that argument&apos;s this category is written in full as in (18)a, using a non-directional slash I. The notation in (a) is rather overwhelming. When positional features are of no immediate relevance in such categories, they will be suppressed. For example, when we are thinking of a function function, rather than as an arguwe will write it as in (18)b, where Rvp}, the distinguished position of the verb is omitted. It is important to note that while the binding of the NP argument&apos;s Distin- Position to its left hand end means that is rightward function, the distinguished posiis to the right hand end of the verb, follows that the verb can potentially combine with an argument elsewhere, just so long as it is to the right. This property was crucial to the earlier analysis of heavy NP shift. Coupled with the parallel independence in the position of the result from the position of the verb, it is the point at which CCG parts company with the directional Lambek calculus, as we shall see below. the expanded the rule of forward application is written as in (19). The fact that the distinguished position must be one of the two ends of an argument category, coupled with the requirement the principle of Adjacency, means that two order-preserving instances of functional application shown in (2) can exist, and only consistent categories can unify with those rules. A combination under this rule proceeds as follows. example (20), the VP musicals. derivation continues as follows. First the positional variables of the categories are bound by the positions in which the words occur in the string, as in (21), which in the first place we will represent explicitly, numbered string Next the combinatory rule (19) applies, to unify the argument term of the function with the real argument, binding the remaining positional variables including the distinguished position, as in (22) and (23). At the point when the combinatory rule applies, the constraint implicit in the distinguished position must actually hold. That is, the distinguished position must be adjacent to the functor. Thus the Consistency property of combinatory rules follows from the principle of Adjacency, embodied in the fact that all such rules identify the distinguished position of the argument terms with the juncture P2, the point to which the two combinands are adjacent, as in the application example (19). The principle of Inheritance also follows directly these assumptions. The fact that correspond to combinators like composition forces directionality to be inherited, like any other property of an argument such as being an NP. It follows that only instances of the two very general rules of composition shown in (24) are allowed, as a consequence of the three Principles. To conform to the principle consistency, it is necessary that and , the of the cancelling category distinct posi- — that is, that be coerced to the empty string. This condition is implicit in the Principle of although in the notation of 3Declaritivising position like this may seem laborious, but it is a tactic familiar from the DCG literature, from which we shall later borrow the elegant device of encoding such positions implicitly in difference-lists. 73 (10) give a policeman a flower and a dog a bone (VP/NP)/NP NP NP conj NP NP &lt;T &lt;T &lt;T &lt;T (VP/NP) \ ( (VP/NP) /11P) VP\(VP/NP) (VP/NP)\((VP/NP)/NP) VP\(VP/NP) &lt;B &lt;13 VP\(VP/NP) VP\(VP/NP) &lt;k&gt; &lt; VP {a, P2} {13, Psi {7i P-y , Pi , P3} a. := DPv p, Lv p, RvP}I{N P,Liat, —kerb) Ruerb</abstract>
<note confidence="0.9867604375">{V PI IN P, , Rnp}, Rverb} DP, I {Y, P2, P2, P3), P1, {Y, P2, P2, P3} {X, P1, (20) 1 enjoy 2 musicals 3 , L {NP, DPnp, Rnp} (21) 1 enjoy 2 musicals 3 {N (22) 1 enjoy 2 musicals 3 P I {N P, ,1,2} 3} I {Y, P2, P2, P3) , P1, P2) P2, P3) (23) 1 enjoy 2 musicals 3 P/{N P,2,2,3),1,2) {NP, 2, 3} a. DP, L, RORY, P2, P1, P2} {{Y, P2, P2, {Z , L,, DP, R,}/{Z, DP, , L,, R,}, P1, P3} {{Y, P2, I {Z , L,, R,}, P1, P2) I {Y, P2, P2), P2, P3) , D Ps , Lc, 14}1{Z , D P, , R,}, Pl, P3) (25) The Possible Composition Rules:</note>
<affiliation confidence="0.2508675">X/Y BXIZ (&gt;B) X IY Y\Z Bx) Y\Z X \Y BX\Z Y I Z X\Y Bx</affiliation>
<address confidence="0.199395">74</address>
<abstract confidence="0.997264247619047">the appendix it has to be explicitly imposed. These schemata permit only the four instances of the rules of composition proposed in [5] [6], given in (25) in the basic CCG notation. &amp;quot;Crossed&amp;quot; rules like (15) are still allowed (because of the non-identity noted in the discussion of (18) between the distinguished position of arguments of functions and the position of the function itself). They are distinguished from the corresponding non-crossing rules by further specifying distinguished position on no rule violating the Principle of Inheritance, like (14), is such a rule would require different distinposition on the two would therefore not be functional composition at all. This is a desirable result: the example (16) and the earlier papers show that the non-order-preserving instances (b, d) are required for the grammar of English and Dutch. In configurational languages like English they must of course be carefully restricted as to the categories may unify with The implications of the present formalism for the type-raising rules are less obvious. Type raising rules are unary, and probably lexical, so the principle of adjacency does not apply. However, we noted earlier we only want the (11), which directionality of the raised category is reverse of that of its argument. how can this reversal be anything but an arbitrary property? Because the directionality constraints are grounded out in string positions, the distinguished position of subject argument of a predicate is, edge that subject — is equivalent to the distinguished position of the predicate that constitutes the argument of an order-preserving raised subthat the of that predicate. It follows that both of the order-preserving rules are instances of the single rule (26) in the extended notation: The crucial property of this rule, which forces its instances to be order-preserving, is distinguished position variable on the argument of the predicate in the raised category is the same as that on the argument of the raised category two distinguished positions are underlined in (26)). Of course, the position is unspecified at the time of applying the rule, and is simply represented as an unbound unification variable with an arbitrary mnemonic identifier. However, when the category combines with a predicate, this variable will be bound by the directionality specified in the predicate itself. Since this condition will be transmitted to the raised will have to coincide with the juncture of combination. of the categories in will therefore fail, just as if the original categories were combining without the mediation of type-raising. Consider the following example. Under the above rule, the categories of the words in the sentence walks are shown in (27), before binding. Binding of string positional variables yields the categories in (28). The combinatory rule of forward application (19) applies as in example (29), binding variables by unification. In particular, DP, P2, are all bound to the juncture position 2, as in (30). By contrast, the same categories in the opposite linear order fail to unify with any combinatory rule. In particular, the backward application rule fails, as in (31). (Combination is blocked because 2 cannot unify with 3). On the assumption implicit in (26), the only permitted instances of type raising are the two rules given earlier as (11). The earlier results concerning wordorder universals under coordination are therefore captured. Moreover, we can now think of these two rules as a single underspecified order-preserving rule directly corresponding to (26), which we might write less long-windedly as follows, augmenting the original simplest notation with a non-directional slash: Rule: = (T) The category that results from this rule can combine in but will always preserve order. Such a property is extremely desirable in a language like English, whose verb requires some arguments to the right, and some to the left, but whose NPs do not bear case. The general raised category can combine in both directions, but will still preserve word order. It thus eliminates what was earlier noted as a worrying extra degree of categorial ambiguity. The way is now clear to incorporate type raising directly into the lexicon, categories of the form TI (TI a category like into the lexicon in place of the basic categories, or (more readably, but less efficiently), to keep the basic categories and the rule (33), and exclude the base categories from all combination. The related proposal of Zeevat et al. [8],[9] also has the property of allowing a single lexical raised for the English because of the way in which the directional constraints are here grounded in relative string position, rather than being primitive to the system, the present proposal avoids certain difficulties in the earlier treatment. Zeevat&apos;s categories are actually require the lexical category for the English predbe of [9, pp.</abstract>
<note confidence="0.804335722222222">75 {X, Lpred, , (27) 1 Gilbert 2 walks 3 {SI {N P, Lpred) {N (28) 1 Gilbert 2 walks 3 {SI {N Lpred, ed}1,21 {SI{NP, Rnp Lnp, Rnp}, DP, 2,3) (29) 1 Gilbert 2 walks 3 {SI {N Lpred, , Rrip, Lnp, I {Y, P2, P2, P3}, P1, {Y, P2, P2, P3} (30) 1 Gilbert 2 walks 3 {SI {N P, 1,2} {SANP, 2,1,2), 2,2,3} {S, 1,31 (31) 1 *Walks 2 Gilbert 3 {SI IN P, Rap, Lnp, RnP}, I IS {N P, 2,3}, Lpred, {Y, P2, Pl, P21 {X/{Y, P2, P1, P2}, P2, P3} {T / / {X, , DPprect,Lpred, , 76</note>
<abstract confidence="0.998826730769231">207-210]). They are thereby prevented from capturing a number of generalisations of CCGs, and in fact exclude functional composition entirely. It is important to be clear that, while the order preserving constraint is very simply imposed, it is nevertheless an additional stipulation, imposed by the form of the type raising rule (26). We could have a unique variable, the crucial position in (26), unrelated to the positional condion the argument of the predicate itself, to define the distinguished position of the predicate argument of the raised category, as in example (32). However, this tactic would yield a completely unconstrained type raising rule, whose result category could not merely be substituted throughout the lexicon for categories like grammatical collapse. (Such categories immediately induce totally free word-order, for example permitting (31) on the English lexicon). It seems likely that type raising is universally confined to the order-preserving kind, and that the sources of so-called free word order lie elsewhere. Such a constraint can therefore be understood in terms of the present proposal simply as a requirement for the lexicon itself to be consistent. It should be observed that a uniformly category of the 1Cmd proposed by Zeevat et al. is not possible under this theory. The above argument translates directly into unification-based frameworks such as PATR or Prolog. A small Prolog program, shown in an appendix, be used to exemplify and check the The program makes no claim to practicality or efficiency as a CCG parser, a question on which the reader is refered to [7]. Purely for explanatory simplicity, it uses type raising as a syntactic rule, rather than as an offline lexical rule. While a few English lexical categories and an English sentence are given by way of illustration, the very general combinatory rules that are included will of course require further constraints if they are not to overgenerate with larger (For example, &gt;12. and be distinguished as outlined above, and the latter must be greatly constrained for English.) One very general constraint, excluding all combinations with or into included in the program, in order to force type-raising and exemplify the way in which further constrained rule-instances may be specified. CONCLUSION can now safely revert to the original CCG notaprogram is based on a simple shift-reduce parser/recogniser, using &amp;quot;difference list&amp;quot;-encoding of string position (cf. [4], [3]).</abstract>
<intro confidence="0.686625">tion described in the preliminaries to the paper, mod-</intro>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Haskell Curry</author>
<author>Robert Feys</author>
</authors>
<date>1958</date>
<location>Combinatory Logic, North Holland, Amsterdam.</location>
<marker>Curry, Feys, 1958</marker>
<rawString>[1] Curry, Haskell and Robert Feys: 1958, Combinatory Logic, North Holland, Amsterdam.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dowty</author>
</authors>
<title>Type raising, functional composition, and non-constituent coordination, in</title>
<date>1988</date>
<pages>153--198</pages>
<location>David:</location>
<marker>Dowty, 1988</marker>
<rawString>[2] Dowty, David: 1988, Type raising, functional composition, and non-constituent coordination, in Richard T. Oehrle, E. Bach and D. Wheeler, (eds), Categorial Grammars and Natural Language Structures, Reidel, Dordrecht, 153-198.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dale Gerdeman</author>
<author>Erhard Hinrichs</author>
</authors>
<title>Functor-driven Natural Language Generation with Categorial Unification Grammars.</title>
<date>1990</date>
<booktitle>Proceedings of COLING 90,</booktitle>
<pages>145--150</pages>
<location>Helsinki,</location>
<marker>Gerdeman, Hinrichs, 1990</marker>
<rawString>[3] Gerdeman, Dale and Hinrichs, Erhard: 1990. Functor-driven Natural Language Generation with Categorial Unification Grammars. Proceedings of COLING 90, Helsinki, 145-150.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fernando Pereira</author>
<author>Stuart Shieber</author>
</authors>
<title>Prolog and Natural Language Analysis, CSLI/Univ. of</title>
<date>1987</date>
<publisher>Chicago Press.</publisher>
<marker>Pereira, Shieber, 1987</marker>
<rawString>[4] Pereira, Fernando, and Stuart Shieber: 1987, Prolog and Natural Language Analysis, CSLI/Univ. of Chicago Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Steedman</author>
</authors>
<title>Combinatory grammars and parasitic gaps.</title>
<date>1987</date>
<journal>Natural Language &amp; Linguistic Theory,</journal>
<volume>5</volume>
<pages>403--439</pages>
<marker>Steedman, 1987</marker>
<rawString>[5] Steedman, Mark: 1987. Combinatory grammars and parasitic gaps. Natural Language &amp; Linguistic Theory, 5, 403-439.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Steedman</author>
</authors>
<title>Gapping as Constitutent Coordination,</title>
<date>1990</date>
<journal>Linguistics and Philosophy,</journal>
<volume>13</volume>
<pages>207--263</pages>
<marker>Steedman, 1990</marker>
<rawString>[6] Steedman, Mark: 1990, Gapping as Constitutent Coordination, Linguistics and Philosophy, 13, 207-263.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shankar</author>
<author>David Weir</author>
</authors>
<title>Polynomial Time Parsing of Combinatory Categorial Grammars&apos;,</title>
<date>1990</date>
<booktitle>Proceedings of the 28th Annual Conference of the ACL,</booktitle>
<location>Pittsburgh,</location>
<marker>Vijay-Shankar, Weir, 1990</marker>
<rawString>[7] Vijay-Shankar, K and David Weir: 1990, &apos;Polynomial Time Parsing of Combinatory Categorial Grammars&apos;, Proceedings of the 28th Annual Conference of the ACL, Pittsburgh, June 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Henk Zeevat</author>
<author>Ewan Klein</author>
<author>Jo Calder</author>
</authors>
<title>An Introduction to Unification Categorial Grammar&apos;,</title>
<date>1987</date>
<booktitle>Edinburgh Working Papers in Cognitive Science, 1: Categorial Grammar, Unification Grammar, and Parsing.</booktitle>
<editor>in N. Haddock et al. (eds.),</editor>
<marker>Zeevat, Klein, Calder, 1987</marker>
<rawString>[8] Zeevat, Henk, Ewan Klein, and Jo Calder: 1987, &apos;An Introduction to Unification Categorial Grammar&apos;, in N. Haddock et al. (eds.), Edinburgh Working Papers in Cognitive Science, 1: Categorial Grammar, Unification Grammar, and Parsing.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Zeevat</author>
</authors>
<title>Combining Categorial Grammar and Unification&apos;,</title>
<date>1988</date>
<booktitle>Natural Language Parsing and Linguistic Theories,</booktitle>
<pages>202--229</pages>
<editor>in U. Reyle and C. Rohrer (eds.),</editor>
<location>Henk:</location>
<marker>Zeevat, 1988</marker>
<rawString>[9] Zeevat, Henk: 1988, &apos;Combining Categorial Grammar and Unification&apos;, in U. Reyle and C. Rohrer (eds.), Natural Language Parsing and Linguistic Theories, Dordrecht, Reidel, 202-229.</rawString>
</citation>
<citation valid="false">
<title>A Lexical Fragment: parse will bind position (via list-encoding): category(gilbert, cat(np,</title>
<location>Pi, P2)).</location>
<marker></marker>
<rawString>%% A Lexical Fragment: parse will bind position (via list-encoding): category(gilbert, cat(np, Pi, P2)).</rawString>
</citation>
<citation valid="false">
<authors>
<author>category</author>
</authors>
<marker>category, </marker>
<rawString>category(brigitte, cat(np, Pi, P2)). category(walks,cat(cat(s,_,_,_)/cat(np,P2,_,P2),_,P3,P4)). category(love, cat(cat(vp,_,_,_)/cat(np,P3,P3,_),_,P1,P2)). category(must,cat(cat(cat(s,-,-,_)/cat(np,P2,_,P2),_._,_)/cat(vp,P6,P5,_),_,P3,P4)).</rawString>
</citation>
<citation valid="false">
<title>Application and (overgeneral) Composition: Partial evaluation of DPy with the actual Juncture P2 %% imposes Adjacency. DPy (=P2) must not be == Y&apos;s other end (see and &gt;B). Antecedent \+ Y=np X% disallows ALL combination with unraised NPs.</title>
<note>reduce(cat(cat(X,DPx,P1,P3)/cat(Y,P2,P2,P3),_,P1,P2),</note>
<marker></marker>
<rawString>category(madly, cat(cat(vP,-,-,_)/cat(vp,P2,_,P2),_,P3,P4)). %% Application and (overgeneral) Composition: Partial evaluation of DPy with the actual Juncture P2 %% imposes Adjacency. DPy (=P2) must not be == Y&apos;s other end (see &lt;B and &gt;B). Antecedent \+ Y=np X% disallows ALL combination with unraised NPs. reduce(cat(cat(X,DPx,P1,P3)/cat(Y,P2,P2,P3),_,P1,P2),</rawString>
</citation>
<citation valid="false">
<authors>
<author>cat</author>
</authors>
<booktitle>P2, P2,P3), cat(X,DPx,P1,P3)) \+ Y=np. %&gt; reduce(cat(Y,P2,P1,P2),</booktitle>
<marker>cat, </marker>
<rawString>cat(Y, P2, P2,P3), cat(X,DPx,P1,P3)) \+ Y=np. %&gt; reduce(cat(Y,P2,P1,P2),</rawString>
</citation>
<citation valid="false">
<note>cat(cat(X,DPx,P1,P3)/cat(r,P2,P1,P2),_,P2,P3), cat(X,DPx,P1,P3)) \+ Y=np.</note>
<marker></marker>
<rawString>cat(cat(X,DPx,P1,P3)/cat(r,P2,P1,P2),_,P2,P3), cat(X,DPx,P1,P3)) \+ Y=np.</rawString>
</citation>
<citation valid="false">
<booktitle>reduce(cat(cat(X,DPx,X1,12)/cat(Y,P2,P2,Y2),_,P1,P2), cat(cat(Y,P2,P2,Y2)/cat(Z,DPz,Z1,Z2),_,P2,P3), cat(cat(I,DPx,X1,12)/cat(Z,DPz,Z1,Z2),_,P1,P3)) \+ Y=np,\+ Y2==P2. %&gt;B, cf. ex. 24a</booktitle>
<marker></marker>
<rawString>reduce(cat(cat(X,DPx,X1,12)/cat(Y,P2,P2,Y2),_,P1,P2), cat(cat(Y,P2,P2,Y2)/cat(Z,DPz,Z1,Z2),_,P2,P3), cat(cat(I,DPx,X1,12)/cat(Z,DPz,Z1,Z2),_,P1,P3)) \+ Y=np,\+ Y2==P2. %&gt;B, cf. ex. 24a</rawString>
</citation>
<citation valid="false">
<note>reduce(cat(cat(Y,P2,Y1,P2)/cat(Z,DPz,Z1,Z2),_,P1,P2), cat(cat(I,DPx,X1,X2)/cat(Y,P2,Y1,P2),_,P2,P3).</note>
<marker></marker>
<rawString>reduce(cat(cat(Y,P2,Y1,P2)/cat(Z,DPz,Z1,Z2),_,P1,P2), cat(cat(I,DPx,X1,X2)/cat(Y,P2,Y1,P2),_,P2,P3).</rawString>
</citation>
<citation valid="false">
<booktitle>cat(cat(I,DPx,X1,12)/cat(Z,DPz,Z1,Z2),_,P1,P3)) \+ Y=np,\+ Y1==P2. %&lt;B, cf. ex. 24b X% Order Preserving Type Raising: the rule np -&gt; TI(TInp).</booktitle>
<marker></marker>
<rawString>cat(cat(I,DPx,X1,12)/cat(Z,DPz,Z1,Z2),_,P1,P3)) \+ Y=np,\+ Y1==P2. %&lt;B, cf. ex. 24b X% Order Preserving Type Raising: the rule np -&gt; TI(TInp).</rawString>
</citation>
<citation valid="false">
<authors>
<author>Binds Pi raise</author>
</authors>
<booktitle>P2 cat(cat(T,DPt,T1,T2)/cat(cat(T,DPt,T1,T2)/cat(np,DPnp,P1,P2),DPnp,_,_), % cf.</booktitle>
<pages>26--1</pages>
<marker>raise, </marker>
<rawString>raise(cat(np,DPnp,P1,P2), % Binds Pi, P2 cat(cat(T,DPt,T1,T2)/cat(cat(T,DPt,T1,T2)/cat(np,DPnp,P1,P2),DPnp,_,_), % cf. ex. 26 -,P1,P2)).</rawString>
</citation>
<citation valid="false">
<authors>
<author>Parse</author>
</authors>
<title>simulates reduce-first shift-reduce recogniser with backtracking (inefficiently)</title>
<booktitle>parse([Result], 0, Result). % Halt parse([Cati1Stack], Buffer, Result) :- % Raise (syntactic) raise(Cat1, Cat2),</booktitle>
<location>parse((Cat2IStack], Buffer, Result).</location>
<marker>Parse, </marker>
<rawString>%% Parse simulates reduce-first shift-reduce recogniser with backtracking (inefficiently) parse([Result], 0, Result). % Halt parse([Cati1Stack], Buffer, Result) :- % Raise (syntactic) raise(Cat1, Cat2), parse((Cat2IStack], Buffer, Result).</rawString>
</citation>
<citation valid="false">
<authors>
<author>parse</author>
</authors>
<title>Buffer, Result) :- % Reduce reduce(Catl,</title>
<location>Cat2, Cat3), parse((Cat3IStack], Buffer, Result).</location>
<marker>parse, </marker>
<rawString>parse([Cat2, CatiIStack], Buffer, Result) :- % Reduce reduce(Catl, Cat2, Cat3), parse((Cat3IStack], Buffer, Result).</rawString>
</citation>
<citation valid="false">
<authors>
<author>parse</author>
</authors>
<title>Result) :- % Shift category(Vord, cat(V,DPw,NordIBuffer],Buffer)), % Position is list-encoded parseacat(V,DPedVordIBufferl,Buffer)IStack], Buffer, Result). %% Example crucially involving bidirectional T (twice) and % I ?-</title>
<pages>0</pages>
<marker>parse, </marker>
<rawString>parse(Stack, NordIBuffer], Result) :- % Shift category(Vord, cat(V,DPw,NordIBuffer],Buffer)), % Position is list-encoded parseacat(V,DPedVordIBufferl,Buffer)IStack], Buffer, Result). %% Example crucially involving bidirectional T (twice) and &lt;Bx: % I ?- parse(0,[gilbert,must,love,madly,brigitte],R).</rawString>
</citation>
<citation valid="false">
<booktitle>R = cat(s,_37,Egilbert,must,love,madly,brigittel,0) % ; -- plus 4 more equivalent derivations % yes</booktitle>
<marker></marker>
<rawString>% R = cat(s,_37,Egilbert,must,love,madly,brigittel,0) % ; -- plus 4 more equivalent derivations % yes</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>