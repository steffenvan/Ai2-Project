<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<note confidence="0.713732">
Proceedings of EACL &apos;99
</note>
<title confidence="0.949202">
Transducers from Rewrite Rules with Backreferences
</title>
<author confidence="0.969931">
Dale Gerdemann
</author>
<affiliation confidence="0.984488">
University of Tuebingen
</affiliation>
<address confidence="0.907028">
Kl. Wilhelmstr. 113
D-72074 Tuebingen
</address>
<email confidence="0.992127">
dg@sfs.nphil.uni-tuebingen.de
</email>
<author confidence="0.494989">
Gertjan van Noord
</author>
<affiliation confidence="0.965166">
Groningen University
</affiliation>
<address confidence="0.99104">
PO Box 716
NL 9700 AS Groningen
</address>
<email confidence="0.996952">
vannoord@1et.rug.n1
</email>
<sectionHeader confidence="0.982985" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999663923076923">
Context sensitive rewrite rules have been
widely used in several areas of natural
language processing, including syntax,
morphology, phonology and speech pro-
cessing. Kaplan and Kay, Karttunen,
and Mohri &amp; Sproat have given vari-
ous algorithms to compile such rewrite
rules into finite-state transducers. The
present paper extends this work by al-
lowing a limited form of backreferencing
in such rules. The explicit use of backref-
erencing leads to more elegant and gen-
eral solutions.
</bodyText>
<sectionHeader confidence="0.996301" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999899971428571">
Context sensitive rewrite rules have been widely
used in several areas of natural language pro-
cessing. Johnson (1972) has shown that such
rewrite rules are equivalent to finite state trans-
ducers in the special case that they are not al-
lowed to rewrite their own output. An algo-
rithm for compilation into transducers was pro-
vided by Kaplan and Kay (1994). Improvements
and extensions to this algorithm have been pro-
vided by Karttunen (1995), Karttunen (1997),
Karttunen (1996) and Mohri and Sproat (1996).
In this paper, the algorithm will be ex-
tended to provide a limited form of back-
referencing. Backreferencing has been im-
plicit in previous research, such as in the
&amp;quot;batch rules&amp;quot; of Kaplan and Kay (1994), brack-
eting transducers for finite-state parsing (Kart-
tunen, 1996), and the &amp;quot;LocalExtension&amp;quot; operation
of Roche and Schabes (1995). The explicit use of
backreferencing leads to more elegant and general
solutions.
Backreferencing is widely used in editors, script-
ing languages and other tools employing regular
expressions (Friedl, 1997). For example, Emacs
uses the special brackets \( and \) to capture
strings along with the notation \n to recall the nth
such string. The expression \ (a* \ )b \ 1 matches
strings of the form anban. Unrestricted use of
backreferencing thus can introduce non-regular
languages. For NLP finite state calculi (Kart-
tunen et al., 1996; van Noord, 1997) this is unac-
ceptable. The form of backreferences introduced
in this paper will therefore be restricted.
The central case of an allowable backreference
is:
</bodyText>
<equation confidence="0.997589">
x = T(x)IA__p (1)
</equation>
<bodyText confidence="0.955351576923077">
This says that each string x preceded by A and
followed by p is replaced by T(x), where A and p
are arbitrary regular expressions, and T is a trans-
ducer.&apos; This contrasts sharply with the rewriting
rules that follow the tradition of Kaplan &amp; Kay:
(2)
In this case, any string from the language 0 is
replaced by any string independently chosen from
the language 0.
We also allow multiple (non-permuting) back-
references of the form:
&apos;The syntax at this point is merely suggestive. As
an example, suppose that Ta„ transduces phrases into
acronyms. Then
T., (x)gabbr)__(/abbr)
would transduce &lt;abbr&gt;non-deterministic finite
automaton&lt;/abbr&gt; into &lt;abbr&gt;NDFA&lt;/abbr&gt;.
To compare this with a backreference in Per!,
suppose that T., is a subroutine that con-
verts phrases into acronyms and that R.„ is
a regular expression matching phrases that can
be converted into acronyms. Then (ignoring
the left context) one can write something like:
s/(Roc,.)(?=(/ABBR))/T„ ($1)/ge;. The backrefer-
ence variable, $1, will be set to whatever string
matches.
</bodyText>
<page confidence="0.985878">
126
</page>
<equation confidence="0.693444">
Proceedings of EACL &apos;99
xix2 Ti(xi)T2(x2) .7,,(xn)1A--P (3)
</equation>
<bodyText confidence="0.999616333333333">
Since transducers are closed under concatenation,
handling multiple backreferences reduces to the
problem of handling a single backreference:
</bodyText>
<equation confidence="0.992985">
X Ti • T2 • . . . • Tn)(x)IA__p (4)
</equation>
<bodyText confidence="0.999898769230769">
A problem arises if we want capturing to fol-
low the POSIX standard requiring a longest-
capture strategy. Friedl (1997) (p. 117), for
example, discusses matching the regular expres-
sion (toitop)(olpolo)?(gicallo?logical) against the
word: topological. The desired result is that
(once an overall match is established) the first set
of parentheses should capture the longest string
possible (top); the second set should then match
the longest string possible from what&apos;s left (o),
and so on. Such a left-most longest match con-
catenation operation is described in §3.
In the following section, we initially concentrate
on the simple case in (1) and show how (1) may be
compiled assuming left-to-right processing along
with the overall longest match strategy described
by Karttunen (1996).
The major components of the algorithm are
not new, but straightforward modifications of
components presented in Karttunen (1996) and
Mohri and Sproat (1996). We improve upon ex-
isting approaches because we solve a problem con-
cerning the use of special marker symbols (§2.1.2).
A further contribution is that all steps are imple-
mented in a freely available system, the FSA Util-
ities of van Noord (1997) (§2.1.1).
</bodyText>
<sectionHeader confidence="0.990893" genericHeader="method">
2 The Algorithm
</sectionHeader>
<subsectionHeader confidence="0.996161">
2.1 Preliminary Considerations
</subsectionHeader>
<bodyText confidence="0.999858">
Before presenting the algorithm proper, we will
deal with a couple of meta issues. First, we in-
troduce our version of the finite state calculus in
§2.1.1. The treatment of special marker symbols
is discussed in §2.1.2. Then in §2.1.3, we discuss
various utilities that will be essential for the algo-
rithm.
</bodyText>
<subsubsectionHeader confidence="0.539916">
2.1.1 FSA Utilities
</subsubsectionHeader>
<bodyText confidence="0.927560916666667">
The algorithm is implemented in the FSA Util-
ities (van Noord, 1997). We use the notation pro-
vided by the toolbox throughout this paper. Ta-
ble 1 lists the relevant regular expression opera-
tors. FSA Utilities offers the possibility to de-
fine new regular expression operators. For exam-
ple, consider the definition of the nullary operator
vowel as the union of the five vowels:
empty string
[El, ...En] concatenation of El ...En
empty language
{E1,...En} union of El,.. .En
</bodyText>
<figure confidence="0.983094">
E* Kleene closure
E- optionality
-E complement
El-E2 difference
$ E containment
El &amp; E2 intersection
any symbol
A:B pair
El x E2 cross-product
A o B composition
domain (E) domain of a transduction
range(E) range of a transduction
identity(E) identity transduction
inverse (E) inverse transduction
</figure>
<tableCaption confidence="0.9701285">
Table 1: Regular expression operators.
macro(vowelja,e,i,o,u1).
</tableCaption>
<bodyText confidence="0.98395175">
In such macro definitions, Prolog variables can be
used in order to define new n-ary regular expres-
sion operators in terms of existing operators. For
instance, the lenient_composition operator (Kart-
tunen, 1998) is defined by:
macro (priority_union (Q ,R) ,
{Q, -domain(Q) o Ft}).
macro (lenient_composition(R,C) ,
priority_union(R o C,R)).
Here, priority_union of two regular expressions
Q and R is defined as the union of Q and the compo-
sition of the complement of the domain of Q with
R. Lenient composition of R and C is defined as the
priority union of the composition of R and C (on
the one hand) and R (on the other hand).
Some operators, however, require something
more than simple macro expansion for their def-
inition. For example, suppose a user wanted to
match n occurrences of some pattern. The FSA
Utilities already has the &apos;*&apos; and &apos;+&apos; quantifiers,
but any other operators like this need to be user
defined. For this purpose, the FSA Utilities sup-
plies simple Prolog hooks allowing this general
quantifier to be defined as:
</bodyText>
<equation confidence="0.907012571428571">
macro (match_n(N , X) ,Regex) : -
match_n (N , X ,Regex)
match_n(0,_X, []) .
match_n(N,XJX1Rest]) :-
N &gt; 0,
Ni is N-1,
match_n(N1,X,Rest).
</equation>
<page confidence="0.901746">
127
</page>
<bodyText confidence="0.976756272727273">
Proceedings of EACL &apos;99
For example: match_n(3 , a) is equivalent to the
ordinary finite state calculus expression [a, a, a] .
Finally, regular expression operators can be
defined in terms of operations on the un-
derlying automaton. In such cases, Prolog
hooks for manipulating states and transitions
may be used. This functionality has been
used in van Noord and Gerdemann (1999) to pro-
vide an implementation of the algorithm in
Mohri and Sproat (1996).
</bodyText>
<subsectionHeader confidence="0.943766">
2.1.2 Treatment of Markers
</subsectionHeader>
<bodyText confidence="0.981814886792453">
Previous algorithms for compiling rewrite
rules into transducers have followed
Kaplan and Kay (1994) by introducing spe-
cial marker symbols (markers) into strings in
order to mark off candidate regions for replace-
ment. The assumption is that these markers are
outside the resulting transducer&apos;s alphabets. But
previous algorithms have not ensured that the
assumption holds.
This problem was recognized by
Karttunen (1996), whose algorithm starts with
a filter transducer which filters out any string
containing a marker. This is problematic for two
reasons. First, when applied to a string that does
happen to contain a marker, the algorithm will
simply fail. Second, it leads to logical problems in
the interpretation of complementation. Since the
complement of a regular expression R is defined
as E — R, one needs to know whether the marker
symbols are in E or not. This has not been
clearly addressed in previous literature.
We have taken a different approach by providing
a contextual way of distinguishing markers from
non-markers. Every symbol used in the algorithm
is replaced by a pair of symbols, where the second
member of the pair is either a 0 or a 1 depending
on whether the first member is a marker or not.2
As the first step in the algorithm, O&apos;s are inserted
after every symbol in the input string to indicate
that initially every symbol is a non-marker. This
is defined as:
macro(non_markers, [?, 0 :0]*).
Similarly, the following macro can be used to
insert a 0 after every symbol in an arbitrary ex-
pression E.
2This approach is similar to the idea of laying down
tracks as in the compilation of monadic second-order
logic into automata Klarlund (1997, p. 5). In fact, this
technique could possibly be used for a more efficient
implementation of our algorithm: instead of adding
transitions over 0 and 1, one could represent the al-
phabet as bit sequences and then add a final 0 bit for
any ordinary symbol and a final 1 bit for a marker
symbol.
macro (non_markers (E) ,
range(E o non_markers)).
Since E is a recognizer, it is first coerced to
identity(E). This form of implicit conversion is
standard in the finite state calculus.
Note that 0 and 1 are perfectly ordinary alpha-
bet symbols, which may also be used within a re-
placement. For example, the sequence [1,0] repre-
sents a non-marker use of the symbol 1.
</bodyText>
<subsubsectionHeader confidence="0.708042">
2.1.3 Utilities
</subsubsectionHeader>
<bodyText confidence="0.997346264705883">
Before describing the algorithm, it will be
helpful to have at our disposal a few general
tools, most of which were described already in
Kaplan and Kay (1994). These tools, however,
have been modified so that they work with our
approach of distinguishing markers from ordinary
symbols. So to begin with, we provide macros to
describe the alphabet and the alphabet extended
with marker symbols:
macro (sig, [?,0]) .
macro (xs ig, [?,{O,1}]).
The macro xsig is useful for defining a special-
ized version of complementation and containment:
macro (not (X) , xsig* - X) .
macro ($$ (X) , [xsig* , X , xsig*] ) .
The algorithm uses four kinds of brackets, so
it will be convenient to define macros for each of
these brackets, and for a few disjunctions.
macro Uhl , [&apos;&lt;1&apos;,1]).
macro(1b2,[&apos;&lt;2&apos;,1]).
macro(rb2,[&apos;2&gt;&apos; ,1]).
macro(rbl, [&apos;1&gt;&apos; ,1]).
macro(lb,{1b1,1b2}).
macro(rb,{rbl,rb2}).
macro(b1,-(1b1,rb11).
macro(b2,{1b2,rb2}).
macro(brack,-(1b,rbI).
As in Kaplan &amp; Kay, we define an Intro(S) op-
erator that produces a transducer that freely in-
troduces instances of S into an input string. We
extend this idea to create a family of Intro oper-
ators. It is often the case that we want to freely
introduce marker symbols into a string at any po-
sition except the beginning or the end.
</bodyText>
<table confidence="0.387888333333333">
%% Free introduction
macro (intro (S) , {xsig-S , x S}*).
%% Introduction, except at begin
macro(xintro(S),-(0,[xsig-S,intro(S)]}).
%% Introduction, except at end
macro(introx(S),-(0 ,[intro(S),xsig-S]l) .
</table>
<page confidence="0.9493">
128
</page>
<bodyText confidence="0.9435195">
Proceedings of EACL &apos;99
WI. Introduction, except at begin &amp; end
macro (xintrox (S) , { , [xsig-S] ,
[xsig-S, intro (S) , xsig-S] .
This family of Intro operators is useful for defin-
ing a family of Ignore operators:
</bodyText>
<equation confidence="0.64860275">
macro( ign( El,S),range(E1 o intro( S))).
macro(xign( E1,S),range(E1 o xintro( S))).
macro( ignx(E1,S),range(E1 o introx(S)))
macro(xignx(E1,S),range(E1 o xintrox(S)))
</equation>
<bodyText confidence="0.916870543478261">
In order to create filter transducers to en-
sure that markers are placed in the correct po-
sitions, Kaplan &amp; Kay introduce the operator
P-iff-S(L1,L2). A string is described by this
expression if each prefix in L1 is followed by a
suffix in L2 and each suffix in L2 is preceded by a
prefix in L1. In our approach, this is defined as:
macro(if_p_then_s(L1,L2),
notaL1,not(L2)])).
macro(if_s_then_p(L1,L2),
not([not(L1),L2])).
macro(p_iff_s(L1,L2),
if_p_then_s(L1,L2)
if_s_then_p(L1,L2)).
To make the use of p_if f _s more convenient, we
introduce a new operator l_iff_r (L , R) , which de-
scribes strings where every string position is pre-
ceded by a string in L just in case it is followed by
a string in R:
macro (l_iff_r (L ,R) ,
p_iff_s( [xsig*,L] , [R,xsig*] )) .
Finally, we introduce a new operator
if (Condition ,Then ,Else) for conditionals.
This operator is extremely useful, but in order
for it to work within the finite state calculus, one
needs a convention as to what counts as a boolean
true or false for the condition argument. It is
possible to define true as the universal language
and false as the empty language:
macro (true ,? *) . macro (f alse , .
With these definitions, we can use the comple-
ment operator as negation, the intersection opera-
tor as conjunction and the union operator as dis-
junction. Arbitrary expressions may be coerced
to booleans using the following macro:
macro (coerce_to_boolean (E) ,
range (E o (true x true) )) .
Here, E should describe a recognizer. E is corn-
posed with the universal transducer, which trans-
duces from anything (?*) to anything (?*). Now
with this background, we can define the condi-
tional:
macro ( if (Cond , Then ,Else) ,
coerce_to_boolean(Cond) o Then,
&amp;quot;coerce_to_boolean(Cond) o Else
1).
</bodyText>
<subsectionHeader confidence="0.932312">
2.2 Implementation
</subsectionHeader>
<bodyText confidence="0.98699546875">
A rule of the form x -+ T(x)IA__p will be written
as replace (T , Lambda ,Rho) . Rules of the more
general form xi . x7, Ti (xi ) T„(x„)IA__p
will be discussed in §3. The algorithm consists
of nine steps composed as in figure 1.
The names of these steps are mostly
derived from Karttunen (1995) and
Mohri and Sproat (1996) even though the
transductions involved are not exactly the same.
In particular, the steps derived from Mohri &amp;
Sproat (r, f, 11 and 12) will all be defined in
terms of the finite state calculus as opposed to
Mohri &amp; Sproat&apos;s approach of using low-level
manipulation of states and transitions.3
The first step, non_markers, was already de-
fined above. For the second step, we first consider
a simple special case. If the empty string is in
the language described by Right, then r (Right)
should insert an rb2 in every string position. The
definition of r (Right) is both simpler and more
efficient if this is treated as a special case. To in-
sert a bracket in every possible string position, we
use:
[[[Ix rb2, sig] * , x rb2]
If the empty string is not in Right, then we
must use intro (rb2) to introduce the marker
rb2, followed by l_iff_r to ensure that such
markers are immediately followed by a string in
Right, or more precisely a string in Right where
additional instances of rb2 are freely inserted in
any position other than the beginning. This ex-
pression is written as:
</bodyText>
<equation confidence="0.866519">
intro (rb2)
1_ if f _r (rb2 , xign (non_markers (Right) ,rb2) )
</equation>
<bodyText confidence="0.6328405">
Putting these two pieces together with the con-
ditional yields:
</bodyText>
<equation confidence="0.941441">
macro (r (R) ,
if([]&amp; R, % If: [1 is in R:
[7 x rb2 , sig]*, x rb2] ,
intro (rb2) % Else:
1_ iff _r (rb2 ,xign(non_markers (R) ,rb2) ) ) ) .
</equation>
<bodyText confidence="0.923875">
The third step, f (domain (T) ) is implemented
as:
</bodyText>
<footnote confidence="0.9915885">
3The alternative implementation is provided in
van Noord and Gerdemann (1999).
</footnote>
<page confidence="0.989009">
129
</page>
<equation confidence="0.878338090909091">
Proceedings of EACL &apos;99
macro(replace(T,Left,Right),
non_markers
r(Right)
f(domain(T))
left_to_right(domain(T))
longest_match(domain(T))
aux_replace(T)
11(Left)
12(Left)
inverse(non_markers)).
</equation>
<table confidence="0.692112615384615">
% introduce 0 after every symbol
% (a b c =&gt; a 0 b 0 c 0).
% introduce rb2 before any string
% in Right.
% introduce 1b2 before any string in
% domain(T) followed by rb2.
V. 1b2 rb2 around domain(T) optionally
V. replaced by lbl rbl
% filter out non-longest matches marked
% in previous step.
V. perform T&apos;s transduction on regions marked
% off by M&apos;s.
% ensure that lbl must be preceded
</table>
<figure confidence="0.88126225">
V. by a string in Left.
V. ensure that 1b2 must not occur preceded
V. by a string in Left.
V. remove the auxiliary O&apos;s.
</figure>
<figureCaption confidence="0.999976">
Figure 1: Definition of replace operator.
</figureCaption>
<bodyText confidence="0.981077083333333">
macro (f (Phi) , intro ( lb2)
l_if f _r (1b2 , [xignx (non_markers (Phi) , b2) ,
1b2- , rb2] )) .
The 1b2 is first introduced and then, using
l_if f _r, it is constrained to occur immediately be-
fore every instance of (ignoring complexities) Phi
followed by an rb2. Phi needs to be marked as
normal text using non_markers and then xign_x
is used to allow freely inserted 1b2 and rb2 any-
where except at the beginning and end. The fol-
lowing 1b2- allows an optional 1b2, which occurs
when the empty string is in Phi.
The fourth step is a guessing component which
(ignoring complexities) looks for sequences of the
form 1b2 Phi rb2 and converts some of these
into lbl Phi rbl, where the b1 marking indicates
that the sequence is a candidate for replacement.
The complication is that Phi, as always, must
be converted to non_markers (Phi) and instances
of b2 need to be ignored. Furthermore, between
pairs of lbl and rbl, instances of 1b2 are deleted.
These 1b2 markers have done their job and are
no longer needed. Putting this all together, the
definition is:
</bodyText>
<equation confidence="0.87138175">
macro(left_to_right(Phi),
[[xsig*,
[1b2 x lbl,
(ign(non_markers(Phi),b2)
inverse(intro(1b2))
),
rb2 x rbl]
]*, xsig*] ) .
</equation>
<bodyText confidence="0.954977208333333">
The fifth step filters out non-longest matches
produced in the previous step. For example (and
simplifying a bit), if Phi is ab*, then a string of
the form ... rbl a b lbl b ... should be ruled out
since there is an instance of Phi (ignoring brackets
except at the end) where there is an internal 1b1.
This is implemented as:4
macro (longest _match (Phi) ,
not($$([1b1,
(ignx(non_markers(Phi),brack)
$$(rbl)
), V. longer match must be
rb V. followed by an rb
) )
V. so context is ok
V. done with rb2, throw away:
inverse ( intro (rb2) ) ) •
The sixth step performs the transduction de-
scribed by T. This step is straightforwardly imple-
mented, where the main difficulty is getting T to
apply to our specially marked string:
macro(aux_replace(T),
Clbl,
inverse(non_markers)
</bodyText>
<footnote confidence="0.983410166666667">
4The line with $$ (rbl) can be opti-
mized a bit: Since we know that an rbl
must be preceded by Phi, we can write:
[ign_ (non_markers (Phi) , brack) ,rbl , xs ig*] ) .
This may lead to a more constrained (hence smaller)
transducer.
</footnote>
<page confidence="0.97002">
130
</page>
<equation confidence="0.7961596">
Proceedings of EACL &apos;99
o T o
non_markers ,
rb1 x 0
}*)
</equation>
<bodyText confidence="0.913805">
The seventh step ensures that 1b1 is preceded
by a string in Left:
</bodyText>
<equation confidence="0.903943666666667">
macro (11(L) ,
ign (if _s_then_p(
ignx( [xsig*,non_markers (L) ,1b1) ,
[1b1,xsig*] ) ,
1b2)
inverse (intro (1b1)) ) .
</equation>
<bodyText confidence="0.995621">
The eighth step ensures that 1b2 is not preceded
by a string in Left. This is implemented similarly
to the previous step:
</bodyText>
<equation confidence="0.6716326">
macro (12 (L) ,
if _s_then_p(
ignx (not ( [xsig* , non_markers (L)] ) ,1b2)
[1b2 ,xsig*] )
inverse (intro (1b2)) ) .
</equation>
<bodyText confidence="0.923402">
Finally the ninth step, inverse (non_markers),
removes .the O&apos;s so that the final result in not
marked up in any special way.
</bodyText>
<sectionHeader confidence="0.921286" genericHeader="method">
3 Longest Match Capturing
</sectionHeader>
<bodyText confidence="0.9992555">
As discussed in §1 the POSIX standard requires
that multiple captures follow a longest match
strategy. For multiple captures as in (3), one es-
tablishes first a longest match for domain(Ti)
</bodyText>
<listItem confidence="0.9789438">
• domain(Tn). Then we ensure that each of
domain(T2) in turn is required to match as long
as possible, with each one having priority over its
rightward neighbors. To implement this, we define
a macro lm_concat (Ts) and use it as:
</listItem>
<equation confidence="0.509865">
replace(lm_concat(Ts),Left,Right)
</equation>
<bodyText confidence="0.99988845">
Ensuring the longest overall match is delegated
to the replace macro, so lm_concat (Ts) needs
only ensure that each individual transducer within
Ts gets its proper left-to-right longest matching
priority. This problem is mostly solved by the
same techniques used to ensure the longest match
within the replace macro. The only complica-
tion here is that Ts can be of unbounded length.
So it is not possible to have a single expression in
the finite state calculus that applies to all possi-
ble lenghts. This means that we need something
a little more powerful than mere macro expan-
sion to construct the proper finite state calculus
expression. The FSA Utilities provides a Prolog
hook for this purpose. The resulting definition of
1m_concat is given in figure 2.
Suppose (as in Friedl (1997)), we want to match
the following list of recognizers against the string
topological and insert a marker in each bound-
ary position. This reduces to applying:
</bodyText>
<equation confidence="0.8631382">
1m_concat ( [
[{[t ,o] , [t,o,p]}, :
[-Co, Cp,o,l,oJI, : ,
{[g,i,c,a,1],
)
</equation>
<bodyText confidence="0.999607">
This expression transduces the string
topological only to the string top#oltlogical.5
</bodyText>
<sectionHeader confidence="0.994018" genericHeader="conclusions">
4 Conclusions
</sectionHeader>
<bodyText confidence="0.884549666666667">
5An anonymous reviewer suggested that
lm_concat could be implemented in the frame-
work of Karttunen (1996) as:
</bodyText>
<equation confidence="0.888629">
[toltoplolpolo]-4 #;
</equation>
<bodyText confidence="0.998949333333333">
Indeed the resulting transducer from this expression
would transduce topological into top#o#logical.
But unfortunately this transducer would also trans-
duce polotopogical into polottop#ottgical, since
the notion of left-right ordering is lost in this expres-
sion.
</bodyText>
<footnote confidence="0.700877666666667">
6The bracketing operator of Karttunen (1996), on
the other hand, does not provide for left and right
contexts.
</footnote>
<bodyText confidence="0.99882236">
The algorithm presented here has extended previ-
ous algorithms for rewrite rules by adding a lim-
ited version of backreferencing. This allows the
output of rewriting to be dependent on the form of
, the strings which are rewritten. This new feature
brings techniques used in Pen-like languages into
the finite state calculus. Such an integration is
needed in practical applications where simple text
processing needs to be combined with more so-
phisticated computational linguistics techniques.
One particularly interesting example where
backreferences are essential is cascaded determin-
istic (longest match) finite state parsing as de-
scribed for example in Abney (Abney, 1996) and
various papers in (Roche and Schabes, 1997a).
Clearly, the standard rewrite rules do not apply in
this domain. If NP is an NP recognizer, it would
not do to .say NP [NP]/p. Nothing would
force the string matched by the NP to the left of
the arrow to be the same as the string matched
by the NP to the right of the arrow.
One advantage of using our algorithm for fi-
nite state parsing is that the left and right con-
texts may be used to bring in top-down filter-
ing.6 An often cited advantage of finite state
</bodyText>
<page confidence="0.994744">
131
</page>
<bodyText confidence="0.814663222222222">
Proceedings of EACL &apos;99
macro(lm_concat(Ts),mark_boundaries(Domains) o ConcatTs):-
domains(Ts,Domains), concatT(Ts,ConcatTs).
domains([],[]).
domainsUFIR0],[domain(F)IRD:- domains(RO,R).
concatT([],[]).
concatTaTITs], [inverse(non_markers) o T,1b1 x [IIRest]):- concatT(Ts,Rest).
%% macro(mark_boundaries(L),Exp): This is the central component of lm_concat. For our
%% &amp;quot;toplological&amp;quot; example we will have:
</bodyText>
<equation confidence="0.7495695">
%% mark_boundaries(rdomain(H[t,o],[t,o,01,0: #7),
%% domain(Efo,[p,04,0]1,0: #7),
</equation>
<bodyText confidence="0.81547705">
%% domain(f[g,i,c,a,1],[o-,1,o,g,i,c,a,1]})])
%% which simplifies to:
%% mark_boundariesaf[t,o],[t,o,01,
%% Then by macro expansion, we get:
%% [f[t,o],[t,o,p]} o non_markers,px lbl,
o non_markers,Ux lbl,
%% o non_markers,Dx 1b1]
%%
%% % Filter 1: f[t,o],[t,o,p]I gets longest match
%% [ignx_1(non_markers(ift,o],[t,o,p]l),1b1),
%% ign(non_markers(fo,[p,o,l,o]}),lb1),
%% ign(non_markers(f[g,i,c,a,1],[o-,1,o,g,i,c,a,1]}),1b1)]
% Filter 2: fo,[p,o,1,0]1 gets longest match
%% [non_markers(f[t,0],Et,0,0}),1b1,
%% ignx_1(non_markers(fojp,o,l,o11),1b1),
%% ign(non_markers(f[g,i,c,a,1],[o-,1,o,g,i,c,a,1]}),1b1)]
macro(mark_boundaries(L),Exp):-
boundaries(L,Exp0), % guess boundary positions
greed(L,ExpO,Exp). V. filter non-longest matches
boundaries([],[]).
</bodyText>
<equation confidence="0.6892725">
boundaries([FIRO],[F o non_markers, [] x lbl IR]):- boundaries(RO,R).
greed(L,ComposedO,Composed) :-
aux_greed(L,O,Filters), compose_list(Filters,ComposedO,Composed).
aux_greed( [HITLFront,Filters):- aux_greed(T,H,Front,Filters,_CurrentFilter).
aux_greed(D,F,_,[],[ign(non_markers(F),1b1)]).
aux_greedUHIROLF,Front,[-L11R],[ign(non_markers(F),1b1)1R1]) :-
</equation>
<bodyText confidence="0.930810285714286">
append(Front,[ignx_1(non_markers(F),1b1)1R1],L1),
append(Front,[non_markers(F),1b1],NewFront),
aux_greed(RO,H,NewFront,R,R1).
%% ignore at least one instance of E2 except at end
macro(ignx_1(E1,E2), range(E1 o [[? *,[] x E2]+,? +])).
compose_list([],SoFar,SoFar).
compose_list(EFIRLSoFar,Composed):- compose_list(R,(SoFar o F),Composed).
</bodyText>
<figureCaption confidence="0.9979">
Figure 2: Definition of 1m_concat operator.
</figureCaption>
<page confidence="0.986348">
132
</page>
<bodyText confidence="0.991633648648649">
Proceedings of EACL &apos;99
parsing is robustness. A constituent is found bot-
tom up in an early level in the cascade even if
that constituent does not ultimately contribute
to an S in a later level of the cascade. While
this is undoubtedly an advantage for certain ap-
plications, our approach would allow the intro-
duction of some top-down filtering while main-
taining the robustness of a bottom-up approach.
A second advantage for robust finite state pars-
ing is that bracketing could also include the no-
tion of &amp;quot;repair&amp;quot; as in Abney (1990). One might,
for example, want to say something like: xy
[NP RepairDet(x) RepairNWii A--p7 so that an
NP could be parsed as a slightly malformed Det
followed by a slightly malformed N. RepairDet
and RepairN, in this example, could be doing a
variety of things such as: contextualized spelling
correction, reordering of function words, replace-
ment of phrases by acronyms, or any other oper-
ation implemented as a transducer.
Finally, we should mention the problem of com-
plexity. A critical reader might see the nine steps
in our algorithm and conclude that the algorithm
is overly complex. This would be a false conclu-
sion. To begin with, the problem itself is complex.
It is easy to create examples where the resulting
transducer created by any algorithm would be-
come unmanageably large. But there exist strate-
gies for keeping the transducers smaller. For ex-
ample, it is not necessary for all nine steps to
be composed. They can also be cascaded. In
that case it will be possible to implement different
steps by different strategies, e.g. by determinis-
tic or non-deterministic transducers or bimachines
(Roche and Schabes, 1997b). The range of possi-
bilities leaves plenty of room for future research.
</bodyText>
<sectionHeader confidence="0.999403" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.9741943125">
Steve Abney. 1990. Rapid incremental parsing
with repair. In Proceedings of the 6th New OED
Conference: Electronic Text Rese arch, pages
1-9.
Steven Abney. 1996. Partial parsing via finite-
state cascades. In Proceedings of the ESSLLI
&apos;96 Robust Parsing Workshop.
Jeffrey Friedl. 1997. Mastering Regular Expres-
sions. O&apos;Reilly Sz Associates, Inc.
C. Douglas Johnson. 1972. Formal Aspects
of Phonological Descriptions. Mouton, The
Hague.
7The syntax here has been simplified. The rule
should be understood as: replace(lm_concat(Minp&apos;,
repair_det, repair_n, [1:Tblambda, rho).
Ronald Kaplan and Martin Kay. 1994. Regular
models of phonological rule systems. Computa-
tional Linguistics, 20(3):331-379.
L. Karttunen, J-P. Chanod, G. Grefenstette, and
A. Schiller. 1996. Regular expressions for lan-
guage engineering. Natural Language Engineer-
ing, 2(4):305-238.
Lauri Karttunen. 1995. The replace operator.
In 33th Annual Meeting of the Association for
Computational Linguistics, M.I.T. Cambridge
Mass.
Lauri Karttunen. 1996. Directed replacement.
In 34th Annual Meeting of the Association for
Computational Linguistics, Santa Cruz.
Lauri Karttunen. 1997. The replace operator.
In Emannual Roche and Yves Schabes, editors,
Finite-State Language Processing, pages 117-
147. Bradford, MIT Press.
Lauri Karttunen. 1998. The proper treatment
of optimality theory in computational phonol-
ogy. In Finite-state Methods in Natural Lan-
guage Processing, pages 1-12, Ankara, June.
Nils Klarlund. 1997. Mona &amp; Fido: The logic
automaton connection in practice. In CSL &apos;97.
Mehryar Mohri and Richard Sproat. 1996. An
efficient compiler for weighted rewrite rules.
In 34th Annual Meeting of the Association, for
Computational Linguistics, Santa Cruz.
Emmanuel Roche and Yves Schabes. 1995. De-
terministic part-of-speech tagging with finite-
state transducers. Computational Linguistics,
21:227-263. Reprinted in Roche &amp; Schabes
(1997).
Emmanuel Roche and Yves Schabes, editors.
1997a. Finite-State Language Processing. MIT
Press, Cambridge.
Emmanuel Roche and Yves Schabes. 1997b. In-
troduction. In Emmanuel Roche and Yves Sch-
abes, editors, Finite-State Language Processing.
MIT Press, Cambridge, Mass.
Gertjan van Noord and Dale Gerdemann. 1999.
An extendible regular expression compiler for
finite-state approaches in natural language pro-
cessing. In Workshop on Implementing Au-
tomata 99, Potsdam Germany.
Gertjan van Noord. 1997. Fsa utilities.
The FSA Utilities toolbox is available free of
charge under Gnu General Public License at
http: / / www .rug .nlr vannoord /Fsa/
</reference>
<page confidence="0.99893">
133
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.085652">
<note confidence="0.601739">Proceedings of EACL &apos;99</note>
<title confidence="0.920889">Transducers from Rewrite Rules with Backreferences</title>
<author confidence="0.999714">Dale Gerdemann</author>
<affiliation confidence="0.998656">University of Tuebingen</affiliation>
<address confidence="0.7832605">Kl. Wilhelmstr. 113 D-72074 Tuebingen</address>
<author confidence="0.96534">Gertjan van_Noord</author>
<affiliation confidence="0.999955">Groningen University</affiliation>
<address confidence="0.933681">PO Box 716 NL 9700 AS Groningen</address>
<email confidence="0.350728">vannoord@1et.rug.n1</email>
<abstract confidence="0.990338928571429">Context sensitive rewrite rules have been widely used in several areas of natural language processing, including syntax, morphology, phonology and speech processing. Kaplan and Kay, Karttunen, Mohri have given various algorithms to compile such rewrite rules into finite-state transducers. The present paper extends this work by allowing a limited form of backreferencing in such rules. The explicit use of backreferencing leads to more elegant and general solutions.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Steve Abney</author>
</authors>
<title>Rapid incremental parsing with repair.</title>
<date>1990</date>
<booktitle>In Proceedings of the 6th New OED Conference: Electronic Text Rese arch,</booktitle>
<pages>1--9</pages>
<contexts>
<context position="24807" citStr="Abney (1990)" startWordPosition="3972" endWordPosition="3973">e_list(R,(SoFar o F),Composed). Figure 2: Definition of 1m_concat operator. 132 Proceedings of EACL &apos;99 parsing is robustness. A constituent is found bottom up in an early level in the cascade even if that constituent does not ultimately contribute to an S in a later level of the cascade. While this is undoubtedly an advantage for certain applications, our approach would allow the introduction of some top-down filtering while maintaining the robustness of a bottom-up approach. A second advantage for robust finite state parsing is that bracketing could also include the notion of &amp;quot;repair&amp;quot; as in Abney (1990). One might, for example, want to say something like: xy [NP RepairDet(x) RepairNWii A--p7 so that an NP could be parsed as a slightly malformed Det followed by a slightly malformed N. RepairDet and RepairN, in this example, could be doing a variety of things such as: contextualized spelling correction, reordering of function words, replacement of phrases by acronyms, or any other operation implemented as a transducer. Finally, we should mention the problem of complexity. A critical reader might see the nine steps in our algorithm and conclude that the algorithm is overly complex. This would b</context>
</contexts>
<marker>Abney, 1990</marker>
<rawString>Steve Abney. 1990. Rapid incremental parsing with repair. In Proceedings of the 6th New OED Conference: Electronic Text Rese arch, pages 1-9.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Steven Abney</author>
</authors>
<title>Partial parsing via finitestate cascades.</title>
<date>1996</date>
<booktitle>In Proceedings of the ESSLLI &apos;96 Robust Parsing Workshop.</booktitle>
<contexts>
<context position="21773" citStr="Abney, 1996" startWordPosition="3616" endWordPosition="3617">for rewrite rules by adding a limited version of backreferencing. This allows the output of rewriting to be dependent on the form of , the strings which are rewritten. This new feature brings techniques used in Pen-like languages into the finite state calculus. Such an integration is needed in practical applications where simple text processing needs to be combined with more sophisticated computational linguistics techniques. One particularly interesting example where backreferences are essential is cascaded deterministic (longest match) finite state parsing as described for example in Abney (Abney, 1996) and various papers in (Roche and Schabes, 1997a). Clearly, the standard rewrite rules do not apply in this domain. If NP is an NP recognizer, it would not do to .say NP [NP]/p. Nothing would force the string matched by the NP to the left of the arrow to be the same as the string matched by the NP to the right of the arrow. One advantage of using our algorithm for finite state parsing is that the left and right contexts may be used to bring in top-down filtering.6 An often cited advantage of finite state 131 Proceedings of EACL &apos;99 macro(lm_concat(Ts),mark_boundaries(Domains) o ConcatTs):- dom</context>
</contexts>
<marker>Abney, 1996</marker>
<rawString>Steven Abney. 1996. Partial parsing via finitestate cascades. In Proceedings of the ESSLLI &apos;96 Robust Parsing Workshop.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jeffrey Friedl</author>
</authors>
<title>Mastering Regular Expressions. O&apos;Reilly Sz Associates,</title>
<date>1997</date>
<publisher>Inc.</publisher>
<contexts>
<context position="1821" citStr="Friedl, 1997" startWordPosition="276" endWordPosition="277">en (1995), Karttunen (1997), Karttunen (1996) and Mohri and Sproat (1996). In this paper, the algorithm will be extended to provide a limited form of backreferencing. Backreferencing has been implicit in previous research, such as in the &amp;quot;batch rules&amp;quot; of Kaplan and Kay (1994), bracketing transducers for finite-state parsing (Karttunen, 1996), and the &amp;quot;LocalExtension&amp;quot; operation of Roche and Schabes (1995). The explicit use of backreferencing leads to more elegant and general solutions. Backreferencing is widely used in editors, scripting languages and other tools employing regular expressions (Friedl, 1997). For example, Emacs uses the special brackets \( and \) to capture strings along with the notation \n to recall the nth such string. The expression \ (a* \ )b \ 1 matches strings of the form anban. Unrestricted use of backreferencing thus can introduce non-regular languages. For NLP finite state calculi (Karttunen et al., 1996; van Noord, 1997) this is unacceptable. The form of backreferences introduced in this paper will therefore be restricted. The central case of an allowable backreference is: x = T(x)IA__p (1) This says that each string x preceded by A and followed by p is replaced by T(x</context>
<context position="3736" citStr="Friedl (1997)" startWordPosition="586" endWordPosition="587">at R.„ is a regular expression matching phrases that can be converted into acronyms. Then (ignoring the left context) one can write something like: s/(Roc,.)(?=(/ABBR))/T„ ($1)/ge;. The backreference variable, $1, will be set to whatever string matches. 126 Proceedings of EACL &apos;99 xix2 Ti(xi)T2(x2) .7,,(xn)1A--P (3) Since transducers are closed under concatenation, handling multiple backreferences reduces to the problem of handling a single backreference: X Ti • T2 • . . . • Tn)(x)IA__p (4) A problem arises if we want capturing to follow the POSIX standard requiring a longestcapture strategy. Friedl (1997) (p. 117), for example, discusses matching the regular expression (toitop)(olpolo)?(gicallo?logical) against the word: topological. The desired result is that (once an overall match is established) the first set of parentheses should capture the longest string possible (top); the second set should then match the longest string possible from what&apos;s left (o), and so on. Such a left-most longest match concatenation operation is described in §3. In the following section, we initially concentrate on the simple case in (1) and show how (1) may be compiled assuming left-to-right processing along with</context>
<context position="20262" citStr="Friedl (1997)" startWordPosition="3389" endWordPosition="3390">ht longest matching priority. This problem is mostly solved by the same techniques used to ensure the longest match within the replace macro. The only complication here is that Ts can be of unbounded length. So it is not possible to have a single expression in the finite state calculus that applies to all possible lenghts. This means that we need something a little more powerful than mere macro expansion to construct the proper finite state calculus expression. The FSA Utilities provides a Prolog hook for this purpose. The resulting definition of 1m_concat is given in figure 2. Suppose (as in Friedl (1997)), we want to match the following list of recognizers against the string topological and insert a marker in each boundary position. This reduces to applying: 1m_concat ( [ [{[t ,o] , [t,o,p]}, : [-Co, Cp,o,l,oJI, : , {[g,i,c,a,1], ) This expression transduces the string topological only to the string top#oltlogical.5 4 Conclusions 5An anonymous reviewer suggested that lm_concat could be implemented in the framework of Karttunen (1996) as: [toltoplolpolo]-4 #; Indeed the resulting transducer from this expression would transduce topological into top#o#logical. But unfortunately this transducer w</context>
</contexts>
<marker>Friedl, 1997</marker>
<rawString>Jeffrey Friedl. 1997. Mastering Regular Expressions. O&apos;Reilly Sz Associates, Inc.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Douglas Johnson</author>
</authors>
<title>Formal Aspects of Phonological Descriptions.</title>
<date>1972</date>
<publisher>Mouton, The Hague.</publisher>
<contexts>
<context position="895" citStr="Johnson (1972)" startWordPosition="128" endWordPosition="129"> Context sensitive rewrite rules have been widely used in several areas of natural language processing, including syntax, morphology, phonology and speech processing. Kaplan and Kay, Karttunen, and Mohri &amp; Sproat have given various algorithms to compile such rewrite rules into finite-state transducers. The present paper extends this work by allowing a limited form of backreferencing in such rules. The explicit use of backreferencing leads to more elegant and general solutions. 1 Introduction Context sensitive rewrite rules have been widely used in several areas of natural language processing. Johnson (1972) has shown that such rewrite rules are equivalent to finite state transducers in the special case that they are not allowed to rewrite their own output. An algorithm for compilation into transducers was provided by Kaplan and Kay (1994). Improvements and extensions to this algorithm have been provided by Karttunen (1995), Karttunen (1997), Karttunen (1996) and Mohri and Sproat (1996). In this paper, the algorithm will be extended to provide a limited form of backreferencing. Backreferencing has been implicit in previous research, such as in the &amp;quot;batch rules&amp;quot; of Kaplan and Kay (1994), bracketin</context>
</contexts>
<marker>Johnson, 1972</marker>
<rawString>C. Douglas Johnson. 1972. Formal Aspects of Phonological Descriptions. Mouton, The Hague.</rawString>
</citation>
<citation valid="false">
<title>7The syntax here has been simplified. The rule should be understood as: replace(lm_concat(Minp&apos;, repair_det, repair_n,</title>
<location>[1:Tblambda, rho).</location>
<marker></marker>
<rawString>7The syntax here has been simplified. The rule should be understood as: replace(lm_concat(Minp&apos;, repair_det, repair_n, [1:Tblambda, rho).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ronald Kaplan</author>
<author>Martin Kay</author>
</authors>
<title>Regular models of phonological rule systems.</title>
<date>1994</date>
<journal>Computational Linguistics,</journal>
<pages>20--3</pages>
<contexts>
<context position="1131" citStr="Kaplan and Kay (1994)" startWordPosition="169" endWordPosition="172">us algorithms to compile such rewrite rules into finite-state transducers. The present paper extends this work by allowing a limited form of backreferencing in such rules. The explicit use of backreferencing leads to more elegant and general solutions. 1 Introduction Context sensitive rewrite rules have been widely used in several areas of natural language processing. Johnson (1972) has shown that such rewrite rules are equivalent to finite state transducers in the special case that they are not allowed to rewrite their own output. An algorithm for compilation into transducers was provided by Kaplan and Kay (1994). Improvements and extensions to this algorithm have been provided by Karttunen (1995), Karttunen (1997), Karttunen (1996) and Mohri and Sproat (1996). In this paper, the algorithm will be extended to provide a limited form of backreferencing. Backreferencing has been implicit in previous research, such as in the &amp;quot;batch rules&amp;quot; of Kaplan and Kay (1994), bracketing transducers for finite-state parsing (Karttunen, 1996), and the &amp;quot;LocalExtension&amp;quot; operation of Roche and Schabes (1995). The explicit use of backreferencing leads to more elegant and general solutions. Backreferencing is widely used in</context>
<context position="7778" citStr="Kaplan and Kay (1994)" startWordPosition="1238" endWordPosition="1241">&gt; 0, Ni is N-1, match_n(N1,X,Rest). 127 Proceedings of EACL &apos;99 For example: match_n(3 , a) is equivalent to the ordinary finite state calculus expression [a, a, a] . Finally, regular expression operators can be defined in terms of operations on the underlying automaton. In such cases, Prolog hooks for manipulating states and transitions may be used. This functionality has been used in van Noord and Gerdemann (1999) to provide an implementation of the algorithm in Mohri and Sproat (1996). 2.1.2 Treatment of Markers Previous algorithms for compiling rewrite rules into transducers have followed Kaplan and Kay (1994) by introducing special marker symbols (markers) into strings in order to mark off candidate regions for replacement. The assumption is that these markers are outside the resulting transducer&apos;s alphabets. But previous algorithms have not ensured that the assumption holds. This problem was recognized by Karttunen (1996), whose algorithm starts with a filter transducer which filters out any string containing a marker. This is problematic for two reasons. First, when applied to a string that does happen to contain a marker, the algorithm will simply fail. Second, it leads to logical problems in t</context>
<context position="10182" citStr="Kaplan and Kay (1994)" startWordPosition="1652" endWordPosition="1655">dd a final 0 bit for any ordinary symbol and a final 1 bit for a marker symbol. macro (non_markers (E) , range(E o non_markers)). Since E is a recognizer, it is first coerced to identity(E). This form of implicit conversion is standard in the finite state calculus. Note that 0 and 1 are perfectly ordinary alphabet symbols, which may also be used within a replacement. For example, the sequence [1,0] represents a non-marker use of the symbol 1. 2.1.3 Utilities Before describing the algorithm, it will be helpful to have at our disposal a few general tools, most of which were described already in Kaplan and Kay (1994). These tools, however, have been modified so that they work with our approach of distinguishing markers from ordinary symbols. So to begin with, we provide macros to describe the alphabet and the alphabet extended with marker symbols: macro (sig, [?,0]) . macro (xs ig, [?,{O,1}]). The macro xsig is useful for defining a specialized version of complementation and containment: macro (not (X) , xsig* - X) . macro ($$ (X) , [xsig* , X , xsig*] ) . The algorithm uses four kinds of brackets, so it will be convenient to define macros for each of these brackets, and for a few disjunctions. macro Uhl </context>
</contexts>
<marker>Kaplan, Kay, 1994</marker>
<rawString>Ronald Kaplan and Martin Kay. 1994. Regular models of phonological rule systems. Computational Linguistics, 20(3):331-379.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Karttunen</author>
<author>J-P Chanod</author>
<author>G Grefenstette</author>
<author>A Schiller</author>
</authors>
<title>Regular expressions for language engineering.</title>
<date>1996</date>
<journal>Natural Language Engineering,</journal>
<pages>2--4</pages>
<contexts>
<context position="2150" citStr="Karttunen et al., 1996" startWordPosition="330" endWordPosition="334">rsing (Karttunen, 1996), and the &amp;quot;LocalExtension&amp;quot; operation of Roche and Schabes (1995). The explicit use of backreferencing leads to more elegant and general solutions. Backreferencing is widely used in editors, scripting languages and other tools employing regular expressions (Friedl, 1997). For example, Emacs uses the special brackets \( and \) to capture strings along with the notation \n to recall the nth such string. The expression \ (a* \ )b \ 1 matches strings of the form anban. Unrestricted use of backreferencing thus can introduce non-regular languages. For NLP finite state calculi (Karttunen et al., 1996; van Noord, 1997) this is unacceptable. The form of backreferences introduced in this paper will therefore be restricted. The central case of an allowable backreference is: x = T(x)IA__p (1) This says that each string x preceded by A and followed by p is replaced by T(x), where A and p are arbitrary regular expressions, and T is a transducer.&apos; This contrasts sharply with the rewriting rules that follow the tradition of Kaplan &amp; Kay: (2) In this case, any string from the language 0 is replaced by any string independently chosen from the language 0. We also allow multiple (non-permuting) backre</context>
</contexts>
<marker>Karttunen, Chanod, Grefenstette, Schiller, 1996</marker>
<rawString>L. Karttunen, J-P. Chanod, G. Grefenstette, and A. Schiller. 1996. Regular expressions for language engineering. Natural Language Engineering, 2(4):305-238.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
</authors>
<title>The replace operator.</title>
<date>1995</date>
<booktitle>In 33th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<location>M.I.T. Cambridge Mass.</location>
<contexts>
<context position="1217" citStr="Karttunen (1995)" startWordPosition="184" endWordPosition="185">r extends this work by allowing a limited form of backreferencing in such rules. The explicit use of backreferencing leads to more elegant and general solutions. 1 Introduction Context sensitive rewrite rules have been widely used in several areas of natural language processing. Johnson (1972) has shown that such rewrite rules are equivalent to finite state transducers in the special case that they are not allowed to rewrite their own output. An algorithm for compilation into transducers was provided by Kaplan and Kay (1994). Improvements and extensions to this algorithm have been provided by Karttunen (1995), Karttunen (1997), Karttunen (1996) and Mohri and Sproat (1996). In this paper, the algorithm will be extended to provide a limited form of backreferencing. Backreferencing has been implicit in previous research, such as in the &amp;quot;batch rules&amp;quot; of Kaplan and Kay (1994), bracketing transducers for finite-state parsing (Karttunen, 1996), and the &amp;quot;LocalExtension&amp;quot; operation of Roche and Schabes (1995). The explicit use of backreferencing leads to more elegant and general solutions. Backreferencing is widely used in editors, scripting languages and other tools employing regular expressions (Friedl, 1</context>
<context position="13955" citStr="Karttunen (1995)" startWordPosition="2278" endWordPosition="2279">) )) . Here, E should describe a recognizer. E is cornposed with the universal transducer, which transduces from anything (?*) to anything (?*). Now with this background, we can define the conditional: macro ( if (Cond , Then ,Else) , coerce_to_boolean(Cond) o Then, &amp;quot;coerce_to_boolean(Cond) o Else 1). 2.2 Implementation A rule of the form x -+ T(x)IA__p will be written as replace (T , Lambda ,Rho) . Rules of the more general form xi . x7, Ti (xi ) T„(x„)IA__p will be discussed in §3. The algorithm consists of nine steps composed as in figure 1. The names of these steps are mostly derived from Karttunen (1995) and Mohri and Sproat (1996) even though the transductions involved are not exactly the same. In particular, the steps derived from Mohri &amp; Sproat (r, f, 11 and 12) will all be defined in terms of the finite state calculus as opposed to Mohri &amp; Sproat&apos;s approach of using low-level manipulation of states and transitions.3 The first step, non_markers, was already defined above. For the second step, we first consider a simple special case. If the empty string is in the language described by Right, then r (Right) should insert an rb2 in every string position. The definition of r (Right) is both si</context>
</contexts>
<marker>Karttunen, 1995</marker>
<rawString>Lauri Karttunen. 1995. The replace operator. In 33th Annual Meeting of the Association for Computational Linguistics, M.I.T. Cambridge Mass.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
</authors>
<title>Directed replacement.</title>
<date>1996</date>
<booktitle>In 34th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<location>Santa Cruz.</location>
<contexts>
<context position="1253" citStr="Karttunen (1996)" startWordPosition="188" endWordPosition="189">mited form of backreferencing in such rules. The explicit use of backreferencing leads to more elegant and general solutions. 1 Introduction Context sensitive rewrite rules have been widely used in several areas of natural language processing. Johnson (1972) has shown that such rewrite rules are equivalent to finite state transducers in the special case that they are not allowed to rewrite their own output. An algorithm for compilation into transducers was provided by Kaplan and Kay (1994). Improvements and extensions to this algorithm have been provided by Karttunen (1995), Karttunen (1997), Karttunen (1996) and Mohri and Sproat (1996). In this paper, the algorithm will be extended to provide a limited form of backreferencing. Backreferencing has been implicit in previous research, such as in the &amp;quot;batch rules&amp;quot; of Kaplan and Kay (1994), bracketing transducers for finite-state parsing (Karttunen, 1996), and the &amp;quot;LocalExtension&amp;quot; operation of Roche and Schabes (1995). The explicit use of backreferencing leads to more elegant and general solutions. Backreferencing is widely used in editors, scripting languages and other tools employing regular expressions (Friedl, 1997). For example, Emacs uses the sp</context>
<context position="4401" citStr="Karttunen (1996)" startWordPosition="687" endWordPosition="688">gular expression (toitop)(olpolo)?(gicallo?logical) against the word: topological. The desired result is that (once an overall match is established) the first set of parentheses should capture the longest string possible (top); the second set should then match the longest string possible from what&apos;s left (o), and so on. Such a left-most longest match concatenation operation is described in §3. In the following section, we initially concentrate on the simple case in (1) and show how (1) may be compiled assuming left-to-right processing along with the overall longest match strategy described by Karttunen (1996). The major components of the algorithm are not new, but straightforward modifications of components presented in Karttunen (1996) and Mohri and Sproat (1996). We improve upon existing approaches because we solve a problem concerning the use of special marker symbols (§2.1.2). A further contribution is that all steps are implemented in a freely available system, the FSA Utilities of van Noord (1997) (§2.1.1). 2 The Algorithm 2.1 Preliminary Considerations Before presenting the algorithm proper, we will deal with a couple of meta issues. First, we introduce our version of the finite state calcu</context>
<context position="8098" citStr="Karttunen (1996)" startWordPosition="1288" endWordPosition="1289">nd transitions may be used. This functionality has been used in van Noord and Gerdemann (1999) to provide an implementation of the algorithm in Mohri and Sproat (1996). 2.1.2 Treatment of Markers Previous algorithms for compiling rewrite rules into transducers have followed Kaplan and Kay (1994) by introducing special marker symbols (markers) into strings in order to mark off candidate regions for replacement. The assumption is that these markers are outside the resulting transducer&apos;s alphabets. But previous algorithms have not ensured that the assumption holds. This problem was recognized by Karttunen (1996), whose algorithm starts with a filter transducer which filters out any string containing a marker. This is problematic for two reasons. First, when applied to a string that does happen to contain a marker, the algorithm will simply fail. Second, it leads to logical problems in the interpretation of complementation. Since the complement of a regular expression R is defined as E — R, one needs to know whether the marker symbols are in E or not. This has not been clearly addressed in previous literature. We have taken a different approach by providing a contextual way of distinguishing markers f</context>
<context position="20700" citStr="Karttunen (1996)" startWordPosition="3458" endWordPosition="3459">ite state calculus expression. The FSA Utilities provides a Prolog hook for this purpose. The resulting definition of 1m_concat is given in figure 2. Suppose (as in Friedl (1997)), we want to match the following list of recognizers against the string topological and insert a marker in each boundary position. This reduces to applying: 1m_concat ( [ [{[t ,o] , [t,o,p]}, : [-Co, Cp,o,l,oJI, : , {[g,i,c,a,1], ) This expression transduces the string topological only to the string top#oltlogical.5 4 Conclusions 5An anonymous reviewer suggested that lm_concat could be implemented in the framework of Karttunen (1996) as: [toltoplolpolo]-4 #; Indeed the resulting transducer from this expression would transduce topological into top#o#logical. But unfortunately this transducer would also transduce polotopogical into polottop#ottgical, since the notion of left-right ordering is lost in this expression. 6The bracketing operator of Karttunen (1996), on the other hand, does not provide for left and right contexts. The algorithm presented here has extended previous algorithms for rewrite rules by adding a limited version of backreferencing. This allows the output of rewriting to be dependent on the form of , the </context>
</contexts>
<marker>Karttunen, 1996</marker>
<rawString>Lauri Karttunen. 1996. Directed replacement. In 34th Annual Meeting of the Association for Computational Linguistics, Santa Cruz.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
</authors>
<title>The replace operator.</title>
<date>1997</date>
<booktitle>In Emannual Roche and Yves Schabes, editors, Finite-State Language Processing,</booktitle>
<pages>117--147</pages>
<publisher>Bradford, MIT Press.</publisher>
<contexts>
<context position="1235" citStr="Karttunen (1997)" startWordPosition="186" endWordPosition="187">k by allowing a limited form of backreferencing in such rules. The explicit use of backreferencing leads to more elegant and general solutions. 1 Introduction Context sensitive rewrite rules have been widely used in several areas of natural language processing. Johnson (1972) has shown that such rewrite rules are equivalent to finite state transducers in the special case that they are not allowed to rewrite their own output. An algorithm for compilation into transducers was provided by Kaplan and Kay (1994). Improvements and extensions to this algorithm have been provided by Karttunen (1995), Karttunen (1997), Karttunen (1996) and Mohri and Sproat (1996). In this paper, the algorithm will be extended to provide a limited form of backreferencing. Backreferencing has been implicit in previous research, such as in the &amp;quot;batch rules&amp;quot; of Kaplan and Kay (1994), bracketing transducers for finite-state parsing (Karttunen, 1996), and the &amp;quot;LocalExtension&amp;quot; operation of Roche and Schabes (1995). The explicit use of backreferencing leads to more elegant and general solutions. Backreferencing is widely used in editors, scripting languages and other tools employing regular expressions (Friedl, 1997). For example,</context>
</contexts>
<marker>Karttunen, 1997</marker>
<rawString>Lauri Karttunen. 1997. The replace operator. In Emannual Roche and Yves Schabes, editors, Finite-State Language Processing, pages 117-147. Bradford, MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
</authors>
<title>The proper treatment of optimality theory in computational phonology.</title>
<date>1998</date>
<booktitle>In Finite-state Methods in Natural Language Processing,</booktitle>
<pages>1--12</pages>
<location>Ankara,</location>
<contexts>
<context position="6228" citStr="Karttunen, 1998" startWordPosition="977" endWordPosition="979">empty language {E1,...En} union of El,.. .En E* Kleene closure E- optionality -E complement El-E2 difference $ E containment El &amp; E2 intersection any symbol A:B pair El x E2 cross-product A o B composition domain (E) domain of a transduction range(E) range of a transduction identity(E) identity transduction inverse (E) inverse transduction Table 1: Regular expression operators. macro(vowelja,e,i,o,u1). In such macro definitions, Prolog variables can be used in order to define new n-ary regular expression operators in terms of existing operators. For instance, the lenient_composition operator (Karttunen, 1998) is defined by: macro (priority_union (Q ,R) , {Q, -domain(Q) o Ft}). macro (lenient_composition(R,C) , priority_union(R o C,R)). Here, priority_union of two regular expressions Q and R is defined as the union of Q and the composition of the complement of the domain of Q with R. Lenient composition of R and C is defined as the priority union of the composition of R and C (on the one hand) and R (on the other hand). Some operators, however, require something more than simple macro expansion for their definition. For example, suppose a user wanted to match n occurrences of some pattern. The FSA </context>
</contexts>
<marker>Karttunen, 1998</marker>
<rawString>Lauri Karttunen. 1998. The proper treatment of optimality theory in computational phonology. In Finite-state Methods in Natural Language Processing, pages 1-12, Ankara, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Nils Klarlund</author>
</authors>
<title>Mona &amp; Fido: The logic automaton connection in practice.</title>
<date>1997</date>
<booktitle>In CSL &apos;97.</booktitle>
<contexts>
<context position="9347" citStr="Klarlund (1997" startWordPosition="1505" endWordPosition="1506">in the algorithm is replaced by a pair of symbols, where the second member of the pair is either a 0 or a 1 depending on whether the first member is a marker or not.2 As the first step in the algorithm, O&apos;s are inserted after every symbol in the input string to indicate that initially every symbol is a non-marker. This is defined as: macro(non_markers, [?, 0 :0]*). Similarly, the following macro can be used to insert a 0 after every symbol in an arbitrary expression E. 2This approach is similar to the idea of laying down tracks as in the compilation of monadic second-order logic into automata Klarlund (1997, p. 5). In fact, this technique could possibly be used for a more efficient implementation of our algorithm: instead of adding transitions over 0 and 1, one could represent the alphabet as bit sequences and then add a final 0 bit for any ordinary symbol and a final 1 bit for a marker symbol. macro (non_markers (E) , range(E o non_markers)). Since E is a recognizer, it is first coerced to identity(E). This form of implicit conversion is standard in the finite state calculus. Note that 0 and 1 are perfectly ordinary alphabet symbols, which may also be used within a replacement. For example, the</context>
</contexts>
<marker>Klarlund, 1997</marker>
<rawString>Nils Klarlund. 1997. Mona &amp; Fido: The logic automaton connection in practice. In CSL &apos;97.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mehryar Mohri</author>
<author>Richard Sproat</author>
</authors>
<title>An efficient compiler for weighted rewrite rules.</title>
<date>1996</date>
<booktitle>In 34th Annual Meeting of the Association, for Computational Linguistics,</booktitle>
<location>Santa Cruz.</location>
<contexts>
<context position="1281" citStr="Mohri and Sproat (1996)" startWordPosition="191" endWordPosition="194">erencing in such rules. The explicit use of backreferencing leads to more elegant and general solutions. 1 Introduction Context sensitive rewrite rules have been widely used in several areas of natural language processing. Johnson (1972) has shown that such rewrite rules are equivalent to finite state transducers in the special case that they are not allowed to rewrite their own output. An algorithm for compilation into transducers was provided by Kaplan and Kay (1994). Improvements and extensions to this algorithm have been provided by Karttunen (1995), Karttunen (1997), Karttunen (1996) and Mohri and Sproat (1996). In this paper, the algorithm will be extended to provide a limited form of backreferencing. Backreferencing has been implicit in previous research, such as in the &amp;quot;batch rules&amp;quot; of Kaplan and Kay (1994), bracketing transducers for finite-state parsing (Karttunen, 1996), and the &amp;quot;LocalExtension&amp;quot; operation of Roche and Schabes (1995). The explicit use of backreferencing leads to more elegant and general solutions. Backreferencing is widely used in editors, scripting languages and other tools employing regular expressions (Friedl, 1997). For example, Emacs uses the special brackets \( and \) to </context>
<context position="4559" citStr="Mohri and Sproat (1996)" startWordPosition="708" endWordPosition="711">e first set of parentheses should capture the longest string possible (top); the second set should then match the longest string possible from what&apos;s left (o), and so on. Such a left-most longest match concatenation operation is described in §3. In the following section, we initially concentrate on the simple case in (1) and show how (1) may be compiled assuming left-to-right processing along with the overall longest match strategy described by Karttunen (1996). The major components of the algorithm are not new, but straightforward modifications of components presented in Karttunen (1996) and Mohri and Sproat (1996). We improve upon existing approaches because we solve a problem concerning the use of special marker symbols (§2.1.2). A further contribution is that all steps are implemented in a freely available system, the FSA Utilities of van Noord (1997) (§2.1.1). 2 The Algorithm 2.1 Preliminary Considerations Before presenting the algorithm proper, we will deal with a couple of meta issues. First, we introduce our version of the finite state calculus in §2.1.1. The treatment of special marker symbols is discussed in §2.1.2. Then in §2.1.3, we discuss various utilities that will be essential for the alg</context>
<context position="7649" citStr="Mohri and Sproat (1996)" startWordPosition="1220" endWordPosition="1223">uantifier to be defined as: macro (match_n(N , X) ,Regex) : - match_n (N , X ,Regex) match_n(0,_X, []) . match_n(N,XJX1Rest]) :- N &gt; 0, Ni is N-1, match_n(N1,X,Rest). 127 Proceedings of EACL &apos;99 For example: match_n(3 , a) is equivalent to the ordinary finite state calculus expression [a, a, a] . Finally, regular expression operators can be defined in terms of operations on the underlying automaton. In such cases, Prolog hooks for manipulating states and transitions may be used. This functionality has been used in van Noord and Gerdemann (1999) to provide an implementation of the algorithm in Mohri and Sproat (1996). 2.1.2 Treatment of Markers Previous algorithms for compiling rewrite rules into transducers have followed Kaplan and Kay (1994) by introducing special marker symbols (markers) into strings in order to mark off candidate regions for replacement. The assumption is that these markers are outside the resulting transducer&apos;s alphabets. But previous algorithms have not ensured that the assumption holds. This problem was recognized by Karttunen (1996), whose algorithm starts with a filter transducer which filters out any string containing a marker. This is problematic for two reasons. First, when ap</context>
<context position="13983" citStr="Mohri and Sproat (1996)" startWordPosition="2281" endWordPosition="2284"> describe a recognizer. E is cornposed with the universal transducer, which transduces from anything (?*) to anything (?*). Now with this background, we can define the conditional: macro ( if (Cond , Then ,Else) , coerce_to_boolean(Cond) o Then, &amp;quot;coerce_to_boolean(Cond) o Else 1). 2.2 Implementation A rule of the form x -+ T(x)IA__p will be written as replace (T , Lambda ,Rho) . Rules of the more general form xi . x7, Ti (xi ) T„(x„)IA__p will be discussed in §3. The algorithm consists of nine steps composed as in figure 1. The names of these steps are mostly derived from Karttunen (1995) and Mohri and Sproat (1996) even though the transductions involved are not exactly the same. In particular, the steps derived from Mohri &amp; Sproat (r, f, 11 and 12) will all be defined in terms of the finite state calculus as opposed to Mohri &amp; Sproat&apos;s approach of using low-level manipulation of states and transitions.3 The first step, non_markers, was already defined above. For the second step, we first consider a simple special case. If the empty string is in the language described by Right, then r (Right) should insert an rb2 in every string position. The definition of r (Right) is both simpler and more efficient if </context>
</contexts>
<marker>Mohri, Sproat, 1996</marker>
<rawString>Mehryar Mohri and Richard Sproat. 1996. An efficient compiler for weighted rewrite rules. In 34th Annual Meeting of the Association, for Computational Linguistics, Santa Cruz.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Emmanuel Roche</author>
<author>Yves Schabes</author>
</authors>
<title>Deterministic part-of-speech tagging with finitestate transducers.</title>
<date>1995</date>
<journal>Computational Linguistics,</journal>
<pages>21--227</pages>
<note>Reprinted in Roche &amp; Schabes</note>
<contexts>
<context position="1615" citStr="Roche and Schabes (1995)" startWordPosition="245" endWordPosition="248">e that they are not allowed to rewrite their own output. An algorithm for compilation into transducers was provided by Kaplan and Kay (1994). Improvements and extensions to this algorithm have been provided by Karttunen (1995), Karttunen (1997), Karttunen (1996) and Mohri and Sproat (1996). In this paper, the algorithm will be extended to provide a limited form of backreferencing. Backreferencing has been implicit in previous research, such as in the &amp;quot;batch rules&amp;quot; of Kaplan and Kay (1994), bracketing transducers for finite-state parsing (Karttunen, 1996), and the &amp;quot;LocalExtension&amp;quot; operation of Roche and Schabes (1995). The explicit use of backreferencing leads to more elegant and general solutions. Backreferencing is widely used in editors, scripting languages and other tools employing regular expressions (Friedl, 1997). For example, Emacs uses the special brackets \( and \) to capture strings along with the notation \n to recall the nth such string. The expression \ (a* \ )b \ 1 matches strings of the form anban. Unrestricted use of backreferencing thus can introduce non-regular languages. For NLP finite state calculi (Karttunen et al., 1996; van Noord, 1997) this is unacceptable. The form of backreferenc</context>
</contexts>
<marker>Roche, Schabes, 1995</marker>
<rawString>Emmanuel Roche and Yves Schabes. 1995. Deterministic part-of-speech tagging with finitestate transducers. Computational Linguistics, 21:227-263. Reprinted in Roche &amp; Schabes (1997).</rawString>
</citation>
<citation valid="false">
<booktitle>1997a. Finite-State Language Processing.</booktitle>
<editor>Emmanuel Roche and Yves Schabes, editors.</editor>
<publisher>MIT Press,</publisher>
<location>Cambridge.</location>
<marker></marker>
<rawString>Emmanuel Roche and Yves Schabes, editors. 1997a. Finite-State Language Processing. MIT Press, Cambridge.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Emmanuel Roche</author>
<author>Yves Schabes</author>
</authors>
<date>1997</date>
<booktitle>Finite-State Language Processing.</booktitle>
<editor>Introduction. In Emmanuel Roche and Yves Schabes, editors,</editor>
<publisher>MIT Press,</publisher>
<location>Cambridge, Mass.</location>
<contexts>
<context position="21820" citStr="Roche and Schabes, 1997" startWordPosition="3622" endWordPosition="3625">d version of backreferencing. This allows the output of rewriting to be dependent on the form of , the strings which are rewritten. This new feature brings techniques used in Pen-like languages into the finite state calculus. Such an integration is needed in practical applications where simple text processing needs to be combined with more sophisticated computational linguistics techniques. One particularly interesting example where backreferences are essential is cascaded deterministic (longest match) finite state parsing as described for example in Abney (Abney, 1996) and various papers in (Roche and Schabes, 1997a). Clearly, the standard rewrite rules do not apply in this domain. If NP is an NP recognizer, it would not do to .say NP [NP]/p. Nothing would force the string matched by the NP to the left of the arrow to be the same as the string matched by the NP to the right of the arrow. One advantage of using our algorithm for finite state parsing is that the left and right contexts may be used to bring in top-down filtering.6 An often cited advantage of finite state 131 Proceedings of EACL &apos;99 macro(lm_concat(Ts),mark_boundaries(Domains) o ConcatTs):- domains(Ts,Domains), concatT(Ts,ConcatTs). domains</context>
</contexts>
<marker>Roche, Schabes, 1997</marker>
<rawString>Emmanuel Roche and Yves Schabes. 1997b. Introduction. In Emmanuel Roche and Yves Schabes, editors, Finite-State Language Processing. MIT Press, Cambridge, Mass.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gertjan van Noord</author>
<author>Dale Gerdemann</author>
</authors>
<title>An extendible regular expression compiler for finite-state approaches in natural language processing.</title>
<date>1999</date>
<booktitle>In Workshop on Implementing Automata 99,</booktitle>
<location>Potsdam</location>
<marker>van Noord, Gerdemann, 1999</marker>
<rawString>Gertjan van Noord and Dale Gerdemann. 1999. An extendible regular expression compiler for finite-state approaches in natural language processing. In Workshop on Implementing Automata 99, Potsdam Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gertjan van Noord</author>
</authors>
<title>Fsa utilities. The FSA Utilities toolbox is available free of charge under Gnu General Public License at http: / / www .rug .nlr vannoord /Fsa/</title>
<date>1997</date>
<marker>van Noord, 1997</marker>
<rawString>Gertjan van Noord. 1997. Fsa utilities. The FSA Utilities toolbox is available free of charge under Gnu General Public License at http: / / www .rug .nlr vannoord /Fsa/</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>