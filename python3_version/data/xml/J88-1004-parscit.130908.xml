<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<sectionHeader confidence="0.954469" genericHeader="method">
IMPLEMENTING SYSTEMIC CLASSIFICATION BY UNIFICATION
C. S. Mellish
</sectionHeader>
<subsectionHeader confidence="0.874923">
School of Cognitive Sciences, University of Sussex&apos;
</subsectionHeader>
<bodyText confidence="0.9354247">
The &amp;quot;system networks&amp;quot; of Systemic Grammar provide
a notation for declaring how combinations of properties
may imply or be inconsistent with other combinations.
Partial information about a linguistic entity can be
recorded as a set of known properties, and a system
network then enables one to infer which other proper-
ties follow from this and which other properties are
incompatible with this. The possible descriptions al-
lowed by a system network are partially ordered by the
relationship of subsumption, where a description sub-
sumes any description that is more specific than it,
given the background constraints declared by the net-
work. Given this partial ordering, the set of descriptions
can be seen as forming a lattice with least upper bound
and greatest lower bound operations. In a class of
applications (such as parsing and generation) that re-
quire incremental description refinement, we are only
really interested in forming new conjunctions (greatest
lower bounds) and testing subsumption relationships.
If one factors out the complexity of variable renam-
ing and introduces special top and bottom elements, the
set of logical terms also forms a lattice (the lattice of
Generalised Atomic Formulae —&amp;quot;GAF lattice&amp;quot;) under
the partial ordering relation &amp;quot;is equally or more instan-
tiated than&amp;quot; (Reynolds (1970)). In this lattice, the great-
est lower bound operation is unification (Robinson
(1965)). Unification is a primitive operation in most
logic programming systems and is also the basis of
various grammatical formalisms. It is therefore a rela-
tively well understood operation and can be efficiently
implemented.
In this paper, we investigate to what extent it is
possible to find structure-preserving mappings from the
description spaces defined by system networks to su-
blattices of the GAF lattice. Where this is possible, we
can use a fixed mapping from property names to logical
terms to create terms that represent conjunctive de-
scriptions (by unification) and to test subsumption (by
testing &amp;quot;less instantiated than&amp;quot;). Incompatibility of
descriptions is also indicated by unification failure.
There are a number of reasons why it is interesting to
investigate these possibilities:
(1) They may result in more efficient or flexible ways of
using system networks for inferencing.
(2) They may enable language analysers or generators
which involve unification for other reasons (e.g.,
analysers for GPSG (Gazdar et al. (1985)) or Func-
tional Unification Grammar (Kay (1984)) to build in
feature co-occurrence tests using the same mecha-
nism.
</bodyText>
<listItem confidence="0.768339777777778">
(3) They may enable us to make formal sense of various
ad-hoc mechanisms used by logic programmers in
natural language processing.
(4) By exposing the nature of the relevant description
spaces, they may open various possibilities for the
implementation of other classification tasks, e.g.,
concept learning (Mellish forthcoming).
(5) They may give us more insight into the semantics of
system networks and the potential of unification.
</listItem>
<sectionHeader confidence="0.954226" genericHeader="method">
1 HALLIDAY&apos;S SYSTEM NETWORKS
</sectionHeader>
<bodyText confidence="0.931936647058824">
System networks, as used in Halliday&apos;s Systemic Gram-
mar (Hudson (1971), Kress (1976), Winograd (1983)) are
a way of encoding the choices that must be made in the
generation of a complex linguistic object and the inter-
dependencies between them. There is actually nothing
that makes such networks specific to linguistic applica-
tions, and so there is no reason why they cannot be
applied to describing the choices involved in other
complex situations.
A system network can be viewed as a graph, some of
whose nodes are annotated with symbols representing
properties. The nodes are tied together by the use of
four different &amp;quot;connectives&amp;quot;, which we shall designate
by &amp;quot;I&amp;quot;, &amp;quot;{&amp;quot;, &amp;quot;}&amp;quot; and &amp;quot;1&amp;quot;. In order to be precise about
Copyright 1988 by the Association for Computational Linguistics. Permission to copy without fee all or part of this material is granted provided
that the copies are not made for direct commercial advantage and the CL reference and this copyright notice are included on the first page. To
copy otherwise, or to republish, requires a fee and/or specific permission.
</bodyText>
<note confidence="0.556233">
0362-613X/ 88 /010040-51$03.00
</note>
<page confidence="0.664853">
40 Computational Linguistics Volume 14, Number 1, Winter 1988
</page>
<note confidence="0.902461">
C.S. Mellish Implementing Systemic Classification by Unification
</note>
<bodyText confidence="0.998826571428571">
exactly what system networks mean, we will present a
logical interpretation, where each appearance of a
&amp;quot;connective&amp;quot; in a network gives rise to a set of logical
axioms relating the property symbols (interpreted as
unary predicates) appearing with it.
A fundamental concept in system networks is that of
the choice system. A choice system indicates that, if a
certain &amp;quot;entry condition&amp;quot; holds, then the object de-
scribed must have exactly one of the properties men-
tioned in the system. Choice systems are denoted by
use of the &amp;quot;I&amp;quot; &amp;quot;connective&amp;quot;. Thus, Figure 1 indicates
that masculine, feminine and neuter are mutually exclu-
sive and whenever an object has a gender it has one of
these. In logic,
</bodyText>
<equation confidence="0.989773666666667">
V x: AMO {feminine(x) masculine(x) neuter(x)}
V x: gender(x) feminine(x) v masculine(x) v
neuter(x)
</equation>
<bodyText confidence="0.961406">
where AMO (&amp;quot;at most one of&apos;) is defined by:
</bodyText>
<equation confidence="0.724945666666667">
AMO S == /X\ —1(s1 &amp; s2)
si.s2 E S
SI s2
</equation>
<bodyText confidence="0.9925695">
Incidentally, an alternative reading that might suggest
itself, namely:
</bodyText>
<equation confidence="0.76060525">
V x: gender(x) (AMO {feminine(x) masculine(x)
neuter(x)} &amp;
feminine(x) v masculine(x) v
neuter(x))
</equation>
<bodyText confidence="0.999782769230769">
is not adequate, because it allows spurious models, for
instance where there is an object &amp;quot;a&amp;quot; which satisfies
&amp;quot;feminine(a)&amp;quot; and &amp;quot;masculine(a)&amp;quot; but not &amp;quot;gender
(a)&amp;quot;.
Sometimes more than one choice will be relevant,
given the same entry conditions. This is indicated by the
&amp;quot;{&amp;quot; &amp;quot;connective&amp;quot;. For instance, as indicated in Figure
2, in some languages a noun may be either singular or
plural, and also either masculine or feminine. Instances
of the &amp;quot;{&amp;quot; connective can be translated into logic by
simply treating the entry condition of the &amp;quot;{&amp;quot; as that of
all the networks introduced on the right hand side.
Thus:
</bodyText>
<equation confidence="0.980938">
V x: AMO {feminine(x) masculine(x)1
V x: noun(x) feminine(x) v masculine(x)
V x: AMO {singular(x) plural(x)}
Vx: noun(x) singular(x) v plural(x)
</equation>
<bodyText confidence="0.8372782">
The final two connectives concern complex entry con-
ditions into networks. A conjunctive entry condition is
denoted by &amp;quot;1&amp;quot;, as shown in Figure 3. This means
third
sing
</bodyText>
<equation confidence="0.7664655">
simply:
V x: third(x) &amp; sing(x) gender(x)
</equation>
<bodyText confidence="0.7892465">
Finally, &amp;quot;1&amp;quot; introduces a disjunctive entry condition, so
that the example provided in Figure 4
personal
demonstr
</bodyText>
<equation confidence="0.667504">
means:
V x: personal(x) v demonstr(x) number(x)
</equation>
<bodyText confidence="0.993407888888889">
By convention, uses of the four &amp;quot;connectives&amp;quot; can be
connected together in any way, as long as &amp;quot;loops&amp;quot; are
not created. That is, if one regards each connective as a
set of arcs going from properties on its &amp;quot;left&amp;quot; to
properties on its &amp;quot;right&amp;quot;, the resulting directed graph
must be acyclic.
As a larger example, Figure 5 depicts the system
network for English pronouns presented in Winograd
(1983)). Here is a logical translation of selected parts.
</bodyText>
<equation confidence="0.9999406">
V x: AMO {first(x) second(x) third(x)}
V x: person(x) first(x) v second(x) v third(x)
V x: AMO {singular(x) plural(x)}
V x: numb(x) singular(x) v plural(x)
V x: third(x) &amp; singular(x) gender(x)
</equation>
<bodyText confidence="0.9994452">
It is important to note that in this paper we consider
system networks as a self-contained notation for de-
scribing certain types of choices (&amp;quot;systemic choices&amp;quot;)
that are available in the construction of a complex
(linguistic) object. We will be completely ignoring the
philosophical differences between Systemic Grammar
and other forms of generative grammar, and we will also
completely ignore the other components that are re-
quired in a full Systemic Grammar, such as realisation
rules.
</bodyText>
<figure confidence="0.750396678571428">
gender masculine
feminine
neuter
masculine
feminine
noun
singular
plural
gender
number
Computational Linguistics Volume 14, Number 1, Winter 1988 41
C.S. Mellish Implementing Systemic Classification by Unification
animate
inanimate
subjective
objective
reflexive
possessive
possdet
question
personal person first gender feminine
second masculine
third
numb singular neuter
plural
demonstrativ
near
far
</figure>
<sectionHeader confidence="0.946964" genericHeader="method">
2 SUBSUMPTION AND THE LATTICE OF DESCRIPTIONS
</sectionHeader>
<bodyText confidence="0.984613571428572">
The property symbols in a system network provide a
basic vocabulary out of which descriptions can be built.
The most obvious way to produce more complex de-
scriptions is by conjunction and disjunction. The logical
interpretation of such complex descriptions is straight-
forward, and we will often blur the distinction between
a description and its interpretation. Thus:
masculine &amp; singular corresponds to
Ax. masculine(x) &amp; singular(x)
masculine v feminine corresponds to
Ax. masculine(x) v feminine(x)
A fundamental relationship between descriptions is
subsumption:
di subsumes d2 if 1= V x: d2(x) D di(x)
where is the set of axioms derived from the network.
Note that our notion of subsumption depends vitally on
1. This is a special case of what Buntine (1986) calls
&amp;quot;generalised subsumption&amp;quot;. Intuitively di subsumes d2
if, given the axioms 1, di is a more general description
than d2. That is, if di describes all the objects accurately
described by d2 and maybe more. Subsumption is a
partial ordering on descriptions, and the set of possible
descriptions (properties and all possible finite conjunc-
tions and disjunctions of descriptions made from them),
ordered by subsumption, forms a lattice. In this lattice,
the least upper bound of two descriptions is their
disjunction and the greatest lower bound is their con-
junction. Figure 6 is a picture of a portion of the lattice
consisting of the descriptions derived from the pronoun
network. In the picture, if there is a line going upwards
from description d2 to description di then di subsumes
d2. Two descriptions that are logically equivalent (e.g.,
&amp;quot;personal&amp;singular&amp;quot; is the same as &amp;quot;singular&amp;case&amp;quot;)
give rise to a single node in the diagram (technically, we
are interested in the quotient lattice of the free lattice
generated by the property symbols, with respect to the
congruence relation defined by 1,). To find the node for
the conjunction of two descriptions, one finds the
highest node that is &amp;quot;below&amp;quot; both, i.e., the greatest
lower bound. Similarly, to find the node for the disjunc-
tion of two descriptions, one finds the lowest node
which is &amp;quot;above&amp;quot; both.
</bodyText>
<sectionHeader confidence="0.999379" genericHeader="method">
3 INCREMENTAL DESCRIPTION REFINEMENT
</sectionHeader>
<bodyText confidence="0.9987536">
The previous two sections introduced a simple language
of descriptions and the use of system networks to
express extra background information about (con-
straints on) the terms appearing in those descriptions. A
notion of subsumption was defined which allowed this
</bodyText>
<page confidence="0.964622">
42 Computational Linguistics Volume 14, Number 1, Winter 1988
</page>
<figure confidence="0.836852666666667">
C.S. Mellish Implementing Systemic Classification by Unification
personal singular
third personal &amp;
singular
gender
neuter
</figure>
<bodyText confidence="0.999886574712644">
background information to be taken into account. But
what are the operations that we need to carry out on
descriptions in practical natural language processing
systems, and does the structure we have described
support these?
In this paper, we will concentrate especially on a
process that seems to arise in a number of contexts in
natural language processing—incremental description
refinement. Incremental description refinement (IDR)
takes place when, a target description is gradually being
built of some individual, and information about this
individual appears as a sequence of self-contained,
independent data descriptions. For instance, the target
could be the description of an English sentence and the
data descriptions partial descriptions of this sentence
like:
the sentence is passive
the sentence is declarative
the agent of the sentence is the speaker
At any point in an IDR process, the information that has
accumulated so far may allow certain properties of the
individual to be inferred, and so one would like to be
able to interrogate the partial description that has been
built. In particular, one would like to be able to answer
questions about which descriptions are compatible and
incompatible with the target description. To build an
effective IDR system, one must have a way to represent
the conjunction of an arbitrary set of pieces of informa-
tion so that inconsistency and subsumption relation-
ships with other descriptions can be easily detected.
The term &amp;quot;incremental description refinement&amp;quot; was,
we believe, originally coined by Bobrow and Webber
(1980), but the notion of incrementally building descrip-
tions has been influential in a number of AI projects.
In natural language processing, IDR is relevant to
both natural language parsing and generation. In pars-
ing, it is natural to accumulate information about the
structure of a phrase gradually as words are read. For
instance, in the sentence
The hairy sheep was. . .
we know after reading the first three words that the
gender of the subject noun phrase is &amp;quot;neuter&amp;quot; and after
the next word we know that the number of that phrase
is &amp;quot;singular&amp;quot;. It is important in parsing that we be able
to accumulate pieces of information of this kind and
detect inconsistencies if they arise. In generation, it is
natural to want to allow different semantic and prag-
matic factors to provide separate constraints on a
sentence to be generated. For instance, one pragmatic
goal may force a sentence to be passive; another forces
it to have a given surface subject. This conjunction of
constraints may be inconsistent with certain choices of
the main verb (e.g., &amp;quot;buy&amp;quot; vs. &amp;quot;sell&amp;quot;). Again there is a
need to reason about partial descriptions that are built
incrementally.
In formal terms, the operations involved in IDR are
simple. At any point, the information known about the
target description can be represented without loss by a
single &amp;quot;partial description—the least upper bound of all
the descriptions the target could be. Initially this is
simply the most general description of all (&amp;quot;true&amp;quot;).
When a new data description appears, the partial de-
scription is replaced by the greatest lower bound of it
and the data description. This &amp;quot;algorithm&amp;quot; for IDR is in
fact a special case of a more general classification
algorithm given in Mellish (forthcoming). At any point,
a contradiction is signaled by the partial description
becoming the most specific description of all (&amp;quot;false&amp;quot;).
Moreover, one can validly infer that the target is
subsumed by a given description if the partial descrip-
tion is. The only operations that we need for IDR are
subsumption checking and the computation of greatest
lower bounds. This means that, in fact, we do not need
the full lattice structure developed above—all we need
is the meet semi-lattice (Birkhoff (1963)) that contains
the possible data descriptions and all possible conjunc-
tions of them.
The above description of IDR is not dependent on
descriptions being related to system networks, and
indeed IDR has been used in quite different contexts. In
this paper, however, we will confine ourselves to this
case, and consider IDR where the data descriptions are
precisely the properties mentioned in a system network.
We are thus concerned with ways of computing and
testing subsumption between conjunctions of proper-
ties, given the background information provided by the
network axioms.
</bodyText>
<sectionHeader confidence="0.9990675" genericHeader="method">
4 USING LOGICAL TERMS TO ENCODE SUBSUMPTION
RELATIONSHIPS
</sectionHeader>
<bodyText confidence="0.913890142857143">
The set of terms used in logic is partially ordered by the
relation (&amp;quot;at least as instantiated as&amp;quot;) where:
ti t2 iff
ti = t20 for some substitution 0
Thus for instance, the following statements are true:
Computational Linguistics Volume 14, Number 1, Winter 1988 43
C.S. Mellish Implementing Systemic Classification by Unification
</bodyText>
<equation confidence="0.973741333333333">
f(y,z) x
f(a,x) f(y,z)
f(f(x)) f(y)
</equation>
<bodyText confidence="0.998915066666667">
Just as we formed a lattice from descriptions, collapsing
together two descriptions that were logically equivalent,
so we can form a lattice from logical terms, collapsing
together terms which are &amp;quot;variants&amp;quot; (i.e., terms t1 and
t2 such that ti t2 and t2 ti). This lattice, with a
necessarily slightly altered version of defined on it
and with special &amp;quot;top&amp;quot; and &amp;quot;bottom&amp;quot; terms added, is
the lattice of Generalised Atomic Formulae (&amp;quot;GAF
lattice&amp;quot;) discussed by Reynolds (1970). In this lattice,
the greatest lower bound operation is unification Rob-
inson (1965), although for various sublattices the actual
operation may be simpler.
The main point of this paper is to investigate when a
structure-preserving mapping (1-1, 0-preserving meet
homomorphism) can be found from the description
lattice arising from a system network to the GAF lattice.
Where this is possible, we can use the mapping from
property names to logical terms to make terms that
correspond to conjunctive descriptions (by unification)
and to test subsumption (by testing &amp;quot;less instantiated
than&amp;quot;). Incompatibility of descriptions is also indicated
by unification failure.
We will initially illustrate the idea of encoding prop-
erties as logical terms by an example. Let us assume
that we are given the above system network for English
pronouns. We might come up with a mapping T from
properties mentioned in the network to logical terms
which includes the following assignments (variables
whose names are of no importance in the logical terms
are denoted here by the symbol &amp;quot;_&amp;quot;):
</bodyText>
<equation confidence="0.9999282">
T(animate) = pr(q(an),c(),no)
T(case) = pr(_,c0,_)
-r(far) = pr(d(far),no,n(_,_))
7(gender) = pr(p(3),c(_),n(s,_))
7(neuter) = pr(p(3),cU,n(s,n))
T(numb) = Prt_
r(personal) = pr(p(_),c(_),n(_,_))
7(reflexive) = pr(_,c(refl),_)
7(singular) = pr(_ ,_))
T(third) = Pr(P(3),c(J,11(_,J)
</equation>
<bodyText confidence="0.95714876">
This mapping is not purely random, but has been chosen
so that the logical relationship of subsumption is
&amp;quot;echoed&amp;quot; in the &amp;quot;degree of instantiation&amp;quot; of the terms.
So the idea of the mapping T is to have:
Pi subsumes p2 iff 7(P1) .(P2)
Thus, for instance, &amp;quot;gender&amp;quot; subsumes &amp;quot;neuter&amp;quot; and is
translated into a term which is almost identical, but
which is slightly less instantiated. The situation is
similar with &amp;quot;case&amp;quot; and &amp;quot;reflexive&amp;quot;. On the other
hand, the terms from &amp;quot;reflexive&amp;quot; and &amp;quot;third&amp;quot; do not
disagree on any non-variable component but neither is
more instantiated than the other. This reflects the fact
that the two properties are compatible but neither is
more general than the other. In the case of the terms
from &amp;quot;singular&amp;quot;, &amp;quot;third&amp;quot; and &amp;quot;gender&amp;quot;, the &amp;quot;gender&amp;quot;
term is the least instantiated term that is more instanti-
ated than each of the other two (it is the result of
unifying the other two). This reflects the fact that
&amp;quot;gender&amp;quot; is equivalent to the logical conjunction of
&amp;quot;third&amp;quot; and &amp;quot;singular&amp;quot;.
Figure 7 shows a portion of the GAF lattice whose
structure mirrors the part of the pronoun description
space shown in section 2. In the GAF lattice, one object
is below another if it is more instantiated (less free), and
the greatest lower bound is computed by unification. If
</bodyText>
<equation confidence="0.9570075">
pr(pCi.cU.K_._))
pr(p(3).cCialLki) Pr(PC).cU.n(s._))
Pr(1)(3)43.11(s._))
pr(p(3),c(j.n(s.n))
</equation>
<bodyText confidence="0.993170333333333">
we can find a mapping such as T, we can use operations
in the GAF lattice to solve problems in the original
description lattice. For instance, if we have an object
which is &amp;quot;neuter&amp;quot; we might be interested to see
whether it can also be &amp;quot;far&amp;quot;. This is not possible, and is
indicated by the fact that the two terms
</bodyText>
<equation confidence="0.708545">
pr(p(3),c(_),n(s,n)) (from &amp;quot;neuter&amp;quot;)
pr(d(far),no,n(_,_)) (from &amp;quot;far&amp;quot;)
</equation>
<bodyText confidence="0.9932588125">
do not unify (the conjunction is the &amp;quot;bottom&amp;quot;, or
&amp;quot;false&amp;quot; property). Similarly, we can establish that if an
object is &amp;quot;singular&amp;quot; and &amp;quot;far&amp;quot; then it cannot be &amp;quot;an-
imate&amp;quot;. For, unifying the terms for &amp;quot;singular&amp;quot; and
&amp;quot;far&amp;quot; we get:
pr(d(far) , no , n(s ,_))
which does not unify with the term for &amp;quot;animate&amp;quot;.
Using T, we can also verify that &amp;quot;reflexive&amp;gender&amp;quot;
definitely implies &amp;quot;personal&amp;quot;, that &amp;quot;singular&amp;quot; is com-
patible with &amp;quot;reflexive&amp;quot;, and so on. It is worth noting
that these inferences involving compatibility and prop-
erties that are not &amp;quot;maximally delicate&amp;quot; go beyond
those allowed by previous systems such as Patten (1986).
This seems to work well, but is there a principled
way to produce such mappings into the GAF lattice that
is guaranteed to yield correct results? For correctness,
</bodyText>
<page confidence="0.901291">
44 Computational Linguistics Volume 14, Number 1, Winter 1988
</page>
<note confidence="0.746727">
C.S. Mellish Implementing Systemic Classification by Unification
</note>
<bodyText confidence="0.6506605">
we need the following to be true for all possible prop-
erties Pi, , n
</bodyText>
<equation confidence="0.994824833333333">
2, • • • Pn+1 named in the system network:
Potx: p1(x) &amp; p2(x) &amp;. . .&amp; p„(x)
p01(x)
iff ,r(p,) II 7(p2) II . . n)
I 1= Vx: p1(x) &amp; p2(x) &amp;.. .&amp; p,,(x) = F
iff f7(PI)AP2) • • APO} is not unifiable
</equation>
<bodyText confidence="0.999568142857143">
where I is the set of logical axioms derived from the
network and II is unification (greatest lower bound in
the GAF lattice). A sufficient condition for this would
be for T to be a 1-1, 0-preserving meet-homomorphism
(Birkhoff (1963)).
In fact, the above mapping does not echo in the GAF
lattice the result:
</bodyText>
<equation confidence="0.991824">
V x: case(x) &amp; numb(x) D personal(x)
</equation>
<bodyText confidence="0.9957995">
and cannot be straightforwardly extended to do so. We
thus need to investigate under what conditions such
mappings exist and what algorithms might enable us to
discover them.
</bodyText>
<sectionHeader confidence="0.938217" genericHeader="method">
5 A &amp;quot;BRUTE FORCE&amp;quot; TRANSLATION
</sectionHeader>
<bodyText confidence="0.999868">
That such mappings always exist, and that inefficient
algorithms exist for discovering them, is demonstrated
by a more general result. If we have a finite set of
propositional symbols and an arbitrary set of axioms
mentioning these symbols then there is a method of
encoding those symbols as logical terms so that con-
junctions are computed by unification and subsumption
between conjunctive descriptions (relative to the axi-
oms) is reflected in &amp;quot;degree of instantiation&amp;quot;. We can
apply this result to the system networks domain be-
cause the logical axioms, although not strictly proposi-
tional, are equivalent to propositional axioms if we only
consider one object being described at a time.
The way to construct this encoding is to consider all
possible models of the axioms and the truth assignments
made to the symbols in them. In the case of the
pronouns network, there are 54 models of the corre-
sponding logical axioms. The following example shows
the truth assignments made by one of them (this corre-
sponds to the pronoun &amp;quot;he&amp;quot;).
</bodyText>
<equation confidence="0.634299857142857">
animate = F, case = T, demonstrative = F, far = F,
feminine = F, first = F, gender = T, inanimate = F,
masculine = T, near = F, neuter = F, numb = T.
objective = F, person = T, personal = T, plural = F,
possessive = F, possdet = F, pronoun = T, question = F,
reflexive = F, second = F. singular = T, subjective = T,
third = T
</equation>
<bodyText confidence="0.999922083333333">
If there are n possible models, each property is repre-
sented by a logical term of arity n + 1. Each such term
also has the same function symbol, the constant &amp;quot;0&amp;quot; as
its first argument and the constant &amp;quot;1&amp;quot; as its last
argument. The other arguments, for a given property,
are to be derived as follows. Each argument starts off as
a distinct variable, and then, for each model i which
assigns &amp;quot;F&amp;quot; to the property, the ith argument is unified
with the i + 1st argument. In a situation where there are
five possible models, the following example includes
some of the terms that might result (again we use &amp;quot;_&amp;quot;
for variables with uninteresting names).
</bodyText>
<equation confidence="0.989175">
1 2 3 4 5
I I I I I
</equation>
<bodyText confidence="0.9555887">
f(0, _, X, X, 1) (property excludes only model 4)
f(0, 0, _, X, X, 1) (property excludes models 1 and 4)
f(0, X, X, X, 1, 1) (property excludes models 2, 3, 5)
Each such term represents the models that the property
excludes by the instantiation of its arguments. When
two such terms are unified, the result is a term that
encodes exclusion of the union of the models excluded
by the terms individually. If the two terms together
exclude all possible models, the unification fails (this
occurs if we attempt to unify the last two of the above
terms). This is as desired, since excluding all models
amounts to incompatibility of descriptions. The tech-
nique used here, which amounts to encoding sets as
terms, was, we believe, first developed by Alain Col-
merauer in another context. In fact, we can make do
with only n arguments.
In general, given a set of n property symbols, there
can be as many as r different models, and so this
&amp;quot;brute force&amp;quot; approach is unattractive. In a situation
where there are very few models of the logical axioms,
however, the encoding scheme might be quite practical.
For instance, for the pronoun network the number of
models (54) is much smaller than the worst case for the
same number of properties (225). The theoretical maxi-
mum number of models is reduced by a factor of
roughly 2r/r for every &amp;quot;I&amp;quot; connective with r symbols on
its right appearing in the system network. Moreover,
the theoretical maximum is reduced by a factor of
roughly 2 for each property appearing on the right hand
side of a &amp;quot;{&amp;quot;. The encoding technique is analogous to
using bit strings to encode sets, the only advantage
being that a contradictory conjunction is flagged imme-
diately by a unification failure. On the other hand, the
terms make use of repeated variables, and so the
potential for exploiting parallelism in the unifications is
restricted.
System networks do not, however, correspond to
arbitrary sets of logical axioms. Only certain kinds of
axioms can come out of a system network (although a
useful characterisation eludes us). We might therefore
hope that, given the extra restrictions, there are better
encoding techniques available, in particular encoding
techniques that do not require the use of repeated
variables. We will therefore investigate whether struc-
ture-preserving mappings can be found from systemic
descriptions to elements of the lattice of generalised
atomic formulae without repeated variables, which we
call GAF°.
Computational Linguistics Volume 14, Number 1, Winter 1988 45
Implementing Systemic Classification by Unification
</bodyText>
<sectionHeader confidence="0.967472" genericHeader="method">
6 ENCODING FOR THE CONNECTIVES &amp;quot;I&amp;quot;, AND &amp;quot;{&amp;quot;
</sectionHeader>
<bodyText confidence="0.9610762">
If the only connective used in a system network is &amp;quot;I&amp;quot;,
a particularly simple encoding scheme is feasible. This
technique has been used in an ad hoc way in a number
of language processing systems written in Prolog, and
probably originates from Dahl (1977). Consider the
example network depicted in Figure 8, expressing the
top levels of classification normally used for the plant
kingdom. For such a simple network, we can use
vascular
function symbols more than one argument. Such a
system has been used by McCord (1986). Figure 9
depicts a version of the &amp;quot;verb&amp;quot; network used by
Winograd (1972), simplified to use only &amp;quot;I&amp;quot; and &amp;quot;{&amp;quot;.
One possible translation from the above property sym-
bols into terms includes the following:
</bodyText>
<equation confidence="0.990423333333333">
7(vb) = vb(_,_)
7(vprt) = vb(vprt,_)
T(aux) = vb(aux(_,_,),_)
</equation>
<figure confidence="0.941615769230769">
psilopsidan
sphenopsidan
lycopsidan
C.S. Mellish
plant
gymnospermal
angiospermal
pteropsidan
bacterial
fungal
algal
bryophyte
non_vascular
</figure>
<bodyText confidence="0.998886833333334">
nesting as a means of capturing the subsumption rela-
tionships in logical terms. Thus each property, apart
from properties at the &amp;quot;leaves&amp;quot; of the tree, is associated
with a unary function symbol, and the argument of a
function symbol is used for a more &amp;quot;fine grained&amp;quot;
description if that is available:
</bodyText>
<equation confidence="0.9994192">
r(plant) = plant()
T(vascular) = plant(vascular( _))
7(pteropsidan) = plant(vascular(pteropsidan(_)))
7(angiospermal) = plant(vascular(pteropsidan(angio-
spermal)))
</equation>
<bodyText confidence="0.9997605">
Where there are alternatives at a given level in the
classification, these are indicated simply by different
function symbols appearing in the relevant argument
positions. Thus, for instance:
</bodyText>
<equation confidence="0.99988825">
T(non_vascular) = plant(non_vascular(j)
T(sphenopsidan) = plant(vascular(sphenopsidan))
7(filicinal) = plant(vascular(pteropsidan(filicinal)))
T(fungal) = plant(non_vascular(fungal))
</equation>
<bodyText confidence="0.9990025">
If the &amp;quot;{&amp;quot; connective is also allowed in system net-
works, this means that a given property may have
refinements along several independent dimensions. In
the logical terms, this can be allowed for by giving the
</bodyText>
<equation confidence="0.999756">
T(neg) = vb(aux(neg,_,J,J
T(be) = vb(aux(_,_,be),_)
T(pres) = vb(_,pres)
</equation>
<bodyText confidence="0.999984181818182">
Notice how the &amp;quot;aux&amp;quot; function symbol has arity 3; this
corresponds to the three independent sub-classifica-
tions introduced by the &amp;quot;{&amp;quot; connective. Similarly, &amp;quot;vb&amp;quot;
has arity 2. The translation from symbols to terms is
again fairly straightforward.
Instead of going into detail about the relatively sim-
ple problems of dealing with system networks contain-
ing only &amp;quot;I&amp;quot; and &amp;quot;{&amp;quot; connectives, we shall concentrate
on an algorithm which also allows &amp;quot;}&amp;quot; connectives.
This algorithm was used in essence by Bundy et al.
(1982), although it has not been described before.
</bodyText>
<sectionHeader confidence="0.998787" genericHeader="method">
7 INTRODUCING 46}99
</sectionHeader>
<bodyText confidence="0.999923714285714">
In this section we describe a generalised translation
algorithm which associates elements of GAF() with
properties displayed in a system network. The algo-
rithm works for networks using the connectives &amp;quot;I&amp;quot;,
&amp;quot;{&amp;quot; and &amp;quot;}&amp;quot;, but does not handle networks that use
For this algorithm, we require in advance a function
A which associates with each node n of the system
</bodyText>
<page confidence="0.972729">
46 Computational Linguistics Volume 14, Number 1, Winter 1988
</page>
<note confidence="0.792519">
C.S. Mellish Implementing Systemic Classification by Unification
</note>
<bodyText confidence="0.955997922077922">
network (a possibly labeled location corresponding to
one or more &amp;quot;ends&amp;quot; of connectives) a function symbol
A (n). A is required to be 1-1, except that it should map
all the nodes appearing around a &amp;quot;{&amp;quot; connective to the
same function symbol. Such a function is easy to define
for a given network; for instance, most nodes can be
simply mapped to the names associated with them in the
network. The translation algorithm associates with each
node of the network a pair (C, P). The values for C and
P are:
C = a set of &amp;quot;constraints&amp;quot; describing the term
P = a &amp;quot;path&amp;quot; indicating a (possibly embedded) com-
ponent of the term which can become further instan-
tiated for terms representing properties subsumed
by the current property
A path is simply a sequence of alternating function
symbols and numbers, either empty or starting with a
function symbol, indicating a specific position in a term
and the function symbols that appear on the route from
the outside of the term to this position. A symbol in the
sequence indicates a function symbol that is present,
whereas a number selects one of the argument positions
of the last function symbol. For instance, in
f(a, g(X,h(b),i(d,ej(c))))
the symbol &amp;quot;c&amp;quot; appears at the place indicated by the
path (f,2,g,3,i,3,j, 1) and the symbol &amp;quot;b&amp;quot; at the place
indicated by (f,2,g,2,h,1). We will make use of two basic
types of extensions of a path P:
an extension of P to f, for some function symbol f:
If P is () then (f)
Otherwise if P is (pi, P29 • • i) for some
number i
then (pi, p2, . . . i,f)
Otherwise if P is (PO P2, • . s) for some
symbol s
then (pi, p2, . . . s,i,f) for some number i
an extension of P beyond f, for some function
symbol f:
If P is () then (f,i) for some number i
Otherwise if P is (pi, P2, • • • i) for some
number i
then (pi , p2, . . . i,f,j) for some number j
Otherwise if P is (pi, P2, • • • s) for some
symbol s
then (pi, p2, . . . s,i) for some number i
For instance, for the path (f,2,g), two possible exten-
sions to h are (f,2,g,33,h) and (f,2,g, 1 ,h). For the path
(f,l,g,2) two possible extensions beyond h are
(f,l,g,2,h,4) and (f, 1 ,g,2,h,6). Finally, we will have two
ways of describing paths that differ, according to the
type of the first component where they disagree:
PI and P2 are independent iff their first
disagreement is on a number
P1 and P2 are inconsistent if their first
disagreement is on a function symbol
Thus (f,2,g,3,h) is independent of (f,2,g,4,d,3), and
(f,2,g,5,a) is inconsistent with (f,2,h,4).
A constraint is a path used to specify that particular
function symbols must appear at particular places in a
term. A term is correctly described by a constraint if the
path makes sense (i.e., all the relevant components
exist) and the given function symbols do indeed appear
at the relevant places. A term is correctly described by
a set of constraints if it is correctly described by all of
them. Thus, for instance, the set of constraints:
{ (g, 1 ,f,2,a), (g, 1 ,f,3,b), (g, 1 ,f), (g)
correctly describes any of the terms:
g(f(z,a,b(c)),h(1))
g(f(w(x),a(d,f,g),b,x))
g(f(w(x),a(g),b),x)
The term that is the translation of a node in a system
network is obtained from the set of constraints as
follows. First of all, each function symbol (element of
the range of A) is taken to have the same arity (number
of arguments) in all the terms derived from the network.
This is the minimal arity such that all the constraints
attached to all the nodes are satisfiable. Secondly, with
</bodyText>
<figure confidence="0.9801914">
aux
vb
neg
Pos
qaux
no_qaux
be
do
have
will
modal
vPrt
no_vprt
pres
Past
ing
en
inf
Computational Linguistics Volume 14, Number 1, Winter 1988 47
C.S. Mellish Implementing Systemic Classification by Unification
</figure>
<bodyText confidence="0.978028">
arities fixed in this way, the translation of a property is
the most general (least instantiated) term that is cor-
rectly described by the constraints at the property&apos;s
node. Thus, for example, if the arities of a, b, f and g
were 1, 0, 3 and 2 respectively (note that the arity off
must be at least 3), the following term would be the
&amp;quot;solution&amp;quot; of the above set of constraints:
g(f(_, a(_) ,b) ,_)
The following defines a space of possible translation
algorithms. For each place where alternatives are al-
lowed, it does not matter which the algorithm specifies.
</bodyText>
<listItem confidence="0.983839833333333">
(1) Record ({(f)},(f)) as the value for the leftmost
node, where f is the value of A for that node
(2) Until there is no connective all of whose left nodes
have translations but none of whose right nodes
do, do the following:
(2.1) Select one such connective
</listItem>
<bodyText confidence="0.920481">
(2.2) If the connective is &amp;quot;I&amp;quot; and the left hand node has
translation (C,P), assign to the ith node ni on the
right hand side the translation:
</bodyText>
<equation confidence="0.517236">
(C u Pi)
</equation>
<bodyText confidence="0.984983166666667">
where, for each i, p, is an extension of P to A (ni),
and where pi is inconsistent with pi if i # j.
If the connective is &amp;quot;{&amp;quot; and the left hand node L
has translation (C, P), assign to the ith node on the
right hand side the translation:
(C, Pi)
where, for each i, p1 is an extension of P beyond A
(L) and where pi and pi are independent if i I.
If the connective is &amp;quot;}&amp;quot; and the two left hand
nodes have translations (C1, P1) and (C2, P2),
assign to the node on the right hand side the
translation:
</bodyText>
<equation confidence="0.546152">
(C1 U C2, Pi)
with either i = 1 or i = 2.
</equation>
<bodyText confidence="0.997617307692308">
The basic idea is that as one goes to the right in the
network, the constraints on a node are the constraints
on the nodes to its immediate left, together with possi-
bly extra constraints to differentiate it from them (if
they properly subsume it). At each point, the path
component of a node&apos;s translation indicates where
nodes further to the right can be further instantiated. If
the connective is &amp;quot;I&amp;quot;, the extra constraints added for
each node on the right amount to forcing the place
indicated by the path to have the function symbol
associated with that node. Since the paths used for the
right hand nodes are inconsistent, the terms generated
for the nodes will be incompatible. If the connective is
&amp;quot;{&amp;quot;, the nodes on the right hand side must have the
same constraints as the node on the left. On the other
hand, each is given a different, slightly longer, path so
that the term can be further instantiated in several
independent ways.
The above algorithm, although not optimal in the
sense of generating the smallest possible terms, is the
basis of one that has generated correct results in prac-
tice. In addition, we have a proof of correctness for it.
The proof hinges on the reduction of the correctness
criterion given in section 4 to the following simpler one.
The translation Tis correct if for all properties pi, 132 and
p3 named in the network:
</bodyText>
<equation confidence="0.975754">
V x: pi(x) D p2(x)
iff API) s T(P2)
11= V x: pi(x) D p2(x)
if I1= p2 = p4&amp;p5 for some p4,p5 in the network
with p2, p4 and p5 all logically distinct
or A(P2) appears in i(p1)
x: pi(x) &amp; p2(x) = F
iff {T(p1)7(p2)1 is not unifiable
V x: pi(x) &amp; p2(x) = p3(x)
if API) II T(P2) = T(P3)
</equation>
<bodyText confidence="0.993825054054054">
for some function A is introduced above. The reduction
can be made because of various special properties that
hold of system networks that only use &amp;quot;I&amp;quot;, &amp;quot;1&amp;quot; and
If I 1= V x: pi(x) = p2(x)&amp;p3(x), for properties pi,
P2 and p3 mentioned in the network and logically
distinct, then pi is equivalent to a property on the
right hand side of a &amp;quot;1&amp;quot; connective, and p2 and p3
are equivalent to the properties appearing on the
left hand side.
If I V x: p1(x)&amp;p2(x)&amp;. . .p,z(x) D p(x), for
properties pi , . . . pn, p mentioned in the network,
then either 1 1= V x: pi(x) D p(x) for some i, or p
is equivalent to a property appearing on the right of
a
If P is a set of properties mentioned in the network
and for every &amp;quot;I&amp;quot; connective either no elements of
P lie to the right of that connective or all elements
lie to the right of the same right hand branch, then
the set P is compatible.
None of the schemes in this section or the previous
section require repeated variables in the logical terms,
and so there is nothing to prevent unification tackling
different components in parallel. Of course, if one had a
great deal of parallelism available, one could use it to
implement a naive network searcher for testing compat-
ibility of two properties (e.g., by searching for the
rightmost node that appears to the left of both and
seeing whether the connective at that point is &amp;quot;I&amp;quot;. The
implementation via unification would then be unneces-
sary (at least for simple cases). Thus to a certain extent
the &amp;quot;compilation&amp;quot; of tasks like compatibility- and sub-
sumption-checking into unification tasks can be viewed
as a special case of compiling OR-parallel programs into
AND-parallel programs (Codish and Shapiro (1986),
Ueda (1986)). The checking can be even faster if the
unifications are further compiled (Warren (1977)). For
instance, in the verb network, checking that a descrip-
</bodyText>
<page confidence="0.89501">
48 Computational Linguistics Volume 14, Number 1, Winter 1988
</page>
<note confidence="0.829686">
C.S. Mellish Implementing Systemic Classification by Unification
</note>
<bodyText confidence="0.999762">
tion of a verb is compatible with &amp;quot;pres&amp;quot; simply amounts
to seeing whether the third component of the term is not
a function symbol different from &amp;quot;pres&amp;quot;.
</bodyText>
<sectionHeader confidence="0.827392" genericHeader="method">
8 INTRODUCING 4 99
</sectionHeader>
<bodyText confidence="0.999967142857143">
We have intentionally left consideration of the &amp;quot;1&amp;quot;
connective to its own section. This is because we have
no general algorithm (apart from the above &amp;quot;brute
force&amp;quot; algorithm) for translating system networks with
&amp;quot;1&amp;quot; connectives into logical terms in a way that will
correctly mirror the subsumption relationships. Indeed,
there is no reason to believe that there are straightfor-
ward algorithms for this.
First of all, we can easily demonstrate through an
example that networks containing &amp;quot;1&amp;quot;s cannot be im-
plemented using only GAF°. Thus, something like the
full power of unification is necessary, rather than the
simple subcases we have considered up to now. Con-
sider the system network depicted in Figure 10. The
</bodyText>
<sectionHeader confidence="0.450824" genericHeader="method">
entity
</sectionHeader>
<bodyText confidence="0.96527605">
b2
subsumption relationships between properties and con-
junctions of properties are shown in Figure 11. This
entity
that we need for an IDR application, but it means that,
although we can read off from the diagram information
about greatest lower bounds, we cannot obtain from it
information about least upper bounds. Now ai&amp;c and
b1&amp;a2 are incompatible, i.e., their greatest lower bound
is &amp;quot;F&amp;quot;. Therefore the terms representing these two
descriptions cannot unify. If we are not allowing terms
with repeated variables, the only way that two terms
can fail to unify is by there being some component
where the twQ terms take on different non-variable
values. Let ai&amp;c take the value &amp;quot;y&amp;quot; in this component
and b1&amp;a2 take the value &amp;quot;n&amp;quot; (we do not have to
assume that &amp;quot;y&amp;quot; and &amp;quot;n&amp;quot; are atomic, merely that their
&amp;quot;top level&amp;quot; function symbols are different). We can
then make various inferences about what other terms
should have in this component:
</bodyText>
<equation confidence="0.241429166666667">
al&amp;c —y (hypothesis)
b,&amp;a2 —n (hypothesis)
b, since it is above a,&amp;c and b1&amp;a2
since it is above b1
a2 —n so as to make b1&amp;a2 when unified with bl
b2&amp;a2 —n since it is below a2
</equation>
<bodyText confidence="0.961381266666667">
a, —y so to make al&amp;c when unified with c
a,&amp;b2 —y since it is below al
b2 since it is above b2&amp;a2 and a1&amp;b2
Now b2&amp;a2, as well as being the greatest lower bound
of b2 and a2, is also the greatest lower bound of b2 and
c. However, unifying the terms for b2 and c, the above
specifies that the particular component will have the
value &amp;quot;_&amp;quot;. This conflicts with the value already inferred
for b2&amp;a2 —&amp;quot;n&amp;quot;. Therefore, under the constraint of
avoiding repeated variables, it is not possible to produce
a valid mapping from descriptions to terms.
Figure 12 shows the subsumption relationships again,
with the descriptions substituted by logical terms ob-
tained by the &amp;quot;brute force&amp;quot; method. Of course, re-
peated variables have to be used several times.
</bodyText>
<figure confidence="0.977539">
al
a2
al b2
a ittb2 biaca2 b284,22
f(0.0.R.X.1)
f(0.0.0.0.1) f(0.0.0.1.1) f(0.0.1.1.1)
</figure>
<bodyText confidence="0.959599966666667">
diagram must be read with some care, as we have only
shown the elements of the meet-semilattice consisting
of the data elements and their conjunctions. This is all
It is natural to ask what it is about descriptions
arising from networks with &amp;quot;1&amp;quot; that cannot be modelled
Computational Linguistics Volume 14, Number 1, Winter 1988 49
C.S. Mellish Implementing Systemic Classification by Unification
in GAF°. There is at least one property of GAF() (and
any sub-semilattice of it that contains the bottom ele-
ment) which is not echoed in description spaces like our
examples. Since descriptions from &amp;quot;1&amp;quot; networks can
violate this property, it follows that GAF° cannot be
used accurately to model the description spaces. The
particular property is that compatibility is pairwise
determined:
For all sets of elements {t1, t2, . . . tn}
{to t2, . . . tn} compatible
iff ti is compatible with ti for each i, j.
(we say that a set of objects is compatible if their
greatest lower bound is not the &amp;quot;bottom&amp;quot; element). In
our example description space, the set {al, b2, c} is not
compatible, and yet each pair of elements taken from it
is compatible. Thus compatibility is not determined
pairwise in the description space.
It seems unlikely in this example that one could come
up with an encoding in the full GAF that would improve
on the &amp;quot;brute force&amp;quot; approach. Indeed, this may often
be the case, as networks containing &amp;quot;]&amp;quot;s are very
complex to process. Consider, for instance, Figure 13
which is an extension to the above network.
</bodyText>
<figure confidence="0.968982857142857">
al
a2
•••
entity am
b
b2
•••
</figure>
<bodyText confidence="0.995772444444444">
In choosing logical terms for a1, a2, . .am, b1, b2,
. .b„, one has to reflect the fact that
c &amp; ai implies b1 (i = 1. .m-1)
c implies am (i = 2. .n)
bi Si c is contradictory (i = 1. .m-1, j = 2. .n)
This certainly prevents the sub-classifications repre-
sented by the &amp;quot;a&amp;quot;s and the &amp;quot;b&amp;quot;s from being translated
independently, in the way that could be done in our
portion of Winograd&apos;s verb network.
</bodyText>
<sectionHeader confidence="0.999094" genericHeader="related work">
9 RELATED WORK
</sectionHeader>
<bodyText confidence="0.997997870370371">
A piece of work that is closely related in many ways is
Kasper&apos;s work (Kasper (1986)) on translating Systemic
Grammars into functional unification grammars. Kasper
describes a way of mapping a system network and
feature choices into a functional description of FUG
(Kay (1984)). Such a mapping induces a mapping from
systemic descriptions to functional descriptions in such
a way that conjunction of descriptions is computed by
(functional) unification of the functional descriptions.
Kasper&apos;s work represents an extension of ours in that it
treats more than the systemic choices of a Systemic
Grammar, and we are currently investigating how our
framework can best be extended to deal with these
other aspects. Unfortunately, the functional description
that Kasper builds for anything but a complete (maxi-
mally specific) systemic description will contain dis-
junctions, and the complexity of functional unification
is seriously affected by the presence of disjunctions.
Moreover, Kasper actually needs to extend the notion
of functional description in order to produce transla-
tions for networks with complex entry conditions. Since
logical unification corresponds closely to functional
unification when there are no disjunctive descriptions or
ordering patterns, our methods can be viewed as tech-
niques for mapping systemic descriptions into disjunc-
tion-free, conventional functional descriptions.
Whereas Kasper&apos;s primary aim is for a mapping be-
tween a systemic Grammar and a Functional Unifica-
tion Grammar (with a mapping between individual
descriptions induced by this), in our case there is only a
description mapping. It is hard to believe that a unifi-
cation grammar allowing exactly those functional de-
scriptions corresponding to the terms generated by our
&amp;quot;brute force&amp;quot; method would be of much interest.
Another related piece of work is that of Gazdar et al.,
(forthcoming), which seeks to produce a uniform for-
malism for describing legal categories in grammatical
formalisms. In the case of Systemic Grammar, a &amp;quot;cat-
egory&amp;quot; is a set of feature specifications. The work of
Gazdar and his colleagues envisages an implementation
of category conjunction by a kind of unification which is
similar to logical unification, except that there are no
repeated variables. As with Kasper&apos;s work, the ap-
proach is to provide a translation for the grammar of
legal descriptions. In this case, however, one product of
the translation is a set of global constraints on legal
descriptions. Unfortunately, unification does not pre-
serve the validity of these constraints and is not there-
fore a correct implementation of greatest lower bound in
the subsumption lattice. Our approach can be roughly
characterised as an attempt to find alternative transla-
tions where unification is correct because the global
constraints have been &amp;quot;built in&amp;quot;. To do this, unfortu-
nately, we need to allow repeated variables.
</bodyText>
<sectionHeader confidence="0.996938" genericHeader="acknowledgments">
ACKNOWLEDGEMENTS
</sectionHeader>
<bodyText confidence="0.990994">
This work was carried out as part of a project on natural
language generation financed by SERC grant GR/D/
</bodyText>
<page confidence="0.757251">
50 Computational Linguistics Volume 14, Number 1, Winter 1988
</page>
<reference confidence="0.961685791044776">
C.S. Mellish Implementing Systemic Classification by Unification
08876. I am currently supported by an SERC Advanced
Fellowship.
REFERENCES
Birkhoff, Garrett. 1963 Lattice Theory. American Mathematical So-
ciety.
Bundy, Alan; Byrd, Lawrence and Mellish, Chris. 1982 Special
Purpose, but Domain Independent, Inference Mechanisms. In
Steels, Luc and Campbell, John, Eds., Progress in Artificial
Intelligence. John Wiley, Chichester, UK: 93-111.
Buntine, Wray. 1986 Generalised Subsumption and its Applications to
Induction and Redundancy. In Steels, Luc and DuBoulay, Ben,
Eds., Procs of the Seventh European Conference on Artificial
Intelligence. Brighton, 1986.
Codish, Michael and Shapiro, Ehud. 1986 Compiling OR-Parallelism
into AND-Parallelism. In Shapiro, Ehud, Ed., Procs of the Third
International Conference on Logic Programming. Springer Ver-
lag.
Dahl, Veronica. 1977 Un Systeme Deductif d&apos;Interrogation de Ban-
ques de Donnes en Espagnol. PhD dissertation, Groupe d&apos;Intelli-
gence Artificielle, University of Marseille-Luminy.
Gazdar, Gerald; Klein, Ewan; Pullum, Geoffrey and Sag, Ivan. 1985
Generalised Phrase Structure Grammar. Blackwell.
Gazdar, Gerald; Pullum, Geoffrey; Carpenter, Robert; Klein, Ewan;
Hukari, Thomas and Levine, Robert. (to appear) Category Struc-
tures. Computational Linguistics.
Hudson, Richard A. 1971 English Complex Sentences: An Introduc-
tion to Systemic Grammar. North Holland.
Kasper, Robert. 1986 Systemic Grammar and Functional Unification
Grammar. In Benson, J. and Greaves, W., Eds., Selected papers
from the Twelfth International Systemics Workshop. Ablex, Nor-
wood, NJ, USA.
Kay, Martin. 1984 Functional Unification Grammar: A Formalism for
Machine Translation. In Procs of COLING-84. Stanford, July
1984.
Kress, Gunther, Ed. 1976 Halliday: System and Function in Lan-
guage. Oxford University Press.
McCord, Michael C. 1986 Design of a Prolog-based Machine Trans-
lation System. In Shapiro, Ehud, Ed., Procs of the Third Interna-
tional Conference on Logic Programming. Springer Verlag.
Mellish, Chris S. (forthcoming) Version Spaces, Description Spaces
and Unification. Research paper, Dept of Artificial Intelligence,
University of Edinburgh.
Patten, Terry A. 1986 Interpreting Systemic Grammar as a Computa-
tional Representation: A Problem Solving Approach to Text
Generation. PhD thesis, University of Edinburgh.
Reynolds, John C. 1970 Transformational Systems and the Algebraic
Structure of Atomic Formulas. In Meltzer, Bernard and Michie,
Donald, Eds., Machine Intelligence 5. Edinburgh University
Press.
Robinson, J. Alan. 1965 A Machine-Oriented Logic Based on the
Resolution Principle. JACM 12, 23-41.
Ueda, Kazunori. 1986 Making Exhaustive Search Programs Deter-
ministic. In Shapiro, Ehud, Ed., Procs of the Third International
Conference on Logic Programming. Springer Verlag.
Warren, David H. D. 1977 Implementing Prolog: Compiling Predicate
Logic Programs: Research Reports 39 and 40, Department of
Artificial Intelligence, University of Edinburgh.
Winograd, Terry. 1972 Understanding Natural Language. Academic
Press.
Winograd, Terry. 1983 Language as a Cognitive Process. Volume 1:
Syntax. Addison Wesley.
NOTES
1. Author&apos;s current address: Department of Artificial Intelligence,
University of Edinburgh, 80 South Bridge, EDINBURGH EH1
1HN, Scotland.
Computational Linguistics Volume 14, Number 1, Winter 1988 51
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.000004">
<title confidence="0.99888">IMPLEMENTING SYSTEMIC CLASSIFICATION BY UNIFICATION</title>
<author confidence="0.999592">C S Mellish</author>
<affiliation confidence="0.783642">of Cognitive Sciences, University Sussex&apos;</affiliation>
<abstract confidence="0.995746833673473">The &amp;quot;system networks&amp;quot; of Systemic Grammar provide a notation for declaring how combinations of properties may imply or be inconsistent with other combinations. Partial information about a linguistic entity can be recorded as a set of known properties, and a system network then enables one to infer which other properties follow from this and which other properties are incompatible with this. The possible descriptions allowed by a system network are partially ordered by the of a description subany description that is more specific than given the background constraints declared by the network. Given this partial ordering, the set of descriptions can be seen as forming a lattice with least upper bound and greatest lower bound operations. In a class of applications (such as parsing and generation) that redescription refinement, are only really interested in forming new conjunctions (greatest lower bounds) and testing subsumption relationships. If one factors out the complexity of variable renaming and introduces special top and bottom elements, the set of logical terms also forms a lattice (the lattice of Generalised Atomic Formulae —&amp;quot;GAF lattice&amp;quot;) under the partial ordering relation &amp;quot;is equally or more instantiated than&amp;quot; (Reynolds (1970)). In this lattice, the greatest lower bound operation is unification (Robinson Unification primitive operation in most logic programming systems and is also the basis of various grammatical formalisms. It is therefore a relatively well understood operation and can be efficiently implemented. In this paper, we investigate to what extent it is possible to find structure-preserving mappings from the spaces defined by system networks sublattices of the GAF lattice. Where this is possible, we can use a fixed mapping from property names to logical terms to create terms that represent conjunctive descriptions (by unification) and to test subsumption (by testing &amp;quot;less instantiated than&amp;quot;). Incompatibility of descriptions is also indicated by unification failure. There are a number of reasons why it is interesting to investigate these possibilities: (1) They may result in more efficient or flexible ways of using system networks for inferencing. (2) They may enable language analysers or generators which involve unification for other reasons (e.g., analysers for GPSG (Gazdar et al. (1985)) or Functional Unification Grammar (Kay (1984)) to build in feature co-occurrence tests using the same mechanism. (3) They may enable us to make formal sense of various ad-hoc mechanisms used by logic programmers in natural language processing. (4) By exposing the nature of the relevant description spaces, they may open various possibilities for the implementation of other classification tasks, e.g., concept learning (Mellish forthcoming). (5) They may give us more insight into the semantics of system networks and the potential of unification. 1 HALLIDAY&apos;S SYSTEM NETWORKS System networks, as used in Halliday&apos;s Systemic Grammar (Hudson (1971), Kress (1976), Winograd (1983)) are a way of encoding the choices that must be made in the generation of a complex linguistic object and the interdependencies between them. There is actually nothing that makes such networks specific to linguistic applications, and so there is no reason why they cannot be applied to describing the choices involved in other complex situations. A system network can be viewed as a graph, some of whose nodes are annotated with symbols representing properties. The nodes are tied together by the use of four different &amp;quot;connectives&amp;quot;, which we shall designate &amp;quot;I&amp;quot;, &amp;quot;{&amp;quot;, &amp;quot;}&amp;quot; and &amp;quot;1&amp;quot;. In order precise about by the Association for Computational Linguistics. Permission to copy without fee all or part of this material is granted provided the copies are not made for direct commercial advantage and the and this copyright notice are included on the first page. To otherwise, or to republish, requires a specific permission. 0362-613X/ 88 /010040-51$03.00 Computational Volume 14, Number 1, Winter 1988 C.S. Mellish Implementing Systemic Classification by Unification exactly what system networks mean, we will present a logical interpretation, where each appearance of a &amp;quot;connective&amp;quot; in a network gives rise to a set of logical axioms relating the property symbols (interpreted as unary predicates) appearing with it. A fundamental concept in system networks is that of the choice system. A choice system indicates that, if a certain &amp;quot;entry condition&amp;quot; holds, then the object described must have exactly one of the properties mentioned in the system. Choice systems are denoted by use of the &amp;quot;I&amp;quot; &amp;quot;connective&amp;quot;. Thus, Figure 1 indicates that masculine, feminine and neuter are mutually exclusive and whenever an object has a gender it has one of these. In logic, AMO {feminine(x) masculine(x) neuter(x)} gender(x) feminine(x) v masculine(x) v neuter(x) where AMO (&amp;quot;at most one of&apos;) is defined by: S == /X\ &amp; E S Incidentally, an alternative reading that might suggest itself, namely: gender(x) (AMO {feminine(x) neuter(x)} &amp; feminine(x) v masculine(x) v neuter(x)) is not adequate, because it allows spurious models, for instance where there is an object &amp;quot;a&amp;quot; which satisfies &amp;quot;feminine(a)&amp;quot; and &amp;quot;masculine(a)&amp;quot; but not &amp;quot;gender (a)&amp;quot;. Sometimes more than one choice will be relevant, given the same entry conditions. This is indicated by the &amp;quot;{&amp;quot; &amp;quot;connective&amp;quot;. For instance, as indicated in Figure 2, in some languages a noun may be either singular or plural, and also either masculine or feminine. Instances of the &amp;quot;{&amp;quot; connective can be translated into logic by simply treating the entry condition of the &amp;quot;{&amp;quot; as that of all the networks introduced on the right hand side. Thus: AMO {feminine(x) masculine(x)1 noun(x) feminine(x) v masculine(x) AMO {singular(x) plural(x)} Vx: noun(x) singular(x) v plural(x) The final two connectives concern complex entry conditions into networks. A conjunctive entry condition is denoted by &amp;quot;1&amp;quot;, as shown in Figure 3. This means third sing simply: third(x) &amp; sing(x) gender(x) Finally, &amp;quot;1&amp;quot; introduces a disjunctive entry condition, so that the example provided in Figure 4 personal demonstr means: personal(x) v demonstr(x) number(x) By convention, uses of the four &amp;quot;connectives&amp;quot; can be connected together in any way, as long as &amp;quot;loops&amp;quot; are not created. That is, if one regards each connective as a set of arcs going from properties on its &amp;quot;left&amp;quot; to properties on its &amp;quot;right&amp;quot;, the resulting directed graph must be acyclic. As a larger example, Figure 5 depicts the system network for English pronouns presented in Winograd (1983)). Here is a logical translation of selected parts. AMO {first(x) second(x) third(x)} V x: person(x) first(x) v second(x) v third(x) AMO {singular(x) plural(x)} numb(x) singular(x) v plural(x) third(x) &amp; singular(x) gender(x) It is important to note that in this paper we consider system networks as a self-contained notation for describing certain types of choices (&amp;quot;systemic choices&amp;quot;) that are available in the construction of a complex (linguistic) object. We will be completely ignoring the philosophical differences between Systemic Grammar and other forms of generative grammar, and we will also completely ignore the other components that are required in a full Systemic Grammar, such as realisation rules. gender masculine feminine neuter masculine feminine noun singular plural gender number Computational Linguistics Volume 14, Number 1, Winter 1988 41 C.S. Mellish Implementing Systemic Classification by Unification animate inanimate subjective objective reflexive possessive possdet question personal person first second third gender feminine masculine numb singular neuter plural demonstrativ near far 2 SUBSUMPTION AND THE LATTICE OF DESCRIPTIONS The property symbols in a system network provide a basic vocabulary out of which descriptions can be built. The most obvious way to produce more complex descriptions is by conjunction and disjunction. The logical interpretation of such complex descriptions is straightforward, and we will often blur the distinction between a description and its interpretation. Thus: masculine &amp; singular corresponds to Ax. masculine(x) &amp; singular(x) masculine v feminine corresponds to Ax. masculine(x) v feminine(x) A fundamental relationship between descriptions is subsumption: subsumes if 1= where is the set of axioms derived from the network. Note that our notion of subsumption depends vitally on 1. This is a special case of what Buntine (1986) calls subsumption&amp;quot;. Intuitively subsumes the axioms 1, is a more general description is, if describes all the objects accurately by and maybe more. Subsumption is a partial ordering on descriptions, and the set of possible (properties and all possible conjunctions and disjunctions of descriptions made from them), ordered by subsumption, forms a lattice. In this lattice, the least upper bound of two descriptions is their disjunction and the greatest lower bound is their conjunction. Figure 6 is a picture of a portion of the lattice consisting of the descriptions derived from the pronoun network. In the picture, if there is a line going upwards description to description then subsumes descriptions that are logically equivalent (e.g., &amp;quot;personal&amp;singular&amp;quot; is the same as &amp;quot;singular&amp;case&amp;quot;) give rise to a single node in the diagram (technically, we are interested in the quotient lattice of the free lattice generated by the property symbols, with respect to the congruence relation defined by 1,). To find the node for the conjunction of two descriptions, one finds the highest node that is &amp;quot;below&amp;quot; both, i.e., the greatest lower bound. Similarly, to find the node for the disjunction of two descriptions, one finds the lowest node which is &amp;quot;above&amp;quot; both. 3 INCREMENTAL DESCRIPTION REFINEMENT The previous two sections introduced a simple language of descriptions and the use of system networks to express extra background information about (constraints on) the terms appearing in those descriptions. A of subsumption defined which allowed this Linguistics Volume 14, Number 1, Winter 1988 C.S. Mellish Implementing Systemic Classification by Unification personal singular thirdpersonal &amp; singular gender neuter background information to be taken into account. But what are the operations that we need to carry out on descriptions in practical natural language processing systems, and does the structure we have described support these? In this paper, we will concentrate especially on a process that seems to arise in a number of contexts in language processing—incremental description refinement (IDR) place when, a description gradually being built of some individual, and information about this individual appears as a sequence of self-contained, descriptions. instance, the target could be the description of an English sentence and the data descriptions partial descriptions of this sentence like: the sentence is passive the sentence is declarative the agent of the sentence is the speaker any point in an the information that has accumulated so far may allow certain properties of the individual to be inferred, and so one would like to be able to interrogate the partial description that has been built. In particular, one would like to be able to answer questions about which descriptions are compatible and incompatible with the target description. To build an one must have a way to represent the conjunction of an arbitrary set of pieces of information so that inconsistency and subsumption relationships with other descriptions can be easily detected. The term &amp;quot;incremental description refinement&amp;quot; was, we believe, originally coined by Bobrow and Webber (1980), but the notion of incrementally building descriptions has been influential in a number of AI projects. natural language processing, relevant to both natural language parsing and generation. In parsing, it is natural to accumulate information about the structure of a phrase gradually as words are read. For instance, in the sentence sheep was. . . we know after reading the first three words that the gender of the subject noun phrase is &amp;quot;neuter&amp;quot; and after the next word we know that the number of that phrase is &amp;quot;singular&amp;quot;. It is important in parsing that we be able to accumulate pieces of information of this kind and detect inconsistencies if they arise. In generation, it is natural to want to allow different semantic and pragmatic factors to provide separate constraints on a sentence to be generated. For instance, one pragmatic goal may force a sentence to be passive; another forces it to have a given surface subject. This conjunction of constraints may be inconsistent with certain choices of the main verb (e.g., &amp;quot;buy&amp;quot; vs. &amp;quot;sell&amp;quot;). Again there is a need to reason about partial descriptions that are built incrementally. formal terms, the operations involved in simple. At any point, the information known about the target description can be represented without loss by a single &amp;quot;partial description—the least upper bound of all the descriptions the target could be. Initially this is simply the most general description of all (&amp;quot;true&amp;quot;). When a new data description appears, the partial description is replaced by the greatest lower bound of it the data description. This &amp;quot;algorithm&amp;quot; for in fact a special case of a more general classification algorithm given in Mellish (forthcoming). At any point, a contradiction is signaled by the partial description becoming the most specific description of all (&amp;quot;false&amp;quot;). Moreover, one can validly infer that the target is subsumed by a given description if the partial description is. The only operations that we need for IDR are subsumption checking and the computation of greatest lower bounds. This means that, in fact, we do not need the full lattice structure developed above—all we need is the meet semi-lattice (Birkhoff (1963)) that contains the possible data descriptions and all possible conjunctions of them. The above description of IDR is not dependent on descriptions being related to system networks, and been used in quite different contexts. In this paper, however, we will confine ourselves to this and consider the data descriptions are precisely the properties mentioned in a system network. We are thus concerned with ways of computing and testing subsumption between conjunctions of properties, given the background information provided by the network axioms. 4 USING LOGICAL TERMS TO ENCODE RELATIONSHIPS The set of terms used in logic is partially ordered by the relation (&amp;quot;at least as instantiated as&amp;quot;) where: iff = some substitution Thus for instance, the following statements are true: Computational Linguistics Volume 14, Number 1, Winter 1988 43 C.S. Mellish Implementing Systemic Classification by Unification f(y,z) x f(a,x) f(y,z) f(f(x)) f(y) Just as we formed a lattice from descriptions, collapsing together two descriptions that were logically equivalent, so we can form a lattice from logical terms, collapsing terms which are &amp;quot;variants&amp;quot; (i.e., terms and such that and This lattice, with a necessarily slightly altered version of defined on and with special &amp;quot;top&amp;quot; and &amp;quot;bottom&amp;quot; terms added, is the lattice of Generalised Atomic Formulae (&amp;quot;GAF lattice&amp;quot;) discussed by Reynolds (1970). In this lattice, the greatest lower bound operation is unification Robinson (1965), although for various sublattices the actual operation may be simpler. The main point of this paper is to investigate when a structure-preserving mapping (1-1, 0-preserving meet homomorphism) can be found from the description lattice arising from a system network to the GAF lattice. Where this is possible, we can use the mapping from property names to logical terms to make terms that correspond to conjunctive descriptions (by unification) and to test subsumption (by testing &amp;quot;less instantiated than&amp;quot;). Incompatibility of descriptions is also indicated by unification failure. We will initially illustrate the idea of encoding properties as logical terms by an example. Let us assume that we are given the above system network for English We might come up with a mapping properties mentioned in the network to logical terms which includes the following assignments (variables whose names are of no importance in the logical terms are denoted here by the symbol &amp;quot;_&amp;quot;): T(animate) = pr(q(an),c(),no) T(case) = pr(_,c0,_) -r(far) = pr(d(far),no,n(_,_)) 7(gender) = pr(p(3),c(_),n(s,_)) 7(neuter) = pr(p(3),cU,n(s,n)) T(numb) = Prt_ r(personal) = pr(p(_),c(_),n(_,_)) 7(reflexive) = pr(_,c(refl),_) 7(singular) = pr(_ ,_)) T(third) = Pr(P(3),c(J,11(_,J) This mapping is not purely random, but has been chosen so that the logical relationship of subsumption is &amp;quot;echoed&amp;quot; in the &amp;quot;degree of instantiation&amp;quot; of the terms. the idea of the mapping to have: subsumes iff Thus, for instance, &amp;quot;gender&amp;quot; subsumes &amp;quot;neuter&amp;quot; and is translated into a term which is almost identical, but which is slightly less instantiated. The situation is similar with &amp;quot;case&amp;quot; and &amp;quot;reflexive&amp;quot;. On the other hand, the terms from &amp;quot;reflexive&amp;quot; and &amp;quot;third&amp;quot; do not disagree on any non-variable component but neither is more instantiated than the other. This reflects the fact that the two properties are compatible but neither is more general than the other. In the case of the terms from &amp;quot;singular&amp;quot;, &amp;quot;third&amp;quot; and &amp;quot;gender&amp;quot;, the &amp;quot;gender&amp;quot; term is the least instantiated term that is more instantiated than each of the other two (it is the result of unifying the other two). This reflects the fact that &amp;quot;gender&amp;quot; is equivalent to the logical conjunction of &amp;quot;third&amp;quot; and &amp;quot;singular&amp;quot;. Figure 7 shows a portion of the GAF lattice whose structure mirrors the part of the pronoun description space shown in section 2. In the GAF lattice, one object is below another if it is more instantiated (less free), and the greatest lower bound is computed by unification. If pr(p(3),c(j.n(s.n)) can find a mapping such as can use operations in the GAF lattice to solve problems in the original description lattice. For instance, if we have an object which is &amp;quot;neuter&amp;quot; we might be interested to see whether it can also be &amp;quot;far&amp;quot;. This is not possible, and is indicated by the fact that the two terms pr(p(3),c(_),n(s,n)) (from &amp;quot;neuter&amp;quot;) pr(d(far),no,n(_,_)) (from &amp;quot;far&amp;quot;) do not unify (the conjunction is the &amp;quot;bottom&amp;quot;, or &amp;quot;false&amp;quot; property). Similarly, we can establish that if an object is &amp;quot;singular&amp;quot; and &amp;quot;far&amp;quot; then it cannot be &amp;quot;animate&amp;quot;. For, unifying the terms for &amp;quot;singular&amp;quot; and &amp;quot;far&amp;quot; we get: pr(d(far) , no , n(s ,_)) which does not unify with the term for &amp;quot;animate&amp;quot;. can also verify that &amp;quot;reflexive&amp;gender&amp;quot; definitely implies &amp;quot;personal&amp;quot;, that &amp;quot;singular&amp;quot; is compatible with &amp;quot;reflexive&amp;quot;, and so on. It is worth noting that these inferences involving compatibility and properties that are not &amp;quot;maximally delicate&amp;quot; go beyond those allowed by previous systems such as Patten (1986). This seems to work well, but is there a principled way to produce such mappings into the GAF lattice that is guaranteed to yield correct results? For correctness, Linguistics Volume 14, Number 1, Winter 1988 C.S. Mellish Implementing Systemic Classification by Unification we need the following to be true for all possible prop- , • • • Pn+1 in the system network: &amp; &amp;. . .&amp; p„(x) II II . . 1= Vx: &amp; &amp;.. .&amp; p,,(x) = F • • APO} is not unifiable where I is the set of logical axioms derived from the network and II is unification (greatest lower bound in the GAF lattice). A sufficient condition for this would be for T to be a 1-1, 0-preserving meet-homomorphism (Birkhoff (1963)). In fact, the above mapping does not echo in the GAF lattice the result: case(x) &amp; numb(x) D personal(x) and cannot be straightforwardly extended to do so. We thus need to investigate under what conditions such mappings exist and what algorithms might enable us to discover them. 5 A &amp;quot;BRUTE FORCE&amp;quot; TRANSLATION That such mappings always exist, and that inefficient algorithms exist for discovering them, is demonstrated by a more general result. If we have a finite set of propositional symbols and an arbitrary set of axioms mentioning these symbols then there is a method of encoding those symbols as logical terms so that conjunctions are computed by unification and subsumption between conjunctive descriptions (relative to the axioms) is reflected in &amp;quot;degree of instantiation&amp;quot;. We can apply this result to the system networks domain because the logical axioms, although not strictly propositional, are equivalent to propositional axioms if we only consider one object being described at a time. The way to construct this encoding is to consider all possible models of the axioms and the truth assignments made to the symbols in them. In the case of the pronouns network, there are 54 models of the corresponding logical axioms. The following example shows the truth assignments made by one of them (this correto the pronoun animate = F, case = T, demonstrative = F, far = F, feminine = F, first = F, gender = T, inanimate = F, masculine = T, near = F, neuter = F, numb = T. objective = F, person = T, personal = T, plural = F, possessive = F, possdet = F, pronoun = T, question = F, reflexive = F, second = F. singular = T, subjective = T, third = T If there are n possible models, each property is represented by a logical term of arity n + 1. Each such term also has the same function symbol, the constant &amp;quot;0&amp;quot; as first argument and the constant its last argument. The other arguments, for a given property, are to be derived as follows. Each argument starts off as distinct variable, and then, for each model i assigns &amp;quot;F&amp;quot; to the property, the ith argument is unified with the i + 1st argument. In a situation where there are five possible models, the following example includes some of the terms that might result (again we use &amp;quot;_&amp;quot; for variables with uninteresting names). 1 2 3 4 5 I I I I I f(0, _, X, X, 1) (property excludes only model f(0, 0, _, X, X, 1) (property excludes models 1 and 4) f(0, X, X, X, 1, 1) (property excludes models 2, 3, 5) such term the models that the property excludes by the instantiation of its arguments. When two such terms are unified, the result is a term that encodes exclusion of the union of the models excluded by the terms individually. If the two terms together exclude all possible models, the unification fails (this occurs if we attempt to unify the last two of the above terms). This is as desired, since excluding all models amounts to incompatibility of descriptions. The technique used here, which amounts to encoding sets as terms, was, we believe, first developed by Alain Colmerauer in another context. In fact, we can make do with only n arguments. In general, given a set of n property symbols, there can be as many as r different models, and so this &amp;quot;brute force&amp;quot; approach is unattractive. In a situation where there are very few models of the logical axioms, however, the encoding scheme might be quite practical. For instance, for the pronoun network the number of models (54) is much smaller than the worst case for the number of properties The theoretical maximum number of models is reduced by a factor of roughly 2r/r for every &amp;quot;I&amp;quot; connective with r symbols on its right appearing in the system network. Moreover, the theoretical maximum is reduced by a factor of roughly 2 for each property appearing on the right hand side of a &amp;quot;{&amp;quot;. The encoding technique is analogous to using bit strings to encode sets, the only advantage being that a contradictory conjunction is flagged immediately by a unification failure. On the other hand, the terms make use of repeated variables, and so the potential for exploiting parallelism in the unifications is restricted. System networks do not, however, correspond to arbitrary sets of logical axioms. Only certain kinds of axioms can come out of a system network (although a useful characterisation eludes us). We might therefore hope that, given the extra restrictions, there are better encoding techniques available, in particular encoding techniques that do not require the use of repeated variables. We will therefore investigate whether structure-preserving mappings can be found from systemic descriptions to elements of the lattice of generalised atomic formulae without repeated variables, which we Computational Linguistics Volume 14, Number 1, Winter 1988 45 Implementing Systemic Classification by Unification 6 ENCODING FOR THE CONNECTIVES &amp;quot;I&amp;quot;, AND &amp;quot;{&amp;quot; If the only connective used in a system network is &amp;quot;I&amp;quot;, a particularly simple encoding scheme is feasible. This technique has been used in an ad hoc way in a number of language processing systems written in Prolog, and probably originates from Dahl (1977). Consider the example network depicted in Figure 8, expressing the top levels of classification normally used for the plant kingdom. For such a simple network, we can use vascular function symbols more than one argument. Such a system has been used by McCord (1986). Figure 9 depicts a version of the &amp;quot;verb&amp;quot; network used by Winograd (1972), simplified to use only &amp;quot;I&amp;quot; and &amp;quot;{&amp;quot;. One possible translation from the above property symbols into terms includes the following: 7(vb) = vb(_,_) 7(vprt) = vb(vprt,_) T(aux) = vb(aux(_,_,),_) psilopsidan sphenopsidan lycopsidan C.S. Mellish plant gymnospermal angiospermal pteropsidan bacterial fungal algal bryophyte non_vascular nesting as a means of capturing the subsumption relationships in logical terms. Thus each property, apart from properties at the &amp;quot;leaves&amp;quot; of the tree, is associated with a unary function symbol, and the argument of a function symbol is used for a more &amp;quot;fine grained&amp;quot; description if that is available: r(plant) = plant() T(vascular) = plant(vascular( _)) 7(pteropsidan) = plant(vascular(pteropsidan(_))) 7(angiospermal) = plant(vascular(pteropsidan(angiospermal))) Where there are alternatives at a given level in the classification, these are indicated simply by different function symbols appearing in the relevant argument positions. Thus, for instance: T(non_vascular) = plant(non_vascular(j) T(sphenopsidan) = plant(vascular(sphenopsidan)) 7(filicinal) = plant(vascular(pteropsidan(filicinal))) T(fungal) = plant(non_vascular(fungal)) If the &amp;quot;{&amp;quot; connective is also allowed in system networks, this means that a given property may have refinements along several independent dimensions. In logical this can be allowed for by giving the T(neg) = vb(aux(neg,_,J,J T(be) = vb(aux(_,_,be),_) T(pres) = vb(_,pres) Notice how the &amp;quot;aux&amp;quot; function symbol has arity 3; this corresponds to the three independent sub-classifications introduced by the &amp;quot;{&amp;quot; connective. Similarly, &amp;quot;vb&amp;quot; has arity 2. The translation from symbols to terms is again fairly straightforward. Instead of going into detail about the relatively simple problems of dealing with system networks containing only &amp;quot;I&amp;quot; and &amp;quot;{&amp;quot; connectives, we shall concentrate on an algorithm which also allows &amp;quot;}&amp;quot; connectives. This algorithm was used in essence by Bundy et al. (1982), although it has not been described before. INTRODUCING In this section we describe a generalised translation which associates elements of with properties displayed in a system network. The algorithm works for networks using the connectives &amp;quot;I&amp;quot;, &amp;quot;{&amp;quot; and &amp;quot;}&amp;quot;, but does not handle networks that use For this algorithm, we require in advance a function A which associates with each node n of the system Computational Linguistics 14, Number 1, Winter 1988 C.S. Mellish Implementing Systemic Classification by Unification network (a possibly labeled location corresponding to one or more &amp;quot;ends&amp;quot; of connectives) a function symbol A (n). A is required to be 1-1, except that it should map all the nodes appearing around a &amp;quot;{&amp;quot; connective to the same function symbol. Such a function is easy to define for a given network; for instance, most nodes can be simply mapped to the names associated with them in the network. The translation algorithm associates with each node of the network a pair (C, P). The values for C and P are: C = a set of &amp;quot;constraints&amp;quot; describing the term P = a &amp;quot;path&amp;quot; indicating a (possibly embedded) component of the term which can become further instantiated for terms representing properties subsumed by the current property A path is simply a sequence of alternating function symbols and numbers, either empty or starting with a function symbol, indicating a specific position in a term and the function symbols that appear on the route from the outside of the term to this position. A symbol in the sequence indicates a function symbol that is present, whereas a number selects one of the argument positions of the last function symbol. For instance, in f(a, g(X,h(b),i(d,ej(c)))) the symbol &amp;quot;c&amp;quot; appears at the place indicated by the path (f,2,g,3,i,3,j, 1) and the symbol &amp;quot;b&amp;quot; at the place indicated by (f,2,g,2,h,1). We will make use of two basic types of extensions of a path P: extension of P for some function symbol f: If P is () then (f) if P is • • for some number i . . . if P is P2, • s) for some symbol s . . . for some number i extension of P for some function symbol f: If P is () then (f,i) for some number i if P is P2, • • i) for some number i , . . . for some number j if P is P2, • • s) for some symbol s . . . for some number i For instance, for the path (f,2,g), two possible extenare (f,2,g,33,h) and (f,2,g, 1 ,h). For the path two possible extensions are (f,l,g,2,h,4) and (f, 1 ,g,2,h,6). Finally, we will have two ways of describing paths that differ, according to the type of the first component where they disagree: and P2 are their first disagreement is on a number P1 and P2 are inconsistent if their first disagreement is on a function symbol Thus (f,2,g,3,h) is independent of (f,2,g,4,d,3), and (f,2,g,5,a) is inconsistent with (f,2,h,4). A constraint is a path used to specify that particular function symbols must appear at particular places in a term. A term is correctly described by a constraint if the path makes sense (i.e., all the relevant components exist) and the given function symbols do indeed appear at the relevant places. A term is correctly described by a set of constraints if it is correctly described by all of them. Thus, for instance, the set of constraints: { (g, 1 ,f,2,a), (g, 1 ,f,3,b), (g, 1 ,f), (g) correctly describes any of the terms: g(f(z,a,b(c)),h(1)) g(f(w(x),a(d,f,g),b,x)) g(f(w(x),a(g),b),x) The term that is the translation of a node in a system network is obtained from the set of constraints as follows. First of all, each function symbol (element of the range of A) is taken to have the same arity (number of arguments) in all the terms derived from the network. This is the minimal arity such that all the constraints attached to all the nodes are satisfiable. Secondly, with aux vb Pos qaux no_qaux be do have will modal vPrt no_vprt pres Past ing en inf Computational Linguistics Volume 14, Number 1, Winter 1988 47 C.S. Mellish Implementing Systemic Classification by Unification arities fixed in this way, the translation of a property is the most general (least instantiated) term that is correctly described by the constraints at the property&apos;s node. Thus, for example, if the arities of a, b, f and g were 1, 0, 3 and 2 respectively (note that the arity off must be at least 3), the following term would be the &amp;quot;solution&amp;quot; of the above set of constraints: g(f(_, a(_) ,b) ,_) The following defines a space of possible translation algorithms. For each place where alternatives are allowed, it does not matter which the algorithm specifies. (1) Record ({(f)},(f)) as the value for the leftmost node, where f is the value of A for that node (2) Until there is no connective all of whose left nodes have translations but none of whose right nodes do, do the following: (2.1) Select one such connective (2.2) If the connective is &amp;quot;I&amp;quot; and the left hand node has (C,P), assign to the ith node on the right hand side the translation: for each p, is extension of P to A where is inconsistent with if If the connective is &amp;quot;{&amp;quot; and the left hand node L has translation (C, P), assign to the ith node on the right hand side the translation: for each is extension of P beyond A and where and are independent if I. If the connective is &amp;quot;}&amp;quot; and the two left hand have translations assign to the node on the right hand side the translation: U C2, either 1 or i = 2. The basic idea is that as one goes to the right in the network, the constraints on a node are the constraints on the nodes to its immediate left, together with possibly extra constraints to differentiate it from them (if they properly subsume it). At each point, the path component of a node&apos;s translation indicates where nodes further to the right can be further instantiated. If the connective is &amp;quot;I&amp;quot;, the extra constraints added for each node on the right amount to forcing the place indicated by the path to have the function symbol associated with that node. Since the paths used for the right hand nodes are inconsistent, the terms generated for the nodes will be incompatible. If the connective is &amp;quot;{&amp;quot;, the nodes on the right hand side must have the same constraints as the node on the left. On the other hand, each is given a different, slightly longer, path so that the term can be further instantiated in several independent ways. The above algorithm, although not optimal in the sense of generating the smallest possible terms, is the basis of one that has generated correct results in practice. In addition, we have a proof of correctness for it. The proof hinges on the reduction of the correctness criterion given in section 4 to the following simpler one. translation for all properties and named in the network: x: D sT(P2) V x: D I1= = for some in the network and all logically distinct A(P2) in &amp; = not unifiable x: &amp; = T(P2) = T(P3) for some function A is introduced above. The reduction can be made because of various special properties that of system networks that only &amp;quot;I&amp;quot;, I 1= V = for properties and mentioned in the network and logically then is equivalent to a property on the hand side of a and and are equivalent to the properties appearing on the left hand side. I V x: . D p(x), for , . . . mentioned in either 1 1= x: p(x) some i, or p equivalent to a property appearing on the right a P is set of properties mentioned in the network and for every &amp;quot;I&amp;quot; connective either no elements of P lie to the right of that connective or all elements lie to the right of the same right hand branch, then the set P is compatible. None of the schemes in this section or the previous section require repeated variables in the logical terms, and so there is nothing to prevent unification tackling different components in parallel. Of course, if one had a great deal of parallelism available, one could use it to implement a naive network searcher for testing compatibility of two properties (e.g., by searching for the rightmost node that appears to the left of both and seeing whether the connective at that point is &amp;quot;I&amp;quot;. The implementation via unification would then be unnecessary (at least for simple cases). Thus to a certain extent the &amp;quot;compilation&amp;quot; of tasks like compatibilityand subsumption-checking into unification tasks can be viewed as a special case of compiling OR-parallel programs into AND-parallel programs (Codish and Shapiro (1986), Ueda (1986)). The checking can be even faster if the unifications are further compiled (Warren (1977)). For in the network, checking that a descrip- 48 Computational Linguistics Volume 14, Number 1, Winter 1988 C.S. Mellish Implementing Systemic Classification by Unification tion of a verb is compatible with &amp;quot;pres&amp;quot; simply amounts to seeing whether the third component of the term is not a function symbol different from &amp;quot;pres&amp;quot;. INTRODUCING 4 We have intentionally left consideration of the &amp;quot;1&amp;quot; connective to its own section. This is because we have no general algorithm (apart from the above &amp;quot;brute force&amp;quot; algorithm) for translating system networks with &amp;quot;1&amp;quot; connectives into logical terms in a way that will correctly mirror the subsumption relationships. Indeed, there is no reason to believe that there are straightforward algorithms for this. First of all, we can easily demonstrate through an example that networks containing &amp;quot;1&amp;quot;s cannot be imusing only something like the full power of unification is necessary, rather than the simple subcases we have considered up to now. Consider the system network depicted in Figure 10. The entity b2 subsumption relationships between properties and conjunctions of properties are shown in Figure 11. This entity that we need for an IDR application, but it means that, although we can read off from the diagram information about greatest lower bounds, we cannot obtain from it about least upper bounds. Now are incompatible, i.e., their greatest lower bound is &amp;quot;F&amp;quot;. Therefore the terms representing these two descriptions cannot unify. If we are not allowing terms with repeated variables, the only way that two terms can fail to unify is by there being some component where the twQ terms take on different non-variable Let the value &amp;quot;y&amp;quot; in this component take the value &amp;quot;n&amp;quot; (we do not have to assume that &amp;quot;y&amp;quot; and &amp;quot;n&amp;quot; are atomic, merely that their &amp;quot;top level&amp;quot; function symbols are different). We can then make various inferences about what other terms should have in this component: —y —n it is above it is above —n so as to make when unified with it is below —y to make unified with —y it is below it is above and as well as being the greatest lower bound and is also the greatest lower bound of and unifying the terms for and above specifies that the particular component will have the value &amp;quot;_&amp;quot;. This conflicts with the value already inferred —&amp;quot;n&amp;quot;. Therefore, under the constraint of avoiding repeated variables, it is not possible to produce a valid mapping from descriptions to terms. Figure 12 shows the subsumption relationships again, with the descriptions substituted by logical terms obtained by the &amp;quot;brute force&amp;quot; method. Of course, repeated variables have to be used several times. al a2 b2 f(0.0.R.X.1) diagram must be read with some care, as we have only shown the elements of the meet-semilattice consisting of the data elements and their conjunctions. This is all It is natural to ask what it is about descriptions arising from networks with &amp;quot;1&amp;quot; that cannot be modelled Computational Linguistics Volume 14, Number 1, Winter 1988 49 C.S. Mellish Implementing Systemic Classification by Unification is at least one property of (and any sub-semilattice of it that contains the bottom element) which is not echoed in description spaces like our examples. Since descriptions from &amp;quot;1&amp;quot; networks can this property, it follows that cannot be used accurately to model the description spaces. The property is that compatibility is determined: all sets of elements . . . . . . compatible is compatible with for each j. (we say that a set of objects is compatible if their greatest lower bound is not the &amp;quot;bottom&amp;quot; element). In example description space, the set c} is not compatible, and yet each pair of elements taken from it is compatible. Thus compatibility is not determined pairwise in the description space. It seems unlikely in this example that one could come up with an encoding in the full GAF that would improve on the &amp;quot;brute force&amp;quot; approach. Indeed, this may often be the case, as networks containing &amp;quot;]&amp;quot;s are very complex to process. Consider, for instance, Figure 13 which is an extension to the above network. ••• b b2 ••• choosing logical terms for . .b„, has to reflect the fact that &amp; = .m-1) (i 2. .n) Si c contradictory 1. .m-1, 2. .n) This certainly prevents the sub-classifications represented by the &amp;quot;a&amp;quot;s and the &amp;quot;b&amp;quot;s from being translated independently, in the way that could be done in our portion of Winograd&apos;s verb network. 9 RELATED WORK A piece of work that is closely related in many ways is Kasper&apos;s work (Kasper (1986)) on translating Systemic Grammars into functional unification grammars. Kasper describes a way of mapping a system network and feature choices into a functional description of FUG (Kay (1984)). Such a mapping induces a mapping from systemic descriptions to functional descriptions in such a way that conjunction of descriptions is computed by (functional) unification of the functional descriptions. Kasper&apos;s work represents an extension of ours in that it treats more than the systemic choices of a Systemic Grammar, and we are currently investigating how our framework can best be extended to deal with these other aspects. Unfortunately, the functional description Kasper builds for anything but a complete (maximally specific) systemic description will contain disjunctions, and the complexity of functional unification is seriously affected by the presence of disjunctions. Moreover, Kasper actually needs to extend the notion of functional description in order to produce translations for networks with complex entry conditions. Since logical unification corresponds closely to functional unification when there are no disjunctive descriptions or patterns, our methods can be viewed as techfor mapping systemic descriptions into disjunction-free, conventional functional descriptions. Kasper&apos;s primary aim is for a mapping bea systemic a Functional Unificaa mapping between individual descriptions induced by this), in our case there is only a description mapping. It is hard to believe that a unification grammar allowing exactly those functional descriptions corresponding to the terms generated by our &amp;quot;brute force&amp;quot; method would be of much interest. Another related piece of work is that of Gazdar et al., which seeks to produce a uniform formalism for describing legal categories in grammatical formalisms. In the case of Systemic Grammar, a &amp;quot;category&amp;quot; is a set of feature specifications. The work of Gazdar and his colleagues envisages an implementation of category conjunction by a kind of unification which is similar to logical unification, except that there are no repeated variables. As with Kasper&apos;s work, the approach is to provide a translation for the grammar of legal descriptions. In this case, however, one product of the translation is a set of global constraints on legal Unfortunately, unification does not prethe validity of these constraints and is not therefore a correct implementation of greatest lower bound in the subsumption lattice. Our approach can be roughly characterised as an attempt to find alternative translations where unification is correct because the global constraints have been &amp;quot;built in&amp;quot;. To do this, unfortunately, we need to allow repeated variables. ACKNOWLEDGEMENTS</abstract>
<note confidence="0.770477588235294">This work was carried out as part of a project on natural generation financed by SERC grant Computational Linguistics Volume 14, Number 1, Winter C.S. Mellish Implementing Systemic Classification by Unification 08876. I am currently supported by an SERC Advanced Fellowship. REFERENCES Garrett. 1963 Theory. Mathematical Society. Bundy, Alan; Byrd, Lawrence and Mellish, Chris. 1982 Special Purpose, but Domain Independent, Inference Mechanisms. In Luc and Campbell, John, Eds., in Artificial Wiley, Chichester, UK: 93-111. Buntine, Wray. 1986 Generalised Subsumption and its Applications to Induction and Redundancy. In Steels, Luc and DuBoulay, Ben, of the Seventh European Conference on Artificial 1986. Codish, Michael and Shapiro, Ehud. 1986 Compiling OR-Parallelism AND-Parallelism. In Shapiro, Ehud, Ed., of the Third Conference on Logic Programming. Verlag. Dahl, Veronica. 1977 Un Systeme Deductif d&apos;Interrogation de Banques de Donnes en Espagnol. PhD dissertation, Groupe d&apos;Intelligence Artificielle, University of Marseille-Luminy. Gazdar, Gerald; Klein, Ewan; Pullum, Geoffrey and Sag, Ivan. 1985 Phrase Structure Grammar. Gazdar, Gerald; Pullum, Geoffrey; Carpenter, Robert; Klein, Ewan; Hukari, Thomas and Levine, Robert. (to appear) Category Struc- Linguistics. Richard A. 1971 Complex Sentences: An Introducto Systemic Grammar. Holland. Kasper, Robert. 1986 Systemic Grammar and Functional Unification In Benson, J. and Greaves, W., Eds., papers the Twelfth International Systemics Workshop. Nor-</note>
<address confidence="0.6953565">wood, NJ, USA. Kay, Martin. 1984 Functional Unification Grammar: A Formalism for</address>
<note confidence="0.710032">Translation. In of COLING-84. July 1984.</note>
<author confidence="0.692965">System</author>
<author confidence="0.692965">Function in Lan-</author>
<affiliation confidence="0.982263">University Press.</affiliation>
<address confidence="0.859985">McCord, Michael C. 1986 Design of a Prolog-based Machine Trans-</address>
<title confidence="0.507628666666667">System. In Shapiro, Ehud, Ed., of the Third Interna- Conference on Logic Programming. Verlag. Mellish, Chris S. (forthcoming) Version Spaces, Description Spaces</title>
<author confidence="0.296729">Research paper</author>
<author confidence="0.296729">Dept of Artificial Intelligence</author>
<affiliation confidence="0.992246">University of Edinburgh.</affiliation>
<note confidence="0.43493375">Patten, Terry A. 1986 Interpreting Systemic Grammar as a Computational Representation: A Problem Solving Approach to Text Generation. PhD thesis, University of Edinburgh. Reynolds, John C. 1970 Transformational Systems and the Algebraic</note>
<affiliation confidence="0.930757">Structure of Atomic Formulas. In Meltzer, Bernard and Michie, Eds., Intelligence Edinburgh University</affiliation>
<address confidence="0.603773">Press. Robinson, J. Alan. 1965 A Machine-Oriented Logic Based on the</address>
<note confidence="0.87537825">Principle. 23-41. Ueda, Kazunori. 1986 Making Exhaustive Search Programs Deter- In Shapiro, Ehud, Ed., of the Third International on Logic Programming. Verlag. Warren, David H. D. 1977 Implementing Prolog: Compiling Predicate Logic Programs: Research Reports 39 and 40, Department of Artificial Intelligence, University of Edinburgh. Terry. 1972 Natural Language. Press. Terry. 1983 as a Cognitive Process. Volume 1: Wesley. NOTES 1. Author&apos;s current address: Department of Artificial Intelligence, University of Edinburgh, 80 South Bridge, EDINBURGH EH1 1HN, Scotland. Computational Linguistics Volume 14, Number 1, Winter 1988 51</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<authors>
<author>C S Mellish</author>
</authors>
<title>Implementing Systemic Classification by Unification 08876. I am currently supported by an SERC Advanced Fellowship.</title>
<marker>Mellish, </marker>
<rawString>C.S. Mellish Implementing Systemic Classification by Unification 08876. I am currently supported by an SERC Advanced Fellowship.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Garrett Birkhoff</author>
</authors>
<title>Lattice Theory.</title>
<date>1963</date>
<publisher>American Mathematical Society.</publisher>
<contexts>
<context position="14550" citStr="Birkhoff (1963)" startWordPosition="2297" endWordPosition="2298">This &amp;quot;algorithm&amp;quot; for IDR is in fact a special case of a more general classification algorithm given in Mellish (forthcoming). At any point, a contradiction is signaled by the partial description becoming the most specific description of all (&amp;quot;false&amp;quot;). Moreover, one can validly infer that the target is subsumed by a given description if the partial description is. The only operations that we need for IDR are subsumption checking and the computation of greatest lower bounds. This means that, in fact, we do not need the full lattice structure developed above—all we need is the meet semi-lattice (Birkhoff (1963)) that contains the possible data descriptions and all possible conjunctions of them. The above description of IDR is not dependent on descriptions being related to system networks, and indeed IDR has been used in quite different contexts. In this paper, however, we will confine ourselves to this case, and consider IDR where the data descriptions are precisely the properties mentioned in a system network. We are thus concerned with ways of computing and testing subsumption between conjunctions of properties, given the background information provided by the network axioms. 4 USING LOGICAL TERMS</context>
<context position="20557" citStr="Birkhoff (1963)" startWordPosition="3269" endWordPosition="3270">ional Linguistics Volume 14, Number 1, Winter 1988 C.S. Mellish Implementing Systemic Classification by Unification we need the following to be true for all possible properties Pi, , n 2, • • • Pn+1 named in the system network: Potx: p1(x) &amp; p2(x) &amp;. . .&amp; p„(x) p01(x) iff ,r(p,) II 7(p2) II . . n) I 1= Vx: p1(x) &amp; p2(x) &amp;.. .&amp; p,,(x) = F iff f7(PI)AP2) • • APO} is not unifiable where I is the set of logical axioms derived from the network and II is unification (greatest lower bound in the GAF lattice). A sufficient condition for this would be for T to be a 1-1, 0-preserving meet-homomorphism (Birkhoff (1963)). In fact, the above mapping does not echo in the GAF lattice the result: V x: case(x) &amp; numb(x) D personal(x) and cannot be straightforwardly extended to do so. We thus need to investigate under what conditions such mappings exist and what algorithms might enable us to discover them. 5 A &amp;quot;BRUTE FORCE&amp;quot; TRANSLATION That such mappings always exist, and that inefficient algorithms exist for discovering them, is demonstrated by a more general result. If we have a finite set of propositional symbols and an arbitrary set of axioms mentioning these symbols then there is a method of encoding those sy</context>
</contexts>
<marker>Birkhoff, 1963</marker>
<rawString>Birkhoff, Garrett. 1963 Lattice Theory. American Mathematical Society.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alan Bundy</author>
<author>Lawrence Byrd</author>
<author>Chris Mellish</author>
</authors>
<title>Special Purpose, but Domain Independent, Inference Mechanisms. In Steels,</title>
<date>1982</date>
<booktitle>in Artificial Intelligence.</booktitle>
<pages>93--111</pages>
<publisher>John Wiley,</publisher>
<location>Luc and Campbell, John, Eds., Progress</location>
<contexts>
<context position="28072" citStr="Bundy et al. (1982)" startWordPosition="4506" endWordPosition="4509">an be allowed for by giving the T(neg) = vb(aux(neg,_,J,J T(be) = vb(aux(_,_,be),_) T(pres) = vb(_,pres) Notice how the &amp;quot;aux&amp;quot; function symbol has arity 3; this corresponds to the three independent sub-classifications introduced by the &amp;quot;{&amp;quot; connective. Similarly, &amp;quot;vb&amp;quot; has arity 2. The translation from symbols to terms is again fairly straightforward. Instead of going into detail about the relatively simple problems of dealing with system networks containing only &amp;quot;I&amp;quot; and &amp;quot;{&amp;quot; connectives, we shall concentrate on an algorithm which also allows &amp;quot;}&amp;quot; connectives. This algorithm was used in essence by Bundy et al. (1982), although it has not been described before. 7 INTRODUCING 46}99 In this section we describe a generalised translation algorithm which associates elements of GAF() with properties displayed in a system network. The algorithm works for networks using the connectives &amp;quot;I&amp;quot;, &amp;quot;{&amp;quot; and &amp;quot;}&amp;quot;, but does not handle networks that use For this algorithm, we require in advance a function A which associates with each node n of the system 46 Computational Linguistics Volume 14, Number 1, Winter 1988 C.S. Mellish Implementing Systemic Classification by Unification network (a possibly labeled location correspondi</context>
</contexts>
<marker>Bundy, Byrd, Mellish, 1982</marker>
<rawString>Bundy, Alan; Byrd, Lawrence and Mellish, Chris. 1982 Special Purpose, but Domain Independent, Inference Mechanisms. In Steels, Luc and Campbell, John, Eds., Progress in Artificial Intelligence. John Wiley, Chichester, UK: 93-111.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Wray Buntine</author>
</authors>
<title>Generalised Subsumption and its Applications to Induction and Redundancy.</title>
<date>1986</date>
<booktitle>In Steels, Luc and DuBoulay, Ben, Eds., Procs of the Seventh European Conference on Artificial Intelligence.</booktitle>
<location>Brighton,</location>
<contexts>
<context position="8887" citStr="Buntine (1986)" startWordPosition="1390" endWordPosition="1391">plex descriptions is by conjunction and disjunction. The logical interpretation of such complex descriptions is straightforward, and we will often blur the distinction between a description and its interpretation. Thus: masculine &amp; singular corresponds to Ax. masculine(x) &amp; singular(x) masculine v feminine corresponds to Ax. masculine(x) v feminine(x) A fundamental relationship between descriptions is subsumption: di subsumes d2 if 1= V x: d2(x) D di(x) where is the set of axioms derived from the network. Note that our notion of subsumption depends vitally on 1. This is a special case of what Buntine (1986) calls &amp;quot;generalised subsumption&amp;quot;. Intuitively di subsumes d2 if, given the axioms 1, di is a more general description than d2. That is, if di describes all the objects accurately described by d2 and maybe more. Subsumption is a partial ordering on descriptions, and the set of possible descriptions (properties and all possible finite conjunctions and disjunctions of descriptions made from them), ordered by subsumption, forms a lattice. In this lattice, the least upper bound of two descriptions is their disjunction and the greatest lower bound is their conjunction. Figure 6 is a picture of a por</context>
</contexts>
<marker>Buntine, 1986</marker>
<rawString>Buntine, Wray. 1986 Generalised Subsumption and its Applications to Induction and Redundancy. In Steels, Luc and DuBoulay, Ben, Eds., Procs of the Seventh European Conference on Artificial Intelligence. Brighton, 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Codish</author>
<author>Ehud Shapiro</author>
</authors>
<title>Compiling OR-Parallelism into AND-Parallelism.</title>
<date>1986</date>
<booktitle>In Shapiro, Ehud, Ed., Procs of the Third International Conference on Logic Programming.</booktitle>
<publisher>Springer Verlag.</publisher>
<contexts>
<context position="37159" citStr="Codish and Shapiro (1986)" startWordPosition="6166" endWordPosition="6169">el. Of course, if one had a great deal of parallelism available, one could use it to implement a naive network searcher for testing compatibility of two properties (e.g., by searching for the rightmost node that appears to the left of both and seeing whether the connective at that point is &amp;quot;I&amp;quot;. The implementation via unification would then be unnecessary (at least for simple cases). Thus to a certain extent the &amp;quot;compilation&amp;quot; of tasks like compatibility- and subsumption-checking into unification tasks can be viewed as a special case of compiling OR-parallel programs into AND-parallel programs (Codish and Shapiro (1986), Ueda (1986)). The checking can be even faster if the unifications are further compiled (Warren (1977)). For instance, in the verb network, checking that a descrip48 Computational Linguistics Volume 14, Number 1, Winter 1988 C.S. Mellish Implementing Systemic Classification by Unification tion of a verb is compatible with &amp;quot;pres&amp;quot; simply amounts to seeing whether the third component of the term is not a function symbol different from &amp;quot;pres&amp;quot;. 8 INTRODUCING 4 99 We have intentionally left consideration of the &amp;quot;1&amp;quot; connective to its own section. This is because we have no general algorithm (apart f</context>
</contexts>
<marker>Codish, Shapiro, 1986</marker>
<rawString>Codish, Michael and Shapiro, Ehud. 1986 Compiling OR-Parallelism into AND-Parallelism. In Shapiro, Ehud, Ed., Procs of the Third International Conference on Logic Programming. Springer Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Veronica Dahl</author>
</authors>
<title>Un Systeme Deductif d&apos;Interrogation de Banques de Donnes en Espagnol.</title>
<date>1977</date>
<institution>Artificielle, University of Marseille-Luminy.</institution>
<note>PhD dissertation, Groupe d&apos;Intelligence</note>
<contexts>
<context position="25765" citStr="Dahl (1977)" startWordPosition="4175" endWordPosition="4176">e investigate whether structure-preserving mappings can be found from systemic descriptions to elements of the lattice of generalised atomic formulae without repeated variables, which we call GAF°. Computational Linguistics Volume 14, Number 1, Winter 1988 45 Implementing Systemic Classification by Unification 6 ENCODING FOR THE CONNECTIVES &amp;quot;I&amp;quot;, AND &amp;quot;{&amp;quot; If the only connective used in a system network is &amp;quot;I&amp;quot;, a particularly simple encoding scheme is feasible. This technique has been used in an ad hoc way in a number of language processing systems written in Prolog, and probably originates from Dahl (1977). Consider the example network depicted in Figure 8, expressing the top levels of classification normally used for the plant kingdom. For such a simple network, we can use vascular function symbols more than one argument. Such a system has been used by McCord (1986). Figure 9 depicts a version of the &amp;quot;verb&amp;quot; network used by Winograd (1972), simplified to use only &amp;quot;I&amp;quot; and &amp;quot;{&amp;quot;. One possible translation from the above property symbols into terms includes the following: 7(vb) = vb(_,_) 7(vprt) = vb(vprt,_) T(aux) = vb(aux(_,_,),_) psilopsidan sphenopsidan lycopsidan C.S. Mellish plant gymnospermal </context>
</contexts>
<marker>Dahl, 1977</marker>
<rawString>Dahl, Veronica. 1977 Un Systeme Deductif d&apos;Interrogation de Banques de Donnes en Espagnol. PhD dissertation, Groupe d&apos;Intelligence Artificielle, University of Marseille-Luminy.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gerald Gazdar</author>
<author>Ewan Klein</author>
<author>Geoffrey Pullum</author>
<author>Ivan Sag</author>
</authors>
<title>Generalised Phrase Structure Grammar.</title>
<date>1985</date>
<publisher>Blackwell.</publisher>
<contexts>
<context position="2557" citStr="Gazdar et al. (1985)" startWordPosition="388" endWordPosition="391">his is possible, we can use a fixed mapping from property names to logical terms to create terms that represent conjunctive descriptions (by unification) and to test subsumption (by testing &amp;quot;less instantiated than&amp;quot;). Incompatibility of descriptions is also indicated by unification failure. There are a number of reasons why it is interesting to investigate these possibilities: (1) They may result in more efficient or flexible ways of using system networks for inferencing. (2) They may enable language analysers or generators which involve unification for other reasons (e.g., analysers for GPSG (Gazdar et al. (1985)) or Functional Unification Grammar (Kay (1984)) to build in feature co-occurrence tests using the same mechanism. (3) They may enable us to make formal sense of various ad-hoc mechanisms used by logic programmers in natural language processing. (4) By exposing the nature of the relevant description spaces, they may open various possibilities for the implementation of other classification tasks, e.g., concept learning (Mellish forthcoming). (5) They may give us more insight into the semantics of system networks and the potential of unification. 1 HALLIDAY&apos;S SYSTEM NETWORKS System networks, as </context>
</contexts>
<marker>Gazdar, Klein, Pullum, Sag, 1985</marker>
<rawString>Gazdar, Gerald; Klein, Ewan; Pullum, Geoffrey and Sag, Ivan. 1985 Generalised Phrase Structure Grammar. Blackwell.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Gerald Gazdar</author>
<author>Geoffrey Pullum</author>
<author>Robert Carpenter</author>
<author>Ewan Klein</author>
<author>Thomas Hukari</author>
<author>Robert Levine</author>
</authors>
<title>(to appear) Category Structures. Computational Linguistics.</title>
<marker>Gazdar, Pullum, Carpenter, Klein, Hukari, Levine, </marker>
<rawString>Gazdar, Gerald; Pullum, Geoffrey; Carpenter, Robert; Klein, Ewan; Hukari, Thomas and Levine, Robert. (to appear) Category Structures. Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Richard A Hudson</author>
</authors>
<title>English Complex Sentences: An Introduction to Systemic Grammar.</title>
<date>1971</date>
<publisher>North Holland.</publisher>
<contexts>
<context position="3207" citStr="Hudson (1971)" startWordPosition="489" endWordPosition="490">Kay (1984)) to build in feature co-occurrence tests using the same mechanism. (3) They may enable us to make formal sense of various ad-hoc mechanisms used by logic programmers in natural language processing. (4) By exposing the nature of the relevant description spaces, they may open various possibilities for the implementation of other classification tasks, e.g., concept learning (Mellish forthcoming). (5) They may give us more insight into the semantics of system networks and the potential of unification. 1 HALLIDAY&apos;S SYSTEM NETWORKS System networks, as used in Halliday&apos;s Systemic Grammar (Hudson (1971), Kress (1976), Winograd (1983)) are a way of encoding the choices that must be made in the generation of a complex linguistic object and the interdependencies between them. There is actually nothing that makes such networks specific to linguistic applications, and so there is no reason why they cannot be applied to describing the choices involved in other complex situations. A system network can be viewed as a graph, some of whose nodes are annotated with symbols representing properties. The nodes are tied together by the use of four different &amp;quot;connectives&amp;quot;, which we shall designate by &amp;quot;I&amp;quot;, &amp;quot;</context>
</contexts>
<marker>Hudson, 1971</marker>
<rawString>Hudson, Richard A. 1971 English Complex Sentences: An Introduction to Systemic Grammar. North Holland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert Kasper</author>
</authors>
<title>Systemic Grammar and Functional Unification Grammar. In</title>
<date>1986</date>
<booktitle>Selected papers from the Twelfth International Systemics Workshop. Ablex,</booktitle>
<location>Norwood, NJ, USA.</location>
<contexts>
<context position="42336" citStr="Kasper (1986)" startWordPosition="7064" endWordPosition="7065">to process. Consider, for instance, Figure 13 which is an extension to the above network. al a2 ••• entity am b b2 ••• In choosing logical terms for a1, a2, . .am, b1, b2, . .b„, one has to reflect the fact that c &amp; ai implies b1 (i = 1. .m-1) c implies am (i = 2. .n) bi Si c is contradictory (i = 1. .m-1, j = 2. .n) This certainly prevents the sub-classifications represented by the &amp;quot;a&amp;quot;s and the &amp;quot;b&amp;quot;s from being translated independently, in the way that could be done in our portion of Winograd&apos;s verb network. 9 RELATED WORK A piece of work that is closely related in many ways is Kasper&apos;s work (Kasper (1986)) on translating Systemic Grammars into functional unification grammars. Kasper describes a way of mapping a system network and feature choices into a functional description of FUG (Kay (1984)). Such a mapping induces a mapping from systemic descriptions to functional descriptions in such a way that conjunction of descriptions is computed by (functional) unification of the functional descriptions. Kasper&apos;s work represents an extension of ours in that it treats more than the systemic choices of a Systemic Grammar, and we are currently investigating how our framework can best be extended to deal</context>
</contexts>
<marker>Kasper, 1986</marker>
<rawString>Kasper, Robert. 1986 Systemic Grammar and Functional Unification Grammar. In Benson, J. and Greaves, W., Eds., Selected papers from the Twelfth International Systemics Workshop. Ablex, Norwood, NJ, USA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Martin Kay</author>
</authors>
<title>Functional Unification Grammar: A Formalism for Machine Translation.</title>
<date>1984</date>
<booktitle>In Procs of COLING-84.</booktitle>
<location>Stanford,</location>
<contexts>
<context position="2604" citStr="Kay (1984)" startWordPosition="397" endWordPosition="398"> names to logical terms to create terms that represent conjunctive descriptions (by unification) and to test subsumption (by testing &amp;quot;less instantiated than&amp;quot;). Incompatibility of descriptions is also indicated by unification failure. There are a number of reasons why it is interesting to investigate these possibilities: (1) They may result in more efficient or flexible ways of using system networks for inferencing. (2) They may enable language analysers or generators which involve unification for other reasons (e.g., analysers for GPSG (Gazdar et al. (1985)) or Functional Unification Grammar (Kay (1984)) to build in feature co-occurrence tests using the same mechanism. (3) They may enable us to make formal sense of various ad-hoc mechanisms used by logic programmers in natural language processing. (4) By exposing the nature of the relevant description spaces, they may open various possibilities for the implementation of other classification tasks, e.g., concept learning (Mellish forthcoming). (5) They may give us more insight into the semantics of system networks and the potential of unification. 1 HALLIDAY&apos;S SYSTEM NETWORKS System networks, as used in Halliday&apos;s Systemic Grammar (Hudson (19</context>
<context position="42528" citStr="Kay (1984)" startWordPosition="7092" endWordPosition="7093">ct the fact that c &amp; ai implies b1 (i = 1. .m-1) c implies am (i = 2. .n) bi Si c is contradictory (i = 1. .m-1, j = 2. .n) This certainly prevents the sub-classifications represented by the &amp;quot;a&amp;quot;s and the &amp;quot;b&amp;quot;s from being translated independently, in the way that could be done in our portion of Winograd&apos;s verb network. 9 RELATED WORK A piece of work that is closely related in many ways is Kasper&apos;s work (Kasper (1986)) on translating Systemic Grammars into functional unification grammars. Kasper describes a way of mapping a system network and feature choices into a functional description of FUG (Kay (1984)). Such a mapping induces a mapping from systemic descriptions to functional descriptions in such a way that conjunction of descriptions is computed by (functional) unification of the functional descriptions. Kasper&apos;s work represents an extension of ours in that it treats more than the systemic choices of a Systemic Grammar, and we are currently investigating how our framework can best be extended to deal with these other aspects. Unfortunately, the functional description that Kasper builds for anything but a complete (maximally specific) systemic description will contain disjunctions, and the</context>
</contexts>
<marker>Kay, 1984</marker>
<rawString>Kay, Martin. 1984 Functional Unification Grammar: A Formalism for Machine Translation. In Procs of COLING-84. Stanford, July 1984.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gunther Kress</author>
<author>Ed</author>
</authors>
<title>Halliday: System and Function in Language.</title>
<date>1976</date>
<publisher>Oxford University Press.</publisher>
<marker>Kress, Ed, 1976</marker>
<rawString>Kress, Gunther, Ed. 1976 Halliday: System and Function in Language. Oxford University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael C McCord</author>
</authors>
<title>Design of a Prolog-based Machine Translation System. In</title>
<date>1986</date>
<booktitle>Shapiro, Ehud, Ed., Procs of the Third International Conference on Logic Programming.</booktitle>
<publisher>Springer Verlag.</publisher>
<contexts>
<context position="26031" citStr="McCord (1986)" startWordPosition="4219" endWordPosition="4220">ementing Systemic Classification by Unification 6 ENCODING FOR THE CONNECTIVES &amp;quot;I&amp;quot;, AND &amp;quot;{&amp;quot; If the only connective used in a system network is &amp;quot;I&amp;quot;, a particularly simple encoding scheme is feasible. This technique has been used in an ad hoc way in a number of language processing systems written in Prolog, and probably originates from Dahl (1977). Consider the example network depicted in Figure 8, expressing the top levels of classification normally used for the plant kingdom. For such a simple network, we can use vascular function symbols more than one argument. Such a system has been used by McCord (1986). Figure 9 depicts a version of the &amp;quot;verb&amp;quot; network used by Winograd (1972), simplified to use only &amp;quot;I&amp;quot; and &amp;quot;{&amp;quot;. One possible translation from the above property symbols into terms includes the following: 7(vb) = vb(_,_) 7(vprt) = vb(vprt,_) T(aux) = vb(aux(_,_,),_) psilopsidan sphenopsidan lycopsidan C.S. Mellish plant gymnospermal angiospermal pteropsidan bacterial fungal algal bryophyte non_vascular nesting as a means of capturing the subsumption relationships in logical terms. Thus each property, apart from properties at the &amp;quot;leaves&amp;quot; of the tree, is associated with a unary function symbol, </context>
</contexts>
<marker>McCord, 1986</marker>
<rawString>McCord, Michael C. 1986 Design of a Prolog-based Machine Translation System. In Shapiro, Ehud, Ed., Procs of the Third International Conference on Logic Programming. Springer Verlag.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Chris S Mellish</author>
</authors>
<title>(forthcoming) Version Spaces, Description Spaces and Unification. Research paper,</title>
<institution>Dept of Artificial Intelligence, University of Edinburgh.</institution>
<marker>Mellish, </marker>
<rawString>Mellish, Chris S. (forthcoming) Version Spaces, Description Spaces and Unification. Research paper, Dept of Artificial Intelligence, University of Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Terry A Patten</author>
</authors>
<title>Interpreting Systemic Grammar as a Computational Representation: A Problem Solving Approach to Text Generation.</title>
<date>1986</date>
<tech>PhD thesis,</tech>
<institution>University of Edinburgh.</institution>
<contexts>
<context position="19766" citStr="Patten (1986)" startWordPosition="3124" endWordPosition="3125">ify (the conjunction is the &amp;quot;bottom&amp;quot;, or &amp;quot;false&amp;quot; property). Similarly, we can establish that if an object is &amp;quot;singular&amp;quot; and &amp;quot;far&amp;quot; then it cannot be &amp;quot;animate&amp;quot;. For, unifying the terms for &amp;quot;singular&amp;quot; and &amp;quot;far&amp;quot; we get: pr(d(far) , no , n(s ,_)) which does not unify with the term for &amp;quot;animate&amp;quot;. Using T, we can also verify that &amp;quot;reflexive&amp;gender&amp;quot; definitely implies &amp;quot;personal&amp;quot;, that &amp;quot;singular&amp;quot; is compatible with &amp;quot;reflexive&amp;quot;, and so on. It is worth noting that these inferences involving compatibility and properties that are not &amp;quot;maximally delicate&amp;quot; go beyond those allowed by previous systems such as Patten (1986). This seems to work well, but is there a principled way to produce such mappings into the GAF lattice that is guaranteed to yield correct results? For correctness, 44 Computational Linguistics Volume 14, Number 1, Winter 1988 C.S. Mellish Implementing Systemic Classification by Unification we need the following to be true for all possible properties Pi, , n 2, • • • Pn+1 named in the system network: Potx: p1(x) &amp; p2(x) &amp;. . .&amp; p„(x) p01(x) iff ,r(p,) II 7(p2) II . . n) I 1= Vx: p1(x) &amp; p2(x) &amp;.. .&amp; p,,(x) = F iff f7(PI)AP2) • • APO} is not unifiable where I is the set of logical axioms derive</context>
</contexts>
<marker>Patten, 1986</marker>
<rawString>Patten, Terry A. 1986 Interpreting Systemic Grammar as a Computational Representation: A Problem Solving Approach to Text Generation. PhD thesis, University of Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John C Reynolds</author>
</authors>
<title>Transformational Systems and the Algebraic Structure of Atomic Formulas.</title>
<date>1970</date>
<booktitle>In Meltzer, Bernard and Michie, Donald, Eds., Machine Intelligence 5.</booktitle>
<publisher>Edinburgh University Press.</publisher>
<contexts>
<context position="1434" citStr="Reynolds (1970)" startWordPosition="218" endWordPosition="219">een as forming a lattice with least upper bound and greatest lower bound operations. In a class of applications (such as parsing and generation) that require incremental description refinement, we are only really interested in forming new conjunctions (greatest lower bounds) and testing subsumption relationships. If one factors out the complexity of variable renaming and introduces special top and bottom elements, the set of logical terms also forms a lattice (the lattice of Generalised Atomic Formulae —&amp;quot;GAF lattice&amp;quot;) under the partial ordering relation &amp;quot;is equally or more instantiated than&amp;quot; (Reynolds (1970)). In this lattice, the greatest lower bound operation is unification (Robinson (1965)). Unification is a primitive operation in most logic programming systems and is also the basis of various grammatical formalisms. It is therefore a relatively well understood operation and can be efficiently implemented. In this paper, we investigate to what extent it is possible to find structure-preserving mappings from the description spaces defined by system networks to sublattices of the GAF lattice. Where this is possible, we can use a fixed mapping from property names to logical terms to create terms </context>
<context position="16027" citStr="Reynolds (1970)" startWordPosition="2530" endWordPosition="2531">tics Volume 14, Number 1, Winter 1988 43 C.S. Mellish Implementing Systemic Classification by Unification f(y,z) x f(a,x) f(y,z) f(f(x)) f(y) Just as we formed a lattice from descriptions, collapsing together two descriptions that were logically equivalent, so we can form a lattice from logical terms, collapsing together terms which are &amp;quot;variants&amp;quot; (i.e., terms t1 and t2 such that ti t2 and t2 ti). This lattice, with a necessarily slightly altered version of defined on it and with special &amp;quot;top&amp;quot; and &amp;quot;bottom&amp;quot; terms added, is the lattice of Generalised Atomic Formulae (&amp;quot;GAF lattice&amp;quot;) discussed by Reynolds (1970). In this lattice, the greatest lower bound operation is unification Robinson (1965), although for various sublattices the actual operation may be simpler. The main point of this paper is to investigate when a structure-preserving mapping (1-1, 0-preserving meet homomorphism) can be found from the description lattice arising from a system network to the GAF lattice. Where this is possible, we can use the mapping from property names to logical terms to make terms that correspond to conjunctive descriptions (by unification) and to test subsumption (by testing &amp;quot;less instantiated than&amp;quot;). Incompati</context>
</contexts>
<marker>Reynolds, 1970</marker>
<rawString>Reynolds, John C. 1970 Transformational Systems and the Algebraic Structure of Atomic Formulas. In Meltzer, Bernard and Michie, Donald, Eds., Machine Intelligence 5. Edinburgh University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Alan Robinson</author>
</authors>
<title>A Machine-Oriented Logic Based on the Resolution Principle.</title>
<date>1965</date>
<journal>JACM</journal>
<volume>12</volume>
<pages>23--41</pages>
<contexts>
<context position="1520" citStr="Robinson (1965)" startWordPosition="231" endWordPosition="232">n a class of applications (such as parsing and generation) that require incremental description refinement, we are only really interested in forming new conjunctions (greatest lower bounds) and testing subsumption relationships. If one factors out the complexity of variable renaming and introduces special top and bottom elements, the set of logical terms also forms a lattice (the lattice of Generalised Atomic Formulae —&amp;quot;GAF lattice&amp;quot;) under the partial ordering relation &amp;quot;is equally or more instantiated than&amp;quot; (Reynolds (1970)). In this lattice, the greatest lower bound operation is unification (Robinson (1965)). Unification is a primitive operation in most logic programming systems and is also the basis of various grammatical formalisms. It is therefore a relatively well understood operation and can be efficiently implemented. In this paper, we investigate to what extent it is possible to find structure-preserving mappings from the description spaces defined by system networks to sublattices of the GAF lattice. Where this is possible, we can use a fixed mapping from property names to logical terms to create terms that represent conjunctive descriptions (by unification) and to test subsumption (by t</context>
<context position="16111" citStr="Robinson (1965)" startWordPosition="2542" endWordPosition="2544">cation by Unification f(y,z) x f(a,x) f(y,z) f(f(x)) f(y) Just as we formed a lattice from descriptions, collapsing together two descriptions that were logically equivalent, so we can form a lattice from logical terms, collapsing together terms which are &amp;quot;variants&amp;quot; (i.e., terms t1 and t2 such that ti t2 and t2 ti). This lattice, with a necessarily slightly altered version of defined on it and with special &amp;quot;top&amp;quot; and &amp;quot;bottom&amp;quot; terms added, is the lattice of Generalised Atomic Formulae (&amp;quot;GAF lattice&amp;quot;) discussed by Reynolds (1970). In this lattice, the greatest lower bound operation is unification Robinson (1965), although for various sublattices the actual operation may be simpler. The main point of this paper is to investigate when a structure-preserving mapping (1-1, 0-preserving meet homomorphism) can be found from the description lattice arising from a system network to the GAF lattice. Where this is possible, we can use the mapping from property names to logical terms to make terms that correspond to conjunctive descriptions (by unification) and to test subsumption (by testing &amp;quot;less instantiated than&amp;quot;). Incompatibility of descriptions is also indicated by unification failure. We will initially i</context>
</contexts>
<marker>Robinson, 1965</marker>
<rawString>Robinson, J. Alan. 1965 A Machine-Oriented Logic Based on the Resolution Principle. JACM 12, 23-41.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kazunori Ueda</author>
</authors>
<title>Making Exhaustive Search Programs Deterministic.</title>
<date>1986</date>
<booktitle>In Shapiro, Ehud, Ed., Procs of the Third International Conference on Logic Programming.</booktitle>
<publisher>Springer Verlag.</publisher>
<contexts>
<context position="37172" citStr="Ueda (1986)" startWordPosition="6170" endWordPosition="6171"> great deal of parallelism available, one could use it to implement a naive network searcher for testing compatibility of two properties (e.g., by searching for the rightmost node that appears to the left of both and seeing whether the connective at that point is &amp;quot;I&amp;quot;. The implementation via unification would then be unnecessary (at least for simple cases). Thus to a certain extent the &amp;quot;compilation&amp;quot; of tasks like compatibility- and subsumption-checking into unification tasks can be viewed as a special case of compiling OR-parallel programs into AND-parallel programs (Codish and Shapiro (1986), Ueda (1986)). The checking can be even faster if the unifications are further compiled (Warren (1977)). For instance, in the verb network, checking that a descrip48 Computational Linguistics Volume 14, Number 1, Winter 1988 C.S. Mellish Implementing Systemic Classification by Unification tion of a verb is compatible with &amp;quot;pres&amp;quot; simply amounts to seeing whether the third component of the term is not a function symbol different from &amp;quot;pres&amp;quot;. 8 INTRODUCING 4 99 We have intentionally left consideration of the &amp;quot;1&amp;quot; connective to its own section. This is because we have no general algorithm (apart from the above</context>
</contexts>
<marker>Ueda, 1986</marker>
<rawString>Ueda, Kazunori. 1986 Making Exhaustive Search Programs Deterministic. In Shapiro, Ehud, Ed., Procs of the Third International Conference on Logic Programming. Springer Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David H D Warren</author>
</authors>
<title>Implementing Prolog: Compiling Predicate Logic Programs:</title>
<date>1977</date>
<journal>Research Reports</journal>
<volume>39</volume>
<institution>Department of Artificial Intelligence, University of Edinburgh.</institution>
<contexts>
<context position="37262" citStr="Warren (1977)" startWordPosition="6184" endWordPosition="6185">cher for testing compatibility of two properties (e.g., by searching for the rightmost node that appears to the left of both and seeing whether the connective at that point is &amp;quot;I&amp;quot;. The implementation via unification would then be unnecessary (at least for simple cases). Thus to a certain extent the &amp;quot;compilation&amp;quot; of tasks like compatibility- and subsumption-checking into unification tasks can be viewed as a special case of compiling OR-parallel programs into AND-parallel programs (Codish and Shapiro (1986), Ueda (1986)). The checking can be even faster if the unifications are further compiled (Warren (1977)). For instance, in the verb network, checking that a descrip48 Computational Linguistics Volume 14, Number 1, Winter 1988 C.S. Mellish Implementing Systemic Classification by Unification tion of a verb is compatible with &amp;quot;pres&amp;quot; simply amounts to seeing whether the third component of the term is not a function symbol different from &amp;quot;pres&amp;quot;. 8 INTRODUCING 4 99 We have intentionally left consideration of the &amp;quot;1&amp;quot; connective to its own section. This is because we have no general algorithm (apart from the above &amp;quot;brute force&amp;quot; algorithm) for translating system networks with &amp;quot;1&amp;quot; connectives into logica</context>
</contexts>
<marker>Warren, 1977</marker>
<rawString>Warren, David H. D. 1977 Implementing Prolog: Compiling Predicate Logic Programs: Research Reports 39 and 40, Department of Artificial Intelligence, University of Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Terry Winograd</author>
</authors>
<title>Understanding Natural Language.</title>
<date>1972</date>
<publisher>Academic Press.</publisher>
<contexts>
<context position="26105" citStr="Winograd (1972)" startWordPosition="4232" endWordPosition="4233">CTIVES &amp;quot;I&amp;quot;, AND &amp;quot;{&amp;quot; If the only connective used in a system network is &amp;quot;I&amp;quot;, a particularly simple encoding scheme is feasible. This technique has been used in an ad hoc way in a number of language processing systems written in Prolog, and probably originates from Dahl (1977). Consider the example network depicted in Figure 8, expressing the top levels of classification normally used for the plant kingdom. For such a simple network, we can use vascular function symbols more than one argument. Such a system has been used by McCord (1986). Figure 9 depicts a version of the &amp;quot;verb&amp;quot; network used by Winograd (1972), simplified to use only &amp;quot;I&amp;quot; and &amp;quot;{&amp;quot;. One possible translation from the above property symbols into terms includes the following: 7(vb) = vb(_,_) 7(vprt) = vb(vprt,_) T(aux) = vb(aux(_,_,),_) psilopsidan sphenopsidan lycopsidan C.S. Mellish plant gymnospermal angiospermal pteropsidan bacterial fungal algal bryophyte non_vascular nesting as a means of capturing the subsumption relationships in logical terms. Thus each property, apart from properties at the &amp;quot;leaves&amp;quot; of the tree, is associated with a unary function symbol, and the argument of a function symbol is used for a more &amp;quot;fine grained&amp;quot; de</context>
</contexts>
<marker>Winograd, 1972</marker>
<rawString>Winograd, Terry. 1972 Understanding Natural Language. Academic Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Terry Winograd</author>
</authors>
<title>Language as a Cognitive Process. Volume 1: Syntax.</title>
<date>1983</date>
<publisher>Addison Wesley.</publisher>
<contexts>
<context position="3238" citStr="Winograd (1983)" startWordPosition="493" endWordPosition="494">re co-occurrence tests using the same mechanism. (3) They may enable us to make formal sense of various ad-hoc mechanisms used by logic programmers in natural language processing. (4) By exposing the nature of the relevant description spaces, they may open various possibilities for the implementation of other classification tasks, e.g., concept learning (Mellish forthcoming). (5) They may give us more insight into the semantics of system networks and the potential of unification. 1 HALLIDAY&apos;S SYSTEM NETWORKS System networks, as used in Halliday&apos;s Systemic Grammar (Hudson (1971), Kress (1976), Winograd (1983)) are a way of encoding the choices that must be made in the generation of a complex linguistic object and the interdependencies between them. There is actually nothing that makes such networks specific to linguistic applications, and so there is no reason why they cannot be applied to describing the choices involved in other complex situations. A system network can be viewed as a graph, some of whose nodes are annotated with symbols representing properties. The nodes are tied together by the use of four different &amp;quot;connectives&amp;quot;, which we shall designate by &amp;quot;I&amp;quot;, &amp;quot;{&amp;quot;, &amp;quot;}&amp;quot; and &amp;quot;1&amp;quot;. In order to be</context>
<context position="6943" citStr="Winograd (1983)" startWordPosition="1097" endWordPosition="1098">eans third sing simply: V x: third(x) &amp; sing(x) gender(x) Finally, &amp;quot;1&amp;quot; introduces a disjunctive entry condition, so that the example provided in Figure 4 personal demonstr means: V x: personal(x) v demonstr(x) number(x) By convention, uses of the four &amp;quot;connectives&amp;quot; can be connected together in any way, as long as &amp;quot;loops&amp;quot; are not created. That is, if one regards each connective as a set of arcs going from properties on its &amp;quot;left&amp;quot; to properties on its &amp;quot;right&amp;quot;, the resulting directed graph must be acyclic. As a larger example, Figure 5 depicts the system network for English pronouns presented in Winograd (1983)). Here is a logical translation of selected parts. V x: AMO {first(x) second(x) third(x)} V x: person(x) first(x) v second(x) v third(x) V x: AMO {singular(x) plural(x)} V x: numb(x) singular(x) v plural(x) V x: third(x) &amp; singular(x) gender(x) It is important to note that in this paper we consider system networks as a self-contained notation for describing certain types of choices (&amp;quot;systemic choices&amp;quot;) that are available in the construction of a complex (linguistic) object. We will be completely ignoring the philosophical differences between Systemic Grammar and other forms of generative gram</context>
</contexts>
<marker>Winograd, 1983</marker>
<rawString>Winograd, Terry. 1983 Language as a Cognitive Process. Volume 1: Syntax. Addison Wesley.</rawString>
</citation>
<citation valid="false">
<authors>
<author>NOTES</author>
</authors>
<title>Author&apos;s current address:</title>
<booktitle>80 South Bridge, EDINBURGH EH1 1HN,</booktitle>
<institution>Department of Artificial Intelligence, University of Edinburgh,</institution>
<location>Scotland.</location>
<marker>NOTES, </marker>
<rawString>NOTES 1. Author&apos;s current address: Department of Artificial Intelligence, University of Edinburgh, 80 South Bridge, EDINBURGH EH1 1HN, Scotland.</rawString>
</citation>
<citation valid="false">
<date>1988</date>
<volume>14</volume>
<pages>51</pages>
<institution>Computational Linguistics</institution>
<location>Winter</location>
<marker>1988</marker>
<rawString>Computational Linguistics Volume 14, Number 1, Winter 1988 51</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>