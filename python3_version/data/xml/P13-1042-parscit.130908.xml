<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000011">
<title confidence="0.997738">
Large-scale Semantic Parsing via Schema Matching and Lexicon
Extension
</title>
<author confidence="0.995003">
Qingqing Cai
</author>
<affiliation confidence="0.946866">
Temple University
Computer and Information Sciences
</affiliation>
<email confidence="0.990993">
qingqing.cai@temple.edu
</email>
<sectionHeader confidence="0.99468" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9991488125">
Supervised training procedures for seman-
tic parsers produce high-quality semantic
parsers, but they have difficulty scaling
to large databases because of the sheer
number of logical constants for which
they must see labeled training data. We
present a technique for developing seman-
tic parsers for large databases based on
a reduction to standard supervised train-
ing algorithms, schema matching, and pat-
tern learning. Leveraging techniques from
each of these areas, we develop a semantic
parser for Freebase that is capable of pars-
ing questions with an F1 that improves by
0.42 over a purely-supervised learning al-
gorithm.
</bodyText>
<sectionHeader confidence="0.998427" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999926791666667">
Semantic parsing is the task of translating natural
language utterances to a formal meaning represen-
tation language (Chen et al., 2010; Liang et al.,
2009; Clarke et al., 2010; Liang et al., 2011; Artzi
and Zettlemoyer, 2011). There has been recent in-
terest in producing such semantic parsers for large,
heterogeneous databases like Freebase (Krishna-
murthy and Mitchell, 2012; Cai and Yates, 2013)
and Yago2 (Yahya et al., 2012), which has driven
the development of semi-supervised and distantly-
supervised training methods for semantic parsing.
Previous purely-supervised approaches have been
limited to smaller domains and databases, such as
the GeoQuery database, in part because of the cost
of labeling enough samples to cover all of the log-
ical constants involved in a domain.
This paper investigates a reduction of the prob-
lem of building a semantic parser to three stan-
dard problems in semantics and machine learning:
supervised training of a semantic parser, schema
matching, and pattern learning. Figure 1 provides
a visualization of our system architecture. We
apply an existing supervised training algorithm
for semantic parsing to a labeled data set. We
</bodyText>
<note confidence="0.73391075">
Alexander Yates
Temple University
Computer and Information Sciences
yates@temple.edu
</note>
<figureCaption confidence="0.964569">
Figure 1: We reduce the task of learning a large-
</figureCaption>
<bodyText confidence="0.976892892857143">
scale semantic parser to a combination of 1) a
standard supervised algorithm for learning seman-
tic parsers; 2) our MATCHER algorithm for find-
ing correspondences between words and database
symbols; and 3) our LEXTENDER algorithm for
integrating (word, database symbol) matches into
a semantic parsing lexicon.
apply schema matching techniques to the prob-
lem of finding correspondences between English
words w and ontological symbols s. And we ap-
ply pattern learning techniques to incorporate new
(w, s) pairs into the lexicon of the trained seman-
tic parser.
This reduction allows us to apply standard tech-
niques from each problem area, which in com-
bination provide a large improvement over the
purely-supervised approaches. On a dataset of
917 questions taken from 81 domains of the Free-
base database, a standard learning algorithm for
semantic parsing yields a parser with an F1 of
0.21, in large part because of the number of log-
ical symbols that appear during testing but never
appear during training. Our techniques can extend
this parser to new logical symbols through schema
matching, and yield a semantic parser with an F1
of 0.63 on the same task. On a more challenging
task where training and test data are divided so that
all logical constants in test are never observed dur-
</bodyText>
<figure confidence="0.998781608695652">
Freebase PCCG
Grammar and
Lexicon
Test questions
(sentence,
logical form)
Training data
Supervised
Semantic
Parser
Learning
High-Coverage Freebase
PCCG Grammar and
Lexicon
Freebase
LEXTENDER
MATCHER
Web
(word, Freebase symbol)
correspondences
Relations
Extracted
from Web
</figure>
<page confidence="0.992829">
423
</page>
<note confidence="0.914024">
Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, pages 423–433,
Sofia, Bulgaria, August 4-9 2013. c�2013 Association for Computational Linguistics
</note>
<bodyText confidence="0.999816529411765">
ing training, our approach yields a semantic parser
with an F1 of 0.6, whereas the purely supervised
approach cannot parse a single test question cor-
rectly. These results indicate that it is possible to
automatically extend semantic parsers to symbols
for which little or no training data has been ob-
served.
The rest of this paper is organized as follows.
The next section discusses related work. Section 3
describes our MATCHER algorithm for performing
schema matching between a knowledge base and
text. Section 4 explains how we use MATCHER’s
schema matching to extend a standard semantic
parser to logical symbols for which it has seen no
labeled training data. Section 5 analyzes the per-
formance of MATCHER and our semantic parser.
Section 6 concludes.
</bodyText>
<sectionHeader confidence="0.996894" genericHeader="introduction">
2 Previous Work
</sectionHeader>
<bodyText confidence="0.999973074074074">
Two existing systems translate between natural
language questions and database queries over
large-scale databases. Yahya et al. (2012) re-
port on a system for translating natural language
queries to SPARQL queries over the Yago2 (Hof-
fart et al., 2013) database. Yago2 consists of
information extracted from Wikipedia, WordNet,
and other resources using manually-defined ex-
traction patterns. The manual extraction patterns
pre-define a link between natural language terms
and Yago2 relations. Our techniques automate
the process of identifying matches between tex-
tual phrases and database relation symbols, in or-
der to scale up to databases with more relations,
like Freebase. A more minor difference between
Yahya et al.’s work and ours is that their system
handles SPARQL queries, which do not handle ag-
gregation queries like argmax and count. We
rely on an existing semantic parsing technology
to learn the language that will translate into such
aggregation queries. On the other hand, their test
questions involve more conjunctions and complex
semantics than ours. Developing a dataset with
more complicated semantics in the queries is part
of our ongoing efforts.
Krishnamurthy and Mitchell (2012) also cre-
ate a semantic parser for Freebase covering 77
of Freebase’s over 2000 relations. Like our
work, their technique uses distant supervision to
drive training over a collection of sentences gath-
ered from the Web, and they do not require any
manually-labeled training data. However, their
technique does require manual specification of
rules that construct CCG lexical entries from de-
pendency parses. In comparison, we fully auto-
mate the process of constructing CCG lexical en-
tries for the semantic parser by making it a pre-
diction task. We also leverage synonym-matching
techniques for comparing relations extracted from
text with Freebase relations. Finally, we test our
results on a dataset of 917 questions covering
over 600 Freebase relations, a more extensive test
than the 50 questions used by Krishnamurthy and
Mitchell.
Numerous methods exist for comparing two re-
lations based on their sets of tuples. For instance,
the DIRT system (Lin and Pantel, 2001) uses the
mutual information between the (X, Y ) argument
pairs for two binary relations to measure the sim-
ilarity between them, and clusters relations ac-
cordingly. More recent examples of similar tech-
niques include the Resolver system (Yates and Et-
zioni, 2009) and Poon and Domingos’s USP sys-
tem (Poon and Domingos, 2009). Our techniques
for comparing relations fit into this line of work,
but they are novel in their application of these
techniques to the task of comparing database re-
lations and relations extracted from text.
Schema matching (Rahm and Bernstein, 2001;
Ehrig et al., 2004; Giunchiglia et al., 2005) is a
task from the database and knowledge representa-
tion community in which systems attempt to iden-
tify a “common schema” that covers the relations
defined in a set of databases or ontologies, and the
mapping between each individual database and the
common schema. Owing to the complexity of the
general case, researchers have resorted to defining
standard similarity metrics between relations and
attributes, as well as machine learning algorithms
for learning and predicting matches between rela-
tions (Doan et al., 2004; Wick et al., 2008b; Wick
et al., 2008a; Nottelmann and Straccia, 2007;
Berlin and Motro, 2006). These techniques con-
sider only matches between relational databases,
whereas we apply these ideas to matches between
Freebase and extracted relations. Schema match-
ing in the database sense often considers com-
plex matches between relations (Dhamanka et al.,
2004), whereas as our techniques are currently re-
stricted to matches involving one database relation
and one relation extracted from text.
</bodyText>
<page confidence="0.999369">
424
</page>
<sectionHeader confidence="0.983506" genericHeader="method">
3 Textual Schema Matching
</sectionHeader>
<subsectionHeader confidence="0.999352">
3.1 Problem Formulation
</subsectionHeader>
<bodyText confidence="0.999761868852459">
The textual schema matching task is to identify
natural language words and phrases that corre-
spond with each relation and entity in a fixed
schema for a relational database. To formalize this
task, we first introduce some notation.
A schema 5 = (E, R, C, I) consists of a
set of entities E, a set of relations R, a set of
categories C, and a set of instances I. Categories
are one-argument predicates (e.g., film(e)), and
relations are two- (or more-) argument predicates
(e.g., directed by(e1, e2)). Instances are
known tuples of entities that make a relation
or category true, such as film(Titanic)
or directed by(Titanic, James
Cameron). Fora given r E R (or c E C),
IS(r) indicates the set of known instances of r in
schema 5 (and likewise for IS(c)). Examples of
such schemas include Freebase (Bollacker et al.,
2008) and Yago2 (Hoffart et al., 2013). We say a
schema is a textual schema if it has been extracted
from free text, such as the Nell (Carlson et al.,
2010) and ReVerb (Fader et al., 2011) extracted
databases.
Given a textual schema T and a database
schema D, the textual schema matching task is to
identify an alignment or matching M C RT x RD
such that (rT, rD) E M if and only if rT can
be used to refer to rD in normal language usage.
The problem would be greatly simplified if
M were a 1-1 function, but in practice most
database relations can be referred to in many
ways by natural language users: for instance,
film actor can be referenced by the English
verbs “played,” “acted,” and “starred,” along
with morphological variants of them. In addi-
tion, many English verbs can refer to several
different relations in Freebase: “make” can refer
to computer processor manufacturer
or distilled spirits producer, among
many others. Our MATCHER algorithm for textual
schema matching handles this by producing a
confidence score for every possible (rT, rD) pair,
which downstream applications can then use to
reason about the possible alignments.
Even worse than the ambiguities in alignment,
some textual relations do not correspond with
any database relation exactly, but instead they
correspond with a projection of a relation, or a
join between multiple relations, or another com-
plex view of a database schema. As a sim-
ple example, “actress” corresponds to a subset
of the Freebase film actor relation that inter-
sects with the set {x: gender(x, female)I.
MATCHER can only determine that “actress”
aligns with film actor or not; it cannot pro-
duce an alignment between “actress” and a join of
film actor and gender. These more complex
alignments are an important consideration for fu-
ture work, but as our experiments will show, quite
useful alignments can be produced without han-
dling these more complex cases.
</bodyText>
<subsectionHeader confidence="0.999906">
3.2 Identifying candidate matches
</subsectionHeader>
<bodyText confidence="0.998674181818182">
MATCHER uses a generate-and-test architecture
for determining M. It uses a Web search engine
to issue queries for a database relation rD consist-
ing of all the entities in a tuple t E ID(rD). 1000
tuples for each rD are randomly chosen for issu-
ing queries. The system then retrieves matching
snippets from the search engine results. It uses
the top 10 results for each search engine query. It
then counts the frequency of each word type in the
set of retrieved snippets for rD. The top 500 non-
stopword word types are chosen as candidates for
matches with rD. We denote the candidate set for
rD as C(rD).
MATCHER’s threshold of 500 candidates for
C(rD) results in a maximum possible recall of just
less than 0.8 for the alignments in our dataset, but
even if we double the threshold to 1000, the re-
call improves only slightly to 0.82. We therefore
settled on 500 as a point with an acceptable upper
bound on recall, while also producing an accept-
able number of candidate terms for further pro-
cessing.
</bodyText>
<subsectionHeader confidence="0.999916">
3.3 Pattern-based match selection
</subsectionHeader>
<bodyText confidence="0.999977384615385">
The candidate pool C(rD) of 500 word types is
significantly smaller than the set of all textual re-
lations, but it is also extremely noisy. The can-
didates may include non-relation words, or other
frequent but unrelated words. They may also in-
clude words that are highly related to rD, but not
actually corresponding textual relations. For in-
stance, the candidate set for film director in
Freebase includes words like “directed,” but also
words like “film,” “movie,” “written,” “produced,”
and “starring.” We use a series of filters based on
synonym-detection techniques to help select the
true matching candidates from C(rD).
</bodyText>
<page confidence="0.997043">
425
</page>
<table confidence="0.993926333333333">
Pattern Condition Example
“rT in E” rT ends with “-ed” and E has “founded in 1989”
type datetime or location
“rT by E” rT ends with “-ed” “invented by Edison”
“rT such as E” rT ends with “-s” “directors such as Tarantino”
“E is a(n) rT” all cases “Paul Rudd is an actor”
</table>
<tableCaption confidence="0.999363">
Table 1: Patterns used by MATCHER as evidence of a match between rD and rT. E represents an entity
</tableCaption>
<bodyText confidence="0.98630003030303">
randomly selected from the tuples in ID(rD).
The first type of evidence we consider for
identifying true matches from C(rD) consists of
pattern-matching. Relation words that express rD
will often be found in complex grammatical con-
structions, and often they will be separated from
their entity arguments by long-distance dependen-
cies. However, over a large corpus, one would ex-
pect that in at least some cases, the relation word
will appear in a simple, relatively-unambiguous
grammatical construction that connects rT with
entities from rD. For instance, entities e from the
relationship automotive designer appearin
the pattern “designed by e” more than 100 times
as often as the next most-common patterns, “con-
sidered by e” and “worked by e.”
MATCHER use searches over the Web to count
the number of instances where a candidate rT ap-
pears in simple patterns that involve entities from
rD. Greater counts for these patterns yield greater
evidence of a correct match between rD and rT.
Table 1 provides a list of patterns that we consider.
For each rD and each rT E C(rD), MATCHER
randomly selects 10 entities from rD’s tuples to
include in its pattern queries. Two of the patterns
are targeted at past-tense verbs, and the other two
patterns at nominal relation words.
MATCHER computes statistics similar to point-
wise mutual information (PMI) (Turney, 2001) to
measure how related rD and rT are, for each pat-
tern p. Let c(p, rD, rT) indicate the sum of all the
counts for a particular pattern p, database relation,
and textual relation:
</bodyText>
<equation confidence="0.99503425">
fp(rT, rD) =
1: c(p, r&apos; D,rT) * c(p, rD, rT)
r� r�
D T
</equation>
<bodyText confidence="0.9997789375">
For the sum over all r&apos;D, we use all r&apos;D in Freebase
for which rT was extracted as a candidate.
One downside of the pattern-matching evidence
is the sheer number of queries it requires. Freebase
currently has over 2,000 relations. For each rD,
we have up to 500 candidate rT, up to 4 patterns,
and up to 10 entities per pattern. To cover all of
Freebase, MATCHER needs 2, 000x500x4x10 =
40 million queries, or just over 1.25 years if it
issues 1 query per second (we covered approxi-
mately one-quarter of Freebase’s relations in our
experiments). Using more patterns and more en-
tities per pattern are desirable for accumulating
more evidence about candidate matches, but there
is a trade-off with the time required to issue the
necessary queries.
</bodyText>
<subsectionHeader confidence="0.98258">
3.4 Comparing database relations with
extracted relations
</subsectionHeader>
<bodyText confidence="0.999875555555556">
Open Information Extraction (Open IE) systems
(Banko et al., 2007) can often provide a large set of
extracted tuples for a given rT, which MATCHER
can then use to make much more comprehensive
comparisons with the full tuple set for rD than the
pattern-matching technique allows.
MATCHER employs a form of PMI to compute
the degree of relatedness between rD and rT. In
its simplest form, MATCHER computes:
</bodyText>
<equation confidence="0.999391">
PMI(rT,rD) = |ID(rD) n IT(rT) |(1)
|ID(rD) |- |IT(rT)|
</equation>
<bodyText confidence="0.999723428571429">
While this PMI statistic is already quite useful, we
have found that in practice there are many cases
where an exact match between tuples in ID(rD)
and tuples in IT(rT) is too strict of a criterion.
MATCHER uses a variety of approximate matches
to compute variations of this statistic. Considered
as predictors for the true matches in M, these vari-
ations of the PMI statistic have a lower precision,
in that they are more likely to have high values
for incorrect matches. However, they also have a
higher recall: that is, they will have a high value
for correct candidates in C(rD) when the strict
version of PMI does not. Table 2 lists all the vari-
ations used by MATCHER.
</bodyText>
<equation confidence="0.734711">
c(p, rD, rT)
</equation>
<page confidence="0.793164">
426
</page>
<bodyText confidence="0.290714">
Statistics for (rT, rD) Φ(t) for tuple t = (e1, ... , en)
</bodyText>
<equation confidence="0.982894">
�
sκ(rT, rD) = tD∈ID(rD)
�
tT ∈IT (rT )
κ(tD, tT)
|ID(rD)|·|IT (rT )|
Viei (projection to one dimension)
(e1, ... , en) (full tuple)
Vσ(·)(eσ(1), ... , eσ(n)) (permutation)
0 sκ (rT ,rD)
sκ(rT, rD) =
</equation>
<tableCaption confidence="0.9157166">
Table 2: MATCHER statistics: for each κ func-
tion for comparing two tuples (given in Table 3),
MATCHER computes the statistics above to com-
pare rD and rT. The PMI statistic in Equation
1 corresponds to sκ where κ =strict match over
</tableCaption>
<equation confidence="0.958064333333333">
Φ =full tuples.
κ(t1, t2) for comparing tuples t1, t2
�
1, if Φ(t1) = Φ0(t2)
strict match:
0, otherwise.
1, if Vkcat(Φ(t1)k)
= cat(Φ0(t2)k)
0, otherwise.
</equation>
<bodyText confidence="0.957841869565217">
Table 3: MATCHER’s κ functions for computing
whether two tuples are similar. cat maps an entity
to a category (or type) in the schema. MATCHER
has a different κ function for each possible com-
bination of Φ and Φ0 functions, which are given in
Table 4.
MATCHER uses an API for the ReVerb Open
IE system1 (Fader et al., 2011) to collect I(rT),
for each rT. The API for ReVerb allows for rela-
tional queries in which some subset of the entity
strings, entity categories, and relation string are
specified. The API returns all matching triples;
types must match exactly, but relation or argument
strings in the query will match any relation or ar-
gument that contains the query string as a sub-
string. MATCHER queries ReVerb with three dif-
ferent types of queries for each rT, specifying the
types for both arguments, or just the type of the
first argument, or just the second argument. Types
for arguments are taken from the types of argu-
ments for a potentially matching rD in Freebase.
To avoid overwhelming the ReVerb servers, for
our experiments we limited MATCHER to queries
</bodyText>
<footnote confidence="0.953174">
1http://openie.cs.washington.edu/
</footnote>
<tableCaption confidence="0.525711">
Table 4: MATCHER’s Φ functions for projecting
or permuting a tuple. σ indicates a permutation of
the indices.
</tableCaption>
<bodyText confidence="0.991194333333333">
for the top 80 rT E C(rD), when they are ranked
according to frequency during the candidate iden-
tification process.
</bodyText>
<subsectionHeader confidence="0.828752">
3.5 Regression models for scoring candidates
</subsectionHeader>
<bodyText confidence="0.999985523809524">
Pattern statistics, the ReVerb statistics from Ta-
ble 2, and the count of rT during the candidate
identification step all provide evidence for correct
matches between rD and rT. MATCHER uses a re-
gression model to combine these various statistics
into a score for (rT, rD). The regression model
is a linear regression with least-squares parameter
estimation; we experimented with support vector
regression models with non-linear kernels, with
no significant improvements in accuracy. Section
5 explains the dataset we use to train this model.
Unlike a classifier, MATCHER does not output any
single matching M. However, downstream appli-
cations can easily convert MATCHER’s output into
a matching M by, for instance, selecting the top K
candidate rT values for each rD, or by selecting all
(rT, rD) pairs with a score over a chosen thresh-
old. Our experiments analyze MATCHER’s suc-
cess by comparing its performance across a range
of different values for the number of rT matches
for each rD.
</bodyText>
<sectionHeader confidence="0.753488" genericHeader="method">
4 Extending a Semantic Parser Using a
</sectionHeader>
<subsectionHeader confidence="0.797393">
Schema Alignment
</subsectionHeader>
<bodyText confidence="0.999487416666667">
An alignment between textual relations and
database relations has many possible uses: for ex-
ample, it might be used to allow queries over a
database to be answered using additional infor-
mation stored in an extracted relation store, or
it might be used to deduce clusters of synony-
mous relation words in English. Here, we de-
scribe an application in which we build a question-
answering system for Freebase by extending a
standard learning technique for semantic parsing
with schema alignment information.
As a starting point, we used the UBL system
</bodyText>
<figure confidence="0.903730125">
�sκ(r0D, rT)
r1D
s00(rT, rD) = |IT (rT )|
|ID(rD)|
⎧
⎨⎪
⎪⎩
type match:
</figure>
<page confidence="0.990106">
427
</page>
<bodyText confidence="0.996817545454545">
developed by Kwiatkowski et al. (2010) to learn
a semantic parser based on probabilistic Com-
binatory Categorial Grammar (PCCG). Source
code for UBL is freely available. Its authors
found that it achieves results competitive with the
state-of-the-art on a variety of standard semantic
parsing data sets, including Geo250 English (0.85
F1). Using a fixed CCG grammar and a procedure
based on unification in second-order logic, UBL
learns a lexicon A from the training data which
includes entries like:
</bodyText>
<subsectionHeader confidence="0.608812">
Example Lexical Entries
</subsectionHeader>
<bodyText confidence="0.8186885">
New York City �- NP : new york
neighborhoods in �-
</bodyText>
<equation confidence="0.953439">
S\NP/NP : AxAy.neighborhoods(x, y)
Example CCG Grammar Rules
X/Y : f Y : g ⇒ X : f(g)
Y : g X\Y : f ⇒ X : f(g)
</equation>
<bodyText confidence="0.985866592592593">
Using A, UBL selects a logical form z
for a sentence S by selecting the z with the
most likely parse derivations y: h(S) =
�
arg maxz y p(y, z|x; θ, A). The probabilistic
model is a log-linear model with features for lex-
ical entries used in the parse, as well as indi-
cator features for relation-argument pairs in the
logical form, to capture selectional preferences.
Inference (parsing) and parameter estimation are
driven by standard dynamic programming algo-
rithms (Clark and Curran, 2007), while lexicon
induction is based on a novel search procedure
through the space of possible higher-order logic
unification operations that yield the desired logi-
cal form for a training sentence.
Our Freebase data covers 81 of the 86 core do-
mains in Freebase, and 635 of its over 2000 re-
lations, but we wish to develop a semantic parser
that can scale to all of Freebase. UBL gets us part
of the way there, by inducing a PCCG grammar, as
well as lexical entries for function words that must
be handled in all domains. It can also learn lexical
entries for relations rD that appear in the training
data. However, UBL has no way to learn lexical
entries for the many valid (rT, rD) pairs that do
not appear during training.
We use MATCHER’s learned alignment to ex-
tend the semantic parser that we get from UBL
by automatically adding in lexical entries for Free-
base relations. Essentially, for each (rT, rD) from
MATCHER’s output, we wish to construct a lexi-
cal entry that states that rT’s semantics resembles
AxAy.rD(x, y). However, this simple process is
complicated by the fact that the semantic parser re-
quires two additional types of information for each
lexical entry: a syntactic category, and a weight.
Furthermore, for many cases the appropriate se-
mantics are significantly more complex than this
pattern.
To extend the learned semantic parser to a se-
mantic parser for all of Freebase, we introduce a
prediction task, which we call semantic lexicon ex-
tension: given a matching M together with scores
for each pair in M, predict the syntactic category
Syn, lambda-calculus semantics Sem, and weight
W for a full lexical entry for each (rT, rD) E M.
One advantage of the reduction approach to learn-
ing a semantic parser is that we can automatically
construct training examples for this prediction task
from the other components in the reduction. We
use the output lexical entries learned by UBL as
(potentially noisy) examples of true lexical entries
for (rT, rD) pairs where rT matches the word in
one of UBL’s lexical entries, and rD forms part
of the semantics in the same lexical entry. For
(rT, rD) pairs in M where rD occurs in UBL’s
lexical entries, but not paired with rT, we create
dummy “negative” lexical entries with very low
weights, one for each possible syntactic category
observed in all lexical entries. Note that in or-
der to train LEXTENDER, we need the output of
MATCHER for the relations in UBL’s training data,
as well as UBL’s output lexicon from the training
data.
Our system for this prediction task, which we
call LEXTENDER (for Lexicon eXtender), factors
into three components: P(Sem|rD, rT, score),
P(Syn|Sem, rD, rT, score), and
P(W |Syn, Sem, rD, rT, score). This factoriza-
tion is trivial in that it introduces no independence
assumptions, but it helps in designing models
for the task. We set the event space for random
variable Sem to be the set of all lambda calculus
expressions observed in UBL’s output lexicon,
modulo the names of specific Freebase relations.
For instance, if the lexicon includes two entries
whose semantics are AxAy . film actor(x, y) and
AxAy . book author(x, y), the event space would
include the single expression in which relations
film actor and book author were replaced by
</bodyText>
<page confidence="0.997823">
428
</page>
<bodyText confidence="0.999934653846154">
a new variable: ApAxAy.p(x, y). The final
semantics for a lexical entry is then constructed
by substituting rD for p, or more formally, by a
function application Sem(rD). The event space
for Syn consists of all syntactic categories in
UBL’s output lexicon, and W ranges over R.
LEXTENDER’s model for Sem and Syn are
Naive Bayes classifiers (NBC), with features for
the part-of-speech for rT (taken from a POS tag-
ger), the suffix of rT, the number of arguments of
rD, and the argument types of rD. For Syn, we
add a feature for the predicted value of Sem. For
W, we use a linear regression model whose fea-
tures are the score from MATCHER, the probabili-
ties from the Syn and Sem NBC models, and the
average weight of all lexical entries in UBL with
matching syntax and semantics. Using the pre-
dictions from these models, LEXTENDER extends
UBL’s learned lexicon with all possible lexical en-
tries with their predicted weights, although typi-
cally only a few lexical entries have high enough
weight to make a difference during parsing. Prun-
ing entries with low weights could improve the
memory and time requirements for parsing, but
these were not an issue in our experiments, so we
did not investigate this further.
</bodyText>
<sectionHeader confidence="0.999284" genericHeader="evaluation">
5 Experiments
</sectionHeader>
<bodyText confidence="0.999796555555556">
We conducted experiments to test the ability of
MATCHER and LEXTENDER to produce a se-
mantic parser for Freebase. We first analyze
MATCHER on the task of finding matches between
Freebase relations and textual relations. We then
compare the performance of the semantic parser
learned by UBL with its extension provided by
LEXTENDER on a dataset of English questions
posed to Freebase.
</bodyText>
<subsectionHeader confidence="0.967259">
5.1 Experimental Setup
</subsectionHeader>
<bodyText confidence="0.972325538461538">
Freebase (Bollacker et al., 2008) is a free,
online, user-contributed, relational database
(www.freebase.com) covering many different
domains of knowledge. The full schema and
contents are available for download. The “Free-
base Commons” subset of Freebase, which is our
focus, consists of 86 domains, an average of 25
relations per domain (total of 2134 relations),
and 615,000 known instances per domain (53
million instances total). As a reference point,
the GeoQuery database — which is a standard
benchmark database for semantic parsing —
Examples
</bodyText>
<listItem confidence="0.998796142857143">
1. What are the neighborhoods in New
York City?
Ax . neighborhoods(new york, x)
2. How many countries use the rupee?
count(x) . countries used(rupee,x)
3. How many Peabody Award winners are
there?
</listItem>
<equation confidence="0.719211333333333">
count(x) . ∃y . award honor(y) ∧
award winner(y, x) ∧
award(y, peabody award)
</equation>
<figureCaption confidence="0.79458">
Figure 2: Example questions with their logical
</figureCaption>
<bodyText confidence="0.946766851851852">
forms. The logical forms make use of Freebase
symbols as logical constants, as well as a few ad-
ditional symbols such as count and argmin, to
allow for aggregation queries.
contains a single domain (geography), 8 relations,
and 880 total instances.
Our dataset contains 917 questions (on aver-
age, 6.3 words per question) and a meaning repre-
sentation for each question written in a variant of
lambda calculus2. 81 domains are represented in
the data set, and the lambda calculus forms contain
635 distinct Freebase relations. The most com-
mon domains, film and business, each took
up no more than 6% of the overall dataset. Sev-
eral examples are listed in Fig. 2. The ques-
tions were provided by two native English speak-
ers. No restrictions were placed on the type of
questions they should produce, except that they
should produce questions for multiple domains.
By inspection, a large majority of the questions
appear to be answerable from Freebase, although
no instructions were given to restrict questions
to this sort. We also created a dataset of align-
ments from these annotated questions by creating
an alignment for each Freebase relation mentioned
in the logical form for a question, paired with a
manually-selected word from the question.
</bodyText>
<subsectionHeader confidence="0.999597">
5.2 Alignment Tests
</subsectionHeader>
<bodyText confidence="0.9997216">
We measured the precision and recall of
MATCHER’s output against the manually la-
beled data. Let M be the set of (rT, rD) matches
produced by the system, and G the set of matches
in the gold-standard manual data. We define
</bodyText>
<footnote confidence="0.990678">
2The data is available from the second author’s website.
</footnote>
<page confidence="0.997071">
429
</page>
<figureCaption confidence="0.8998565">
Figure 3: MATCHER’s Pattern features and Extrac-
tions features complement one another, so that in
combination they outperform either subset on its
own, especially at the high-recall end of the curve.
</figureCaption>
<bodyText confidence="0.922541">
precision and recall as:
</bodyText>
<equation confidence="0.994957">
P = |M ∩ G |R = |M ∩ G|
|M |,|G|
</equation>
<bodyText confidence="0.99996996">
Figure 3 shows a Precision-Recall (PR) curve
for MATCHER and three baselines: a “Frequency”
model that ranks candidate matches for rD by their
frequency during the candidate identification step;
a “Pattern” model that uses MATCHER’s linear re-
gression model for ranking, but is restricted to
only the pattern-based features; and an “Extrac-
tions” model that similarly restricts the ranking
model to ReVerb features. We have three folds in
our data; the alignments for relation rD in one fold
are predicted by models trained on the other two
folds. Once all of the alignments in all three folds
are scored, we generate points on the PR curve by
applying a threshold to the model’s ranking, and
treating all alignments above the threshold as the
set of predicted alignments.
All regression models for learning alignments
outperform the Frequency ranking by a wide mar-
gin. The Pattern model outperforms the Extrac-
tions model at the high-precision, low-recall end
of the curve. At the high-recall points, the Pat-
tern model drops quickly in precision. However,
the combination of the two kinds of features in
MATCHER yields improved precision at all levels
of recall.
</bodyText>
<subsectionHeader confidence="0.997894">
5.3 Semantic Parsing Tests
</subsectionHeader>
<bodyText confidence="0.999908696428572">
While our alignment tests can tell us in relative
terms how well different models are performing,
it is difficult to assess these models in absolute
terms, since alignments are not typical applica-
tions that people care about in their own right. We
now compare our alignments on a semantic pars-
ing task for Freebase.
In a first semantic parsing experiment, we train
UBL, MATCHER, and LEXTENDER on a random
sample of 70% of the questions, and test them
on the remaining 30%. In a second test, we fo-
cus on the hard case where all questions from the
test set contain logical constants that have never
been seen before during training. We split the
data into 3 folds, making sure that no Freebase do-
main has symbols appearing in questions in more
than one fold. We then perform 3-fold cross-
validation for all of our supervised models. We
varied the number of matches that the alignment
model (MATCHER, Pattern, Extractions, or Fre-
quency) could make for each Freebase relation,
and measured semantic parsing performance as a
function of the number of matches.
Figure 4 shows the F1 scores for these se-
mantic parsers, judged by exact match between
the top-scoring logical form from the parser and
the manually-produced logical form. Exact-match
tests are overly-strict, in the sense that the sys-
tem may be judged incorrect even when the log-
ical form that is produced is logically equivalent
to the correct logical form. However, by inspec-
tion such cases appear to be very rare in our data,
and the exact-match criterion is often used in other
semantic parsing experimental settings.
The semantic parsers produced by
MATCHER+LEXTENDER and the other alignment
techniques significantly outperform the baseline
semantic parser learned by UBL, which achieves
an overall F1 of 0.21 on these questions in the
70/30 split of the data, and an F1 of 0 in the
cross-domain experiment. Purely-supervised
approaches to this data are severely limited, since
they have almost no chance of correctly parsing
questions that refer to logical symbols that never
appeared during training. However, MATCHER
and LEXTENDER combine with UBL to produce
an effective semantic parser. The best semantic
parser we tested, which was produced by UBL,
MATCHER, and LEXTENDER with 9 matches per
Freebase relation, had a precision of 0.67 and a
recall of 0.59 on the 70/30 split experiment.
The difference in alignment performance be-
tween MATCHER, Pattern, and Extractions carries
over to semantic parsing. MATCHER drops in F1
with more matches as additional matches tend to
be low-quality and low-probability, whereas Pat-
</bodyText>
<figure confidence="0.9989286">
Precision
0.6
0.5
0.4
0.3
0.2
0.1
0
Alignment Predictions
0.2 0.4 0.6 0.8 1
Recall
Matcher
Extractions
Pattern
Frequency
</figure>
<page confidence="0.824828">
430
</page>
<figureCaption confidence="0.88630825">
Figure 4: Semantic parsers produced by UBL+MATCHER+LEXTENDER outperform the purely-
supervised baseline semantic parser on a random 70/30 split of the data (left) by as much as
0.42 in F1. In the case of this split and in the case of a cross-domain experiment (right),
UBL+MATCHER+LEXTENDER outperforms UBL+Pattern+LEXTENDER by as much as 0.06 in F1.
</figureCaption>
<figure confidence="0.9993976">
0.7
F1 for exact match
of logical forms
Matcher
Pattern
Extractions
Frequency
Baseline
0.6
0.5
0.4
0.3
0.2
0.1
0.7
Matcher
Extractions
Pattern
Frequency
F1 for exact match
of logical forms
0.6
0.5
0.4
0.3
0.2
0.1
Semantic Parsing (70/30 Split)
5 10 15 20 25 30
Number of Matches per Freebase Relation
0
Semantic Parsing (Cross-Domain)
5 10 15 20 25 30
Number of Matches per Freebase Relation
0
</figure>
<bodyText confidence="0.999485709677419">
tern and Extractions keep improving as more low-
probability alignments are added. Interestingly,
the Extractions model begins to overtake the Pat-
tern model in F1 at higher numbers of matches,
and all three models trend toward convergence in
F1 with increasing numbers of matches. Neverthe-
less, MATCHER clearly improves over both, and
reaches a higher F1 than either Pattern or Extrac-
tions using a small number of matches, which cor-
responds to a smaller lexicon and a leaner model.
To place these results in context, many different
semantic parsers for databases like GeoQuery and
ATIS (including parsers produced by UBL) have
achieved F1 scores of 0.85 and higher. However,
in all such tests, the test questions refer to logi-
cal constants that also appeared during training, al-
lowing supervised techniques for learning seman-
tic parsers to achieve strong accuracy. As we have
argued, Freebase is large enough that is difficult
to produce enough labeled training data to cover
all of its logical constants. An unsupervised se-
mantic parser for GeoQuery has achieved an F1
score of 0.66 (Goldwasser et al., 2011), impres-
sive in its own right and slightly better than our F1
score. However, this parser was given questions
which it knew a priori to contain words that re-
fer to the logical constants in the database. Our
MATCHER and LEXTENDER systems address a
different challenge: how to learn a semantic parser
for Freebase given the Web and a set of initial la-
beled questions.
</bodyText>
<sectionHeader confidence="0.999329" genericHeader="conclusions">
6 Conclusion
</sectionHeader>
<bodyText confidence="0.99979388">
Scaling semantic parsing to large databases re-
quires an engineering effort to handle large
datasets, but also novel algorithms to extend se-
mantic parsing models to testing examples that
look significantly different from labeled training
data. The MATCHER and LEXTENDER algo-
rithms represent an initial investigation into such
techniques, with early results indicating that se-
mantic parsers can handle Freebase questions on a
large variety of domains with an F1 of 0.63.
We hope that our techniques and datasets will
spur further research into this area. In particu-
lar, more research is needed to handle more com-
plex matches between database and textual rela-
tions, and to handle more complex natural lan-
guage queries. As mentioned in section 3.1, words
like “actress” cannot be addressed by the cur-
rent methodology, since MATCHER assumes that
a word maps to a single Freebase relation, but
the closest Freebase equivalent to the meaning of
“actress” involves the two relations film actor
and gender. Another limitation is that our cur-
rent methodology focuses on finding matches for
nouns and verbs. Other important limitations of
the current methodology include:
</bodyText>
<listItem confidence="0.973548">
• the assumption that function words have no
domain-specific meaning, which prepositions
in particular can violate;
• low accuracy when there are few relevant re-
sults among the set of extracted relations;
• and the restriction to a single database (Free-
base) for finding answers.
</listItem>
<bodyText confidence="0.999764">
While significant challenges remain, the reduction
of large-scale semantic parsing to a combination
of schema matching and supervised learning of-
fers a new path toward building high-coverage se-
mantic parsers.
</bodyText>
<page confidence="0.998627">
431
</page>
<sectionHeader confidence="0.983093" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999705028037384">
Yoav Artzi and Luke Zettlemoyer. 2011. Bootstrap-
ping Semantic Parsers from Conversations. In Pro-
ceedings of the Conference on Empirical Methods in
Natural Language Processing (EMNLP).
M. Banko, M. J. Cafarella, S. Soderland, M. Broad-
head, and O. Etzioni. 2007. Open information ex-
traction from the web. In IJCAI.
Jacob Berlin and Amihai Motro. 2006. Database
schema matching using machine learning with fea-
ture selection. In Advanced Information Systems
Engineering. Springer.
Kurt Bollacker, Colin Evans, Praveen Paritosh, Tim
Sturge, and Jamie Taylor. 2008. Freebase: A col-
laboratively created graph database for structuring
human knowledge. In Proceedings of the Interna-
tional Conference on Management of Data (SIG-
MOD), pages 1247–1250.
Qingqing Cai and Alexander Yates. 2013. Semantic
Parsing Freebase: Towards Open-Domain Semantic
Parsing. In Second Joint Conference on Lexical and
Computational Semantics.
Andrew Carlson, Justin Betteridge, Bryan Kisiel, Burr
Settles, Estevam R. Hruschka Jr., and Tom M.
Mitchell. 2010. Toward an Architecture for Never-
Ending Language Learning. In Proceedings of the
Twenty-Fourth Conference on Artificial Intelligence
(AAAI 2010).
David L. Chen, Joohyun Kim, and Raymond J.
Mooney. 2010. Training a Multilingual
Sportscaster: Using Perceptual Context to Learn
Language. Journal of Artificial Intelligence Re-
search, 37:397–435.
Stephen Clark and James R. Curran. 2007. Wide-
coverage efficient statistical parsing with ccg and
log-linear models. Computational Linguistics,
33(4):493–552.
J. Clarke, D. Goldwasser, M. Chang, and D. Roth.
2010. Driving semantic parsing from the world’s re-
sponse. In Computational Natural Language Learn-
ing (CoNLL).
R. Dhamanka, Y. Lee, A. Doan, A. Halevy, and
P. Domingos. 2004. iMAP: Discovering Complex
Semantic Matches between Database Schemas. In
SIGMOD.
A. Doan, J. Madhavan, P. Domingos, and A. Halevy.
2004. Ontology Matching: A Machine Learning
Approach. In S. Staab and R. Studer, editors, Hand-
book on Ontologies in Information Systems, pages
397–416. Springer-Verlag.
M. Ehrig, P. Haase, N. Stojanovic, and M. Hefke.
2004. Similarity for ontologies-a comprehensive
framework. In Workshop Enterprise Modelling and
Ontology: Ingredients for Interoperability, PAKM.
Anthony Fader, Stephen Soderland, and Oren Etzioni.
2011. Identifying Relations for Open Information
Extraction. In Conference on Empirical Methods in
Natural Language Processing (EMNLP).
Fausto Giunchiglia, Pavel Shvaiko, and Mikalai
Yatskevich. 2005. Semantic schema matching.
On the Move to Meaningful Internet Systems 2005:
CoopIS, DOA, and ODBASE, pages 347–365.
D. Goldwasser, R. Reichart, J. Clarke, and D. Roth.
2011. Confidence driven unsupervised semantic
parsing. In Association for Computational Linguis-
tics (ACL).
Johannes Hoffart, Fabian M. Suchanek, Klaus
Berberich, and Gerhard Weikum. 2013. YAGO2:
A Spatially and Temporally Enhanced Knowl-
edge Base from Wikipedia. Artificial Intelligence,
194:28–61, January.
Jayant Krishnamurthy and Tom Mitchell. 2012.
Weakly Supervised Training of Semantic Parsers. In
Proceedings of the Conference on Empirical Meth-
ods in Natural Language Processing (EMNLP).
Tom Kwiatkowski, Luke Zettlemoyer, Sharon Goldwa-
ter, and Mark Steedman. 2010. Inducing Probabilis-
tic CCG Grammars from Logical Form with Higher-
order Unification. In Proceedings of the Conference
on Empirical Methods in Natural Language Pro-
cessing (EMNLP).
P. Liang, M. I. Jordan, and D. Klein. 2009. Learning
semantic correspondences with less supervision. In
Association for Computational Linguistics and In-
ternational Joint Conference on Natural Language
Processing (ACL-IJCNLP).
P. Liang, M. I. Jordan, and D. Klein. 2011. Learn-
ing dependency-based compositional semantics. In
Association for Computational Linguistics (ACL).
D. Lin and P. Pantel. 2001. DIRT – Discovery of In-
ference Rules from Text. In KDD.
Henrik Nottelmann and Umberto Straccia. 2007. In-
formation retrieval and machine learning for proba-
bilistic schema matching. Information processing &amp;
management, 43(3):552–576.
Hoifung Poon and Pedro Domingos. 2009. Unsu-
pervised semantic parsing. In Proceedings of the
2009 Conference on Empirical Methods in Natu-
ral Language Processing, EMNLP ’09, pages 1–10,
Stroudsburg, PA, USA. Association for Computa-
tional Linguistics.
E. Rahm and P.A. Bernstein. 2001. A survey of ap-
proaches to automatic schema matching. The VLDB
Journal, 10:334–350.
P. D. Turney. 2001. Mining the Web for Synonyms:
PMI-IR versus LSA on TOEFL. In Procs. of the
Twelfth European Conference on Machine Learning
(ECML), pages 491–502, Freiburg, Germany.
</reference>
<page confidence="0.981934">
432
</page>
<reference confidence="0.998986571428572">
M. Wick, K. Rohanimanesh, A. McCallum, and A.H.
Doan. 2008a. A discriminative approach to ontol-
ogy mapping. In International Workshop on New
Trends in Information Integration (NTII) at VLDB
WS.
M.L. Wick, K. Rohanimanesh, K. Schultz, and A. Mc-
Callum. 2008b. A unified approach for schema
matching, coreference and canonicalization. In Pro-
ceeding of the 14th ACM SIGKDD international
conference on Knowledge discovery and data min-
ing.
Mohamed Yahya, Klaus Berberich, Shady Elbas-
suoni, Maya Ramanath, Volker Tresp, and Gerhard
Weikum. 2012. Natural Language Questions for the
Web of Data. In Proceedings of the Conference on
Empirical Methods in Natural Language Processing
(EMNLP).
Alexander Yates and Oren Etzioni. 2009. Unsuper-
vised methods for determining object and relation
synonyms on the web. Journal of Artificial Intelli-
gence Research (JAIR), 34:255–296, March.
</reference>
<page confidence="0.999436">
433
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.465652">
<title confidence="0.996375">Large-scale Semantic Parsing via Schema Matching and Lexicon Extension Qingqing</title>
<author confidence="0.905855">Temple</author>
<affiliation confidence="0.864847">Computer and Information</affiliation>
<email confidence="0.998054">qingqing.cai@temple.edu</email>
<abstract confidence="0.968245882352941">Supervised training procedures for semantic parsers produce high-quality semantic parsers, but they have difficulty scaling to large databases because of the sheer number of logical constants for which they must see labeled training data. We present a technique for developing semantic parsers for large databases based on a reduction to standard supervised training algorithms, schema matching, and pattern learning. Leveraging techniques from each of these areas, we develop a semantic parser for Freebase that is capable of parsing questions with an F1 that improves by 0.42 over a purely-supervised learning algorithm.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Yoav Artzi</author>
<author>Luke Zettlemoyer</author>
</authors>
<title>Bootstrapping Semantic Parsers from Conversations.</title>
<date>2011</date>
<booktitle>In Proceedings of the Conference on Empirical Methods in Natural Language Processing (EMNLP).</booktitle>
<contexts>
<context position="1032" citStr="Artzi and Zettlemoyer, 2011" startWordPosition="151" endWordPosition="154">ta. We present a technique for developing semantic parsers for large databases based on a reduction to standard supervised training algorithms, schema matching, and pattern learning. Leveraging techniques from each of these areas, we develop a semantic parser for Freebase that is capable of parsing questions with an F1 that improves by 0.42 over a purely-supervised learning algorithm. 1 Introduction Semantic parsing is the task of translating natural language utterances to a formal meaning representation language (Chen et al., 2010; Liang et al., 2009; Clarke et al., 2010; Liang et al., 2011; Artzi and Zettlemoyer, 2011). There has been recent interest in producing such semantic parsers for large, heterogeneous databases like Freebase (Krishnamurthy and Mitchell, 2012; Cai and Yates, 2013) and Yago2 (Yahya et al., 2012), which has driven the development of semi-supervised and distantlysupervised training methods for semantic parsing. Previous purely-supervised approaches have been limited to smaller domains and databases, such as the GeoQuery database, in part because of the cost of labeling enough samples to cover all of the logical constants involved in a domain. This paper investigates a reduction of the p</context>
</contexts>
<marker>Artzi, Zettlemoyer, 2011</marker>
<rawString>Yoav Artzi and Luke Zettlemoyer. 2011. Bootstrapping Semantic Parsers from Conversations. In Proceedings of the Conference on Empirical Methods in Natural Language Processing (EMNLP).</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Banko</author>
<author>M J Cafarella</author>
<author>S Soderland</author>
<author>M Broadhead</author>
<author>O Etzioni</author>
</authors>
<title>Open information extraction from the web. In IJCAI.</title>
<date>2007</date>
<contexts>
<context position="15739" citStr="Banko et al., 2007" startWordPosition="2560" endWordPosition="2563"> up to 500 candidate rT, up to 4 patterns, and up to 10 entities per pattern. To cover all of Freebase, MATCHER needs 2, 000x500x4x10 = 40 million queries, or just over 1.25 years if it issues 1 query per second (we covered approximately one-quarter of Freebase’s relations in our experiments). Using more patterns and more entities per pattern are desirable for accumulating more evidence about candidate matches, but there is a trade-off with the time required to issue the necessary queries. 3.4 Comparing database relations with extracted relations Open Information Extraction (Open IE) systems (Banko et al., 2007) can often provide a large set of extracted tuples for a given rT, which MATCHER can then use to make much more comprehensive comparisons with the full tuple set for rD than the pattern-matching technique allows. MATCHER employs a form of PMI to compute the degree of relatedness between rD and rT. In its simplest form, MATCHER computes: PMI(rT,rD) = |ID(rD) n IT(rT) |(1) |ID(rD) |- |IT(rT)| While this PMI statistic is already quite useful, we have found that in practice there are many cases where an exact match between tuples in ID(rD) and tuples in IT(rT) is too strict of a criterion. MATCHER</context>
</contexts>
<marker>Banko, Cafarella, Soderland, Broadhead, Etzioni, 2007</marker>
<rawString>M. Banko, M. J. Cafarella, S. Soderland, M. Broadhead, and O. Etzioni. 2007. Open information extraction from the web. In IJCAI.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jacob Berlin</author>
<author>Amihai Motro</author>
</authors>
<title>Database schema matching using machine learning with feature selection.</title>
<date>2006</date>
<booktitle>In Advanced Information Systems Engineering.</booktitle>
<publisher>Springer.</publisher>
<contexts>
<context position="8028" citStr="Berlin and Motro, 2006" startWordPosition="1249" endWordPosition="1252">2005) is a task from the database and knowledge representation community in which systems attempt to identify a “common schema” that covers the relations defined in a set of databases or ontologies, and the mapping between each individual database and the common schema. Owing to the complexity of the general case, researchers have resorted to defining standard similarity metrics between relations and attributes, as well as machine learning algorithms for learning and predicting matches between relations (Doan et al., 2004; Wick et al., 2008b; Wick et al., 2008a; Nottelmann and Straccia, 2007; Berlin and Motro, 2006). These techniques consider only matches between relational databases, whereas we apply these ideas to matches between Freebase and extracted relations. Schema matching in the database sense often considers complex matches between relations (Dhamanka et al., 2004), whereas as our techniques are currently restricted to matches involving one database relation and one relation extracted from text. 424 3 Textual Schema Matching 3.1 Problem Formulation The textual schema matching task is to identify natural language words and phrases that correspond with each relation and entity in a fixed schema f</context>
</contexts>
<marker>Berlin, Motro, 2006</marker>
<rawString>Jacob Berlin and Amihai Motro. 2006. Database schema matching using machine learning with feature selection. In Advanced Information Systems Engineering. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kurt Bollacker</author>
<author>Colin Evans</author>
<author>Praveen Paritosh</author>
<author>Tim Sturge</author>
<author>Jamie Taylor</author>
</authors>
<title>Freebase: A collaboratively created graph database for structuring human knowledge.</title>
<date>2008</date>
<booktitle>In Proceedings of the International Conference on Management of Data (SIGMOD),</booktitle>
<pages>1247--1250</pages>
<contexts>
<context position="9302" citStr="Bollacker et al., 2008" startWordPosition="1459" endWordPosition="1462">e first introduce some notation. A schema 5 = (E, R, C, I) consists of a set of entities E, a set of relations R, a set of categories C, and a set of instances I. Categories are one-argument predicates (e.g., film(e)), and relations are two- (or more-) argument predicates (e.g., directed by(e1, e2)). Instances are known tuples of entities that make a relation or category true, such as film(Titanic) or directed by(Titanic, James Cameron). Fora given r E R (or c E C), IS(r) indicates the set of known instances of r in schema 5 (and likewise for IS(c)). Examples of such schemas include Freebase (Bollacker et al., 2008) and Yago2 (Hoffart et al., 2013). We say a schema is a textual schema if it has been extracted from free text, such as the Nell (Carlson et al., 2010) and ReVerb (Fader et al., 2011) extracted databases. Given a textual schema T and a database schema D, the textual schema matching task is to identify an alignment or matching M C RT x RD such that (rT, rD) E M if and only if rT can be used to refer to rD in normal language usage. The problem would be greatly simplified if M were a 1-1 function, but in practice most database relations can be referred to in many ways by natural language users: f</context>
<context position="26589" citStr="Bollacker et al., 2008" startWordPosition="4424" endWordPosition="4427">ries with low weights could improve the memory and time requirements for parsing, but these were not an issue in our experiments, so we did not investigate this further. 5 Experiments We conducted experiments to test the ability of MATCHER and LEXTENDER to produce a semantic parser for Freebase. We first analyze MATCHER on the task of finding matches between Freebase relations and textual relations. We then compare the performance of the semantic parser learned by UBL with its extension provided by LEXTENDER on a dataset of English questions posed to Freebase. 5.1 Experimental Setup Freebase (Bollacker et al., 2008) is a free, online, user-contributed, relational database (www.freebase.com) covering many different domains of knowledge. The full schema and contents are available for download. The “Freebase Commons” subset of Freebase, which is our focus, consists of 86 domains, an average of 25 relations per domain (total of 2134 relations), and 615,000 known instances per domain (53 million instances total). As a reference point, the GeoQuery database — which is a standard benchmark database for semantic parsing — Examples 1. What are the neighborhoods in New York City? Ax . neighborhoods(new york, x) 2.</context>
</contexts>
<marker>Bollacker, Evans, Paritosh, Sturge, Taylor, 2008</marker>
<rawString>Kurt Bollacker, Colin Evans, Praveen Paritosh, Tim Sturge, and Jamie Taylor. 2008. Freebase: A collaboratively created graph database for structuring human knowledge. In Proceedings of the International Conference on Management of Data (SIGMOD), pages 1247–1250.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Qingqing Cai</author>
<author>Alexander Yates</author>
</authors>
<title>Semantic Parsing Freebase: Towards Open-Domain Semantic Parsing.</title>
<date>2013</date>
<booktitle>In Second Joint Conference on Lexical and Computational Semantics.</booktitle>
<contexts>
<context position="1204" citStr="Cai and Yates, 2013" startWordPosition="177" endWordPosition="180">g. Leveraging techniques from each of these areas, we develop a semantic parser for Freebase that is capable of parsing questions with an F1 that improves by 0.42 over a purely-supervised learning algorithm. 1 Introduction Semantic parsing is the task of translating natural language utterances to a formal meaning representation language (Chen et al., 2010; Liang et al., 2009; Clarke et al., 2010; Liang et al., 2011; Artzi and Zettlemoyer, 2011). There has been recent interest in producing such semantic parsers for large, heterogeneous databases like Freebase (Krishnamurthy and Mitchell, 2012; Cai and Yates, 2013) and Yago2 (Yahya et al., 2012), which has driven the development of semi-supervised and distantlysupervised training methods for semantic parsing. Previous purely-supervised approaches have been limited to smaller domains and databases, such as the GeoQuery database, in part because of the cost of labeling enough samples to cover all of the logical constants involved in a domain. This paper investigates a reduction of the problem of building a semantic parser to three standard problems in semantics and machine learning: supervised training of a semantic parser, schema matching, and pattern le</context>
</contexts>
<marker>Cai, Yates, 2013</marker>
<rawString>Qingqing Cai and Alexander Yates. 2013. Semantic Parsing Freebase: Towards Open-Domain Semantic Parsing. In Second Joint Conference on Lexical and Computational Semantics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andrew Carlson</author>
<author>Justin Betteridge</author>
<author>Bryan Kisiel</author>
<author>Burr Settles</author>
<author>Estevam R Hruschka Jr</author>
<author>Tom M Mitchell</author>
</authors>
<title>Toward an Architecture for NeverEnding Language Learning.</title>
<date>2010</date>
<booktitle>In Proceedings of the Twenty-Fourth Conference on Artificial Intelligence (AAAI</booktitle>
<contexts>
<context position="9453" citStr="Carlson et al., 2010" startWordPosition="1489" endWordPosition="1492">tances I. Categories are one-argument predicates (e.g., film(e)), and relations are two- (or more-) argument predicates (e.g., directed by(e1, e2)). Instances are known tuples of entities that make a relation or category true, such as film(Titanic) or directed by(Titanic, James Cameron). Fora given r E R (or c E C), IS(r) indicates the set of known instances of r in schema 5 (and likewise for IS(c)). Examples of such schemas include Freebase (Bollacker et al., 2008) and Yago2 (Hoffart et al., 2013). We say a schema is a textual schema if it has been extracted from free text, such as the Nell (Carlson et al., 2010) and ReVerb (Fader et al., 2011) extracted databases. Given a textual schema T and a database schema D, the textual schema matching task is to identify an alignment or matching M C RT x RD such that (rT, rD) E M if and only if rT can be used to refer to rD in normal language usage. The problem would be greatly simplified if M were a 1-1 function, but in practice most database relations can be referred to in many ways by natural language users: for instance, film actor can be referenced by the English verbs “played,” “acted,” and “starred,” along with morphological variants of them. In addition</context>
</contexts>
<marker>Carlson, Betteridge, Kisiel, Settles, Jr, Mitchell, 2010</marker>
<rawString>Andrew Carlson, Justin Betteridge, Bryan Kisiel, Burr Settles, Estevam R. Hruschka Jr., and Tom M. Mitchell. 2010. Toward an Architecture for NeverEnding Language Learning. In Proceedings of the Twenty-Fourth Conference on Artificial Intelligence (AAAI 2010).</rawString>
</citation>
<citation valid="true">
<authors>
<author>David L Chen</author>
<author>Joohyun Kim</author>
<author>Raymond J Mooney</author>
</authors>
<title>Training a Multilingual Sportscaster: Using Perceptual Context to Learn Language.</title>
<date>2010</date>
<journal>Journal of Artificial Intelligence Research,</journal>
<pages>37--397</pages>
<contexts>
<context position="941" citStr="Chen et al., 2010" startWordPosition="135" endWordPosition="138">he sheer number of logical constants for which they must see labeled training data. We present a technique for developing semantic parsers for large databases based on a reduction to standard supervised training algorithms, schema matching, and pattern learning. Leveraging techniques from each of these areas, we develop a semantic parser for Freebase that is capable of parsing questions with an F1 that improves by 0.42 over a purely-supervised learning algorithm. 1 Introduction Semantic parsing is the task of translating natural language utterances to a formal meaning representation language (Chen et al., 2010; Liang et al., 2009; Clarke et al., 2010; Liang et al., 2011; Artzi and Zettlemoyer, 2011). There has been recent interest in producing such semantic parsers for large, heterogeneous databases like Freebase (Krishnamurthy and Mitchell, 2012; Cai and Yates, 2013) and Yago2 (Yahya et al., 2012), which has driven the development of semi-supervised and distantlysupervised training methods for semantic parsing. Previous purely-supervised approaches have been limited to smaller domains and databases, such as the GeoQuery database, in part because of the cost of labeling enough samples to cover all </context>
</contexts>
<marker>Chen, Kim, Mooney, 2010</marker>
<rawString>David L. Chen, Joohyun Kim, and Raymond J. Mooney. 2010. Training a Multilingual Sportscaster: Using Perceptual Context to Learn Language. Journal of Artificial Intelligence Research, 37:397–435.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stephen Clark</author>
<author>James R Curran</author>
</authors>
<title>Widecoverage efficient statistical parsing with ccg and log-linear models.</title>
<date>2007</date>
<journal>Computational Linguistics,</journal>
<volume>33</volume>
<issue>4</issue>
<contexts>
<context position="21682" citStr="Clark and Curran, 2007" startWordPosition="3585" endWordPosition="3588">k neighborhoods in �- S\NP/NP : AxAy.neighborhoods(x, y) Example CCG Grammar Rules X/Y : f Y : g ⇒ X : f(g) Y : g X\Y : f ⇒ X : f(g) Using A, UBL selects a logical form z for a sentence S by selecting the z with the most likely parse derivations y: h(S) = � arg maxz y p(y, z|x; θ, A). The probabilistic model is a log-linear model with features for lexical entries used in the parse, as well as indicator features for relation-argument pairs in the logical form, to capture selectional preferences. Inference (parsing) and parameter estimation are driven by standard dynamic programming algorithms (Clark and Curran, 2007), while lexicon induction is based on a novel search procedure through the space of possible higher-order logic unification operations that yield the desired logical form for a training sentence. Our Freebase data covers 81 of the 86 core domains in Freebase, and 635 of its over 2000 relations, but we wish to develop a semantic parser that can scale to all of Freebase. UBL gets us part of the way there, by inducing a PCCG grammar, as well as lexical entries for function words that must be handled in all domains. It can also learn lexical entries for relations rD that appear in the training dat</context>
</contexts>
<marker>Clark, Curran, 2007</marker>
<rawString>Stephen Clark and James R. Curran. 2007. Widecoverage efficient statistical parsing with ccg and log-linear models. Computational Linguistics, 33(4):493–552.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Clarke</author>
<author>D Goldwasser</author>
<author>M Chang</author>
<author>D Roth</author>
</authors>
<title>Driving semantic parsing from the world’s response.</title>
<date>2010</date>
<journal>In Computational Natural Language Learning (CoNLL).</journal>
<contexts>
<context position="982" citStr="Clarke et al., 2010" startWordPosition="143" endWordPosition="146">r which they must see labeled training data. We present a technique for developing semantic parsers for large databases based on a reduction to standard supervised training algorithms, schema matching, and pattern learning. Leveraging techniques from each of these areas, we develop a semantic parser for Freebase that is capable of parsing questions with an F1 that improves by 0.42 over a purely-supervised learning algorithm. 1 Introduction Semantic parsing is the task of translating natural language utterances to a formal meaning representation language (Chen et al., 2010; Liang et al., 2009; Clarke et al., 2010; Liang et al., 2011; Artzi and Zettlemoyer, 2011). There has been recent interest in producing such semantic parsers for large, heterogeneous databases like Freebase (Krishnamurthy and Mitchell, 2012; Cai and Yates, 2013) and Yago2 (Yahya et al., 2012), which has driven the development of semi-supervised and distantlysupervised training methods for semantic parsing. Previous purely-supervised approaches have been limited to smaller domains and databases, such as the GeoQuery database, in part because of the cost of labeling enough samples to cover all of the logical constants involved in a do</context>
</contexts>
<marker>Clarke, Goldwasser, Chang, Roth, 2010</marker>
<rawString>J. Clarke, D. Goldwasser, M. Chang, and D. Roth. 2010. Driving semantic parsing from the world’s response. In Computational Natural Language Learning (CoNLL).</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Dhamanka</author>
<author>Y Lee</author>
<author>A Doan</author>
<author>A Halevy</author>
<author>P Domingos</author>
</authors>
<title>iMAP: Discovering Complex Semantic Matches between Database Schemas.</title>
<date>2004</date>
<booktitle>In SIGMOD.</booktitle>
<contexts>
<context position="8292" citStr="Dhamanka et al., 2004" startWordPosition="1288" endWordPosition="1291">hema. Owing to the complexity of the general case, researchers have resorted to defining standard similarity metrics between relations and attributes, as well as machine learning algorithms for learning and predicting matches between relations (Doan et al., 2004; Wick et al., 2008b; Wick et al., 2008a; Nottelmann and Straccia, 2007; Berlin and Motro, 2006). These techniques consider only matches between relational databases, whereas we apply these ideas to matches between Freebase and extracted relations. Schema matching in the database sense often considers complex matches between relations (Dhamanka et al., 2004), whereas as our techniques are currently restricted to matches involving one database relation and one relation extracted from text. 424 3 Textual Schema Matching 3.1 Problem Formulation The textual schema matching task is to identify natural language words and phrases that correspond with each relation and entity in a fixed schema for a relational database. To formalize this task, we first introduce some notation. A schema 5 = (E, R, C, I) consists of a set of entities E, a set of relations R, a set of categories C, and a set of instances I. Categories are one-argument predicates (e.g., film</context>
</contexts>
<marker>Dhamanka, Lee, Doan, Halevy, Domingos, 2004</marker>
<rawString>R. Dhamanka, Y. Lee, A. Doan, A. Halevy, and P. Domingos. 2004. iMAP: Discovering Complex Semantic Matches between Database Schemas. In SIGMOD.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Doan</author>
<author>J Madhavan</author>
<author>P Domingos</author>
<author>A Halevy</author>
</authors>
<title>Ontology Matching: A Machine Learning Approach.</title>
<date>2004</date>
<booktitle>Handbook on Ontologies in Information Systems,</booktitle>
<pages>397--416</pages>
<editor>In S. Staab and R. Studer, editors,</editor>
<publisher>Springer-Verlag.</publisher>
<contexts>
<context position="7932" citStr="Doan et al., 2004" startWordPosition="1233" endWordPosition="1236"> text. Schema matching (Rahm and Bernstein, 2001; Ehrig et al., 2004; Giunchiglia et al., 2005) is a task from the database and knowledge representation community in which systems attempt to identify a “common schema” that covers the relations defined in a set of databases or ontologies, and the mapping between each individual database and the common schema. Owing to the complexity of the general case, researchers have resorted to defining standard similarity metrics between relations and attributes, as well as machine learning algorithms for learning and predicting matches between relations (Doan et al., 2004; Wick et al., 2008b; Wick et al., 2008a; Nottelmann and Straccia, 2007; Berlin and Motro, 2006). These techniques consider only matches between relational databases, whereas we apply these ideas to matches between Freebase and extracted relations. Schema matching in the database sense often considers complex matches between relations (Dhamanka et al., 2004), whereas as our techniques are currently restricted to matches involving one database relation and one relation extracted from text. 424 3 Textual Schema Matching 3.1 Problem Formulation The textual schema matching task is to identify natu</context>
</contexts>
<marker>Doan, Madhavan, Domingos, Halevy, 2004</marker>
<rawString>A. Doan, J. Madhavan, P. Domingos, and A. Halevy. 2004. Ontology Matching: A Machine Learning Approach. In S. Staab and R. Studer, editors, Handbook on Ontologies in Information Systems, pages 397–416. Springer-Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Ehrig</author>
<author>P Haase</author>
<author>N Stojanovic</author>
<author>M Hefke</author>
</authors>
<title>Similarity for ontologies-a comprehensive framework.</title>
<date>2004</date>
<booktitle>In Workshop Enterprise Modelling and Ontology: Ingredients for Interoperability, PAKM.</booktitle>
<contexts>
<context position="7383" citStr="Ehrig et al., 2004" startWordPosition="1147" endWordPosition="1150">stem (Lin and Pantel, 2001) uses the mutual information between the (X, Y ) argument pairs for two binary relations to measure the similarity between them, and clusters relations accordingly. More recent examples of similar techniques include the Resolver system (Yates and Etzioni, 2009) and Poon and Domingos’s USP system (Poon and Domingos, 2009). Our techniques for comparing relations fit into this line of work, but they are novel in their application of these techniques to the task of comparing database relations and relations extracted from text. Schema matching (Rahm and Bernstein, 2001; Ehrig et al., 2004; Giunchiglia et al., 2005) is a task from the database and knowledge representation community in which systems attempt to identify a “common schema” that covers the relations defined in a set of databases or ontologies, and the mapping between each individual database and the common schema. Owing to the complexity of the general case, researchers have resorted to defining standard similarity metrics between relations and attributes, as well as machine learning algorithms for learning and predicting matches between relations (Doan et al., 2004; Wick et al., 2008b; Wick et al., 2008a; Nottelman</context>
</contexts>
<marker>Ehrig, Haase, Stojanovic, Hefke, 2004</marker>
<rawString>M. Ehrig, P. Haase, N. Stojanovic, and M. Hefke. 2004. Similarity for ontologies-a comprehensive framework. In Workshop Enterprise Modelling and Ontology: Ingredients for Interoperability, PAKM.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Anthony Fader</author>
<author>Stephen Soderland</author>
<author>Oren Etzioni</author>
</authors>
<title>Identifying Relations for Open Information Extraction.</title>
<date>2011</date>
<booktitle>In Conference on Empirical Methods in Natural Language Processing (EMNLP).</booktitle>
<contexts>
<context position="9485" citStr="Fader et al., 2011" startWordPosition="1495" endWordPosition="1498">ent predicates (e.g., film(e)), and relations are two- (or more-) argument predicates (e.g., directed by(e1, e2)). Instances are known tuples of entities that make a relation or category true, such as film(Titanic) or directed by(Titanic, James Cameron). Fora given r E R (or c E C), IS(r) indicates the set of known instances of r in schema 5 (and likewise for IS(c)). Examples of such schemas include Freebase (Bollacker et al., 2008) and Yago2 (Hoffart et al., 2013). We say a schema is a textual schema if it has been extracted from free text, such as the Nell (Carlson et al., 2010) and ReVerb (Fader et al., 2011) extracted databases. Given a textual schema T and a database schema D, the textual schema matching task is to identify an alignment or matching M C RT x RD such that (rT, rD) E M if and only if rT can be used to refer to rD in normal language usage. The problem would be greatly simplified if M were a 1-1 function, but in practice most database relations can be referred to in many ways by natural language users: for instance, film actor can be referenced by the English verbs “played,” “acted,” and “starred,” along with morphological variants of them. In addition, many English verbs can refer t</context>
<context position="17788" citStr="Fader et al., 2011" startWordPosition="2931" endWordPosition="2934">e 3), MATCHER computes the statistics above to compare rD and rT. The PMI statistic in Equation 1 corresponds to sκ where κ =strict match over Φ =full tuples. κ(t1, t2) for comparing tuples t1, t2 � 1, if Φ(t1) = Φ0(t2) strict match: 0, otherwise. 1, if Vkcat(Φ(t1)k) = cat(Φ0(t2)k) 0, otherwise. Table 3: MATCHER’s κ functions for computing whether two tuples are similar. cat maps an entity to a category (or type) in the schema. MATCHER has a different κ function for each possible combination of Φ and Φ0 functions, which are given in Table 4. MATCHER uses an API for the ReVerb Open IE system1 (Fader et al., 2011) to collect I(rT), for each rT. The API for ReVerb allows for relational queries in which some subset of the entity strings, entity categories, and relation string are specified. The API returns all matching triples; types must match exactly, but relation or argument strings in the query will match any relation or argument that contains the query string as a substring. MATCHER queries ReVerb with three different types of queries for each rT, specifying the types for both arguments, or just the type of the first argument, or just the second argument. Types for arguments are taken from the types</context>
</contexts>
<marker>Fader, Soderland, Etzioni, 2011</marker>
<rawString>Anthony Fader, Stephen Soderland, and Oren Etzioni. 2011. Identifying Relations for Open Information Extraction. In Conference on Empirical Methods in Natural Language Processing (EMNLP).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fausto Giunchiglia</author>
<author>Pavel Shvaiko</author>
<author>Mikalai Yatskevich</author>
</authors>
<date>2005</date>
<booktitle>Semantic schema matching. On the Move to Meaningful Internet Systems 2005: CoopIS, DOA, and ODBASE,</booktitle>
<pages>347--365</pages>
<contexts>
<context position="7410" citStr="Giunchiglia et al., 2005" startWordPosition="1151" endWordPosition="1154">, 2001) uses the mutual information between the (X, Y ) argument pairs for two binary relations to measure the similarity between them, and clusters relations accordingly. More recent examples of similar techniques include the Resolver system (Yates and Etzioni, 2009) and Poon and Domingos’s USP system (Poon and Domingos, 2009). Our techniques for comparing relations fit into this line of work, but they are novel in their application of these techniques to the task of comparing database relations and relations extracted from text. Schema matching (Rahm and Bernstein, 2001; Ehrig et al., 2004; Giunchiglia et al., 2005) is a task from the database and knowledge representation community in which systems attempt to identify a “common schema” that covers the relations defined in a set of databases or ontologies, and the mapping between each individual database and the common schema. Owing to the complexity of the general case, researchers have resorted to defining standard similarity metrics between relations and attributes, as well as machine learning algorithms for learning and predicting matches between relations (Doan et al., 2004; Wick et al., 2008b; Wick et al., 2008a; Nottelmann and Straccia, 2007; Berli</context>
</contexts>
<marker>Giunchiglia, Shvaiko, Yatskevich, 2005</marker>
<rawString>Fausto Giunchiglia, Pavel Shvaiko, and Mikalai Yatskevich. 2005. Semantic schema matching. On the Move to Meaningful Internet Systems 2005: CoopIS, DOA, and ODBASE, pages 347–365.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Goldwasser</author>
<author>R Reichart</author>
<author>J Clarke</author>
<author>D Roth</author>
</authors>
<title>Confidence driven unsupervised semantic parsing.</title>
<date>2011</date>
<booktitle>In Association for Computational Linguistics (ACL).</booktitle>
<contexts>
<context position="34977" citStr="Goldwasser et al., 2011" startWordPosition="5808" endWordPosition="5811">place these results in context, many different semantic parsers for databases like GeoQuery and ATIS (including parsers produced by UBL) have achieved F1 scores of 0.85 and higher. However, in all such tests, the test questions refer to logical constants that also appeared during training, allowing supervised techniques for learning semantic parsers to achieve strong accuracy. As we have argued, Freebase is large enough that is difficult to produce enough labeled training data to cover all of its logical constants. An unsupervised semantic parser for GeoQuery has achieved an F1 score of 0.66 (Goldwasser et al., 2011), impressive in its own right and slightly better than our F1 score. However, this parser was given questions which it knew a priori to contain words that refer to the logical constants in the database. Our MATCHER and LEXTENDER systems address a different challenge: how to learn a semantic parser for Freebase given the Web and a set of initial labeled questions. 6 Conclusion Scaling semantic parsing to large databases requires an engineering effort to handle large datasets, but also novel algorithms to extend semantic parsing models to testing examples that look significantly different from l</context>
</contexts>
<marker>Goldwasser, Reichart, Clarke, Roth, 2011</marker>
<rawString>D. Goldwasser, R. Reichart, J. Clarke, and D. Roth. 2011. Confidence driven unsupervised semantic parsing. In Association for Computational Linguistics (ACL).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Johannes Hoffart</author>
<author>Fabian M Suchanek</author>
<author>Klaus Berberich</author>
<author>Gerhard Weikum</author>
</authors>
<title>YAGO2: A Spatially and Temporally Enhanced Knowledge Base from Wikipedia.</title>
<date>2013</date>
<journal>Artificial Intelligence,</journal>
<volume>194</volume>
<contexts>
<context position="4874" citStr="Hoffart et al., 2013" startWordPosition="751" endWordPosition="755">on 3 describes our MATCHER algorithm for performing schema matching between a knowledge base and text. Section 4 explains how we use MATCHER’s schema matching to extend a standard semantic parser to logical symbols for which it has seen no labeled training data. Section 5 analyzes the performance of MATCHER and our semantic parser. Section 6 concludes. 2 Previous Work Two existing systems translate between natural language questions and database queries over large-scale databases. Yahya et al. (2012) report on a system for translating natural language queries to SPARQL queries over the Yago2 (Hoffart et al., 2013) database. Yago2 consists of information extracted from Wikipedia, WordNet, and other resources using manually-defined extraction patterns. The manual extraction patterns pre-define a link between natural language terms and Yago2 relations. Our techniques automate the process of identifying matches between textual phrases and database relation symbols, in order to scale up to databases with more relations, like Freebase. A more minor difference between Yahya et al.’s work and ours is that their system handles SPARQL queries, which do not handle aggregation queries like argmax and count. We rel</context>
<context position="9335" citStr="Hoffart et al., 2013" startWordPosition="1465" endWordPosition="1468">schema 5 = (E, R, C, I) consists of a set of entities E, a set of relations R, a set of categories C, and a set of instances I. Categories are one-argument predicates (e.g., film(e)), and relations are two- (or more-) argument predicates (e.g., directed by(e1, e2)). Instances are known tuples of entities that make a relation or category true, such as film(Titanic) or directed by(Titanic, James Cameron). Fora given r E R (or c E C), IS(r) indicates the set of known instances of r in schema 5 (and likewise for IS(c)). Examples of such schemas include Freebase (Bollacker et al., 2008) and Yago2 (Hoffart et al., 2013). We say a schema is a textual schema if it has been extracted from free text, such as the Nell (Carlson et al., 2010) and ReVerb (Fader et al., 2011) extracted databases. Given a textual schema T and a database schema D, the textual schema matching task is to identify an alignment or matching M C RT x RD such that (rT, rD) E M if and only if rT can be used to refer to rD in normal language usage. The problem would be greatly simplified if M were a 1-1 function, but in practice most database relations can be referred to in many ways by natural language users: for instance, film actor can be re</context>
</contexts>
<marker>Hoffart, Suchanek, Berberich, Weikum, 2013</marker>
<rawString>Johannes Hoffart, Fabian M. Suchanek, Klaus Berberich, and Gerhard Weikum. 2013. YAGO2: A Spatially and Temporally Enhanced Knowledge Base from Wikipedia. Artificial Intelligence, 194:28–61, January.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jayant Krishnamurthy</author>
<author>Tom Mitchell</author>
</authors>
<title>Weakly Supervised Training of Semantic Parsers.</title>
<date>2012</date>
<booktitle>In Proceedings of the Conference on Empirical Methods in Natural Language Processing (EMNLP).</booktitle>
<contexts>
<context position="1182" citStr="Krishnamurthy and Mitchell, 2012" startWordPosition="172" endWordPosition="176">hema matching, and pattern learning. Leveraging techniques from each of these areas, we develop a semantic parser for Freebase that is capable of parsing questions with an F1 that improves by 0.42 over a purely-supervised learning algorithm. 1 Introduction Semantic parsing is the task of translating natural language utterances to a formal meaning representation language (Chen et al., 2010; Liang et al., 2009; Clarke et al., 2010; Liang et al., 2011; Artzi and Zettlemoyer, 2011). There has been recent interest in producing such semantic parsers for large, heterogeneous databases like Freebase (Krishnamurthy and Mitchell, 2012; Cai and Yates, 2013) and Yago2 (Yahya et al., 2012), which has driven the development of semi-supervised and distantlysupervised training methods for semantic parsing. Previous purely-supervised approaches have been limited to smaller domains and databases, such as the GeoQuery database, in part because of the cost of labeling enough samples to cover all of the logical constants involved in a domain. This paper investigates a reduction of the problem of building a semantic parser to three standard problems in semantics and machine learning: supervised training of a semantic parser, schema ma</context>
<context position="5824" citStr="Krishnamurthy and Mitchell (2012)" startWordPosition="895" endWordPosition="898">hrases and database relation symbols, in order to scale up to databases with more relations, like Freebase. A more minor difference between Yahya et al.’s work and ours is that their system handles SPARQL queries, which do not handle aggregation queries like argmax and count. We rely on an existing semantic parsing technology to learn the language that will translate into such aggregation queries. On the other hand, their test questions involve more conjunctions and complex semantics than ours. Developing a dataset with more complicated semantics in the queries is part of our ongoing efforts. Krishnamurthy and Mitchell (2012) also create a semantic parser for Freebase covering 77 of Freebase’s over 2000 relations. Like our work, their technique uses distant supervision to drive training over a collection of sentences gathered from the Web, and they do not require any manually-labeled training data. However, their technique does require manual specification of rules that construct CCG lexical entries from dependency parses. In comparison, we fully automate the process of constructing CCG lexical entries for the semantic parser by making it a prediction task. We also leverage synonym-matching techniques for comparin</context>
</contexts>
<marker>Krishnamurthy, Mitchell, 2012</marker>
<rawString>Jayant Krishnamurthy and Tom Mitchell. 2012. Weakly Supervised Training of Semantic Parsers. In Proceedings of the Conference on Empirical Methods in Natural Language Processing (EMNLP).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tom Kwiatkowski</author>
<author>Luke Zettlemoyer</author>
<author>Sharon Goldwater</author>
<author>Mark Steedman</author>
</authors>
<title>Inducing Probabilistic CCG Grammars from Logical Form with Higherorder Unification.</title>
<date>2010</date>
<booktitle>In Proceedings of the Conference on Empirical Methods in Natural Language Processing (EMNLP).</booktitle>
<contexts>
<context position="20544" citStr="Kwiatkowski et al. (2010)" startWordPosition="3387" endWordPosition="3390">ions and database relations has many possible uses: for example, it might be used to allow queries over a database to be answered using additional information stored in an extracted relation store, or it might be used to deduce clusters of synonymous relation words in English. Here, we describe an application in which we build a questionanswering system for Freebase by extending a standard learning technique for semantic parsing with schema alignment information. As a starting point, we used the UBL system �sκ(r0D, rT) r1D s00(rT, rD) = |IT (rT )| |ID(rD)| ⎧ ⎨⎪ ⎪⎩ type match: 427 developed by Kwiatkowski et al. (2010) to learn a semantic parser based on probabilistic Combinatory Categorial Grammar (PCCG). Source code for UBL is freely available. Its authors found that it achieves results competitive with the state-of-the-art on a variety of standard semantic parsing data sets, including Geo250 English (0.85 F1). Using a fixed CCG grammar and a procedure based on unification in second-order logic, UBL learns a lexicon A from the training data which includes entries like: Example Lexical Entries New York City �- NP : new york neighborhoods in �- S\NP/NP : AxAy.neighborhoods(x, y) Example CCG Grammar Rules X/</context>
</contexts>
<marker>Kwiatkowski, Zettlemoyer, Goldwater, Steedman, 2010</marker>
<rawString>Tom Kwiatkowski, Luke Zettlemoyer, Sharon Goldwater, and Mark Steedman. 2010. Inducing Probabilistic CCG Grammars from Logical Form with Higherorder Unification. In Proceedings of the Conference on Empirical Methods in Natural Language Processing (EMNLP).</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Liang</author>
<author>M I Jordan</author>
<author>D Klein</author>
</authors>
<title>Learning semantic correspondences with less supervision.</title>
<date>2009</date>
<booktitle>In Association for Computational Linguistics and International Joint Conference on Natural Language Processing (ACL-IJCNLP).</booktitle>
<contexts>
<context position="961" citStr="Liang et al., 2009" startWordPosition="139" endWordPosition="142">logical constants for which they must see labeled training data. We present a technique for developing semantic parsers for large databases based on a reduction to standard supervised training algorithms, schema matching, and pattern learning. Leveraging techniques from each of these areas, we develop a semantic parser for Freebase that is capable of parsing questions with an F1 that improves by 0.42 over a purely-supervised learning algorithm. 1 Introduction Semantic parsing is the task of translating natural language utterances to a formal meaning representation language (Chen et al., 2010; Liang et al., 2009; Clarke et al., 2010; Liang et al., 2011; Artzi and Zettlemoyer, 2011). There has been recent interest in producing such semantic parsers for large, heterogeneous databases like Freebase (Krishnamurthy and Mitchell, 2012; Cai and Yates, 2013) and Yago2 (Yahya et al., 2012), which has driven the development of semi-supervised and distantlysupervised training methods for semantic parsing. Previous purely-supervised approaches have been limited to smaller domains and databases, such as the GeoQuery database, in part because of the cost of labeling enough samples to cover all of the logical const</context>
</contexts>
<marker>Liang, Jordan, Klein, 2009</marker>
<rawString>P. Liang, M. I. Jordan, and D. Klein. 2009. Learning semantic correspondences with less supervision. In Association for Computational Linguistics and International Joint Conference on Natural Language Processing (ACL-IJCNLP).</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Liang</author>
<author>M I Jordan</author>
<author>D Klein</author>
</authors>
<title>Learning dependency-based compositional semantics.</title>
<date>2011</date>
<booktitle>In Association for Computational Linguistics (ACL).</booktitle>
<contexts>
<context position="1002" citStr="Liang et al., 2011" startWordPosition="147" endWordPosition="150"> labeled training data. We present a technique for developing semantic parsers for large databases based on a reduction to standard supervised training algorithms, schema matching, and pattern learning. Leveraging techniques from each of these areas, we develop a semantic parser for Freebase that is capable of parsing questions with an F1 that improves by 0.42 over a purely-supervised learning algorithm. 1 Introduction Semantic parsing is the task of translating natural language utterances to a formal meaning representation language (Chen et al., 2010; Liang et al., 2009; Clarke et al., 2010; Liang et al., 2011; Artzi and Zettlemoyer, 2011). There has been recent interest in producing such semantic parsers for large, heterogeneous databases like Freebase (Krishnamurthy and Mitchell, 2012; Cai and Yates, 2013) and Yago2 (Yahya et al., 2012), which has driven the development of semi-supervised and distantlysupervised training methods for semantic parsing. Previous purely-supervised approaches have been limited to smaller domains and databases, such as the GeoQuery database, in part because of the cost of labeling enough samples to cover all of the logical constants involved in a domain. This paper inv</context>
</contexts>
<marker>Liang, Jordan, Klein, 2011</marker>
<rawString>P. Liang, M. I. Jordan, and D. Klein. 2011. Learning dependency-based compositional semantics. In Association for Computational Linguistics (ACL).</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Lin</author>
<author>P Pantel</author>
</authors>
<date>2001</date>
<booktitle>DIRT – Discovery of Inference Rules from Text. In KDD.</booktitle>
<contexts>
<context position="6792" citStr="Lin and Pantel, 2001" startWordPosition="1049" endWordPosition="1052">that construct CCG lexical entries from dependency parses. In comparison, we fully automate the process of constructing CCG lexical entries for the semantic parser by making it a prediction task. We also leverage synonym-matching techniques for comparing relations extracted from text with Freebase relations. Finally, we test our results on a dataset of 917 questions covering over 600 Freebase relations, a more extensive test than the 50 questions used by Krishnamurthy and Mitchell. Numerous methods exist for comparing two relations based on their sets of tuples. For instance, the DIRT system (Lin and Pantel, 2001) uses the mutual information between the (X, Y ) argument pairs for two binary relations to measure the similarity between them, and clusters relations accordingly. More recent examples of similar techniques include the Resolver system (Yates and Etzioni, 2009) and Poon and Domingos’s USP system (Poon and Domingos, 2009). Our techniques for comparing relations fit into this line of work, but they are novel in their application of these techniques to the task of comparing database relations and relations extracted from text. Schema matching (Rahm and Bernstein, 2001; Ehrig et al., 2004; Giunchi</context>
</contexts>
<marker>Lin, Pantel, 2001</marker>
<rawString>D. Lin and P. Pantel. 2001. DIRT – Discovery of Inference Rules from Text. In KDD.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Henrik Nottelmann</author>
<author>Umberto Straccia</author>
</authors>
<title>Information retrieval and machine learning for probabilistic schema matching.</title>
<date>2007</date>
<booktitle>Information processing &amp; management,</booktitle>
<pages>43--3</pages>
<contexts>
<context position="8003" citStr="Nottelmann and Straccia, 2007" startWordPosition="1245" endWordPosition="1248">al., 2004; Giunchiglia et al., 2005) is a task from the database and knowledge representation community in which systems attempt to identify a “common schema” that covers the relations defined in a set of databases or ontologies, and the mapping between each individual database and the common schema. Owing to the complexity of the general case, researchers have resorted to defining standard similarity metrics between relations and attributes, as well as machine learning algorithms for learning and predicting matches between relations (Doan et al., 2004; Wick et al., 2008b; Wick et al., 2008a; Nottelmann and Straccia, 2007; Berlin and Motro, 2006). These techniques consider only matches between relational databases, whereas we apply these ideas to matches between Freebase and extracted relations. Schema matching in the database sense often considers complex matches between relations (Dhamanka et al., 2004), whereas as our techniques are currently restricted to matches involving one database relation and one relation extracted from text. 424 3 Textual Schema Matching 3.1 Problem Formulation The textual schema matching task is to identify natural language words and phrases that correspond with each relation and e</context>
</contexts>
<marker>Nottelmann, Straccia, 2007</marker>
<rawString>Henrik Nottelmann and Umberto Straccia. 2007. Information retrieval and machine learning for probabilistic schema matching. Information processing &amp; management, 43(3):552–576.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hoifung Poon</author>
<author>Pedro Domingos</author>
</authors>
<title>Unsupervised semantic parsing.</title>
<date>2009</date>
<booktitle>In Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing, EMNLP ’09,</booktitle>
<pages>1--10</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<location>Stroudsburg, PA, USA.</location>
<contexts>
<context position="7114" citStr="Poon and Domingos, 2009" startWordPosition="1103" endWordPosition="1106">we test our results on a dataset of 917 questions covering over 600 Freebase relations, a more extensive test than the 50 questions used by Krishnamurthy and Mitchell. Numerous methods exist for comparing two relations based on their sets of tuples. For instance, the DIRT system (Lin and Pantel, 2001) uses the mutual information between the (X, Y ) argument pairs for two binary relations to measure the similarity between them, and clusters relations accordingly. More recent examples of similar techniques include the Resolver system (Yates and Etzioni, 2009) and Poon and Domingos’s USP system (Poon and Domingos, 2009). Our techniques for comparing relations fit into this line of work, but they are novel in their application of these techniques to the task of comparing database relations and relations extracted from text. Schema matching (Rahm and Bernstein, 2001; Ehrig et al., 2004; Giunchiglia et al., 2005) is a task from the database and knowledge representation community in which systems attempt to identify a “common schema” that covers the relations defined in a set of databases or ontologies, and the mapping between each individual database and the common schema. Owing to the complexity of the general</context>
</contexts>
<marker>Poon, Domingos, 2009</marker>
<rawString>Hoifung Poon and Pedro Domingos. 2009. Unsupervised semantic parsing. In Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing, EMNLP ’09, pages 1–10, Stroudsburg, PA, USA. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Rahm</author>
<author>P A Bernstein</author>
</authors>
<title>A survey of approaches to automatic schema matching.</title>
<date>2001</date>
<journal>The VLDB Journal,</journal>
<pages>10--334</pages>
<contexts>
<context position="7363" citStr="Rahm and Bernstein, 2001" startWordPosition="1143" endWordPosition="1146"> For instance, the DIRT system (Lin and Pantel, 2001) uses the mutual information between the (X, Y ) argument pairs for two binary relations to measure the similarity between them, and clusters relations accordingly. More recent examples of similar techniques include the Resolver system (Yates and Etzioni, 2009) and Poon and Domingos’s USP system (Poon and Domingos, 2009). Our techniques for comparing relations fit into this line of work, but they are novel in their application of these techniques to the task of comparing database relations and relations extracted from text. Schema matching (Rahm and Bernstein, 2001; Ehrig et al., 2004; Giunchiglia et al., 2005) is a task from the database and knowledge representation community in which systems attempt to identify a “common schema” that covers the relations defined in a set of databases or ontologies, and the mapping between each individual database and the common schema. Owing to the complexity of the general case, researchers have resorted to defining standard similarity metrics between relations and attributes, as well as machine learning algorithms for learning and predicting matches between relations (Doan et al., 2004; Wick et al., 2008b; Wick et a</context>
</contexts>
<marker>Rahm, Bernstein, 2001</marker>
<rawString>E. Rahm and P.A. Bernstein. 2001. A survey of approaches to automatic schema matching. The VLDB Journal, 10:334–350.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P D Turney</author>
</authors>
<title>Mining the Web for Synonyms: PMI-IR versus LSA on TOEFL.</title>
<date>2001</date>
<booktitle>In Procs. of the Twelfth European Conference on Machine Learning (ECML),</booktitle>
<pages>491--502</pages>
<location>Freiburg, Germany.</location>
<contexts>
<context position="14634" citStr="Turney, 2001" startWordPosition="2367" endWordPosition="2368">MATCHER use searches over the Web to count the number of instances where a candidate rT appears in simple patterns that involve entities from rD. Greater counts for these patterns yield greater evidence of a correct match between rD and rT. Table 1 provides a list of patterns that we consider. For each rD and each rT E C(rD), MATCHER randomly selects 10 entities from rD’s tuples to include in its pattern queries. Two of the patterns are targeted at past-tense verbs, and the other two patterns at nominal relation words. MATCHER computes statistics similar to pointwise mutual information (PMI) (Turney, 2001) to measure how related rD and rT are, for each pattern p. Let c(p, rD, rT) indicate the sum of all the counts for a particular pattern p, database relation, and textual relation: fp(rT, rD) = 1: c(p, r&apos; D,rT) * c(p, rD, rT) r� r� D T For the sum over all r&apos;D, we use all r&apos;D in Freebase for which rT was extracted as a candidate. One downside of the pattern-matching evidence is the sheer number of queries it requires. Freebase currently has over 2,000 relations. For each rD, we have up to 500 candidate rT, up to 4 patterns, and up to 10 entities per pattern. To cover all of Freebase, MATCHER ne</context>
</contexts>
<marker>Turney, 2001</marker>
<rawString>P. D. Turney. 2001. Mining the Web for Synonyms: PMI-IR versus LSA on TOEFL. In Procs. of the Twelfth European Conference on Machine Learning (ECML), pages 491–502, Freiburg, Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Wick</author>
<author>K Rohanimanesh</author>
<author>A McCallum</author>
<author>A H Doan</author>
</authors>
<title>A discriminative approach to ontology mapping.</title>
<date>2008</date>
<booktitle>In International Workshop on New Trends in Information Integration (NTII) at VLDB WS.</booktitle>
<contexts>
<context position="7951" citStr="Wick et al., 2008" startWordPosition="1237" endWordPosition="1240">ing (Rahm and Bernstein, 2001; Ehrig et al., 2004; Giunchiglia et al., 2005) is a task from the database and knowledge representation community in which systems attempt to identify a “common schema” that covers the relations defined in a set of databases or ontologies, and the mapping between each individual database and the common schema. Owing to the complexity of the general case, researchers have resorted to defining standard similarity metrics between relations and attributes, as well as machine learning algorithms for learning and predicting matches between relations (Doan et al., 2004; Wick et al., 2008b; Wick et al., 2008a; Nottelmann and Straccia, 2007; Berlin and Motro, 2006). These techniques consider only matches between relational databases, whereas we apply these ideas to matches between Freebase and extracted relations. Schema matching in the database sense often considers complex matches between relations (Dhamanka et al., 2004), whereas as our techniques are currently restricted to matches involving one database relation and one relation extracted from text. 424 3 Textual Schema Matching 3.1 Problem Formulation The textual schema matching task is to identify natural language words </context>
</contexts>
<marker>Wick, Rohanimanesh, McCallum, Doan, 2008</marker>
<rawString>M. Wick, K. Rohanimanesh, A. McCallum, and A.H. Doan. 2008a. A discriminative approach to ontology mapping. In International Workshop on New Trends in Information Integration (NTII) at VLDB WS.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M L Wick</author>
<author>K Rohanimanesh</author>
<author>K Schultz</author>
<author>A McCallum</author>
</authors>
<title>A unified approach for schema matching, coreference and canonicalization.</title>
<date>2008</date>
<booktitle>In Proceeding of the 14th ACM SIGKDD international conference on Knowledge discovery and data mining.</booktitle>
<contexts>
<context position="7951" citStr="Wick et al., 2008" startWordPosition="1237" endWordPosition="1240">ing (Rahm and Bernstein, 2001; Ehrig et al., 2004; Giunchiglia et al., 2005) is a task from the database and knowledge representation community in which systems attempt to identify a “common schema” that covers the relations defined in a set of databases or ontologies, and the mapping between each individual database and the common schema. Owing to the complexity of the general case, researchers have resorted to defining standard similarity metrics between relations and attributes, as well as machine learning algorithms for learning and predicting matches between relations (Doan et al., 2004; Wick et al., 2008b; Wick et al., 2008a; Nottelmann and Straccia, 2007; Berlin and Motro, 2006). These techniques consider only matches between relational databases, whereas we apply these ideas to matches between Freebase and extracted relations. Schema matching in the database sense often considers complex matches between relations (Dhamanka et al., 2004), whereas as our techniques are currently restricted to matches involving one database relation and one relation extracted from text. 424 3 Textual Schema Matching 3.1 Problem Formulation The textual schema matching task is to identify natural language words </context>
</contexts>
<marker>Wick, Rohanimanesh, Schultz, McCallum, 2008</marker>
<rawString>M.L. Wick, K. Rohanimanesh, K. Schultz, and A. McCallum. 2008b. A unified approach for schema matching, coreference and canonicalization. In Proceeding of the 14th ACM SIGKDD international conference on Knowledge discovery and data mining.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mohamed Yahya</author>
<author>Klaus Berberich</author>
<author>Shady Elbassuoni</author>
<author>Maya Ramanath</author>
<author>Volker Tresp</author>
<author>Gerhard Weikum</author>
</authors>
<title>Natural Language Questions for the Web of Data.</title>
<date>2012</date>
<booktitle>In Proceedings of the Conference on Empirical Methods in Natural Language Processing (EMNLP).</booktitle>
<contexts>
<context position="1235" citStr="Yahya et al., 2012" startWordPosition="183" endWordPosition="186">ch of these areas, we develop a semantic parser for Freebase that is capable of parsing questions with an F1 that improves by 0.42 over a purely-supervised learning algorithm. 1 Introduction Semantic parsing is the task of translating natural language utterances to a formal meaning representation language (Chen et al., 2010; Liang et al., 2009; Clarke et al., 2010; Liang et al., 2011; Artzi and Zettlemoyer, 2011). There has been recent interest in producing such semantic parsers for large, heterogeneous databases like Freebase (Krishnamurthy and Mitchell, 2012; Cai and Yates, 2013) and Yago2 (Yahya et al., 2012), which has driven the development of semi-supervised and distantlysupervised training methods for semantic parsing. Previous purely-supervised approaches have been limited to smaller domains and databases, such as the GeoQuery database, in part because of the cost of labeling enough samples to cover all of the logical constants involved in a domain. This paper investigates a reduction of the problem of building a semantic parser to three standard problems in semantics and machine learning: supervised training of a semantic parser, schema matching, and pattern learning. Figure 1 provides a vis</context>
<context position="4758" citStr="Yahya et al. (2012)" startWordPosition="731" endWordPosition="734"> has been observed. The rest of this paper is organized as follows. The next section discusses related work. Section 3 describes our MATCHER algorithm for performing schema matching between a knowledge base and text. Section 4 explains how we use MATCHER’s schema matching to extend a standard semantic parser to logical symbols for which it has seen no labeled training data. Section 5 analyzes the performance of MATCHER and our semantic parser. Section 6 concludes. 2 Previous Work Two existing systems translate between natural language questions and database queries over large-scale databases. Yahya et al. (2012) report on a system for translating natural language queries to SPARQL queries over the Yago2 (Hoffart et al., 2013) database. Yago2 consists of information extracted from Wikipedia, WordNet, and other resources using manually-defined extraction patterns. The manual extraction patterns pre-define a link between natural language terms and Yago2 relations. Our techniques automate the process of identifying matches between textual phrases and database relation symbols, in order to scale up to databases with more relations, like Freebase. A more minor difference between Yahya et al.’s work and our</context>
</contexts>
<marker>Yahya, Berberich, Elbassuoni, Ramanath, Tresp, Weikum, 2012</marker>
<rawString>Mohamed Yahya, Klaus Berberich, Shady Elbassuoni, Maya Ramanath, Volker Tresp, and Gerhard Weikum. 2012. Natural Language Questions for the Web of Data. In Proceedings of the Conference on Empirical Methods in Natural Language Processing (EMNLP).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alexander Yates</author>
<author>Oren Etzioni</author>
</authors>
<title>Unsupervised methods for determining object and relation synonyms on the web.</title>
<date>2009</date>
<journal>Journal of Artificial Intelligence Research (JAIR),</journal>
<pages>34--255</pages>
<contexts>
<context position="7053" citStr="Yates and Etzioni, 2009" startWordPosition="1091" endWordPosition="1095">ations extracted from text with Freebase relations. Finally, we test our results on a dataset of 917 questions covering over 600 Freebase relations, a more extensive test than the 50 questions used by Krishnamurthy and Mitchell. Numerous methods exist for comparing two relations based on their sets of tuples. For instance, the DIRT system (Lin and Pantel, 2001) uses the mutual information between the (X, Y ) argument pairs for two binary relations to measure the similarity between them, and clusters relations accordingly. More recent examples of similar techniques include the Resolver system (Yates and Etzioni, 2009) and Poon and Domingos’s USP system (Poon and Domingos, 2009). Our techniques for comparing relations fit into this line of work, but they are novel in their application of these techniques to the task of comparing database relations and relations extracted from text. Schema matching (Rahm and Bernstein, 2001; Ehrig et al., 2004; Giunchiglia et al., 2005) is a task from the database and knowledge representation community in which systems attempt to identify a “common schema” that covers the relations defined in a set of databases or ontologies, and the mapping between each individual database </context>
</contexts>
<marker>Yates, Etzioni, 2009</marker>
<rawString>Alexander Yates and Oren Etzioni. 2009. Unsupervised methods for determining object and relation synonyms on the web. Journal of Artificial Intelligence Research (JAIR), 34:255–296, March.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>