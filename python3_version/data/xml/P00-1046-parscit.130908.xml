<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.990478">
Processing Optimality-theoretic Syntax by Interleaved
Chart Parsing and Generation
</title>
<author confidence="0.891942">
Jonas Kuhn
</author>
<affiliation confidence="0.537219">
Institut fiir maschinelle Sprachverarbeitung, Universitat Stuttgart
</affiliation>
<address confidence="0.905642">
AzenbergstraEe 12, D-70174 Stuttgart, Germany
</address>
<email confidence="0.995742">
jonas@ims.uni-stuttgart.de
</email>
<sectionHeader confidence="0.995559" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9999749375">
The Earley deduction algorithm is
extended for the processing of OT
syntax based on feature grammars.
Due to faithfulness violations, in-
finitely many candidates must be
compared. With the (reasonable) as-
sumptions (i) that OT constraints
are descriptions denoting bounded
structures and (ii) that every rule re-
cursion in the base grammar incurs
some constraint violation, a chart al-
gorithm can be devised. Interleaving
parsing and generation permits the
application of generation-based op-
timization even in the parsing task,
i.e., for a string input.
</bodyText>
<sectionHeader confidence="0.998517" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.998246347826087">
In Optimality Theory (OT), both the (vio-
lable) constraints and the set of competing
candidate structures are universally invariant;
just the relative ranking of constraints is sub-
ject to cross-linguistic variation. This makes
OT an attractive model for the explanation of
typological variation and acquisition. In con-
trast to OT phonology there has been little
computational work on OT syntax. Here, I
propose a parsing/generation strategy for OT
syntax based on Earley deduction, combin-
ing Tesar&apos;s (1995) chart-based computation
of OT competition with insights from pars-
ing/generation with constraint-based gram-
mars (in particular Neumann&apos;s (1998) inter-
leaving). A prototype has been implemented
in Prolog.
Sec. 2 presents background on OT syn-
tax and a formalization based on Lexical-
Functional Grammar (LFG); sec. 3 identifies
two computational challenges; sec. 4 presents
the Optimality-theoretic Earley deduction ap-
proach, interleaving parsing and generation.
</bodyText>
<sectionHeader confidence="0.928763" genericHeader="method">
2 OT syntax background
</sectionHeader>
<bodyText confidence="0.9977246875">
Various OT syntax models have been as-
sumed. I will follow the OT-LFG ap-
proach first proposed by Bresnan (1998), since
its representations constituent (c-)structure
trees and corresponding feature (f-)struc-
tures are well-understood, and there is both
work on formalization&apos; and a growing typolog-
ical literature.2 However, the algorithm itself
is largely independent from specifics of OT-
LFG.
The set of competing candidates is de-
fined by a common underlying representation
(&amp;quot;input&amp;quot;), in OT-LFG an underspecified f-
structure (1), containing all the information
relevant for interpretation (i.e., all candidates
have the same meaning) .3
</bodyText>
<table confidence="0.531107">
(1) PRED `see(x,y)&apos; &apos;they&apos; x
crFi [ PRED &apos;person&apos;
GF2 [PRED ±
OP
</table>
<bodyText confidence="0.989080166666667">
Candidates are c-structure/f-structure
pairs defined by a grammar Ginvio/ encoding
the inviolable principles (extended X-bar
theory). While each candidate&apos;s f-structure
has to be subsumed by the input, the
c-structure and lexical filling can deviate
</bodyText>
<footnote confidence="0.906773166666667">
&apos;(Johnson, 1998; Kuhn, 2000a; Kuhn, 2000b)
2See e.g., the contributions in (Sells, 2000).
3A richer semantic representation could be as-
sumed, making quantifier scope explicit, etc. In the
OT-LFG literature, the argument structure reflected
in f-structure has been largely sufficient.
</footnote>
<equation confidence="0.846541888888889">
☞
generation marks
(Ti, i)
(T2,432)
(Tr, 43.1)
■ (n44, n2,1, • • • ,nk,i)
▪ n2,2, • • • ,nk,2)
■ •
(ni,j , n2„ , nk,j)
</equation>
<figureCaption confidence="0.998036">
Figure 1: Sketch of generation-based OT processing
</figureCaption>
<bodyText confidence="0.999752">
The violable constraints can be expressed as
(implicative) descriptions of the candidate&apos;s c-
structure and f-structure (Kuhn, 2000b). The
constraint marking function marks is then de-
fined as a follows:
</bodyText>
<listItem confidence="0.5483875">
(10) (T,(1)): LFG analysis; C—(ci, c2 ck): con-
straints; define
</listItem>
<equation confidence="0.994903">
marks((T,(1))) = (ni, n2 • • • nk),
</equation>
<bodyText confidence="0.998724">
where ni is the number of violations that (T, 4.)
incurs for constraint c.
Eval picks the most harmonic (cf. (6)) from
a set of analyses, given a language-specific
ranking &gt;r of the constraints.
</bodyText>
<listItem confidence="0.975185">
(11) F: set of LFG analyses (T, 4.); (C, &gt;&gt;i): ranked
set of constraints; define
</listItem>
<equation confidence="0.981152">
Evalc(F) = {(T),(1) j) E F : marks((T),(1)j)) is
</equation>
<bodyText confidence="0.59075925">
maximally harmonic for all analyses in F, under
ranking &gt;c}
We can now define the language generated
by an OT-LFG system:
</bodyText>
<equation confidence="0.972083">
(12) G”,mot; (C, &gt;&gt;); Lex: lexicon; define
(C &gt;c)) = { w E Lex + : 3 input re-
presentation C„, w is the terminal string of some
(T,(1)) E EvalL(Gen(4)„))}
</equation>
<sectionHeader confidence="0.568172" genericHeader="method">
3 Two computational challenges
</sectionHeader>
<bodyText confidence="0.9982684375">
It seems that OT processing can be modelled
straightforwardly as sketched in fig. 1, based
on &amp;quot;classical&amp;quot; generation from d)in with Ginvio/.
However, due to unfaithfulness, we have to
deal with infinitely many competing candi-
dates: Under a DEP-I0 violation, a recur-
sion in the base grammar may be traversed
without &amp;quot;consuming&amp;quot; any part of the input
generating for example arbitrarily many in-
stances of expletive do. But the following
property of OT systems can resolve the prob-
lem: with assumptions (13) and (14), there
will be a point in any traversal of a base gram-
mar recursion from which on all larger candi-
dates are less harmonic than one given candi-
date.6 To my knowledge, these assumptions
</bodyText>
<footnote confidence="0.988715">
6This is a consequence of the pumping lemma for
context-free languages. A formal proof is in prepara-
tion.
</footnote>
<listItem confidence="0.812579">
are compatible with the intuitions behind the
OT accounts in the literature.7
(13) The constraints are such that every application
of recursive rules from incurs some con-
straint violation!&apos;
(14) OT constraints are structural descriptions denot-
ing bounded structures.9
</listItem>
<bodyText confidence="0.96606221875">
Tesar (1995) exploits this property in his
dynamic programming (or chart-based) algo-
rithm for regular languages and context-free
&amp;quot;position grammars&amp;quot;. In sec. 4.2, this is ex-
tended to feature grammars.
The second computational challenge arises
for the recognition and parsing task for an
OT language defined as in (12). As John-
son (1998) notes, a technique symmetrical
to the one sketched in fig. 1 i.e., parsing a
string and comparing the constraint marking
of the different analyses does not realize the
parsing task for the language defined by the
original system: strings that are not optimal
for any underlying representation d)in accord-
ing to (12) will be wrongly predicted to be
grammatical since trivially, one of these will
be optimal for this parsing-based optimiza-
tion.
7A straightforward way to satisfy (13) is to assume
a constraint AVOIDSTRUC, which is violated once by
every c-structure node.
8 ( 13) can be seen as a relaxed version of the
offline parsability restriction, and a corresponding
offline generability restriction: In classical pars-
ing/generation, these restrictions exclude rule recur-
sion to be applied vacuously (wrt. the input, i.e.,
a string/a resourced feature structure), because this
would lead to an infinite number of c-structures. In
the OT-LFG setting, Gen specifies an infinite set of
candidates, and it is the constraints that control the
traversal of the candidate space.
A reviewer points out that (13) may not be nec-
essary, since for an infinite set of equally harmonic
candidates arising through pumping (cf. fn. 6), the
&amp;quot;unpumped&amp;quot; version could be used as a representative.
Kaplan and Wedekind (2000) make a similar point for
classical generation.
9Note that (14) does not exclude that a constraint
can have an effect on some unboundedly remote part
of the structure (through constraint interaction).
Modelling the recognition and parsing task
computationally will involve a bidirectional
processing effort (Kuhn, 2000b): the string
is parsed to detect possible underlying repre-
sentations, and from these a &amp;quot;backward gener-
ation&amp;quot; step is performed, for which OT eval-
uation is applied. Only if the parsed string
is matched by the optimal candidate for its
underlying representation, is the string gram-
matical.1°
Faithfulness violations of the MAX-TO type
(7) allow for situations where underlying ma-
terial is not reflected by any of the lexical ma-
terial. Unless one introduces a bound for such
violations by definition (restricting the gen-
erality of the computational model), it turns
out that the parsing task in the bidirectional
processing scheme cannot be subjected to the
standard restriction of offline parsability (cf.
fn. 13):n like in generation, the set of parsing
alternatives that have to be considered is in-
finite, so a systematic traversal of the search
space is required (sec. 4.3).
</bodyText>
<sectionHeader confidence="0.9656075" genericHeader="method">
4 Optimality-theoretic Earley
deduction
</sectionHeader>
<bodyText confidence="0.9962425625">
4.1 Earley deduction for parsing and
generation
Since the chart-based algorithm to be devel-
oped is to work bidirectionally, using Ear-
ley deduction (Pereira and Warren, 1983) is
a natural choice.12 Parsing and generation
amounts to deduction of a given goal using
two basic inference rules: prediction (or in-
stantiation) and completion (or reduction). In
parsing, the goal&apos;s string is specified (and used
as its index); in generation, its underlying rep-
resentation is. An agenda is used as a con-
trol structure; items on the agenda and in the
chart have the form of definite clauses. We
distinguish (i) active items, &amp;quot;looking for&amp;quot; ma-
terial of a certain category and with certain
</bodyText>
<sectionHeader confidence="0.622373" genericHeader="method">
10 AA s
</sectionHeader>
<bodyText confidence="0.999211965517241">
just laid out, the model involves bidirectional
processing, but optimization applies only in one (the
generation) direction. It is however straightforward
to extend this model to a bidirectional optimization
model (Kuhn, 2000a).
&amp;quot;This becomes clear in structure (ii) in fn. 5 above.
12Cf. (Shieber, 1988); I adopt Neumann&apos;s (1998)
uniform agenda-driven tabular algorithm.
features (their selected element), and (ii) pas-
sive items, stating that certain material has
already been found. When matching, a pas-
sive and an active item can be combined by
completion.13 Active items come into exis-
tence through prediction, based on a gram-
mar rule. Before creating a new chart item
and triggering inference rules based on it, it is
checked whether such an item exists already
(i.e., it is blocked), avoiding unnecessary re-
computations. The algorithm is initialized by
putting an active item looking for the gram-
mar&apos;s root symbol on the agenda, indexed
with the complete input. It terminates when
the agenda is empty.14
For indexing the underlying information in
generation, I will essentially use the FRED val-
ues in the input f-structure, treating them as
resources. To identify them uniquely, the se-
mantic index for a given item will be a list of
FRED values with their complete paths.
</bodyText>
<subsectionHeader confidence="0.941705">
4.2 Chart-based optimization
</subsectionHeader>
<bodyText confidence="0.999920647058824">
The extension of Earley deduction to an OT
system meeting assumptions (13) and (14) is
strikingly simple: (i) a record of the con-
straint profile of the structure constructed so
far is kept for (heads of) items; (ii) as com-
pletion is applied, the OT constraints are ap-
plied, recording the sum of new violations and
the constraint profile of the passive item con-
sumed (whenever a constraint may or may
not apply, both options are computed15); (iii)
when a passive item is checked for blocking,
the constraint profile is taken into account: if
the new item is more harmonic, it is not con-
sidered as blocked, but is applied. Blocking in
(iii) is subjected to a restriction operation, en-
suring there is only a finite number of possible
types of items.16
</bodyText>
<footnote confidence="0.986684454545454">
13 Scanning is a special case of completion, where a
lexicon entry is used to match an active item&apos;s selec-
tion.
14If successful, the chart contains one or more pas-
sive items covering the entire input, with the gram-
mar&apos;s root symbol as the category.
15A book-keeping scheme ensures that constraints
on f-structure are applied only once, so unified f-
structures are not regarded twice.
16This operation is justified, since assumption (14)
ensures that for comparing the constraint profile of
</footnote>
<bodyText confidence="0.9989188">
A sample derivation. (15) specifies
G invioi, a small extended X-bar fragment.
Categories are assumed to have an inter-
nal structure (Bresnan, 2000; Kuhn, 1999)
encoding lexical class, bar level, the lexi-
cal/functional distinction, and whether they
are topmost within an extended projection
(i.e., a lexical projection with all its func-
tional projections). For clarity, I will how-
ever use abbreviations like VP[-htopl for
</bodyText>
<equation confidence="0.984468923076923">
(verb, max, lex, + top) .17
(15) a. ROOT —&gt; XP[+top]
TA,
b. FP[a] (NP[+top]) F&apos;[a]
(TsuBJ)=4, T=4,
(tropic)=4,
(-1-oBJ)=4,}
c. F&apos;[a] F[a] XP[—top]
TA, TA,
d. VP[a] (NP[+top]) V&apos;[a]
(TsuBJ)=4,
e. V&apos; [a] —&gt; V[a] (NP[+top])
(-1-oBJ)=4,
</equation>
<bodyText confidence="0.9992738125">
The functional annotations follow the an-
notation principles of (Bresnan, 2000), saying
for instance (15e) that the f-structure of the
verb&apos;s complement is introduced under OBJ.
Functional projections are unified with lexical
projections at the level of f-structure (thus the
T=4. for both F[a] and XP[—topl in (15c)).
Note that XP[—topl in (15c) can be instan-
tiated as FP[—topl, leading to a recursion of
FP&apos;s, all mapped to the same f-structure.
(16) lists the lexicon. Under a faithfulness
violation it is possible to skip the lexical con-
tribution, e.g., the FRED introduction by do.
Thus, the candidates in the tableau (5) (and
infinitely many others) are generated by the
grammar.
</bodyText>
<figure confidence="0.745796">
(16) they
who
see
do
</figure>
<footnote confidence="0.984540222222222">
two items with the same index, a bounded subset
of their feature structures has to be regarded. The
restricted structure must be at least the size of the
structure maximally denoted by a constraint; using
abstraction over all constraints as restriction will guar-
antee this.
17FP[+/ —top] is used for functional projections (all
of which will be verbal in this example); XP[±/ —top]
is underspecified for the lexical/functional distinction.
</footnote>
<table confidence="0.306721666666667">
Items are notated as follows:
(17) ( HEAD REMAINING BODY; [non]; in-
dex; book-keeping), where
</table>
<listItem confidence="0.962843333333333">
• REMAINING_BODY (empty for passive
items): selected (here generally leftmost)
element marked by underlining;
• n, m: number of violations of OP-SPEC (2)
and DEP-I0 (3);
• semantic index is written as a list of paths.
</listItem>
<bodyText confidence="0.989615555555555">
The book-keeping keeps track of the struc-
ture constructed so far; for illustrative pur-
poses, I use just the string for this.18 Details
of the control strategy are ignored for clarity
of presentation.
Let us look at the task of generating from
(1), represented here as [FRED-SEE, SUBJ-
PRED-THEY, OBJ-FRED-WHOl. The agenda is
initialized with item
</bodyText>
<equation confidence="0.836394">
(18) ( ANSWER ROOT; [0,0]; [PRED-SEE, SUBJ-
PRED-THEY, OBJ-PRED-WHO]; 0)
</equation>
<bodyText confidence="0.9553975">
Prediction will apply, based on rule (15a),
giving rise to the following new item:
</bodyText>
<equation confidence="0.9007085">
(19) ( ROOT XP[+top]; [0,0]; [PRED-SEE, SUBJ-
PRED-THEY, OBJ-PRED-WHO]; 0),
</equation>
<bodyText confidence="0.99894975">
which will trigger a chain of predictions (note
that the index in these active items is the
selected element&apos;s index, i.e., unless an T=4.
node is selected, the index changes):
</bodyText>
<equation confidence="0.960130071428571">
(20) ( FP[±top] NP[+top] Fq+top]; [0,0]; [sum-
PRED-THEY]; 0 )
(21) ( FP[+top] NP[+top] Fq+top]; [0,0]; [OBJ-
PRED-WHO]; 0 )
(22) ( FP[+top] Fq-ktop]; [0,0]; [PRED-SEE, SUBJ-
PRED-THEY, OBJ-PRED-WHO]; 0)
(23) ( Fq+top] F[+top] XP[—top]; [0,0]; [PRED-
SEE, SUBJ-PRED-THEY, OBJ-PRED-WHO]; 0 )
(24) ( VP[±top] NP[+top] Vq+top]; [0,0]; [SUBJ-
PRED-THEY]; 0)
(25) ( VP[+top] Vq+top]; [0,0]; [PRED-SEE, SUBJ-
PRED-THEY, OBJ-PRED-WHO]; 0)
(26) ( Vq+top] V[+top] (NP[±topp; [0,0]; [PRED-
SEE, SUBJ-PRED-THEY, OBJ-PRED-WHO]; 0 )
</equation>
<footnote confidence="0.756478333333333">
18The string does not represent the string covered
by the selected element, but the entire derivation his-
tory!
</footnote>
<equation confidence="0.679547">
NP[+top]
NP[+top]
V[_]
F[_]
(1-PRED)=`they&apos;
(ToP)=—
(1-PRED)=`who&apos;
(1-0P)=±
(1-PRED)—`see(x, y)&apos;
(1-PRED)—`do(x, y)&apos;
</equation>
<bodyText confidence="0.9997295">
Each of (20) and (24) can undergo scanning
with the entry for they, leading to reduced
items (the index contains the remaining ma-
terial to be generated by the new selection):
</bodyText>
<equation confidence="0.99884875">
(27) ( FP[+top] In+top]; [0,0]; [PRED-SEE, OBJ-
PRED-WHO]; (they) )
(28) ( VP[±top] •&lt;— Vq-ktop]; [0,0]; [PRED-SEE, OBJ-
PRED-WHO]; (they) )
</equation>
<bodyText confidence="0.7078815">
Let us look at (28). The following predic-
tion
</bodyText>
<equation confidence="0.6189975">
(29) ( Vq-ktop] V[+top] (NP[±top]); [0,0]; [PRED-
SEE, OBJ-PRED-WHO]; (they) )
</equation>
<bodyText confidence="0.897300666666667">
can be used to scan see, resulting in two op-
tions, depending whether or not the optional
NP is assumed: another active item
</bodyText>
<listItem confidence="0.54672525">
(30) ( Vq-ktopl NP[+top]; [0,0]; [OBJ-PRED-WHO];
(they see))
or a passive item:
(31) ( [-ktop] c; [0,0]; [PRED-SEE]; (they see) )
</listItem>
<bodyText confidence="0.994255">
When creating a passive item, the struc-
tural OT constraints are checked; however, in
this case, no violations occur.
(30) can be used to scan who, leading to
another passive item (with a different index).
Here, we do have a constraint violation: who
is marked as an operator, but it is not intro-
duced in the topmost specifier position.
</bodyText>
<listItem confidence="0.695413636363636">
(32) ( VIL-ktopl E; [1,0]; [PRED-SEE, OBJ-PRED-
WHO]; (they see who) )
(32) triggers completion of the VP[-htopl
item (not causing any further constraint vio-
lations), which again triggers completion of
the initial ANSWER item. So, we have a first
candidate to cover the entire input.
(33) ( VP[+top] c; [1,0]; [PRED-SEE, SUBJ-PRED-
THEY, OBJ-PRED-WHO]; (they see who))
(34) ( ANSWER c; [1,0]; [PRED-SEE, SUBJ-PRED-
THEY, OBJ-PRED-WHO]; (they see who) )
</listItem>
<bodyText confidence="0.954716">
Going back to (21), this active item can be
used scanning who
</bodyText>
<equation confidence="0.8742852">
(35) ( FP[+top] In-htop]; [0,0]; [PRED-SEE, SUBJ-
PRED-THEY]; (who) )
predicting
(36) ( 11-ktop] F[+top] XP[—top]; [0,0]; [PRED-
SEE, SUBJ-PRED-THEY]; (who) )
</equation>
<bodyText confidence="0.999930857142857">
Here, an interesting case of scanning can
occur: in the lexicon there is an entry of the
selected category F[ 1: do. Its f-annotation
(introducing [PRED-Dol) does not match the
index. But there is the option of using a lexi-
con entry unfaithfully, introducing a violation
of DEP-I0.19 Note the unchanged index.
</bodyText>
<equation confidence="0.917381">
(37) ( 11-ktop] XP[—top]; [0,1]; [PRED-SEE, SUBJ-
PRED-THEY]; (who do))
</equation>
<bodyText confidence="0.999420285714286">
Recall that XP[—topl is either VP[—topl or
FP[—topl. The VP option will give us a par-
tial derivation quite similar to the VP[-htopl
case above ((28)-(31)). Only the object can-
not be realized in the VP, since its resource
path has already been used. So, we get only
the following passive item:
</bodyText>
<equation confidence="0.371617">
(38) ( VP[—top] c; [0,0]; [PRED-SEE, SUBJ-PRED-
THEY]; (who do they see) )
</equation>
<bodyText confidence="0.900976">
This passive item can be used in completion
combined with (37), resulting in the following
passive items:
</bodyText>
<listItem confidence="0.70498525">
(39) ( Fi[+top] c; [0,1]; [PRED-SEE, SUBJ-PRED-
THEY]; (who do they see) )
(40) ( FP[+top] c; [0,1]; [PRED-SEE, SUBJ-PRED-
THEY, OBJ-PRED-WHO]; (who do they see) )
</listItem>
<bodyText confidence="0.99996025">
This will finally trigger completion of (18).
Note that there is already a passive ANSWER
item with the same index: (34). So, classi-
cally, we would have a case of blocking. But
here, the constraint profile is compared, and
it turns out that the new ANSWER item is
more harmonic. So we replace the first item
by this new one:
</bodyText>
<listItem confidence="0.6363265">
(41) ( ANSWER c; [0,1]; [PRED-SEE, SUBJ-PRED-
THEY, OBJ-PRED-WHO]; (who do they see) )
</listItem>
<bodyText confidence="0.99957875">
But processing is not yet finished. The
other option for (37) was that the selected
XP[—topl is an FP[—topl; then, we get the
following new active item (among others):
</bodyText>
<equation confidence="0.5904066">
(42) ( FP[—top] 11—top]; [0,1]; [PRED-SEE, SUBJ-
PRED-THEY]; (who do) )
This will predict
(43) ( 1n—top] F[—top] XP[—top]; [0,1]; [PRED-
SEE, SUBJ-PRED-THEY]; (who do))
</equation>
<bodyText confidence="0.7128502">
19Although DEP-TO could be modelled to be
checked not until passive items are created, it is natu-
ral to keep track of violations along with lexical access.
which can combine with another unfaithful
use of do:
</bodyText>
<equation confidence="0.901482">
(44) ( 1n—top] XP[—top]; [0,2]; [PRED-SEE, SUM-
PRED-THEY]; (who do do) )
</equation>
<bodyText confidence="0.85926">
Again, we have a choice for XP[—topl. We
can pick VP[—topl again, being able to reuse
(38). Completion gives us
</bodyText>
<equation confidence="0.5871794">
(45) ( 11—top] c; [0,2]; [PRED-SEE, SUBJ-PRED-
THEY]; (who do do they see) )
which completes (42) and ultimately (37):
(46) ( 11-ktop] c; [0,2]; [PRED-SEE, SUBJ-PRED-
THEY]; (who do do they see) )
</equation>
<bodyText confidence="0.993505">
But note that such an item exists already:
(39). Comparing the constraint profiles, the
new option is less harmonic (the existing item
used only one do: [0,11). Further predictions
with XP[—topl as FP[—topl are blocked (as in
classical chart parsing/generation).
The sample derivation shows how an infi-
nite set of candidates (basically who do do+
they see) is discarded as an equivalence class.
This makes OT processing with an infinite
candidate set possible. The example was sim-
ple, but the technique carries over to all con-
straints satisfying assumption (14). It may
be required to &amp;quot;pass&amp;quot; a cycle several times be-
fore strict harmony decrease (guaranteed by
(13)) takes effect. The passes of this cyclic
structure have the effect of avoiding the viola-
tion of some high-ranked constraint.20 With
the constraint size bounded, this construction
is guaranteed to terminate. Additional cycle
passes will again cause deterioration.
</bodyText>
<subsectionHeader confidence="0.726624">
4.3 Interleaving parsing and
generation
</subsectionHeader>
<bodyText confidence="0.967988983333334">
As discussed in sec. 3, the recognition and
parsing task for an OT system involves pars-
ing and backward generation. Following ideas
of (Neumann, 1998), I realize this in an inter-
leaved way, assuming a double index for pas-
sive items, so they can be used in both direc-
tions. For parsing with optimizing backward
20Note that an edge avoiding the high-ranked con-
straint will have been constructed already before hit-
ting the recursion, anticipating the larger structure re-
quired. (This is because for any constraint that may
or may not be violated, both options are entered to
the chart.) Thus, the violations incurred by the cycle
will not cut this branch.
generation, the following procedure is effec-
tive:
The agenda is initialized by an active pars-
ing item, indexed by the entire input string.
At the point where normally a passive item
ip is added to the chart, an active generation
item is put on the agenda, with the semantic
index constructed for ip in parsing. This will
trigger an intermediate generation phase, ex-
ploring alternative analyses. Here, optimiza-
tion applies, leading to an optimal item ig
for the semantic index under consideration.
When the generation phase is finished, the ig
is compared to ip. If it is identical, ip is actu-
ally added to the chart; if not, it is ungram-
matical and will be discarded (more precisely,
a record is kept that this particular item has
been shown to be ungrammatical). Later gen-
eration phases can use intermediate results of
the earlier ones.
MAx-I0 violations introduce to parsing
similar situations as DEP-I0 did to genera-
tion: in order to consider all possible underly-
ing representations, a cyclic chart structure
has to be dealt with. If bidirectional opti-
mization is modeled (i.e., the optimal gen-
eration candidates undergo another competi-
tion, leaving only a candidate that is best in
both directions), the computational solution
for generation will carry over directly to pars-
ing: the items constructed in parsing are also
checked for constraint violations and filtered
accordingly.
But MAX-TO violations are also assumed
in models without bidirectional optimization
(which do require bidirectional processing, cf.
sec. 3). So, the recognition task based on
these models seems to pose a decidability
problem. Since there are infinitely many pos-
sible underlying forms for a given string, there
is no straightforward procedure of applying
&amp;quot;backward generation&amp;quot; to each of them. To
guarantee decidability, either (strong21) bidi-
rectional optimization has to be assumed, or
the degree of MAX-TO violations produced by
Gen has to be limited.22
</bodyText>
<footnote confidence="0.879424666666667">
21For a discussion of weaker models, see (Kuhn,
2000a).
221t is however conceivable that in the interleaved
</footnote>
<bodyText confidence="0.999279875">
Implementation. Varges (1997) provides
an experimental Sicstus Prolog implementa-
tion of (Neumann, 1998). On this basis, the
algorithm illustrated in sec. 4.2, and the in-
terleaving discussed in sec. 4.3 have been im-
plemented. The parser/generator has been
tested with small grammar fragments from
the theoretical OT literature.
</bodyText>
<sectionHeader confidence="0.999674" genericHeader="discussions">
5 Discussion
</sectionHeader>
<bodyText confidence="0.99994995">
I proposed a chart-based OT account for syn-
tax, making crucial use of interleaving of pars-
ing and generation. There are several obvious
sources for exponential behaviour:23 (i) con-
straint application leads to highly disjunctive
structures; (ii) for generation, the number of
item sets may grow exponentially in the size
of the input f-structure.24
For (i), sophisticated techniques from fea-
ture grammar parsing (Maxwell and Kaplan,
1998) may help, exploiting de facto indepen-
dence of structures in most cases. Local-
ity restrictions discussed in (Kuhn, 2000b)
may help to limit problem (ii). Also, ex-
ploiting precomputed implications of the con-
straint ranking should have a considerable ef-
fect. Having couched computational OT syn-
tax in the well-studied paradigm of Earley de-
duction will hopefully facilitate such exten-
sions and improvements.
</bodyText>
<sectionHeader confidence="0.994859" genericHeader="acknowledgments">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.954370714285714">
This research was supported by the SFB 340
(project B12) of the Deutsche Forschungs-
gemeinschaft. Thanks to Joan Bresnan,
Anette Frank, Ron Kaplan, Martin Kay,
John Maxwell, Hadar Shemtov, and Jurgen
Wedekind for valuable discussion of various
approach, an indirect control of the infinite candidate
space becomes possible (at least for all linguistically
interesting cases). The idea would be that for all anal-
yses arising through a recursive loop in parsing, it
can be shown systematically that they are production-
based losers to some more harmonic competitor with
the same input (cf. also (Kuhn, 2000a)). This has to
be deferred to future research however.
23But note that parsing is already worst-case expo-
nential for the base grammars.
24Problem (ii) is a theoretical option even for non-
OT generation (Kay, 1996), but the wide-spread un-
faithfulness brings it out in the OT case.
issues related to the formalization and pro-
cessing of OT syntax.
</bodyText>
<sectionHeader confidence="0.995472" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999887192982456">
Joan Bresnan. 1998. Optimal syntax. In J. Dekkers,
F. van der Leeuw, and J. van de Weijer, editors,
Optimality Theory: Phonology, Syntax, and Acqui-
sition. Oxford University Press. To appear.
Joan Bresnan. 2000. Lexical-Functional Syntax.
Blackwell. To appear.
Jane Grimshaw and Vieri Samek-Lodovici. 1998. Op-
timal subjects and subject universals. In P. Bar-
bosa, D. Fox, P. Hagstrom, M. McGinnis, and
D. Pesetsky, editors, Is the Best Good Enough?,
pages 193-219. MIT Press and MITWPL.
Mark Johnson. 1998. Optimality-theoretic Lexi-
cal Functional Grammar. In Proceedings of the
11th Annual CUNY Conference on Human Sen-
tence Processing, Rutgers University. To appear.
Ronald M. Kaplan and Jürgen Wedekind. 2000.
LFG generation produces context-free languages.
In Proceedings of COLING-2000, pages 297-302,
Saarbrficken.
Martin Kay. 1996. Chart generation. In Proceedings
of the 34th Annual Meeting of the Association for
Computational Linguistics, Santa Cruz, CA.
Jonas Kuhn. 1999. Towards a simple architecture for
the structure-function mapping. In M. Butt and
T. H. King, editors, Proceedings of the LFG99 Con-
ference, Manchester, UK, CSLI Proceedings On-
line.
Jonas Kuhn. 2000a. Faithfulness violations and bidi-
rectional optimization. In M. Butt and T. H. King,
editors, Proceedings of the LFG 2000 Conference,
Berkeley, CA, CSLI Proceedings Online. To ap-
pear.
Jonas Kuhn. 2000b. Generation and parsing in Op-
timality Theoretic syntax — issues in the formaliza-
tion of OT-LFG. In (Sells, 2000). To appear.
John Maxwell and Ronald Kaplan. 1998. Unification-
based parsers that automatically take advantage of
context freeness. Ms., Xerox PARC, February 1998.
Gfinter Neumann. 1998. Interleaving natural lan-
guage parsing and generation through uniform pro-
cessing. Artifical Intelligence, 99:121-163.
Fernando Pereira and David Warren. 1983. Parsing
as deduction. In Proceedings of the 21st Annual
Meeting of the Association for Computational Lin-
guistics, Cambridge, MA.
Peter Sells, editor. 2000. Formal and Empirical Issues
in Optimality-theoretic Syntax. CSLI Publications,
Stanford. To appear.
Stuart Shieber. 1988. A uniform architecture for pars-
ing and generation. In Proceedings of the 12th In-
ternational Conference on Computational Linguis-
tics (COLING), Budapest.
Bruce Tesar. 1995. Computational Optimality The-
ory. Ph.D. thesis, University of Colorado.
Sebastian Varges. 1997. Parsing und Generierung
in uniformen Architekturen. Master&apos;s thesis,
Heinrich-Heine-Universitat Düsseldorf.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.904415">
<title confidence="0.9989765">Processing Optimality-theoretic Syntax by Interleaved Chart Parsing and Generation</title>
<author confidence="0.999992">Jonas Kuhn</author>
<affiliation confidence="0.999819">Institut fiir maschinelle Sprachverarbeitung, Universitat Stuttgart</affiliation>
<address confidence="0.988209">AzenbergstraEe 12, D-70174 Stuttgart, Germany</address>
<abstract confidence="0.995013">The Earley deduction algorithm is extended for the processing of OT syntax based on feature grammars. Due to faithfulness violations, infinitely many candidates must be compared. With the (reasonable) assumptions (i) that OT constraints are descriptions denoting bounded structures and (ii) that every rule recursion in the base grammar incurs some constraint violation, a chart algorithm can be devised. Interleaving parsing and generation permits the application of generation-based optimization even in the parsing task, i.e., for a string input.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Joan Bresnan</author>
</authors>
<title>Optimal syntax. In</title>
<date>1998</date>
<booktitle>Optimality Theory: Phonology, Syntax, and Acquisition.</booktitle>
<editor>J. Dekkers, F. van der Leeuw, and J. van de Weijer, editors,</editor>
<publisher>Oxford University Press.</publisher>
<note>To appear.</note>
<contexts>
<context position="1905" citStr="Bresnan (1998)" startWordPosition="272" endWordPosition="273">ombining Tesar&apos;s (1995) chart-based computation of OT competition with insights from parsing/generation with constraint-based grammars (in particular Neumann&apos;s (1998) interleaving). A prototype has been implemented in Prolog. Sec. 2 presents background on OT syntax and a formalization based on LexicalFunctional Grammar (LFG); sec. 3 identifies two computational challenges; sec. 4 presents the Optimality-theoretic Earley deduction approach, interleaving parsing and generation. 2 OT syntax background Various OT syntax models have been assumed. I will follow the OT-LFG approach first proposed by Bresnan (1998), since its representations constituent (c-)structure trees and corresponding feature (f-)structures are well-understood, and there is both work on formalization&apos; and a growing typological literature.2 However, the algorithm itself is largely independent from specifics of OTLFG. The set of competing candidates is defined by a common underlying representation (&amp;quot;input&amp;quot;), in OT-LFG an underspecified fstructure (1), containing all the information relevant for interpretation (i.e., all candidates have the same meaning) .3 (1) PRED `see(x,y)&apos; &apos;they&apos; x crFi [ PRED &apos;person&apos; GF2 [PRED ± OP Candidates a</context>
</contexts>
<marker>Bresnan, 1998</marker>
<rawString>Joan Bresnan. 1998. Optimal syntax. In J. Dekkers, F. van der Leeuw, and J. van de Weijer, editors, Optimality Theory: Phonology, Syntax, and Acquisition. Oxford University Press. To appear.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joan Bresnan</author>
</authors>
<title>Lexical-Functional Syntax.</title>
<date>2000</date>
<publisher>Blackwell.</publisher>
<note>To appear.</note>
<contexts>
<context position="11457" citStr="Bresnan, 2000" startWordPosition="1817" endWordPosition="1818">al case of completion, where a lexicon entry is used to match an active item&apos;s selection. 14If successful, the chart contains one or more passive items covering the entire input, with the grammar&apos;s root symbol as the category. 15A book-keeping scheme ensures that constraints on f-structure are applied only once, so unified fstructures are not regarded twice. 16This operation is justified, since assumption (14) ensures that for comparing the constraint profile of A sample derivation. (15) specifies G invioi, a small extended X-bar fragment. Categories are assumed to have an internal structure (Bresnan, 2000; Kuhn, 1999) encoding lexical class, bar level, the lexical/functional distinction, and whether they are topmost within an extended projection (i.e., a lexical projection with all its functional projections). For clarity, I will however use abbreviations like VP[-htopl for (verb, max, lex, + top) .17 (15) a. ROOT —&gt; XP[+top] TA, b. FP[a] (NP[+top]) F&apos;[a] (TsuBJ)=4, T=4, (tropic)=4, (-1-oBJ)=4,} c. F&apos;[a] F[a] XP[—top] TA, TA, d. VP[a] (NP[+top]) V&apos;[a] (TsuBJ)=4, e. V&apos; [a] —&gt; V[a] (NP[+top]) (-1-oBJ)=4, The functional annotations follow the annotation principles of (Bresnan, 2000), saying for i</context>
</contexts>
<marker>Bresnan, 2000</marker>
<rawString>Joan Bresnan. 2000. Lexical-Functional Syntax. Blackwell. To appear.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jane Grimshaw</author>
<author>Vieri Samek-Lodovici</author>
</authors>
<title>Optimal subjects and subject universals.</title>
<date>1998</date>
<booktitle>Is the Best Good Enough?,</booktitle>
<pages>193--219</pages>
<editor>In P. Barbosa, D. Fox, P. Hagstrom, M. McGinnis, and D. Pesetsky, editors,</editor>
<publisher>MIT Press and MITWPL.</publisher>
<marker>Grimshaw, Samek-Lodovici, 1998</marker>
<rawString>Jane Grimshaw and Vieri Samek-Lodovici. 1998. Optimal subjects and subject universals. In P. Barbosa, D. Fox, P. Hagstrom, M. McGinnis, and D. Pesetsky, editors, Is the Best Good Enough?, pages 193-219. MIT Press and MITWPL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Johnson</author>
</authors>
<title>Optimality-theoretic Lexical Functional Grammar.</title>
<date>1998</date>
<booktitle>In Proceedings of the 11th Annual CUNY Conference on Human Sentence Processing,</booktitle>
<institution>Rutgers University.</institution>
<note>To appear.</note>
<contexts>
<context position="2758" citStr="Johnson, 1998" startWordPosition="395" endWordPosition="396">ly independent from specifics of OTLFG. The set of competing candidates is defined by a common underlying representation (&amp;quot;input&amp;quot;), in OT-LFG an underspecified fstructure (1), containing all the information relevant for interpretation (i.e., all candidates have the same meaning) .3 (1) PRED `see(x,y)&apos; &apos;they&apos; x crFi [ PRED &apos;person&apos; GF2 [PRED ± OP Candidates are c-structure/f-structure pairs defined by a grammar Ginvio/ encoding the inviolable principles (extended X-bar theory). While each candidate&apos;s f-structure has to be subsumed by the input, the c-structure and lexical filling can deviate &apos;(Johnson, 1998; Kuhn, 2000a; Kuhn, 2000b) 2See e.g., the contributions in (Sells, 2000). 3A richer semantic representation could be assumed, making quantifier scope explicit, etc. In the OT-LFG literature, the argument structure reflected in f-structure has been largely sufficient. ☞ generation marks (Ti, i) (T2,432) (Tr, 43.1) ■ (n44, n2,1, • • • ,nk,i) ▪ n2,2, • • • ,nk,2) ■ • (ni,j , n2„ , nk,j) Figure 1: Sketch of generation-based OT processing The violable constraints can be expressed as (implicative) descriptions of the candidate&apos;s cstructure and f-structure (Kuhn, 2000b). The constraint marking funct</context>
<context position="5536" citStr="Johnson (1998)" startWordPosition="857" endWordPosition="859">paration. are compatible with the intuitions behind the OT accounts in the literature.7 (13) The constraints are such that every application of recursive rules from incurs some constraint violation!&apos; (14) OT constraints are structural descriptions denoting bounded structures.9 Tesar (1995) exploits this property in his dynamic programming (or chart-based) algorithm for regular languages and context-free &amp;quot;position grammars&amp;quot;. In sec. 4.2, this is extended to feature grammars. The second computational challenge arises for the recognition and parsing task for an OT language defined as in (12). As Johnson (1998) notes, a technique symmetrical to the one sketched in fig. 1 i.e., parsing a string and comparing the constraint marking of the different analyses does not realize the parsing task for the language defined by the original system: strings that are not optimal for any underlying representation d)in according to (12) will be wrongly predicted to be grammatical since trivially, one of these will be optimal for this parsing-based optimization. 7A straightforward way to satisfy (13) is to assume a constraint AVOIDSTRUC, which is violated once by every c-structure node. 8 ( 13) can be seen as a rela</context>
</contexts>
<marker>Johnson, 1998</marker>
<rawString>Mark Johnson. 1998. Optimality-theoretic Lexical Functional Grammar. In Proceedings of the 11th Annual CUNY Conference on Human Sentence Processing, Rutgers University. To appear.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ronald M Kaplan</author>
<author>Jürgen Wedekind</author>
</authors>
<title>LFG generation produces context-free languages.</title>
<date>2000</date>
<booktitle>In Proceedings of COLING-2000,</booktitle>
<pages>297--302</pages>
<location>Saarbrficken.</location>
<contexts>
<context position="6845" citStr="Kaplan and Wedekind (2000)" startWordPosition="1065" endWordPosition="1068">erability restriction: In classical parsing/generation, these restrictions exclude rule recursion to be applied vacuously (wrt. the input, i.e., a string/a resourced feature structure), because this would lead to an infinite number of c-structures. In the OT-LFG setting, Gen specifies an infinite set of candidates, and it is the constraints that control the traversal of the candidate space. A reviewer points out that (13) may not be necessary, since for an infinite set of equally harmonic candidates arising through pumping (cf. fn. 6), the &amp;quot;unpumped&amp;quot; version could be used as a representative. Kaplan and Wedekind (2000) make a similar point for classical generation. 9Note that (14) does not exclude that a constraint can have an effect on some unboundedly remote part of the structure (through constraint interaction). Modelling the recognition and parsing task computationally will involve a bidirectional processing effort (Kuhn, 2000b): the string is parsed to detect possible underlying representations, and from these a &amp;quot;backward generation&amp;quot; step is performed, for which OT evaluation is applied. Only if the parsed string is matched by the optimal candidate for its underlying representation, is the string gramm</context>
</contexts>
<marker>Kaplan, Wedekind, 2000</marker>
<rawString>Ronald M. Kaplan and Jürgen Wedekind. 2000. LFG generation produces context-free languages. In Proceedings of COLING-2000, pages 297-302, Saarbrficken.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Martin Kay</author>
</authors>
<title>Chart generation.</title>
<date>1996</date>
<booktitle>In Proceedings of the 34th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<location>Santa Cruz, CA.</location>
<marker>Kay, 1996</marker>
<rawString>Martin Kay. 1996. Chart generation. In Proceedings of the 34th Annual Meeting of the Association for Computational Linguistics, Santa Cruz, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jonas Kuhn</author>
</authors>
<title>Towards a simple architecture for the structure-function mapping.</title>
<date>1999</date>
<booktitle>Proceedings of the LFG99 Conference,</booktitle>
<editor>In M. Butt and T. H. King, editors,</editor>
<publisher>CSLI Proceedings Online.</publisher>
<location>Manchester, UK,</location>
<contexts>
<context position="11470" citStr="Kuhn, 1999" startWordPosition="1819" endWordPosition="1820">letion, where a lexicon entry is used to match an active item&apos;s selection. 14If successful, the chart contains one or more passive items covering the entire input, with the grammar&apos;s root symbol as the category. 15A book-keeping scheme ensures that constraints on f-structure are applied only once, so unified fstructures are not regarded twice. 16This operation is justified, since assumption (14) ensures that for comparing the constraint profile of A sample derivation. (15) specifies G invioi, a small extended X-bar fragment. Categories are assumed to have an internal structure (Bresnan, 2000; Kuhn, 1999) encoding lexical class, bar level, the lexical/functional distinction, and whether they are topmost within an extended projection (i.e., a lexical projection with all its functional projections). For clarity, I will however use abbreviations like VP[-htopl for (verb, max, lex, + top) .17 (15) a. ROOT —&gt; XP[+top] TA, b. FP[a] (NP[+top]) F&apos;[a] (TsuBJ)=4, T=4, (tropic)=4, (-1-oBJ)=4,} c. F&apos;[a] F[a] XP[—top] TA, TA, d. VP[a] (NP[+top]) V&apos;[a] (TsuBJ)=4, e. V&apos; [a] —&gt; V[a] (NP[+top]) (-1-oBJ)=4, The functional annotations follow the annotation principles of (Bresnan, 2000), saying for instance (15e)</context>
</contexts>
<marker>Kuhn, 1999</marker>
<rawString>Jonas Kuhn. 1999. Towards a simple architecture for the structure-function mapping. In M. Butt and T. H. King, editors, Proceedings of the LFG99 Conference, Manchester, UK, CSLI Proceedings Online.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jonas Kuhn</author>
</authors>
<title>Faithfulness violations and bidirectional optimization.</title>
<date>2000</date>
<booktitle>Proceedings of the LFG 2000 Conference, Berkeley, CA, CSLI Proceedings Online.</booktitle>
<editor>In M. Butt and T. H. King, editors,</editor>
<note>To appear.</note>
<contexts>
<context position="2770" citStr="Kuhn, 2000" startWordPosition="397" endWordPosition="398">from specifics of OTLFG. The set of competing candidates is defined by a common underlying representation (&amp;quot;input&amp;quot;), in OT-LFG an underspecified fstructure (1), containing all the information relevant for interpretation (i.e., all candidates have the same meaning) .3 (1) PRED `see(x,y)&apos; &apos;they&apos; x crFi [ PRED &apos;person&apos; GF2 [PRED ± OP Candidates are c-structure/f-structure pairs defined by a grammar Ginvio/ encoding the inviolable principles (extended X-bar theory). While each candidate&apos;s f-structure has to be subsumed by the input, the c-structure and lexical filling can deviate &apos;(Johnson, 1998; Kuhn, 2000a; Kuhn, 2000b) 2See e.g., the contributions in (Sells, 2000). 3A richer semantic representation could be assumed, making quantifier scope explicit, etc. In the OT-LFG literature, the argument structure reflected in f-structure has been largely sufficient. ☞ generation marks (Ti, i) (T2,432) (Tr, 43.1) ■ (n44, n2,1, • • • ,nk,i) ▪ n2,2, • • • ,nk,2) ■ • (ni,j , n2„ , nk,j) Figure 1: Sketch of generation-based OT processing The violable constraints can be expressed as (implicative) descriptions of the candidate&apos;s cstructure and f-structure (Kuhn, 2000b). The constraint marking function marks is</context>
<context position="7163" citStr="Kuhn, 2000" startWordPosition="1113" endWordPosition="1114">straints that control the traversal of the candidate space. A reviewer points out that (13) may not be necessary, since for an infinite set of equally harmonic candidates arising through pumping (cf. fn. 6), the &amp;quot;unpumped&amp;quot; version could be used as a representative. Kaplan and Wedekind (2000) make a similar point for classical generation. 9Note that (14) does not exclude that a constraint can have an effect on some unboundedly remote part of the structure (through constraint interaction). Modelling the recognition and parsing task computationally will involve a bidirectional processing effort (Kuhn, 2000b): the string is parsed to detect possible underlying representations, and from these a &amp;quot;backward generation&amp;quot; step is performed, for which OT evaluation is applied. Only if the parsed string is matched by the optimal candidate for its underlying representation, is the string grammatical.1° Faithfulness violations of the MAX-TO type (7) allow for situations where underlying material is not reflected by any of the lexical material. Unless one introduces a bound for such violations by definition (restricting the generality of the computational model), it turns out that the parsing task in the bi</context>
<context position="8991" citStr="Kuhn, 2000" startWordPosition="1406" endWordPosition="1407"> (or instantiation) and completion (or reduction). In parsing, the goal&apos;s string is specified (and used as its index); in generation, its underlying representation is. An agenda is used as a control structure; items on the agenda and in the chart have the form of definite clauses. We distinguish (i) active items, &amp;quot;looking for&amp;quot; material of a certain category and with certain 10 AA s just laid out, the model involves bidirectional processing, but optimization applies only in one (the generation) direction. It is however straightforward to extend this model to a bidirectional optimization model (Kuhn, 2000a). &amp;quot;This becomes clear in structure (ii) in fn. 5 above. 12Cf. (Shieber, 1988); I adopt Neumann&apos;s (1998) uniform agenda-driven tabular algorithm. features (their selected element), and (ii) passive items, stating that certain material has already been found. When matching, a passive and an active item can be combined by completion.13 Active items come into existence through prediction, based on a grammar rule. Before creating a new chart item and triggering inference rules based on it, it is checked whether such an item exists already (i.e., it is blocked), avoiding unnecessary recomputations</context>
<context position="22550" citStr="Kuhn, 2000" startWordPosition="3618" endWordPosition="3619">. But MAX-TO violations are also assumed in models without bidirectional optimization (which do require bidirectional processing, cf. sec. 3). So, the recognition task based on these models seems to pose a decidability problem. Since there are infinitely many possible underlying forms for a given string, there is no straightforward procedure of applying &amp;quot;backward generation&amp;quot; to each of them. To guarantee decidability, either (strong21) bidirectional optimization has to be assumed, or the degree of MAX-TO violations produced by Gen has to be limited.22 21For a discussion of weaker models, see (Kuhn, 2000a). 221t is however conceivable that in the interleaved Implementation. Varges (1997) provides an experimental Sicstus Prolog implementation of (Neumann, 1998). On this basis, the algorithm illustrated in sec. 4.2, and the interleaving discussed in sec. 4.3 have been implemented. The parser/generator has been tested with small grammar fragments from the theoretical OT literature. 5 Discussion I proposed a chart-based OT account for syntax, making crucial use of interleaving of parsing and generation. There are several obvious sources for exponential behaviour:23 (i) constraint application lead</context>
</contexts>
<marker>Kuhn, 2000</marker>
<rawString>Jonas Kuhn. 2000a. Faithfulness violations and bidirectional optimization. In M. Butt and T. H. King, editors, Proceedings of the LFG 2000 Conference, Berkeley, CA, CSLI Proceedings Online. To appear.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jonas Kuhn</author>
</authors>
<title>Generation and parsing in Optimality Theoretic syntax — issues in the formalization of OT-LFG. In (Sells,</title>
<date>2000</date>
<note>To appear.</note>
<contexts>
<context position="2770" citStr="Kuhn, 2000" startWordPosition="397" endWordPosition="398">from specifics of OTLFG. The set of competing candidates is defined by a common underlying representation (&amp;quot;input&amp;quot;), in OT-LFG an underspecified fstructure (1), containing all the information relevant for interpretation (i.e., all candidates have the same meaning) .3 (1) PRED `see(x,y)&apos; &apos;they&apos; x crFi [ PRED &apos;person&apos; GF2 [PRED ± OP Candidates are c-structure/f-structure pairs defined by a grammar Ginvio/ encoding the inviolable principles (extended X-bar theory). While each candidate&apos;s f-structure has to be subsumed by the input, the c-structure and lexical filling can deviate &apos;(Johnson, 1998; Kuhn, 2000a; Kuhn, 2000b) 2See e.g., the contributions in (Sells, 2000). 3A richer semantic representation could be assumed, making quantifier scope explicit, etc. In the OT-LFG literature, the argument structure reflected in f-structure has been largely sufficient. ☞ generation marks (Ti, i) (T2,432) (Tr, 43.1) ■ (n44, n2,1, • • • ,nk,i) ▪ n2,2, • • • ,nk,2) ■ • (ni,j , n2„ , nk,j) Figure 1: Sketch of generation-based OT processing The violable constraints can be expressed as (implicative) descriptions of the candidate&apos;s cstructure and f-structure (Kuhn, 2000b). The constraint marking function marks is</context>
<context position="7163" citStr="Kuhn, 2000" startWordPosition="1113" endWordPosition="1114">straints that control the traversal of the candidate space. A reviewer points out that (13) may not be necessary, since for an infinite set of equally harmonic candidates arising through pumping (cf. fn. 6), the &amp;quot;unpumped&amp;quot; version could be used as a representative. Kaplan and Wedekind (2000) make a similar point for classical generation. 9Note that (14) does not exclude that a constraint can have an effect on some unboundedly remote part of the structure (through constraint interaction). Modelling the recognition and parsing task computationally will involve a bidirectional processing effort (Kuhn, 2000b): the string is parsed to detect possible underlying representations, and from these a &amp;quot;backward generation&amp;quot; step is performed, for which OT evaluation is applied. Only if the parsed string is matched by the optimal candidate for its underlying representation, is the string grammatical.1° Faithfulness violations of the MAX-TO type (7) allow for situations where underlying material is not reflected by any of the lexical material. Unless one introduces a bound for such violations by definition (restricting the generality of the computational model), it turns out that the parsing task in the bi</context>
<context position="8991" citStr="Kuhn, 2000" startWordPosition="1406" endWordPosition="1407"> (or instantiation) and completion (or reduction). In parsing, the goal&apos;s string is specified (and used as its index); in generation, its underlying representation is. An agenda is used as a control structure; items on the agenda and in the chart have the form of definite clauses. We distinguish (i) active items, &amp;quot;looking for&amp;quot; material of a certain category and with certain 10 AA s just laid out, the model involves bidirectional processing, but optimization applies only in one (the generation) direction. It is however straightforward to extend this model to a bidirectional optimization model (Kuhn, 2000a). &amp;quot;This becomes clear in structure (ii) in fn. 5 above. 12Cf. (Shieber, 1988); I adopt Neumann&apos;s (1998) uniform agenda-driven tabular algorithm. features (their selected element), and (ii) passive items, stating that certain material has already been found. When matching, a passive and an active item can be combined by completion.13 Active items come into existence through prediction, based on a grammar rule. Before creating a new chart item and triggering inference rules based on it, it is checked whether such an item exists already (i.e., it is blocked), avoiding unnecessary recomputations</context>
<context position="22550" citStr="Kuhn, 2000" startWordPosition="3618" endWordPosition="3619">. But MAX-TO violations are also assumed in models without bidirectional optimization (which do require bidirectional processing, cf. sec. 3). So, the recognition task based on these models seems to pose a decidability problem. Since there are infinitely many possible underlying forms for a given string, there is no straightforward procedure of applying &amp;quot;backward generation&amp;quot; to each of them. To guarantee decidability, either (strong21) bidirectional optimization has to be assumed, or the degree of MAX-TO violations produced by Gen has to be limited.22 21For a discussion of weaker models, see (Kuhn, 2000a). 221t is however conceivable that in the interleaved Implementation. Varges (1997) provides an experimental Sicstus Prolog implementation of (Neumann, 1998). On this basis, the algorithm illustrated in sec. 4.2, and the interleaving discussed in sec. 4.3 have been implemented. The parser/generator has been tested with small grammar fragments from the theoretical OT literature. 5 Discussion I proposed a chart-based OT account for syntax, making crucial use of interleaving of parsing and generation. There are several obvious sources for exponential behaviour:23 (i) constraint application lead</context>
</contexts>
<marker>Kuhn, 2000</marker>
<rawString>Jonas Kuhn. 2000b. Generation and parsing in Optimality Theoretic syntax — issues in the formalization of OT-LFG. In (Sells, 2000). To appear.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John Maxwell</author>
<author>Ronald Kaplan</author>
</authors>
<title>Unificationbased parsers that automatically take advantage of context freeness. Ms., Xerox PARC,</title>
<date>1998</date>
<contexts>
<context position="23383" citStr="Maxwell and Kaplan, 1998" startWordPosition="3741" endWordPosition="3744">. 4.2, and the interleaving discussed in sec. 4.3 have been implemented. The parser/generator has been tested with small grammar fragments from the theoretical OT literature. 5 Discussion I proposed a chart-based OT account for syntax, making crucial use of interleaving of parsing and generation. There are several obvious sources for exponential behaviour:23 (i) constraint application leads to highly disjunctive structures; (ii) for generation, the number of item sets may grow exponentially in the size of the input f-structure.24 For (i), sophisticated techniques from feature grammar parsing (Maxwell and Kaplan, 1998) may help, exploiting de facto independence of structures in most cases. Locality restrictions discussed in (Kuhn, 2000b) may help to limit problem (ii). Also, exploiting precomputed implications of the constraint ranking should have a considerable effect. Having couched computational OT syntax in the well-studied paradigm of Earley deduction will hopefully facilitate such extensions and improvements. Acknowledgements This research was supported by the SFB 340 (project B12) of the Deutsche Forschungsgemeinschaft. Thanks to Joan Bresnan, Anette Frank, Ron Kaplan, Martin Kay, John Maxwell, Hadar</context>
</contexts>
<marker>Maxwell, Kaplan, 1998</marker>
<rawString>John Maxwell and Ronald Kaplan. 1998. Unificationbased parsers that automatically take advantage of context freeness. Ms., Xerox PARC, February 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gfinter Neumann</author>
</authors>
<title>Interleaving natural language parsing and generation through uniform processing.</title>
<date>1998</date>
<journal>Artifical Intelligence,</journal>
<pages>99--121</pages>
<contexts>
<context position="20054" citStr="Neumann, 1998" startWordPosition="3211" endWordPosition="3212">arries over to all constraints satisfying assumption (14). It may be required to &amp;quot;pass&amp;quot; a cycle several times before strict harmony decrease (guaranteed by (13)) takes effect. The passes of this cyclic structure have the effect of avoiding the violation of some high-ranked constraint.20 With the constraint size bounded, this construction is guaranteed to terminate. Additional cycle passes will again cause deterioration. 4.3 Interleaving parsing and generation As discussed in sec. 3, the recognition and parsing task for an OT system involves parsing and backward generation. Following ideas of (Neumann, 1998), I realize this in an interleaved way, assuming a double index for passive items, so they can be used in both directions. For parsing with optimizing backward 20Note that an edge avoiding the high-ranked constraint will have been constructed already before hitting the recursion, anticipating the larger structure required. (This is because for any constraint that may or may not be violated, both options are entered to the chart.) Thus, the violations incurred by the cycle will not cut this branch. generation, the following procedure is effective: The agenda is initialized by an active parsing </context>
<context position="22709" citStr="Neumann, 1998" startWordPosition="3639" endWordPosition="3640">gnition task based on these models seems to pose a decidability problem. Since there are infinitely many possible underlying forms for a given string, there is no straightforward procedure of applying &amp;quot;backward generation&amp;quot; to each of them. To guarantee decidability, either (strong21) bidirectional optimization has to be assumed, or the degree of MAX-TO violations produced by Gen has to be limited.22 21For a discussion of weaker models, see (Kuhn, 2000a). 221t is however conceivable that in the interleaved Implementation. Varges (1997) provides an experimental Sicstus Prolog implementation of (Neumann, 1998). On this basis, the algorithm illustrated in sec. 4.2, and the interleaving discussed in sec. 4.3 have been implemented. The parser/generator has been tested with small grammar fragments from the theoretical OT literature. 5 Discussion I proposed a chart-based OT account for syntax, making crucial use of interleaving of parsing and generation. There are several obvious sources for exponential behaviour:23 (i) constraint application leads to highly disjunctive structures; (ii) for generation, the number of item sets may grow exponentially in the size of the input f-structure.24 For (i), sophis</context>
</contexts>
<marker>Neumann, 1998</marker>
<rawString>Gfinter Neumann. 1998. Interleaving natural language parsing and generation through uniform processing. Artifical Intelligence, 99:121-163.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fernando Pereira</author>
<author>David Warren</author>
</authors>
<title>Parsing as deduction.</title>
<date>1983</date>
<booktitle>In Proceedings of the 21st Annual Meeting of the Association for Computational Linguistics,</booktitle>
<location>Cambridge, MA.</location>
<contexts>
<context position="8254" citStr="Pereira and Warren, 1983" startWordPosition="1284" endWordPosition="1287">or such violations by definition (restricting the generality of the computational model), it turns out that the parsing task in the bidirectional processing scheme cannot be subjected to the standard restriction of offline parsability (cf. fn. 13):n like in generation, the set of parsing alternatives that have to be considered is infinite, so a systematic traversal of the search space is required (sec. 4.3). 4 Optimality-theoretic Earley deduction 4.1 Earley deduction for parsing and generation Since the chart-based algorithm to be developed is to work bidirectionally, using Earley deduction (Pereira and Warren, 1983) is a natural choice.12 Parsing and generation amounts to deduction of a given goal using two basic inference rules: prediction (or instantiation) and completion (or reduction). In parsing, the goal&apos;s string is specified (and used as its index); in generation, its underlying representation is. An agenda is used as a control structure; items on the agenda and in the chart have the form of definite clauses. We distinguish (i) active items, &amp;quot;looking for&amp;quot; material of a certain category and with certain 10 AA s just laid out, the model involves bidirectional processing, but optimization applies onl</context>
</contexts>
<marker>Pereira, Warren, 1983</marker>
<rawString>Fernando Pereira and David Warren. 1983. Parsing as deduction. In Proceedings of the 21st Annual Meeting of the Association for Computational Linguistics, Cambridge, MA.</rawString>
</citation>
<citation valid="true">
<title>Formal and Empirical Issues in Optimality-theoretic Syntax.</title>
<date>2000</date>
<editor>Peter Sells, editor.</editor>
<publisher>CSLI Publications, Stanford.</publisher>
<note>To appear.</note>
<contexts>
<context position="6845" citStr="(2000)" startWordPosition="1068" endWordPosition="1068">n: In classical parsing/generation, these restrictions exclude rule recursion to be applied vacuously (wrt. the input, i.e., a string/a resourced feature structure), because this would lead to an infinite number of c-structures. In the OT-LFG setting, Gen specifies an infinite set of candidates, and it is the constraints that control the traversal of the candidate space. A reviewer points out that (13) may not be necessary, since for an infinite set of equally harmonic candidates arising through pumping (cf. fn. 6), the &amp;quot;unpumped&amp;quot; version could be used as a representative. Kaplan and Wedekind (2000) make a similar point for classical generation. 9Note that (14) does not exclude that a constraint can have an effect on some unboundedly remote part of the structure (through constraint interaction). Modelling the recognition and parsing task computationally will involve a bidirectional processing effort (Kuhn, 2000b): the string is parsed to detect possible underlying representations, and from these a &amp;quot;backward generation&amp;quot; step is performed, for which OT evaluation is applied. Only if the parsed string is matched by the optimal candidate for its underlying representation, is the string gramm</context>
</contexts>
<marker>2000</marker>
<rawString>Peter Sells, editor. 2000. Formal and Empirical Issues in Optimality-theoretic Syntax. CSLI Publications, Stanford. To appear.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart Shieber</author>
</authors>
<title>A uniform architecture for parsing and generation.</title>
<date>1988</date>
<booktitle>In Proceedings of the 12th International Conference on Computational Linguistics (COLING),</booktitle>
<location>Budapest.</location>
<contexts>
<context position="9070" citStr="Shieber, 1988" startWordPosition="1419" endWordPosition="1420">tring is specified (and used as its index); in generation, its underlying representation is. An agenda is used as a control structure; items on the agenda and in the chart have the form of definite clauses. We distinguish (i) active items, &amp;quot;looking for&amp;quot; material of a certain category and with certain 10 AA s just laid out, the model involves bidirectional processing, but optimization applies only in one (the generation) direction. It is however straightforward to extend this model to a bidirectional optimization model (Kuhn, 2000a). &amp;quot;This becomes clear in structure (ii) in fn. 5 above. 12Cf. (Shieber, 1988); I adopt Neumann&apos;s (1998) uniform agenda-driven tabular algorithm. features (their selected element), and (ii) passive items, stating that certain material has already been found. When matching, a passive and an active item can be combined by completion.13 Active items come into existence through prediction, based on a grammar rule. Before creating a new chart item and triggering inference rules based on it, it is checked whether such an item exists already (i.e., it is blocked), avoiding unnecessary recomputations. The algorithm is initialized by putting an active item looking for the gramma</context>
</contexts>
<marker>Shieber, 1988</marker>
<rawString>Stuart Shieber. 1988. A uniform architecture for parsing and generation. In Proceedings of the 12th International Conference on Computational Linguistics (COLING), Budapest.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bruce Tesar</author>
</authors>
<title>Computational Optimality Theory.</title>
<date>1995</date>
<tech>Ph.D. thesis,</tech>
<institution>University of Colorado.</institution>
<contexts>
<context position="5212" citStr="Tesar (1995)" startWordPosition="807" endWordPosition="808">e problem: with assumptions (13) and (14), there will be a point in any traversal of a base grammar recursion from which on all larger candidates are less harmonic than one given candidate.6 To my knowledge, these assumptions 6This is a consequence of the pumping lemma for context-free languages. A formal proof is in preparation. are compatible with the intuitions behind the OT accounts in the literature.7 (13) The constraints are such that every application of recursive rules from incurs some constraint violation!&apos; (14) OT constraints are structural descriptions denoting bounded structures.9 Tesar (1995) exploits this property in his dynamic programming (or chart-based) algorithm for regular languages and context-free &amp;quot;position grammars&amp;quot;. In sec. 4.2, this is extended to feature grammars. The second computational challenge arises for the recognition and parsing task for an OT language defined as in (12). As Johnson (1998) notes, a technique symmetrical to the one sketched in fig. 1 i.e., parsing a string and comparing the constraint marking of the different analyses does not realize the parsing task for the language defined by the original system: strings that are not optimal for any underlyi</context>
</contexts>
<marker>Tesar, 1995</marker>
<rawString>Bruce Tesar. 1995. Computational Optimality Theory. Ph.D. thesis, University of Colorado.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Sebastian Varges</author>
</authors>
<title>Parsing und Generierung in uniformen Architekturen. Master&apos;s thesis,</title>
<date>1997</date>
<location>Heinrich-Heine-Universitat Düsseldorf.</location>
<contexts>
<context position="22635" citStr="Varges (1997)" startWordPosition="3629" endWordPosition="3630">ion (which do require bidirectional processing, cf. sec. 3). So, the recognition task based on these models seems to pose a decidability problem. Since there are infinitely many possible underlying forms for a given string, there is no straightforward procedure of applying &amp;quot;backward generation&amp;quot; to each of them. To guarantee decidability, either (strong21) bidirectional optimization has to be assumed, or the degree of MAX-TO violations produced by Gen has to be limited.22 21For a discussion of weaker models, see (Kuhn, 2000a). 221t is however conceivable that in the interleaved Implementation. Varges (1997) provides an experimental Sicstus Prolog implementation of (Neumann, 1998). On this basis, the algorithm illustrated in sec. 4.2, and the interleaving discussed in sec. 4.3 have been implemented. The parser/generator has been tested with small grammar fragments from the theoretical OT literature. 5 Discussion I proposed a chart-based OT account for syntax, making crucial use of interleaving of parsing and generation. There are several obvious sources for exponential behaviour:23 (i) constraint application leads to highly disjunctive structures; (ii) for generation, the number of item sets may </context>
</contexts>
<marker>Varges, 1997</marker>
<rawString>Sebastian Varges. 1997. Parsing und Generierung in uniformen Architekturen. Master&apos;s thesis, Heinrich-Heine-Universitat Düsseldorf.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>