<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000018">
<title confidence="0.911787">
The Formal and Processing Models of CLG
</title>
<author confidence="0.859229">
Luis DAMAS
</author>
<affiliation confidence="0.7897225">
Nelma MOREIRA
University of Porto, Campo Alegre 823
</affiliation>
<address confidence="0.764941">
P-4000 Porto
</address>
<email confidence="0.906374">
luis@nccup.ctt.pt
</email>
<bodyText confidence="0.998779111111111">
Abstract: We present the formal
processing model of CLG, a logic grammar
formalism based on complex constraint
resolution. In particular, we show how to
monotonically extend terms and their unification
to constrained terms and their resolution. The
simple CLG constraint rewrite scheme is
presented and its consequence for CLG&apos;s
multiple delay model explained.
</bodyText>
<keyword confidence="0.737834">
Keywords: Grammatical formalisms,
Complex constraint resolution.
</keyword>
<sectionHeader confidence="0.975714" genericHeader="abstract">
Introduction
</sectionHeader>
<bodyText confidence="0.992362052631579">
CLG is a family of grammar formalisms
based on complex constraint resolution designed,
implemented and tested over the last three years.
CLG grammars consist of the description of
global and local constraints of linguistic objects
as described in [1] and [2].
For the more recent members of the CLG
family, global constraints consist of sort
declarations and the definition of relation between
sorts, while local constraints consist of partial
lexical and phrasal descriptions. The sorts
definable in CLG are closed, in a way akin to the
ones used by UCG 13]. Relations over sorts
represent the statement of linguistic principles in
the spirit of HPSG [4].
The constraint language is a classical first
order language with the usual unary and binary
logical connectives, i.e. negation (—), conjunction
(&amp;), disjunction (I), material implication (-4),
equivalence (&lt;---&gt;) and a restricted form of
quantification (V and 3 ) over finitely
instantiatable domains. The interpretation of these
connectives in CLG is strictly classical as in
Smolka&apos;s FL [6] and Johnson&apos;s AVL [5], unlike
the intuitionistic interpretation of negation of
Moshier and Rounds [7]. A more detailed
Giovanni B. VARILE
CEC
Jean Monnet Bldg. B4/001
L-2920 Luxembourg
nino@eurokom.ie
description of CLG including its &amp;notational
semantics can be found in 121.
In this paper we present the formal processing
model of CLG, which has been influenced by the
Constraint Logic Programming paradigm 181 NI.
We show in what way it extends pure unification
based formalisms and how it achieves a sound
implementation of classically interpreted first
order logic while maintaining practical
computational behaviour by resorting to a simple
set of constraint rewrite rules and a lazy
evaluation model for constraints satisfaction thus
avoiding the problem mentioned in 1101
concerning the non-monotonic properties of
negation and implication interpreted in the
Herbrand universe.
The paper is organized as follows: in the first
part we show how we extend term unification to
accommodate complex constraint resolution. We
then explain what rewrites are involved in CLG
constraint resolution, proceeding to show what
the benefits of the delayed evaluation model of
CLG are. We conclude by discussing some of the
issues involved in our approach and compare it to
other approaches based on standard first order
logics.
</bodyText>
<subsectionHeader confidence="0.994771">
From Unification to Constraint
Solving
</subsectionHeader>
<bodyText confidence="0.99956">
We will first show how to extend a unification
based parsing algorithm for a grammar formalism
based on an equational theory, to an algorithm for
a formalism with complex constraints attached to
rules.
Assume a countable set V of variables x, y,
z, ... and a countable set F of function symbols
f, g, h, ... each one equipped with an arity
expressed as P. Let T be the term algebra over F
and V, and To be the corresponding set of
ground terms.
</bodyText>
<equation confidence="0.693544333333333">
- 173 -
Assume furthermore that rules are of the form:
t
</equation>
<bodyText confidence="0.961361571428571">
for t , t1 ,...,tn are in T
and that the parsing algorithm relies solely on the
unification algorithm for its operation, applying it
to terms and either computing a unifier of those
terms or failing.
Associating with a term t its usual denotation
at0={St E TO)
(where S denotes a substitution of terms for
variables) the unifier t of two terms C and C
has the following important property
if till = (fft&amp;quot;jl
Next we introduce constraints over terms in
T. For the moment we will assume that
constraints c include at least atomic equality
constraints between terms and formulas built
from the atomic constraints using the standard
logic operators, namely disjunction, conjunction
and negation, and that a notion of validity can be
defined for closed formulas (see however [2] for
an extended constraint language).
We will extend terms to constrained terms t:c,
where c is a constraint involving only variables
occurring in t, and take
Ilt :c 11= [ St E TO I I— Sc)
as its denotation.
Now, given constrained terms t:c, t&apos;:c&apos; and
t&amp;quot;:c&amp;quot; we say that t:c is a unifier of t&apos;:c&apos; and t&amp;quot;:c&amp;quot;
iff
</bodyText>
<equation confidence="0.721854">
[&apos;Lc 1J= ift&amp;quot;:c&amp;quot;11.
</equation>
<bodyText confidence="0.999876697674419">
It is easy to see that there is at least one
algorithm which given two constrained terms
either fails, if they do not admit a unifier, or else
returns one unifier of the given terms. As a matter
of fact it is enough to apply the unification
algorithm to C and C to obtain an unifying
substitution S and to return S(C:e&amp;c&amp;quot;).
We can then annotate the rules of our formalism
with constraints and use any algorithm for
computing the unifier of the constrained terms to
obtain a new parsing algorithm for the extended
formalism. It is interesting to note that, if we
used the trivial algorithm described above for
computing the unifier of constrained terms, we
would obtain exactly the same terms as in the
equational case but annotated with the
conjunction of all the constraints attached to the
instances of the rules involved in the derivation.
One of the obvious drawbacks of using such a
strategy for computing unifiers is that there is no
guarantee that the denotation of S(C:c&apos;&amp;c&amp;quot;) is
not empty since S(c&apos;&amp;c&amp;quot;) may be unsatisfiable.
We will now give two properties of unifiers
which can be used to derive more interesting
algorithms.
Assume t:c is an unifier of t&apos;:c&apos; and t&amp;quot;:c&amp;quot; and
c is logically equivalent to d, then t:d is also a
unifier. Similarly if, for some variable x and
term r, we can derive x=r from c, then [r/x](t:c)
is also a unifier for t&apos;:c&apos; and t&amp;quot;:c&amp;quot;, where [r/x
denotes substitution of r for x.
It is obvious that by using an algorithm
similar to the one used by Jonhson 151 for
reducing the constraint c to normal form, it is
possible to find all the equalities of the form x=r
which can be derived from c, and also decide if c
is satisfiable. This strategy, however, suffers
from the inherent NP hardness, and, for practical
implementations we prefer to use, at most
unification steps, an incomplete algorithm
reserving the complete algorithm for special
points in the computation process which include
necessarily the final step.
</bodyText>
<sectionHeader confidence="0.88574" genericHeader="keywords">
Rewriting and Delaying
Constraints
</sectionHeader>
<bodyText confidence="0.983459333333334">
In this section we present a slightly simplified
version of the constraint rewriting system which
is at the core of the CLG model. As will be
apparent from these rules they attempt a partial
rewrite to conjunctive rather than to the more
common disjunctive normal form. Some of the
reasons for this choice will be explained below.
Another point worthwhile mentioning here is
that linguistic descriptions and linguistic
representations are pairs consisting of a partial
equational description of an object and
constraints (cf. [2]) in contrast to [12,14] where
constraints are kept within linguistic objects.
- 174 -
The CLO constraint language includes
expressions involving paths which allow
reference to 4 specific argument of a complex
term in order to avoid the need for introducing
existential quantifiers and extraneous variables
when specifying constraints on arguments of
terms.
We define paths p, values v and constraints c
as follows (quantification is omitted for reasons
01 simplicity):
</bodyText>
<equation confidence="0.979762666666667">
p &lt;empty&gt;
p.
v
t.p
J-
C ::= t. p.
v=v
c &amp; c
c I c
</equation>
<bodyText confidence="0.995956666666667">
In the above definitions iq denotes the i -th
projection while the superscript in fn indicates the
arity off as before. As an example, if t denotes
</bodyText>
<equation confidence="0.60312275">
f (a,g (c,d))
the following constraints are satisfied:
1.12 t.12.n2.g2
t.12.1c1 = a t.12.1r2.g2.7c2 = d
</equation>
<bodyText confidence="0.966571">
We can now state the CLO rewriting rules for
values:
</bodyText>
<sectionHeader confidence="0.390182" genericHeader="method">
Rewriting Values
</sectionHeader>
<equation confidence="0.704105">
I (Li ..... tn
(11,...,tn if in gk
</equation>
<bodyText confidence="0.9903805">
and for constraints (keeping in mind that
implication and equivalence are just shorthapds):
</bodyText>
<sectionHeader confidence="0.548753" genericHeader="method">
Rewriting Constraints
</sectionHeader>
<equation confidence="0.936473533333333">
false I c --) c
--C —4 C
—false —4 (TUC
—true —&gt; false
true I c —4 true
false &amp; c —,&gt; false
—(c I c&apos; ) —3 —c &amp;c
J_Ik -4 false
f (tt,...4 ).111 —4 true
g(t1,—,tn).tic —&gt; false if f k
v=v&apos; -,-&gt; false if either v or v&apos; is
V = -4 true if v and v&apos; are the same value
v = v&apos; —4 false if v and v&apos; are atomic and v*v.
f ) = f (u1 .....u )
ii=u1 &amp; &amp; tn=un
</equation>
<bodyText confidence="0.9922852">
f ) = g(u ,...,un ) false
We will use set notation to denote a
conjunction of the constraints in the set. Using
this notation we can state the following rules for
rewriting constrained terms:
</bodyText>
<subsectionHeader confidence="0.536388">
Rewriting Constrained Terms
</subsectionHeader>
<bodyText confidence="0.7260445">
:{..., false,...) 4 FAIL
t :{..., true,...} ---&gt; t
</bodyText>
<equation confidence="0.9746365">
t ci&amp;c2,—) t :(..•,c1,c2.••1
= l&apos;,...) 11)(0 / x I t:{...,...)
= y.q,...)
(p(z)/x,q(z)/ylt:{.,.,...)
t :{...,x.p.fk ,...} --o
IP tf / x Jt :{...,...)
</equation>
<bodyText confidence="0.9023735">
where z arc new variables and p(...)
which can be defined is by:
</bodyText>
<equation confidence="0.983198">
&lt;empty&gt; (x) = x
frixt.p (x ) f (z),...,zi_i, p (x) , 4n )
true &amp; c -4 returns a new generic term t such that the
constraint t.p = x is satisfied.
- 175 -
</equation>
<bodyText confidence="0.997356076923077">
The above is a slight simplification:
constraints associated with terms come in fact in
pairs, the second element of which is omitted
here for the sake of simplicity and contains
essentially negated literals and inequations. The
reason for this is that we want to give the system
a certain inferencing capability without having to
resort to expensive exhaustive pairwise search
through the constraint set.
It should also be mentioned that after one
constraint in a set is rewritten it will only be
rewritten again if some variable occurring in it is
instantiated.
</bodyText>
<subsectionHeader confidence="0.755171">
Completing Rewrites
</subsectionHeader>
<bodyText confidence="0.999598461538462">
As already mentioned the set of rewrite rules
given above is not complete in the sense that it is
not sufficient to reduce all constraints to
conjunctive normal form, although CLG has a
complete set of rewrite rules available to be used
whenever needed. At least at the end of
processing, representations are reduced to
conjunctive form.
Sets of rules for rewriting first order logic
formulae to conjunctive normal form can be
found in the literature [11]. The specific set of
complete rewrites currently used in CLG includes
e.g.:
</bodyText>
<listItem confidence="0.960051333333333">
(1) cl(cl&amp;c&amp;quot;)--* (cic&apos;)&amp;(cic&amp;quot;)
(2) —(c&amp;c&apos;) —cl—c&apos;
(3) (c I c&apos;) &amp; ( --c I c&amp;quot;) c&apos;l c&amp;quot;
</listItem>
<bodyText confidence="0.999041470588235">
There are various reasons for not using them
at every unification step. The application of the
distributive law (1) is avoided since it contributes
to the P-Space completeness of the reduction to
normal form: in general we avoid using rules
which are input length increasing.
As for the de Morgan law (2), we do not use
it because by itself it does neither help to detect
failure nor does it contribute to add positive
equational information.
Lastly, the cut rule (3) is just too expensive to
be used in a systematic way.
Our current experience shows that the number
of constraints which need the complete set of
rewrite rules to be solved is usually nil or
extremely small even for non-trivial grammars
[1].
</bodyText>
<sectionHeader confidence="0.979524" genericHeader="method">
Discussion
</sectionHeader>
<bodyText confidence="0.985357709677419">
The three main characteristics of the CLG
processing model are the use of constrained terms
to represent partial descriptions, the lack of
systematic rewriting of constraints to normal
form and the lazy evaluation of complex
constraints.
The choice of constrained terms instead of the
more common sets of constraints is motivated by
methodological rather than theoretical reasons.
The two representations are logically equivalent
but CLG&apos;s commitment to naturally extend
unification to constraint resolution makes the
latter better suited if, as in the present case, we
want to use existing algorithms where they have
shown successful.
The alternative, to develop new algorithms
and data structures for complex constraint
resolution (including equation solving)
[12,13,14] is less attractive. It is preferable to
split the problem into its well understood
equational subpart and the more speculative
complex constraint resolution.
It is also worthwhile noting that terms
constitute a very compact representation for sets
of equations and naturally suggest the use of
conjunctive forms, another distinguishing
characteristics of CLG. Furthermore, conjunctive
forms constitute a compact way of representing
partial objects in that they localise ambiguity.
We already have discussed the reasons for
avoiding systematic rewrites of constraints to
normal form. This in no way affects the
soundness of the system although it may prevent
early failure. Even so it is computationally more
effective than resorting to normal form reduction
Note that CLG is not a priori committed to
check whether newly added constraints will lead
to inconsistency. However it is often possible to
check such inconsistencies at little cost without
full reduction to normal form. A solvability check
is only performed for a limited number of easily
testable situations, mainly for the case of negated
literals, of which a separate list is kept as
mentioned above.
- 176 -
It has to be pointed out though, that in order
to guarantee the global completeness of the
rewrites,. as opposed to potential local
incompleteness, CLG completes the rewrite to
normalized form at the latest at the very end of
processing. Nevertheless this decision is not a
commitment. Rather, a rewrite to normal form
could. be carried ,out with the frequency deemed
necessary. Our present experience however
shows that a full rewrite at the end is sufficient.
Finally, the , way constraint resolution is
delayed is a direct consequence of the rewrites
available at run-time. Every constraint which
cannot at a given point in time be reduced with
one of the above rules is just left untouched in
that cycle of constraint evaluation, awaiting for
further instantiations to make it a candidate for
</bodyText>
<listItem confidence="0.928177">
• reduction.
</listItem>
<bodyText confidence="0.999059833333333">
A last note on some consequences these
properties have for the user: as with other
complex constraint based systems, in CLG there
is no guarantee that all constraints will always be
solved, not even after the last rewrite to normal
form. As a result (a) the system does not fail
because all constraints have not been resolved
and (b) the intermediate and final data structure
are also partial descriptions, being potentially
annotated with unresolved constraints, and
denote not a single, but a class of representations.
The first consequence is clearly a desirable
property, for it is unreasonable to think that
grammatical descriptions will ever be complete to
the point where all and only the constraints which
are needed will be expressed in a grammar and all
and only the information which is needed to
satisfy these constraints will be available at the
appropriate moment.
As for the second consequence, we have
found unresolved constraints to be the best
possible source of information about the state of
the computation and the incompleteness of
grammatical description.
</bodyText>
<sectionHeader confidence="0.673959" genericHeader="method">
Relation to Other Work
</sectionHeader>
<bodyText confidence="0.9996657">
Although in this paper we have presented a
specific (subset of) constraint language and a
specific incomplete set of rewrite rules, neither is
integral part of CLG&apos;s theoretical framework.
In fact the basic ideas behind the CLG
processing model can be carried over to other,
frameworks, such as the feature logic of Smolka
16,15b by replacing the unification of terms with
the unification of the set of equational constraints
and by either redefining the constraint language in
a suitable way (e.g. redefining the notion of path)
or else by translating the non-atomic formulae of
the feature logic.
Finally, note that the processing model
described in this paper can, and eventually
should, be complemented with techniques from
constraint logic programming 1161 to handle
cases such as constraints on finite domain
variables where the completeness of the
constraint handling is computationally tractable.
</bodyText>
<sectionHeader confidence="0.832806" genericHeader="conclusions">
Conclusions
</sectionHeader>
<bodyText confidence="0.999763052631579">
We have shown how, starting from a purely
unification based framework, it is possible to
extend its expressive power by introducing a
constraint language for restricting the ways in
which partial objects can be instantiated, and have
provided a general strategy for processing in the
extended framework.
We have also presented and justified the use
of partial rewrite rules which, while maintaining
the essential formal properties, are
computationally effective with available
technologies.
We justified the use of conjunctive forms as a
better option than their disjunctive counterparts as
a means for providing amongst other things a
compact representation of partial objects.
Finally we have emphasized the importance of
lazy evaluation of complex constraints in order to
ensure computational tractability.
</bodyText>
<sectionHeader confidence="0.957266" genericHeader="acknowledgments">
Acknowledgement
</sectionHeader>
<bodyText confidence="0.9997726">
The work reported herein has been carried out
within the framework of the Eurotra R&amp;D
programme financed by the European
Communities. The opinions exposed are the sole
responsibility of the authors.
</bodyText>
<sectionHeader confidence="0.99924" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.984351142857143">
[1] Damas, Luis and Giovanni B. Varile, 1989.
&amp;quot;CLG: A grammar formalism based on
constraint resolution&amp;quot;, in EPIA &apos;89, E.M.
Morgado and J.P. Martins (eds.), Lecture
- 177 -
Notes in Artificial Intelligence 390, Springer,
Berlin.
[2] Balari, Sergio, Luis Damas, Nelma Moreira
and Giovanni B. Varile, 1990. &amp;quot;CLG:
Constraint Logic Grammars&amp;quot;, Proceedings of
the 13th International Conference on
Computational Linguistics, H. Karlgren
(ed.), Helsinki.
[3] Moens, M., J. Calder, E. Klein, M. Reape
and H. Zeevat, 1989. &amp;quot;Expressing
generalizations in unification-based
formalisms&amp;quot;, in Proceedings of the fourth
conference of the European Chapter of the
ACL, ACL.
14] Pollard, Carl J. and Ivan A. Sag, 1987.
&amp;quot;Information-Based Syntax and Semantics 1:
Fundamentals&amp;quot;, Center for the Study of
Language and Information, Stanford, CA.
[5] Johnson, Mark, 1988. &amp;quot;Attribute-Value Logic
and the Theory of Grammar&amp;quot;, Center for the
Study of Language and Information,
Stanford, CA.
16] Smolka, G. 1989. &amp;quot;Feature Constraint Logics
for Unification Grammars&amp;quot;, LILOG Report
93, IWBS, IBM Deutschland.
[7] Moshier, M. Drew and William C. Rounds,
1986. &amp;quot;A logic for partially specified data
structures&amp;quot;, manuscript, Electrical
Engineering and Computer Science
Department, University of Michigan, Ann
Arbor, MI.
[8] Jaffar, J., J-L. Lassez, 1988. &amp;quot;From
unification to constraints&amp;quot;, in Logic
Programming 1987, G. Goos &amp; J. Hartmanis
(eds.), Lecture Notes in Computer Science
315, Springer, Berlin.
[9] Cohen, Jacques, 1990. &amp;quot;Constraint Logic
Programming Languages&amp;quot;, in CAM, July
1990,volume 33, No. 7.
[10] Doerre, Jochen, Andreas Eisele, 1990.
&amp;quot;Feature Logic with Disjunctive Unification&amp;quot;,
Proceedings of the 13th International
Conference on Computational Linguistics, H.
Karlgren (ed.), Helsinki.
[11] Hilbert, D., P. Bernays, 1934 &amp; 1968.
&amp;quot;Grundlagen der Mathematik I &amp; II&amp;quot;,
Springer, Berlin.
[12] Carpenter, B., C. Pollard, A. Franz (to
appear). &amp;quot;The Specification and
Implementation of Constraint-Based
Unfication Grammars&amp;quot;.
[13] Kasper, Robert, 1987, &amp;quot;A Unification
Method for Disjunctive Feature Description&amp;quot;,
Proceedings of the 25th Annual Meeting of
the ACL, ACL.
[14] Carpenter, Bob, 1990. &amp;quot;The Logic of Typed
Feature Structures: Inheritance, (In)equations
and Extensionality&amp;quot;, unpublished Ms.
[15] Smolka, Gert, 1988. &amp;quot;A Feature Logic with
Subsorts&amp;quot;, LILOG Report 33, IWBS, IBM
Deutschland.
[16] Van Hentenryck, P., M. Dincbas, 1986.
&amp;quot;Domains in Logic Programming&amp;quot;, Proceedings
of the AAAI, Philadelphia, PA.
- 178 -
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.445691">
<title confidence="0.99945">The Formal and Processing Models of CLG</title>
<author confidence="0.975819">Luis DAMAS</author>
<affiliation confidence="0.8488365">Nelma MOREIRA University of Porto, Campo Alegre 823</affiliation>
<address confidence="0.914087">P-4000 Porto</address>
<email confidence="0.798768">luis@nccup.ctt.pt</email>
<abstract confidence="0.999794222222222">present the formal processing model of CLG, a logic grammar formalism based on complex constraint resolution. In particular, we show how to monotonically extend terms and their unification to constrained terms and their resolution. The simple CLG constraint rewrite scheme is presented and its consequence for CLG&apos;s multiple delay model explained.</abstract>
<keyword confidence="0.9062435">Keywords: Grammatical formalisms, Complex constraint resolution.</keyword>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Luis Damas</author>
<author>Giovanni B Varile</author>
</authors>
<title>CLG: A grammar formalism based on constraint resolution&amp;quot;,</title>
<date>1989</date>
<booktitle>Lecture - 177 -Notes in Artificial Intelligence 390,</booktitle>
<editor>in EPIA &apos;89, E.M. Morgado and J.P. Martins (eds.),</editor>
<publisher>Springer,</publisher>
<location>Berlin.</location>
<contexts>
<context position="823" citStr="[1]" startWordPosition="118" endWordPosition="118">ed on complex constraint resolution. In particular, we show how to monotonically extend terms and their unification to constrained terms and their resolution. The simple CLG constraint rewrite scheme is presented and its consequence for CLG&apos;s multiple delay model explained. Keywords: Grammatical formalisms, Complex constraint resolution. Introduction CLG is a family of grammar formalisms based on complex constraint resolution designed, implemented and tested over the last three years. CLG grammars consist of the description of global and local constraints of linguistic objects as described in [1] and [2]. For the more recent members of the CLG family, global constraints consist of sort declarations and the definition of relation between sorts, while local constraints consist of partial lexical and phrasal descriptions. The sorts definable in CLG are closed, in a way akin to the ones used by UCG 13]. Relations over sorts represent the statement of linguistic principles in the spirit of HPSG [4]. The constraint language is a classical first order language with the usual unary and binary logical connectives, i.e. negation (—), conjunction (&amp;), disjunction (I), material implication (-4), </context>
<context position="10987" citStr="[1]" startWordPosition="1868" endWordPosition="1868">ive law (1) is avoided since it contributes to the P-Space completeness of the reduction to normal form: in general we avoid using rules which are input length increasing. As for the de Morgan law (2), we do not use it because by itself it does neither help to detect failure nor does it contribute to add positive equational information. Lastly, the cut rule (3) is just too expensive to be used in a systematic way. Our current experience shows that the number of constraints which need the complete set of rewrite rules to be solved is usually nil or extremely small even for non-trivial grammars [1]. Discussion The three main characteristics of the CLG processing model are the use of constrained terms to represent partial descriptions, the lack of systematic rewriting of constraints to normal form and the lazy evaluation of complex constraints. The choice of constrained terms instead of the more common sets of constraints is motivated by methodological rather than theoretical reasons. The two representations are logically equivalent but CLG&apos;s commitment to naturally extend unification to constraint resolution makes the latter better suited if, as in the present case, we want to use exist</context>
</contexts>
<marker>[1]</marker>
<rawString>Damas, Luis and Giovanni B. Varile, 1989. &amp;quot;CLG: A grammar formalism based on constraint resolution&amp;quot;, in EPIA &apos;89, E.M. Morgado and J.P. Martins (eds.), Lecture - 177 -Notes in Artificial Intelligence 390, Springer, Berlin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Sergio Balari</author>
<author>Luis Damas</author>
<author>Nelma Moreira</author>
<author>Giovanni B Varile</author>
</authors>
<title>CLG: Constraint Logic Grammars&amp;quot;,</title>
<date>1990</date>
<booktitle>Proceedings of the 13th International Conference on Computational Linguistics,</booktitle>
<editor>H. Karlgren (ed.),</editor>
<location>Helsinki.</location>
<contexts>
<context position="831" citStr="[2]" startWordPosition="120" endWordPosition="120">mplex constraint resolution. In particular, we show how to monotonically extend terms and their unification to constrained terms and their resolution. The simple CLG constraint rewrite scheme is presented and its consequence for CLG&apos;s multiple delay model explained. Keywords: Grammatical formalisms, Complex constraint resolution. Introduction CLG is a family of grammar formalisms based on complex constraint resolution designed, implemented and tested over the last three years. CLG grammars consist of the description of global and local constraints of linguistic objects as described in [1] and [2]. For the more recent members of the CLG family, global constraints consist of sort declarations and the definition of relation between sorts, while local constraints consist of partial lexical and phrasal descriptions. The sorts definable in CLG are closed, in a way akin to the ones used by UCG 13]. Relations over sorts represent the statement of linguistic principles in the spirit of HPSG [4]. The constraint language is a classical first order language with the usual unary and binary logical connectives, i.e. negation (—), conjunction (&amp;), disjunction (I), material implication (-4), equivale</context>
<context position="4257" citStr="[2]" startWordPosition="677" endWordPosition="677">ier of those terms or failing. Associating with a term t its usual denotation at0={St E TO) (where S denotes a substitution of terms for variables) the unifier t of two terms C and C has the following important property if till = (fft&amp;quot;jl Next we introduce constraints over terms in T. For the moment we will assume that constraints c include at least atomic equality constraints between terms and formulas built from the atomic constraints using the standard logic operators, namely disjunction, conjunction and negation, and that a notion of validity can be defined for closed formulas (see however [2] for an extended constraint language). We will extend terms to constrained terms t:c, where c is a constraint involving only variables occurring in t, and take Ilt :c 11= [ St E TO I I— Sc) as its denotation. Now, given constrained terms t:c, t&apos;:c&apos; and t&amp;quot;:c&amp;quot; we say that t:c is a unifier of t&apos;:c&apos; and t&amp;quot;:c&amp;quot; iff [&apos;Lc 1J= ift&amp;quot;:c&amp;quot;11. It is easy to see that there is at least one algorithm which given two constrained terms either fails, if they do not admit a unifier, or else returns one unifier of the given terms. As a matter of fact it is enough to apply the unification algorithm to C and C to obta</context>
<context position="7104" citStr="[2]" startWordPosition="1169" endWordPosition="1169">ch include necessarily the final step. Rewriting and Delaying Constraints In this section we present a slightly simplified version of the constraint rewriting system which is at the core of the CLG model. As will be apparent from these rules they attempt a partial rewrite to conjunctive rather than to the more common disjunctive normal form. Some of the reasons for this choice will be explained below. Another point worthwhile mentioning here is that linguistic descriptions and linguistic representations are pairs consisting of a partial equational description of an object and constraints (cf. [2]) in contrast to [12,14] where constraints are kept within linguistic objects. - 174 - The CLO constraint language includes expressions involving paths which allow reference to 4 specific argument of a complex term in order to avoid the need for introducing existential quantifiers and extraneous variables when specifying constraints on arguments of terms. We define paths p, values v and constraints c as follows (quantification is omitted for reasons 01 simplicity): p &lt;empty&gt; p. v t.p JC ::= t. p. v=v c &amp; c c I c In the above definitions iq denotes the i -th projection while the superscript in </context>
</contexts>
<marker>[2]</marker>
<rawString>Balari, Sergio, Luis Damas, Nelma Moreira and Giovanni B. Varile, 1990. &amp;quot;CLG: Constraint Logic Grammars&amp;quot;, Proceedings of the 13th International Conference on Computational Linguistics, H. Karlgren (ed.), Helsinki.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Moens</author>
<author>J Calder</author>
<author>E Klein</author>
<author>M Reape</author>
<author>H Zeevat</author>
</authors>
<title>Expressing generalizations in unification-based formalisms&amp;quot;,</title>
<date>1989</date>
<booktitle>in Proceedings of the fourth conference of the European Chapter of the ACL, ACL.</booktitle>
<volume>14</volume>
<location>Stanford, CA.</location>
<marker>[3]</marker>
<rawString>Moens, M., J. Calder, E. Klein, M. Reape and H. Zeevat, 1989. &amp;quot;Expressing generalizations in unification-based formalisms&amp;quot;, in Proceedings of the fourth conference of the European Chapter of the ACL, ACL. 14] Pollard, Carl J. and Ivan A. Sag, 1987. &amp;quot;Information-Based Syntax and Semantics 1: Fundamentals&amp;quot;, Center for the Study of Language and Information, Stanford, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Johnson</author>
</authors>
<title>Attribute-Value Logic and the Theory of Grammar&amp;quot;, Center for the Study of Language and Information,</title>
<date>1988</date>
<tech>LILOG Report 93, IWBS, IBM Deutschland.</tech>
<volume>16</volume>
<location>Stanford, CA.</location>
<contexts>
<context position="1644" citStr="[5]" startWordPosition="247" endWordPosition="247">riptions. The sorts definable in CLG are closed, in a way akin to the ones used by UCG 13]. Relations over sorts represent the statement of linguistic principles in the spirit of HPSG [4]. The constraint language is a classical first order language with the usual unary and binary logical connectives, i.e. negation (—), conjunction (&amp;), disjunction (I), material implication (-4), equivalence (&lt;---&gt;) and a restricted form of quantification (V and 3 ) over finitely instantiatable domains. The interpretation of these connectives in CLG is strictly classical as in Smolka&apos;s FL [6] and Johnson&apos;s AVL [5], unlike the intuitionistic interpretation of negation of Moshier and Rounds [7]. A more detailed Giovanni B. VARILE CEC Jean Monnet Bldg. B4/001 L-2920 Luxembourg nino@eurokom.ie description of CLG including its &amp;notational semantics can be found in 121. In this paper we present the formal processing model of CLG, which has been influenced by the Constraint Logic Programming paradigm 181 NI. We show in what way it extends pure unification based formalisms and how it achieves a sound implementation of classically interpreted first order logic while maintaining practical computational behaviour</context>
</contexts>
<marker>[5]</marker>
<rawString>Johnson, Mark, 1988. &amp;quot;Attribute-Value Logic and the Theory of Grammar&amp;quot;, Center for the Study of Language and Information, Stanford, CA. 16] Smolka, G. 1989. &amp;quot;Feature Constraint Logics for Unification Grammars&amp;quot;, LILOG Report 93, IWBS, IBM Deutschland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Drew Moshier</author>
<author>William C Rounds</author>
</authors>
<title>A logic for partially specified data structures&amp;quot;,</title>
<date>1986</date>
<tech>manuscript,</tech>
<institution>Electrical Engineering and Computer Science Department, University of Michigan,</institution>
<location>Ann Arbor, MI.</location>
<contexts>
<context position="1724" citStr="[7]" startWordPosition="258" endWordPosition="258">by UCG 13]. Relations over sorts represent the statement of linguistic principles in the spirit of HPSG [4]. The constraint language is a classical first order language with the usual unary and binary logical connectives, i.e. negation (—), conjunction (&amp;), disjunction (I), material implication (-4), equivalence (&lt;---&gt;) and a restricted form of quantification (V and 3 ) over finitely instantiatable domains. The interpretation of these connectives in CLG is strictly classical as in Smolka&apos;s FL [6] and Johnson&apos;s AVL [5], unlike the intuitionistic interpretation of negation of Moshier and Rounds [7]. A more detailed Giovanni B. VARILE CEC Jean Monnet Bldg. B4/001 L-2920 Luxembourg nino@eurokom.ie description of CLG including its &amp;notational semantics can be found in 121. In this paper we present the formal processing model of CLG, which has been influenced by the Constraint Logic Programming paradigm 181 NI. We show in what way it extends pure unification based formalisms and how it achieves a sound implementation of classically interpreted first order logic while maintaining practical computational behaviour by resorting to a simple set of constraint rewrite rules and a lazy evaluation </context>
</contexts>
<marker>[7]</marker>
<rawString>Moshier, M. Drew and William C. Rounds, 1986. &amp;quot;A logic for partially specified data structures&amp;quot;, manuscript, Electrical Engineering and Computer Science Department, University of Michigan, Ann Arbor, MI.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Jaffar</author>
<author>J-L Lassez</author>
</authors>
<title>From unification to constraints&amp;quot;, in Logic Programming</title>
<date>1988</date>
<booktitle>Lecture Notes in Computer Science 315,</booktitle>
<editor>G. Goos &amp; J. Hartmanis (eds.),</editor>
<publisher>Springer,</publisher>
<location>Berlin.</location>
<marker>[8]</marker>
<rawString>Jaffar, J., J-L. Lassez, 1988. &amp;quot;From unification to constraints&amp;quot;, in Logic Programming 1987, G. Goos &amp; J. Hartmanis (eds.), Lecture Notes in Computer Science 315, Springer, Berlin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jacques Cohen</author>
</authors>
<title>Constraint Logic Programming Languages&amp;quot;,</title>
<date>1990</date>
<volume>33</volume>
<editor>in CAM,</editor>
<marker>[9]</marker>
<rawString>Cohen, Jacques, 1990. &amp;quot;Constraint Logic Programming Languages&amp;quot;, in CAM, July 1990,volume 33, No. 7.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jochen Doerre</author>
<author>Andreas Eisele</author>
</authors>
<title>Feature Logic with Disjunctive Unification&amp;quot;,</title>
<date>1990</date>
<booktitle>Proceedings of the 13th International Conference on Computational Linguistics,</booktitle>
<editor>H. Karlgren (ed.),</editor>
<location>Helsinki.</location>
<marker>[10]</marker>
<rawString>Doerre, Jochen, Andreas Eisele, 1990. &amp;quot;Feature Logic with Disjunctive Unification&amp;quot;, Proceedings of the 13th International Conference on Computational Linguistics, H. Karlgren (ed.), Helsinki.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Hilbert</author>
<author>P Bernays</author>
</authors>
<title>Grundlagen der Mathematik I &amp; II&amp;quot;,</title>
<date>1934</date>
<publisher>Springer,</publisher>
<location>Berlin.</location>
<contexts>
<context position="10119" citStr="[11]" startWordPosition="1716" endWordPosition="1716">hat after one constraint in a set is rewritten it will only be rewritten again if some variable occurring in it is instantiated. Completing Rewrites As already mentioned the set of rewrite rules given above is not complete in the sense that it is not sufficient to reduce all constraints to conjunctive normal form, although CLG has a complete set of rewrite rules available to be used whenever needed. At least at the end of processing, representations are reduced to conjunctive form. Sets of rules for rewriting first order logic formulae to conjunctive normal form can be found in the literature [11]. The specific set of complete rewrites currently used in CLG includes e.g.: (1) cl(cl&amp;c&amp;quot;)--* (cic&apos;)&amp;(cic&amp;quot;) (2) —(c&amp;c&apos;) —cl—c&apos; (3) (c I c&apos;) &amp; ( --c I c&amp;quot;) c&apos;l c&amp;quot; There are various reasons for not using them at every unification step. The application of the distributive law (1) is avoided since it contributes to the P-Space completeness of the reduction to normal form: in general we avoid using rules which are input length increasing. As for the de Morgan law (2), we do not use it because by itself it does neither help to detect failure nor does it contribute to add positive equational informati</context>
</contexts>
<marker>[11]</marker>
<rawString>Hilbert, D., P. Bernays, 1934 &amp; 1968. &amp;quot;Grundlagen der Mathematik I &amp; II&amp;quot;, Springer, Berlin.</rawString>
</citation>
<citation valid="false">
<authors>
<author>B Carpenter</author>
<author>C Pollard</author>
<author>A</author>
</authors>
<title>Franz (to appear). &amp;quot;The Specification and Implementation of Constraint-Based Unfication Grammars&amp;quot;.</title>
<contexts>
<context position="7128" citStr="[12,14]" startWordPosition="1173" endWordPosition="1173">ly the final step. Rewriting and Delaying Constraints In this section we present a slightly simplified version of the constraint rewriting system which is at the core of the CLG model. As will be apparent from these rules they attempt a partial rewrite to conjunctive rather than to the more common disjunctive normal form. Some of the reasons for this choice will be explained below. Another point worthwhile mentioning here is that linguistic descriptions and linguistic representations are pairs consisting of a partial equational description of an object and constraints (cf. [2]) in contrast to [12,14] where constraints are kept within linguistic objects. - 174 - The CLO constraint language includes expressions involving paths which allow reference to 4 specific argument of a complex term in order to avoid the need for introducing existential quantifiers and extraneous variables when specifying constraints on arguments of terms. We define paths p, values v and constraints c as follows (quantification is omitted for reasons 01 simplicity): p &lt;empty&gt; p. v t.p JC ::= t. p. v=v c &amp; c c I c In the above definitions iq denotes the i -th projection while the superscript in fn indicates the arity o</context>
<context position="11772" citStr="[12,13,14]" startWordPosition="1981" endWordPosition="1981"> constraints to normal form and the lazy evaluation of complex constraints. The choice of constrained terms instead of the more common sets of constraints is motivated by methodological rather than theoretical reasons. The two representations are logically equivalent but CLG&apos;s commitment to naturally extend unification to constraint resolution makes the latter better suited if, as in the present case, we want to use existing algorithms where they have shown successful. The alternative, to develop new algorithms and data structures for complex constraint resolution (including equation solving) [12,13,14] is less attractive. It is preferable to split the problem into its well understood equational subpart and the more speculative complex constraint resolution. It is also worthwhile noting that terms constitute a very compact representation for sets of equations and naturally suggest the use of conjunctive forms, another distinguishing characteristics of CLG. Furthermore, conjunctive forms constitute a compact way of representing partial objects in that they localise ambiguity. We already have discussed the reasons for avoiding systematic rewrites of constraints to normal form. This in no way a</context>
</contexts>
<marker>[12]</marker>
<rawString>Carpenter, B., C. Pollard, A. Franz (to appear). &amp;quot;The Specification and Implementation of Constraint-Based Unfication Grammars&amp;quot;.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert Kasper</author>
</authors>
<title>A Unification Method for Disjunctive Feature Description&amp;quot;,</title>
<date>1987</date>
<booktitle>Proceedings of the 25th Annual Meeting of the ACL,</booktitle>
<publisher>ACL.</publisher>
<contexts>
<context position="11772" citStr="[12,13,14]" startWordPosition="1981" endWordPosition="1981"> constraints to normal form and the lazy evaluation of complex constraints. The choice of constrained terms instead of the more common sets of constraints is motivated by methodological rather than theoretical reasons. The two representations are logically equivalent but CLG&apos;s commitment to naturally extend unification to constraint resolution makes the latter better suited if, as in the present case, we want to use existing algorithms where they have shown successful. The alternative, to develop new algorithms and data structures for complex constraint resolution (including equation solving) [12,13,14] is less attractive. It is preferable to split the problem into its well understood equational subpart and the more speculative complex constraint resolution. It is also worthwhile noting that terms constitute a very compact representation for sets of equations and naturally suggest the use of conjunctive forms, another distinguishing characteristics of CLG. Furthermore, conjunctive forms constitute a compact way of representing partial objects in that they localise ambiguity. We already have discussed the reasons for avoiding systematic rewrites of constraints to normal form. This in no way a</context>
</contexts>
<marker>[13]</marker>
<rawString>Kasper, Robert, 1987, &amp;quot;A Unification Method for Disjunctive Feature Description&amp;quot;, Proceedings of the 25th Annual Meeting of the ACL, ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bob Carpenter</author>
</authors>
<title>The Logic of Typed Feature Structures: Inheritance, (In)equations and Extensionality&amp;quot;, unpublished Ms.</title>
<date>1990</date>
<contexts>
<context position="7128" citStr="[12,14]" startWordPosition="1173" endWordPosition="1173">ly the final step. Rewriting and Delaying Constraints In this section we present a slightly simplified version of the constraint rewriting system which is at the core of the CLG model. As will be apparent from these rules they attempt a partial rewrite to conjunctive rather than to the more common disjunctive normal form. Some of the reasons for this choice will be explained below. Another point worthwhile mentioning here is that linguistic descriptions and linguistic representations are pairs consisting of a partial equational description of an object and constraints (cf. [2]) in contrast to [12,14] where constraints are kept within linguistic objects. - 174 - The CLO constraint language includes expressions involving paths which allow reference to 4 specific argument of a complex term in order to avoid the need for introducing existential quantifiers and extraneous variables when specifying constraints on arguments of terms. We define paths p, values v and constraints c as follows (quantification is omitted for reasons 01 simplicity): p &lt;empty&gt; p. v t.p JC ::= t. p. v=v c &amp; c c I c In the above definitions iq denotes the i -th projection while the superscript in fn indicates the arity o</context>
<context position="11772" citStr="[12,13,14]" startWordPosition="1981" endWordPosition="1981"> constraints to normal form and the lazy evaluation of complex constraints. The choice of constrained terms instead of the more common sets of constraints is motivated by methodological rather than theoretical reasons. The two representations are logically equivalent but CLG&apos;s commitment to naturally extend unification to constraint resolution makes the latter better suited if, as in the present case, we want to use existing algorithms where they have shown successful. The alternative, to develop new algorithms and data structures for complex constraint resolution (including equation solving) [12,13,14] is less attractive. It is preferable to split the problem into its well understood equational subpart and the more speculative complex constraint resolution. It is also worthwhile noting that terms constitute a very compact representation for sets of equations and naturally suggest the use of conjunctive forms, another distinguishing characteristics of CLG. Furthermore, conjunctive forms constitute a compact way of representing partial objects in that they localise ambiguity. We already have discussed the reasons for avoiding systematic rewrites of constraints to normal form. This in no way a</context>
</contexts>
<marker>[14]</marker>
<rawString>Carpenter, Bob, 1990. &amp;quot;The Logic of Typed Feature Structures: Inheritance, (In)equations and Extensionality&amp;quot;, unpublished Ms.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gert Smolka</author>
</authors>
<title>A Feature Logic with Subsorts&amp;quot;,</title>
<date>1988</date>
<tech>LILOG Report 33, IWBS, IBM Deutschland.</tech>
<marker>[15]</marker>
<rawString>Smolka, Gert, 1988. &amp;quot;A Feature Logic with Subsorts&amp;quot;, LILOG Report 33, IWBS, IBM Deutschland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Van Hentenryck</author>
<author>M Dincbas</author>
</authors>
<title>Domains in Logic Programming&amp;quot;,</title>
<date>1986</date>
<booktitle>Proceedings of the AAAI,</booktitle>
<pages>178</pages>
<location>Philadelphia, PA. -</location>
<marker>[16]</marker>
<rawString>Van Hentenryck, P., M. Dincbas, 1986. &amp;quot;Domains in Logic Programming&amp;quot;, Proceedings of the AAAI, Philadelphia, PA. - 178 -</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>