<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<note confidence="0.724569">
Proceedings of EACL &apos;99
</note>
<title confidence="0.910891">
Ambiguous propositions typed
</title>
<author confidence="0.989666">
Tim Fernando
</author>
<affiliation confidence="0.9770255">
Philosophy Department
University of Texas
</affiliation>
<address confidence="0.619268">
Austin, TX 78712-1180, USA
</address>
<email confidence="0.892109">
fernandoOims.uni—stuttgart.de*
</email>
<sectionHeader confidence="0.994158" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999463214285714">
Ambiguous propositions are analyzed in
a type system where disambiguation is
effected during assembly (i.e. by coer-
cion). Ambiguity is introduced through
a layer of types that are underspecified
relative to a pre-existing collection of de-
pendent types, construed as unambigu-
ous propositions. A simple system of
reasoning directly with such underspec-
ification is described, and shown to be
sound and complete for the full range of
disambiguations. Beyond erasing types,
the system supports constraints on dis-
ambiguations, including co-variation.
</bodyText>
<sectionHeader confidence="0.998789" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.976935382352941">
A widely held view expressed in (Carbonell and
Hayes, 1987) is that &amp;quot;if there were one word to
describe why natural language processing is hard,
it is ambiguity.&amp;quot; For any given natural language
utterance, a formal language such as predicate
logic typically offers several non-equivalent (well-
formed) formulas as possible translations. An ob-
vious approach is to take the disjunction of all
alternatives, assuming (for the sake of the argu-
ment) that the disjunction is a formula. Even if it
were, however, various objections have been raised
against this proposal (e.g. (Deemter, 1996)). For
the purposes of the present paper, what is inter-
esting about a word, phrase, sentence or discourse
that is ambiguous in isolation is how it may get
disambiguated when combined with other expres-
sions (or, more generally, when placed in a wider
context); the challenge for any theory of ambigu-
ity is to throw light on that process of disambigua-
tion.
*From June to mid-August 1999, I will be visiting
IMS, Uni Stuttgart, Azenbergstr 12, 70174 Stuttgart,
Germany. Where I might be after that is unclear.
More concretely, suppose • were a binary con-
nective on propositions A and B such that A• B is
a proposition ambiguous between A and B. Under
the &amp;quot;propositions-as-types&amp;quot; paradigm (e.g. (Gi-
rard et al., 1989)) identifying proofs of a proposi-
tion with programs of the corresponding type (so
that &amp;quot;t: A&amp;quot; can be read as t is a proof of proposi-
tion A, or equivalently, t is a program of type A),
disambiguation may take the form of type coer-
cion. An instructive example with r as the con-
text
</bodyText>
<equation confidence="0.992105666666667">
x:(A--13)•C, y:D•A
is
r F- ap(p.(x),q.(y)):B (1)
</equation>
<bodyText confidence="0.987782666666667">
where ap is function application (corresponding to
modus ponens), while p. and q. are the first and
second •-projections, so that
</bodyText>
<equation confidence="0.519048">
x:(A B) • C p.(x): A - B
and
y:D • A H q.,(y):A
</equation>
<bodyText confidence="0.995943529411765">
Evidently, there is something conjunctive (never
mind disjunctive) about .; but beyond the ques-
tion as to whether the unambiguous propositions
constituting the possible readings of an ambigu-
ous proposition form a conjunctive or disjunctive
set (whatever that may precisely mean), there is
also the matter of the interconnected choices from
such sets, mediated by terms such as p.,(x) and
q. (y).
To ground these abstract considerations in nat-
ural language processing, a few words about how
to think of the terms t and types A are useful.
For predicate logic formulas A, the terms t might
be intuitionistic natural deduction proofs, related
by the Curry-Howard isomorphism to a suitable
typed A-calculus. A notable innovation made
in Intuitionistic Type Theory (ITT, (Martin-Lof,
</bodyText>
<page confidence="0.993779">
86
</page>
<bodyText confidence="0.985429533333333">
Proceedings of EACL &apos;99
1984)) is to allow proofs to enter into judgments of
well-formedness (propositionhood). This stands
in sharp contrast to ordinary predicate logic (be it
intuitionistic or classical), where well-formedness
is a trivial matter taken for granted (rather than
analyzed) by the Curry-Howard isomorphism. For
a natural language, however, it is well-formedness
that is addressed by building types A over sen-
tences, nouns, etc (in categorial grammar; e.g.
(Morrill, 1994)) or LFG f-structures (in the &amp;quot;glue&amp;quot;
approach, (Dalrymple et al., 1993; Dalrymple et
al., 1997)). Now, while ITT&apos;s rules for proposi-
tionhood hardly constitute an account of gram-
maticality in English, the combination (in ITT)
of assertions of well-formedness (A type) and the-
oremhood (t: A) re-introduces matters of informa-
tion content (over and above grammatical form),
which have been applied in (Ranta, 1994) (among
other places) to discourse semantics (in particu-
lar, anaphora). The present paper assumes the
machinery of dependent functions and sums in
ITT, without choosing between grammatical and
semantic applications. In both cases, what ambi-
guity contributes to the pot is indeterminacy in
typing, the intuition being that an expression is
ambiguous to the extent that its typing is inde-
terminate.
That said, let us return to (1) and consider how
to capture sequent inferences such as
</bodyText>
<equation confidence="0.995856">
r I- x:(A --+ B) • C r I- y:D • A
F H ap(p.(x),q.(y)):B
</equation>
<bodyText confidence="0.80178275">
and more complicated cases from iterated appli-
cations of., nested among other type constructs.
The idea developed below is to set aside the con-
nective • (as well as notational clutter p., 4.),
and to step up from assertions t : A to (roughly)
t :: A, where A is a set of types A (roughly,
t : A : A). For instance, a direct transcription of
the -*-introduction rule into :: is
</bodyText>
<equation confidence="0.9969525">
r,x::A F. t::B (2)
r E- Ax.t::A -+ B
</equation>
<bodyText confidence="0.754527833333333">
where A B abbreviates the set
{A -&gt;BIAEAandBEB}.
But what exactly could t:: A mean? The disjunc-
tive conception
t:: A if t: A for some A E A (3)
would have as a consequence the implication
</bodyText>
<listItem confidence="0.727602">
t :: A and A C B implies t::B B.
</listItem>
<bodyText confidence="0.9604615">
Now, if combinatorial explosion is a problem for
ambiguity, then surely we ought to avoid feeding
it with cases of spurious ambiguity. A comple-
mentary alternative is conjunction,
</bodyText>
<listItem confidence="0.9574899">
t:: A if t: A for all A E A , (4)
the object this time being to identify the C-largest
such set A, as (4) supports
t:: A and B C A implies t ::B B.
But while (4) and (2) will do for Ax.y where y is
a variable distinct from x, (4) suggests that (2)
overgenerates for Ax.x. Spurious ambiguity may
also arise to the left of H (not just to the right),
if we are not careful to disambiguate the context.
(1) illustrates the point; compare
</listItem>
<equation confidence="0.998117">
F H x :: {A -4, B,C} r H y ::{A, D} (5)
r H ap(x,y)::{B}
</equation>
<bodyText confidence="0.95894">
where the context r is left untouched, to
</bodyText>
<equation confidence="0.786659">
F H x :: {A -+ B , C} r H y :: {A, D}
</equation>
<listItem confidence="0.890974833333333">
(i) attach variables onto sets A of types, to form
decorated expressions a
and
(ii) collect constraints on a&apos;s in sets C, hung as
subscripts, hc, on H.
(3) and (4) are then sharpened by a contextual
</listItem>
<bodyText confidence="0.525292666666667">
characterization, semantically interpreting judg-
ments of the form t :: a and a typ by disambigua-
tions respecting suitable constraints.
</bodyText>
<sectionHeader confidence="0.723459" genericHeader="method">
2 Two systems
</sectionHeader>
<bodyText confidence="0.9994445">
Let us begin with a system of dependent types,
confining our attention to three forms of judg-
ments, r context, A type and t : A. (That is, for
simplicity, we leave out equations between types
and between terms.) Contexts can be formed from
the empty sequence ()
</bodyText>
<equation confidence="0.9982776">
(0c) H () context
F H A type
(tc) x 0 Var(F)
H r, x: A context
B}, y:: {A} H ap(x,y)::{B} (6)
</equation>
<bodyText confidence="0.994751">
where the context gets trimmed. (5) and (2) yield
H Ax.Ay.ap(x,y):: {A -&gt; B, C} -&gt; ({A, D} -&gt; {B})
whereas (6) and (2) yield
1-- Ax.Ay.ap(x, y):: {A -4 B} -4 ({A} -&gt; {B}) .
To weed out spurious ambiguity, we will
</bodyText>
<page confidence="0.969737">
87
</page>
<bodyText confidence="0.611927333333333">
Proceedings of EACL &apos;99
where Var(F) is the set of variables occurring in
F. Assumptions cross I—
</bodyText>
<equation confidence="0.9304915">
(As) : A context
x:A
</equation>
<bodyText confidence="0.951284">
and contexts weaken to the right
</bodyText>
<equation confidence="0.709349">
re Hr,context
(Weak)
</equation>
<bodyText confidence="0.999728">
(where 0 ranges over judgments A type and t :
A). Next come formation (F), introduction (I)
and elimination (E) rules for dependent functions
ri (generalizing non-dependent functions -4.)
</bodyText>
<equation confidence="0.927719666666667">
r,x: A context F,x:A H B type
r H (flx:A)B type
1&amp;quot;,x:AFt:B
r H Ax.t:(ri x:A)B
r t:(Fix:A)B r H u:A
I&apos; ap(t,u):B[x := u]
</equation>
<bodyText confidence="0.963258">
(where B[x := u] is B with x replaced by u)
and for dependent sums E (generalizing Carte-
sian products x)
</bodyText>
<table confidence="0.984281375">
H F, x:A context r,x:A B type
r x: A)B type
✓ t:A r u:B[x t]
(t,u):(Ex:A)B
✓ Ht:(Ex:A)B
r H p(t):A
r t:(Ex:A)B
✓ q(t):B[x :=p(t)] •
</table>
<bodyText confidence="0.999347">
Now for the novel part: a second system, with
terms t as before, but colons squared, and :-
types A, B replaced by decorated expressions a, 0
and unadorned expressions A generated simulta-
neously according to
</bodyText>
<equation confidence="0.945108666666667">
A :== a x::a)A I (Ex::a)A
ce,0 :== AxF (11x::a)0 I (Ex::a)0
aaft} aP I ag{t}
</equation>
<bodyText confidence="0.999972">
where a belongs to a fixed countable set X of vari-
ables. The intent (made precise in the next sec-
tion) is that a u-expression A describes a set of
:-types, while a d-expression a denotes a choice
from such a set. D-expressions of the form as, ce,
a{t} and af{t} are said to be non-dependent,
and are used, in conjunction with constraints of
the form fcn(a, 0), sum(a) and eq(a, f3), to infer
sequents relativized to finite sets C of constraints
as follows
</bodyText>
<equation confidence="0.993090333333333">
r 1--c t::a r Hc, u::0
✓ 1—Cueu{fen(a,f3)} ap(t,u)::a,r3ful
r t::a
✓ F-cu{sum(c)} p(t):: aP
r t::ct
F Hufsum(a)) q(t)::aq {p(t)}
</equation>
<bodyText confidence="0.9996015">
where each of the three rules have the side condi-
tion that a is non-dependent.&apos; In addition,
</bodyText>
<equation confidence="0.9878945">
F t::(llx::a)f3 F
(II r Ecueu{eq(a,7)} ap(t,u)::f3[x := u]
</equation>
<bodyText confidence="0.992535555555556">
with the side condition a 0 7. The intuition (for-
malized in clauses (c2)-(c4) of the next section) is
that
- the constraint eq(a, 7) is satisfied by a dis-
ambiguation equating a with -y,
fcn(a, 0) is satisfied by a disarnbiguation of a
and 0 to :-types of the form (fix: A)B and
A respectively
and
</bodyText>
<equation confidence="0.967879636363636">
ho cxt
r Hc A typ
x Var(F)
r, x::Az cxt
F-c r,x::a Oct
r,x::a Fc x::cx
r Hc r, ort
F, LX Fax, e
hc r, x:: a cxt r, x:: a He B tYP
1—cuo (II x::c)13 tYP
r,x::a t::0
F Hc Ax.t::(fix::a)0
F hc t::(rjx::a)13 r u
F Hcuc, ap(t,u)::/3[x
Hc r,2::a oct x:: a B tYP
r Hu, (E x::a)B typ
F t:: a r
(E
F t::(Ex::a)f3
F p(t)::a
F Hc t::(Ex::a)0
F q(t)::0[x p(t)] •
</equation>
<footnote confidence="0.340294">
&apos;Variations on this side condition are taken up in
§5 below.
</footnote>
<figure confidence="0.9856409">
F)
(n
(ll E)
(fin)
(Enp)
(Eng)
sum(a) is satisfied by a disambiguation of a
to a :-type of the form (E x:A)B).
Rules of the previous system translate to
(N)°
(tc)°
(As)°
(Weak)°
(fl F)°
(11 1)0
(IIE)°
(E F)°
(E I)°
(E Ep)°
(E Eq)°
</figure>
<page confidence="0.976447">
88
</page>
<table confidence="0.868793">
Proceedings of EACL &apos;99
Further rules provide co-varying choices
r t:: a
(::c) x Var(r)
r, x:: a cxt
r,x::a cxt r, x::a t:13
r, y (n cxt
r, x::a cxt t::/3
</table>
<page confidence="0.659172">
7
</page>
<bodyText confidence="0.897009">
I—cue r,Y::(Ex::a)/3 cxt
where (11c) and (Ec) each have the side condition
y Var(r)U {x}.
</bodyText>
<sectionHeader confidence="0.953962" genericHeader="method">
3 Disambiguating::
</sectionHeader>
<bodyText confidence="0.9496245">
Let Ty be the collection of :-type expressions A,
and for every d-expression a, let
</bodyText>
<listItem confidence="0.809293111111111">
- X(a) be the set of variables in X occurring
in a
- D(a) be the set of (sub-)d-expressions oc-
curring in a (including a)
and
- U(a) be the set of (sub-)u-expressions A oc-
curring in a.
Suppressing the tedious inductive definitions of
D(a) and U(a), let us just note that, for instance,
</listItem>
<equation confidence="0.708179">
D((llx::az)(E y::aiy)az) is
x::az)(E Y::ceg)az, (EY::asy)az,
ax, cey, az}
and U((II x::az)(E y::asy)az) is
{(11x::ax)(Ey::dy)a, (Ey::ciy)a, a, al .
Next, given a d-expression ao and a function p:
D(a0) Ty, let .1) be the function from U(ao)
to Pow(Ty) such that for a E X(ao),
a = Ty,
for (n x::a)A E U(a0),
((ll x::a)A)&apos; = {(11x:p(a))A I A E AP}
</equation>
<bodyText confidence="0.4526855">
and for (Ex::a)A E U(ao),
((E x:: a)A)P = {(Ex:P(a))A I A E A&apos;}.
Now, call p a disambiguation of a0 if the following
conditions hold:
</bodyText>
<listItem confidence="0.96603">
(i) for every Az E D(ao), p(Ax) E AP
(ii) for every (n x::cc)13 E D(ao),
</listItem>
<equation confidence="0.732413153846154">
x::a)/3) = z: P(a))/0)
(iii) for every (E x::a)0 E D(ao),
P((E x a)0) = (E x:P(a))P(0)
(iv) for every ap{t} E D(120),
P(a) = (il x:P(0))A
for some x and A with A[x := t] = p(ao{t})
(v) for every ce E
p(a) = (E x: p(aP))B for some x and B
and
(vi) for every a{t} E D(ao),
p(a) = (Ex:A)B
for some x, A and B with
B[x := t] = p(a{t}).
</equation>
<bodyText confidence="0.996945375">
Next, let us pass from a single d-expression ao
to a fixed set Do of d-expressions. A disambigua-
tion of the set Do of d-expressions is a function p
from U{D(a) I a E Dol to Ty such that for all
a E Do, p restricted to D(a) is a disambiguation
of a.2 A disambiguation p of Do respects a set C
of constraints if there is an extension p+ J p so
that
</bodyText>
<equation confidence="0.80672575">
(a) p+ is a disambiguation of
Do U fa I a is mentioned in C}
(c2) whenever eq(a03) E C, p(a) = IMO)
(c3) whenever fcn(a,f3) E C,
p(a) = (n x:p+(,3))B for some x and B
and
(c4) whenever sum(a) E C,
p(a) = (E x: A)B for some x, A and B.
</equation>
<bodyText confidence="0.759282">
Given a sequence r of the form
xi :al, • • •
let ima(r) = and for every disam-
biguation p of a set Do containing ima(r), let
</bodyText>
<listItem confidence="0.95376">
• • , rn P(On) -
</listItem>
<bodyText confidence="0.972809727272727">
Let us say that Fc r cxt can be disambiguated
to I— I, context if there is a disambiguation p of
ima(r) respecting C such that r = rp. Similarly,
F }—c a typ (t a) can be disambiguated to r I—
A type (t : A) if there is a disambiguation p of
ima(r) U {a} respecting C such that r = rp and
A = p(a).
21t is crucial for this formulation that the set Var(r)
mentioned in side conditions for various rules in the
previous section include all variables in r, whether
they occur freely or bound.
</bodyText>
<page confidence="0.998515">
89
</page>
<bodyText confidence="0.4331">
Proceedings of EACL &apos;99
</bodyText>
<sectionHeader confidence="0.990455" genericHeader="method">
4 Relating the derivations
</sectionHeader>
<bodyText confidence="0.99973625">
Observe that to derive a sequent other than H
0 context in the first system, or Ho () cxt in the
second, we need to assume a non-empty set T
of sequents. Let us agree to write r FT 0 to
mean that the sequent r F 9 is derivable from
T, and I—T r context to mean that F- r context is
derivable from T. Similarly, for the second system
(with H replaced by Hc, context by cxt, etc). As
every rule (R) for the first system has a counter-
part (R)° in the second system, it is tempting to
seek a natural translation .° from the first system
to the second system validating the following
</bodyText>
<equation confidence="0.691451">
Claim: r IT 9 implies r0 FT: e°.
</equation>
<bodyText confidence="0.999261333333333">
For example, if T consists of the sequent I-- A type,
F is empty, and 0 is Ax.x: (nx:A)A, then T° is
{Ho a typ}, r° is empty, and 0° is Ax.x „(fi x::
a.)a.. Replacing r by y: A, and 0 by Ax.y : (11 x :
A)A, we get y as, for r° and Ax.y (nx::az)ay
for
To pin down a systematic definition of .°, it is
easy enough to fix a 1-1 mapping X 14 ax of
atomic :-types X to variables ax in X, and set
</bodyText>
<equation confidence="0.9998862">
X° =
((11 x : A)B)° =
((E x : A)B)°
(A type)° =
(x:A)° =
</equation>
<bodyText confidence="0.968537307692308">
While (11) induces a translation r° of a context
F, what about (t: A)°, where t is not just, as in
(11), a variable x? Before revising the definition
of d-expressions a to accommodate subscripts t
on A°, let us explore what we can do with (7)-
(11). Define a simple type base T to be a set of
sequents of the form r F- A type. Given a simple
type base T, let T° be its translation into:: ac-
cording to equations (11) and (10). By induction
on derivations from 7, we can prove a reformu-
lation of the claim above, where r° and 00 are
replaced by disambiguations.
Proposition 1. Let T be a simple type base.
</bodyText>
<listItem confidence="0.935483888888889">
(a) I—T r context implies Her r cxt for some r
such that Ho cxt can be disarnbiguated to
F context.
(b) r FT A type implies r Fr a typ for some
F&apos; and a such that r Ho a typ can be dis-
ambiguated to r H A type.
(c) r I—T t: A implies r Hr t :: a for some r,
and a such that I- Ho t :: a can be disam-
biguated to r H t: A.
</listItem>
<bodyText confidence="0.846612">
Moreover, as the rules (fin), (E np) and (E nq)
can, for disambiguations that meet the appropri-
ate constraints, be replaced by (n E), (E Ep) and
(E Eq), it follows that
Proposition 2. Let T be a simple type base.
</bodyText>
<listItem confidence="0.8834972">
(a) If Hr r oct and I—c r cxt can be disam-
biguated to I— r context, then I—T r context.
(b) F I--cr a typ and F 1--c typ can be disam-
biguated to I- F A type, then I&amp;quot; HT A type.
(c) If r Frcr t :: a and r t:: a can be disam-
biguated to r t: A, then I- FT t: A.
Conversely, going from (n E)°, (E E)° and
(E Eg)° to (Fin), (E np) and (E ng), we have
Proposition 3. Let T be a simple type base.
(a) If FT F&apos; context and r cxt can be disam-
biguated to F- r, context, then Fr F cxt.
(b) 1f F1 Fr A type and r typ can be ciisarn-
biguated to r, F- A type, then r Fr a typ.
(c) if r FT t : A and r t :: a can be disam-
biguated to r t: A, then r Fr t:: a.
</listItem>
<bodyText confidence="0.952823769230769">
Proposition 3(c) is roughly of (3), while Propo-
sition 2(c) approximates = of (4). If Proposi-
tion 2 says that the system for:: above is sound,
Proposition 3 says it is complete.3 To tie together
Propositions 2 and 3 in an equivalence, it is useful
to define a set C of constraints to be satisfiable
if 0 is a disambiguation (of 0) respecting C. Note
that sequents Hc r and F 0 have disambigua-
tions exactly when C is satisfiable. Consequently,
Propositions 2 and 3 yield (focussing on
Corollary 4. Given a simple type base T and a
satisfiable set C of constraints, the following are
equivalent.
</bodyText>
<equation confidence="0.878062">
(i) r Hz- t:: a
F&apos; FT t : A, for every sequent t : A to
which r t a can be disambiguated
FT t: A, for some sequent t : A to
which r Hc t::a can be disambiguated.
</equation>
<footnote confidence="0.92944075">
3As for how this relates to soundness and com-
pleteness in say, classical predicate logic, please see
the discussion of translation versus entailment in the
concluding paragraph below.
</footnote>
<figure confidence="0.6409806">
ax
x x).B°
(E x :: A° z)B°
A° typ
A° x .
</figure>
<page confidence="0.910008">
90
</page>
<bodyText confidence="0.973121333333333">
Proceedings of EACL &apos;99
The formulation above of Corollary 4 depends on
the possibility of deriving sequents r k-c 0 where
C is not satisfiable. We could have, of course,
added side conditions to (fin), (E n9) and (E nq)
checking that the constraints are satisfiable. By
electing not to do so, we have exposed a certain
separability of inference from constraint satisfac-
tion, which we will explore in the next section.
For now, turning to the general case of a set T
of :-sequents, observe that if T is to be compatible
with the first system, then
</bodyText>
<footnote confidence="0.322744666666667">
whenever r F Ax.t:C belongs to T,
C must have the form (11x:A)B with
1&amp;quot;,x:A FT t:B
</footnote>
<bodyText confidence="0.670821">
(ii) whenever I&apos; F- (t, u):C belongs to T,
C must have the form (E x:A)B with
</bodyText>
<listItem confidence="0.979999066666667">
✓ LA and r F-T u:B[x :=t]
(iii) whenever r H ap(t,u):B belongs to T,
✓ HT t: (fix: A)B for some x and A such
that r HT u: A
(iv) whenever r H p(t): A belongs to T,
✓ FT t: (E x: A)B for some x and B
(v) whenever r F q(t):B belongs to T,
✓ F-T t:(Ex:A)B for some x and A
(vi) whenever r H 0 belongs to T, HT r context
(vii) whenever H r, x: A context or r t: A
belongs to T, r HT A type
and
(viii) whenever r H x:A)B type or
• H (E x :A)B type belongs to T,
✓ HT A type and r, x: A HT B type.
</listItem>
<bodyText confidence="0.9746634">
Thus, a base set T compatible with the first sys-
tem can be assumed without loss of generality to
consist of sequents of two forms: r H A type and
P H t:B, where A and t are atomic (i.e. indecom-
posable by n, E and A, (, ), ap,p,q respectively).
By clause (vii) above, it follows that for every se-
quent r Ht:B in T, there is some To C T
such that r F70 B type. So starting with sim-
ple type bases To, we can take (for B) the D-
expression f3 which Proposition 1(b) returns, given
P HT° B type. We can then define T° by trans-
lating r Ht:B as r° F t ::/3. Alternatively, we
might make do with simple type bases by refor-
mulating t as a variable xt, and smuggling xt into
enriched contexts r for which a 7-derivation of
</bodyText>
<listItem confidence="0.772362">
• H 9, is sought (with 0&apos; adjusted for xt, rather
</listItem>
<bodyText confidence="0.98100575">
than t). That is, instead of injecting t on top of
F (within some superscript T), we might add it
(along with the context it depends on) to the left
of F.
</bodyText>
<sectionHeader confidence="0.761525" genericHeader="evaluation">
5 Variations and refinements
</sectionHeader>
<bodyText confidence="0.999961066666667">
The sequent rules for :: chosen above lie between
two extremes. The first is obtained by dropping
the side conditions of (fin), (E lip) and (E ng),
rendering the four rules (ri E)°, (E Ep)°, (E n)°
and (n E)0 redundant. The idea is to put off con-
straint satisfaction to the very end. Alternatively,
the side conditions of (11n), (E np), (E ng) and
(n E)s might be strengthened to check that the
constraints are satisfiable (adding to (fin), for ex-
ample, the requirement that sum(a) C U C&apos; and
eq(a03&apos;) 0 C U C&apos; for all 13&apos; E D(/3)). Assum-
ing that we did, we might as well rewrite the rel-
evant d-expressions, and dispense with the sub-
script C. (For example, with the appropriate side
conditions, (lin) might be revised to
</bodyText>
<equation confidence="0.8279895">
r t::a r H u::0
r[a (nx::(3)ct]F ap(t,u)::a[x
</equation>
<bodyText confidence="0.99974108">
where r[a := (n x :43)a] is r with a replaced by
(fix f3)a.) An increase in complexity of the side
conditions is a price that we may well be willing
to pay to get rid of subscripts C. Or perhaps not.
Among the considerations relevant to the inter-
play between inference and constraint satisfaction
are:
(I) the difficulty/ease of applying/abusing infer-
ence rules
(D) the difficulty of disambiguating (i.e. of veri-
fying the assumption in Corollary 4 of a &amp;quot;sat-
isfiable set C&amp;quot; )
(W) wasted effort on spurious readings (i.e. se-
quents 0 with non-satisfiable C).
Designing sequent rules balancing (I), (D) and (W)
is a delicate language engineering problem, about
which it is probably best to keep an open mind.
Consider again the binary connective • mentioned
in the introduction (which we set aside to concen-
trate instead on certain underspecified representa-
tions). It is easy enough to refine the notion of a
disambiguation to an &amp;disambiguation, where e is
a function encoding the readings specified by In
particular, example (1) can be re-conceptualized
in terms of
</bodyText>
<equation confidence="0.767559333333333">
(i) the instance
r x::a r y::/3
r }—{fcri(cx,$)} ap(x,y) ap {y}
</equation>
<bodyText confidence="0.99694725">
of the rule (11n) where I&apos; is the context x
a,y::13, and say, a is az and 13 is a&apos;y (against
the base set of sequents Ho a typ and Fo
a&apos; typ)
</bodyText>
<figure confidence="0.424372">
(i)
</figure>
<page confidence="0.986752">
91
</page>
<bodyText confidence="0.97313364516129">
Proceedings of EACL &apos;99
and
(ii) an e-disambiguation of a{y}, where e(a) =
{A B, C} and E(0) = {A, D}.
Given a (partial) function e from some set
Do of d-expressions to Pow(Ty) — {0}, an
disambiguation of of Do is a disambiguation p of
Do such that for every a in the domain of e,
p(a) E e(a).4 Now, there are at least two ways
to incorporate e-disambiguations into Corollary 4.
The first is to leave the sequent rules for :: as be-
fore, but to relativize the notion of a satisfiable
set C of constraints to e (adding to the defini-
tion of &amp;quot;p respects C&amp;quot; the requirement that the
extension p+ be an e-disambiguation). A more
interesting approach is to bring c into the sequent
rules by forming constraints to guarantee that dis-
ambiguations are e-disambiguations (the general
point being that all kinds of information might
be encoded within the subscripts C on 1—). For
starters, we might change the rule (()c)° to
(Øc)° I-0,e 0 oct
where the subscript 0, e denotes a constraint set
requiring that for every a in the domain of c,
a can only be disambiguated into an element of
e(a). The rules (fin), (E n9), (E nq) and (ri E)0
might then be modified to trim the sets c(a) so
that in example (1), for instance, the applica-
tion of (fin) reduces c(a) = {A B, C} to
{A B}. More specifically, let (lin)
be
</bodyText>
<equation confidence="0.880089666666667">
x::ce r
(fin)
r ap(x,y)::ao{y}
</equation>
<bodyText confidence="0.915008">
with the side condition that
a is non-dependent, and E is consistent
with ei (i.e. for every a in the domain of
both E and e&apos;, e(a) n e&apos;(a) 0 0)
and where C&amp;quot; is C U C&apos; U {fcn(a, 0)} and c&amp;quot; com-
bines e and c&apos; in the obvious way (e.g. map-
ping every a in the domain of both c and c&apos; to
c(a)ne (a)). (Subscripts C, e may, as in the case of
0, e, be construed as single constraint sets, which
are convenient for certain purposes to decompose
into pairs C, e.)
We could put a bit more work into (fin) as
follows. Given an integer k &gt; 0, let Dk (0) be
&apos;We can also introduce • as a binary connective on
u-expressions and/or on d-expressions, although this
would require a bit more work and would run against
the spirit of underspecified representations, insofar as
</bodyText>
<listItem confidence="0.706877">
• spells out possible disambiguations.
</listItem>
<bodyText confidence="0.994290130434783">
the subset of the set D(0) of sub-d-expressions
of 0, from which 0 can be constructed with &lt; k
applications of d-expression formation rules. (For
example, Di ((E c)m ::13)7) is
f(E x::ct)(11Y::13)7, (ll Y:43)-Y, a}
with 0 and 7 buried too deeply to be included.)
Now, for a fixed k, add to the side condition of
(11n) the requirement that sum(a) C U C&apos; and
eq(a, 0&apos;) 0 C U C&apos; for all 0&apos; E Dk(0); and choose
Ell to also rule out the possibility that a is 0&apos; for
some 0&apos; E D(/3). Clearly, the larger k is, the
stronger the rule becomes. But so long as a satisfi-
ability check is made after inference (as suggested
by Corollary 4), it is not necessary that the con-
straint set C in a sequent r 0 that has been
derived be reduced (to make all its consequences
explicit) any more than it is necessary to require
that C be satisfiable. (Concerning the latter, no-
tice also that spurious sequents may drop out as
further inferences are made, eliminating the need
there to ever disambiguate.)
To establish (the analog of) Corollary 4, a cru-
cial property for a sequent rule
</bodyText>
<equation confidence="0.566801">
(*)
r 1--c
</equation>
<bodyText confidence="0.999924421052632">
to have is monotonicity: for every disambiguation
p respecting C, p respects Ci for 1 &lt;i &lt; n.5 (This
is a generalization of Ci C C, suggested by the en-
coding above of e-disambiguations/. in terms of
constraints.) To weed out spurious readings (con-
sideration (W) above), side conditions might be
imposed on (*), which ought (according to (I))
to be as simple as possible. The trick in design-
ing C (and (*)) is to make inference just com-
plicated enough so as, (D), not to put an undue
burden on disambiguating at the end. The whole
idea is to distribute the work between inferring se-
quents and (subsequently) checking satisfiability.
The claim is that the middle ground between the
two extremes mentioned at the beginning of this
section (i.e. between lax side conditions that leave
the bulk of the work to disambiguation at the end,
and strict side conditions that essentially reduce::
to :) is fertile.
</bodyText>
<sectionHeader confidence="0.999876" genericHeader="conclusions">
6 Discussion
</sectionHeader>
<bodyText confidence="0.9380705">
More than one reader (of a previous draft of this
paper) has asked about linguistic examples. The
</bodyText>
<footnote confidence="0.427606">
5Compare to (Alshawi and Crouch, 1992). Mono-
tonicity is used above for soundness, Proposition 2.
Completeness, Proposition 3, follows from having
enough such rules (*) (or equivalently, making the side
conditions for (*) comprehensive enough).
</footnote>
<equation confidence="0.554537">
r1 hc, 01 • • rn hc„ en
</equation>
<page confidence="0.930918">
92
</page>
<bodyText confidence="0.993696209302326">
Proceedings of EACL &apos;99
short, easy answer is that the sort of ambiguity
addressed here can be syntactic (with types A
ranging over grammatical categories) or seman-
tic (with types drawn, say, from a higher-order
predicate logic). Clearly, more must be said —
for example, to properly motivate the rules (:: c),
(11c) and (Ec) mentioned at the end of §2. De-
tailed case studies are bound to push :: in various
directions; and no doubt, after applying enough
pressure, the system above will break.
Be that as it may, I hope that case studies
will be carried out (by others and/or by myself),
testing, by stretching, the basic idea above. I
close with a few words on that idea, and, beg-
ging the reader&apos;s indulgence, on the theoretical
background out of which, in my experience, it
grew. From examining the binary connective •
in (Fernando, 1997), I concluded that • is unlike
any ordinary logical connective related to entail-
ment because the force of • is best understood rel-
ative not to entailment, but to translation. Un-
derlying the distinction between entailment and
translation is that between well-formed formulas
and possibly ambiguous expressions (correspond-
ing, in the present work, to :-types, on the one
hand, and d- and u-expressions, on the other). An
abstract picture relating the processes of trans-
lation and entailment is framed in (Fernando, in
press), which I have attempted to flesh out here for
the case of ITT, with a view to extending ITT&apos;s
applications beyond anaphora to underspecifica-
tion. The obvious step is to drop all types, and
construe the terms as belonging to a type-free A-
calculus. The twist above is that ambiguous ex-
pressions are typed by d-expressions cx, distinct
from u-expressions A. The construction is, in fact,
quite general, and can be applied to linear deriva-
tions as well. The essential point is to break free
from a generative straitjacket, relaxing the infer-
ence rules for derivations by collecting constraints
that are enforced at various points of the deriva-
tion, including the end.
</bodyText>
<sectionHeader confidence="0.999257" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999444789473684">
H. Alshawi and R. Crouch. 1992. Monotonic se-
mantic interpretation. In Proc. 30th Annual
Meeting of the Association for Computational
Linguistics.
J. Carbonell and P. Hayes. 1987. Natural lan-
guage understanding. In S. Shapiro, D. Eck-
roth, and G. Vallasi, editors, Encyclopedia of
Artificial Intelligence. Wiley and Sons, New
York.
M. Dalrymple, J. Lamping, F.C.N. Pereira, and
V. Saraswat. 1993. LFG semantics via con-
straints. In Proc. Sixth European ACL. Univer-
sity of Utrecht.
M. Dalrymple, V. Gupta, J. Lamping, and
V. Saraswat. 1997. Relating resource-based se-
mantics to categorial semantics. Mathematics
of Language 5, Saarbriicken.
Kees van Deemter. 1996. Towards a logic of am-
biguous expressions. In K. van Deemter and
S. Peters, editors, Semantic Ambiguity and Un-
derspecification. CSLI Lecture Notes Number
55, Stanford.
Tim Fernando. 1997. Ambiguity under changing
contexts. Linguistics and Philosophy, 20(6).
Tim Fernando. In press. A modal logic for non-
deterministic discourse processing. Journal of
Logic, Language and Information.
Jean-Yves Girard, Yves Lafont, and Paul Tay-
lor. 1989. Proofs and Types. Cambridge Tracts
in Theoretical Computer Science 7. Cambridge
University Press.
Per Martin-Lof. 1984. Intuitionistic Type Theory.
Bibliopolis, Napoli. Notes by Giovanni Sambin
of a series of lectures given in Padua, June 1980.
Glyn V. Morrill. 1994. Type Logical Grammar.
Kluwer Academic Publishers, Dordrecht.
Aarne Ranta. 1994. Type-Theoretical Grammar.
Oxford University Press, Oxford.
</reference>
<page confidence="0.999176">
93
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.553790">
<note confidence="0.751368">Proceedings of EACL &apos;99</note>
<title confidence="0.874707">Ambiguous propositions typed</title>
<author confidence="0.999606">Tim Fernando</author>
<affiliation confidence="0.9782875">Philosophy Department University of Texas</affiliation>
<address confidence="0.999514">Austin, TX 78712-1180, USA</address>
<email confidence="0.989789">fernandoOims.uni—stuttgart.de*</email>
<abstract confidence="0.995442666666667">Ambiguous propositions are analyzed in a type system where disambiguation is effected during assembly (i.e. by coercion). Ambiguity is introduced through a layer of types that are underspecified relative to a pre-existing collection of dependent types, construed as unambiguous propositions. A simple system of reasoning directly with such underspecification is described, and shown to be sound and complete for the full range of disambiguations. Beyond erasing types, the system supports constraints on disambiguations, including co-variation.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>H Alshawi</author>
<author>R Crouch</author>
</authors>
<title>Monotonic semantic interpretation.</title>
<date>1992</date>
<booktitle>In Proc. 30th Annual Meeting of the Association for Computational Linguistics.</booktitle>
<contexts>
<context position="24795" citStr="Alshawi and Crouch, 1992" startWordPosition="4744" endWordPosition="4747">just complicated enough so as, (D), not to put an undue burden on disambiguating at the end. The whole idea is to distribute the work between inferring sequents and (subsequently) checking satisfiability. The claim is that the middle ground between the two extremes mentioned at the beginning of this section (i.e. between lax side conditions that leave the bulk of the work to disambiguation at the end, and strict side conditions that essentially reduce:: to :) is fertile. 6 Discussion More than one reader (of a previous draft of this paper) has asked about linguistic examples. The 5Compare to (Alshawi and Crouch, 1992). Monotonicity is used above for soundness, Proposition 2. Completeness, Proposition 3, follows from having enough such rules (*) (or equivalently, making the side conditions for (*) comprehensive enough). r1 hc, 01 • • rn hc„ en 92 Proceedings of EACL &apos;99 short, easy answer is that the sort of ambiguity addressed here can be syntactic (with types A ranging over grammatical categories) or semantic (with types drawn, say, from a higher-order predicate logic). Clearly, more must be said — for example, to properly motivate the rules (:: c), (11c) and (Ec) mentioned at the end of §2. Detailed case</context>
</contexts>
<marker>Alshawi, Crouch, 1992</marker>
<rawString>H. Alshawi and R. Crouch. 1992. Monotonic semantic interpretation. In Proc. 30th Annual Meeting of the Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Carbonell</author>
<author>P Hayes</author>
</authors>
<title>Natural language understanding.</title>
<date>1987</date>
<booktitle>Encyclopedia of Artificial Intelligence.</booktitle>
<editor>In S. Shapiro, D. Eckroth, and G. Vallasi, editors,</editor>
<publisher>Wiley and Sons,</publisher>
<location>New York.</location>
<contexts>
<context position="794" citStr="Carbonell and Hayes, 1987" startWordPosition="108" endWordPosition="111">stract Ambiguous propositions are analyzed in a type system where disambiguation is effected during assembly (i.e. by coercion). Ambiguity is introduced through a layer of types that are underspecified relative to a pre-existing collection of dependent types, construed as unambiguous propositions. A simple system of reasoning directly with such underspecification is described, and shown to be sound and complete for the full range of disambiguations. Beyond erasing types, the system supports constraints on disambiguations, including co-variation. 1 Introduction A widely held view expressed in (Carbonell and Hayes, 1987) is that &amp;quot;if there were one word to describe why natural language processing is hard, it is ambiguity.&amp;quot; For any given natural language utterance, a formal language such as predicate logic typically offers several non-equivalent (wellformed) formulas as possible translations. An obvious approach is to take the disjunction of all alternatives, assuming (for the sake of the argument) that the disjunction is a formula. Even if it were, however, various objections have been raised against this proposal (e.g. (Deemter, 1996)). For the purposes of the present paper, what is interesting about a word, </context>
</contexts>
<marker>Carbonell, Hayes, 1987</marker>
<rawString>J. Carbonell and P. Hayes. 1987. Natural language understanding. In S. Shapiro, D. Eckroth, and G. Vallasi, editors, Encyclopedia of Artificial Intelligence. Wiley and Sons, New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Dalrymple</author>
<author>J Lamping</author>
<author>F C N Pereira</author>
<author>V Saraswat</author>
</authors>
<title>LFG semantics via constraints. In</title>
<date>1993</date>
<booktitle>Proc. Sixth European ACL.</booktitle>
<institution>University of Utrecht.</institution>
<contexts>
<context position="3876" citStr="Dalrymple et al., 1993" startWordPosition="617" endWordPosition="620">ovation made in Intuitionistic Type Theory (ITT, (Martin-Lof, 86 Proceedings of EACL &apos;99 1984)) is to allow proofs to enter into judgments of well-formedness (propositionhood). This stands in sharp contrast to ordinary predicate logic (be it intuitionistic or classical), where well-formedness is a trivial matter taken for granted (rather than analyzed) by the Curry-Howard isomorphism. For a natural language, however, it is well-formedness that is addressed by building types A over sentences, nouns, etc (in categorial grammar; e.g. (Morrill, 1994)) or LFG f-structures (in the &amp;quot;glue&amp;quot; approach, (Dalrymple et al., 1993; Dalrymple et al., 1997)). Now, while ITT&apos;s rules for propositionhood hardly constitute an account of grammaticality in English, the combination (in ITT) of assertions of well-formedness (A type) and theoremhood (t: A) re-introduces matters of information content (over and above grammatical form), which have been applied in (Ranta, 1994) (among other places) to discourse semantics (in particular, anaphora). The present paper assumes the machinery of dependent functions and sums in ITT, without choosing between grammatical and semantic applications. In both cases, what ambiguity contributes to</context>
</contexts>
<marker>Dalrymple, Lamping, Pereira, Saraswat, 1993</marker>
<rawString>M. Dalrymple, J. Lamping, F.C.N. Pereira, and V. Saraswat. 1993. LFG semantics via constraints. In Proc. Sixth European ACL. University of Utrecht.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Dalrymple</author>
<author>V Gupta</author>
<author>J Lamping</author>
<author>V Saraswat</author>
</authors>
<title>Relating resource-based semantics to categorial semantics.</title>
<date>1997</date>
<journal>Mathematics of Language 5, Saarbriicken.</journal>
<contexts>
<context position="3901" citStr="Dalrymple et al., 1997" startWordPosition="621" endWordPosition="624">nistic Type Theory (ITT, (Martin-Lof, 86 Proceedings of EACL &apos;99 1984)) is to allow proofs to enter into judgments of well-formedness (propositionhood). This stands in sharp contrast to ordinary predicate logic (be it intuitionistic or classical), where well-formedness is a trivial matter taken for granted (rather than analyzed) by the Curry-Howard isomorphism. For a natural language, however, it is well-formedness that is addressed by building types A over sentences, nouns, etc (in categorial grammar; e.g. (Morrill, 1994)) or LFG f-structures (in the &amp;quot;glue&amp;quot; approach, (Dalrymple et al., 1993; Dalrymple et al., 1997)). Now, while ITT&apos;s rules for propositionhood hardly constitute an account of grammaticality in English, the combination (in ITT) of assertions of well-formedness (A type) and theoremhood (t: A) re-introduces matters of information content (over and above grammatical form), which have been applied in (Ranta, 1994) (among other places) to discourse semantics (in particular, anaphora). The present paper assumes the machinery of dependent functions and sums in ITT, without choosing between grammatical and semantic applications. In both cases, what ambiguity contributes to the pot is indeterminacy</context>
</contexts>
<marker>Dalrymple, Gupta, Lamping, Saraswat, 1997</marker>
<rawString>M. Dalrymple, V. Gupta, J. Lamping, and V. Saraswat. 1997. Relating resource-based semantics to categorial semantics. Mathematics of Language 5, Saarbriicken.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kees van Deemter</author>
</authors>
<title>Towards a logic of ambiguous expressions.</title>
<date>1996</date>
<booktitle>Semantic Ambiguity and Underspecification. CSLI Lecture Notes Number 55,</booktitle>
<editor>In K. van Deemter and S. Peters, editors,</editor>
<location>Stanford.</location>
<marker>van Deemter, 1996</marker>
<rawString>Kees van Deemter. 1996. Towards a logic of ambiguous expressions. In K. van Deemter and S. Peters, editors, Semantic Ambiguity and Underspecification. CSLI Lecture Notes Number 55, Stanford.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tim Fernando</author>
</authors>
<title>Ambiguity under changing contexts.</title>
<date>1997</date>
<journal>Linguistics and Philosophy,</journal>
<volume>20</volume>
<issue>6</issue>
<contexts>
<context position="25869" citStr="Fernando, 1997" startWordPosition="4931" endWordPosition="4932">c). Clearly, more must be said — for example, to properly motivate the rules (:: c), (11c) and (Ec) mentioned at the end of §2. Detailed case studies are bound to push :: in various directions; and no doubt, after applying enough pressure, the system above will break. Be that as it may, I hope that case studies will be carried out (by others and/or by myself), testing, by stretching, the basic idea above. I close with a few words on that idea, and, begging the reader&apos;s indulgence, on the theoretical background out of which, in my experience, it grew. From examining the binary connective • in (Fernando, 1997), I concluded that • is unlike any ordinary logical connective related to entailment because the force of • is best understood relative not to entailment, but to translation. Underlying the distinction between entailment and translation is that between well-formed formulas and possibly ambiguous expressions (corresponding, in the present work, to :-types, on the one hand, and d- and u-expressions, on the other). An abstract picture relating the processes of translation and entailment is framed in (Fernando, in press), which I have attempted to flesh out here for the case of ITT, with a view to</context>
</contexts>
<marker>Fernando, 1997</marker>
<rawString>Tim Fernando. 1997. Ambiguity under changing contexts. Linguistics and Philosophy, 20(6).</rawString>
</citation>
<citation valid="false">
<authors>
<author>Tim Fernando</author>
</authors>
<title>In press. A modal logic for nondeterministic discourse processing.</title>
<journal>Journal of Logic, Language and Information.</journal>
<marker>Fernando, </marker>
<rawString>Tim Fernando. In press. A modal logic for nondeterministic discourse processing. Journal of Logic, Language and Information.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jean-Yves Girard</author>
<author>Yves Lafont</author>
<author>Paul Taylor</author>
</authors>
<title>Proofs and Types. Cambridge Tracts in Theoretical Computer Science 7.</title>
<date>1989</date>
<publisher>Cambridge University Press.</publisher>
<contexts>
<context position="2030" citStr="Girard et al., 1989" startWordPosition="313" endWordPosition="317"> or discourse that is ambiguous in isolation is how it may get disambiguated when combined with other expressions (or, more generally, when placed in a wider context); the challenge for any theory of ambiguity is to throw light on that process of disambiguation. *From June to mid-August 1999, I will be visiting IMS, Uni Stuttgart, Azenbergstr 12, 70174 Stuttgart, Germany. Where I might be after that is unclear. More concretely, suppose • were a binary connective on propositions A and B such that A• B is a proposition ambiguous between A and B. Under the &amp;quot;propositions-as-types&amp;quot; paradigm (e.g. (Girard et al., 1989)) identifying proofs of a proposition with programs of the corresponding type (so that &amp;quot;t: A&amp;quot; can be read as t is a proof of proposition A, or equivalently, t is a program of type A), disambiguation may take the form of type coercion. An instructive example with r as the context x:(A--13)•C, y:D•A is r F- ap(p.(x),q.(y)):B (1) where ap is function application (corresponding to modus ponens), while p. and q. are the first and second •-projections, so that x:(A B) • C p.(x): A - B and y:D • A H q.,(y):A Evidently, there is something conjunctive (never mind disjunctive) about .; but beyond the qu</context>
</contexts>
<marker>Girard, Lafont, Taylor, 1989</marker>
<rawString>Jean-Yves Girard, Yves Lafont, and Paul Taylor. 1989. Proofs and Types. Cambridge Tracts in Theoretical Computer Science 7. Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Per Martin-Lof</author>
</authors>
<title>Intuitionistic Type Theory. Bibliopolis, Napoli. Notes by Giovanni Sambin of a series of lectures given in Padua,</title>
<date>1984</date>
<marker>Martin-Lof, 1984</marker>
<rawString>Per Martin-Lof. 1984. Intuitionistic Type Theory. Bibliopolis, Napoli. Notes by Giovanni Sambin of a series of lectures given in Padua, June 1980.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Glyn V Morrill</author>
</authors>
<title>Type Logical Grammar.</title>
<date>1994</date>
<publisher>Kluwer Academic Publishers,</publisher>
<location>Dordrecht.</location>
<contexts>
<context position="3806" citStr="Morrill, 1994" startWordPosition="608" endWordPosition="609">ward isomorphism to a suitable typed A-calculus. A notable innovation made in Intuitionistic Type Theory (ITT, (Martin-Lof, 86 Proceedings of EACL &apos;99 1984)) is to allow proofs to enter into judgments of well-formedness (propositionhood). This stands in sharp contrast to ordinary predicate logic (be it intuitionistic or classical), where well-formedness is a trivial matter taken for granted (rather than analyzed) by the Curry-Howard isomorphism. For a natural language, however, it is well-formedness that is addressed by building types A over sentences, nouns, etc (in categorial grammar; e.g. (Morrill, 1994)) or LFG f-structures (in the &amp;quot;glue&amp;quot; approach, (Dalrymple et al., 1993; Dalrymple et al., 1997)). Now, while ITT&apos;s rules for propositionhood hardly constitute an account of grammaticality in English, the combination (in ITT) of assertions of well-formedness (A type) and theoremhood (t: A) re-introduces matters of information content (over and above grammatical form), which have been applied in (Ranta, 1994) (among other places) to discourse semantics (in particular, anaphora). The present paper assumes the machinery of dependent functions and sums in ITT, without choosing between grammatical a</context>
</contexts>
<marker>Morrill, 1994</marker>
<rawString>Glyn V. Morrill. 1994. Type Logical Grammar. Kluwer Academic Publishers, Dordrecht.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Aarne Ranta</author>
</authors>
<title>Type-Theoretical Grammar.</title>
<date>1994</date>
<publisher>Oxford University Press,</publisher>
<location>Oxford.</location>
<contexts>
<context position="4216" citStr="Ranta, 1994" startWordPosition="672" endWordPosition="673">zed) by the Curry-Howard isomorphism. For a natural language, however, it is well-formedness that is addressed by building types A over sentences, nouns, etc (in categorial grammar; e.g. (Morrill, 1994)) or LFG f-structures (in the &amp;quot;glue&amp;quot; approach, (Dalrymple et al., 1993; Dalrymple et al., 1997)). Now, while ITT&apos;s rules for propositionhood hardly constitute an account of grammaticality in English, the combination (in ITT) of assertions of well-formedness (A type) and theoremhood (t: A) re-introduces matters of information content (over and above grammatical form), which have been applied in (Ranta, 1994) (among other places) to discourse semantics (in particular, anaphora). The present paper assumes the machinery of dependent functions and sums in ITT, without choosing between grammatical and semantic applications. In both cases, what ambiguity contributes to the pot is indeterminacy in typing, the intuition being that an expression is ambiguous to the extent that its typing is indeterminate. That said, let us return to (1) and consider how to capture sequent inferences such as r I- x:(A --+ B) • C r I- y:D • A F H ap(p.(x),q.(y)):B and more complicated cases from iterated applications of., n</context>
</contexts>
<marker>Ranta, 1994</marker>
<rawString>Aarne Ranta. 1994. Type-Theoretical Grammar. Oxford University Press, Oxford.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>