<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.996333">
Inheritance in Natural Language
Processing
</title>
<author confidence="0.99931">
Walter Daelemans Koenraad De Smedt.
</author>
<affiliation confidence="0.999896">
Tilburg University University of Nijmegen
</affiliation>
<author confidence="0.988573">
Gerald Gazdar
</author>
<affiliation confidence="0.987289">
University of Sussex
</affiliation>
<bodyText confidence="0.993081">
In this introduction to the special issues, we begin by outlining a concrete example that indicates
some of the motivations leading to the widespread use of inheritance networks in computational
linguistics. This example allows us to illustrate some of the formal choices that have to be made
by those who seek network solutions to natural language processing (NLP) problems. We provide
some pointers into the extensive body of Al knowledge representation publications that have been
concerned with the theory of inheritance over the last dozen years or so. We go on to identify the
three rather separate traditions that have led to the current work in NLP. We then provide a fairly
comprehensive literature survey of the use that computational linguists have made of inheritance
networks over the last two decades, organized by reference to levels of linguistic description. In
the course of this survey, we draw the reader&apos;s attention to each of the papers in these issues of
Computational Linguistics and set them in the context of related work.
</bodyText>
<sectionHeader confidence="0.991988" genericHeader="abstract">
1. Introduction
</sectionHeader>
<bodyText confidence="0.99997765">
Imagine that you are a linguistic innocent setting out on the job of building a computer
lexicon for English. You begin by encoding everything you know about the verb love
and then turn your attention to the verb hate. Although they are antonyms, the majority
of properties that you have listed for love will show up again in your list for hate. Your
first thought is to put this list of common properties into an editor macro to save you
the laborious task of typing them all in each time that you add another verb. But
it soon becomes clear to you that adopting this strategy is going to lead to a huge
representation for your lexicon, and one that keeps saying the same thing again and
again. Your second thought is to put the common property list in just one place and call
it, say, TRANSITIVE VERB. Then you amend what you have entered for love and hate
so that all the common material is replaced by a notation that indicates that each is a
transitive verb. This works well and you add a couple of thousand more English verbs
without difficulty. It is only when you reach elapse and expire that you find yourself
landed with the tedious task of again typing full lists of properties, since these two
verbs cannot be accurately represented by including a reference to the TRANSITIVE
VERB property list. Looking at the entries for these two anomalous verbs induces a
feeling of déjà vu. They too have many properties in common, but just not exactly
the same set of common properties as hate and love and their siblings. Following the
strategy that worked well before, you gather their common properties together and
give them the name INTRANSITIVE VERB, then you strip the duplicated material
</bodyText>
<note confidence="0.4736205">
* University of Leiden, Psychology Department, P.O. Box 9555, 2300 RB Leiden, The Netherlands.
C) 1992 Association for Computational Linguistics
</note>
<figure confidence="0.9927169375">
Computational Linguistics
Volume 18, Number 2
VERB
&lt;category&gt; = verb
&lt;past partic&apos;ple&gt; % /e d/
• •
TRANSITIVE VERB
&lt;transitive&gt; = yes
Love
&lt;form&gt; = /I o v e/
Nate
&lt;form&gt; = /h a t e/
INTRANSITIVE VERB
&lt;transitive&gt; = no
Expire
&lt;form&gt; = /expir e/
</figure>
<figureCaption confidence="0.986224">
Figure 1
</figureCaption>
<subsectionHeader confidence="0.46275">
Monotonic single inheritance.
</subsectionHeader>
<bodyText confidence="0.999973208333333">
from the entries for elapse and expire and replace it with a notation that points to your
list of intransitive verb properties. As you inspect your handiwork, you notice that the
lists of properties associated with TRANSITIVE VERB and INTRANSITIVE VERB now
exhibit exactly the kind of duplication that you first saw when you wrote down your
entries for love and hate. Indeed, the number of their commonalities exceeds the number
of their differences. Once again you decide to invoke the style of solution that you have
used before: you collect the common properties together, give the collection the name
VERB and then rework your formulation of TRANSITIVE VERB and INTRANSITIVE
VERB so as to strip the shared material and replace it with a notation indicating that
each is an instance of VERB.
Although you may not realize it, what you have done is build an inheritance
network to represent the information that you are including in your lexicon—see Fig-
ure 1. The root node of this network is VERB and it has two daughters, TRANSITIVE
VERB and INTRANSITIVE VERB, which inherit all the properties associated with the
root. Each of these two nodes has further daughters (Love, Elapse, etc.). The latter
inherit all the properties of VERB together with all the properties of their immediate
parent. These inherited properties are added to the properties listed as idiosyncratic
to the lexical item itself (e.g., the property of being orthographically represented as
/1 o v e/). This very simple lexical network has a couple of characteristics that it is
worth drawing attention to. Firstly, each node has a single parent, and there is thus
only one path through which properties may be inherited. A network of this kind ei-
ther consists of a single tree of nodes, or of a set of (unconnected) trees of nodes, and
we will call such a network a single inheritance network.&apos; Secondly, in describing our
example, we have been assuming that each node inherits all the properties associated
</bodyText>
<footnote confidence="0.979932">
1 Two trees are unconnected if and only if they have no nodes in common. For present purposes, a set of
unconnected trees can always be trivially converted into an equivalent single tree by adding a new
root for all the trees, but one that has no properties associated with it.
</footnote>
<page confidence="0.991661">
206
</page>
<note confidence="0.998145">
Walter Daelemans et al. Inheritance in Natural Language Processing
</note>
<bodyText confidence="0.999867470588235">
with its parent node which, in logician&apos;s parlance, means that property inheritance is
monotonic.
Neither single inheritance nor monotonicity is a necessary characteristic of inheri-
tance networks. Suppose you try to add Beat to the network we have been describing.
The obvious thing to do is to insert it as a daughter of TRANSITIVE VERB. But this
is likely to entail that your network will claim that the past participle is *heated. One
potential solution to this problem would be to define a node called EN TRANSITIVE
VERB and attach Beat as a daughter to this. However, this strategy simply pushes the
problem further up the inheritance tree: EN TRANSITIVE VERB cannot be a daugh-
ter of the TRANSITIVE VERB node since it contains a property (past participle =
/e n/) that is inconsistent with a property associated with the latter (past participle
= /e d/). Nor can our new node be attached as a daughter of VERB, for exactly the
same reason. It seems, therefore, as if the new node may have to be defined wholly
from scratch, duplicating all but one of the properties of TRANSITIVE VERB. To avoid
this disagreeable conclusion, we might consider another potential solution in which
we remove any reference to the past participle suffix at the level of the VERB node,
and specify it instead at the level of that node&apos;s daughters. At first sight, this appears
to be a most attractive option. In fact, by adopting it, we have embarked on a slippery
slope that will result in our stripping VERB of almost all the properties canonically
associated with verbs. For each property you might expect it to have, if there is a sin-
gle verb in English that is exceptional with respect to that property, then the property
cannot appear at the VERB node. In the case of morphological properties, this is likely
to mean that &amp;quot;present participle = /i n g/&amp;quot; is the only property that can be associated
with the VERB node. And, in the case of syntactic properties, it is likely to mean that
banalities such as &amp;quot;category = verb&amp;quot; will be all we are able to list.
How are we to avoid these rather dismal alternatives? There are (at least) two
possibilities. One is to abandon single inheritance. Suppose we reorganize our net-
work so that TRANSITIVE VERB and INTRANSITIVE VERB only encode syntactic
properties of verbs. We then introduce two further nodes, ED VERB and EN VERB,
which only encode morphological properties. Then we allow Beat to have both TRAN-
SITIVE VERB and EN VERB as its parents. A network of this kind can no longer be
represented as a tree (or set of unconnected trees) and is said to employ multiple in-
heritance—see Figure 2. Another possibility is to abandon monotonicity. We leave Beat
where we first attached it, under TRANSITIVE VERB in our original network, and we
associate the property &amp;quot;past participle = /e n/&amp;quot; with it. If inheritance continues to be
construed monotonically, then the network will make contradictory claims about the
past participle of Beat. But if we adopt a nonmonotonic interpretation of inheritance,
in which properties that are attached to a node take precedence over those that are in-
herited from a parent, then no contradiction will arise. Such nonmonotonic inheritance
is known as &amp;quot;default inheritance&amp;quot;—see Figure 3.
Monotonic single inheritance networks are easy to build and easy to understand. If
one designs a notation for defining them, then it is straightforward to say what the se-
mantics of that notation is: translation into first order logic, for example, is quite trivial.
Unfortunately, for the reasons hinted at in the example considered above, monotonic
single inheritance networks are not really very well suited to the description of natural
languages. As a result, as we shall see below, most researchers who have employed in-
heritance techniques in NLP have chosen to use either default inheritance or multiple
inheritance or, very commonly, both. Networks that employ default and/or multiple
inheritance are also quite easy to build, but they are much less easy to understand.
The combination of default and multiple inheritance is especially problematic: &amp;quot;de-
spite a decade of study, with increasingly subtle examples and counterexamples being
</bodyText>
<page confidence="0.992742">
207
</page>
<bodyText confidence="0.1971">
Computational Linguistics Volume 18, Number 2
</bodyText>
<equation confidence="0.9872180625">
VERB
&lt;category, = verb
V.
EN VERB
&lt;past participle&gt; = /e n/
TRANSITIVE VERB
&lt;transitive&gt; = yes
Hate
&lt;form&gt; = /h a t e/
ED VERB
&lt;past partic&apos;ple&gt; = /e
. .
INTRANSITIVE VERB
&lt;transitive&gt; no
1 Elapse
&lt;form&gt; = /elapS e/
Beat
&lt;form&gt; = /b e a t/
Figure 2
Monotonic multiple inheritance.
VERB
&lt;category&gt; = verb
&lt;past partic pie&apos; = /e d/
. ,
1.1
TRANSITIVE VERB
&lt;transitive&gt; = yes
INTRANSITIVE VERB
&lt;transitive&gt; = no
. .
Hate
&lt;form&gt; = /h a t e/
</equation>
<figure confidence="0.863545">
Beat
doree. = /6 e a t/
&lt;past participle&gt; . /e n/
Elapse Expire
&lt;form&gt; = /elaps e/ &lt;forgo = /expir e/
</figure>
<figureCaption confidence="0.560651">
Figure 3
Nonmonotonic single inheritance.
</figureCaption>
<page confidence="0.8868">
208
</page>
<note confidence="0.922226">
Walter Daelemans et al. Inheritance in Natural Language Processing
</note>
<bodyText confidence="0.999890145833333">
considered, consensus has yet to emerge regarding the proper treatment of multiple
inheritance with cancellations&amp;quot; (Selman and Levesque 1989, pp. 1140). Unsurprisingly,
the problem has given rise to a large, and growing, list of publications in the knowl-
edge representation literature (see, e.g., Horty, Thomason, and Touretzky 1990, and
references therein). Almost all of this theoretical work has concerned itself with very
simple networks that are only able to say whether or not a monadic property holds of a
node in the network. Recently, however, Thomason and Touretzky (1991) have turned
their attention to the properties of more expressive networks, potentially capable of
encoding what would need to be encoded in any real NLP application. Nonmonotonic
inference more generally (i.e. not just in networks) has been, arguably, the dominant
theoretical concern in the AT literature of the late 1980s (as measured, for example, by
the proportion of papers that have appeared on the topic in Artificial Intelligence over
the period).
One of the key issues in the knowledge representation literature has been how to
deal with the default inheritance of mutually contradictory information from two or
more parent nodes. Most NLP researchers who have embraced multiple inheritance
techniques have chosen to avoid this issue by adopting one of two strategies. On one
strategy, information is partitioned between parental nodes. You can, for example,
inherit morphological properties from node A and syntactic properties from node B,
but no single property can be inherited from more than one parent node. This is known
as &amp;quot;orthogonal inheritance.&amp;quot; One way of thinking of it is in terms of a set of disjoint
single inheritance networks layered on top of each other. On another strategy, a given
property, or set of properties, may potentially be inherited from more than one parent
node, but the parents are ordered: the first parent in the ordering that is able to supply
the property wins, and contradiction is thus avoided. We will refer to this strategy as
&amp;quot;prioritized inheritance.&amp;quot;
The use of inheritance networks in current NLP comes from three rather separate
traditions. The first is that of &amp;quot;semantic nets&amp;quot; in Al, which goes back to Quillian (1968)
through Fahlman&apos;s (1979) NETL to the late 1980s monographs by Touretzky (1986) and
Etherington (1988). The second is that of data abstraction in programming languages,
which has led to (a) object-orientation in computer science with its notions of classes
and inheritance as embodied in such languages as Smalltalk, Simula, Flavors, CLOS
and C++, and (b) the use of type hierarchies, which have become widely seen in
unification-oriented NLP since the appearance of AR-Kaci (1984) and Cardelli (1984).
Of necessity, the type hierarchy work in NLP has remained strictly monotonic. The
third is the notion of &amp;quot;markedness&amp;quot; in linguistics, which originates in the Prague School
phonology of the 1930s, reappears in the &amp;quot;generative phonology&amp;quot; of Chomsky and
Halle (1968) and Hetzron&apos;s (1975) and Jackendoff&apos;s (1975) models of the lexicon, and
shows up in syntax in the &amp;quot;feature specification defaults&amp;quot; of Gazdar, Klein, Pullum,
and Sag (1985).2 Unlike the other three traditions, the linguistic tradition does not
embody a notion of inheritance per se. But the issue of how to decide which operations
take precedence over others has been a continuing concern in the literature (see, e.g.,
Pullum 1979, especially Section 1.4.1, and references therein).
The consensus view, though largely unspoken, among computational linguists cur-
rently working with default inheritance networks appears to be that nodes that are
close (or identical) to the root(s) of the network should be used to encode that which
is regular, &amp;quot;unmarked,&amp;quot; and productive, and that distance from the root(s) should
correlate with increasing irregularity, &amp;quot;markedness,&amp;quot; and lack of productivity. At the
</bodyText>
<page confidence="0.7322475">
2 See Evans (1987), Gazdar (1987), and Shieber (1986a) on the various defaulty characteristics of GPSG.
209
</page>
<note confidence="0.317792">
Computational Linguistics Volume 18, Number 2
</note>
<bodyText confidence="0.99988375">
very least, this is what emerges from their practice. T he differences between the cur-
rent strands of NLP work in this area are partly philosophical (e.g., as to whether
psycholinguistic data could or should be relevant to the structure of the network),
partly methodological (e.g., as to whether networks should be built in a formal lan-
guage designed for the purpose or implemented in an existing computer language),
partly technical (e.g., whether a negation operator is useful, or whether orthogonal
networks are to be preferred to those using prioritized inheritance), and partly the-
oretical (e.g., the trade-off between the semantic perspicuity of monotonic networks
versus the expressiveness and concision of their nonmonotonic competitors).
In the subsequent sections of this paper we will survey the use computational
linguists have made of inheritance networks over the last dozen years. To organize
this chronologically (e.g. by date of publication) would be to impose a wholly spurious
sense of historical continuity on what has, in fact, been a fairly haphazard set of parallel
developments. It is tempting to try to organize the discussion that follows by reference
to technical and formal parameters, but the area is just too young for that to be possible
without a great deal of rather arbitrary taxonomy. So we have chosen to play safe and
organize the material by reference to levels of linguistic description. This is not wholly
satisfactory, since a significant number of the approaches we discuss have been applied
to several different levels of description, which means that we have to refer to them
in more than one section. But we hope that readers will bear with us.
</bodyText>
<sectionHeader confidence="0.609206" genericHeader="categories and subject descriptors">
2. Syntax and Morphology
</sectionHeader>
<bodyText confidence="0.999524535714286">
One of the earliest applications of inheritance to syntax was Bobrow and Webber&apos;s
(1980a,b) use of PSI-KLONE (a variant of KL-ONE) to encode ATNs. In the context
of RUS, a system for natural language parsing and interpretation, inheritance was
used to organize linguistic knowledge efficiently in terms of grammatical categories.
This frame-based representation was used by a process called incremental description
refinement, which first determined which descriptions were compatible with an object
known to have a set of properties, and then refined this set of descriptions as more
properties become known. Subsequent work by Brachman and Schmolze (1985) used
PSI-KLONE to translate the ouput of the RUS parser into KL-ONE representations of
literal meaning. An inheritance network that the authors refer to as a &amp;quot;syntaxonomy&amp;quot;
is used to encode information about syntactic categories.
A rather similar view of language processing is to be found in the Conceptual
Grammar of Steels (1978) and Steels and De Smedt (1983). This approach adopted
a single frame-based grammar representation for a variety of language processing
tasks and for all types of linguistic knowledge. General inference mechanisms based
on constraint propagation used the frames, organized in inheritance hierarchies, in
generation and parsing. De Smedt (1984) went on to use generic function application to
provide one of the earliest illustrations of the descriptive power of default inheritance
networks for morphology in a treatment of Dutch verbs, an analysis that is extended
to adjectival and nominal forms in De Smedt and de Graaf (1990). In the same paper,
the authors indicate how inheritance techniques can be applied to a unification-based
formalism called Segment Grammar (Kempen 1987), which is intended to facilitate
incremental syntactic processing.
Attempts to reconcile inheritance with unification grammars began in the mid-
1980s. Shieber (1986b, p. 57ff) noted that the provision of lexical &amp;quot;templates&amp;quot; in PATR
amounted to a language for defining monotonic multiple inheritance networks. He
drew attention to the possibility of adding a nonmonotonic &amp;quot;overwriting&amp;quot; operation to
PATR and commented that &amp;quot;the cost of such a move is great, however, because the use
</bodyText>
<page confidence="0.997227">
210
</page>
<note confidence="0.97785">
Walter Daelemans et al. Inheritance in Natural Language Processing
</note>
<bodyText confidence="0.979587571428571">
of overwriting eliminates the order independence that is so advantageous a property
in a formalism&amp;quot; (1986, p. 60). In a subsequent implementation of PATR, Karttunen
(1986) makes all D-PATR templates subject to overwriting. The very similar notion of
&amp;quot;priority union&amp;quot; is introduced in the context of LFG by Kaplan (1987, p. 180). These
ideas are developed by Bouma (this issue) who gives a definition of default unification
on the basis of a logic for features.
Kameyama (1988) uses PATR-style templates to build a multiple inheritance mul-
tilingual lexicon to support Categorial Unification Grammar descriptions of Arabic,
English, French, German, and Japanese nominals. Although the system described is
monotonic, there is a footnote suggesting a move toward a default inheritance system
to deal with marked constituent orders (p. 202, n10).
Of all the unification-based grammar formalisms, it is HPSG which has thus far led
to the greatest use of inheritance networks, both default and monotonic. Flickinger, Pol-
lard, and Wasow (1985) proposed a treatment of lexical organization in which English
subcategorization frames and inflectional morphology were handled within a default
multiple inheritance network implemented in HPRL. They pointed out that such an
approach took care of morphological &amp;quot;blocking&amp;quot; phenomena &amp;quot;largely for free&amp;quot; (1985,
p. 267).3 In his 1987 Ph.D. dissertation, Flickinger goes on to provide a monograph
length inheritance treatment of the syntactic and morphological information embod-
ied in the English lexicon. His analysis crucially presupposes machinery for multiple
default inheritance. Like Shieber (1986b, pp. 60-61), he notes the problem that contra-
dictory attribute values pose for such machinery and entertains the hypothesis that
the relevant links &amp;quot;should be disjoint in the set of attributes for which they support
inheritance&amp;quot; (1987, p. 61). Flickinger&apos;s thesis is probably the most detailed discursive
application of a default inheritance framework to the lexicon. In their paper in the
present issue, Flickinger and Nerbonne (in press) extend the analysis further still so
as to encompass some of the trickiest and most-debated data in the syntax of English.
Pollard and Sag (1987), in the first book-length presentation of HPSG, treat the
lexicon as a monotonic multiple-inheritance type hierarchy. They implicitly reject the
use of an &amp;quot;overriding mechanism&amp;quot; (p. 194, n4) in favor of a variety of restrictions
designed to prevent overgeneration, together with a nonmonotonic formulation of
lexical rules (pp. 212-213). A concern to preserve monotonic inheritance in HPSG is
likewise evident in more recent work, such as Carpenter and Pollard (1991) and Zajac
(this issue).
Monotonic multiple inheritance type hierarchies figure in a good deal of recent
work in unification-based grammars. Examples include papers by Porter (1987), Emele
and Zajac (1990), and Emele et al. (1990), who all use a semantics based on Ait-Kaci
(1984); the use of sorts in Unification Categorial Grammar (Moens et al. 1989); the CLE
project (Alshawi et al. 1989) and theoretical work by Smolka (1988).
Default multiple inheritance also figures centrally in a couple of grammatical
frameworks. One is Hudson&apos;s (1984,1990) Word Grammar, and a detailed exposition
is provided by Fraser and Hudson in this issue. Word Grammar is a feature-based
variant of dependency grammar, one that makes pervasive use of a (multiple) inheri-
tance relation. The latter is unusual in that stipulated exceptions do not automatically
override an inherited default: the latter has to be explicitly negated if the grammar
requires its suppression (compare Flickinger, Pollard, and Wasow&apos;s (1985) approach to
&amp;quot;blocking,&amp;quot; noted above).
3 The existence of an irregular form typically means that the corresponding regular form is not a
permissible option. This is known as -blocking.&amp;quot;
</bodyText>
<page confidence="0.982548">
211
</page>
<note confidence="0.319205">
Computational Linguistics Volume 18, Number 2
</note>
<bodyText confidence="0.999702551724138">
The other is ELU (Russell et al. in press), which extends a PATR-like grammar
formalism with a language for defining default multiple inheritance networks for
the lexicon. Inspired by CLOS, an object-oriented extension of Common LISP, they
adopt prioritized inheritance to escape the problem caused by conflicting inherited
information. Russell et al. (in press) illustrate their approach with ELU analyses of
English and German verbal morphology.
Evans and Gazdar (1989a) outline the syntax and theory of inference for DATR, a
language for lexical knowledge representation, and (1989b) they provide a semantics
for the language that is loosely based on the approach taken by Moore (1985) in
his semantics for autoepistemic logic. DATR allows multiple default inheritance but
enforces orthogonality. Evans et al. (in press) show how DATR can also be used to
encode certain kinds of prioritized inheritance. Unlike ELU and the Word Grammar
notation, DATR is not intended to be a full grammar formalism. Rather, it is intended
to be a lexical formalism that can be used with any grammar that can be encoded in
terms of attributes and values. Kilbury et al. (1991) show how a DATR lexicon can be
linked to a PATR syntax, while Andry et al. (in press) employ a DATR lexicon in the
context of a Unification Categorial Grammar. The use of DATR to describe morphology
is illustrated, for Latin, by Gazdar (in press) and in the fragments of Arabic, English,
German, and Japanese included in Evans and Gazdar (1990).
All of our discussion thus far has presupposed the use of inheritance networks
to store essentially static information. But, following the precedent set by Brachman
and Schmolze (1985), a number of researchers have begun to explore their utility in
language processing itself. Thus, for example, van der Linden (this issue) exploits the
structure of the network in order to avoid premature lexical disambiguation and to
identify lexical preferences during incremental parsing with a Lambek categorial gram-
mar. And Vogel and Popowich (1990) add a new twist to the now familiar &amp;quot;parsing
as deduction&amp;quot; strategy: instead of construing parsing as, for example, inference in a
Horn clause logic, they describe an HPSG parser that operates by means of path-based
inference over an inheritance network.
</bodyText>
<sectionHeader confidence="0.668122" genericHeader="method">
3. Phonology, Orthography, and Morphophonology
</sectionHeader>
<bodyText confidence="0.999920764705882">
Computational phonology is perhaps the youngest and least studied branch of NLP.
But notions of default have played such a prominent role in linguistic discussion of
the area that it is not surprising that default inheritance networks have found a place
in this subfield right from the start.
Thus Gibbon and Reinhard have made extensive use of DATR networks to de-
scribe lexical morphophonological phenomena such as German umlaut, Kikuyu tone,
and Arabic vowel intercalation (Gibbon 1990b, in press; Reinhard 1990; Reinhard and
Gibbon 1991). And Daelemans (1987a,b, 1988) uses the object-oriented knowledge rep-
resentation language KRS to implement default orthogonal inheritance networks for
the lexical representation of phonological, orthographic, and morphological knowledge
of Dutch and shows how such a lexicon architecture can be used for both language
generation and automatic dictionary construction. The work of Calder (1989) and his
associates at Edinburgh and Stuttgart on &amp;quot;paradigmatic morphology&amp;quot; also fits within
this tradition in that it invokes a restricted kind of default orthogonal inheritance for
morphophonological description. However, the emphasis in this work is on the use of
string unification to define morphological operations rather than on the default struc-
ture of the lexicon per se. In subsequent work, Calder and Bird (1991) use a general
</bodyText>
<page confidence="0.994317">
212
</page>
<note confidence="0.992461">
Walter Daelemans et al. Inheritance in Natural Language Processing
</note>
<bodyText confidence="0.8916095">
nonmonotonic logic to give a formal reconstruction of &amp;quot;underspecification phonology&amp;quot;
(Archangeli 1988).&amp;quot;
</bodyText>
<sectionHeader confidence="0.40465" genericHeader="method">
4. Semantics and Pragmatics
</sectionHeader>
<bodyText confidence="0.999867317073171">
Given that knowledge representation was principally driven by nat-
ural language concerns right up to the beginning of the decade, one
would have expected substantial progress to have been made in the
1980s on knowledge representation support for natural language se-
mantics. This seems not to have been the case (Brachman 1990; p. 1088).
If one compares the progress made in morphology and syntax in NLP in the 1980s,
then Brachman&apos;s judgment is surely correct. And yet there has been a steady tradition
of using semantic networks in the service of natural language understanding that
goes back at least as far as Simmons (1973). Much of the work in this tradition has
concerned itself with domain and world knowledge relevant to disambiguation and
to drawing inferences from what is said, but not to the semantic representations of
words, phrases and utterances per se. Exceptions to this generalization are not hard
to find, however.
For example, Barnett et al. (1990) use the same language (CycL) for linguistic
semantic representation as is used in the encyclopedic inheritance network for which
they are providing a natural language interface. And Jacobs (1986, 1987) proposes a
uniform hierarchical encoding of both linguistic and conceptual knowledge in a frame-
based formalism called ACE. Jacobs then uses the resulting inheritance network to
give an account of metaphor, inter alia. By contrast, Allgayer et al. (1989) employ two
separate inheritance networks, one for linguistic semantic knowledge and the other
for conceptual knowledge, both being implemented in a KL-ONE derivative called
SB-ONE.
Several of the inheritance-based linguistic knowledge representation formalisms
that we have introduced in earlier sections are being used for semantic purposes. Thus
Fraser and Hudson (this issue) make crucial use of the Word Grammar inheritance
network to reconstruct the meanings of various types of constituent (e.g. verb phrases)
that cannot be syntactically reconstructed in a dependency grammar. Weischedel (1989)
uses the taxonomic language NKL (based on KL-ONE) to express selectional restric-
tions, while Andry et al. (in press) use DATR for the same purpose. Cahill and Evans
(1990) use DATR to build up complex lambda calculus representations in the lexi-
con of a message understanding system. Briscoe et al. (1990) use a version of PAIR
augmented with defeasible templates to implement a default orthogonal inheritance
network for a Pustejovskian analysis of metonymic sense extension in lexical seman-
tics (e.g. interpreting the film in Enjoy the film! as watching the film).5 Their approach is
further elaborated in Briscoe and Copestake (1991) and Copestake and Briscoe (1991).
A semantic analog of the monotonic type hierarchies discussed above in connection
with syntax is manifested in the situation theoretic &amp;quot;infon lattices&amp;quot; introduced by
Kameyama et al. (1991) to deal with meaning mismatches in machine translation.
The use of inheritance networks for specifically linguistic pragmatic purposes (as
opposed to general reasoning) is notable largely for its absence. The only example we
know of is Etherington et al.&apos;s (1989) proposal to represent the consequences of Gricean
</bodyText>
<footnote confidence="0.489713">
4 Compare Gibbon&apos;s (1990a) use of DATR to the same end.
5 See Pustejovsky (1989, 1991).
</footnote>
<page confidence="0.977186">
213
</page>
<note confidence="0.508376">
Computational Linguistics Volume 18, Number 2
</note>
<bodyText confidence="0.993546727272727">
maxims in a default inheritance network designed for fast (though not necessarily
correct) reasoning.
Most recent computational linguistic work on pragmatics has tended to turn to
general nonstandard logics as tools for the job, rather than their less expressive network
relations. Thus Joshi et al. (1984) and Lascarides and Asher (1991) have made the case
for nonmonotonic logics in formalizing Gricean maxims, while Schubert and Hwang
(1989) show how a probabilistic logic might be used in story understanding. Mercer
and Reiter (1982) and Mercer (1988) have employed Reiter&apos;s default logic to capture
the behavior of natural language presuppositions. Perrault (1990) uses default logic to
express a theory of speech acts, while Appelt and Konolige (1988) have deployed an
extension to Moore&apos;s (1985) autoepistemic logic for the same purpose.
</bodyText>
<sectionHeader confidence="0.959758" genericHeader="method">
5. Concluding Remarks
</sectionHeader>
<bodyText confidence="0.999964142857143">
Within computational linguistics, it is possible to see three distinct trends emerging.
The first is the increasing employment of monotonic type lattices in unification-based
grammars to constrain the space of permissible descriptions. The second is the use
of a variety of general nonmonotonic logics for formalizing pragmatic components
of NLP systems. And the third is the development of a variety of restricted default
inheritance languages designed for the representation of phonological, morphological,
syntactic, and compositional semantic properties of lexemes.
This last trend is partly driven by descriptive linguistic considerations (e.g. captur-
ing linguistically significant generalizations) and partly by considerations of software
engineering. The latter are somewhat analogous to the considerations that have encour-
aged the spread of object-orientation in computer science and include (i) parsimony—
inheritance lexicons can be made one or two orders of magnitude smaller than their
full-entry counterparts; (ii) ease of maintenance—changes or corrections will typically
only need to be made in one or two nodes, not in thousands of individual entries; (iii)
uniformity—several levels of linguistic description can be encoded in the same way
and be made subject to the same rules of inference; (iv) modularity—multiple inheri-
tance allows different taxonomies to apply for different levels of description; and (v)
interaction—where a lexical property at one level of description (e.g. syntactic gender)
depends on a lexical property at another level of description (e.g. the phonology of a
word-final vowel), then this can be stated.
The work that has been done to date suggests that while default inheritance is
essential for lexical networks, full unrestricted multiple inheritance is probably more
of a hindrance than a help. It looks as if some version of orthogonal or prioritized
inheritance will be sufficient for lexical knowledge representation. Moore and Kaplan
(in Whitelock et al. 1987, pp. 62-63) have noted that lexical defaults amount to de-
fault specification (as opposed to the conjectural defaults of standard AT knowledge
representation) and that they often substitute for (large) finite specifications. Likewise,
Thomason (1991) has referred to lexical defaults as &amp;quot;a priori in a sense&amp;quot; or &amp;quot;at least
stipulative or conventional&amp;quot; and he goes on to point out that any nonmonotonic lexical
application can be converted to a monotonic one, albeit at the cost of scale. These con-
siderations provide some limited grounds for optimism with regard to the tractability
and mathematical probity of (future) languages for lexical representation. However,
two cautionary notes are in order: firstly, the inheritance relation itself is not the sole
source of intractability, and, secondly, existing work on inheritance lexicons has been
almost wholly based on familiar European languages.
</bodyText>
<page confidence="0.998949">
214
</page>
<note confidence="0.99748">
Walter Daelemans et al. Inheritance in Natural Language Processing
</note>
<sectionHeader confidence="0.973872" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.9988875">
We are grateful to Rich Thomason for
relevant conversation and comments.
</bodyText>
<sectionHeader confidence="0.790548" genericHeader="references">
References
</sectionHeader>
<figureCaption confidence="0.741160418604651">
Aft-Kaci, Hassan (1984). A Lattice-Theoretic
Approach to Computation Based on a Calculus
of Partially Ordered Types. Doctoral
dissertation, University of Pennsylvania,
Philadelphia, PA.
Allgayer, Jansen-Winkeln, Roman;
Reddig, Carola; and Reithinger, Norbert
(1989). &amp;quot;Bidirectional use of knowledge in
the multi-modal NL access system
XTRA,&amp;quot; IJCAI-89, 1492-1497.
Alshawi, Hiyan; Carter, David; van Eijck,
Johan; Moore, Robert; Moran, Douglas;
Pereira, Fernando; Pulman, Stephen; and
Smith, Arnold (1989). &amp;quot;Final Report: Core
Language Engine,&amp;quot; Technical Report,
Project No. 2989, SRI, Cambridge.
Andry, Francois; Fraser, Norman M.;
McGlashan, Scott; Thornton, Simon; and
Youd, Nick (1991). &amp;quot;Making DATR work
for speech: Lexicon compilation in
SUNDIAL,&amp;quot; Computational Linguistics,
18,3.
Appelt, Douglas, and Konolige, Kurt (1988).
&amp;quot;A practical nonmonotonic theory of
speech acts.&amp;quot; In ACL Proceedings, 26th
Annual Meeting, 170-178.
Archangeli, D. (1988). &amp;quot;Aspects of
underspecification theory&amp;quot; Phonology, 5,
183-207.
Barnett, Jim; Knight, Kevin; Mani, Inderjeet;
and Rich, Elaine (1990). &amp;quot;Knowledge and
natural language processing,&amp;quot;
Communications of the ACM, 33,8,50-71.
Bobrow, Robert J., and Webber, Bonnie Lynn
(1980a). &amp;quot;PSI-KLONE,&amp;quot; Third Biennial
Conference of the CSCSI/SCEIO, 131-142.
Bobrow, Robert J., and Webber, Bonnie Lynn
(1980b). &amp;quot;Knowledge representation for
syntactic/semantic processing,&amp;quot; AAAI-80,
316-323.
Bouma, Gosse (1992). &amp;quot;Feature structures
and nonmonotonicity,&amp;quot; Computational
Linguistics, 18(2), 183-203.
</figureCaption>
<reference confidence="0.896778457142857">
Brachman, Ronald J. (1990). &amp;quot;The future of
knowledge representation,&amp;quot; AAAI-90,
1082-1092.
Brachman, Ronald J., and Schmolze, James
G. (1985). &amp;quot;An overview of the KL-ONE
knowledge representation system,&amp;quot;
Cognitive Science, 9,191-216.
Briscoe, Ted; Copestake, Ann; and
Boguraev, Bran (1990). &amp;quot;Enjoy the paper:
Lexical semantics via lexicology.&amp;quot; In
COLING-90,42-47.
Briscoe, Ted, and Copestake, Ann (1991).
&amp;quot;Sense extensions as lexical rules.&amp;quot; In
Proceedings of the IJCAI Workshop on
Computational Approaches to Non-Literal
Language. Sydney.
Cahill, Lynne, and Evans, Roger (1990). &amp;quot;An
application of DATR: the TIC lexicon,&amp;quot;
ECAI-90, 120-125.
Calder, Jo (1989). &amp;quot;Paradigmatic
morphology.&amp;quot; In ACL Proceedings, Fourth
European Conference, 58-65.
Calder, Jo, and Bird, Steven (1991). &amp;quot;Defaults
in underspecification phonology&amp;quot; In
Default Logics for Linguistic Analysis, edited
by Hans Kamp, 129-139, DYANA,
ESPRIT deliverable R2.5.B, Edinburgh.
Cardelli, Luca (1984). &amp;quot;A semantics of
multiple inheritance.&amp;quot; In Semantics of Data
Types, edited by G. Kahn, D. B. McQueen,
and G. Plotkin, 51-67. New York:
Springer.
Carpenter, Bob, and Pollard, Carl (1991)
&amp;quot;Inclusion, disjointness, and choice: The
logic of linguistic classification.&amp;quot; In ACL
Proceedings, 29th Annual Meeting, 9-16.
Chomsky, Noam, and Halle, Morris (1968).
The Sound Pattern of English. New York:
Harper and Row.
Copestake, Ann, and Briscoe, Ted (1991).
&amp;quot;Lexical operations in a unification-based
framework.&amp;quot; In Proceedings, ACL-SIGLEX
Workshop on Lexical Semantics and
Knowledge Representation, Berkeley,
188-197.
Daelemans, Walter M. P. (1987a). &amp;quot;A tool for
the automatic creation, extension and
updating of lexical knowledge bases.&amp;quot; In
ACL Proceedings, 3rd European Conference,
70-74.
Daelemans, Walter M. P. (1987b). Studies in
language technology: An object-oriented
computer model of morpho phonological aspects
of Dutch. University of Leuven. Doctoral
dissertation.
Daelemans, Walter M. P. (1988). &amp;quot;A model
of Dutch morphophonology and its
applications,&amp;quot; Al Communications, 1(2),
18-25.
De Smedt, Koenraad (1984). &amp;quot;Using
object-oriented knowledge-representation
techniques in morphology and syntax
programming,&amp;quot; ECAI-84, 181-184.
De Smedt, Koenraad, and de Graaf, Josje
(1990). &amp;quot;Structured inheritance in
frame-based representation of linguistic
categories.&amp;quot; In Proceedings of the Workshop
on Inheritance in Natural Language
Processing, edited by Walter Daelemans
and Gerald Gazdar, 39-47. Tilburg, The
</reference>
<page confidence="0.996694">
215
</page>
<note confidence="0.459409">
Computational Linguistics Volume 18, Number 2
</note>
<reference confidence="0.978615139344262">
Netherlands: ITK.
Emele, Martin C., and Zajac, Remi (1990).
&amp;quot;Typed unification grammars.&amp;quot; In
COLING-90, 293-298.
Emele, Martin C.; Heid, Ulrich; Momma,
Stefan; and Zajac, Remi (1990).
&amp;quot;Organizing linguistic knowledge for
multilingual generation.&amp;quot; In COLING-90,
102-107.
Etherington, David W. (1988). Reasoning with
Incomplete Information. London/Los Altos:
Pitman/Morgan Kaufmann.
Etherington, David W.; Borgida, Alex;
Brachman, Ronald J.; and Kautz, Henry
(1989). &amp;quot;Vivid knowledge and tractable
reasoning: preliminary report,&amp;quot; IJCAI-89,
1146-1152.
Evans, Roger (1987). &amp;quot;Towards a formal
specification for defaults in GPSG.&amp;quot; In
Proceedings, Workshop on Natural Language
Processing, Unification, and Grammar
Formalisms, University of Stirling, 3-8.
Evans, Roger, and Gazdar, Gerald (1989a).
&amp;quot;Inference in DATR.&amp;quot; In ACL Proceedings,
4th European Conference, 66-71.
Evans, Roger, and Gazdar, Gerald (1989b).
&amp;quot;The semantics of DATR.&amp;quot; In Proceedings,
Seventh Conference of the Society for the Study
of Artificial Intelligence and Simulation of
Behaviour, edited by Anthony G. Cohn,
79-87.
Evans, Roger, and Gazdar, Gerald (1990).
&amp;quot;The DATR Papers, Volume 1,&amp;quot; Cognitive
Science Research Paper CSRP 139,
University of Sussex, Brighton.
Evans, Roger; Gazdar, Gerald; and Moser,
Lionel (In press). &amp;quot;Prioritised multiple
inheritance in DATR.&amp;quot; In Default
Inheritance in the Lexicon, edited by Ted
Briscoe, Ann Copestake, and Valeria
de Paiva. Cambridge: Cambridge
University Press.
Fahlman, Scott (1979). NETL: A System for
Representing and Using Real-World
Knowledge. Cambridge, MA: The MIT
Press.
Flickinger, Daniel P.; Pollard, Carl J.; and
Wasow, Thomas (1985). &amp;quot;Structure-sharing
in lexical representation.&amp;quot; In ACL
Proceedings, 23rd Annual Meeting, 262-267.
Flickinger, Daniel P. (1987). Lexical Rules in
the Hierarchical Lexicon. Doctoral
dissertation, Stanford University.
Flickinger, Daniel P., and Nerbonne, John
(In press). &amp;quot;Inheritance and
complementation: A case study of easy
adjectives and related nouns,&amp;quot;
Computational Linguistics, 18(3).
Fraser, Norman M., and Hudson, Richard A.
(1992). &amp;quot;Inheritance in word grammar,&amp;quot;
Computational Linguistics, 18(2), 133-158.
Gazdar, Gerald (1987). &amp;quot;Linguistic
applications of default inheritance
mechanisms.&amp;quot; In Linguistic Theory and
Computer Applications, edited by Peter
Whitelock, Mary McGee Wood, Harold
L. Somers, Rod L. Johnson, and Paul
Bennett, 37-67, London: Academic Press.
Gazdar, Gerald (In press). &amp;quot;Ceteris paribus.&amp;quot;
In Aspects of Computational Linguistics:
Syntax, Semantics, Phonetics, edited by
Christian Rohrer and Hans Kamp. Berlin:
Springer-Verlag.
Gazdar, Gerald; Klein, Ewan; Pullum,
Geoffrey K.; and Sag, Ivan A. (1985).
Generalized Phrase Structure Grammar,
Oxford /Cambridge: Blackwell/Harvard.
Gibbon, Dafydd (1990a).
&amp;quot;Underspecification in phonology.&amp;quot; In The
DATR Papers, Volume 1, edited by Roger
Evans and Gerald Gazdar, 99-100.
University of Sussex, Brighton: COGS.
Gibbon, Dafydd (1990b). &amp;quot;Prosodic
association by template inheritance.&amp;quot; In
Proceedings, Workshop on Inheritance in
Natural Language Processing, Walter
Daelemans and Gerald Gazdar, 65-81.
Tilburg, The Netherlands: ITK (Institute
for Language Technology and Al).
Gibbon, Dafydd (1991). &amp;quot;ILEX: a linguistic
approach to computational lexica.&amp;quot; In
Ursula Klenk, ed. Computatio Linguae:
Aufsti tze Zur algorithmischen und
quantitativen Analyse der Sprache.
Zeitschrift fur Dialektologie und
Linguistik, Beiheft 7,32-53.
Hetzron, Robert (1975). &amp;quot;Where the
grammar fails,&amp;quot; Language, 51,859-872.
Horty, John E; Thomason, Richmond H.;
and Touretzky, David S. (1990). &amp;quot;A
skeptical theory of inheritance in
nonmonotonic semantic networks,&amp;quot;
Artificial Intelligence, 42(2-3), 311-348.
Hudson, Richard A. (1984). Word Grammar.
Oxford: Blackwell.
Hudson, Richard A. (1990). English Word
Grammar. Oxford: Blackwell.
Jackendoff, Ray (1975). &amp;quot;Morphological and
semantic regularities in the lexicon,&amp;quot;
Language, 51,639-671.
Jacobs, Paul S. (1986). &amp;quot;Knowledge
structures for natural language
generation.&amp;quot; In COLING-86, 554-559.
Jacobs, Paul S. (1987). &amp;quot;A knowledge
framework for natural language
analysis.&amp;quot; In IJCAI-87, 2,675-678.
Joshi, Aravind; Webber, Bonnie L.; and
Weischedel, Ralph (1984). &amp;quot;Default
reasoning in interaction.&amp;quot; In Proceedings,
AAAI Non-Monotonic Reasoning Workshop,
New York, 144-150.
Kameyarna, Megumi (1988). &amp;quot;Atomization
</reference>
<page confidence="0.999045">
216
</page>
<note confidence="0.997818">
Walter Daelemans et al. Inheritance in Natural Language Processing
</note>
<reference confidence="0.999035131147541">
in grammar sharing.&amp;quot; In ACL Proceedings,
26th Annual Meeting, 194-203.
Kameyama, Megumi; Ochitani, Ryo; and
Peters, Stanley (1991). &amp;quot;Resolving
translation mismatches with information
flow.&amp;quot; In ACL Proceedings, 29th Annual
Meeting, 193-200.
Kaplan, Ronald M. (1987). &amp;quot;Three seductions
of computational psycholinguistics.&amp;quot; In
Linguistic Theory and Computer Applications,
edited by Peter Whitelock, Mary McGee
Wood, Harold L. Somers, Rod L. Johnson,
and Paul Bennett, 149-188. London:
Academic Press.
Karttunen, Lauri (1986). &amp;quot;D-PATR: A
development environment for
unification-based grammars.&amp;quot; In
COLING-86, 74-80.
Kempen, Gerard (1987). &amp;quot;A framework for
incremental syntactic tree formation.&amp;quot; In
IJCAI-87, 2,655-660.
Kilbury, James; Naerger, Petra; and Renz,
Ingrid (1991). &amp;quot;DATR as a lexical
component for PATR&amp;quot; In ACL Proceedings,
5th European Conference, 137-142.
Lascarides, Alex, and Asher, Nicholas
(1991). &amp;quot;Discourse relations and
defeasible knowledge.&amp;quot; In ACL
Proceedings, 29th Annual Meeting, 55-62.
Mercer, Robert E. (1988). &amp;quot;Using default
logic to derive natural language
presuppositions.&amp;quot; In Proceedings, Seventh
Biennial Conference of the CSCSIISCEIO,
14-21.
Mercer, Robert E., and Reiter, Raymond
(1982). &amp;quot;The representation of
presuppositions using defaults.&amp;quot; In
Proceedings, Fourth Biennial Conference of the
CSCSI/SCEIO, 103-107.
Moens, Marc; Calder, Jo; Klein, Ewan;
Reape, Mike; and Zeevat, Henk (1989).
&amp;quot;Expressing generalizations in
unification-based grammar formalisms.&amp;quot;
In ACL Proceedings, 4th European
Conference, 174-181.
Moore, Robert C. (1985). &amp;quot;Semantical
considerations on nonmonotonic logic,&amp;quot;
Artificial Intelligence, 25(1), 75-94.
Perrault, C. Raymond (1990). &amp;quot;An
application of default logic to speech act
theory.&amp;quot; In Intentions in Communication,
edited by Philip Cohen, Jerry Morgan,
and Martha Pollack, 161-185. Cambridge,
MA: The MIT Press.
Pollard, Carl, and Sag, Ivan A. (1987).
Information-Based Syntax and Semantics,
Volume 1. Stanford/Chicago:
CSLI/Chicago University Press.
Porter, Harry H. (1987). &amp;quot;Incorporating
inheritance and feature structures into a
logic grammar formalism.&amp;quot; In ACL
Proceedings, 25th Annual Meeting,
228-234.
Pullum, Geoffrey K. (1979). Rule Interaction
and the Organization of a Grammar. New
York: Garland.
Pustejovsky, James (1989). &amp;quot;Current issues
in computational lexical semantics.&amp;quot; In
ACL Proceedings, Fourth European
Conference, xvii-xxv.
Pustejovsky, James (1991). &amp;quot;The generative
lexicon,&amp;quot; Computational Linguistics, 17(4),
409-441.
Quillian, M. (1968). &amp;quot;Semantic memory.&amp;quot; In
Semantic Information Processing, edited by
Marvin Minsky, 227-270. Cambridge, MA:
The MIT Press.
Reinhard, Sabine (1990).
&amp;quot;Verarbeitungsprobleme nichtlinearer
Morphologien: Umlautbeschreibung in
einem hierarchischen Lexikon,&amp;quot; In Lexikon
und Lexicographie, edited by B. Rieger and
B. Schaeder, 45-61. Hildesheim: Olms
Verlag.
Reinhard, Sabine, and Gibbon, Dafydd
(1991). &amp;quot;Prosodic inheritance and
morphological generalisations,&amp;quot; In
Proceedings, Fifth Conference of the European
Chapter of the Association for Computational
Linguistics, 131-136.
Russell, Graham; Ballim, Afzal; Carroll,
John; and Warwick-Armstrong, Susan (In
press). &amp;quot;A practical approach to multiple
default inheritance for unification-based
lexicons,&amp;quot; Computational Linguistics, 18(3).
Schubert, Lenhart K., and Hwang, Chung
Hee (1989). &amp;quot;An episodic knowledge
representation for narrative texts.&amp;quot; In
Proceedings, First International Conference on
Principles of Knowledge Representation and
Reasoning, 444-458.
Selman, Bart, and Levesque, Hector J.
(1989). &amp;quot;The tractability of path-based
inheritance,&amp;quot; IJCAI-89, 1140-1145.
Shieber, Stuart M. (1986a). &amp;quot;A simple
reconstruction of GPSG.&amp;quot; In COLING-86,
211-215.
Shieber, Stuart M. (1986b). An Introduction to
Unification-Based Approaches to Grammar.
Chicago: University of Chicago Press.
Simmons, Robert F. (1973). &amp;quot;Semantic
networks: Their computation and use for
understanding English sentences.&amp;quot; In
Computer Models of Thought and Language,
edited by Roger C. Schank and Kenneth
M. Colby, 63-113. San Francisco: Freeman.
Smolka, G. (1988). &amp;quot;A feature logic with
subsorts,&amp;quot; LILOG Report 33, IBM
Deutschland, Stuttgart.
Steels, Luc (1978). &amp;quot;Introducing conceptual
grammar,&amp;quot; Working Paper 176, MIT Al
Laboratory, Cambridge, MA.
</reference>
<page confidence="0.943392">
217
</page>
<reference confidence="0.986171325581395">
Computational Linguistics Volume 18, Number 2
Steels, Luc, and De Smedt, Koenraad (1983).
&amp;quot;Some examples of frame-based syntactic
processing.&amp;quot; In Een Spyeghel voor G. Jo
Steenbergen, edited by Fr. Daems and
L. Goossens, 293-305. Leuven: Acco.
Thomason, Richmond H. (1991).
&amp;quot;Inheritance in natural language,&amp;quot;
Unpublished manuscript, Intelligent
Systems Programme, Pittsburgh.
Thomason, Richmond H., and Touretzky,
David S. (1992). &amp;quot;Inheritance theory and
networks with roles.&amp;quot; In Principles of
Semantic Networks: Explorations in the
Representation of Knowledge, edited by John
Sowa, 231-266. San Mateo: Morgan
Kaufmann.
Touretzky, David S. (1986). The Mathematics
of Inheritance Systems. London/Los Altos:
Pitman/Morgan Kaufmann.
Vogel, Carl, and Popowich, Fred (1990).
&amp;quot;Head-driven phrase structure grammar
as an inheritance hierarchy.&amp;quot; In
Proceedings, Workshop on Inheritance in
Natural Language Processing, edited by
Walter Daelemans and Gerald Gazdar,
104-113. ITK, Tilburg.
van der Linden, Erik-Jan (1992).
&amp;quot;Incremental processing and the
hierarchical lexicon,&amp;quot; Computational
Linguistics, 18(2), 219-235.
Weischedel, Ralph M. (1989). &amp;quot;A hybrid
approach to representation in the Janus
natural language processor.&amp;quot; In ACL
Proceedings, 27th Annual Meeting, 193-202.
Whitelock, Peter; McGee Wood, Mary;
Somers, Harold L.; Johnson, Rod L.; and
Bennett, Paul (1987). Linguistic Theory and
Computer Applications. London: Academic
Press.
Zajac, Remi (1992). &amp;quot;Inheritance and
constraint-based grammar formalisms,&amp;quot;
Computational Linguistics, 18(2), 159-182.
</reference>
<page confidence="0.99717">
218
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.671102">
<title confidence="0.990401">Inheritance in Natural Language Processing</title>
<author confidence="0.69422">Walter Daelemans Koenraad De_Smedt</author>
<affiliation confidence="0.826492">Tilburg University University of Nijmegen</affiliation>
<author confidence="0.987897">Gerald Gazdar</author>
<affiliation confidence="0.991367">University of Sussex</affiliation>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Ronald J Brachman</author>
</authors>
<title>The future of knowledge representation,&amp;quot;</title>
<date>1990</date>
<pages>90--1082</pages>
<contexts>
<context position="26866" citStr="Brachman 1990" startWordPosition="4309" endWordPosition="4310">ture of the lexicon per se. In subsequent work, Calder and Bird (1991) use a general 212 Walter Daelemans et al. Inheritance in Natural Language Processing nonmonotonic logic to give a formal reconstruction of &amp;quot;underspecification phonology&amp;quot; (Archangeli 1988).&amp;quot; 4. Semantics and Pragmatics Given that knowledge representation was principally driven by natural language concerns right up to the beginning of the decade, one would have expected substantial progress to have been made in the 1980s on knowledge representation support for natural language semantics. This seems not to have been the case (Brachman 1990; p. 1088). If one compares the progress made in morphology and syntax in NLP in the 1980s, then Brachman&apos;s judgment is surely correct. And yet there has been a steady tradition of using semantic networks in the service of natural language understanding that goes back at least as far as Simmons (1973). Much of the work in this tradition has concerned itself with domain and world knowledge relevant to disambiguation and to drawing inferences from what is said, but not to the semantic representations of words, phrases and utterances per se. Exceptions to this generalization are not hard to find,</context>
</contexts>
<marker>Brachman, 1990</marker>
<rawString>Brachman, Ronald J. (1990). &amp;quot;The future of knowledge representation,&amp;quot; AAAI-90, 1082-1092.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ronald J Brachman</author>
<author>James G Schmolze</author>
</authors>
<title>An overview of the KL-ONE knowledge representation system,&amp;quot;</title>
<date>1985</date>
<journal>Cognitive Science,</journal>
<pages>9--191</pages>
<contexts>
<context position="17024" citStr="Brachman and Schmolze (1985)" startWordPosition="2800" endWordPosition="2803">ons of inheritance to syntax was Bobrow and Webber&apos;s (1980a,b) use of PSI-KLONE (a variant of KL-ONE) to encode ATNs. In the context of RUS, a system for natural language parsing and interpretation, inheritance was used to organize linguistic knowledge efficiently in terms of grammatical categories. This frame-based representation was used by a process called incremental description refinement, which first determined which descriptions were compatible with an object known to have a set of properties, and then refined this set of descriptions as more properties become known. Subsequent work by Brachman and Schmolze (1985) used PSI-KLONE to translate the ouput of the RUS parser into KL-ONE representations of literal meaning. An inheritance network that the authors refer to as a &amp;quot;syntaxonomy&amp;quot; is used to encode information about syntactic categories. A rather similar view of language processing is to be found in the Conceptual Grammar of Steels (1978) and Steels and De Smedt (1983). This approach adopted a single frame-based grammar representation for a variety of language processing tasks and for all types of linguistic knowledge. General inference mechanisms based on constraint propagation used the frames, orga</context>
<context position="24308" citStr="Brachman and Schmolze (1985)" startWordPosition="3923" endWordPosition="3926">sed with any grammar that can be encoded in terms of attributes and values. Kilbury et al. (1991) show how a DATR lexicon can be linked to a PATR syntax, while Andry et al. (in press) employ a DATR lexicon in the context of a Unification Categorial Grammar. The use of DATR to describe morphology is illustrated, for Latin, by Gazdar (in press) and in the fragments of Arabic, English, German, and Japanese included in Evans and Gazdar (1990). All of our discussion thus far has presupposed the use of inheritance networks to store essentially static information. But, following the precedent set by Brachman and Schmolze (1985), a number of researchers have begun to explore their utility in language processing itself. Thus, for example, van der Linden (this issue) exploits the structure of the network in order to avoid premature lexical disambiguation and to identify lexical preferences during incremental parsing with a Lambek categorial grammar. And Vogel and Popowich (1990) add a new twist to the now familiar &amp;quot;parsing as deduction&amp;quot; strategy: instead of construing parsing as, for example, inference in a Horn clause logic, they describe an HPSG parser that operates by means of path-based inference over an inheritanc</context>
</contexts>
<marker>Brachman, Schmolze, 1985</marker>
<rawString>Brachman, Ronald J., and Schmolze, James G. (1985). &amp;quot;An overview of the KL-ONE knowledge representation system,&amp;quot; Cognitive Science, 9,191-216.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ted Briscoe</author>
<author>Ann Copestake</author>
<author>Bran Boguraev</author>
</authors>
<title>Enjoy the paper: Lexical semantics via lexicology.&amp;quot; In</title>
<date>1990</date>
<pages>90--42</pages>
<contexts>
<context position="28873" citStr="Briscoe et al. (1990)" startWordPosition="4618" endWordPosition="4621">in earlier sections are being used for semantic purposes. Thus Fraser and Hudson (this issue) make crucial use of the Word Grammar inheritance network to reconstruct the meanings of various types of constituent (e.g. verb phrases) that cannot be syntactically reconstructed in a dependency grammar. Weischedel (1989) uses the taxonomic language NKL (based on KL-ONE) to express selectional restrictions, while Andry et al. (in press) use DATR for the same purpose. Cahill and Evans (1990) use DATR to build up complex lambda calculus representations in the lexicon of a message understanding system. Briscoe et al. (1990) use a version of PAIR augmented with defeasible templates to implement a default orthogonal inheritance network for a Pustejovskian analysis of metonymic sense extension in lexical semantics (e.g. interpreting the film in Enjoy the film! as watching the film).5 Their approach is further elaborated in Briscoe and Copestake (1991) and Copestake and Briscoe (1991). A semantic analog of the monotonic type hierarchies discussed above in connection with syntax is manifested in the situation theoretic &amp;quot;infon lattices&amp;quot; introduced by Kameyama et al. (1991) to deal with meaning mismatches in machine tr</context>
</contexts>
<marker>Briscoe, Copestake, Boguraev, 1990</marker>
<rawString>Briscoe, Ted; Copestake, Ann; and Boguraev, Bran (1990). &amp;quot;Enjoy the paper: Lexical semantics via lexicology.&amp;quot; In COLING-90,42-47.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ted Briscoe</author>
<author>Ann Copestake</author>
</authors>
<title>Sense extensions as lexical rules.&amp;quot;</title>
<date>1991</date>
<booktitle>In Proceedings of the IJCAI Workshop on Computational Approaches to Non-Literal Language.</booktitle>
<location>Sydney.</location>
<contexts>
<context position="29204" citStr="Briscoe and Copestake (1991)" startWordPosition="4668" endWordPosition="4671">e taxonomic language NKL (based on KL-ONE) to express selectional restrictions, while Andry et al. (in press) use DATR for the same purpose. Cahill and Evans (1990) use DATR to build up complex lambda calculus representations in the lexicon of a message understanding system. Briscoe et al. (1990) use a version of PAIR augmented with defeasible templates to implement a default orthogonal inheritance network for a Pustejovskian analysis of metonymic sense extension in lexical semantics (e.g. interpreting the film in Enjoy the film! as watching the film).5 Their approach is further elaborated in Briscoe and Copestake (1991) and Copestake and Briscoe (1991). A semantic analog of the monotonic type hierarchies discussed above in connection with syntax is manifested in the situation theoretic &amp;quot;infon lattices&amp;quot; introduced by Kameyama et al. (1991) to deal with meaning mismatches in machine translation. The use of inheritance networks for specifically linguistic pragmatic purposes (as opposed to general reasoning) is notable largely for its absence. The only example we know of is Etherington et al.&apos;s (1989) proposal to represent the consequences of Gricean 4 Compare Gibbon&apos;s (1990a) use of DATR to the same end. 5 See </context>
</contexts>
<marker>Briscoe, Copestake, 1991</marker>
<rawString>Briscoe, Ted, and Copestake, Ann (1991). &amp;quot;Sense extensions as lexical rules.&amp;quot; In Proceedings of the IJCAI Workshop on Computational Approaches to Non-Literal Language. Sydney.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lynne Cahill</author>
<author>Roger Evans</author>
</authors>
<title>An application of DATR: the TIC lexicon,&amp;quot; ECAI-90,</title>
<date>1990</date>
<pages>120--125</pages>
<contexts>
<context position="28740" citStr="Cahill and Evans (1990)" startWordPosition="4596" endWordPosition="4599">-ONE derivative called SB-ONE. Several of the inheritance-based linguistic knowledge representation formalisms that we have introduced in earlier sections are being used for semantic purposes. Thus Fraser and Hudson (this issue) make crucial use of the Word Grammar inheritance network to reconstruct the meanings of various types of constituent (e.g. verb phrases) that cannot be syntactically reconstructed in a dependency grammar. Weischedel (1989) uses the taxonomic language NKL (based on KL-ONE) to express selectional restrictions, while Andry et al. (in press) use DATR for the same purpose. Cahill and Evans (1990) use DATR to build up complex lambda calculus representations in the lexicon of a message understanding system. Briscoe et al. (1990) use a version of PAIR augmented with defeasible templates to implement a default orthogonal inheritance network for a Pustejovskian analysis of metonymic sense extension in lexical semantics (e.g. interpreting the film in Enjoy the film! as watching the film).5 Their approach is further elaborated in Briscoe and Copestake (1991) and Copestake and Briscoe (1991). A semantic analog of the monotonic type hierarchies discussed above in connection with syntax is mani</context>
</contexts>
<marker>Cahill, Evans, 1990</marker>
<rawString>Cahill, Lynne, and Evans, Roger (1990). &amp;quot;An application of DATR: the TIC lexicon,&amp;quot; ECAI-90, 120-125.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jo Calder</author>
</authors>
<title>Paradigmatic morphology.&amp;quot;</title>
<date>1989</date>
<booktitle>In ACL Proceedings, Fourth European Conference,</booktitle>
<pages>58--65</pages>
<contexts>
<context position="25900" citStr="Calder (1989)" startWordPosition="4163" endWordPosition="4164">e made extensive use of DATR networks to describe lexical morphophonological phenomena such as German umlaut, Kikuyu tone, and Arabic vowel intercalation (Gibbon 1990b, in press; Reinhard 1990; Reinhard and Gibbon 1991). And Daelemans (1987a,b, 1988) uses the object-oriented knowledge representation language KRS to implement default orthogonal inheritance networks for the lexical representation of phonological, orthographic, and morphological knowledge of Dutch and shows how such a lexicon architecture can be used for both language generation and automatic dictionary construction. The work of Calder (1989) and his associates at Edinburgh and Stuttgart on &amp;quot;paradigmatic morphology&amp;quot; also fits within this tradition in that it invokes a restricted kind of default orthogonal inheritance for morphophonological description. However, the emphasis in this work is on the use of string unification to define morphological operations rather than on the default structure of the lexicon per se. In subsequent work, Calder and Bird (1991) use a general 212 Walter Daelemans et al. Inheritance in Natural Language Processing nonmonotonic logic to give a formal reconstruction of &amp;quot;underspecification phonology&amp;quot; (Archa</context>
</contexts>
<marker>Calder, 1989</marker>
<rawString>Calder, Jo (1989). &amp;quot;Paradigmatic morphology.&amp;quot; In ACL Proceedings, Fourth European Conference, 58-65.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jo Calder</author>
<author>Steven Bird</author>
</authors>
<title>Defaults in underspecification phonology&amp;quot; In Default Logics for Linguistic Analysis, edited by Hans</title>
<date>1991</date>
<booktitle>Kamp, 129-139, DYANA, ESPRIT deliverable R2.5.B,</booktitle>
<location>Edinburgh.</location>
<contexts>
<context position="26323" citStr="Calder and Bird (1991)" startWordPosition="4226" endWordPosition="4229"> orthographic, and morphological knowledge of Dutch and shows how such a lexicon architecture can be used for both language generation and automatic dictionary construction. The work of Calder (1989) and his associates at Edinburgh and Stuttgart on &amp;quot;paradigmatic morphology&amp;quot; also fits within this tradition in that it invokes a restricted kind of default orthogonal inheritance for morphophonological description. However, the emphasis in this work is on the use of string unification to define morphological operations rather than on the default structure of the lexicon per se. In subsequent work, Calder and Bird (1991) use a general 212 Walter Daelemans et al. Inheritance in Natural Language Processing nonmonotonic logic to give a formal reconstruction of &amp;quot;underspecification phonology&amp;quot; (Archangeli 1988).&amp;quot; 4. Semantics and Pragmatics Given that knowledge representation was principally driven by natural language concerns right up to the beginning of the decade, one would have expected substantial progress to have been made in the 1980s on knowledge representation support for natural language semantics. This seems not to have been the case (Brachman 1990; p. 1088). If one compares the progress made in morpholo</context>
</contexts>
<marker>Calder, Bird, 1991</marker>
<rawString>Calder, Jo, and Bird, Steven (1991). &amp;quot;Defaults in underspecification phonology&amp;quot; In Default Logics for Linguistic Analysis, edited by Hans Kamp, 129-139, DYANA, ESPRIT deliverable R2.5.B, Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Luca Cardelli</author>
</authors>
<title>A semantics of multiple inheritance.&amp;quot; In Semantics of Data Types,</title>
<date>1984</date>
<pages>51--67</pages>
<publisher>Springer.</publisher>
<location>New York:</location>
<note>edited by</note>
<contexts>
<context position="13332" citStr="Cardelli (1984)" startWordPosition="2226" endWordPosition="2227">m three rather separate traditions. The first is that of &amp;quot;semantic nets&amp;quot; in Al, which goes back to Quillian (1968) through Fahlman&apos;s (1979) NETL to the late 1980s monographs by Touretzky (1986) and Etherington (1988). The second is that of data abstraction in programming languages, which has led to (a) object-orientation in computer science with its notions of classes and inheritance as embodied in such languages as Smalltalk, Simula, Flavors, CLOS and C++, and (b) the use of type hierarchies, which have become widely seen in unification-oriented NLP since the appearance of AR-Kaci (1984) and Cardelli (1984). Of necessity, the type hierarchy work in NLP has remained strictly monotonic. The third is the notion of &amp;quot;markedness&amp;quot; in linguistics, which originates in the Prague School phonology of the 1930s, reappears in the &amp;quot;generative phonology&amp;quot; of Chomsky and Halle (1968) and Hetzron&apos;s (1975) and Jackendoff&apos;s (1975) models of the lexicon, and shows up in syntax in the &amp;quot;feature specification defaults&amp;quot; of Gazdar, Klein, Pullum, and Sag (1985).2 Unlike the other three traditions, the linguistic tradition does not embody a notion of inheritance per se. But the issue of how to decide which operations take</context>
</contexts>
<marker>Cardelli, 1984</marker>
<rawString>Cardelli, Luca (1984). &amp;quot;A semantics of multiple inheritance.&amp;quot; In Semantics of Data Types, edited by G. Kahn, D. B. McQueen, and G. Plotkin, 51-67. New York: Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bob Carpenter</author>
<author>Carl Pollard</author>
</authors>
<title>Inclusion, disjointness, and choice: The logic of linguistic classification.&amp;quot;</title>
<date>1991</date>
<booktitle>In ACL Proceedings, 29th Annual Meeting,</booktitle>
<pages>9--16</pages>
<contexts>
<context position="21380" citStr="Carpenter and Pollard (1991)" startWordPosition="3459" endWordPosition="3462">nne (in press) extend the analysis further still so as to encompass some of the trickiest and most-debated data in the syntax of English. Pollard and Sag (1987), in the first book-length presentation of HPSG, treat the lexicon as a monotonic multiple-inheritance type hierarchy. They implicitly reject the use of an &amp;quot;overriding mechanism&amp;quot; (p. 194, n4) in favor of a variety of restrictions designed to prevent overgeneration, together with a nonmonotonic formulation of lexical rules (pp. 212-213). A concern to preserve monotonic inheritance in HPSG is likewise evident in more recent work, such as Carpenter and Pollard (1991) and Zajac (this issue). Monotonic multiple inheritance type hierarchies figure in a good deal of recent work in unification-based grammars. Examples include papers by Porter (1987), Emele and Zajac (1990), and Emele et al. (1990), who all use a semantics based on Ait-Kaci (1984); the use of sorts in Unification Categorial Grammar (Moens et al. 1989); the CLE project (Alshawi et al. 1989) and theoretical work by Smolka (1988). Default multiple inheritance also figures centrally in a couple of grammatical frameworks. One is Hudson&apos;s (1984,1990) Word Grammar, and a detailed exposition is provide</context>
</contexts>
<marker>Carpenter, Pollard, 1991</marker>
<rawString>Carpenter, Bob, and Pollard, Carl (1991) &amp;quot;Inclusion, disjointness, and choice: The logic of linguistic classification.&amp;quot; In ACL Proceedings, 29th Annual Meeting, 9-16.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Noam Chomsky</author>
<author>Morris Halle</author>
</authors>
<title>The Sound Pattern of English.</title>
<date>1968</date>
<location>New York: Harper and Row.</location>
<contexts>
<context position="13597" citStr="Chomsky and Halle (1968)" startWordPosition="2265" endWordPosition="2268"> in programming languages, which has led to (a) object-orientation in computer science with its notions of classes and inheritance as embodied in such languages as Smalltalk, Simula, Flavors, CLOS and C++, and (b) the use of type hierarchies, which have become widely seen in unification-oriented NLP since the appearance of AR-Kaci (1984) and Cardelli (1984). Of necessity, the type hierarchy work in NLP has remained strictly monotonic. The third is the notion of &amp;quot;markedness&amp;quot; in linguistics, which originates in the Prague School phonology of the 1930s, reappears in the &amp;quot;generative phonology&amp;quot; of Chomsky and Halle (1968) and Hetzron&apos;s (1975) and Jackendoff&apos;s (1975) models of the lexicon, and shows up in syntax in the &amp;quot;feature specification defaults&amp;quot; of Gazdar, Klein, Pullum, and Sag (1985).2 Unlike the other three traditions, the linguistic tradition does not embody a notion of inheritance per se. But the issue of how to decide which operations take precedence over others has been a continuing concern in the literature (see, e.g., Pullum 1979, especially Section 1.4.1, and references therein). The consensus view, though largely unspoken, among computational linguists currently working with default inheritance</context>
</contexts>
<marker>Chomsky, Halle, 1968</marker>
<rawString>Chomsky, Noam, and Halle, Morris (1968). The Sound Pattern of English. New York: Harper and Row.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ann Copestake</author>
<author>Ted Briscoe</author>
</authors>
<title>Lexical operations in a unification-based framework.&amp;quot;</title>
<date>1991</date>
<booktitle>In Proceedings, ACL-SIGLEX Workshop on Lexical Semantics and Knowledge Representation,</booktitle>
<location>Berkeley,</location>
<contexts>
<context position="29237" citStr="Copestake and Briscoe (1991)" startWordPosition="4673" endWordPosition="4676">n KL-ONE) to express selectional restrictions, while Andry et al. (in press) use DATR for the same purpose. Cahill and Evans (1990) use DATR to build up complex lambda calculus representations in the lexicon of a message understanding system. Briscoe et al. (1990) use a version of PAIR augmented with defeasible templates to implement a default orthogonal inheritance network for a Pustejovskian analysis of metonymic sense extension in lexical semantics (e.g. interpreting the film in Enjoy the film! as watching the film).5 Their approach is further elaborated in Briscoe and Copestake (1991) and Copestake and Briscoe (1991). A semantic analog of the monotonic type hierarchies discussed above in connection with syntax is manifested in the situation theoretic &amp;quot;infon lattices&amp;quot; introduced by Kameyama et al. (1991) to deal with meaning mismatches in machine translation. The use of inheritance networks for specifically linguistic pragmatic purposes (as opposed to general reasoning) is notable largely for its absence. The only example we know of is Etherington et al.&apos;s (1989) proposal to represent the consequences of Gricean 4 Compare Gibbon&apos;s (1990a) use of DATR to the same end. 5 See Pustejovsky (1989, 1991). 213 Com</context>
</contexts>
<marker>Copestake, Briscoe, 1991</marker>
<rawString>Copestake, Ann, and Briscoe, Ted (1991). &amp;quot;Lexical operations in a unification-based framework.&amp;quot; In Proceedings, ACL-SIGLEX Workshop on Lexical Semantics and Knowledge Representation, Berkeley, 188-197.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Walter M P Daelemans</author>
</authors>
<title>A tool for the automatic creation, extension and updating of lexical knowledge bases.&amp;quot;</title>
<date>1987</date>
<booktitle>In ACL Proceedings, 3rd European Conference,</booktitle>
<pages>70--74</pages>
<contexts>
<context position="25527" citStr="Daelemans (1987" startWordPosition="4113" endWordPosition="4114">twork. 3. Phonology, Orthography, and Morphophonology Computational phonology is perhaps the youngest and least studied branch of NLP. But notions of default have played such a prominent role in linguistic discussion of the area that it is not surprising that default inheritance networks have found a place in this subfield right from the start. Thus Gibbon and Reinhard have made extensive use of DATR networks to describe lexical morphophonological phenomena such as German umlaut, Kikuyu tone, and Arabic vowel intercalation (Gibbon 1990b, in press; Reinhard 1990; Reinhard and Gibbon 1991). And Daelemans (1987a,b, 1988) uses the object-oriented knowledge representation language KRS to implement default orthogonal inheritance networks for the lexical representation of phonological, orthographic, and morphological knowledge of Dutch and shows how such a lexicon architecture can be used for both language generation and automatic dictionary construction. The work of Calder (1989) and his associates at Edinburgh and Stuttgart on &amp;quot;paradigmatic morphology&amp;quot; also fits within this tradition in that it invokes a restricted kind of default orthogonal inheritance for morphophonological description. However, the</context>
</contexts>
<marker>Daelemans, 1987</marker>
<rawString>Daelemans, Walter M. P. (1987a). &amp;quot;A tool for the automatic creation, extension and updating of lexical knowledge bases.&amp;quot; In ACL Proceedings, 3rd European Conference, 70-74.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Walter M P Daelemans</author>
</authors>
<title>Studies in language technology: An object-oriented computer model of morpho phonological aspects of</title>
<date>1987</date>
<institution>Dutch. University of Leuven.</institution>
<note>Doctoral dissertation.</note>
<contexts>
<context position="25527" citStr="Daelemans (1987" startWordPosition="4113" endWordPosition="4114">twork. 3. Phonology, Orthography, and Morphophonology Computational phonology is perhaps the youngest and least studied branch of NLP. But notions of default have played such a prominent role in linguistic discussion of the area that it is not surprising that default inheritance networks have found a place in this subfield right from the start. Thus Gibbon and Reinhard have made extensive use of DATR networks to describe lexical morphophonological phenomena such as German umlaut, Kikuyu tone, and Arabic vowel intercalation (Gibbon 1990b, in press; Reinhard 1990; Reinhard and Gibbon 1991). And Daelemans (1987a,b, 1988) uses the object-oriented knowledge representation language KRS to implement default orthogonal inheritance networks for the lexical representation of phonological, orthographic, and morphological knowledge of Dutch and shows how such a lexicon architecture can be used for both language generation and automatic dictionary construction. The work of Calder (1989) and his associates at Edinburgh and Stuttgart on &amp;quot;paradigmatic morphology&amp;quot; also fits within this tradition in that it invokes a restricted kind of default orthogonal inheritance for morphophonological description. However, the</context>
</contexts>
<marker>Daelemans, 1987</marker>
<rawString>Daelemans, Walter M. P. (1987b). Studies in language technology: An object-oriented computer model of morpho phonological aspects of Dutch. University of Leuven. Doctoral dissertation.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Walter M P Daelemans</author>
</authors>
<title>A model of Dutch morphophonology and its applications,&amp;quot;</title>
<date>1988</date>
<journal>Al Communications,</journal>
<volume>1</volume>
<issue>2</issue>
<pages>18--25</pages>
<marker>Daelemans, 1988</marker>
<rawString>Daelemans, Walter M. P. (1988). &amp;quot;A model of Dutch morphophonology and its applications,&amp;quot; Al Communications, 1(2), 18-25.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Koenraad De Smedt</author>
</authors>
<title>Using object-oriented knowledge-representation techniques in morphology and syntax programming,&amp;quot;</title>
<date>1984</date>
<pages>84--181</pages>
<marker>De Smedt, 1984</marker>
<rawString>De Smedt, Koenraad (1984). &amp;quot;Using object-oriented knowledge-representation techniques in morphology and syntax programming,&amp;quot; ECAI-84, 181-184.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Koenraad De Smedt</author>
<author>de Graaf</author>
</authors>
<title>Structured inheritance in frame-based representation of linguistic categories.&amp;quot;</title>
<date>1990</date>
<booktitle>In Proceedings of the Workshop on Inheritance in Natural Language Processing, edited by Walter Daelemans and Gerald Gazdar,</booktitle>
<pages>39--47</pages>
<publisher>ITK.</publisher>
<location>Tilburg, The Netherlands:</location>
<marker>De Smedt, de Graaf, 1990</marker>
<rawString>De Smedt, Koenraad, and de Graaf, Josje (1990). &amp;quot;Structured inheritance in frame-based representation of linguistic categories.&amp;quot; In Proceedings of the Workshop on Inheritance in Natural Language Processing, edited by Walter Daelemans and Gerald Gazdar, 39-47. Tilburg, The Netherlands: ITK.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Martin C Emele</author>
<author>Remi Zajac</author>
</authors>
<title>Typed unification grammars.&amp;quot;</title>
<date>1990</date>
<booktitle>In COLING-90,</booktitle>
<pages>293--298</pages>
<contexts>
<context position="21585" citStr="Emele and Zajac (1990)" startWordPosition="3489" endWordPosition="3492">eat the lexicon as a monotonic multiple-inheritance type hierarchy. They implicitly reject the use of an &amp;quot;overriding mechanism&amp;quot; (p. 194, n4) in favor of a variety of restrictions designed to prevent overgeneration, together with a nonmonotonic formulation of lexical rules (pp. 212-213). A concern to preserve monotonic inheritance in HPSG is likewise evident in more recent work, such as Carpenter and Pollard (1991) and Zajac (this issue). Monotonic multiple inheritance type hierarchies figure in a good deal of recent work in unification-based grammars. Examples include papers by Porter (1987), Emele and Zajac (1990), and Emele et al. (1990), who all use a semantics based on Ait-Kaci (1984); the use of sorts in Unification Categorial Grammar (Moens et al. 1989); the CLE project (Alshawi et al. 1989) and theoretical work by Smolka (1988). Default multiple inheritance also figures centrally in a couple of grammatical frameworks. One is Hudson&apos;s (1984,1990) Word Grammar, and a detailed exposition is provided by Fraser and Hudson in this issue. Word Grammar is a feature-based variant of dependency grammar, one that makes pervasive use of a (multiple) inheritance relation. The latter is unusual in that stipula</context>
</contexts>
<marker>Emele, Zajac, 1990</marker>
<rawString>Emele, Martin C., and Zajac, Remi (1990). &amp;quot;Typed unification grammars.&amp;quot; In COLING-90, 293-298.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Martin C Emele</author>
<author>Ulrich Heid</author>
<author>Stefan Momma</author>
<author>Remi Zajac</author>
</authors>
<title>Organizing linguistic knowledge for multilingual generation.&amp;quot; In</title>
<date>1990</date>
<booktitle>COLING-90,</booktitle>
<pages>102--107</pages>
<contexts>
<context position="21610" citStr="Emele et al. (1990)" startWordPosition="3494" endWordPosition="3497">ic multiple-inheritance type hierarchy. They implicitly reject the use of an &amp;quot;overriding mechanism&amp;quot; (p. 194, n4) in favor of a variety of restrictions designed to prevent overgeneration, together with a nonmonotonic formulation of lexical rules (pp. 212-213). A concern to preserve monotonic inheritance in HPSG is likewise evident in more recent work, such as Carpenter and Pollard (1991) and Zajac (this issue). Monotonic multiple inheritance type hierarchies figure in a good deal of recent work in unification-based grammars. Examples include papers by Porter (1987), Emele and Zajac (1990), and Emele et al. (1990), who all use a semantics based on Ait-Kaci (1984); the use of sorts in Unification Categorial Grammar (Moens et al. 1989); the CLE project (Alshawi et al. 1989) and theoretical work by Smolka (1988). Default multiple inheritance also figures centrally in a couple of grammatical frameworks. One is Hudson&apos;s (1984,1990) Word Grammar, and a detailed exposition is provided by Fraser and Hudson in this issue. Word Grammar is a feature-based variant of dependency grammar, one that makes pervasive use of a (multiple) inheritance relation. The latter is unusual in that stipulated exceptions do not aut</context>
</contexts>
<marker>Emele, Heid, Momma, Zajac, 1990</marker>
<rawString>Emele, Martin C.; Heid, Ulrich; Momma, Stefan; and Zajac, Remi (1990). &amp;quot;Organizing linguistic knowledge for multilingual generation.&amp;quot; In COLING-90, 102-107.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David W Etherington</author>
</authors>
<title>Reasoning with Incomplete Information. London/Los Altos:</title>
<date>1988</date>
<publisher>Pitman/Morgan Kaufmann.</publisher>
<contexts>
<context position="12933" citStr="Etherington (1988)" startWordPosition="2164" endWordPosition="2165">d on top of each other. On another strategy, a given property, or set of properties, may potentially be inherited from more than one parent node, but the parents are ordered: the first parent in the ordering that is able to supply the property wins, and contradiction is thus avoided. We will refer to this strategy as &amp;quot;prioritized inheritance.&amp;quot; The use of inheritance networks in current NLP comes from three rather separate traditions. The first is that of &amp;quot;semantic nets&amp;quot; in Al, which goes back to Quillian (1968) through Fahlman&apos;s (1979) NETL to the late 1980s monographs by Touretzky (1986) and Etherington (1988). The second is that of data abstraction in programming languages, which has led to (a) object-orientation in computer science with its notions of classes and inheritance as embodied in such languages as Smalltalk, Simula, Flavors, CLOS and C++, and (b) the use of type hierarchies, which have become widely seen in unification-oriented NLP since the appearance of AR-Kaci (1984) and Cardelli (1984). Of necessity, the type hierarchy work in NLP has remained strictly monotonic. The third is the notion of &amp;quot;markedness&amp;quot; in linguistics, which originates in the Prague School phonology of the 1930s, rea</context>
</contexts>
<marker>Etherington, 1988</marker>
<rawString>Etherington, David W. (1988). Reasoning with Incomplete Information. London/Los Altos: Pitman/Morgan Kaufmann.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David W Etherington</author>
<author>Alex Borgida</author>
<author>Ronald J Brachman</author>
<author>Henry Kautz</author>
</authors>
<title>Vivid knowledge and tractable reasoning: preliminary report,&amp;quot;</title>
<date>1989</date>
<booktitle>IJCAI-89,</booktitle>
<pages>1146--1152</pages>
<marker>Etherington, Borgida, Brachman, Kautz, 1989</marker>
<rawString>Etherington, David W.; Borgida, Alex; Brachman, Ronald J.; and Kautz, Henry (1989). &amp;quot;Vivid knowledge and tractable reasoning: preliminary report,&amp;quot; IJCAI-89, 1146-1152.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Roger Evans</author>
</authors>
<title>Towards a formal specification for defaults in GPSG.&amp;quot;</title>
<date>1987</date>
<booktitle>In Proceedings, Workshop on Natural Language Processing, Unification, and Grammar Formalisms, University of Stirling,</booktitle>
<pages>3--8</pages>
<contexts>
<context position="14515" citStr="Evans (1987)" startWordPosition="2408" endWordPosition="2409"> decide which operations take precedence over others has been a continuing concern in the literature (see, e.g., Pullum 1979, especially Section 1.4.1, and references therein). The consensus view, though largely unspoken, among computational linguists currently working with default inheritance networks appears to be that nodes that are close (or identical) to the root(s) of the network should be used to encode that which is regular, &amp;quot;unmarked,&amp;quot; and productive, and that distance from the root(s) should correlate with increasing irregularity, &amp;quot;markedness,&amp;quot; and lack of productivity. At the 2 See Evans (1987), Gazdar (1987), and Shieber (1986a) on the various defaulty characteristics of GPSG. 209 Computational Linguistics Volume 18, Number 2 very least, this is what emerges from their practice. T he differences between the current strands of NLP work in this area are partly philosophical (e.g., as to whether psycholinguistic data could or should be relevant to the structure of the network), partly methodological (e.g., as to whether networks should be built in a formal language designed for the purpose or implemented in an existing computer language), partly technical (e.g., whether a negation ope</context>
</contexts>
<marker>Evans, 1987</marker>
<rawString>Evans, Roger (1987). &amp;quot;Towards a formal specification for defaults in GPSG.&amp;quot; In Proceedings, Workshop on Natural Language Processing, Unification, and Grammar Formalisms, University of Stirling, 3-8.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Roger Evans</author>
<author>Gerald Gazdar</author>
</authors>
<title>Inference in DATR.&amp;quot;</title>
<date>1989</date>
<booktitle>In ACL Proceedings, 4th European Conference,</booktitle>
<pages>66--71</pages>
<contexts>
<context position="23086" citStr="Evans and Gazdar (1989" startWordPosition="3719" endWordPosition="3722">y means that the corresponding regular form is not a permissible option. This is known as -blocking.&amp;quot; 211 Computational Linguistics Volume 18, Number 2 The other is ELU (Russell et al. in press), which extends a PATR-like grammar formalism with a language for defining default multiple inheritance networks for the lexicon. Inspired by CLOS, an object-oriented extension of Common LISP, they adopt prioritized inheritance to escape the problem caused by conflicting inherited information. Russell et al. (in press) illustrate their approach with ELU analyses of English and German verbal morphology. Evans and Gazdar (1989a) outline the syntax and theory of inference for DATR, a language for lexical knowledge representation, and (1989b) they provide a semantics for the language that is loosely based on the approach taken by Moore (1985) in his semantics for autoepistemic logic. DATR allows multiple default inheritance but enforces orthogonality. Evans et al. (in press) show how DATR can also be used to encode certain kinds of prioritized inheritance. Unlike ELU and the Word Grammar notation, DATR is not intended to be a full grammar formalism. Rather, it is intended to be a lexical formalism that can be used wi</context>
</contexts>
<marker>Evans, Gazdar, 1989</marker>
<rawString>Evans, Roger, and Gazdar, Gerald (1989a). &amp;quot;Inference in DATR.&amp;quot; In ACL Proceedings, 4th European Conference, 66-71.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Roger Evans</author>
<author>Gerald Gazdar</author>
</authors>
<title>The semantics of DATR.&amp;quot;</title>
<date>1989</date>
<booktitle>In Proceedings, Seventh Conference of the Society for the Study of Artificial Intelligence and Simulation of Behaviour, edited by</booktitle>
<pages>79--87</pages>
<contexts>
<context position="23086" citStr="Evans and Gazdar (1989" startWordPosition="3719" endWordPosition="3722">y means that the corresponding regular form is not a permissible option. This is known as -blocking.&amp;quot; 211 Computational Linguistics Volume 18, Number 2 The other is ELU (Russell et al. in press), which extends a PATR-like grammar formalism with a language for defining default multiple inheritance networks for the lexicon. Inspired by CLOS, an object-oriented extension of Common LISP, they adopt prioritized inheritance to escape the problem caused by conflicting inherited information. Russell et al. (in press) illustrate their approach with ELU analyses of English and German verbal morphology. Evans and Gazdar (1989a) outline the syntax and theory of inference for DATR, a language for lexical knowledge representation, and (1989b) they provide a semantics for the language that is loosely based on the approach taken by Moore (1985) in his semantics for autoepistemic logic. DATR allows multiple default inheritance but enforces orthogonality. Evans et al. (in press) show how DATR can also be used to encode certain kinds of prioritized inheritance. Unlike ELU and the Word Grammar notation, DATR is not intended to be a full grammar formalism. Rather, it is intended to be a lexical formalism that can be used wi</context>
</contexts>
<marker>Evans, Gazdar, 1989</marker>
<rawString>Evans, Roger, and Gazdar, Gerald (1989b). &amp;quot;The semantics of DATR.&amp;quot; In Proceedings, Seventh Conference of the Society for the Study of Artificial Intelligence and Simulation of Behaviour, edited by Anthony G. Cohn, 79-87.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Roger Evans</author>
<author>Gerald Gazdar</author>
</authors>
<title>The DATR Papers, Volume 1,&amp;quot;</title>
<date>1990</date>
<booktitle>Cognitive Science Research Paper CSRP 139,</booktitle>
<institution>University of Sussex,</institution>
<location>Brighton.</location>
<contexts>
<context position="24122" citStr="Evans and Gazdar (1990)" startWordPosition="3895" endWordPosition="3898">rioritized inheritance. Unlike ELU and the Word Grammar notation, DATR is not intended to be a full grammar formalism. Rather, it is intended to be a lexical formalism that can be used with any grammar that can be encoded in terms of attributes and values. Kilbury et al. (1991) show how a DATR lexicon can be linked to a PATR syntax, while Andry et al. (in press) employ a DATR lexicon in the context of a Unification Categorial Grammar. The use of DATR to describe morphology is illustrated, for Latin, by Gazdar (in press) and in the fragments of Arabic, English, German, and Japanese included in Evans and Gazdar (1990). All of our discussion thus far has presupposed the use of inheritance networks to store essentially static information. But, following the precedent set by Brachman and Schmolze (1985), a number of researchers have begun to explore their utility in language processing itself. Thus, for example, van der Linden (this issue) exploits the structure of the network in order to avoid premature lexical disambiguation and to identify lexical preferences during incremental parsing with a Lambek categorial grammar. And Vogel and Popowich (1990) add a new twist to the now familiar &amp;quot;parsing as deduction&amp;quot;</context>
</contexts>
<marker>Evans, Gazdar, 1990</marker>
<rawString>Evans, Roger, and Gazdar, Gerald (1990). &amp;quot;The DATR Papers, Volume 1,&amp;quot; Cognitive Science Research Paper CSRP 139, University of Sussex, Brighton.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Roger Evans</author>
<author>Gerald Gazdar</author>
<author>Moser</author>
</authors>
<title>Lionel (In press). &amp;quot;Prioritised multiple inheritance in DATR.&amp;quot;</title>
<booktitle>In Default Inheritance in the Lexicon, edited by Ted Briscoe, Ann Copestake, and Valeria</booktitle>
<publisher>Cambridge University Press.</publisher>
<marker>Evans, Gazdar, Moser, </marker>
<rawString>Evans, Roger; Gazdar, Gerald; and Moser, Lionel (In press). &amp;quot;Prioritised multiple inheritance in DATR.&amp;quot; In Default Inheritance in the Lexicon, edited by Ted Briscoe, Ann Copestake, and Valeria de Paiva. Cambridge: Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Scott Fahlman</author>
</authors>
<title>NETL: A System for Representing and Using Real-World Knowledge.</title>
<date>1979</date>
<publisher>The MIT Press.</publisher>
<location>Cambridge, MA:</location>
<marker>Fahlman, 1979</marker>
<rawString>Fahlman, Scott (1979). NETL: A System for Representing and Using Real-World Knowledge. Cambridge, MA: The MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Daniel P Flickinger</author>
<author>Carl J Pollard</author>
<author>Thomas Wasow</author>
</authors>
<title>Structure-sharing in lexical representation.&amp;quot;</title>
<date>1985</date>
<booktitle>In ACL Proceedings, 23rd Annual Meeting,</booktitle>
<pages>262--267</pages>
<marker>Flickinger, Pollard, Wasow, 1985</marker>
<rawString>Flickinger, Daniel P.; Pollard, Carl J.; and Wasow, Thomas (1985). &amp;quot;Structure-sharing in lexical representation.&amp;quot; In ACL Proceedings, 23rd Annual Meeting, 262-267.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Daniel P Flickinger</author>
</authors>
<title>Lexical Rules in the Hierarchical Lexicon. Doctoral dissertation,</title>
<date>1987</date>
<institution>Stanford University.</institution>
<marker>Flickinger, 1987</marker>
<rawString>Flickinger, Daniel P. (1987). Lexical Rules in the Hierarchical Lexicon. Doctoral dissertation, Stanford University.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Daniel P Flickinger</author>
<author>John Nerbonne</author>
</authors>
<title>Inheritance and complementation: A case study of easy adjectives and related nouns,&amp;quot;</title>
<journal>Computational Linguistics,</journal>
<volume>18</volume>
<issue>3</issue>
<marker>Flickinger, Nerbonne, </marker>
<rawString>Flickinger, Daniel P., and Nerbonne, John (In press). &amp;quot;Inheritance and complementation: A case study of easy adjectives and related nouns,&amp;quot; Computational Linguistics, 18(3).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Norman M Fraser</author>
<author>Richard A Hudson</author>
</authors>
<title>Inheritance in word grammar,&amp;quot;</title>
<date>1992</date>
<journal>Computational Linguistics,</journal>
<volume>18</volume>
<issue>2</issue>
<pages>133--158</pages>
<marker>Fraser, Hudson, 1992</marker>
<rawString>Fraser, Norman M., and Hudson, Richard A. (1992). &amp;quot;Inheritance in word grammar,&amp;quot; Computational Linguistics, 18(2), 133-158.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gerald Gazdar</author>
</authors>
<title>Linguistic applications of default inheritance mechanisms.&amp;quot; In Linguistic Theory and Computer Applications, edited by Peter Whitelock,</title>
<date>1987</date>
<pages>37--67</pages>
<publisher>Academic Press.</publisher>
<location>Mary McGee</location>
<contexts>
<context position="14530" citStr="Gazdar (1987)" startWordPosition="2410" endWordPosition="2411">operations take precedence over others has been a continuing concern in the literature (see, e.g., Pullum 1979, especially Section 1.4.1, and references therein). The consensus view, though largely unspoken, among computational linguists currently working with default inheritance networks appears to be that nodes that are close (or identical) to the root(s) of the network should be used to encode that which is regular, &amp;quot;unmarked,&amp;quot; and productive, and that distance from the root(s) should correlate with increasing irregularity, &amp;quot;markedness,&amp;quot; and lack of productivity. At the 2 See Evans (1987), Gazdar (1987), and Shieber (1986a) on the various defaulty characteristics of GPSG. 209 Computational Linguistics Volume 18, Number 2 very least, this is what emerges from their practice. T he differences between the current strands of NLP work in this area are partly philosophical (e.g., as to whether psycholinguistic data could or should be relevant to the structure of the network), partly methodological (e.g., as to whether networks should be built in a formal language designed for the purpose or implemented in an existing computer language), partly technical (e.g., whether a negation operator is useful</context>
</contexts>
<marker>Gazdar, 1987</marker>
<rawString>Gazdar, Gerald (1987). &amp;quot;Linguistic applications of default inheritance mechanisms.&amp;quot; In Linguistic Theory and Computer Applications, edited by Peter Whitelock, Mary McGee Wood, Harold L. Somers, Rod L. Johnson, and Paul Bennett, 37-67, London: Academic Press.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Gerald Gazdar</author>
</authors>
<title>(In press). &amp;quot;Ceteris paribus.&amp;quot; In Aspects of Computational Linguistics: Syntax, Semantics, Phonetics, edited by Christian Rohrer and Hans Kamp.</title>
<publisher>Springer-Verlag.</publisher>
<location>Berlin:</location>
<marker>Gazdar, </marker>
<rawString>Gazdar, Gerald (In press). &amp;quot;Ceteris paribus.&amp;quot; In Aspects of Computational Linguistics: Syntax, Semantics, Phonetics, edited by Christian Rohrer and Hans Kamp. Berlin: Springer-Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gerald Gazdar</author>
<author>Ewan Klein</author>
<author>Geoffrey K Pullum</author>
<author>Ivan A Sag</author>
</authors>
<title>Generalized Phrase Structure Grammar,</title>
<date>1985</date>
<publisher>Blackwell/Harvard.</publisher>
<location>Oxford /Cambridge:</location>
<marker>Gazdar, Klein, Pullum, Sag, 1985</marker>
<rawString>Gazdar, Gerald; Klein, Ewan; Pullum, Geoffrey K.; and Sag, Ivan A. (1985). Generalized Phrase Structure Grammar, Oxford /Cambridge: Blackwell/Harvard.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dafydd Gibbon</author>
</authors>
<title>Underspecification in phonology.&amp;quot;</title>
<date>1990</date>
<booktitle>In The DATR Papers, Volume 1, edited by Roger Evans and Gerald Gazdar,</booktitle>
<pages>99--100</pages>
<publisher>COGS.</publisher>
<institution>University of Sussex,</institution>
<location>Brighton:</location>
<contexts>
<context position="25453" citStr="Gibbon 1990" startWordPosition="4102" endWordPosition="4103"> that operates by means of path-based inference over an inheritance network. 3. Phonology, Orthography, and Morphophonology Computational phonology is perhaps the youngest and least studied branch of NLP. But notions of default have played such a prominent role in linguistic discussion of the area that it is not surprising that default inheritance networks have found a place in this subfield right from the start. Thus Gibbon and Reinhard have made extensive use of DATR networks to describe lexical morphophonological phenomena such as German umlaut, Kikuyu tone, and Arabic vowel intercalation (Gibbon 1990b, in press; Reinhard 1990; Reinhard and Gibbon 1991). And Daelemans (1987a,b, 1988) uses the object-oriented knowledge representation language KRS to implement default orthogonal inheritance networks for the lexical representation of phonological, orthographic, and morphological knowledge of Dutch and shows how such a lexicon architecture can be used for both language generation and automatic dictionary construction. The work of Calder (1989) and his associates at Edinburgh and Stuttgart on &amp;quot;paradigmatic morphology&amp;quot; also fits within this tradition in that it invokes a restricted kind of defau</context>
</contexts>
<marker>Gibbon, 1990</marker>
<rawString>Gibbon, Dafydd (1990a). &amp;quot;Underspecification in phonology.&amp;quot; In The DATR Papers, Volume 1, edited by Roger Evans and Gerald Gazdar, 99-100. University of Sussex, Brighton: COGS.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dafydd Gibbon</author>
</authors>
<title>Prosodic association by template inheritance.&amp;quot;</title>
<date>1990</date>
<booktitle>In Proceedings, Workshop on Inheritance in Natural Language Processing, Walter Daelemans and Gerald Gazdar,</booktitle>
<pages>65--81</pages>
<institution>ITK (Institute for Language Technology and Al).</institution>
<location>Tilburg, The Netherlands:</location>
<contexts>
<context position="25453" citStr="Gibbon 1990" startWordPosition="4102" endWordPosition="4103"> that operates by means of path-based inference over an inheritance network. 3. Phonology, Orthography, and Morphophonology Computational phonology is perhaps the youngest and least studied branch of NLP. But notions of default have played such a prominent role in linguistic discussion of the area that it is not surprising that default inheritance networks have found a place in this subfield right from the start. Thus Gibbon and Reinhard have made extensive use of DATR networks to describe lexical morphophonological phenomena such as German umlaut, Kikuyu tone, and Arabic vowel intercalation (Gibbon 1990b, in press; Reinhard 1990; Reinhard and Gibbon 1991). And Daelemans (1987a,b, 1988) uses the object-oriented knowledge representation language KRS to implement default orthogonal inheritance networks for the lexical representation of phonological, orthographic, and morphological knowledge of Dutch and shows how such a lexicon architecture can be used for both language generation and automatic dictionary construction. The work of Calder (1989) and his associates at Edinburgh and Stuttgart on &amp;quot;paradigmatic morphology&amp;quot; also fits within this tradition in that it invokes a restricted kind of defau</context>
</contexts>
<marker>Gibbon, 1990</marker>
<rawString>Gibbon, Dafydd (1990b). &amp;quot;Prosodic association by template inheritance.&amp;quot; In Proceedings, Workshop on Inheritance in Natural Language Processing, Walter Daelemans and Gerald Gazdar, 65-81. Tilburg, The Netherlands: ITK (Institute for Language Technology and Al).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dafydd Gibbon</author>
</authors>
<title>ILEX: a linguistic approach to computational lexica.&amp;quot;</title>
<date>1991</date>
<booktitle>Computatio Linguae: Aufsti tze Zur algorithmischen und quantitativen Analyse der Sprache. Zeitschrift fur Dialektologie und Linguistik, Beiheft</booktitle>
<pages>7--32</pages>
<editor>In Ursula Klenk, ed.</editor>
<contexts>
<context position="25506" citStr="Gibbon 1991" startWordPosition="4110" endWordPosition="4111"> an inheritance network. 3. Phonology, Orthography, and Morphophonology Computational phonology is perhaps the youngest and least studied branch of NLP. But notions of default have played such a prominent role in linguistic discussion of the area that it is not surprising that default inheritance networks have found a place in this subfield right from the start. Thus Gibbon and Reinhard have made extensive use of DATR networks to describe lexical morphophonological phenomena such as German umlaut, Kikuyu tone, and Arabic vowel intercalation (Gibbon 1990b, in press; Reinhard 1990; Reinhard and Gibbon 1991). And Daelemans (1987a,b, 1988) uses the object-oriented knowledge representation language KRS to implement default orthogonal inheritance networks for the lexical representation of phonological, orthographic, and morphological knowledge of Dutch and shows how such a lexicon architecture can be used for both language generation and automatic dictionary construction. The work of Calder (1989) and his associates at Edinburgh and Stuttgart on &amp;quot;paradigmatic morphology&amp;quot; also fits within this tradition in that it invokes a restricted kind of default orthogonal inheritance for morphophonological desc</context>
</contexts>
<marker>Gibbon, 1991</marker>
<rawString>Gibbon, Dafydd (1991). &amp;quot;ILEX: a linguistic approach to computational lexica.&amp;quot; In Ursula Klenk, ed. Computatio Linguae: Aufsti tze Zur algorithmischen und quantitativen Analyse der Sprache. Zeitschrift fur Dialektologie und Linguistik, Beiheft 7,32-53.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert Hetzron</author>
</authors>
<title>Where the grammar fails,&amp;quot;</title>
<date>1975</date>
<journal>Language,</journal>
<pages>51--859</pages>
<marker>Hetzron, 1975</marker>
<rawString>Hetzron, Robert (1975). &amp;quot;Where the grammar fails,&amp;quot; Language, 51,859-872.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John E Horty</author>
<author>Richmond H Thomason</author>
<author>David S Touretzky</author>
</authors>
<title>A skeptical theory of inheritance in nonmonotonic semantic networks,&amp;quot;</title>
<date>1990</date>
<journal>Artificial Intelligence,</journal>
<volume>42</volume>
<issue>2</issue>
<pages>311--348</pages>
<marker>Horty, Thomason, Touretzky, 1990</marker>
<rawString>Horty, John E; Thomason, Richmond H.; and Touretzky, David S. (1990). &amp;quot;A skeptical theory of inheritance in nonmonotonic semantic networks,&amp;quot; Artificial Intelligence, 42(2-3), 311-348.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Richard A Hudson</author>
</authors>
<title>Word Grammar.</title>
<date>1984</date>
<publisher>Blackwell.</publisher>
<location>Oxford:</location>
<marker>Hudson, 1984</marker>
<rawString>Hudson, Richard A. (1984). Word Grammar. Oxford: Blackwell.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Richard A Hudson</author>
</authors>
<title>English Word Grammar.</title>
<date>1990</date>
<publisher>Blackwell.</publisher>
<location>Oxford:</location>
<marker>Hudson, 1990</marker>
<rawString>Hudson, Richard A. (1990). English Word Grammar. Oxford: Blackwell.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ray Jackendoff</author>
</authors>
<title>Morphological and semantic regularities in the lexicon,&amp;quot;</title>
<date>1975</date>
<journal>Language,</journal>
<pages>51--639</pages>
<marker>Jackendoff, 1975</marker>
<rawString>Jackendoff, Ray (1975). &amp;quot;Morphological and semantic regularities in the lexicon,&amp;quot; Language, 51,639-671.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Paul S Jacobs</author>
</authors>
<title>Knowledge structures for natural language generation.&amp;quot;</title>
<date>1986</date>
<booktitle>In COLING-86,</booktitle>
<pages>554--559</pages>
<contexts>
<context position="27705" citStr="Jacobs (1986" startWordPosition="4445" endWordPosition="4446">ral language understanding that goes back at least as far as Simmons (1973). Much of the work in this tradition has concerned itself with domain and world knowledge relevant to disambiguation and to drawing inferences from what is said, but not to the semantic representations of words, phrases and utterances per se. Exceptions to this generalization are not hard to find, however. For example, Barnett et al. (1990) use the same language (CycL) for linguistic semantic representation as is used in the encyclopedic inheritance network for which they are providing a natural language interface. And Jacobs (1986, 1987) proposes a uniform hierarchical encoding of both linguistic and conceptual knowledge in a framebased formalism called ACE. Jacobs then uses the resulting inheritance network to give an account of metaphor, inter alia. By contrast, Allgayer et al. (1989) employ two separate inheritance networks, one for linguistic semantic knowledge and the other for conceptual knowledge, both being implemented in a KL-ONE derivative called SB-ONE. Several of the inheritance-based linguistic knowledge representation formalisms that we have introduced in earlier sections are being used for semantic purpo</context>
</contexts>
<marker>Jacobs, 1986</marker>
<rawString>Jacobs, Paul S. (1986). &amp;quot;Knowledge structures for natural language generation.&amp;quot; In COLING-86, 554-559.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Paul S Jacobs</author>
</authors>
<title>A knowledge framework for natural language analysis.&amp;quot;</title>
<date>1987</date>
<booktitle>In IJCAI-87,</booktitle>
<pages>2--675</pages>
<marker>Jacobs, 1987</marker>
<rawString>Jacobs, Paul S. (1987). &amp;quot;A knowledge framework for natural language analysis.&amp;quot; In IJCAI-87, 2,675-678.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Aravind Joshi</author>
<author>Bonnie L Webber</author>
<author>Ralph Weischedel</author>
</authors>
<title>Default reasoning in interaction.&amp;quot;</title>
<date>1984</date>
<booktitle>In Proceedings, AAAI Non-Monotonic Reasoning Workshop,</booktitle>
<pages>144--150</pages>
<location>New York,</location>
<contexts>
<context position="30186" citStr="Joshi et al. (1984)" startWordPosition="4817" endWordPosition="4820">opposed to general reasoning) is notable largely for its absence. The only example we know of is Etherington et al.&apos;s (1989) proposal to represent the consequences of Gricean 4 Compare Gibbon&apos;s (1990a) use of DATR to the same end. 5 See Pustejovsky (1989, 1991). 213 Computational Linguistics Volume 18, Number 2 maxims in a default inheritance network designed for fast (though not necessarily correct) reasoning. Most recent computational linguistic work on pragmatics has tended to turn to general nonstandard logics as tools for the job, rather than their less expressive network relations. Thus Joshi et al. (1984) and Lascarides and Asher (1991) have made the case for nonmonotonic logics in formalizing Gricean maxims, while Schubert and Hwang (1989) show how a probabilistic logic might be used in story understanding. Mercer and Reiter (1982) and Mercer (1988) have employed Reiter&apos;s default logic to capture the behavior of natural language presuppositions. Perrault (1990) uses default logic to express a theory of speech acts, while Appelt and Konolige (1988) have deployed an extension to Moore&apos;s (1985) autoepistemic logic for the same purpose. 5. Concluding Remarks Within computational linguistics, it i</context>
</contexts>
<marker>Joshi, Webber, Weischedel, 1984</marker>
<rawString>Joshi, Aravind; Webber, Bonnie L.; and Weischedel, Ralph (1984). &amp;quot;Default reasoning in interaction.&amp;quot; In Proceedings, AAAI Non-Monotonic Reasoning Workshop, New York, 144-150.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Megumi Kameyarna</author>
</authors>
<title>Atomization in grammar sharing.&amp;quot;</title>
<date>1988</date>
<booktitle>In ACL Proceedings, 26th Annual Meeting,</booktitle>
<pages>194--203</pages>
<marker>Kameyarna, 1988</marker>
<rawString>Kameyarna, Megumi (1988). &amp;quot;Atomization in grammar sharing.&amp;quot; In ACL Proceedings, 26th Annual Meeting, 194-203.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Megumi Kameyama</author>
<author>Ryo Ochitani</author>
<author>Stanley Peters</author>
</authors>
<title>Resolving translation mismatches with information flow.&amp;quot;</title>
<date>1991</date>
<booktitle>In ACL Proceedings, 29th Annual Meeting,</booktitle>
<pages>193--200</pages>
<contexts>
<context position="29427" citStr="Kameyama et al. (1991)" startWordPosition="4701" endWordPosition="4704">the lexicon of a message understanding system. Briscoe et al. (1990) use a version of PAIR augmented with defeasible templates to implement a default orthogonal inheritance network for a Pustejovskian analysis of metonymic sense extension in lexical semantics (e.g. interpreting the film in Enjoy the film! as watching the film).5 Their approach is further elaborated in Briscoe and Copestake (1991) and Copestake and Briscoe (1991). A semantic analog of the monotonic type hierarchies discussed above in connection with syntax is manifested in the situation theoretic &amp;quot;infon lattices&amp;quot; introduced by Kameyama et al. (1991) to deal with meaning mismatches in machine translation. The use of inheritance networks for specifically linguistic pragmatic purposes (as opposed to general reasoning) is notable largely for its absence. The only example we know of is Etherington et al.&apos;s (1989) proposal to represent the consequences of Gricean 4 Compare Gibbon&apos;s (1990a) use of DATR to the same end. 5 See Pustejovsky (1989, 1991). 213 Computational Linguistics Volume 18, Number 2 maxims in a default inheritance network designed for fast (though not necessarily correct) reasoning. Most recent computational linguistic work on </context>
</contexts>
<marker>Kameyama, Ochitani, Peters, 1991</marker>
<rawString>Kameyama, Megumi; Ochitani, Ryo; and Peters, Stanley (1991). &amp;quot;Resolving translation mismatches with information flow.&amp;quot; In ACL Proceedings, 29th Annual Meeting, 193-200.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ronald M Kaplan</author>
</authors>
<title>Three seductions of computational psycholinguistics.&amp;quot; In Linguistic Theory and Computer Applications, edited by Peter Whitelock,</title>
<date>1987</date>
<pages>149--188</pages>
<publisher>Academic Press.</publisher>
<location>Mary McGee</location>
<contexts>
<context position="19009" citStr="Kaplan (1987" startWordPosition="3105" endWordPosition="3106">defining monotonic multiple inheritance networks. He drew attention to the possibility of adding a nonmonotonic &amp;quot;overwriting&amp;quot; operation to PATR and commented that &amp;quot;the cost of such a move is great, however, because the use 210 Walter Daelemans et al. Inheritance in Natural Language Processing of overwriting eliminates the order independence that is so advantageous a property in a formalism&amp;quot; (1986, p. 60). In a subsequent implementation of PATR, Karttunen (1986) makes all D-PATR templates subject to overwriting. The very similar notion of &amp;quot;priority union&amp;quot; is introduced in the context of LFG by Kaplan (1987, p. 180). These ideas are developed by Bouma (this issue) who gives a definition of default unification on the basis of a logic for features. Kameyama (1988) uses PATR-style templates to build a multiple inheritance multilingual lexicon to support Categorial Unification Grammar descriptions of Arabic, English, French, German, and Japanese nominals. Although the system described is monotonic, there is a footnote suggesting a move toward a default inheritance system to deal with marked constituent orders (p. 202, n10). Of all the unification-based grammar formalisms, it is HPSG which has thus f</context>
</contexts>
<marker>Kaplan, 1987</marker>
<rawString>Kaplan, Ronald M. (1987). &amp;quot;Three seductions of computational psycholinguistics.&amp;quot; In Linguistic Theory and Computer Applications, edited by Peter Whitelock, Mary McGee Wood, Harold L. Somers, Rod L. Johnson, and Paul Bennett, 149-188. London: Academic Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
</authors>
<title>D-PATR: A development environment for unification-based grammars.&amp;quot;</title>
<date>1986</date>
<booktitle>In COLING-86,</booktitle>
<pages>74--80</pages>
<contexts>
<context position="18862" citStr="Karttunen (1986)" startWordPosition="3081" endWordPosition="3082">nification grammars began in the mid1980s. Shieber (1986b, p. 57ff) noted that the provision of lexical &amp;quot;templates&amp;quot; in PATR amounted to a language for defining monotonic multiple inheritance networks. He drew attention to the possibility of adding a nonmonotonic &amp;quot;overwriting&amp;quot; operation to PATR and commented that &amp;quot;the cost of such a move is great, however, because the use 210 Walter Daelemans et al. Inheritance in Natural Language Processing of overwriting eliminates the order independence that is so advantageous a property in a formalism&amp;quot; (1986, p. 60). In a subsequent implementation of PATR, Karttunen (1986) makes all D-PATR templates subject to overwriting. The very similar notion of &amp;quot;priority union&amp;quot; is introduced in the context of LFG by Kaplan (1987, p. 180). These ideas are developed by Bouma (this issue) who gives a definition of default unification on the basis of a logic for features. Kameyama (1988) uses PATR-style templates to build a multiple inheritance multilingual lexicon to support Categorial Unification Grammar descriptions of Arabic, English, French, German, and Japanese nominals. Although the system described is monotonic, there is a footnote suggesting a move toward a default in</context>
</contexts>
<marker>Karttunen, 1986</marker>
<rawString>Karttunen, Lauri (1986). &amp;quot;D-PATR: A development environment for unification-based grammars.&amp;quot; In COLING-86, 74-80.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gerard Kempen</author>
</authors>
<title>A framework for incremental syntactic tree formation.&amp;quot;</title>
<date>1987</date>
<booktitle>In IJCAI-87,</booktitle>
<pages>2--655</pages>
<contexts>
<context position="18138" citStr="Kempen 1987" startWordPosition="2973" endWordPosition="2974">stic knowledge. General inference mechanisms based on constraint propagation used the frames, organized in inheritance hierarchies, in generation and parsing. De Smedt (1984) went on to use generic function application to provide one of the earliest illustrations of the descriptive power of default inheritance networks for morphology in a treatment of Dutch verbs, an analysis that is extended to adjectival and nominal forms in De Smedt and de Graaf (1990). In the same paper, the authors indicate how inheritance techniques can be applied to a unification-based formalism called Segment Grammar (Kempen 1987), which is intended to facilitate incremental syntactic processing. Attempts to reconcile inheritance with unification grammars began in the mid1980s. Shieber (1986b, p. 57ff) noted that the provision of lexical &amp;quot;templates&amp;quot; in PATR amounted to a language for defining monotonic multiple inheritance networks. He drew attention to the possibility of adding a nonmonotonic &amp;quot;overwriting&amp;quot; operation to PATR and commented that &amp;quot;the cost of such a move is great, however, because the use 210 Walter Daelemans et al. Inheritance in Natural Language Processing of overwriting eliminates the order independenc</context>
</contexts>
<marker>Kempen, 1987</marker>
<rawString>Kempen, Gerard (1987). &amp;quot;A framework for incremental syntactic tree formation.&amp;quot; In IJCAI-87, 2,655-660.</rawString>
</citation>
<citation valid="true">
<authors>
<author>James Kilbury</author>
<author>Petra Naerger</author>
<author>Ingrid Renz</author>
</authors>
<title>DATR as a lexical component for PATR&amp;quot;</title>
<date>1991</date>
<booktitle>In ACL Proceedings, 5th European Conference,</booktitle>
<pages>137--142</pages>
<contexts>
<context position="23777" citStr="Kilbury et al. (1991)" startWordPosition="3834" endWordPosition="3837"> lexical knowledge representation, and (1989b) they provide a semantics for the language that is loosely based on the approach taken by Moore (1985) in his semantics for autoepistemic logic. DATR allows multiple default inheritance but enforces orthogonality. Evans et al. (in press) show how DATR can also be used to encode certain kinds of prioritized inheritance. Unlike ELU and the Word Grammar notation, DATR is not intended to be a full grammar formalism. Rather, it is intended to be a lexical formalism that can be used with any grammar that can be encoded in terms of attributes and values. Kilbury et al. (1991) show how a DATR lexicon can be linked to a PATR syntax, while Andry et al. (in press) employ a DATR lexicon in the context of a Unification Categorial Grammar. The use of DATR to describe morphology is illustrated, for Latin, by Gazdar (in press) and in the fragments of Arabic, English, German, and Japanese included in Evans and Gazdar (1990). All of our discussion thus far has presupposed the use of inheritance networks to store essentially static information. But, following the precedent set by Brachman and Schmolze (1985), a number of researchers have begun to explore their utility in lang</context>
</contexts>
<marker>Kilbury, Naerger, Renz, 1991</marker>
<rawString>Kilbury, James; Naerger, Petra; and Renz, Ingrid (1991). &amp;quot;DATR as a lexical component for PATR&amp;quot; In ACL Proceedings, 5th European Conference, 137-142.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alex Lascarides</author>
<author>Nicholas Asher</author>
</authors>
<title>Discourse relations and defeasible knowledge.&amp;quot;</title>
<date>1991</date>
<booktitle>In ACL Proceedings, 29th Annual Meeting,</booktitle>
<pages>55--62</pages>
<contexts>
<context position="30218" citStr="Lascarides and Asher (1991)" startWordPosition="4822" endWordPosition="4825">ning) is notable largely for its absence. The only example we know of is Etherington et al.&apos;s (1989) proposal to represent the consequences of Gricean 4 Compare Gibbon&apos;s (1990a) use of DATR to the same end. 5 See Pustejovsky (1989, 1991). 213 Computational Linguistics Volume 18, Number 2 maxims in a default inheritance network designed for fast (though not necessarily correct) reasoning. Most recent computational linguistic work on pragmatics has tended to turn to general nonstandard logics as tools for the job, rather than their less expressive network relations. Thus Joshi et al. (1984) and Lascarides and Asher (1991) have made the case for nonmonotonic logics in formalizing Gricean maxims, while Schubert and Hwang (1989) show how a probabilistic logic might be used in story understanding. Mercer and Reiter (1982) and Mercer (1988) have employed Reiter&apos;s default logic to capture the behavior of natural language presuppositions. Perrault (1990) uses default logic to express a theory of speech acts, while Appelt and Konolige (1988) have deployed an extension to Moore&apos;s (1985) autoepistemic logic for the same purpose. 5. Concluding Remarks Within computational linguistics, it is possible to see three distinct</context>
</contexts>
<marker>Lascarides, Asher, 1991</marker>
<rawString>Lascarides, Alex, and Asher, Nicholas (1991). &amp;quot;Discourse relations and defeasible knowledge.&amp;quot; In ACL Proceedings, 29th Annual Meeting, 55-62.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert E Mercer</author>
</authors>
<title>Using default logic to derive natural language presuppositions.&amp;quot;</title>
<date>1988</date>
<booktitle>In Proceedings, Seventh Biennial Conference of the CSCSIISCEIO,</booktitle>
<pages>14--21</pages>
<contexts>
<context position="30436" citStr="Mercer (1988)" startWordPosition="4858" endWordPosition="4859">1991). 213 Computational Linguistics Volume 18, Number 2 maxims in a default inheritance network designed for fast (though not necessarily correct) reasoning. Most recent computational linguistic work on pragmatics has tended to turn to general nonstandard logics as tools for the job, rather than their less expressive network relations. Thus Joshi et al. (1984) and Lascarides and Asher (1991) have made the case for nonmonotonic logics in formalizing Gricean maxims, while Schubert and Hwang (1989) show how a probabilistic logic might be used in story understanding. Mercer and Reiter (1982) and Mercer (1988) have employed Reiter&apos;s default logic to capture the behavior of natural language presuppositions. Perrault (1990) uses default logic to express a theory of speech acts, while Appelt and Konolige (1988) have deployed an extension to Moore&apos;s (1985) autoepistemic logic for the same purpose. 5. Concluding Remarks Within computational linguistics, it is possible to see three distinct trends emerging. The first is the increasing employment of monotonic type lattices in unification-based grammars to constrain the space of permissible descriptions. The second is the use of a variety of general nonmon</context>
</contexts>
<marker>Mercer, 1988</marker>
<rawString>Mercer, Robert E. (1988). &amp;quot;Using default logic to derive natural language presuppositions.&amp;quot; In Proceedings, Seventh Biennial Conference of the CSCSIISCEIO, 14-21.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert E Mercer</author>
<author>Raymond Reiter</author>
</authors>
<title>The representation of presuppositions using defaults.&amp;quot; In</title>
<date>1982</date>
<booktitle>Proceedings, Fourth Biennial Conference of the CSCSI/SCEIO,</booktitle>
<pages>103--107</pages>
<contexts>
<context position="30418" citStr="Mercer and Reiter (1982)" startWordPosition="4853" endWordPosition="4856">nd. 5 See Pustejovsky (1989, 1991). 213 Computational Linguistics Volume 18, Number 2 maxims in a default inheritance network designed for fast (though not necessarily correct) reasoning. Most recent computational linguistic work on pragmatics has tended to turn to general nonstandard logics as tools for the job, rather than their less expressive network relations. Thus Joshi et al. (1984) and Lascarides and Asher (1991) have made the case for nonmonotonic logics in formalizing Gricean maxims, while Schubert and Hwang (1989) show how a probabilistic logic might be used in story understanding. Mercer and Reiter (1982) and Mercer (1988) have employed Reiter&apos;s default logic to capture the behavior of natural language presuppositions. Perrault (1990) uses default logic to express a theory of speech acts, while Appelt and Konolige (1988) have deployed an extension to Moore&apos;s (1985) autoepistemic logic for the same purpose. 5. Concluding Remarks Within computational linguistics, it is possible to see three distinct trends emerging. The first is the increasing employment of monotonic type lattices in unification-based grammars to constrain the space of permissible descriptions. The second is the use of a variety</context>
</contexts>
<marker>Mercer, Reiter, 1982</marker>
<rawString>Mercer, Robert E., and Reiter, Raymond (1982). &amp;quot;The representation of presuppositions using defaults.&amp;quot; In Proceedings, Fourth Biennial Conference of the CSCSI/SCEIO, 103-107.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Marc Moens</author>
<author>Jo Calder</author>
<author>Ewan Klein</author>
<author>Mike Reape</author>
<author>Henk Zeevat</author>
</authors>
<title>Expressing generalizations in unification-based grammar formalisms.&amp;quot;</title>
<date>1989</date>
<booktitle>In ACL Proceedings, 4th European Conference,</booktitle>
<pages>174--181</pages>
<contexts>
<context position="21732" citStr="Moens et al. 1989" startWordPosition="3515" endWordPosition="3518">f a variety of restrictions designed to prevent overgeneration, together with a nonmonotonic formulation of lexical rules (pp. 212-213). A concern to preserve monotonic inheritance in HPSG is likewise evident in more recent work, such as Carpenter and Pollard (1991) and Zajac (this issue). Monotonic multiple inheritance type hierarchies figure in a good deal of recent work in unification-based grammars. Examples include papers by Porter (1987), Emele and Zajac (1990), and Emele et al. (1990), who all use a semantics based on Ait-Kaci (1984); the use of sorts in Unification Categorial Grammar (Moens et al. 1989); the CLE project (Alshawi et al. 1989) and theoretical work by Smolka (1988). Default multiple inheritance also figures centrally in a couple of grammatical frameworks. One is Hudson&apos;s (1984,1990) Word Grammar, and a detailed exposition is provided by Fraser and Hudson in this issue. Word Grammar is a feature-based variant of dependency grammar, one that makes pervasive use of a (multiple) inheritance relation. The latter is unusual in that stipulated exceptions do not automatically override an inherited default: the latter has to be explicitly negated if the grammar requires its suppression </context>
</contexts>
<marker>Moens, Calder, Klein, Reape, Zeevat, 1989</marker>
<rawString>Moens, Marc; Calder, Jo; Klein, Ewan; Reape, Mike; and Zeevat, Henk (1989). &amp;quot;Expressing generalizations in unification-based grammar formalisms.&amp;quot; In ACL Proceedings, 4th European Conference, 174-181.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert C Moore</author>
</authors>
<title>Semantical considerations on nonmonotonic logic,&amp;quot;</title>
<date>1985</date>
<journal>Artificial Intelligence,</journal>
<volume>25</volume>
<issue>1</issue>
<pages>75--94</pages>
<contexts>
<context position="23304" citStr="Moore (1985)" startWordPosition="3756" endWordPosition="3757">r formalism with a language for defining default multiple inheritance networks for the lexicon. Inspired by CLOS, an object-oriented extension of Common LISP, they adopt prioritized inheritance to escape the problem caused by conflicting inherited information. Russell et al. (in press) illustrate their approach with ELU analyses of English and German verbal morphology. Evans and Gazdar (1989a) outline the syntax and theory of inference for DATR, a language for lexical knowledge representation, and (1989b) they provide a semantics for the language that is loosely based on the approach taken by Moore (1985) in his semantics for autoepistemic logic. DATR allows multiple default inheritance but enforces orthogonality. Evans et al. (in press) show how DATR can also be used to encode certain kinds of prioritized inheritance. Unlike ELU and the Word Grammar notation, DATR is not intended to be a full grammar formalism. Rather, it is intended to be a lexical formalism that can be used with any grammar that can be encoded in terms of attributes and values. Kilbury et al. (1991) show how a DATR lexicon can be linked to a PATR syntax, while Andry et al. (in press) employ a DATR lexicon in the context of </context>
</contexts>
<marker>Moore, 1985</marker>
<rawString>Moore, Robert C. (1985). &amp;quot;Semantical considerations on nonmonotonic logic,&amp;quot; Artificial Intelligence, 25(1), 75-94.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Raymond Perrault</author>
</authors>
<title>An application of default logic to speech act theory.&amp;quot;</title>
<date>1990</date>
<booktitle>In Intentions in Communication, edited by</booktitle>
<pages>161--185</pages>
<publisher>The MIT Press.</publisher>
<location>Cambridge, MA:</location>
<contexts>
<context position="30550" citStr="Perrault (1990)" startWordPosition="4873" endWordPosition="4874">st (though not necessarily correct) reasoning. Most recent computational linguistic work on pragmatics has tended to turn to general nonstandard logics as tools for the job, rather than their less expressive network relations. Thus Joshi et al. (1984) and Lascarides and Asher (1991) have made the case for nonmonotonic logics in formalizing Gricean maxims, while Schubert and Hwang (1989) show how a probabilistic logic might be used in story understanding. Mercer and Reiter (1982) and Mercer (1988) have employed Reiter&apos;s default logic to capture the behavior of natural language presuppositions. Perrault (1990) uses default logic to express a theory of speech acts, while Appelt and Konolige (1988) have deployed an extension to Moore&apos;s (1985) autoepistemic logic for the same purpose. 5. Concluding Remarks Within computational linguistics, it is possible to see three distinct trends emerging. The first is the increasing employment of monotonic type lattices in unification-based grammars to constrain the space of permissible descriptions. The second is the use of a variety of general nonmonotonic logics for formalizing pragmatic components of NLP systems. And the third is the development of a variety o</context>
</contexts>
<marker>Perrault, 1990</marker>
<rawString>Perrault, C. Raymond (1990). &amp;quot;An application of default logic to speech act theory.&amp;quot; In Intentions in Communication, edited by Philip Cohen, Jerry Morgan, and Martha Pollack, 161-185. Cambridge, MA: The MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Carl Pollard</author>
<author>Ivan A Sag</author>
</authors>
<title>Information-Based Syntax and Semantics, Volume 1. Stanford/Chicago: CSLI/Chicago</title>
<date>1987</date>
<publisher>University Press.</publisher>
<contexts>
<context position="20912" citStr="Pollard and Sag (1987)" startWordPosition="3389" endWordPosition="3392">ult inheritance. Like Shieber (1986b, pp. 60-61), he notes the problem that contradictory attribute values pose for such machinery and entertains the hypothesis that the relevant links &amp;quot;should be disjoint in the set of attributes for which they support inheritance&amp;quot; (1987, p. 61). Flickinger&apos;s thesis is probably the most detailed discursive application of a default inheritance framework to the lexicon. In their paper in the present issue, Flickinger and Nerbonne (in press) extend the analysis further still so as to encompass some of the trickiest and most-debated data in the syntax of English. Pollard and Sag (1987), in the first book-length presentation of HPSG, treat the lexicon as a monotonic multiple-inheritance type hierarchy. They implicitly reject the use of an &amp;quot;overriding mechanism&amp;quot; (p. 194, n4) in favor of a variety of restrictions designed to prevent overgeneration, together with a nonmonotonic formulation of lexical rules (pp. 212-213). A concern to preserve monotonic inheritance in HPSG is likewise evident in more recent work, such as Carpenter and Pollard (1991) and Zajac (this issue). Monotonic multiple inheritance type hierarchies figure in a good deal of recent work in unification-based g</context>
</contexts>
<marker>Pollard, Sag, 1987</marker>
<rawString>Pollard, Carl, and Sag, Ivan A. (1987). Information-Based Syntax and Semantics, Volume 1. Stanford/Chicago: CSLI/Chicago University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Harry H Porter</author>
</authors>
<title>Incorporating inheritance and feature structures into a logic grammar formalism.&amp;quot;</title>
<date>1987</date>
<booktitle>In ACL Proceedings, 25th Annual Meeting,</booktitle>
<pages>228--234</pages>
<contexts>
<context position="21561" citStr="Porter (1987)" startWordPosition="3487" endWordPosition="3488">ion of HPSG, treat the lexicon as a monotonic multiple-inheritance type hierarchy. They implicitly reject the use of an &amp;quot;overriding mechanism&amp;quot; (p. 194, n4) in favor of a variety of restrictions designed to prevent overgeneration, together with a nonmonotonic formulation of lexical rules (pp. 212-213). A concern to preserve monotonic inheritance in HPSG is likewise evident in more recent work, such as Carpenter and Pollard (1991) and Zajac (this issue). Monotonic multiple inheritance type hierarchies figure in a good deal of recent work in unification-based grammars. Examples include papers by Porter (1987), Emele and Zajac (1990), and Emele et al. (1990), who all use a semantics based on Ait-Kaci (1984); the use of sorts in Unification Categorial Grammar (Moens et al. 1989); the CLE project (Alshawi et al. 1989) and theoretical work by Smolka (1988). Default multiple inheritance also figures centrally in a couple of grammatical frameworks. One is Hudson&apos;s (1984,1990) Word Grammar, and a detailed exposition is provided by Fraser and Hudson in this issue. Word Grammar is a feature-based variant of dependency grammar, one that makes pervasive use of a (multiple) inheritance relation. The latter is</context>
</contexts>
<marker>Porter, 1987</marker>
<rawString>Porter, Harry H. (1987). &amp;quot;Incorporating inheritance and feature structures into a logic grammar formalism.&amp;quot; In ACL Proceedings, 25th Annual Meeting, 228-234.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Geoffrey K Pullum</author>
</authors>
<title>Rule Interaction and the Organization of a Grammar.</title>
<date>1979</date>
<publisher>Garland.</publisher>
<location>New York:</location>
<contexts>
<context position="14027" citStr="Pullum 1979" startWordPosition="2336" endWordPosition="2337">third is the notion of &amp;quot;markedness&amp;quot; in linguistics, which originates in the Prague School phonology of the 1930s, reappears in the &amp;quot;generative phonology&amp;quot; of Chomsky and Halle (1968) and Hetzron&apos;s (1975) and Jackendoff&apos;s (1975) models of the lexicon, and shows up in syntax in the &amp;quot;feature specification defaults&amp;quot; of Gazdar, Klein, Pullum, and Sag (1985).2 Unlike the other three traditions, the linguistic tradition does not embody a notion of inheritance per se. But the issue of how to decide which operations take precedence over others has been a continuing concern in the literature (see, e.g., Pullum 1979, especially Section 1.4.1, and references therein). The consensus view, though largely unspoken, among computational linguists currently working with default inheritance networks appears to be that nodes that are close (or identical) to the root(s) of the network should be used to encode that which is regular, &amp;quot;unmarked,&amp;quot; and productive, and that distance from the root(s) should correlate with increasing irregularity, &amp;quot;markedness,&amp;quot; and lack of productivity. At the 2 See Evans (1987), Gazdar (1987), and Shieber (1986a) on the various defaulty characteristics of GPSG. 209 Computational Linguist</context>
</contexts>
<marker>Pullum, 1979</marker>
<rawString>Pullum, Geoffrey K. (1979). Rule Interaction and the Organization of a Grammar. New York: Garland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>James Pustejovsky</author>
</authors>
<title>Current issues in computational lexical semantics.&amp;quot;</title>
<date>1989</date>
<booktitle>In ACL Proceedings, Fourth European Conference,</booktitle>
<pages>xvii-xxv.</pages>
<contexts>
<context position="29821" citStr="Pustejovsky (1989" startWordPosition="4765" endWordPosition="4766"> and Copestake and Briscoe (1991). A semantic analog of the monotonic type hierarchies discussed above in connection with syntax is manifested in the situation theoretic &amp;quot;infon lattices&amp;quot; introduced by Kameyama et al. (1991) to deal with meaning mismatches in machine translation. The use of inheritance networks for specifically linguistic pragmatic purposes (as opposed to general reasoning) is notable largely for its absence. The only example we know of is Etherington et al.&apos;s (1989) proposal to represent the consequences of Gricean 4 Compare Gibbon&apos;s (1990a) use of DATR to the same end. 5 See Pustejovsky (1989, 1991). 213 Computational Linguistics Volume 18, Number 2 maxims in a default inheritance network designed for fast (though not necessarily correct) reasoning. Most recent computational linguistic work on pragmatics has tended to turn to general nonstandard logics as tools for the job, rather than their less expressive network relations. Thus Joshi et al. (1984) and Lascarides and Asher (1991) have made the case for nonmonotonic logics in formalizing Gricean maxims, while Schubert and Hwang (1989) show how a probabilistic logic might be used in story understanding. Mercer and Reiter (1982) an</context>
</contexts>
<marker>Pustejovsky, 1989</marker>
<rawString>Pustejovsky, James (1989). &amp;quot;Current issues in computational lexical semantics.&amp;quot; In ACL Proceedings, Fourth European Conference, xvii-xxv.</rawString>
</citation>
<citation valid="true">
<authors>
<author>James Pustejovsky</author>
</authors>
<title>The generative lexicon,&amp;quot;</title>
<date>1991</date>
<journal>Computational Linguistics,</journal>
<volume>17</volume>
<issue>4</issue>
<pages>409--441</pages>
<marker>Pustejovsky, 1991</marker>
<rawString>Pustejovsky, James (1991). &amp;quot;The generative lexicon,&amp;quot; Computational Linguistics, 17(4), 409-441.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Quillian</author>
</authors>
<title>Semantic memory.&amp;quot;</title>
<date>1968</date>
<booktitle>In Semantic Information Processing, edited by Marvin Minsky,</booktitle>
<pages>227--270</pages>
<publisher>The MIT Press.</publisher>
<location>Cambridge, MA:</location>
<contexts>
<context position="12831" citStr="Quillian (1968)" startWordPosition="2149" endWordPosition="2150">nce.&amp;quot; One way of thinking of it is in terms of a set of disjoint single inheritance networks layered on top of each other. On another strategy, a given property, or set of properties, may potentially be inherited from more than one parent node, but the parents are ordered: the first parent in the ordering that is able to supply the property wins, and contradiction is thus avoided. We will refer to this strategy as &amp;quot;prioritized inheritance.&amp;quot; The use of inheritance networks in current NLP comes from three rather separate traditions. The first is that of &amp;quot;semantic nets&amp;quot; in Al, which goes back to Quillian (1968) through Fahlman&apos;s (1979) NETL to the late 1980s monographs by Touretzky (1986) and Etherington (1988). The second is that of data abstraction in programming languages, which has led to (a) object-orientation in computer science with its notions of classes and inheritance as embodied in such languages as Smalltalk, Simula, Flavors, CLOS and C++, and (b) the use of type hierarchies, which have become widely seen in unification-oriented NLP since the appearance of AR-Kaci (1984) and Cardelli (1984). Of necessity, the type hierarchy work in NLP has remained strictly monotonic. The third is the no</context>
</contexts>
<marker>Quillian, 1968</marker>
<rawString>Quillian, M. (1968). &amp;quot;Semantic memory.&amp;quot; In Semantic Information Processing, edited by Marvin Minsky, 227-270. Cambridge, MA: The MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Sabine Reinhard</author>
</authors>
<title>Verarbeitungsprobleme nichtlinearer Morphologien: Umlautbeschreibung in einem hierarchischen Lexikon,&amp;quot;</title>
<date>1990</date>
<booktitle>In Lexikon und Lexicographie,</booktitle>
<pages>45--61</pages>
<publisher>Olms Verlag.</publisher>
<location>Hildesheim:</location>
<note>edited by</note>
<contexts>
<context position="25479" citStr="Reinhard 1990" startWordPosition="4106" endWordPosition="4107">of path-based inference over an inheritance network. 3. Phonology, Orthography, and Morphophonology Computational phonology is perhaps the youngest and least studied branch of NLP. But notions of default have played such a prominent role in linguistic discussion of the area that it is not surprising that default inheritance networks have found a place in this subfield right from the start. Thus Gibbon and Reinhard have made extensive use of DATR networks to describe lexical morphophonological phenomena such as German umlaut, Kikuyu tone, and Arabic vowel intercalation (Gibbon 1990b, in press; Reinhard 1990; Reinhard and Gibbon 1991). And Daelemans (1987a,b, 1988) uses the object-oriented knowledge representation language KRS to implement default orthogonal inheritance networks for the lexical representation of phonological, orthographic, and morphological knowledge of Dutch and shows how such a lexicon architecture can be used for both language generation and automatic dictionary construction. The work of Calder (1989) and his associates at Edinburgh and Stuttgart on &amp;quot;paradigmatic morphology&amp;quot; also fits within this tradition in that it invokes a restricted kind of default orthogonal inheritance </context>
</contexts>
<marker>Reinhard, 1990</marker>
<rawString>Reinhard, Sabine (1990). &amp;quot;Verarbeitungsprobleme nichtlinearer Morphologien: Umlautbeschreibung in einem hierarchischen Lexikon,&amp;quot; In Lexikon und Lexicographie, edited by B. Rieger and B. Schaeder, 45-61. Hildesheim: Olms Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Sabine Reinhard</author>
<author>Dafydd Gibbon</author>
</authors>
<title>Prosodic inheritance and morphological generalisations,&amp;quot;</title>
<date>1991</date>
<booktitle>In Proceedings, Fifth Conference of the European Chapter of the Association for Computational Linguistics,</booktitle>
<pages>131--136</pages>
<contexts>
<context position="25506" citStr="Reinhard and Gibbon 1991" startWordPosition="4108" endWordPosition="4111">nference over an inheritance network. 3. Phonology, Orthography, and Morphophonology Computational phonology is perhaps the youngest and least studied branch of NLP. But notions of default have played such a prominent role in linguistic discussion of the area that it is not surprising that default inheritance networks have found a place in this subfield right from the start. Thus Gibbon and Reinhard have made extensive use of DATR networks to describe lexical morphophonological phenomena such as German umlaut, Kikuyu tone, and Arabic vowel intercalation (Gibbon 1990b, in press; Reinhard 1990; Reinhard and Gibbon 1991). And Daelemans (1987a,b, 1988) uses the object-oriented knowledge representation language KRS to implement default orthogonal inheritance networks for the lexical representation of phonological, orthographic, and morphological knowledge of Dutch and shows how such a lexicon architecture can be used for both language generation and automatic dictionary construction. The work of Calder (1989) and his associates at Edinburgh and Stuttgart on &amp;quot;paradigmatic morphology&amp;quot; also fits within this tradition in that it invokes a restricted kind of default orthogonal inheritance for morphophonological desc</context>
</contexts>
<marker>Reinhard, Gibbon, 1991</marker>
<rawString>Reinhard, Sabine, and Gibbon, Dafydd (1991). &amp;quot;Prosodic inheritance and morphological generalisations,&amp;quot; In Proceedings, Fifth Conference of the European Chapter of the Association for Computational Linguistics, 131-136.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Graham Russell</author>
<author>Afzal Ballim</author>
<author>John Carroll</author>
<author>Warwick-Armstrong</author>
</authors>
<title>Susan (In press). &amp;quot;A practical approach to multiple default inheritance for unification-based lexicons,&amp;quot;</title>
<journal>Computational Linguistics,</journal>
<volume>18</volume>
<issue>3</issue>
<marker>Russell, Ballim, Carroll, Warwick-Armstrong, </marker>
<rawString>Russell, Graham; Ballim, Afzal; Carroll, John; and Warwick-Armstrong, Susan (In press). &amp;quot;A practical approach to multiple default inheritance for unification-based lexicons,&amp;quot; Computational Linguistics, 18(3).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lenhart K Schubert</author>
<author>Chung Hee Hwang</author>
</authors>
<title>An episodic knowledge representation for narrative texts.&amp;quot; In</title>
<date>1989</date>
<booktitle>Proceedings, First International Conference on Principles of Knowledge Representation and Reasoning,</booktitle>
<pages>444--458</pages>
<contexts>
<context position="30324" citStr="Schubert and Hwang (1989)" startWordPosition="4838" endWordPosition="4841">l to represent the consequences of Gricean 4 Compare Gibbon&apos;s (1990a) use of DATR to the same end. 5 See Pustejovsky (1989, 1991). 213 Computational Linguistics Volume 18, Number 2 maxims in a default inheritance network designed for fast (though not necessarily correct) reasoning. Most recent computational linguistic work on pragmatics has tended to turn to general nonstandard logics as tools for the job, rather than their less expressive network relations. Thus Joshi et al. (1984) and Lascarides and Asher (1991) have made the case for nonmonotonic logics in formalizing Gricean maxims, while Schubert and Hwang (1989) show how a probabilistic logic might be used in story understanding. Mercer and Reiter (1982) and Mercer (1988) have employed Reiter&apos;s default logic to capture the behavior of natural language presuppositions. Perrault (1990) uses default logic to express a theory of speech acts, while Appelt and Konolige (1988) have deployed an extension to Moore&apos;s (1985) autoepistemic logic for the same purpose. 5. Concluding Remarks Within computational linguistics, it is possible to see three distinct trends emerging. The first is the increasing employment of monotonic type lattices in unification-based g</context>
</contexts>
<marker>Schubert, Hwang, 1989</marker>
<rawString>Schubert, Lenhart K., and Hwang, Chung Hee (1989). &amp;quot;An episodic knowledge representation for narrative texts.&amp;quot; In Proceedings, First International Conference on Principles of Knowledge Representation and Reasoning, 444-458.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bart Selman</author>
<author>Hector J Levesque</author>
</authors>
<title>The tractability of path-based inheritance,&amp;quot;</title>
<date>1989</date>
<booktitle>IJCAI-89,</booktitle>
<pages>1140--1145</pages>
<contexts>
<context position="10713" citStr="Selman and Levesque 1989" startWordPosition="1807" endWordPosition="1810">ERB &lt;transitive&gt; no 1 Elapse &lt;form&gt; = /elapS e/ Beat &lt;form&gt; = /b e a t/ Figure 2 Monotonic multiple inheritance. VERB &lt;category&gt; = verb &lt;past partic pie&apos; = /e d/ . , 1.1 TRANSITIVE VERB &lt;transitive&gt; = yes INTRANSITIVE VERB &lt;transitive&gt; = no . . Hate &lt;form&gt; = /h a t e/ Beat doree. = /6 e a t/ &lt;past participle&gt; . /e n/ Elapse Expire &lt;form&gt; = /elaps e/ &lt;forgo = /expir e/ Figure 3 Nonmonotonic single inheritance. 208 Walter Daelemans et al. Inheritance in Natural Language Processing considered, consensus has yet to emerge regarding the proper treatment of multiple inheritance with cancellations&amp;quot; (Selman and Levesque 1989, pp. 1140). Unsurprisingly, the problem has given rise to a large, and growing, list of publications in the knowledge representation literature (see, e.g., Horty, Thomason, and Touretzky 1990, and references therein). Almost all of this theoretical work has concerned itself with very simple networks that are only able to say whether or not a monadic property holds of a node in the network. Recently, however, Thomason and Touretzky (1991) have turned their attention to the properties of more expressive networks, potentially capable of encoding what would need to be encoded in any real NLP appl</context>
</contexts>
<marker>Selman, Levesque, 1989</marker>
<rawString>Selman, Bart, and Levesque, Hector J. (1989). &amp;quot;The tractability of path-based inheritance,&amp;quot; IJCAI-89, 1140-1145.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
</authors>
<title>A simple reconstruction of GPSG.&amp;quot;</title>
<date>1986</date>
<booktitle>In COLING-86,</booktitle>
<pages>211--215</pages>
<contexts>
<context position="14549" citStr="Shieber (1986" startWordPosition="2413" endWordPosition="2414">cedence over others has been a continuing concern in the literature (see, e.g., Pullum 1979, especially Section 1.4.1, and references therein). The consensus view, though largely unspoken, among computational linguists currently working with default inheritance networks appears to be that nodes that are close (or identical) to the root(s) of the network should be used to encode that which is regular, &amp;quot;unmarked,&amp;quot; and productive, and that distance from the root(s) should correlate with increasing irregularity, &amp;quot;markedness,&amp;quot; and lack of productivity. At the 2 See Evans (1987), Gazdar (1987), and Shieber (1986a) on the various defaulty characteristics of GPSG. 209 Computational Linguistics Volume 18, Number 2 very least, this is what emerges from their practice. T he differences between the current strands of NLP work in this area are partly philosophical (e.g., as to whether psycholinguistic data could or should be relevant to the structure of the network), partly methodological (e.g., as to whether networks should be built in a formal language designed for the purpose or implemented in an existing computer language), partly technical (e.g., whether a negation operator is useful, or whether orthog</context>
<context position="18302" citStr="Shieber (1986" startWordPosition="2995" endWordPosition="2996">medt (1984) went on to use generic function application to provide one of the earliest illustrations of the descriptive power of default inheritance networks for morphology in a treatment of Dutch verbs, an analysis that is extended to adjectival and nominal forms in De Smedt and de Graaf (1990). In the same paper, the authors indicate how inheritance techniques can be applied to a unification-based formalism called Segment Grammar (Kempen 1987), which is intended to facilitate incremental syntactic processing. Attempts to reconcile inheritance with unification grammars began in the mid1980s. Shieber (1986b, p. 57ff) noted that the provision of lexical &amp;quot;templates&amp;quot; in PATR amounted to a language for defining monotonic multiple inheritance networks. He drew attention to the possibility of adding a nonmonotonic &amp;quot;overwriting&amp;quot; operation to PATR and commented that &amp;quot;the cost of such a move is great, however, because the use 210 Walter Daelemans et al. Inheritance in Natural Language Processing of overwriting eliminates the order independence that is so advantageous a property in a formalism&amp;quot; (1986, p. 60). In a subsequent implementation of PATR, Karttunen (1986) makes all D-PATR templates subject to o</context>
<context position="20325" citStr="Shieber (1986" startWordPosition="3298" endWordPosition="3299">d Wasow (1985) proposed a treatment of lexical organization in which English subcategorization frames and inflectional morphology were handled within a default multiple inheritance network implemented in HPRL. They pointed out that such an approach took care of morphological &amp;quot;blocking&amp;quot; phenomena &amp;quot;largely for free&amp;quot; (1985, p. 267).3 In his 1987 Ph.D. dissertation, Flickinger goes on to provide a monograph length inheritance treatment of the syntactic and morphological information embodied in the English lexicon. His analysis crucially presupposes machinery for multiple default inheritance. Like Shieber (1986b, pp. 60-61), he notes the problem that contradictory attribute values pose for such machinery and entertains the hypothesis that the relevant links &amp;quot;should be disjoint in the set of attributes for which they support inheritance&amp;quot; (1987, p. 61). Flickinger&apos;s thesis is probably the most detailed discursive application of a default inheritance framework to the lexicon. In their paper in the present issue, Flickinger and Nerbonne (in press) extend the analysis further still so as to encompass some of the trickiest and most-debated data in the syntax of English. Pollard and Sag (1987), in the firs</context>
</contexts>
<marker>Shieber, 1986</marker>
<rawString>Shieber, Stuart M. (1986a). &amp;quot;A simple reconstruction of GPSG.&amp;quot; In COLING-86, 211-215.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
</authors>
<title>An Introduction to Unification-Based Approaches to Grammar. Chicago:</title>
<date>1986</date>
<publisher>University of Chicago Press.</publisher>
<contexts>
<context position="14549" citStr="Shieber (1986" startWordPosition="2413" endWordPosition="2414">cedence over others has been a continuing concern in the literature (see, e.g., Pullum 1979, especially Section 1.4.1, and references therein). The consensus view, though largely unspoken, among computational linguists currently working with default inheritance networks appears to be that nodes that are close (or identical) to the root(s) of the network should be used to encode that which is regular, &amp;quot;unmarked,&amp;quot; and productive, and that distance from the root(s) should correlate with increasing irregularity, &amp;quot;markedness,&amp;quot; and lack of productivity. At the 2 See Evans (1987), Gazdar (1987), and Shieber (1986a) on the various defaulty characteristics of GPSG. 209 Computational Linguistics Volume 18, Number 2 very least, this is what emerges from their practice. T he differences between the current strands of NLP work in this area are partly philosophical (e.g., as to whether psycholinguistic data could or should be relevant to the structure of the network), partly methodological (e.g., as to whether networks should be built in a formal language designed for the purpose or implemented in an existing computer language), partly technical (e.g., whether a negation operator is useful, or whether orthog</context>
<context position="18302" citStr="Shieber (1986" startWordPosition="2995" endWordPosition="2996">medt (1984) went on to use generic function application to provide one of the earliest illustrations of the descriptive power of default inheritance networks for morphology in a treatment of Dutch verbs, an analysis that is extended to adjectival and nominal forms in De Smedt and de Graaf (1990). In the same paper, the authors indicate how inheritance techniques can be applied to a unification-based formalism called Segment Grammar (Kempen 1987), which is intended to facilitate incremental syntactic processing. Attempts to reconcile inheritance with unification grammars began in the mid1980s. Shieber (1986b, p. 57ff) noted that the provision of lexical &amp;quot;templates&amp;quot; in PATR amounted to a language for defining monotonic multiple inheritance networks. He drew attention to the possibility of adding a nonmonotonic &amp;quot;overwriting&amp;quot; operation to PATR and commented that &amp;quot;the cost of such a move is great, however, because the use 210 Walter Daelemans et al. Inheritance in Natural Language Processing of overwriting eliminates the order independence that is so advantageous a property in a formalism&amp;quot; (1986, p. 60). In a subsequent implementation of PATR, Karttunen (1986) makes all D-PATR templates subject to o</context>
<context position="20325" citStr="Shieber (1986" startWordPosition="3298" endWordPosition="3299">d Wasow (1985) proposed a treatment of lexical organization in which English subcategorization frames and inflectional morphology were handled within a default multiple inheritance network implemented in HPRL. They pointed out that such an approach took care of morphological &amp;quot;blocking&amp;quot; phenomena &amp;quot;largely for free&amp;quot; (1985, p. 267).3 In his 1987 Ph.D. dissertation, Flickinger goes on to provide a monograph length inheritance treatment of the syntactic and morphological information embodied in the English lexicon. His analysis crucially presupposes machinery for multiple default inheritance. Like Shieber (1986b, pp. 60-61), he notes the problem that contradictory attribute values pose for such machinery and entertains the hypothesis that the relevant links &amp;quot;should be disjoint in the set of attributes for which they support inheritance&amp;quot; (1987, p. 61). Flickinger&apos;s thesis is probably the most detailed discursive application of a default inheritance framework to the lexicon. In their paper in the present issue, Flickinger and Nerbonne (in press) extend the analysis further still so as to encompass some of the trickiest and most-debated data in the syntax of English. Pollard and Sag (1987), in the firs</context>
</contexts>
<marker>Shieber, 1986</marker>
<rawString>Shieber, Stuart M. (1986b). An Introduction to Unification-Based Approaches to Grammar. Chicago: University of Chicago Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert F Simmons</author>
</authors>
<title>Semantic networks: Their computation and use for understanding English sentences.&amp;quot; In Computer Models of Thought and Language, edited by</title>
<date>1973</date>
<pages>63--113</pages>
<location>San Francisco: Freeman.</location>
<contexts>
<context position="27168" citStr="Simmons (1973)" startWordPosition="4361" endWordPosition="4362">nowledge representation was principally driven by natural language concerns right up to the beginning of the decade, one would have expected substantial progress to have been made in the 1980s on knowledge representation support for natural language semantics. This seems not to have been the case (Brachman 1990; p. 1088). If one compares the progress made in morphology and syntax in NLP in the 1980s, then Brachman&apos;s judgment is surely correct. And yet there has been a steady tradition of using semantic networks in the service of natural language understanding that goes back at least as far as Simmons (1973). Much of the work in this tradition has concerned itself with domain and world knowledge relevant to disambiguation and to drawing inferences from what is said, but not to the semantic representations of words, phrases and utterances per se. Exceptions to this generalization are not hard to find, however. For example, Barnett et al. (1990) use the same language (CycL) for linguistic semantic representation as is used in the encyclopedic inheritance network for which they are providing a natural language interface. And Jacobs (1986, 1987) proposes a uniform hierarchical encoding of both lingui</context>
</contexts>
<marker>Simmons, 1973</marker>
<rawString>Simmons, Robert F. (1973). &amp;quot;Semantic networks: Their computation and use for understanding English sentences.&amp;quot; In Computer Models of Thought and Language, edited by Roger C. Schank and Kenneth M. Colby, 63-113. San Francisco: Freeman.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Smolka</author>
</authors>
<title>A feature logic with subsorts,&amp;quot;</title>
<date>1988</date>
<tech>LILOG Report 33, IBM Deutschland,</tech>
<location>Stuttgart.</location>
<contexts>
<context position="21809" citStr="Smolka (1988)" startWordPosition="3530" endWordPosition="3531">nmonotonic formulation of lexical rules (pp. 212-213). A concern to preserve monotonic inheritance in HPSG is likewise evident in more recent work, such as Carpenter and Pollard (1991) and Zajac (this issue). Monotonic multiple inheritance type hierarchies figure in a good deal of recent work in unification-based grammars. Examples include papers by Porter (1987), Emele and Zajac (1990), and Emele et al. (1990), who all use a semantics based on Ait-Kaci (1984); the use of sorts in Unification Categorial Grammar (Moens et al. 1989); the CLE project (Alshawi et al. 1989) and theoretical work by Smolka (1988). Default multiple inheritance also figures centrally in a couple of grammatical frameworks. One is Hudson&apos;s (1984,1990) Word Grammar, and a detailed exposition is provided by Fraser and Hudson in this issue. Word Grammar is a feature-based variant of dependency grammar, one that makes pervasive use of a (multiple) inheritance relation. The latter is unusual in that stipulated exceptions do not automatically override an inherited default: the latter has to be explicitly negated if the grammar requires its suppression (compare Flickinger, Pollard, and Wasow&apos;s (1985) approach to &amp;quot;blocking,&amp;quot; note</context>
</contexts>
<marker>Smolka, 1988</marker>
<rawString>Smolka, G. (1988). &amp;quot;A feature logic with subsorts,&amp;quot; LILOG Report 33, IBM Deutschland, Stuttgart.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Steels</author>
</authors>
<title>Introducing conceptual grammar,&amp;quot;</title>
<date>1978</date>
<tech>Working Paper 176,</tech>
<institution>MIT Al Laboratory,</institution>
<location>Luc</location>
<contexts>
<context position="17357" citStr="Steels (1978)" startWordPosition="2855" endWordPosition="2856">rocess called incremental description refinement, which first determined which descriptions were compatible with an object known to have a set of properties, and then refined this set of descriptions as more properties become known. Subsequent work by Brachman and Schmolze (1985) used PSI-KLONE to translate the ouput of the RUS parser into KL-ONE representations of literal meaning. An inheritance network that the authors refer to as a &amp;quot;syntaxonomy&amp;quot; is used to encode information about syntactic categories. A rather similar view of language processing is to be found in the Conceptual Grammar of Steels (1978) and Steels and De Smedt (1983). This approach adopted a single frame-based grammar representation for a variety of language processing tasks and for all types of linguistic knowledge. General inference mechanisms based on constraint propagation used the frames, organized in inheritance hierarchies, in generation and parsing. De Smedt (1984) went on to use generic function application to provide one of the earliest illustrations of the descriptive power of default inheritance networks for morphology in a treatment of Dutch verbs, an analysis that is extended to adjectival and nominal forms in </context>
</contexts>
<marker>Steels, 1978</marker>
<rawString>Steels, Luc (1978). &amp;quot;Introducing conceptual grammar,&amp;quot; Working Paper 176, MIT Al Laboratory, Cambridge, MA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Luc Steels</author>
<author>Koenraad De Smedt</author>
</authors>
<title>Some examples of frame-based syntactic processing.&amp;quot;</title>
<date>1983</date>
<booktitle>In Een Spyeghel voor G. Jo Steenbergen, edited by Fr. Daems</booktitle>
<pages>293--305</pages>
<location>Leuven: Acco.</location>
<marker>Steels, De Smedt, 1983</marker>
<rawString>Steels, Luc, and De Smedt, Koenraad (1983). &amp;quot;Some examples of frame-based syntactic processing.&amp;quot; In Een Spyeghel voor G. Jo Steenbergen, edited by Fr. Daems and L. Goossens, 293-305. Leuven: Acco.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Richmond H Thomason</author>
</authors>
<title>Inheritance in natural language,&amp;quot;</title>
<date>1991</date>
<booktitle>Unpublished manuscript, Intelligent Systems Programme,</booktitle>
<location>Pittsburgh.</location>
<contexts>
<context position="33009" citStr="Thomason (1991)" startWordPosition="5234" endWordPosition="5235">. The work that has been done to date suggests that while default inheritance is essential for lexical networks, full unrestricted multiple inheritance is probably more of a hindrance than a help. It looks as if some version of orthogonal or prioritized inheritance will be sufficient for lexical knowledge representation. Moore and Kaplan (in Whitelock et al. 1987, pp. 62-63) have noted that lexical defaults amount to default specification (as opposed to the conjectural defaults of standard AT knowledge representation) and that they often substitute for (large) finite specifications. Likewise, Thomason (1991) has referred to lexical defaults as &amp;quot;a priori in a sense&amp;quot; or &amp;quot;at least stipulative or conventional&amp;quot; and he goes on to point out that any nonmonotonic lexical application can be converted to a monotonic one, albeit at the cost of scale. These considerations provide some limited grounds for optimism with regard to the tractability and mathematical probity of (future) languages for lexical representation. However, two cautionary notes are in order: firstly, the inheritance relation itself is not the sole source of intractability, and, secondly, existing work on inheritance lexicons has been almo</context>
</contexts>
<marker>Thomason, 1991</marker>
<rawString>Thomason, Richmond H. (1991). &amp;quot;Inheritance in natural language,&amp;quot; Unpublished manuscript, Intelligent Systems Programme, Pittsburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Richmond H Thomason</author>
<author>David S Touretzky</author>
</authors>
<title>Inheritance theory and networks with roles.&amp;quot;</title>
<date>1992</date>
<booktitle>In Principles of Semantic Networks: Explorations in the Representation of Knowledge, edited by John Sowa,</booktitle>
<pages>231--266</pages>
<publisher>Morgan Kaufmann.</publisher>
<location>San Mateo:</location>
<marker>Thomason, Touretzky, 1992</marker>
<rawString>Thomason, Richmond H., and Touretzky, David S. (1992). &amp;quot;Inheritance theory and networks with roles.&amp;quot; In Principles of Semantic Networks: Explorations in the Representation of Knowledge, edited by John Sowa, 231-266. San Mateo: Morgan Kaufmann.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David S Touretzky</author>
</authors>
<title>The Mathematics of Inheritance Systems. London/Los Altos:</title>
<date>1986</date>
<publisher>Pitman/Morgan Kaufmann.</publisher>
<contexts>
<context position="12910" citStr="Touretzky (1986)" startWordPosition="2161" endWordPosition="2162">tance networks layered on top of each other. On another strategy, a given property, or set of properties, may potentially be inherited from more than one parent node, but the parents are ordered: the first parent in the ordering that is able to supply the property wins, and contradiction is thus avoided. We will refer to this strategy as &amp;quot;prioritized inheritance.&amp;quot; The use of inheritance networks in current NLP comes from three rather separate traditions. The first is that of &amp;quot;semantic nets&amp;quot; in Al, which goes back to Quillian (1968) through Fahlman&apos;s (1979) NETL to the late 1980s monographs by Touretzky (1986) and Etherington (1988). The second is that of data abstraction in programming languages, which has led to (a) object-orientation in computer science with its notions of classes and inheritance as embodied in such languages as Smalltalk, Simula, Flavors, CLOS and C++, and (b) the use of type hierarchies, which have become widely seen in unification-oriented NLP since the appearance of AR-Kaci (1984) and Cardelli (1984). Of necessity, the type hierarchy work in NLP has remained strictly monotonic. The third is the notion of &amp;quot;markedness&amp;quot; in linguistics, which originates in the Prague School phon</context>
</contexts>
<marker>Touretzky, 1986</marker>
<rawString>Touretzky, David S. (1986). The Mathematics of Inheritance Systems. London/Los Altos: Pitman/Morgan Kaufmann.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Carl Vogel</author>
<author>Fred Popowich</author>
</authors>
<title>Head-driven phrase structure grammar as an inheritance hierarchy.&amp;quot;</title>
<date>1990</date>
<booktitle>In Proceedings, Workshop on Inheritance in Natural Language Processing, edited by Walter Daelemans and Gerald Gazdar,</booktitle>
<pages>104--113</pages>
<publisher>ITK,</publisher>
<location>Tilburg.</location>
<contexts>
<context position="24663" citStr="Vogel and Popowich (1990)" startWordPosition="3977" endWordPosition="3980">agments of Arabic, English, German, and Japanese included in Evans and Gazdar (1990). All of our discussion thus far has presupposed the use of inheritance networks to store essentially static information. But, following the precedent set by Brachman and Schmolze (1985), a number of researchers have begun to explore their utility in language processing itself. Thus, for example, van der Linden (this issue) exploits the structure of the network in order to avoid premature lexical disambiguation and to identify lexical preferences during incremental parsing with a Lambek categorial grammar. And Vogel and Popowich (1990) add a new twist to the now familiar &amp;quot;parsing as deduction&amp;quot; strategy: instead of construing parsing as, for example, inference in a Horn clause logic, they describe an HPSG parser that operates by means of path-based inference over an inheritance network. 3. Phonology, Orthography, and Morphophonology Computational phonology is perhaps the youngest and least studied branch of NLP. But notions of default have played such a prominent role in linguistic discussion of the area that it is not surprising that default inheritance networks have found a place in this subfield right from the start. Thus</context>
</contexts>
<marker>Vogel, Popowich, 1990</marker>
<rawString>Vogel, Carl, and Popowich, Fred (1990). &amp;quot;Head-driven phrase structure grammar as an inheritance hierarchy.&amp;quot; In Proceedings, Workshop on Inheritance in Natural Language Processing, edited by Walter Daelemans and Gerald Gazdar, 104-113. ITK, Tilburg.</rawString>
</citation>
<citation valid="true">
<authors>
<author>van der Linden</author>
</authors>
<title>Incremental processing and the hierarchical lexicon,&amp;quot;</title>
<date>1992</date>
<journal>Computational Linguistics,</journal>
<volume>18</volume>
<issue>2</issue>
<pages>219--235</pages>
<location>Erik-Jan</location>
<marker>van der Linden, 1992</marker>
<rawString>van der Linden, Erik-Jan (1992). &amp;quot;Incremental processing and the hierarchical lexicon,&amp;quot; Computational Linguistics, 18(2), 219-235.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ralph M Weischedel</author>
</authors>
<title>A hybrid approach to representation in the Janus natural language processor.&amp;quot;</title>
<date>1989</date>
<booktitle>In ACL Proceedings, 27th Annual Meeting,</booktitle>
<pages>193--202</pages>
<contexts>
<context position="28568" citStr="Weischedel (1989)" startWordPosition="4569" endWordPosition="4570">r et al. (1989) employ two separate inheritance networks, one for linguistic semantic knowledge and the other for conceptual knowledge, both being implemented in a KL-ONE derivative called SB-ONE. Several of the inheritance-based linguistic knowledge representation formalisms that we have introduced in earlier sections are being used for semantic purposes. Thus Fraser and Hudson (this issue) make crucial use of the Word Grammar inheritance network to reconstruct the meanings of various types of constituent (e.g. verb phrases) that cannot be syntactically reconstructed in a dependency grammar. Weischedel (1989) uses the taxonomic language NKL (based on KL-ONE) to express selectional restrictions, while Andry et al. (in press) use DATR for the same purpose. Cahill and Evans (1990) use DATR to build up complex lambda calculus representations in the lexicon of a message understanding system. Briscoe et al. (1990) use a version of PAIR augmented with defeasible templates to implement a default orthogonal inheritance network for a Pustejovskian analysis of metonymic sense extension in lexical semantics (e.g. interpreting the film in Enjoy the film! as watching the film).5 Their approach is further elabor</context>
</contexts>
<marker>Weischedel, 1989</marker>
<rawString>Weischedel, Ralph M. (1989). &amp;quot;A hybrid approach to representation in the Janus natural language processor.&amp;quot; In ACL Proceedings, 27th Annual Meeting, 193-202.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Peter Whitelock</author>
<author>McGee Wood</author>
<author>Somers Mary</author>
<author>L Harold</author>
<author>Rod L Johnson</author>
<author>Paul Bennett</author>
</authors>
<title>Linguistic Theory and Computer Applications.</title>
<date>1987</date>
<publisher>Academic Press.</publisher>
<location>London:</location>
<contexts>
<context position="32759" citStr="Whitelock et al. 1987" startWordPosition="5197" endWordPosition="5200">ferent levels of description; and (v) interaction—where a lexical property at one level of description (e.g. syntactic gender) depends on a lexical property at another level of description (e.g. the phonology of a word-final vowel), then this can be stated. The work that has been done to date suggests that while default inheritance is essential for lexical networks, full unrestricted multiple inheritance is probably more of a hindrance than a help. It looks as if some version of orthogonal or prioritized inheritance will be sufficient for lexical knowledge representation. Moore and Kaplan (in Whitelock et al. 1987, pp. 62-63) have noted that lexical defaults amount to default specification (as opposed to the conjectural defaults of standard AT knowledge representation) and that they often substitute for (large) finite specifications. Likewise, Thomason (1991) has referred to lexical defaults as &amp;quot;a priori in a sense&amp;quot; or &amp;quot;at least stipulative or conventional&amp;quot; and he goes on to point out that any nonmonotonic lexical application can be converted to a monotonic one, albeit at the cost of scale. These considerations provide some limited grounds for optimism with regard to the tractability and mathematical p</context>
</contexts>
<marker>Whitelock, Wood, Mary, Harold, Johnson, Bennett, 1987</marker>
<rawString>Whitelock, Peter; McGee Wood, Mary; Somers, Harold L.; Johnson, Rod L.; and Bennett, Paul (1987). Linguistic Theory and Computer Applications. London: Academic Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Remi Zajac</author>
</authors>
<title>Inheritance and constraint-based grammar formalisms,&amp;quot;</title>
<date>1992</date>
<journal>Computational Linguistics,</journal>
<volume>18</volume>
<issue>2</issue>
<pages>159--182</pages>
<marker>Zajac, 1992</marker>
<rawString>Zajac, Remi (1992). &amp;quot;Inheritance and constraint-based grammar formalisms,&amp;quot; Computational Linguistics, 18(2), 159-182.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>