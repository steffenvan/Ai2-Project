<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.992457333333333">
Inherently Reversible Grammars,
Logic Programming
and Computability
</title>
<author confidence="0.931511">
Marc Dymetman
</author>
<affiliation confidence="0.858507">
CCRIT, Communications Canada
</affiliation>
<address confidence="0.7802455">
1575 boulevard Chomedey
Laval (Quebec) H7V 2X2, Canada
</address>
<email confidence="0.9932">
dymetman@ccrit.doc.ca
</email>
<sectionHeader confidence="0.955619" genericHeader="abstract">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.999890388888889">
This paper attempts to clarify two distinct notions
of &amp;quot;reversibility&amp;quot;: (i) Uniformity of implementa-
tion of parsing and generation, and (ii) reversibil-
ity as an inherent (or intrinsic) property of gram-
mars. On the one hand, we explain why gram-
mars specified as definite programs (or the vari-
ous related &amp;quot;unification grammars&amp;quot;) lead to uni-
formity of implementation. On the other hand, we
define different intrinsic reversibility properties for
such grammars—the most important being finite
reversibility, which says that both parsing and gen-
eration are finitely enumerable (see text)— and give
examples and counter-examples of grammars which
possess or do not possess these intrinsic properties.
We also show that, under a certain &amp;quot;moderation&amp;quot;
condition on linguistic description, finite enumer-
ability of parsing is equivalent to finite enumerabil-
ity of generation.
</bodyText>
<sectionHeader confidence="0.999133" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999409693877551">
From the linguist&apos;s point of view, a grammar is a
formal device which defines a recursively enumer-
able set of well-formed linguistic structures, each
having, among other aspects, a phonological con-
tent (or, when dealing with written text, a string
content) and a semantic content. Such a device is
completely neutral as regards its uses for parsing
(recovering semantic content from string content)
or generation (recovering string content from se-
mantic content).
From the computational linguist&apos;s point of view,
on the other hand, the problem is how to imple-
ment such a grammar both as a parsing program
and as a generation program, in such a way that
these programs exactly reflect the content of the
grammar. This we will call the reversibility prob-
lem.
Let us assume, for specificity, that the grammar
has been presented as a definite program (a Prolog
program).&apos; Then the reversibility problem has a
simple solution: use a complete interpreter for defi-
nite programs—for instance a top-down interpreter
having a breadth-first search procedure2—and di-
rectly use the grammar as the program both for
parsing and for generation. In the parsing mode,
for any given string x, the program will enumerate
all semantics yi, y2, ... assigned to it by the gram-
mar, and similarly, in the generation mode, for any
given semantics y, the program will enumerate all
semantics xl, x2,... assigned to it by the grammar.
This is a striking property of definite programs:
they are reversible in the sense that they naturally
lead to uniformity of implementation of the parsing
and generation modes (see §4).
So the reversibility problem is solved, and we can
spend the next few years skimming through Fodor&apos;s
(not Jerry&apos;s) guides in travel bookstores?
Not quite. First, the standard depth-first inter-
preter for definite programs is an incomplete one,
and this problem must be circumvented in some
way. Second, and more crucially, even when us-
ing a complete interpreter, parsing (and similarly
generation) does not in general terminate: the pro-
gram may well enumerate yl, y2, ... ad infinitum.
This is even true if, in fact, there are only a finite
number of solutions yi , y2, ... , yk, or even, in the
extreme case, no solution at all: the program may
not be &amp;quot;aware&amp;quot; that it has at some point already
exhausted all the solutions that it will eventually
</bodyText>
<footnote confidence="0.6614994">
1We could have made some other choice, for instance
some unification grammar formalism. The advantage of us-
ing definite programs in the present discussion is that they
embody the whole unification paradigm in its purest form,
that unification of terms is conceptually simpler (and less
prone to misunderstandings) than unification of DAGs, and
that the denotational and operational semantics of definite
programs have been thoroughly studied.
2See e.g. [7, p. 59] and section §2.1.3. See also [19] in this
volume for a related approach.
</footnote>
<page confidence="0.990086">
20
</page>
<bodyText confidence="0.984033936170213">
find, and go on eternally looking for new solutions.
The source of this problem can be more or less
severe: It may simply be due to the grammar&apos;s
implementation as&apos;a certain program, or it may be
intrinsic to the grammar.
If it is not intrinsic to the grammar, one may
attempt some kind of program transformation on
the grammar—for &apos;instance a local transformation
as goal reordering in clause bodies [4, 16], or a
global transformation as left-recursion elimination
[5, 3] 3 —in order to get a parsing program which
displays a finite behavior.4 If such a transforma-
tion is possible in principle, we say that, intrinsi-
cally, the grammar has a finitely enumerable pars-
ing problem.5 One example of a class of grammars
which respect this crucial condition is provided by
offline-parsable DCGs, once compiled as definite
programs (see [9]).6
We have limited the former discussion to the case
of parsing. The case of generation is treated in a
parallel fashion, and one can similarly define the
conditions in which a grammar is said to have an in-
trinsically finitely enumerable generation problem.
When a grammar is such that it has a finitely enu-
merable parsing problem and a finitely enumerable
generation problem, we call the grammar inherently
finitely reversible.
When this is the case, it is by definition possible
to find a program P„ for parsing and a (not nec-
essarily identical) program Pg for generation such
that, for any string x, Pi, enumerates all associated
semantics y and terminates, and, for any seman-
tics y, Pg enumerates all associated strings x and
terminates.
Inherent finite reversibility is the concept which,
in my opinion, permit us to capture formally the
intuitive notion that a certain grammar is, or is
not, &amp;quot;reversible&amp;quot;.
30r more generally&apos;, any transformation exploiting the-
orems provable of the, grammar. Another instance of this
technique is provided by the addition of conservative guides
in [5], which &amp;quot;strengthen&amp;quot; the grammar on the basis of prop-
erties inferable from its form.
4 Another popular approach is to use a special-purpose
interpreter, exploiting i properties of the grammar known a
priori. [18] and [14] use this approach in the case of gener-
ation (see below).
</bodyText>
<footnote confidence="0.98197625">
5The description is simplified; see §3 for the exact
definition.
6 See also [17] for a discussion of offline-parsability in the
context of generation.
</footnote>
<sectionHeader confidence="0.9784245" genericHeader="introduction">
2 Definite programs and
computation
</sectionHeader>
<subsectionHeader confidence="0.983435">
2.1 Denotational and operational se-
</subsectionHeader>
<bodyText confidence="0.8566958">
mantics of a definite program;
complete and incomplete inter-
preters
A definite program P is a finite set of clauses of the
form (non-unit clauses):
</bodyText>
<equation confidence="0.770331">
ATI, • • • , Tn) 4—
Pi(Tii, • • • Tini) • • • Pm(Tmi • • • ,Tmn..)
or of the form (unit clauses):
ATI, • • • ,Tn) 4--
</equation>
<bodyText confidence="0.999896714285714">
where the the p,pi are predicate symbols and the
Tij are terms over a certain Herbrand universe
of ground terms H.
We will suppose that, among the predicates p
defined by P, one, r, is privileged and plays the
role of the &amp;quot;main predicate&amp;quot; in the program. We
will assume that r is of arity one.7
</bodyText>
<subsectionHeader confidence="0.913453">
2.1.1 Denotational semantics
</subsectionHeader>
<bodyText confidence="0.9962634375">
The denotational, or declarative, semantics of pro-
gram P can be defined as the least fixed point of a
certain operator on Herbrand interpretations which
we will not describe here (see [7]). Informally, the
denotations of the predicate symbols p are defined
as n-ary relations p(xi, , xn) over H, built as the
limit of a bottom-up process which starts from the
unit clauses and uses the non-unit clauses to add
new instances to each relation.
In particular, this process defines the unary rela-
tion r(x) on H, which we shall call the denotational
semantics of the main predicate r relative to pro-
gram P.
Let T be a term over H; We define the special-
ization of r(X) on T as the relation rT(x) on H
defined by:
</bodyText>
<equation confidence="0.475247">
rT(x)4.1 r(x) AxET
</equation>
<bodyText confidence="0.9821955">
where C is the relation of subsumption. In case the
term T is a variable X, we say that X is the trivial
specialization, and we note that the relation rx(x)
is identical to the relation r(x).
</bodyText>
<footnote confidence="0.9955545">
7This assumption permits to simplify the exposition, but
is not otherwise necessary.
</footnote>
<page confidence="0.999301">
21
</page>
<subsectionHeader confidence="0.780903">
2.1.2 Operational semantics
</subsectionHeader>
<bodyText confidence="0.9999146">
While the denotational semantics of P is an in-
trinsic property of P, its operational semantics is
defined relative to some interpreter.
For our purposes, we will informally define an
interpreter as a computational mechanism:
</bodyText>
<equation confidence="0.669886">
intpr(P,r(T))
</equation>
<bodyText confidence="0.95684825">
which is input a definite program P, as well as a
query ?r(T)—where r is P&apos;s main predicate and
T a term over H—and which outputs a finite or
infinite &amp;quot;list of answers&amp;quot;:
Tk,...
The Tk&apos;s are terms over H, ground or not, whose
ground instances provide the &amp;quot;solutions&amp;quot; to query
?r(T). If the list of answers is infinite, the inter-
preter will not stop; If it is finite the interpreter
may or may not stop: if it does, we will say that
the interpreter terminates on query ?r(T).
Consider now the relation 4, on H defined by:
</bodyText>
<equation confidence="0.989695">
r(x) T1 VxE7&apos;2V•-•VxETkV•-•
</equation>
<bodyText confidence="0.9304313">
We say that 4. is the operational semantics of the
main predicate r of P, for specialization T, relative
to interpreter intpr.
Keeping the same notations as above, consider
now the denotational semantics r(x) of r relative
to P, and consider its specialization rT(x).
Interpreter intpr is said to be sound if one has,
for any P, r, T:
VX E H 74(x) rT(x);
and to be complete if:
</bodyText>
<equation confidence="0.873456">
Vx E H rT(x) 74(x).
</equation>
<bodyText confidence="0.999895333333333">
the branches—maybe leading to success—to the
right of this branch in the search-tree [7, pp. 59-60].
By contrast, a top-down, breadth-first inter-
preter, i.e. one which explores nondeterministic
choices (between the different clauses competing for
resolution of the same atomic goal) in parallels is
complete [7, pp. 59].
The naive bottom-up interpreter, which in
essence directly calculates the denotational seman-
tics of P, and filters a posteriori the semantics r(x)
through the constraint that the solutions unify with
T, is also a complete algorithm.
</bodyText>
<subsectionHeader confidence="0.99535">
2.2 Computational behavior of a
</subsectionHeader>
<bodyText confidence="0.961968615384615">
definite program relative to an
interpreter
We now consider a program P, having r as main
predicate, the denotation of r relative to P being
the relation r(x) on H. We also consider a special-
ization T, i.e. a term on H.
We will compare the denotational content of P
to its computational behavior, and describe three
possibilities: (i) P enumerates r on T, (ii) P dis-
covers r on T, and (iii) P finitely enumerates r on
T. The interpreter is supposed to be fixed before-
hand.
We say that:
</bodyText>
<listItem confidence="0.932935142857143">
• P enumerates r on specialization T if:
VX E H &lt;=;., rT(x),
in other words, if its list of answers:
T1, T2, • •Tk • • •
exactly &amp;quot;covers&amp;quot; the denotational semantics
rT9
• P discovers r on specialization T if:
</listItem>
<bodyText confidence="0.9555745">
Soundness is a minimal requirement for an in-
terpreter, and we will always assume it, but com-
pleteness is a requirement which is not always met
in practice.
</bodyText>
<subsectionHeader confidence="0.415036">
2.1.3 Complete and incomplete inter-
preters
</subsectionHeader>
<bodyText confidence="0.9978845">
The &amp;quot;standard&amp;quot; interpreter for definite programs
uses a top-down, depth-first search algorithm. It
is sound but not complete. Its non-completeness is
due to the fact that it is depth-first: if its search-
tree contains infinite branches, the interpreter will
be &amp;quot;caught&amp;quot; in the first one and will never explore
</bodyText>
<listItem confidence="0.9998328">
1. P enumerates r on T;
2. If rT is the uniformly false relation on H,
then P terminates on T.1°
• P finitely enumerates r on specialization T if:
1. P enumerates r on T;
</listItem>
<bodyText confidence="0.914829571428571">
80r, alternatively, uses a fair search rule, i.e. one which
&amp;quot;shares its attention&amp;quot; among all paths in the search-tree.
°This will always be the case if the interpreter is sound
and complete, as seen in §2.1.2.
1° Therefore, when rT is uniformly false, the list of answers
is empty, and the program is &amp;quot;aware&amp;quot; of this fact (i.e. it
terminates).
</bodyText>
<page confidence="0.979427">
22
</page>
<bodyText confidence="0.851267285714286">
2. P terminates on T.11
We simply say that P enumerates (discovers,
finitely enumerates) r if P enumerates (discovers,
finitely enumerates) r on the trivial specialization
X.
We have the obvious entailments:
P finitely enumerates r on T P discovers
</bodyText>
<listItem confidence="0.938361">
• on T P enumerates r on T.
</listItem>
<bodyText confidence="0.999914588235294">
It is often the case that one is interested in the
computational properties of a given definite pro-
gram relative to a certain class of specializations.
For instance, when using a grammar—given as a
definite program—for parsing, one will consider all
queries where some of the variables are ground (the
string to parse) and others (the semantic form) are
not, and one will want to consider the computa-
tional properties Of the program relative to this
class of specializations. When using the definite
program for generation, one will be interested in
another class of specializations, and will want to
consider the computational properties of the pro-
gram relative to that class of specializations.
Let S = {T} be a set of (not necessarily ground)
terms on H, indeed by a finite or infinite set I.
We call S a class of specializations. We say that:
</bodyText>
<listItem confidence="0.988277666666667">
• P enumerates r on S if, for all T E S, P
enumerates r on T;
• P discovers r on S if, for all TE S,P discov-
ers r on T;
• P finitely enumerates r on S if, for all T E S,
P finitely enumerates r on T.
</listItem>
<bodyText confidence="0.998888">
The mutual entailments between these proper-
ties are similar to the ones given in (1).
</bodyText>
<subsectionHeader confidence="0.9903445">
2.3 Intrinsic computational proper-
ties of a definite program
</subsectionHeader>
<bodyText confidence="0.9999574">
Let $ be a class of specializations, and let r(x)
be an arbitrary unary relation on H. We suppose
here that programs are evaluated with respect to
a sound and complete interpreter, which has been
fixed once and for all, and we say that:
</bodyText>
<listItem confidence="0.997469">
• r is enumerable on S if there exists a definite
program P which enumerates r on S.
• r is discoverable on S if there exists a definite
program P which discovers r on S.
</listItem>
<bodyText confidence="0.96868575">
11In particular, the relation rT is, loosely speaking,
&amp;quot;finitely representable as a union of terms T1, 7&apos;2, • • • Ti,&amp;quot; and
the program is &amp;quot;aware&amp;quot;, at a certain point, that it has ex-
hausted the possible answers.
</bodyText>
<listItem confidence="0.836401">
• r is finitely enumerable on S if there exists a
definite program P which finitely enumerates
r on S.
</listItem>
<bodyText confidence="0.8798227">
These three notions, taken together, constitute a
&amp;quot;computability hierarchy&amp;quot; where enumerability is
the weakest condition, discoverability is an inter-
mediary condition, and finite enumerability is the
strongest condition. These computability condi-
tions can be described more intuitively in the fol-
lowing way:12
• r is enumerable on S if there exists a program
P such that, for any TE S,P is able, given
infinite time, to find terms T1, T2 , • • • such that:
</bodyText>
<equation confidence="0.8169755">
Vx E H r(x) Ax CT ..4=&gt;
x C T1 V x C T2 V • •
</equation>
<listItem confidence="0.994654888888889">
• r is discoverable on S if there exists a program
P which is furthermore able to decide in finite
time, for any T E S, if there actually exists an
x such that:
r(x)Ax CT
• r is finitely enumerable on S if there exists a
program P which is furthermore able to find in
finite time, for any T E S, terms Ti , T2, • • • , Tk
such that:
</listItem>
<bodyText confidence="0.993657142857143">
Vx H r(x) AxE T -4=&gt;
sET1VxET2-•-\./xEn
Let {X} be the set having for only element the
trivial specialization X; {X} is called the trivial
class of specializations. We will simply say that r
is enumerable (resp. discoverable, finitely enumer-
able) if r is enumerable (resp. discoverable, finitely
enumerable) on the trivial class {X}.
Let G = H be the set of all ground terms of H. G
is called the class of ground specializations. The fol-
lowing properties—which we will not prove here—
establish links between the notions that we have
just defined and the classical notions of recursively
enumerable relations and recursive relations:
</bodyText>
<listItem confidence="0.73784775">
• is a recursively enumerable relation on H
if r is enumerable on the trivia/ class of
specializations {X} ; if thiS is the case, then (2)
for any class of specializations S, r is enu-
merable on S.
12 Note that these definitions critically depend on the rel-
ative scopes of quantifiers 3P VT E S . : it is essential
that program P be the same for all specializations T in S.
</listItem>
<equation confidence="0.639148">
(1)
</equation>
<page confidence="0.979489">
23
</page>
<bodyText confidence="0.9961245">
r is a recursive relation on H iff r is discov- (3)
erable on the class of ground specializations
g if r is finitely enumerable on the class of
ground specializations G .
</bodyText>
<sectionHeader confidence="0.4979365" genericHeader="method">
3 Grammars and their com-
putational uses
</sectionHeader>
<bodyText confidence="0.998491">
Let X#Y denote, in infix notation, the term
#(X, Y). In the context of this paper, we take
a grammar to be a definite program G having as
its main predicate the unary predicate r, and we
will assume that the clauses defining r are of the
form:
</bodyText>
<equation confidence="0.831093">
r(X#Y) 4-- • • •
</equation>
<bodyText confidence="0.99344475">
X will be called the &amp;quot;p-parameter&amp;quot;, Y the &amp;quot;g-
parameter&amp;quot;. Generally, the p-parameter will rep-
resent a character string, and the g-parameter a
semantic form.13
</bodyText>
<subsectionHeader confidence="0.999612">
3.1 Six computational problems
</subsectionHeader>
<bodyText confidence="0.9997092">
A grammar can be used either to enumerate well-
formed structures or to check whether certain fully
instantiated values of the parameters can be ac-
cepted. We distinguish six computational prob-
lems (grouped into four types) which can be solved
with a grammar: p-enumeration, p-acceptation,
g-enumeration, g-acceptation, bi-enumeration, bi-
acceptation. These problems are defined, together
with comments on their computational proper-
ties, using the terminology of §2.3. This per-
mits us to characterize the different positions a
given grammar can occupy on the &amp;quot;computability
hierarchy&amp;quot; —enumerability/discoverability/finite
enumerability—relatively to each of these prob-
lems.
</bodyText>
<subsubsectionHeader confidence="0.65272">
3.1.1 p-enumeration and p-acceptation
</subsubsectionHeader>
<bodyText confidence="0.955843253968254">
The p-enumeration problem or parsing problem is
the problem of enumerating, for any fixed ground
term x, all ground terms y such that r(x#y). The
p-acceptation problem or decision problem for pars-
ing is the problem of checking, for any fixed ground
term x, whether there exists a ground term y such
that r(x#y) is true.
The same specialization class is associated with
both these problems, namely the class GP =
{x#Y}zEff consisting in all the terms x#Y where
13We thus take r to be a unary relation which &amp;quot;encodes&amp;quot;
a binary relation. This is unessential, but permits us to use
the concepts of the previous section, developed for unary re-
lations, without having to generalize them to n-ary relations.
x is any ground term, and Y is a certain variable
(whose name is indifferent).
Let&apos;s consider in turn, with respect to GP, the
different positions the grammar—or equivalently,
its denotational semantics r—can occupy on the
computational hierarchy, from strongest to weak-
est:
Finite enumerability When r is finitely enu-
merable on gr , it is in theory possible to find
a program P such that, for any given (ground)
value x of the p-parameter (the string), the pro-
gram enumerates all the solutions to the parsing
problem and terminates. These solutions are given
implicitly as a finite list of answers TY1, , TYk:
the TYi&apos;s are terms whose ground instances y are
the looked-for values of the g-parameter (the se-
mantics associated with string x by the grammar).
We also say that, with the grammar at hand, p-
enumeration is finitely enumerable, or simply, that
parsing is finitely enumerable. This is an inher-
ent property of the grammar, and, in practice, this
property does not necessarily entail that finding a
program P to exploit will be obvious.&amp;quot; For in-
stance, offline-parsable grammars [9] can be shown
to possess a finitely enumerable parsing problem,
but algorithms which are able to make use of this
property are by no means trivial [9, 13, 415
Discoverability If r is not finitely enumerable
on GP, it may still be discoverable on P. By
definition, this means that it is possible to find a
program P such that, for any given (ground) value
x of the p-parameter, if there is no value y of the
g-parameter corresponding to x, then the program
will &amp;quot;recognize&amp;quot; this fact in finite time and termi-
nate with an empty list of answers; if, on the other
hand, there are solutions y corresponding to x, then
the program will enumerate them, but maybe not
terminate. If this property holds, we also say that
with the grammar at hand, p-enumeration is dis-
coverable, or, simply, parsing is discoverable. One
can easily prove (although we will not do it here)
that this property is equivalent to the decidability
(in the classical sense) of the p-acceptation prob-
lem. In other words:
14 See footnote 17.
15 These papers do not use the concept (or, a fortiori, the
terminology) &amp;quot;finite entunerability of parsing&amp;quot;, which, to my
knowledge, appears here for the first time (see however [6],
for the related notion of &amp;quot;Universal Parsing Problem&amp;quot;).
</bodyText>
<page confidence="0.997401">
24
</page>
<construct confidence="0.9729535">
p-enumeration is discoverable if and only
if p-acceptation is decidable.&amp;quot;
</construct>
<bodyText confidence="0.9992855">
Enumerability By the definition of a gram-
mar as being a recursively enumerable mechanism,
and by property (2), r is enumerable on any spe-
cialization class, and in particular on P.
</bodyText>
<subsubsectionHeader confidence="0.7252">
3.1.2 g-enumeration and g-acceptation
</subsubsectionHeader>
<bodyText confidence="0.9952535">
The g-enumeration &apos;problem or generation problem
is the problem of enumerating, for any fixed ground
term y, all ground terms x such that r(x#y). The
g-acceptation problem or decision problem for gen-
eration is the problem of checking, for any fixed
ground term y, whether there exists a ground term
x such that r(x#y) is true.
The specialization class is associated with both
these problems is the class gg = pc#0„, con-
sisting in all the terms X#y where y is any ground
term, and X is a certain variable (whose name is
indifferent).
The situation is exactly symmetrical to the case
of p-enumeration and p-acceptation, and we can
define, in the same way, the notions: &amp;quot;generation
is finitely enumerable&amp;quot; and &amp;quot;generation is discover-
able&amp;quot; (which is equivalent to &amp;quot;g-acceptation is de-
cidable&amp;quot;).
</bodyText>
<subsectionHeader confidence="0.919654">
3.1.3 bi-enumeration
</subsectionHeader>
<bodyText confidence="0.935702583333334">
The 6i-enumeration, problem is the problem of enu-
merating all ground, terms x, y such that r(x#y).
The specialization class associated with this
problem is the class&apos; TRIV = {X#Y } which con-
tains the single term X#Y.
For non-degenerate grammars, it is not the case
that r is finitely enumerable on TRIV, for this
would entail in particular that any string recog-
nized by the grammar is subsumed under one of
the terms in a fixed finite set of terms T1, • . • , T.
This is a slightly weaker property than saying that
there are finitely many strings recognized by the
grammar, but is still a very unlikely property for a
grammar.
On the other hand, by definition, r is enumerable
on TRIV. It can be shown easily that it is also
discoverable on TRIV .17
16 An immediate consequence of this property (linking the
p-enumeration problem with the p-acceptation problem) is
the fact that a grammar which is finitely enumerable for
parsing has a decidable p-acceptation problem. The con-
verse is clearly false (see §6 for a counter-example).
17 This is because: (i) In case the grammar gener-
ates nothing, there is a trivial program which, on query
</bodyText>
<subsectionHeader confidence="0.871308">
3.1.4 bi-acceptation
</subsectionHeader>
<bodyText confidence="0.986345625">
The bi-acceptation problem is the problem of check-
ing, for any fixed ground terms x and y, whether
r(x#y) is true.
The specialization class associated with this
problem is the set G= {x#y}z,yEH of ground spe-
cializations.
It can be shown that r is finitely enumerable on
G if it is discoverable on G if the relation r on H
is recursive in the classical sense. When this is the
case, one says that bi-acceptation is decidable.
Again, by property (2), r is enumerable on any
specialization class, and in particular on g.
REMARK. Suppose that parsing is finitely enu-
merable, that is, r is finitely enumerable on GP.
This obviously implies that r is also finitely enu-
merable on G. Therefore, one has:
parsing is finitely enumerable bi-
acceptation is decidable;
and, by the same reasoning:
generation is finitely enumerable = bi-
acceptation is decidable.
On the other hand, the weaker property that
p-acceptation is decidable (or similarly, that g-
acceptation is decidable) does not seem to entail
that bi-acceptation is decidable.
4 Definite programs, unifor-
mity of implementation,
and reversibility
It is sometimes stated that various grammatical
formalisms, based on a variant or another of uni-
fication, are &amp;quot;reversible&amp;quot;. It should more properly
be said that they are &amp;quot;well-adapted&amp;quot; to reversible
grammar implementations. The paradigmatic case
of a grammar given as a definite program G makes
this especially clear.
We know, from the discussion of §3.1.1 and
§3.1.2, that we always have: (i) r is enumerable
?r(X#Y), produces an empty list of answers and termi-
nates and (ii) if this is not the case, then the grammar
itself may serve as an enumerating program (perhaps a
non-terminating one). Note that this does not entail that
by looking at the grammar, one is actually able—even in
principle—to decide which of these two situations actually
holds! This is an extreme instance of the remark made above
(in the discussion of finite enumerability of parsing) that the
existence in principle of a program meeting certain criteria
does not imply that it is obvious, or indeed possible, to find
such a program.
</bodyText>
<page confidence="0.995576">
25
</page>
<bodyText confidence="0.999965">
on GP and (ii) r is enumerable on GG; we therefore
know that there exist programs Pp and Pg which
enumerate r respectively on GP and GG . But in
fact we have more: if we use a sound and complete
interpreter, we can simply take Pp = Pg = G. This
follows from the fact that, by definition, relatively
to such an interpreter, G enumerates rT, for any
specialization T (see §2.1.1):
</bodyText>
<listItem confidence="0.999251">
• G enumerates r on GP;
• G enumerates r on GG.
</listItem>
<bodyText confidence="0.989554">
To be more concrete, suppose that we use a com-
plete top-down interpreter; Its behavior will be
along the following lines:
</bodyText>
<listItem confidence="0.753756">
1. On query ?r(X#Y), the interpreter returns
the (generally infinite) list of answers
</listItem>
<bodyText confidence="0.9634615">
Tl,T2,...,Tk,...
where each Ti is a term of the form Ai#131;
The (generally infinite) &amp;quot;union&amp;quot; of these terms
&amp;quot;exactly covers&amp;quot; the query;
</bodyText>
<listItem confidence="0.842154333333333">
2. On a query of the form ?r(x#Y), where x is
a ground term, the interpreter returns the list
of answers
</listItem>
<bodyText confidence="0.9495142">
TIU(x#Y),T2U(x#Y),... ,TkU(x#Y),...
where U is the operator of term unification,
and where, with some abuse of notation, only
the terms TiU(x#Y) for which unification is
possible actually appear in the list;
</bodyText>
<listItem confidence="0.887528333333333">
3. On a query of the form ?r(X#y), where y is
a ground term, the interpreter returns the list
of answers
</listItem>
<bodyText confidence="0.99950325">
TIU(X#y), T2U(X#y),
(with the same abuse of notation as above).
This is a rather striking property of definite
programs: different &amp;quot;input modes&amp;quot; can be imple-
mented using one and the same interpreter and
one and the same program. (This property strongly
contrasts with other programming paradigms, for
instance functional or imperative ones. Programs
of these types typically map an input x to an out-
put y, and, while it is indeed true that, for a given
y, the set of xi which can serve as its input is recur-
sively enumerable, the interpreter that could imple-
ment the (nondeterministic) mapping y x would
have to be widely different from the &amp;quot;normal&amp;quot; in-
terpreter for the language at hand.)
However, &amp;quot;reversibility&amp;quot; in this sense only means
uniformity of implementation for different modes
of use of a grammar. Intrinsic finite reversibility
which is defined in the next section, gives a much
stronger criterion of grammar reversibility.
</bodyText>
<sectionHeader confidence="0.666099" genericHeader="method">
5 Inherently reversible gram-
mars
</sectionHeader>
<bodyText confidence="0.969857666666667">
We say that a grammar G is (inherently) finitely
reversible if, in the terminology of §3.1.1 and
§3.1.2, G is such that:
</bodyText>
<listItem confidence="0.932387">
1. parsing is finitely enumerable;
2. generation is finitely enumerable.
</listItem>
<bodyText confidence="0.963043">
In other words, G is finitely reversible if there
exists a program Pp for parsing and a (not necessar-
ily identical) program Pg for generation such that,
relative to some sound and complete interpreter:18
</bodyText>
<listItem confidence="0.994776142857143">
1. On a query of the form ?r(x#Y), where x is
any ground term, Pp returns a finite list of
answers
and stops.
2. On a query of the form ?r(X#y), where y is
any ground term, Pg returns a finite list of
answers
</listItem>
<equation confidence="0.869049">
Ti#Y,Ti#Y, • • • ,Ti#Y
</equation>
<bodyText confidence="0.997674461538462">
and stops.
In order to guarantee that a grammar is finitely
reversible, some strong assumptions must be made
on its form. An example of such assumptions is pro-
vided by the class of Lexical Grammars described
in [5].19
Lexical grammars are presented as definite pro-
grams. They all share the same core of rules,
which describe basic compositionality assumptions
(string compositionality, syntactic compositional-
ity, semantic compositionality), but may have dif-
ferent lexicons, which contain all the more specific
linguistic knowledge.
</bodyText>
<footnote confidence="0.982559166666667">
18In fact, one can also take here an incomplete interpreter
such as the standard Prolog interpreter stintpr. Obviously,
if programs Pp and Pg exist for a sound and complete in-
terpreter intpr, one can also find such programs P; and P.4
relative to stint pr, by simulating intpr inside stintpr.
19 See also [10] for a related approach.
</footnote>
<page confidence="0.992621">
26
</page>
<figure confidence="0.994239466666667">
bi-acceptation
decidable
parsing discoverable
p-acceptation decidable
parsing
finitely
enumerable
•&gt;%
%.*
generation
finitely
enumerable
generation discoverable
01■MMI11•410.
g-acceptation decidable
</figure>
<figureCaption confidence="0.99998">
Figure 1: Computational problems associated with a grammar.
</figureCaption>
<bodyText confidence="0.987330463414634">
The hypotheses made on string compositionality
in Lexical Grammars are simply that sister con-
stituents concatenate their strings; they entail that
parsing is finitely enumerable. The hypotheses on
semantic compositionality are related to functional
application and composition in categorial gram-
mars (see e.g. [15]). They entail that generation
is finitely enumerable.
A lexical grammar G is therefore finitely re-
versible. This does not imply that it can be used
directly for parsing and for generation, but only,
as seen previously, that there exist two programs
Pp and Pg implementing G respectively for pars-
ing and for generation. These programs are each
obtained by a technique of adding to the grammar
some redundant knowledge—respectively a conser-
vative guide for parsing and aconservaiive guide for
generation—and by applying a left-recursion elim-
ination transformation (see [5]).
6 Some counter-examples to
finite reversibility and a
&amp;quot;moderation&amp;quot; condition on
linguistic description
Fig.1 sums up graphically some of the relations
which have been established in §3 between the com-
putational problems associated with a grammar.
The full arrows indicate entailments which have
been established. The dotted arrows relate to a
rather obvious question: What are the connections
between the computational properties of parsing
and those of generation? For instance, does the
finite enumerability of parsing entail the finite enu-
merability of generation? If not, does it at least
entail that g-acceptation is decidable? (The same
questions can be asked in the reverse direction.)
The answer is that, if no further assumptions are
made (see below §6.3), then there are no connec-
tions. To show this, we now sketch one example
which shows that finite enumerability of parsing
does not even entail that g-acceptation is decid-
able.
</bodyText>
<subsectionHeader confidence="0.997769">
6.1 A &amp;quot;grammar&amp;quot; related to Matiya-
sevich&apos;s theorem
</subsectionHeader>
<bodyText confidence="0.950388862068966">
Matiyasevich&apos;s theorem [2, p. 116] provides—
among other things—a negative solution to
Hilbert&apos;s tenth problem: &amp;quot;Does there exist an al-
gorithm capable of solving all diophantine equa-
tions?&amp;quot;, a diophantine equation being a multivari-
able polynomial in integer coefficients and whose
variables range over N.2°
Let K be a recursively enumerable, but non-
recursive, subset of N. One corollary of Matiya-
sevich&apos;s theorem is the following property [2, p.
127-28]:
There exists a polynomial q(zi,... ,z.) in
integer coefficients such that K is the set
of values taken by q, for z1, , zn ranging
over all integers.
This corollary can be exploited to give an exam-
ple of a &amp;quot;grammar&amp;quot; which has a finitely enumerable
parsing problem, but such that its g-acceptation
problem is not decidable.
Consider the relation r(x#y) which is true
iff: (i) x is a string encoding any instance (for
z1, , zn ranging over the integers) of the expres-
sion q(zi,... ,z,), using the symbols 0, ,9,
&apos;4r% `C, `r, etc., and (ii) y is a term encoding the in-
teger resulting from the arithmetical evaluation of
q(zi,... ,z). This relation can easily be described
20The actual statement of Matiyasevich&apos;s theorem is
stronger: &amp;quot;Every partially decidable predicate is diophan-
tine&amp;quot; [2, p. 116].
</bodyText>
<page confidence="0.996863">
27
</page>
<bodyText confidence="0.990869333333333">
by a &amp;quot;grammar&amp;quot; G: This grammar checks the well-
formedness of string x, and calculates its &amp;quot;seman-
tics&amp;quot; y.21 G has the following properties:
</bodyText>
<listItem confidence="0.989996666666667">
• parsing is finitely enumerable: there is a pro-
gram (namely G itself) finitely enumerating r
on GP. In effect, for any string x, this pro-
grams checks x for well-formedness and calcu-
lates the (single) &amp;quot;semantics&amp;quot; y resulting from
the evaluation of x.
• g-acceptation is not decidable. Indeed, the
problem of g-acceptation is the problem of de-
ciding, for any given integer y, whether y is in
the image of polynomial q, that is, whether y
belongs to K. But K is a non-recursive set,
hence the conclusion.
</listItem>
<subsectionHeader confidence="0.993554">
6.2 A &amp;quot;grammar&amp;quot; related to the un-
decidability of first-order logic
</subsectionHeader>
<bodyText confidence="0.948040711111111">
I will only very broadly sketch this example, which
I think may provide useful insights on the impor-
tance of constraining &amp;quot;string compositionality&amp;quot; in
a grammar.
Consider ordered pairs (z,y) of (ground) terms
where x is a string encoding a certain first-order
logic tautology, and y (the &amp;quot;semantics&amp;quot;) is a deriva-
tion of x using a certain fixed set of axiom schemata
and rules of inference for a complete system of first-
order logic. Let&apos;s assume for simplicity that the
given rules of inference always have two premises
and one conclusion.22
A grammar G can be defined along the follow-
ing general lines. The clauses of G correspond to
the system&apos;s axiom schemata and rules of inference.
Each clause corresponding to an axiom schema of
name as defines &amp;quot;terminal constituents&amp;quot; (x, as(x)),
where string x is any instance of schema as; each
clause corresponding to an inference rule of name
ir takes two &amp;quot;constituents&amp;quot; (x, y) and (x2, Y2),
and, if applicable (which is checked on the basis of
strings x1 and x2), builds a new constituent (x, y),
where x is the string obtained from xi and x2 ac-
cording to ir, and where y is a new derivation tree
ir(x, Yi, y2). We have the following properties:
• generation is finitely enumerable: The genera-
tion problem is the problem, given a derivation
21This requires defining addition and multiplication of in-
tegers inside G, which presents no special problem.
22See for instance [8, p. 43-44] which describes a system
having the two rules of inference E-11-21.i and at-T (where
x is free in p). The second rule has one premise, but can
easily be viewed as having two, if the premise True is added
to its original premise.
tree y, of enumerating all formulas x that are
associated with it. But y contains an explicit
representation of x, so that generation is triv-
ially finitely enumerable.
• p-acceptation is not decidable: The p-acceptation
problem is the problem of checking if a string
x can be derived from the axioms and the in-
ference rules of the system. That is, it is the
problem of checking if x is a tautology of first-
order logic. By Church&apos;s undecidability result,
this problem is undecidable.
</bodyText>
<subsectionHeader confidence="0.927835">
6.3 Under a &amp;quot;moderation&amp;quot; condition
</subsectionHeader>
<bodyText confidence="0.99448916">
on linguistic description, parsing
is finitely enumerable if genera-
tion is
The two counter-examples that we have just given
have one property in common: the p-parameter can
stay &amp;quot;small&amp;quot;, while the g-parameter grows indef-
initely &amp;quot;large&amp;quot;, or conversely the g-parameter can
stay small while the p-parameter grows indefinitely
large. For instance, in the first counter-example,
for a given value of y, there is no way to bound
a priori the sizes of the integers zi, ... ,z„ that
may produce this y; in the second counter-example,
there is similarly no way to bound a priori the sizes
of proofs y for a given formula x.
In order to characterize this phenomenon for-
mally, we will define a notion of &amp;quot;moderation” for a
grammar G, defined as a definite program over the
Herbrand universe H. As previously r is the unary
relation representing the denotational semantics of
G.
If a is a ground term in H, let us call size of
this term, and denote by size(a), the number of
nodes in a. Grammar G will be called moderate if
there exist total recursive functions f : N --■ N,
and g :N —+N, such that:
</bodyText>
<equation confidence="0.781598">
Vx,yEH r(x, y) size(y) 5_ f (size(x))
A size(x) .5. g(size(y)).
</equation>
<bodyText confidence="0.979317777777778">
We have the following property:
JIG is moderate, then, relative to G, pars-
ing is finitely enumerable if generation is (4)
finitely enumerable.
Let us briefly sketch the proof: Suppose that pars-
ing is finitely enumerable, then we know (see §3.1.4)
that bi-acceptation is decidable. On the other hand,
for any fixed ground term y, there are only finitely
many ground terms x in H such that size(x) &lt;
</bodyText>
<page confidence="0.99462">
28
</page>
<bodyText confidence="0.999987125">
g(size(y)). Therefore, we can finitely enumerate
all these x&apos;s, and for each of them, decide whether
r(x, y) holds. This shows that generation is finitely
enumerable. The converse is proven in the same
way.
Moderation might be claimed to be a &amp;quot;natural&amp;quot;
constraint to impose on grammars used for &amp;quot;legit-
imate&amp;quot; linguistic purposes: One might want to ar-
gue that, in natural language, complexity of ex-
pression is a rather direct reflection of complexity
of meaning. For eXarnple, semantic rules which re-
duced &amp;quot;you love him or you don&apos;t&amp;quot; to &apos;true&apos;, or
&amp;quot;how much is 6 times 7 ?&amp;quot; to &apos;?x.(x = 42)&apos; would
seem to be ruled out as valid linguistic descriptions.
But we will not further pursue these tricky ques-
tions here.
</bodyText>
<sectionHeader confidence="0.998561" genericHeader="evaluation">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.997573666666666">
Thanks to Pierre Isabelle, Francois Perrault, Patrick
Saint-Dizier, Tomek Strzalkowski and Gertjan van
Noord for their comments on an earlier version of
this paper. English and content have bigly suffered
from my lacking time to impose, as usual, its read-
ing on Elliott Macklovitch.
</bodyText>
<sectionHeader confidence="0.98481" genericHeader="conclusions">
Appendix
</sectionHeader>
<bodyText confidence="0.9716235">
Examples of finitely reversible gram-
mars that are inherently difficult to
reverse
In this appendix, we give two examples of gram-
mars that, although they are finitely reversible, are
such that one mode is easy, while the reverse mode
has a high degree ,of complexity. These examples
are closely parallel, in the context of complexity,
to the examples of section 6, which were concerned
with computability.
Number products, cryptography and reversibil-
ity
Consider the binary relation r(x#y) which is true
if x is a string of the form:
</bodyText>
<equation confidence="0.558859">
N * M
</equation>
<bodyText confidence="0.999477413043479">
where N and M are strings, interpreted as integers,
of O&apos;s and l&apos;s and&apos;*&apos; is interpreted as multiplica-
tion, and where y is an integer equal to the product
of M and N.23 We impose a priori that integers
M and N be strictly greater than 1.
This relation can be defined by a &amp;quot;grammar&amp;quot;
G: this essentially simply involves constraining the
&amp;quot;syntax&amp;quot; of x and defining multiplication by a set
of definite clauses.
Implementing r in p-enumeration mode is easy:
it involves verifying that x is well-formed, and com-
puting its product according to specification G; In
fact, G itself can be used for that purpose, using a
standard interpreter.
On the other hand, efficiently implementing r in
g-enumeration mode is extremely difficult, what-
ever the interpreter, program transformations, math-
ematical properties of prime factorization, ..., which
are brought to the task. The fact that it is so dif-
ficult is the basis of the best known &amp;quot;public key
cryptography&amp;quot; algorithm, RSA [11].
NP-complete problems and reversibility
A NP-complete problem is, informally, a problem
for which solutions can be checked in polynomial
time (relative to the length of the problem), but
which requires more than polynomial time for the
discovery of a solution [11.24
For specificity, let us focus on one NP-complete
problem, namely the &amp;quot;3-colorability problem&amp;quot; which
consists, given a certain graph x, in finding a color-
ing y for x using blue, green and red, in such a way
that vertices sharing a common arc have different
colors.
It is possible to state the problem as a definite
program G, whose main relation is of the form
r(x#y), x and y being suitable term encodings for
the graph x and for the solution y. The solution
y can be considered as implicitely containing a de-
scription of graph x.
It is obvious that g-acceplation is computation-
ally easy (polynomial): it consists in verifying that
the coloring y respects the coloring condition. On
the other hand, p-acceptation is computationally
costly: it consists in checking whether graph x has
a solution, a problem which is at the present time
believed to require exponential time.
</bodyText>
<reference confidence="0.804068">
23The string N *M and the integer y are suitably encoded
as ground terms on H.
24More exactly, which is believed to require more than
polynomial time. This belief constitutes the content of the
famous POW&apos; conjecture.
</reference>
<page confidence="0.999353">
29
</page>
<sectionHeader confidence="0.998341" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999945816091954">
[1] Alfred V. Aho, John E. Hoperoft, and Jef-
frey D. Ullman. The Design and Analysis of
Computer Algorithms. Addison-Wesley, Read-
ing, MA, 1974.
[2] N. J. Cutland. Computability. Cambridge Uni-
versity Press, Cambridge, England, 1980.
[3] Marc Dymetman. A Generalized Greibach
Normal Form for Definite Clause Grammars
and the decidability of the offline-parsability
problem, May 1991. Paper presented at the
Second Meeting on the Mathematics of Lan-
guage, Yorktown Heights, NY. (To be pub-
lished).
[4] Marc Dymetman and Pierre Isabelle. Re-
versible logic grammars for machine transla-
tion. In Proceedings of the Second Interna-
tional Conference on Theoretical and Method-
ological Issues in Machine Translation of Nat-
ural Languages, Pittsburgh, PA, June 1988.
Carnegie Mellon University.
[5] Marc Dymetman, Pierre Isabelle, and Francois
Perrault. A symmetrical approach to parsing
and generation. In Proceedings of the 13th In-
ternational Conference on Computational Lin-
guistics, volume 3, pages 90-96, Helsinki, Au-
gust 1990.
[6] Mark Johnson. Attribute-Value Logic and the
Theory of Grammar. CSLI lecture note No.
16. Center for the Study of Language and In-
formation, Stanford, CA, 1988.
[71 John Wylie Lloyd. Foundations of Logic Pro-
gramming. Springer-Verlag, Berlin, second
edition, 1987.
[8] Roger C. Lyndon. Notes on Logic. Van Nos-
trand, New York, NY, 1966.
[9] Fernando C. N. Pereira and David H. D. War-
ren. Parsing as deduction. In Proceedings of
the 21th Annual Meeting of the Association
for Computational Linguistics, pages 137-144,
MIT, Cambridge, MA, June 1983.
[10] Francois Perrault. Un nouveau formalisme de
grammaire logique reversible. Master&apos;s thesis,
McGill University, Montreal, Canada, 1991.
[11] R. L. Rivest, A. Shamir, and L. Adleman. A
method for obtaining digital signatures and
public key cryptosystems. Communications of
the ACM, 21:120-126, February 1978.
[12] Stuart M. Shieber. A uniform architecture
for parsing and generation. In Proceedings of
the 12th International Conference on Compu-
tational Linguistics, pages 614-619, Budapest,
August 1988.
[13] Stuart M. Shieber. Parsing and type inference
for natural and computer languages. Techni-
cal note 460, SRI International, Menlo Park,
CA, 1989. (Ph.D. dissertation, Department of
Computer Science, Stanford University).
[14] Stuart M. Shieber, Gertjan van Noord,
Robert Moore, and Fernando Pereira. A
semantic-head-driven generation algorithm for
unification-based formalisms. In Proceedings
of the 27th Annual Meeting of the Associa-
tion for Computational Linguistics, pages 7-
17, Vancouver, BC, Canada, June 1989.
[15] Mark Steedman. Dependency and coordina-
tion in the grammar of dutch and english. Lan-
guage, 61(3):523-568,1985.
[16] Tomek Strzalkowski and Ping Peng. Auto-
mated inversion of logic grammars for genera-
tion. In Proceedings of the 28th Annual Meet-
ing of the Association for Computational Lin-
guistics, pages 212-19, Pittsburgh, PA, June
1990.
[17] Gertjan van Noord. Towards convenient bi-
directional grammar formalisms. In Proceed-
ings of the 13th International Conference on
Computational Linguistics, volume 2, pages
294-298, Helsinki, August 1990.
[18] Gertjan van Noord. BUG: A directed bottom-
up generator for unification based formalisms.
Technical report, RUU, Department of Lin-
guistics, Utrecht, Holland, 1989.
[19] Remi Zajac. A uniform architecture for pars-
ing, generation and transfer. In Proceedings
of the Workshop on Reversible Grammars in
Natural Language Processing, Berkeley, CA,
1991.
</reference>
<page confidence="0.998803">
30
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.268432">
<title confidence="0.977371333333333">Inherently Reversible Logic and Computability</title>
<author confidence="0.977875">Marc</author>
<affiliation confidence="0.704892">CCRIT, Communications</affiliation>
<address confidence="0.350917">1575 boulevard Laval (Quebec) H7V 2X2,</address>
<email confidence="0.986213">dymetman@ccrit.doc.ca</email>
<abstract confidence="0.99905852631579">This paper attempts to clarify two distinct notions &amp;quot;reversibility&amp;quot;: (i) of implementaparsing and generation, and (ii) reversibilas an (or intrinsic) property of gramthe one hand, we explain why grammars specified as definite programs (or the various related &amp;quot;unification grammars&amp;quot;) lead to uniformity of implementation. On the other hand, we define different intrinsic reversibility properties for grammars—the most important being says that both parsing and genare enumerable text)— and give examples and counter-examples of grammars which possess or do not possess these intrinsic properties. We also show that, under a certain &amp;quot;moderation&amp;quot; condition on linguistic description, finite enumerability of parsing is equivalent to finite enumerability of generation.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<title>23The string N *M and the integer y are suitably encoded as ground terms on H. 24More exactly, which is believed to require more than polynomial time. This belief constitutes the content of the famous POW&apos; conjecture.</title>
<marker></marker>
<rawString> 23The string N *M and the integer y are suitably encoded as ground terms on H. 24More exactly, which is believed to require more than polynomial time. This belief constitutes the content of the famous POW&apos; conjecture.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alfred V Aho</author>
<author>John E Hoperoft</author>
<author>Jeffrey D Ullman</author>
</authors>
<title>The Design and Analysis of Computer Algorithms.</title>
<date>1974</date>
<publisher>Addison-Wesley,</publisher>
<location>Reading, MA,</location>
<marker>[1]</marker>
<rawString>Alfred V. Aho, John E. Hoperoft, and Jeffrey D. Ullman. The Design and Analysis of Computer Algorithms. Addison-Wesley, Reading, MA, 1974.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Computability</author>
</authors>
<date>1980</date>
<publisher>Cambridge University Press,</publisher>
<location>Cambridge, England,</location>
<marker>[2]</marker>
<rawString>N. J. Cutland. Computability. Cambridge University Press, Cambridge, England, 1980.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Marc Dymetman</author>
</authors>
<title>A Generalized Greibach Normal Form for Definite Clause Grammars and the decidability of the offline-parsability problem,</title>
<date>1991</date>
<booktitle>Paper presented at the Second Meeting on the Mathematics of Language,</booktitle>
<location>Yorktown Heights, NY.</location>
<note>(To be published).</note>
<contexts>
<context position="4429" citStr="[5, 3]" startWordPosition="709" endWordPosition="710">grams have been thoroughly studied. 2See e.g. [7, p. 59] and section §2.1.3. See also [19] in this volume for a related approach. 20 find, and go on eternally looking for new solutions. The source of this problem can be more or less severe: It may simply be due to the grammar&apos;s implementation as&apos;a certain program, or it may be intrinsic to the grammar. If it is not intrinsic to the grammar, one may attempt some kind of program transformation on the grammar—for &apos;instance a local transformation as goal reordering in clause bodies [4, 16], or a global transformation as left-recursion elimination [5, 3] 3 —in order to get a parsing program which displays a finite behavior.4 If such a transformation is possible in principle, we say that, intrinsically, the grammar has a finitely enumerable parsing problem.5 One example of a class of grammars which respect this crucial condition is provided by offline-parsable DCGs, once compiled as definite programs (see [9]).6 We have limited the former discussion to the case of parsing. The case of generation is treated in a parallel fashion, and one can similarly define the conditions in which a grammar is said to have an intrinsically finitely enumerable </context>
</contexts>
<marker>[3]</marker>
<rawString>Marc Dymetman. A Generalized Greibach Normal Form for Definite Clause Grammars and the decidability of the offline-parsability problem, May 1991. Paper presented at the Second Meeting on the Mathematics of Language, Yorktown Heights, NY. (To be published).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Marc Dymetman</author>
<author>Pierre Isabelle</author>
</authors>
<title>Reversible logic grammars for machine translation.</title>
<date>1988</date>
<booktitle>In Proceedings of the Second International Conference on Theoretical and Methodological Issues in Machine Translation of Natural Languages,</booktitle>
<institution>Carnegie Mellon University.</institution>
<location>Pittsburgh, PA,</location>
<contexts>
<context position="4364" citStr="[4, 16]" startWordPosition="700" endWordPosition="701">nd that the denotational and operational semantics of definite programs have been thoroughly studied. 2See e.g. [7, p. 59] and section §2.1.3. See also [19] in this volume for a related approach. 20 find, and go on eternally looking for new solutions. The source of this problem can be more or less severe: It may simply be due to the grammar&apos;s implementation as&apos;a certain program, or it may be intrinsic to the grammar. If it is not intrinsic to the grammar, one may attempt some kind of program transformation on the grammar—for &apos;instance a local transformation as goal reordering in clause bodies [4, 16], or a global transformation as left-recursion elimination [5, 3] 3 —in order to get a parsing program which displays a finite behavior.4 If such a transformation is possible in principle, we say that, intrinsically, the grammar has a finitely enumerable parsing problem.5 One example of a class of grammars which respect this crucial condition is provided by offline-parsable DCGs, once compiled as definite programs (see [9]).6 We have limited the former discussion to the case of parsing. The case of generation is treated in a parallel fashion, and one can similarly define the conditions in whic</context>
</contexts>
<marker>[4]</marker>
<rawString>Marc Dymetman and Pierre Isabelle. Reversible logic grammars for machine translation. In Proceedings of the Second International Conference on Theoretical and Methodological Issues in Machine Translation of Natural Languages, Pittsburgh, PA, June 1988. Carnegie Mellon University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Marc Dymetman</author>
<author>Pierre Isabelle</author>
<author>Francois Perrault</author>
</authors>
<title>A symmetrical approach to parsing and generation.</title>
<date>1990</date>
<booktitle>In Proceedings of the 13th International Conference on Computational Linguistics,</booktitle>
<volume>3</volume>
<pages>90--96</pages>
<location>Helsinki,</location>
<contexts>
<context position="4429" citStr="[5, 3]" startWordPosition="709" endWordPosition="710">grams have been thoroughly studied. 2See e.g. [7, p. 59] and section §2.1.3. See also [19] in this volume for a related approach. 20 find, and go on eternally looking for new solutions. The source of this problem can be more or less severe: It may simply be due to the grammar&apos;s implementation as&apos;a certain program, or it may be intrinsic to the grammar. If it is not intrinsic to the grammar, one may attempt some kind of program transformation on the grammar—for &apos;instance a local transformation as goal reordering in clause bodies [4, 16], or a global transformation as left-recursion elimination [5, 3] 3 —in order to get a parsing program which displays a finite behavior.4 If such a transformation is possible in principle, we say that, intrinsically, the grammar has a finitely enumerable parsing problem.5 One example of a class of grammars which respect this crucial condition is provided by offline-parsable DCGs, once compiled as definite programs (see [9]).6 We have limited the former discussion to the case of parsing. The case of generation is treated in a parallel fashion, and one can similarly define the conditions in which a grammar is said to have an intrinsically finitely enumerable </context>
<context position="5881" citStr="[5]" startWordPosition="949" endWordPosition="949">d a program P„ for parsing and a (not necessarily identical) program Pg for generation such that, for any string x, Pi, enumerates all associated semantics y and terminates, and, for any semantics y, Pg enumerates all associated strings x and terminates. Inherent finite reversibility is the concept which, in my opinion, permit us to capture formally the intuitive notion that a certain grammar is, or is not, &amp;quot;reversible&amp;quot;. 30r more generally&apos;, any transformation exploiting theorems provable of the, grammar. Another instance of this technique is provided by the addition of conservative guides in [5], which &amp;quot;strengthen&amp;quot; the grammar on the basis of properties inferable from its form. 4 Another popular approach is to use a special-purpose interpreter, exploiting i properties of the grammar known a priori. [18] and [14] use this approach in the case of generation (see below). 5The description is simplified; see §3 for the exact definition. 6 See also [17] for a discussion of offline-parsability in the context of generation. 2 Definite programs and computation 2.1 Denotational and operational semantics of a definite program; complete and incomplete interpreters A definite program P is a finit</context>
<context position="27317" citStr="[5]" startWordPosition="4701" endWordPosition="4701">re exists a program Pp for parsing and a (not necessarily identical) program Pg for generation such that, relative to some sound and complete interpreter:18 1. On a query of the form ?r(x#Y), where x is any ground term, Pp returns a finite list of answers and stops. 2. On a query of the form ?r(X#y), where y is any ground term, Pg returns a finite list of answers Ti#Y,Ti#Y, • • • ,Ti#Y and stops. In order to guarantee that a grammar is finitely reversible, some strong assumptions must be made on its form. An example of such assumptions is provided by the class of Lexical Grammars described in [5].19 Lexical grammars are presented as definite programs. They all share the same core of rules, which describe basic compositionality assumptions (string compositionality, syntactic compositionality, semantic compositionality), but may have different lexicons, which contain all the more specific linguistic knowledge. 18In fact, one can also take here an incomplete interpreter such as the standard Prolog interpreter stintpr. Obviously, if programs Pp and Pg exist for a sound and complete interpreter intpr, one can also find such programs P; and P.4 relative to stint pr, by simulating intpr insi</context>
<context position="29117" citStr="[5]" startWordPosition="4962" endWordPosition="4962">tegorial grammars (see e.g. [15]). They entail that generation is finitely enumerable. A lexical grammar G is therefore finitely reversible. This does not imply that it can be used directly for parsing and for generation, but only, as seen previously, that there exist two programs Pp and Pg implementing G respectively for parsing and for generation. These programs are each obtained by a technique of adding to the grammar some redundant knowledge—respectively a conservative guide for parsing and aconservaiive guide for generation—and by applying a left-recursion elimination transformation (see [5]). 6 Some counter-examples to finite reversibility and a &amp;quot;moderation&amp;quot; condition on linguistic description Fig.1 sums up graphically some of the relations which have been established in §3 between the computational problems associated with a grammar. The full arrows indicate entailments which have been established. The dotted arrows relate to a rather obvious question: What are the connections between the computational properties of parsing and those of generation? For instance, does the finite enumerability of parsing entail the finite enumerability of generation? If not, does it at least enta</context>
</contexts>
<marker>[5]</marker>
<rawString>Marc Dymetman, Pierre Isabelle, and Francois Perrault. A symmetrical approach to parsing and generation. In Proceedings of the 13th International Conference on Computational Linguistics, volume 3, pages 90-96, Helsinki, August 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Johnson</author>
</authors>
<title>Attribute-Value Logic and the Theory of Grammar.</title>
<date>1988</date>
<booktitle>CSLI lecture note No. 16. Center for the Study of Language and Information,</booktitle>
<publisher>Springer-Verlag,</publisher>
<location>Stanford, CA,</location>
<note>second edition,</note>
<contexts>
<context position="19886" citStr="[6]" startWordPosition="3431" endWordPosition="3431">ns y corresponding to x, then the program will enumerate them, but maybe not terminate. If this property holds, we also say that with the grammar at hand, p-enumeration is discoverable, or, simply, parsing is discoverable. One can easily prove (although we will not do it here) that this property is equivalent to the decidability (in the classical sense) of the p-acceptation problem. In other words: 14 See footnote 17. 15 These papers do not use the concept (or, a fortiori, the terminology) &amp;quot;finite entunerability of parsing&amp;quot;, which, to my knowledge, appears here for the first time (see however [6], for the related notion of &amp;quot;Universal Parsing Problem&amp;quot;). 24 p-enumeration is discoverable if and only if p-acceptation is decidable.&amp;quot; Enumerability By the definition of a grammar as being a recursively enumerable mechanism, and by property (2), r is enumerable on any specialization class, and in particular on P. 3.1.2 g-enumeration and g-acceptation The g-enumeration &apos;problem or generation problem is the problem of enumerating, for any fixed ground term y, all ground terms x such that r(x#y). The g-acceptation problem or decision problem for generation is the problem of checking, for any fixe</context>
</contexts>
<marker>[6]</marker>
<rawString>Mark Johnson. Attribute-Value Logic and the Theory of Grammar. CSLI lecture note No. 16. Center for the Study of Language and Information, Stanford, CA, 1988. [71 John Wylie Lloyd. Foundations of Logic Programming. Springer-Verlag, Berlin, second edition, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Roger C Lyndon</author>
</authors>
<title>Notes on Logic.</title>
<date>1966</date>
<location>Van Nostrand, New York, NY,</location>
<marker>[8]</marker>
<rawString>Roger C. Lyndon. Notes on Logic. Van Nostrand, New York, NY, 1966.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fernando C N Pereira</author>
<author>David H D Warren</author>
</authors>
<title>Parsing as deduction.</title>
<date>1983</date>
<booktitle>In Proceedings of the 21th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>137--144</pages>
<location>MIT, Cambridge, MA,</location>
<contexts>
<context position="4790" citStr="[9]" startWordPosition="770" endWordPosition="770">not intrinsic to the grammar, one may attempt some kind of program transformation on the grammar—for &apos;instance a local transformation as goal reordering in clause bodies [4, 16], or a global transformation as left-recursion elimination [5, 3] 3 —in order to get a parsing program which displays a finite behavior.4 If such a transformation is possible in principle, we say that, intrinsically, the grammar has a finitely enumerable parsing problem.5 One example of a class of grammars which respect this crucial condition is provided by offline-parsable DCGs, once compiled as definite programs (see [9]).6 We have limited the former discussion to the case of parsing. The case of generation is treated in a parallel fashion, and one can similarly define the conditions in which a grammar is said to have an intrinsically finitely enumerable generation problem. When a grammar is such that it has a finitely enumerable parsing problem and a finitely enumerable generation problem, we call the grammar inherently finitely reversible. When this is the case, it is by definition possible to find a program P„ for parsing and a (not necessarily identical) program Pg for generation such that, for any string</context>
<context position="18700" citStr="[9]" startWordPosition="3222" endWordPosition="3222">olutions to the parsing problem and terminates. These solutions are given implicitly as a finite list of answers TY1, , TYk: the TYi&apos;s are terms whose ground instances y are the looked-for values of the g-parameter (the semantics associated with string x by the grammar). We also say that, with the grammar at hand, penumeration is finitely enumerable, or simply, that parsing is finitely enumerable. This is an inherent property of the grammar, and, in practice, this property does not necessarily entail that finding a program P to exploit will be obvious.&amp;quot; For instance, offline-parsable grammars [9] can be shown to possess a finitely enumerable parsing problem, but algorithms which are able to make use of this property are by no means trivial [9, 13, 415 Discoverability If r is not finitely enumerable on GP, it may still be discoverable on P. By definition, this means that it is possible to find a program P such that, for any given (ground) value x of the p-parameter, if there is no value y of the g-parameter corresponding to x, then the program will &amp;quot;recognize&amp;quot; this fact in finite time and terminate with an empty list of answers; if, on the other hand, there are solutions y correspondin</context>
</contexts>
<marker>[9]</marker>
<rawString>Fernando C. N. Pereira and David H. D. Warren. Parsing as deduction. In Proceedings of the 21th Annual Meeting of the Association for Computational Linguistics, pages 137-144, MIT, Cambridge, MA, June 1983.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Francois Perrault</author>
</authors>
<title>Un nouveau formalisme de grammaire logique reversible. Master&apos;s thesis,</title>
<date>1991</date>
<institution>McGill University,</institution>
<location>Montreal, Canada,</location>
<contexts>
<context position="27945" citStr="[10]" startWordPosition="4797" endWordPosition="4797"> presented as definite programs. They all share the same core of rules, which describe basic compositionality assumptions (string compositionality, syntactic compositionality, semantic compositionality), but may have different lexicons, which contain all the more specific linguistic knowledge. 18In fact, one can also take here an incomplete interpreter such as the standard Prolog interpreter stintpr. Obviously, if programs Pp and Pg exist for a sound and complete interpreter intpr, one can also find such programs P; and P.4 relative to stint pr, by simulating intpr inside stintpr. 19 See also [10] for a related approach. 26 bi-acceptation decidable parsing discoverable p-acceptation decidable parsing finitely enumerable •&gt;% %.* generation finitely enumerable generation discoverable 01■MMI11•410. g-acceptation decidable Figure 1: Computational problems associated with a grammar. The hypotheses made on string compositionality in Lexical Grammars are simply that sister constituents concatenate their strings; they entail that parsing is finitely enumerable. The hypotheses on semantic compositionality are related to functional application and composition in categorial grammars (see e.g. [15</context>
</contexts>
<marker>[10]</marker>
<rawString>Francois Perrault. Un nouveau formalisme de grammaire logique reversible. Master&apos;s thesis, McGill University, Montreal, Canada, 1991.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R L Rivest</author>
<author>A Shamir</author>
<author>L Adleman</author>
</authors>
<title>A method for obtaining digital signatures and public key cryptosystems.</title>
<date>1978</date>
<journal>Communications of the ACM,</journal>
<pages>21--120</pages>
<contexts>
<context position="38325" citStr="[11]" startWordPosition="6530" endWordPosition="6530">ltiplication by a set of definite clauses. Implementing r in p-enumeration mode is easy: it involves verifying that x is well-formed, and computing its product according to specification G; In fact, G itself can be used for that purpose, using a standard interpreter. On the other hand, efficiently implementing r in g-enumeration mode is extremely difficult, whatever the interpreter, program transformations, mathematical properties of prime factorization, ..., which are brought to the task. The fact that it is so difficult is the basis of the best known &amp;quot;public key cryptography&amp;quot; algorithm, RSA [11]. NP-complete problems and reversibility A NP-complete problem is, informally, a problem for which solutions can be checked in polynomial time (relative to the length of the problem), but which requires more than polynomial time for the discovery of a solution [11.24 For specificity, let us focus on one NP-complete problem, namely the &amp;quot;3-colorability problem&amp;quot; which consists, given a certain graph x, in finding a coloring y for x using blue, green and red, in such a way that vertices sharing a common arc have different colors. It is possible to state the problem as a definite program G, whose m</context>
</contexts>
<marker>[11]</marker>
<rawString>R. L. Rivest, A. Shamir, and L. Adleman. A method for obtaining digital signatures and public key cryptosystems. Communications of the ACM, 21:120-126, February 1978.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
</authors>
<title>A uniform architecture for parsing and generation.</title>
<date>1988</date>
<booktitle>In Proceedings of the 12th International Conference on Computational Linguistics,</booktitle>
<pages>614--619</pages>
<location>Budapest,</location>
<marker>[12]</marker>
<rawString>Stuart M. Shieber. A uniform architecture for parsing and generation. In Proceedings of the 12th International Conference on Computational Linguistics, pages 614-619, Budapest, August 1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
</authors>
<title>Parsing and type inference for natural and computer languages.</title>
<date>1989</date>
<booktitle>Technical note 460, SRI International,</booktitle>
<institution>Department of Computer Science, Stanford University).</institution>
<location>Menlo Park, CA,</location>
<note>Ph.D. dissertation,</note>
<marker>[13]</marker>
<rawString>Stuart M. Shieber. Parsing and type inference for natural and computer languages. Technical note 460, SRI International, Menlo Park, CA, 1989. (Ph.D. dissertation, Department of Computer Science, Stanford University).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
<author>Gertjan van Noord</author>
<author>Robert Moore</author>
<author>Fernando Pereira</author>
</authors>
<title>A semantic-head-driven generation algorithm for unification-based formalisms.</title>
<date>1989</date>
<booktitle>In Proceedings of the 27th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>7--17</pages>
<location>Vancouver, BC, Canada,</location>
<contexts>
<context position="6102" citStr="[14]" startWordPosition="985" endWordPosition="985">sociated strings x and terminates. Inherent finite reversibility is the concept which, in my opinion, permit us to capture formally the intuitive notion that a certain grammar is, or is not, &amp;quot;reversible&amp;quot;. 30r more generally&apos;, any transformation exploiting theorems provable of the, grammar. Another instance of this technique is provided by the addition of conservative guides in [5], which &amp;quot;strengthen&amp;quot; the grammar on the basis of properties inferable from its form. 4 Another popular approach is to use a special-purpose interpreter, exploiting i properties of the grammar known a priori. [18] and [14] use this approach in the case of generation (see below). 5The description is simplified; see §3 for the exact definition. 6 See also [17] for a discussion of offline-parsability in the context of generation. 2 Definite programs and computation 2.1 Denotational and operational semantics of a definite program; complete and incomplete interpreters A definite program P is a finite set of clauses of the form (non-unit clauses): ATI, • • • , Tn) 4— Pi(Tii, • • • Tini) • • • Pm(Tmi • • • ,Tmn..) or of the form (unit clauses): ATI, • • • ,Tn) 4-- where the the p,pi are predicate symbols and the Tij a</context>
</contexts>
<marker>[14]</marker>
<rawString>Stuart M. Shieber, Gertjan van Noord, Robert Moore, and Fernando Pereira. A semantic-head-driven generation algorithm for unification-based formalisms. In Proceedings of the 27th Annual Meeting of the Association for Computational Linguistics, pages 7-17, Vancouver, BC, Canada, June 1989.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Mark Steedman</author>
</authors>
<title>Dependency and coordination in the grammar of dutch and english.</title>
<journal>Language,</journal>
<pages>61--3</pages>
<contexts>
<context position="28546" citStr="[15]" startWordPosition="4873" endWordPosition="4873">10] for a related approach. 26 bi-acceptation decidable parsing discoverable p-acceptation decidable parsing finitely enumerable •&gt;% %.* generation finitely enumerable generation discoverable 01■MMI11•410. g-acceptation decidable Figure 1: Computational problems associated with a grammar. The hypotheses made on string compositionality in Lexical Grammars are simply that sister constituents concatenate their strings; they entail that parsing is finitely enumerable. The hypotheses on semantic compositionality are related to functional application and composition in categorial grammars (see e.g. [15]). They entail that generation is finitely enumerable. A lexical grammar G is therefore finitely reversible. This does not imply that it can be used directly for parsing and for generation, but only, as seen previously, that there exist two programs Pp and Pg implementing G respectively for parsing and for generation. These programs are each obtained by a technique of adding to the grammar some redundant knowledge—respectively a conservative guide for parsing and aconservaiive guide for generation—and by applying a left-recursion elimination transformation (see [5]). 6 Some counter-examples to</context>
</contexts>
<marker>[15]</marker>
<rawString>Mark Steedman. Dependency and coordination in the grammar of dutch and english. Language, 61(3):523-568,1985.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tomek Strzalkowski</author>
<author>Ping Peng</author>
</authors>
<title>Automated inversion of logic grammars for generation.</title>
<date>1990</date>
<booktitle>In Proceedings of the 28th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>212--19</pages>
<location>Pittsburgh, PA,</location>
<contexts>
<context position="4364" citStr="[4, 16]" startWordPosition="700" endWordPosition="701">nd that the denotational and operational semantics of definite programs have been thoroughly studied. 2See e.g. [7, p. 59] and section §2.1.3. See also [19] in this volume for a related approach. 20 find, and go on eternally looking for new solutions. The source of this problem can be more or less severe: It may simply be due to the grammar&apos;s implementation as&apos;a certain program, or it may be intrinsic to the grammar. If it is not intrinsic to the grammar, one may attempt some kind of program transformation on the grammar—for &apos;instance a local transformation as goal reordering in clause bodies [4, 16], or a global transformation as left-recursion elimination [5, 3] 3 —in order to get a parsing program which displays a finite behavior.4 If such a transformation is possible in principle, we say that, intrinsically, the grammar has a finitely enumerable parsing problem.5 One example of a class of grammars which respect this crucial condition is provided by offline-parsable DCGs, once compiled as definite programs (see [9]).6 We have limited the former discussion to the case of parsing. The case of generation is treated in a parallel fashion, and one can similarly define the conditions in whic</context>
</contexts>
<marker>[16]</marker>
<rawString>Tomek Strzalkowski and Ping Peng. Automated inversion of logic grammars for generation. In Proceedings of the 28th Annual Meeting of the Association for Computational Linguistics, pages 212-19, Pittsburgh, PA, June 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gertjan van Noord</author>
</authors>
<title>Towards convenient bidirectional grammar formalisms.</title>
<date>1990</date>
<booktitle>In Proceedings of the 13th International Conference on Computational Linguistics,</booktitle>
<volume>2</volume>
<pages>294--298</pages>
<location>Helsinki,</location>
<contexts>
<context position="6240" citStr="[17]" startWordPosition="1010" endWordPosition="1010">tuitive notion that a certain grammar is, or is not, &amp;quot;reversible&amp;quot;. 30r more generally&apos;, any transformation exploiting theorems provable of the, grammar. Another instance of this technique is provided by the addition of conservative guides in [5], which &amp;quot;strengthen&amp;quot; the grammar on the basis of properties inferable from its form. 4 Another popular approach is to use a special-purpose interpreter, exploiting i properties of the grammar known a priori. [18] and [14] use this approach in the case of generation (see below). 5The description is simplified; see §3 for the exact definition. 6 See also [17] for a discussion of offline-parsability in the context of generation. 2 Definite programs and computation 2.1 Denotational and operational semantics of a definite program; complete and incomplete interpreters A definite program P is a finite set of clauses of the form (non-unit clauses): ATI, • • • , Tn) 4— Pi(Tii, • • • Tini) • • • Pm(Tmi • • • ,Tmn..) or of the form (unit clauses): ATI, • • • ,Tn) 4-- where the the p,pi are predicate symbols and the Tij are terms over a certain Herbrand universe of ground terms H. We will suppose that, among the predicates p defined by P, one, r, is privile</context>
</contexts>
<marker>[17]</marker>
<rawString>Gertjan van Noord. Towards convenient bidirectional grammar formalisms. In Proceedings of the 13th International Conference on Computational Linguistics, volume 2, pages 294-298, Helsinki, August 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gertjan van Noord</author>
</authors>
<title>BUG: A directed bottomup generator for unification based formalisms.</title>
<date>1989</date>
<tech>Technical report, RUU,</tech>
<institution>Department of Linguistics,</institution>
<location>Utrecht, Holland,</location>
<contexts>
<context position="6093" citStr="[18]" startWordPosition="983" endWordPosition="983">es all associated strings x and terminates. Inherent finite reversibility is the concept which, in my opinion, permit us to capture formally the intuitive notion that a certain grammar is, or is not, &amp;quot;reversible&amp;quot;. 30r more generally&apos;, any transformation exploiting theorems provable of the, grammar. Another instance of this technique is provided by the addition of conservative guides in [5], which &amp;quot;strengthen&amp;quot; the grammar on the basis of properties inferable from its form. 4 Another popular approach is to use a special-purpose interpreter, exploiting i properties of the grammar known a priori. [18] and [14] use this approach in the case of generation (see below). 5The description is simplified; see §3 for the exact definition. 6 See also [17] for a discussion of offline-parsability in the context of generation. 2 Definite programs and computation 2.1 Denotational and operational semantics of a definite program; complete and incomplete interpreters A definite program P is a finite set of clauses of the form (non-unit clauses): ATI, • • • , Tn) 4— Pi(Tii, • • • Tini) • • • Pm(Tmi • • • ,Tmn..) or of the form (unit clauses): ATI, • • • ,Tn) 4-- where the the p,pi are predicate symbols and </context>
</contexts>
<marker>[18]</marker>
<rawString>Gertjan van Noord. BUG: A directed bottomup generator for unification based formalisms. Technical report, RUU, Department of Linguistics, Utrecht, Holland, 1989.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Remi Zajac</author>
</authors>
<title>A uniform architecture for parsing, generation and transfer.</title>
<date>1991</date>
<booktitle>In Proceedings of the Workshop on Reversible Grammars in Natural Language Processing,</booktitle>
<location>Berkeley, CA,</location>
<contexts>
<context position="3913" citStr="[19]" startWordPosition="622" endWordPosition="622">m may not be &amp;quot;aware&amp;quot; that it has at some point already exhausted all the solutions that it will eventually 1We could have made some other choice, for instance some unification grammar formalism. The advantage of using definite programs in the present discussion is that they embody the whole unification paradigm in its purest form, that unification of terms is conceptually simpler (and less prone to misunderstandings) than unification of DAGs, and that the denotational and operational semantics of definite programs have been thoroughly studied. 2See e.g. [7, p. 59] and section §2.1.3. See also [19] in this volume for a related approach. 20 find, and go on eternally looking for new solutions. The source of this problem can be more or less severe: It may simply be due to the grammar&apos;s implementation as&apos;a certain program, or it may be intrinsic to the grammar. If it is not intrinsic to the grammar, one may attempt some kind of program transformation on the grammar—for &apos;instance a local transformation as goal reordering in clause bodies [4, 16], or a global transformation as left-recursion elimination [5, 3] 3 —in order to get a parsing program which displays a finite behavior.4 If such a t</context>
</contexts>
<marker>[19]</marker>
<rawString>Remi Zajac. A uniform architecture for parsing, generation and transfer. In Proceedings of the Workshop on Reversible Grammars in Natural Language Processing, Berkeley, CA, 1991.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>