<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.9949885">
An Attributive Logic of Set Descriptions and
Set Operations
</title>
<author confidence="0.735111">
Suresh Manandhar
HCRC Language Technology Group
</author>
<affiliation confidence="0.924572">
The University of Edinburgh
</affiliation>
<address confidence="0.9362095">
2 Buccleuch Place
Edinburgh EH8 9LW, UK
</address>
<email confidence="0.955385">
Internet: Suresh.Manandhar@ed.ac .uk
</email>
<sectionHeader confidence="0.987705" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9965131">
This paper provides a model theoretic semantics to fea-
ture terms augmented with set descriptions. We pro-
vide constraints to specify HPSG style set descriptions,
fixed cardinality set descriptions, set-membership con-
straints, restricted universal role quantifications, set
union, intersection, subset and disjointness. A sound,
complete and terminating consistency checking proce-
dure is provided to determine the consistency of any
given term in the logic. It is shown that determining
consistency of terms is a NP-complete problem.
</bodyText>
<keyword confidence="0.7743565">
Subject Areas: feature logic, constraint-based gram-
mars, HPSG
</keyword>
<sectionHeader confidence="0.996019" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999464973684211">
Grammatical formalisms such as HPSG
[Pollard and Sag, 1987] [Pollard and Sag, 1992] and
LFG [Kaplan and Bresnan, 1982] employ feature de-
scriptions [Kasper and Rounds, 1986] [Smolka, 1992]
as the primary means for stating linguistic theories.
However the descriptive machinery employed by these
formalisms easily exceed the descriptive machinery
available in feature logic [Smolka, 1992]. Furthermore
the descriptive machinery employed by both HPSG
and LFG is difficult (if not impossible) to state in fea-
ture based formalisms such as ALE [Carpenter, 1993],
TFS [Zajac, 1992] and CUF [Dorm and Dorna, 1993]
which augment feature logic with a type system.
One such expressive device employed both within
LFG [Kaplan and Bresnan, 1982] and HPSG but is
unavailable in feature logic is that of set descriptions.
Although various researchers have studied set de-
scriptions (with different semantics) [Rounds, 1988]
[Pollard and Moshier, 1990] two issues remain unad-
dressed. Firstly there has not been any work on consi-
stency checking techniques for feature terms augmen-
ted with set descriptions. Secondly, for applications
within grammatical theories such as the HPSG forma-
lism, set descriptions alone are not enough since de-
scriptions involving set union are also needed. Thus
to adequately address the knowledge representation
needs of current linguistic theories one needs to provide
set descriptions as well as mechanisms to manipulate
these.
In the HPSG grammar forma-
lism [Pollard and Sag, 1987], set descriptions are em-
ployed for the modelling of so called semantic indices
([Pollard and Sag, 1987] pp. 104). The attribute INDS
in the example in (1) is a multi-valued attribute whose
value models a set consisting of (at most) 2 objects.
However multi-valued attributes cannot be descri-
bed within feature logic [Kasper and Rounds, 1986]
[Smola, 1992].
</bodyText>
<sectionHeader confidence="0.87529925" genericHeader="introduction">
VAR 1:3 VAR
INDS [ RELN naming RELN naming
REST NAME sandy REST NAME kim
NAMED NAMED ID
</sectionHeader>
<bodyText confidence="0.999431666666667">
A further complication arises since to be able to deal
with anaphoric dependencies we think that set mem-
berships will be needed to resolve pronoun dependen-
cies. Equally, set unions may be called for to incremen-
tally construct discourse referents. Thus set-valued
extension to feature logic is insufficient on its own.
Similarly, set valued subcategorisation frames (see (2))
has been considered as a possibility within the HPSG
formalism.
</bodyText>
<equation confidence="0.841397">
[ tYNILOCIHEADICAT 1, 11
believes = SYNILOCISUBCAT
SYNILOCIHEADICAT v
</equation>
<bodyText confidence="0.999659">
But once set valued subcategorisation frames are em-
ployed, a set valued analog of the HPSG subcategorisa-
tion principle too is needed. In section 2 we show that
the set valued analog of the subcategorisation principle
can be adequately described by employing a disjoint
union operation over set descriptions as available wit-
hin the logic described in this paper.
</bodyText>
<sectionHeader confidence="0.477781" genericHeader="method">
2 The logic of Set descriptions
</sectionHeader>
<bodyText confidence="0.990640875">
In this section we provide the semantics of feature
terms augmented with set descriptions and various
constraints over set descriptions. We assume an al-
phabet consisting of x, y, z,...E V the set of variables;
f, g,... E .F the set of relation symbols; E C
the set of constant symbols; A, B, C,... E P the set
of primitive concept symbols and a, b,... E At the
set of atomic symbols. Furthermore, we require that
</bodyText>
<figure confidence="0.881940333333333">
T E P.
REL see
[
CONT SEER]
SEENEl
El
</figure>
<page confidence="0.996217">
255
</page>
<note confidence="0.9087925">
The syntax of our term language defined by the follo-
wing BNF definition:
</note>
<equation confidence="0.954884533333333">
P
S,T
f : T feature term
]f : T existential role quantification
V f : P universal role quantification
f : {T1, ...,T} set description
1: {T1,. ,T}= fixed cardinality set description
f : g(x)U h(y) union
f : g(x) n h(y) intersection
f g(x) subset
f (x) g(y) disjointness
S n T conjunction
where S,T,Ti, ,T,. are terms; a is an atom; c is a
constant; C is a primitive concept and f is a relation
symbol.
</equation>
<bodyText confidence="0.98753025">
The interpretation of relation symbols and atoms is
provided by an interpretation I =&lt; , I&gt; where /1/
is an arbitrary non-empty set and / is an interpretation
function that maps:
</bodyText>
<listItem confidence="0.998426">
1. every relation symbol f E to a binary relation
1/ CUI x U1
2. every atom a E At to an element al E 111
Notation:
• Let f1(e) denote the set {e&apos; I (e, e&apos;) E f}
• Let 11(e) f mean [1(e) =
I is required to satisfy the following properties :
1. if al a2 then af 0 (4 (distinctness)
2. for any atom a E At and for any relation f E .T there
</listItem>
<bodyText confidence="0.982137666666667">
exists no e Ell1 such that (a, e) E f1 (atomicity)
For a given interpretation I an I-assignment a is a
function that maps :
</bodyText>
<listItem confidence="0.999759714285714">
1. every variable x E V to an element a(x) E 141
2. every constant c E C to an element a(c) E 111 such
that for distinct constants c1, c2 : a(ci) a(c2)
3. every primitive concept C E P to a subset a(C) C
Ill such that:
• ce(1) = 0
• a(T) = /11
</listItem>
<bodyText confidence="0.7947654">
The interpretation of terms is provided by a denotation
function [[.]]i&apos;a that given an interpretation I and an
I-assignment a maps terms to subsets of /11.
The function Eli,&amp;quot; is defined as follows:
= {a(x)}
</bodyText>
<equation confidence="0.99914664">
= {al}
= {a(c)}
= a(C)
if : T1102 =
le E U/ I Be&apos; E 2,1/ : f (e) = {e&apos;} A e&apos; E
[Pf : =
fe E /41 I Be&apos; E 1,11 : (e, e&apos;) E f1 A e&apos; E [[2111,c1
E{Vf : Tr,&amp;quot; =
fe E Ve&apos; E Li/ : (e,e&apos;) E fi= e&apos; E IT11,c1
iffe: {Eliti&apos;}.1.3&apos;T 1
ein,}.11..73=en E tii :
f (e) = ,en}A
el E IIT1F,a A ... A en E ETnil,a}
irt.iLi {71, Tn}=111,
Li 1 ,&amp;quot;, nJ=jic =
le E Li/ IBe1,... Be, E U1 :
I f/(e) I = n f I (e) = {ei, • • • en} A
E A ... A en E iTnFa}
: g(x) U h(y)P =
{e EU/ (e) = (a()) U (a(y))}
: g(x) n h(y)Fa =
{e E f (e) = (a(x)) n (a(y))}
l[f Q g(x)l&amp;quot;&amp;quot; =
{e E I 11(e) (a(x))}
J[f(x) g(y)1I&amp;quot; =
</equation>
<listItem confidence="0.933523">
• 0 if f ((x)) n (a(y)) 0
• ur if f. [(c(x)) n gi (a(y)) = 0
</listItem>
<equation confidence="0.85348">
[s n 71]I&apos;a = isFa n FF.
FTF,a = ti/ — ETFa
</equation>
<bodyText confidence="0.724778666666667">
The above definitions fix the syntax and semantics of
every term.
It follows from the above definitions that:
</bodyText>
<equation confidence="0.842944">
f : T f : {T} f : {T},
</equation>
<figureCaption confidence="0.892181">
Figure 1
</figureCaption>
<bodyText confidence="0.8760244">
Although disjoint union is not a primitive in the logic
it can easily be defined by employing set disjointness
and set union operations:
f : g(x) W h(y) = de f g(x) 0 h(y) n f : g(x)U h(y)
Thus disjoint set union is exactly like set union except
that it additionally requires the sets denoted by g(x)
and h(y) to be disjoint.
The set-valued description of the subcategorisation
principle can now be stated as given in example (3).
(3) Subcategorisation Principle
</bodyText>
<equation confidence="0.750822666666667">
[
SYNILOC Y
DTRS X n H-DTRISYNILOCISUBCAT c-dtrs(X) W subcat(Y)
</equation>
<bodyText confidence="0.997430666666667">
The description in (3) simply states that the subcat
value of the H-DTR is the disjoint union of the subcat
value of the mother and the values of C-DTRS. Note
that the disjoint union operation is the right operation
to be specified to split the set into two disjoint subsets.
Employing just union operation would not work since
</bodyText>
<equation confidence="0.757889">
I I
</equation>
<page confidence="0.985013">
256
</page>
<figureCaption confidence="0.997514">
Figure 2: Decomposition rules
</figureCaption>
<equation confidence="0.974466882352941">
Decomposition rules
(DFeat) x=F:TA
x=F:yAy=TAC,
if y is new and T is not a variable and F ranges over 3f, f
x=Vf :ZAC,
(DForall)
x = Vf :yAy=ZAC,
if y is new and -6 ranges over a, c.
x = f :{T1,...,Tn} A Cs
x = f : {xi, ,x,-} A = A ... A xn = Tn A C,
if xi, .. • ,Xn are new and at least one of Ti :1 &lt; i &lt; n is not a variable
(DSetF)
x = f: , xn} A x = f: {xi, ... ,xm}= A xi =T1 A ... A xn = Tn A Cs
if xl, ,x,-, are new and at least one of T :1 &lt;i &lt; n is not a variable
(DConj) x=SnT AC,
(DSet)
x=SAx=TAC,
</equation>
<bodyText confidence="0.976490285714286">
it would permit repetition between members of the
SUBCAT attribute and C-DTRS attribute.
Alternatively, we can assume that N is the only multi-
valued relation symbol while both SUBCAT and C-DTRS
are single-valued and then employ the intuitively ap-
pealing sub categorisation principle given in (4).
(4) Subcategorisation Principle
</bodyText>
<equation confidence="0.93623325">
SYNILOCISUBCAT Y
[
DTRS [H-DTRISYNILOCISUBCATIN N(X)W N(Y)]
C-DTRS x
</equation>
<bodyText confidence="0.9999510625">
With the availability of set operations, multi-valued
structures can be incrementally built. For instance, by
employing union operations, semantic indices can be
incrementally constructed and by employing members-
hip constraints on the set of semantic indices pronoun
resolution may be carried out.
The set difference operation f : g(y)— h(z) is not avai-
lable from the constructs described so far. However,
assume that we are given the term x n f : g(y) — h(z)
and it is known that 111(a(z)) C (a(y)) for every in-
terpretation I, a such that 1[x n f : g(y)—h(z)F&apos; 0 0.
Then the term x fl f : g(y) — h(z) (assuming the ob-
vious interpretation for the set difference operation) is
consistent if the term yng:f (x) W h(z) is consistent.
This is so since for sets G, F, H:G-F=HAFCG
if G = F Eti H. See figure 1 for verification.
</bodyText>
<sectionHeader confidence="0.946069" genericHeader="method">
3 Consistency checking
</sectionHeader>
<bodyText confidence="0.999958181818182">
To employ a term language for knowledge representa-
tion tasks or in constraint programming languages the
minimal operation that needs to be supported is that
of consistency checking of terms.
A term T is consistent if there exists an interpreta-
tion I and an I-assignment a such that [[T]i&amp;quot; 0 0.
In order to develop constraint solving algorithms for
consistency testing of terms we follow the approaches
in [Smollca, 1992] [Hollunder and Nutt, 1990].
A containment constraint is a constraint of the
form x = T where x is a variable and T is an term.
</bodyText>
<figureCaption confidence="0.989673">
Figure 3: Constraint simplification rules - I
</figureCaption>
<bodyText confidence="0.9996546">
In addition, for the purposes of consistency checking
we need to introduce disjunctive constraints which
are of the form x = xi U U
We say that an interpretation I and an I-assignment
a satisfies a constraint K written I, a =K if
</bodyText>
<listItem confidence="0.995838">
• I, a =x = T &lt;=*- a(x) E
• /, a x = xi U U xn a(x) = a(xi) for some
xi :1 &lt;i &lt; n.
</listItem>
<bodyText confidence="0.949422071428571">
A constraint system a, is a conjunction of con-
straints.
We say that an interpretation I and an I-assignment
a satisfy a constraint system C, if I, a satisfies every
constraint in Cs.
The following lemma demonstrates the usefulness of
constraint systems for the purposes of consistency
checking.
Lemma 1 An term T is consistent if there exists a
variable x, an interpretation I and an I-assignment a
such that I, a satisfies the constraint system x = T.
Now we are ready to turn our attention to constraint
solving rules that will allow us to determine the con-
sistency of a given constraint system.
</bodyText>
<equation confidence="0.590607">
Constraint simplification rules - I
x=yAC,
(SEquals)
x = y A [x I y]C,
</equation>
<bodyText confidence="0.659766142857143">
if x y and x occurs in Cs
x=e-Ay=&amp;quot;eAC,
(SConst)
x=yAx=cAC,
where ranges over a, c.
(SFeat) x=f:yAx=F:zA Cs
x=f:yAy=zAC,
where F ranges over f ,]f,V f
(SExists) x =3f :y Ax =Vf :z
x=f:yAy=zAa,
(SForallE) x=Vf:-0- Ax=]f :y AC,
x = Vf : C A x = : yAy=CAC„
if C ranges over C, --C, and
C, V y = C.
</bodyText>
<page confidence="0.900516">
257
</page>
<figureCaption confidence="0.998971">
Figure 4: Constraint simplification rules - II
</figureCaption>
<bodyText confidence="0.973712666666667">
Constraint simplification rules - II
(SSetF) x=F:yAx= f: {x1,.. • ,xn} A Cs
where F ranges over f ,V
</bodyText>
<equation confidence="0.836189333333333">
x=f:yAy=xiA...Ay=xnACs
x = 1: {y} A Cs
x=f:yACs
x = f : •• • ,xn} A Cs
x f : {xi, • • • &apos;xi, • • , • • • , Xn} A Cs
if xi
(SForall) = Vf x = : {x1, xn} A Cs
x = f : {xi, ... ,xn} A = A ... A = A Cs
if C ranges over -ix and
there exists xi : 1 &lt;i &lt; n such that Cs 1/ xi =C.
(SSetE) x=3f :yAx= f :{xi,...,xn} ACs
x = f : {xi, . , xn} A y = LJ ... xn A Cs
(SSetSet) x = f : fx1,... , xn} A x = f : , ym} A C,
{xi,
= yi yni A ... A xn = U ymA
</equation>
<bodyText confidence="0.9608755">
= x1U ... UXn A ... A yn, = x1U ... LI Xn A Cs
where n &lt; m
</bodyText>
<equation confidence="0.933995714285714">
x = U xn A Cs
x=xj LJ xn A = x, A Cs
if 1 &lt;i &lt; n and
there is no x3,1 &lt; j &lt;n such that Cs x = x3
(SSet)
(SDup)
(SDis)
</equation>
<bodyText confidence="0.999816477272727">
We say that a constraint system C, is basic if none of
the decomposition rules (see figure 2) are applicable to
Cs.
The purpose of the decomposition rules is to break
down a complex constraint into possibly a number of
simpler constraints upon which the constraint simpli-
fication rules (see figures 3, 4 and 5 ) can apply by
possibly introducing new variables.
The first phase of consistency checking of a term T
consists of exhaustively applying the decomposition
rules to an initial constraint of the form x = T (where
x does not occur in T) until no rules are applicable.
This transforms any given constraint system into basic
form.
The constraint simplification rules (see figures 3, 4 and
5) either eliminate variable equalities of the form x =
y or generate them from existing constraints. However,
they do not introduce new variables.
The constraint simplification rules given in figure 3 are
the analog of the feature simplification rules provided
in [Smolka, 1991]. The main difference being that our
simplification rules have been modified to deal with
relation symbols as opposed to just feature symbols.
The constraint simplification rules given in figure 4
simplify constraints involving set descriptions when
they interact with other constraints such as feature
constraints - rule (SSetF), singleton sets - rule (SSet),
duplicate elements in a set - rule (SDup), universally
quantified constraint - rule (SForall), another set de-
scription - rule (SSetSet). Rule (SDis) on the other
hand simplifies disjunctive constraints. Amongst all
the constraint simplification rules in figures 3 and 4
only rule (SDis) is non-deterministic and creates a n-
ary choice point.
Rules (SSet) and (SDup) are redundant as comple-
teness (see section below) is not affected by these rules.
However these rules result in a simpler normal form.
The following syntactic notion of entailment is em-
ployed to render a slightly compact presentation of the
constraint solving rules for dealing with set operations
given in figure 5.
A constraint system C, syntactically entails the (con-
junction of) constraint(s) ck if C, cb is derivable from
the following deduction rules:
</bodyText>
<listItem confidence="0.996228">
1. A Cs I-
2. C, x = x
3. C5l-x=y--&gt;C31-y= x
4. Cs 1-x=yACsl-y=z—C,,F-x = z
5. Cs x = Cs y =
6. C8l-x=f:y—&gt;C31-x= 3f:y
7. Csl-x=f:y—*C51-x=Vf:y
8. Cs F- x = f : 1. , .1 —&gt; Cs x = 3f :
</listItem>
<bodyText confidence="0.999823444444444">
Note that the above definitions are an incomplete list
of deduction rules. However Cs I- q implies Cs
where = is the semantic entailment relation defined as
for predicate logic.
We write Cs 171 0 if it is not the case that Cs 0.
The constraint simplification rules given in figure 5
deal with constraints involving set operations. Rule
(C) propagates g-values of y into f-values of x in
the presence of the constraint x = f :D g(y). Rule
</bodyText>
<page confidence="0.99284">
258
</page>
<figureCaption confidence="0.998589">
Figure 5: Constraint solving with set operations
</figureCaption>
<bodyText confidence="0.9550305">
(ULeft) (correspondingly Rule (URight)) adds the
constraint x = f :D g(y) (correspondingly x = f :D
h(z)) in the presence of the constraint x = f : g(y) U
h(z). Also in the presence of x = f : g(y)U h(z) rule
(UDown) non-deterministically propagates an f-value
of x to either an g-value of y or an h-value of z (if
neither already holds). The notation y = 3g : xi I z =
3h : xi denotes a non-deterministic choice between
y =- 3g : xi and z = ah: xt. Rule (nDown) propaga-
tes an f-value of x both as a g-value of y and h-value of
z in the presence of the constraint x = f : g(y) fl h(z).
Finally, rule (nUp) propagates a common g-value of y
and h-value of z as an f-value of x in the presence of
the constraint x = f : g(y) 11 h(z).
</bodyText>
<sectionHeader confidence="0.991001" genericHeader="method">
4 Invariance, Completeness and
Termination
</sectionHeader>
<bodyText confidence="0.997466416666667">
In this section we establish the main results of this
paper - namely that our consistency checking proce-
dure for set descriptions and set operations is invari-
ant, complete and terminating. In other words, we
have a decision procedure for determining the consi-
stency of terms in our extended feature logic.
For the purpose of showing invariance of our ru-
les we distinguish between deterministic and non-
deterministic rules. Amongst all our rules only rule
(SDis) given in figure 4 and rule (UDown) are non-
deterministic while all the other rules are determini-
stic.
</bodyText>
<construct confidence="0.5202618">
Theorem 2 (Invariance) 1. If a decomposition rule
transforms C, to Cs then C, is consistent if C; is
consistent.
2. Let I, a be any interpretation, assignment pair and
let C, be any constraint system.
</construct>
<listItem confidence="0.948895285714286">
• If a deterministic simplification rule transforms
C, to C; then:
I, a Cs if I, a C&apos;s
• If a non-deterministic simplification rule applies
to C, then there is at least one non-deterministic
choice which transforms C, to C; such that:
I, a =C, iff /, a Cis
</listItem>
<bodyText confidence="0.991688857142857">
A constraint system Cs is in normal form if no rules
are applicable to C,.
Let succ(x, f) denote the set:
succ(x, f) = {y I Cs x = 3f : y}
A constraint system C, in normal form contains a
clash if there exists a variable x in Cs such that any
of the following conditions are satisfied :
</bodyText>
<listItem confidence="0.995633555555556">
1. Cs x = al and Cs x = a2 such that al a2
2. Cs x = ci and Cs x = c2 such that ci c2
3. Cs x = 3 and Cs I- x =
where S ranges over x,a,c,C.
4. Cs x = 3f : y and C, x = a
5. Cs f (x) g(y) and succ(x, n succ(y, g) 0
6. Cs x = f: {x1,. ,x,}= and Isucc(x,ffl &lt; n
If Cs does not contain a clash then Cs is called clash-
free.
</listItem>
<bodyText confidence="0.981533761904762">
The constraint solving process can terminate as soon
as a clash-free constraint system in normal form is fo-
und or alternatively all the choice points are exhau-
sted.
The purpose of the clash definition is highlighted in
the completeness theorem given below.
For a constraint system C, in normal form an equiva-
lence relation c on variables occurring in Cs is defined
as follows:
x y if C, h x = y
For a variable x we represent its equivalence class by
[x].
Theorem 3 (Completeness) A constraint system
C, in normal form is consistent if C, is clash-free.
Proof Sketch: For the first part, let Cs be a constraint
system containing a clash then it is clear from the de-
finition of clash that there is no interpretation I and
I-assignment a which satisfies Cs.
Let Cs be a clash-free constraint system in normal
form.
We shall construct an interpretation R. =&lt; UR, .R &gt;
</bodyText>
<figure confidence="0.964385333333333">
Extended Constraint simplification rules
x = f g(y) A Cs
x =f g(y) A x = 3f :y,AC8
if:
• Cs x = 3f : yi and
• Cs y = 3g : yi
x = f : g(y) U h(z) A C,
x = f : g(y)U h(z) Ax=fQ g(y) A Cs
if Cs x = f :2 9(Y)
uRi ght x = f : g(y) U h(z) A Cs
)
(
x = f : g(y)U h(z) A x = f :D h(z) A Cs
if C, x = f :2 h(z)
(UDown)
x = f : g(y) U h(z) A Cs
x = f : g(y) U h(z) A y = : I z = : xi A Cs
if:
• Cs V y = : xi and
• Cs = Dh :xi and
• Cs x = 3f : xi
(nDown)
x = f g(y) n h(z) A C,
x = f : g(y) n h(z) A y = 39 : xi A z = 3h : xi A Cs
if:
• (C, V y =ag : xi or Cs I/ z = 3h : xi) and
• Cs h x = ]f : xi
x = f : g(y) n h(z) A C,
x = f : g(y) n h(z) A x = 3f : xi A Cs
if:
• C, V x = Df : xi and
• C, y = 3g : xi and
• Cs h z = 3h : xi
(c)
(ULe f t)
(nup)
</figure>
<page confidence="0.995935">
259
</page>
<bodyText confidence="0.999405">
and a variable assignment a such that 7?., a = C,.
Let UR = V Li At C.
The assignment function a is defined as follows:
</bodyText>
<listItem confidence="0.998369818181818">
1. For every variable x in V
(a) if Ca x = a then a(x) = a
(b) if the previous condition does not apply then
a(x) = choose([x]) where choose([x]) denotes a
unique representative (chosen arbitrarily) from
the equivalence class [x].
2. For every constant c in C:
(a) if C, x = c then a(c) = a(x)
(b) if c is a constant such that the previous condition
does not apply then a(c) = c
3. For every primitive concept C in 2:
</listItem>
<equation confidence="0.856534">
a(C) = {a(x) I Cs F- x = c}
</equation>
<bodyText confidence="0.923636">
The interpretation function .R is defined as follows:
</bodyText>
<listItem confidence="0.99922">
• fR(x) = succ(x, f)
• aR = a
</listItem>
<bodyText confidence="0.914944428571429">
It can be shown by a case by case analysis that for
every constraint K in Ca:
7Z, a = K.
Hence we have the theorem.
Theorem 4 (Termination)
The consistency checking procedure terminates in a fi-
nite number of steps.
</bodyText>
<listItem confidence="0.963280888888889">
Proof Sketch: Termination is obvious if we observe the
following properties:
1. Since decomposition rules breakdown terms into
smaller ones these rules must terminate.
2. None of the simplification rules introduce new va-
riables and hence there is an upper bound on the
number of variables.
3. Every simplification rule does either of the following:
(a) reduces the &apos;effective&apos; number of variables.
</listItem>
<bodyText confidence="0.9896206">
A variable x is considered to be ineffective if it
occurs only once in C, within the constraint x =
y such that rule (SEquals) does not apply. A
variable that is not ineffective is considered to be
effective.
</bodyText>
<listItem confidence="0.58296">
(b) adds a constraint of the form x = C where C
</listItem>
<bodyText confidence="0.999883846153846">
ranges over y, a, c, C, , —C which means
there is an upper bound on the number of con-
straints of the form x = C that the simplification
rules can add. This is so since the number of va-
riables, atoms, constants and primitive concepts
are bounded for every constraint system in basic
form.
increases the size of succ(x, f). But the size of
succ(x, f) is bounded by the number of variables
in C, which remains constant during the applica-
tion of the simplification rules. Hence our con-
straint solving rules cannot indefinitely increase
the size of succ(x, f).
</bodyText>
<sectionHeader confidence="0.79879" genericHeader="method">
5 NP-completeness
</sectionHeader>
<bodyText confidence="0.999324714285714">
In this section, we show that consistency checking
of terms within the logic described in this paper is
NP-complete. This result holds even if the terms
involving set operations are excluded. We prove
this result by providing a polynomial time transla-
tion of the well-known NP-complete problem of de-
termining the satisfiability of propositional formulas
[Garey and Johnson, 1979].
Theorem 5 (NP-Completeness) Determining
consistency of terms is NP-Complete.
Proof: Let 0 be any given propositional formula for
which consistency is to be determined. We split our
translation into two intuitive parts : truth assignment
denoted by A(0) and evaluation denoted by r(0).
Let a, b,. . . be the set of propositional variables occur-
ring in 0. We translate every propositional variable a
by a variable xa in our logic. Let f be some relation
symbol. Let true, false be two atoms.
Furthermore, let xl, x2, ... be a finite set of variables
distinct from the ones introduced above.
We define the translation function A(0) by:
</bodyText>
<equation confidence="0.964063666666667">
A(0)= f: {true, false}n
3f : xa nRf : xb n ...n
3f 11 n 3f : 12 fl
</equation>
<bodyText confidence="0.99874375">
The above description forces each of the variable
xa,1b,... and each of the variables xl, x2, . to be
either equivalent to true or false.
We define the evaluation function 7-(0) by:
</bodyText>
<equation confidence="0.999362">
r(a) = xci
r(S8cT) = r(S) n 7-(T)
</equation>
<bodyText confidence="0.978745769230769">
7-(s VT) = xi n 3f : (f: (S), r (T)} n 3f : xi)
where Xi E {Xi, 12, ...} is a new variable
= xi rI 2f: (r(S)n
where xi E {X1,12, ...} is a new variable
Intuitively speaking T can be understood as follows.
Evaluation of a propositional variable is just its value;
evaluating a conjunction amounts to evaluating each
of the conjuncts; evaluating a disjunction amounts to
evaluating either of the disjuncts and finally evaluating
a negation involves choosing something other than the
value of the term.
Determining satisfiability of 0 then amounts to deter-
mining the consistency of the following term:
</bodyText>
<equation confidence="0.805649">
3f : A(0) n ]f : (true n TM)
</equation>
<bodyText confidence="0.9998583">
Note that the term true n r(0) forces the value of r(0)
to be true. This translation demonstrates that deter-
mining consistency of terms is NP-hard.
On the other hand, every deterministic completion of
our constraint solving rules terminate in polynomial
time since they do not generate new variables and the
number of new constraints are polynomially bounded.
This means determining consistency of terms is NP-
easy. Hence, we conclude that determining consistency
of terms is NP-complete.
</bodyText>
<sectionHeader confidence="0.7316805" genericHeader="method">
6 Translation to Schonfinkel-Bernays
class
</sectionHeader>
<bodyText confidence="0.997752">
The Schonfinkel-Bernays class (see [Lewis, 1980]) con-
sists of function-free first-order formulae which have
</bodyText>
<page confidence="0.984137">
260
</page>
<bodyText confidence="0.971354476190476">
the form:
3x1• xThVy1 ymd
In this section we show that the attributive logic
developed in this paper can be encoded within the
Schonfinkel-Bernays subclass of first-order formulae by
extending the approach developed in [Johnson, 1991].
However formulae such as V f: (3 f: (V f : T)) which
involve an embedded existential quantification cannot
be translated into the Schi5nfinkel-Bernays class. This
means that an unrestricted variant of our logic which
does not restrict the universal role quantification can-
not be expressed within the Schonfinkel-Bernays class.
In order to put things more concretely, we provide
a translation of every construct in our logic into the
Schonfinkel-Bernays class.
Let T be any extended feature term. Let x be a va-
riable free in T. Then T is consistent if the formula
(x = T)6 is consistent where 5 is a translation function
from our extended feature logic into the Schonfinkel-
Bernays class. Here we provide only the essential de-
finitions of 6:
</bodyText>
<listItem confidence="0.948195666666667">
• (x = a)8 = x = a
• (x = -,a)6 = x a
• (x =f : T)6 =
</listItem>
<bodyText confidence="0.703518">
f (x,y) &amp; (y = T)5 &amp; VV(.i(x,V) —&gt; y =
where y is a new variable
</bodyText>
<listItem confidence="0.9493802">
• (x = 3f : T)6 = f (x, y) &amp; (y = T)6
where y is a new variable
• (x = Vf a)8 = Vy( f (x, y) —&gt; y = a)
• (x Vf : -,a)6 = Vy(f (x, y) ---+ y a)
• (x = f : ,Tri})6 =
</listItem>
<equation confidence="0.984748333333333">
f (x, xi) &amp; • • • &amp; f (x,xn)&amp;
VY (f (x, Y) y xi v v y =
(x1 = T1)8 Sz (xi = Tn)8
</equation>
<bodyText confidence="0.96582">
where x1,.., xi, are new variables
</bodyText>
<listItem confidence="0.658881">
• (x f : g(y) U h(z))5 =
</listItem>
<equation confidence="0.631367666666667">
V xi( f (x, xi) ---+ g(y, xi) V h(z, xi)) &amp;
Vyi(g(y, yi) f (x,y,)) &amp;
V zi(h(z , zi) f(xzi))
• (x = f : (y) g(z))6 =
Vyiz ( f (y , yi) &amp; g(z, Zi) -4 yi zi)
• (x = S T)6 = (x = s)6 &amp; (x
</equation>
<bodyText confidence="0.9991825">
These translation rules essentially mimic the decom-
position rules given in figure 2.
Furthermore for every atom a and every feature f in
T we need the following axiom:
</bodyText>
<listItem confidence="0.761590333333333">
• Vax(--, f (a, x))
For every distinct atoms a, b in T we need the axiom:
• a b
</listItem>
<bodyText confidence="0.99990725">
Taking into account the NP-completeness result
established earlier this translation identifies a NP-
complete subclass of formulae within the Schonfinkel-
Bernays class which is suited for NL applications.
</bodyText>
<sectionHeader confidence="0.998735" genericHeader="related work">
7 Related Work
</sectionHeader>
<bodyText confidence="0.99994659375">
Feature logics and concept languages such as
KL-ONE are closely related family of languages
[Nebel and Smolka, 1991]. The principal difference
being that feature logics interpret attributive labels
as functional binary relations while concept langua-
ges interpret them as just binary relations. However
the integration of concept languages with feature lo-
gics has been problematic due to the fact the while
path equations do not lead to increased computatio-
nal complexity in feature logic the addition of role-
value-maps (which are the relational analog of path
equations) in concept languages causes undecidabi-
lity [Schmidt-Schau13, 1989]. This blocks a straight-
forward integration of a variable-free concept language
such as ALC [Schmidt-Schaui3 and Smolka, 1991] with
a variable-free feature logic [Smolka, 1991].
In [Manandhar, 1993] the addition of variables, fea-
ture symbols and set descriptions to ALC is investi-
gated providing an alternative method for integrating
concept languages and feature logics. It is shown that
set descriptions can be translated into the so called
&amp;quot;number restrictions&amp;quot; available within concept langu-
ages such as BACK [von Luck et al., 1987]. However,
the propositionally complete languages ALV and ALS
investigated in [Manandhar, 1993] are PSPACE-hard
languages which do not support set operations.
The work described in this paper describes yet another
unexplored dimension for concept languages - that of
a restricted concept language with variables, feature
symbols, set descriptions and set operations for which
the consistency checking problem is within the com-
plexity class NP.
</bodyText>
<sectionHeader confidence="0.894084" genericHeader="conclusions">
8 Summary and Conclusions
</sectionHeader>
<bodyText confidence="0.999666407407407">
In this paper we have provided an extended feature lo-
gic (excluding disjunctions and negations) with a range
of constraints involving set descriptions. These con-
straints are set descriptions, fixed cardinality set de-
scriptions, set-membership constraints, restricted uni-
versal role quantifications, set union, set intersection,
subset and disjointness. We have given a model theo-
retic semantics to our extended logic which shows that
a simple and elegant formalisation of set descriptions
is possible if we add relational attributes to our logic
as opposed to just functional attributes available in
feature logic.
For realistic implementation of the logic described in
this paper, further investigation is needed to develop
concrete algorithms that are reasonably efficient in the
average case. The consistency checking procedure de-
scribed in this paper abstracts away from algorithmic
considerations and clearly modest improvements to the
basic algorithm suggested in this paper are feasible.
However, a report on such improvements is beyond
the scope of this paper.
For applications within constraint based grammar
formalisms such as HPSG, minimally a type sy-
stem [Carpenter, 1992] and/or a Horn-like extension
[Holifeld and Smolka, 1988] will be necessary.
We believe that the logic described in this paper pro-
vides both a better picture of the formal aspects of
</bodyText>
<page confidence="0.990215">
261
</page>
<bodyText confidence="0.9998166">
current constraint based grammar formalisms which
employ set descriptions and at the same time gives
a basis for building knowledge representation tools in
order to support grammar development within these
formalisms.
</bodyText>
<sectionHeader confidence="0.993015" genericHeader="acknowledgments">
9 Acknowledgments
</sectionHeader>
<bodyText confidence="0.999534857142857">
The work described here has been carried out as part
of the EC-funded project LRE-61-061 RGR (Reusa-
bility of Grammatical Resources). A longer version
of the paper is available in [Erbach et al., 1993]. The
work described is a further development of the aut-
hor&apos;s PhD thesis carried out at the Department of Ar-
tificial Intelligence, University of Edinburgh. I thank
my supervisors Chris Mellish and Alan Smaill for their
guidance. I have also benefited from comments by an
anonymous reviewer and discussions with Chris Brew,
Bob Carpenter, Jochen Done and Herbert Ruessink.
The Human Communication Research Centre (HCRC)
is supported by the Economic and Social Research
Council (UK).
</bodyText>
<sectionHeader confidence="0.999203" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999939810526316">
[Carpenter, 1992] Bob Carpenter. The Logic of Typed Fea-
ture Structures. Cambridge University Press, 1992.
[Carpenter, 1993] Bob Carpenter. ALE:Attribute Logic
Engine Users Guide, Version #. Technical report, Car-
negie Mellon University, Pittsburgh, PA 15213, 1993.
[Dorre and Dorna, 1993] Jochen Dorre and Michael
Dorna. CUF: A Formalism for Linguistic Knowledge
Representation. Dyana-2 deliverable, IMS, Stuttgart,
Germany, August 1993.
[Erbach et al., 1993] Gregor Erbach, Mark van der Kraan,
Suresh Manandhar, M. Andrew Moshier, Herbert Rues-
sink, and Craig Thiersch. Specification of Datatypes.
In Deliverable D.B of LRE-61-061 &amp;quot;The Reusability of
Grammatical Resources&amp;quot;. 1993.
[Garey and Johnson, 1979] M. R. Garey and D. S. John-
son. Computers and Intractability : A Guide to the
Theory of NP-Completeness. Freeman, San Francisco,
1979.
[Hohfeld and Smolka, 1988] Markus Hohfeld and Gert
Smolka. Definite relations over constraint languages. LI-
LOG Report 53, IBM Deutschland, Stuttgart, Germany,
October 1988.
[Hollunder and Nutt, 1990] B. Hollunder and W. Nutt.
Subsumption Algorithms for Concept Languages. Rese-
arch Report RR-90-04, German Research Center for Ar-
tificial Intelligence (DFKI), Stuhlsatzenhausweg 3, 6600
Saarbriicken 11, Germany, 1990.
[Johnson, 1991] Mask Johnson. Features and Formulae.
Computational Linguistics, 17(2):131-151, June 1991.
[Kaplan and Bresnan, 1982] Ronald M. Kaplan and Joan
Bresnan. Lexical-Functional Grammar: A formal system
for grammatical representation. In Joan Bresnan, editor,
The Mental Representation of Grammatical Relations,
pages 173 — 281. MIT Press, Cambridge, Massachussets,
1982.
[Kasper and Rounds, 1986] Robert Kasper and William
Rounds. A logical semantics for feature structures. In
24th Annual Meeting of the Association for Computatio-
nal Linguistics, Columbia University, New York, pages
257-265, 1986.
[Lewis, 1980] Harry R. Lewis. Complexity Results for
Classes of Quantificational Formulae. Journal of Com-
puter and System Sciences, 21:317-353, 1980.
[Manandhar, 1993] Suresh Manandhar. Relational Exten-
sions to Feature Logic: Applications to Constraint Based
Grammars. PhD thesis, Department of Artificial Intel-
ligence, University of Edinburgh, 1993.
[Nebel and Smolka, 1991] Bernhard Nebel and
Gert Smolka. Attributive description formalisms and
the rest of the world. Research Report RR-91-15, Ger-
man Research Center for Artificial Intelligence (DFKI),
Saarbriicken, Germany, May 1991.
[Pollard and Moshier, 1990] Carl J. Pollard and M. Drew
Moshier. Unifying partial descriptions of sets. In Phi-
lip P. Hanson, editor, Information, Language and Cogni-
tion. University of British Columbia Press, Vancouver,
Canada, 1990. Vancouver Studies in Cognitive Science,
no. 1.
[Pollard and Sag, 1987] Carl Pollard and Ivan Andrew
Sag. Information-Based Syntax and Semantics: Volume
1 Fundamentals, volume 13 of Lecture Notes. Center for
the Study of Language and Information, Stanford, CA,
1987.
[Pollard and Sag, 1992] Carl Pollard and Ivan Andrew
Sag. Head-driven Phrase Structure Grammar: Volume
2. MIT Press, 1992. Forthcoming.
[Rounds, 1988] William C. Rounds. Set values for
unification-based grammar formalisms and logic pro-
gramming. Technical report, Center for the Study of
Language and Information, Stanford, CA, 1988.
[Schmidt-Schau13 and Smolka, 1991] Manfred
Schmidt-Schaul3 and Gert Smolka. Attributive Concept
Descriptions with Unions and Complements. Artificial
Intelligence, 48:1-26, 1991. Also available as IWBS Re-
port 68, IBM Germany, Scientific Center, IWBS, Stutt-
gart, Germary, June 1989.
[Schmidt-Schaul3, 1989] Manfred Schmidt-SchauB. Sub-
sumption in KL-ONE is undecidable. In First Interna-
tional Conference on Principles of Knowledge Represen-
tation and Reasoning, KR&apos; 89, Toronto, Canada, pages
421-431, May 1989.
[Smolka, 1991] Gert Smolka. A feature logic with subsorts.
In Jürgen Wedekind and C. Rohrer (eds.), editors, Uni-
fication in Grammar. MIT Press, 1991. Also appeared
as LILOG Report no. 33, IWBS, IBM Deutschland.
[Smolka, 1992] Gert Smolka. Feature constraint logics for
unification grammars. Journal of Logic Programming,
12:51-87, 1992.
[von Luck et al., 1987] K. von Luck, B. Nebel, C. Pelta-
son, and A. Schmiedel. The Anatomy of the BACK Sy-
stem. KIT Report 41, Department of Computer Science,
Technische Universitat Berlin, Berlin, Germany, 1987.
[Zajac, 1992] Remi Zajac. Inheritance and Constraint-
Based Grammar Formalisms. Computational Lingui-
stics, 18(2):159-182, 1992.
</reference>
<page confidence="0.997295">
262
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.373042">
<title confidence="0.998048">An Attributive Logic of Set Descriptions and Set Operations</title>
<author confidence="0.972903">Suresh Manandhar</author>
<affiliation confidence="0.935925666666667">HCRC Language Technology Group The University of Edinburgh 2 Buccleuch Place</affiliation>
<address confidence="0.99663">Edinburgh EH8 9LW, UK</address>
<email confidence="0.930815">.uk</email>
<abstract confidence="0.999574272727273">This paper provides a model theoretic semantics to feature terms augmented with set descriptions. We provide constraints to specify HPSG style set descriptions, fixed cardinality set descriptions, set-membership constraints, restricted universal role quantifications, set union, intersection, subset and disjointness. A sound, complete and terminating consistency checking procedure is provided to determine the consistency of any given term in the logic. It is shown that determining consistency of terms is a NP-complete problem.</abstract>
<note confidence="0.6850325">Subject Areas: feature logic, constraint-based grammars, HPSG</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Bob Carpenter</author>
</authors>
<title>The Logic of Typed Feature Structures.</title>
<date>1992</date>
<publisher>Cambridge University Press,</publisher>
<marker>[Carpenter, 1992]</marker>
<rawString>Bob Carpenter. The Logic of Typed Feature Structures. Cambridge University Press, 1992.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bob Carpenter</author>
</authors>
<title>ALE:Attribute Logic Engine Users Guide, Version #.</title>
<date>1993</date>
<tech>Technical report,</tech>
<institution>Carnegie Mellon University,</institution>
<location>Pittsburgh, PA 15213,</location>
<marker>[Carpenter, 1993]</marker>
<rawString>Bob Carpenter. ALE:Attribute Logic Engine Users Guide, Version #. Technical report, Carnegie Mellon University, Pittsburgh, PA 15213, 1993.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jochen Dorre</author>
<author>Michael Dorna</author>
</authors>
<title>CUF: A Formalism for Linguistic Knowledge Representation.</title>
<date>1993</date>
<booktitle>Dyana-2 deliverable, IMS,</booktitle>
<location>Stuttgart, Germany,</location>
<marker>[Dorre and Dorna, 1993]</marker>
<rawString>Jochen Dorre and Michael Dorna. CUF: A Formalism for Linguistic Knowledge Representation. Dyana-2 deliverable, IMS, Stuttgart, Germany, August 1993.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gregor Erbach</author>
<author>Mark van der Kraan</author>
<author>Suresh Manandhar</author>
<author>M Andrew Moshier</author>
</authors>
<title>Herbert Ruessink, and Craig Thiersch. Specification of Datatypes.</title>
<date>1993</date>
<booktitle>In Deliverable D.B of</booktitle>
<pages>61--061</pages>
<marker>[Erbach et al., 1993]</marker>
<rawString>Gregor Erbach, Mark van der Kraan, Suresh Manandhar, M. Andrew Moshier, Herbert Ruessink, and Craig Thiersch. Specification of Datatypes. In Deliverable D.B of LRE-61-061 &amp;quot;The Reusability of Grammatical Resources&amp;quot;. 1993.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M R Garey</author>
<author>D S Johnson</author>
</authors>
<title>Computers and Intractability : A Guide to the Theory of NP-Completeness. Freeman,</title>
<date>1979</date>
<location>San Francisco,</location>
<marker>[Garey and Johnson, 1979]</marker>
<rawString>M. R. Garey and D. S. Johnson. Computers and Intractability : A Guide to the Theory of NP-Completeness. Freeman, San Francisco, 1979.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Markus Hohfeld</author>
<author>Gert Smolka</author>
</authors>
<title>Definite relations over constraint languages.</title>
<date>1988</date>
<tech>LILOG Report 53, IBM Deutschland,</tech>
<location>Stuttgart, Germany,</location>
<marker>[Hohfeld and Smolka, 1988]</marker>
<rawString>Markus Hohfeld and Gert Smolka. Definite relations over constraint languages. LILOG Report 53, IBM Deutschland, Stuttgart, Germany, October 1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Hollunder</author>
<author>W Nutt</author>
</authors>
<title>Subsumption Algorithms for Concept Languages.</title>
<date>1990</date>
<booktitle>Artificial Intelligence (DFKI), Stuhlsatzenhausweg 3, 6600 Saarbriicken 11,</booktitle>
<tech>Research Report RR-90-04,</tech>
<institution>German Research Center for</institution>
<marker>[Hollunder and Nutt, 1990]</marker>
<rawString>B. Hollunder and W. Nutt. Subsumption Algorithms for Concept Languages. Research Report RR-90-04, German Research Center for Artificial Intelligence (DFKI), Stuhlsatzenhausweg 3, 6600 Saarbriicken 11, Germany, 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mask Johnson</author>
</authors>
<title>Features and Formulae.</title>
<date>1991</date>
<journal>Computational Linguistics,</journal>
<pages>17--2</pages>
<marker>[Johnson, 1991]</marker>
<rawString>Mask Johnson. Features and Formulae. Computational Linguistics, 17(2):131-151, June 1991.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ronald M Kaplan</author>
<author>Joan Bresnan</author>
</authors>
<title>Lexical-Functional Grammar: A formal system for grammatical representation.</title>
<date>1982</date>
<booktitle>The Mental Representation of Grammatical Relations,</booktitle>
<pages>173--281</pages>
<editor>In Joan Bresnan, editor,</editor>
<publisher>MIT Press,</publisher>
<location>Cambridge, Massachussets,</location>
<marker>[Kaplan and Bresnan, 1982]</marker>
<rawString>Ronald M. Kaplan and Joan Bresnan. Lexical-Functional Grammar: A formal system for grammatical representation. In Joan Bresnan, editor, The Mental Representation of Grammatical Relations, pages 173 — 281. MIT Press, Cambridge, Massachussets, 1982.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert Kasper</author>
<author>William Rounds</author>
</authors>
<title>A logical semantics for feature structures.</title>
<date>1986</date>
<booktitle>In 24th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>257--265</pages>
<institution>Columbia University,</institution>
<location>New York,</location>
<marker>[Kasper and Rounds, 1986]</marker>
<rawString>Robert Kasper and William Rounds. A logical semantics for feature structures. In 24th Annual Meeting of the Association for Computational Linguistics, Columbia University, New York, pages 257-265, 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Harry R Lewis</author>
</authors>
<title>Complexity Results for Classes of Quantificational Formulae.</title>
<date>1980</date>
<journal>Journal of Computer and System Sciences,</journal>
<pages>21--317</pages>
<marker>[Lewis, 1980]</marker>
<rawString>Harry R. Lewis. Complexity Results for Classes of Quantificational Formulae. Journal of Computer and System Sciences, 21:317-353, 1980.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Suresh Manandhar</author>
</authors>
<title>Relational Extensions to Feature Logic: Applications to Constraint Based Grammars.</title>
<date>1993</date>
<tech>PhD thesis,</tech>
<institution>Department of Artificial Intelligence, University of Edinburgh,</institution>
<marker>[Manandhar, 1993]</marker>
<rawString>Suresh Manandhar. Relational Extensions to Feature Logic: Applications to Constraint Based Grammars. PhD thesis, Department of Artificial Intelligence, University of Edinburgh, 1993.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bernhard Nebel</author>
<author>Gert Smolka</author>
</authors>
<title>Attributive description formalisms and the rest of the world.</title>
<date>1991</date>
<tech>Research Report RR-91-15,</tech>
<institution>German Research Center for Artificial Intelligence (DFKI),</institution>
<location>Saarbriicken, Germany,</location>
<marker>[Nebel and Smolka, 1991]</marker>
<rawString>Bernhard Nebel and Gert Smolka. Attributive description formalisms and the rest of the world. Research Report RR-91-15, German Research Center for Artificial Intelligence (DFKI), Saarbriicken, Germany, May 1991.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Carl J Pollard</author>
<author>M Drew Moshier</author>
</authors>
<title>Unifying partial descriptions of sets.</title>
<date>1990</date>
<booktitle>Information, Language and Cognition. University of British</booktitle>
<volume>1</volume>
<editor>In Philip P. Hanson, editor,</editor>
<publisher>Columbia Press,</publisher>
<location>Vancouver, Canada,</location>
<marker>[Pollard and Moshier, 1990]</marker>
<rawString>Carl J. Pollard and M. Drew Moshier. Unifying partial descriptions of sets. In Philip P. Hanson, editor, Information, Language and Cognition. University of British Columbia Press, Vancouver, Canada, 1990. Vancouver Studies in Cognitive Science, no. 1.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Carl Pollard</author>
<author>Ivan Andrew Sag</author>
</authors>
<title>Information-Based Syntax and Semantics: Volume 1 Fundamentals,</title>
<date>1987</date>
<booktitle>of Lecture Notes. Center for the Study of Language and Information,</booktitle>
<volume>13</volume>
<location>Stanford, CA,</location>
<marker>[Pollard and Sag, 1987]</marker>
<rawString>Carl Pollard and Ivan Andrew Sag. Information-Based Syntax and Semantics: Volume 1 Fundamentals, volume 13 of Lecture Notes. Center for the Study of Language and Information, Stanford, CA, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Carl Pollard</author>
<author>Ivan Andrew Sag</author>
</authors>
<title>Head-driven Phrase Structure Grammar: Volume 2.</title>
<date>1992</date>
<publisher>MIT Press,</publisher>
<marker>[Pollard and Sag, 1992]</marker>
<rawString>Carl Pollard and Ivan Andrew Sag. Head-driven Phrase Structure Grammar: Volume 2. MIT Press, 1992. Forthcoming.</rawString>
</citation>
<citation valid="true">
<authors>
<author>William C Rounds</author>
</authors>
<title>Set values for unification-based grammar formalisms and logic programming.</title>
<date>1988</date>
<tech>Technical report,</tech>
<institution>Center for</institution>
<location>Stanford, CA,</location>
<marker>[Rounds, 1988]</marker>
<rawString>William C. Rounds. Set values for unification-based grammar formalisms and logic programming. Technical report, Center for the Study of Language and Information, Stanford, CA, 1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Manfred Schmidt-Schaul3</author>
<author>Gert Smolka</author>
</authors>
<title>Attributive Concept Descriptions with Unions and Complements.</title>
<date>1991</date>
<journal>Artificial Intelligence,</journal>
<pages>48--1</pages>
<location>Scientific Center, IWBS, Stuttgart, Germary,</location>
<note>Also available as IWBS Report 68, IBM Germany,</note>
<marker>[Schmidt-Schau13 and Smolka, 1991]</marker>
<rawString>Manfred Schmidt-Schaul3 and Gert Smolka. Attributive Concept Descriptions with Unions and Complements. Artificial Intelligence, 48:1-26, 1991. Also available as IWBS Report 68, IBM Germany, Scientific Center, IWBS, Stuttgart, Germary, June 1989.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Manfred Schmidt-SchauB</author>
</authors>
<title>Subsumption in KL-ONE is undecidable.</title>
<date>1989</date>
<booktitle>In First International Conference on Principles of Knowledge Representation and Reasoning, KR&apos; 89,</booktitle>
<pages>421--431</pages>
<location>Toronto, Canada,</location>
<marker>[Schmidt-Schaul3, 1989]</marker>
<rawString>Manfred Schmidt-SchauB. Subsumption in KL-ONE is undecidable. In First International Conference on Principles of Knowledge Representation and Reasoning, KR&apos; 89, Toronto, Canada, pages 421-431, May 1989.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gert Smolka</author>
</authors>
<title>A feature logic with subsorts.</title>
<date>1991</date>
<booktitle>Unification in Grammar.</booktitle>
<editor>In Jürgen Wedekind and C. Rohrer (eds.), editors,</editor>
<publisher>MIT Press,</publisher>
<note>Also appeared as LILOG Report</note>
<marker>[Smolka, 1991]</marker>
<rawString>Gert Smolka. A feature logic with subsorts. In Jürgen Wedekind and C. Rohrer (eds.), editors, Unification in Grammar. MIT Press, 1991. Also appeared as LILOG Report no. 33, IWBS, IBM Deutschland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gert Smolka</author>
</authors>
<title>Feature constraint logics for unification grammars.</title>
<date>1992</date>
<journal>Journal of Logic Programming,</journal>
<pages>12--51</pages>
<marker>[Smolka, 1992]</marker>
<rawString>Gert Smolka. Feature constraint logics for unification grammars. Journal of Logic Programming, 12:51-87, 1992.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K von Luck</author>
<author>B Nebel</author>
<author>C Peltason</author>
<author>A Schmiedel</author>
</authors>
<title>The Anatomy of the BACK System.</title>
<date>1987</date>
<tech>KIT Report 41,</tech>
<institution>Department of Computer Science, Technische Universitat Berlin,</institution>
<location>Berlin, Germany,</location>
<marker>[von Luck et al., 1987]</marker>
<rawString>K. von Luck, B. Nebel, C. Peltason, and A. Schmiedel. The Anatomy of the BACK System. KIT Report 41, Department of Computer Science, Technische Universitat Berlin, Berlin, Germany, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Remi Zajac</author>
</authors>
<title>Inheritance and ConstraintBased Grammar Formalisms.</title>
<date>1992</date>
<journal>Computational Linguistics,</journal>
<pages>18--2</pages>
<marker>[Zajac, 1992]</marker>
<rawString>Remi Zajac. Inheritance and ConstraintBased Grammar Formalisms. Computational Linguistics, 18(2):159-182, 1992.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>