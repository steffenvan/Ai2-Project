<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000002">
<title confidence="0.9965815">
Decidability and Undecidability
in stand-alone Feature Logics
</title>
<author confidence="0.999255">
Patrick Blackburn
</author>
<affiliation confidence="0.999857">
Department of Philosophy, University of Utrecht
</affiliation>
<address confidence="0.766306">
Heidelberglaan 8, 3584 CS Utrecht, The Netherlands
</address>
<email confidence="0.753938">
Email: patrickaphil.ruu.n1
</email>
<author confidence="0.989712">
Edith Spaan
</author>
<affiliation confidence="0.806913">
Department of Computer Science, SUNY at Buffalo
226 Bell Hall, Buffalo, NY 14260, United States of America
</affiliation>
<email confidence="0.760761">
Email: spaan©cs.buffalo.EDU
</email>
<sectionHeader confidence="0.983571" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999959933333333">
This paper investigates the complexity of
the satisfiability problem for feature logics
strong enough to code entire grammars un-
aided. We show that feature logics capable
of both enforcing re-entrancy and stating
linguistic generalisations will have undecid-
able satisfiability problems even when most
Boolean expressivity has been discarded.
We exhibit a decidable fragment, but the
restrictions imposed to ensure decidability
render it unfit for stand-alone use. The im-
port of these results is discussed, and we
conclude that there is a need for feature log-
ics that are less homogeneous in their treat-
ment of linguistic structure.
</bodyText>
<sectionHeader confidence="0.999133" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999717259259259">
This paper investigates decidability and undecidabil-
ity in stand-alone feature logics, that is, feature logics
strong enough to express entire grammars without
the assistance of a phrase-structure backbone. Our
results are predominately negative and seem appli-
cable to most existing stand-alone formalisms. We
strengthen a result of [Blackburn and Spaan 1991,
1992] to show that the ability to express re-entrancy
and the ability to express generalisations about fea-
ture structures interact in ways that lead to unde-
cidability even if most Boolean expressivity has been
dropped from the logic. Even our positive results
have a negative flavour. We exhibit a decidable frag-
ment, but the restrictions imposed to attain decid-
ability render it incapable of encoding interesting
grammars unaided.
But what is the import of such results? This is
the question we turn to in the last section of the
paper. Basically, we regard such results as a sign
that existing feature logics treat linguistic structure
too homogeneously. What is needed are feature log-
ics which are more sensitive to the fine structure of
linguistic theorising.
The paper is relatively self contained, nonetheless
the reader may find it helpful to have [Kasper and
Rounds 1986, 1990] and [Blackburn and Spaan 1991,
1992] to hand.
</bodyText>
<sectionHeader confidence="0.988203" genericHeader="introduction">
2 Preliminaries
</sectionHeader>
<bodyText confidence="0.999961315789474">
Feature logics are abstractions from the unifica-
tion based formalisms of computational linguistics.
Originally feature logics embodied just one compo-
nent of unification based formalisms. Early unifica-
tion formalisms such as GPSG [Gazdar et al. 1985]
and LFG [Kaplan and Bresnan 1982] have impor-
tant phrase structure components in addition to their
feature passing mechanisms, and the study of feature
logic was originally intended to throw light only on
the latter. These early unification formalisms are
thus highly heterogeneous: they are architectures
with roots in both formal language theory and logic.
In recent years this picture has changed. For ex-
ample, in HPSG [Pollard and Sag 1987] the feature
machinery has largely displaced the phrase struc-
ture component. Indeed in HPSG the residue of the
phrase structure component is coded up as part of
the feature system. Logic has swallowed formal lan-
guage theory, and in effect the entire HPSG formal-
</bodyText>
<page confidence="0.996171">
30
</page>
<bodyText confidence="0.999903431818182">
ism is a powerful feature logic, a stand-alone formal-
ism, capable of encoding complex grammars without
the help of any other component.&apos;
In this paper we are going to investigate the com-
putational complexity of the satisfiability problem
for such stand-alone feature logics. This is an impor-
tant problem to investigate. Natural language gram-
mars are expressed as logical theories in stand-alone
formalisms, and sentences are represented as wffs.
This means that the problem of deciding whether or
not a sentence is grammatical reduces to the problem
of building a model of the sentence&apos;s logical represen-
tation that conforms to all the constraints imposed
by the logical encoding of the grammar. In short,
the complexity of the satisfiability problem is essen-
tially the worst case complexity of the recognition
problem for grammars expressed in the stand-alone
formalism.
We will tackle this issue by investigating the com-
plexity of the satisfiability problem for one partic-
ular stand-alone formalism, namely LKR*. This is
the language of Kasper Rounds logic augmented with
the strict implication operator. LKRu possesses two
of the most fundamental properties of stand-alone
formalisms: the ability to express re-entrancy, and
the ability to express generalisations about feature
structures. It is important to note that LKR* is
actually a fairly minimal language with these prop-
erties; many feature logics can express a lot more
besides (for example, set values), thus the negative
results for LKR* we present are rather strong: they
extend straightforwardly to richer formalisms.
So let&apos;s begin by defining LKR. By a signature
(G, S) is meant a pair of non-empty sets and 5, the
set of arc labels and the set of sorts respectively. Syn-
tactically, the language LKR (of signature (C&apos;S))
contains the following items: an S indexed collec-
tion of propositional symbols (or sort symbols); all
the standard Boolean operators;3 an indexed col-
lection of distinct unary modalities (that is, features);
a binary modality and two special symbols 0 and
We use r.:1 to make path equations: given any non-
empty sequences A and B consisting of only unary
modalities and 0, then A B is a path equation.
</bodyText>
<footnote confidence="0.8977245">
1See [Johnson 1992] for further discussion of the distinction
between stand-alone formalisms and formalisms with a phrase
structure backbone.
2That is, we have the symbols True (constant true), False
</footnote>
<bodyText confidence="0.849113551724138">
(constant false), (negation), V (disjunction), A (conjunc-
tion), (material implication) and (material equivalence).
For the purposes of the present paper it is sensible to assume
that all these operators are primitives, as in general we will be
working with various subsets of the full language and it would
be tedious to have to pay attention to trivial issues involving
the interdefinability of the Boolean operators in these weaker
fragments.
Intuitively A B says that making the sequence of
feature transitions encoded by A leads to the same
node as making the transition sequence coded by B.
The symbol 0 is a name for the null transition. The
strict implication operator will enable us to ex-
press generalisations about feature structures.
We make the wffs of LKR** as follows. First, all
propositional symbols, all path equations and True
and False are wffs. Second, if 0 and 1/) are wffs then
so are all Boolean combinations of 0 and &apos;0, so is
MO (for all / E .C) and so is 0 =0. Third, noth-
ing else is a wff. If a wff of 1..KR does not contain
any occurrences of then we say it is an LKR wff.
Apart from trivial notational changes, the negation
free fragment of LKR is the language defined and
studied by Kasper and Rounds.3 That is, the LKR
wffs are essentially a way of writing the familiar At-
tribute Value Matrices (AVMs) in linear format. For
example, the following LKR wff:
(NumBER)p/ura/ A (CASE)(nom V gen V acc)
is essentially the following AVM:
</bodyText>
<equation confidence="0.4129575">
[ NUMBER plural
CASE nom or gen or acc
</equation>
<bodyText confidence="0.957835304347826">
To interpret LKR* we use feature structures M
of signature (C, S). A feature structure is a triple
(W, {R/}/ez, V), where W is a non-empty set (the
set of nodes); each R1 is a binary relation on W
that is also a partial function; and V (the valua-
tion) is a function which assigns each propositional
symbol pESa subset of W. Note that as we have
defined them features structures are merely multi-
modal Kripke models,4 and we often refer to feature
structures as models in what follows.
Now for the satisfaction definition. As the sym-
bol 0 is to act as a name for the null transition, in
what follows we shall assume without loss of gener-
ality that 0 fl C, and we will denote the identity re-
lation on any set of nodes W by Ro. This convention
somewhat simplifies the statement of the satisfaction
3Cornputer scientists may have met LKR in another guise.
The language of Kasper Rounds logic is a fragment of (de-
terministic) Propositional Dynamic Logic (PDL) with inter-
section (see [Harel 1984]). An LKR path equation A .c.1 B is
written as (A cl B) True in PDL with intersection.
4 For further discussion of the modal perspective on feature
logic, see [Blackburn and Spaan 1991, 1992].
</bodyText>
<page confidence="0.99196">
31
</page>
<equation confidence="0.960657545454545">
definition:
M = pa[w] if w E V(pa)
M (4) • • (1k) if 3w1(wRi, RI„
(11) • • • (1)[w] &amp; mite, . . .
M = .-Kk[w] if M
M 0V5[w] if M Or
M
M = (1)44w] if atui(wRiw&apos; and
M 0[wl)
M O[wl if Vw&apos;(M 0[14
implies M 1=tk[to&apos;])
</equation>
<bodyText confidence="0.97168078">
The satisfaction clauses for True, False, A, and
have been omitted; these symbols receive their
standard Boolean interpretations. If M = o[tv] then
we say that M satisfies at w, or 4) is true in M at
w (where w E W).
The key things to note about this language is that
it has both the ability to express re-entrancy (the
Kasper Rounds path equality achieves this) and
the ability to express generalisations about feature
structures (note that 0 0 means that at every
node where 0 is true, 0 must also be true). Thus
LKR can certainly express many of the conditions
we might want to impose on feature structures. For
instance, we might want to impose a sort hierarchy.
As a simple example, given sorts list and nelist (non-
empty list) we might wish to insist that every node
of sort nelist is also of sort list. The wff
nelist list
forces this. As a second example, we might want
to insist that any node from which it is possible to
make a CONSTITUENT-STRUCTURE transition must
be of sort phrasal. That is, if a node has constituent
structure, it is a phrasal node. The wff
(CONSTITUENT-STRUCTURE) True = phrasal
forces this. Indeed quite complex demands can be
imposed using LKR. For example the following wff
embodies the essence of the constraint known as the
head feature convention in HPSG:
phrasal (HEAD) (HEAD-DTR) (HEAD).
This wff says that at any node of sort phrasal in
a feature structure, it is possible to make a HEAD
transition and it is also possible to make a HEAD-
DTR transition followed by a HEAD transition, and
furthermore both transition sequences lead to the
same node. In view of such examples it doesn&apos;t seem
wholly unrealistic to claim that LKR has the kind of
expressive power a stand-alone feature logic needs.
However LKR* has crossed a significant com-
plexity boundary: it has an undecidable satisfiabil-
ity problem. This was proved in [Blackburn and
Spaan 1991, 1992] using a tiling argument.5 Now,
the result for the full LKR language is not partic-
ularly surprising (undecidability results for related
feature logics, can be found in the literature; see
[Carpenter 1992] for discussion) but it does lead to
an important question: what can be salvaged? To
put it another way, are there decidable fragments of
LKR that are capable of functioning as stand-alone
feature logics? The pages that follow explore this
question and yield a largely negative response.
</bodyText>
<sectionHeader confidence="0.997" genericHeader="method">
3 Decidability
</sectionHeader>
<bodyText confidence="0.973922583333333">
To begin our search for decidable fragments we will
take our cue from Kasper and Rounds&apos; original work.
Kasper and Rounds&apos; system was negation free, so the
first question to ask is: what happens if we simply
remove negation from LKR? Of course, if this is
all we do we trivialise the satisfiability problem: it is
immediate by induction on the structure of negation
free wffs 0, that every negation free LKR* wff is sat-
isfied in the following model: M = ({w}, {Ri}tEr, , V)
where R1 ={(ww)} for all / EL, and V (p) = {w}
for all propositional variables p. So we have regained
decidability, but in a very uninteresting way.
Now, what made the results of Kasper and Rounds
interesting was that not only did they consider the
negation free fragment (of LKR), they also imposed
certain semantic restrictions. Only extensional mod-
els without constant-constant or constant-compound
clashes were considered.6 Will imposing any (or all)
of these restrictions make it easier to find decidable
fragments of LKR? In fact demanding extensional-
ity (that is, working only with models in which each
atomic symbol is true at at most one node), does
make it easy to find a decidable fragment.
The fragment is the following. We consider wffs of
the following form:
A (cti KO A • • A (an Kn)•
Here 0 is a metavariable over LKR wffs (that is, 0
contains no occurrences of the ai (1 &lt; i &lt; n)
sThese papers take the universal modality 0 as primitive
rather that as it is somewhat easier to work with unary
modalities. In the presence of full Boolean expressivity 0 and
are interdefmable: 04) is True =I 4), and is 0(40
However in what follows we will work with fragments without
enough Boolean expressivity to interdefine these operators. As
is the operator we are really interested in we have chosen
it as our primitive here.
</bodyText>
<footnote confidence="0.762168333333333">
6As Kasper and Rounds showed, introducing this limited
form of negation failure results in an NP complete satisfiability
problem.
</footnote>
<page confidence="0.997783">
32
</page>
<bodyText confidence="0.966853134615385">
are metavariables over combinations of sort symbols
containing only V and A as logical operators; and the
Ki (1 &lt;i &lt; n) are metavariable over LKR wffs.
Note the general form of the wffs of this fragment.
We have an LKR wff 0 conjoined with n general con-
straints a; Ki.I The 0 can be thought of as the
AVM associated with some particular natural lan-
guage sentence, while the wffs of the form a; Ki
can be thought of as encoding the generalisations
embodied in our grammatical theory. Looking for a
satisfying model for a wff from this fragment is thus
like asking whether the analysis of some particular
string of symbols is compatible with a grammar.
The proof that this fragment has a decidable sat-
isfiability problem is straightforward. We&apos;re going to
show that given any wff (I) belonging to this fragment,
there is an upper bound on the size of the models that
need to be inspected to determine whether or not 4)
is satisfiable. The fact that such an upper bound
exists is a direct consequence of three lemmas which
we will now prove.
The first lemma we need is extremely obvious, but
will play a vital role.
Lemma 3.1 Let a be any wff containing no logical
connectives apart from V and A. Then in any ex-
tensional model, a is satisfied at at most m nodes,
where m is the number of distinct sort symbols in a.
Proof: By induction on the construction of a. 0
The importance of this lemma is that it gives us
an upper bound on the number of nodes at which
the antecedents a; of the constraints permitted in
our fragment can be satisfied.
Next we need a similar result for the LKR wffs of
the fragment; that is, for the 0 and the consequents
K; of the constraints. As the next two lemmas es-
tablish, given any LKR wff 0 which is satisfiable at
a node w in some model M, we can always manu-
facture a very small model Minodes(0, w) which also
satisfies tk . How we go about defining MI nodes(0 , w)
is suggested by the following observation: when eval-
uating a formula in some model, only certain of the
model&apos;s nodes are relevant to the truth or falsity of
the wff; all the irrelevant nodes can be thrown away.
What the following two lemmas essentially tell us is
that we can manufacture the small models we need
by discarding nodes.
The nodes that are relevant when evaluating an
pcn wff 0 at a node w in a model M are the nodes
selected by the function nodes . WFF x W
Pow(W) that satisfies the following conditions:
71n what follows we refer to the a, as the antecedents of
the constraints, and the is, as the consequents.
</bodyText>
<equation confidence="0.965729">
nodes(p, w) = {w}
nodes(—np,w) nodese ,
nodes(tk V 0,w) nodes(0, w) U nodes(0 , w)
nodes((l)0 , w) {w} U Uw,,tuRit„, nodes(0, w&apos;)
</equation>
<bodyText confidence="0.991336">
One aspect of the definition of nodes may be both-
ering the reader: there is no clause for the path equa-
tions. In fact to give such a clause is rather messy,
and it seems better to proceed as follows. Given a wff
0 of LKR we define 0* to be the result of replacing
every subformula of the form
</bodyText>
<equation confidence="0.9143002">
(i i)•• •• (ik) • • (em)
in 0 by
(4) • (4) P.&apos;, (ID • • • (lim)
A (11) • • • (ik)True
A (11) • • • (11m) True.
</equation>
<bodyText confidence="0.992093">
Clearly .1,/, is satisfiable at any node in any model if
0* is (all we&apos;ve done is make the node existence de-
mands encoded in the path equalities explicit). The
usefulness of this transformation is simply that the
two new conjuncts make available to the simple ver-
sion of nodes defined above all the information hid-
den in the path equations. From now on we&apos;ll assume
that all the LKR wffs we work with have been trans-
formed in this fashion.
With these preliminaries out of the way we are
ready to proceed. Given a model M, an LKR wff
and a node w we form MI nodes(1,b, w) in the obvious
way: the nodes of the model are nodes(0, w), and the
relations and valuation are the restriction of those of
M to this subset. As the following simple lemma
shows, nodes indeed picks out the correct nodes:
</bodyText>
<equation confidence="0.81787575">
Lemma 3.2 (Selection Lemma) For all models
M, all nodes w of M and all LKR wffs
M tk[tvj iff Minodes(0,w)
Proof: By induction on the structure of (Note
</equation>
<bodyText confidence="0.997937615384615">
that it follows from the definition of nodes that w E
nodes(0 , w). Once this is observed the induction is
straightforward.) 0
The selection lemma is a completely general fact
about modal languages. It doesn&apos;t depend on any
special assumptions made in this paper, and in par-
ticular it doesn&apos;t make any use of the fact that we are
only working with models in which each of the RI is
a partial function. Once this additional fact is taken
into account, however, we see that MI nodes(0, w) is
pleasingly small: there can only be one more node in
Mn odes(&apos;, w) than there are occurrences of modal-
ities in 0. That is, we have:
</bodyText>
<page confidence="0.998154">
33
</page>
<bodyText confidence="0.989063662337663">
Lemma 3.3 (Size Lemma) Let tb be an LK R toff,
and let mod(tb) be the number of occurrences of
modalities in tb. Then for all models M and all nodes
w in M we have that &apos;nodes( b, w)\{w}I &lt; mod(0).
Proof: By induction on the structure of tk. 0
We now have all the pieces we need to establish the
decidability result. Using these lemmas we can show
that given any wff 4) of our fragment it is possible
to place an upper bound on the size of models that
need to be checked to determine whether or not 4) is
satisfiable. So, suppose 4) is a wff of the form
(I) A (ai KO A • • • A (cvn
that is satisfiable. That is, there is a model M and
a node w in M such that M = 4)[w]. Now, simply
forming Mjnodes(0,w) is not a process guaranteed
to make a smaller model satisfying 4). The problem
is that while this model certainly satisfies 0, in the
course of selecting all the needed nodes we may be
forced to select a node that verifies an antecedent
ai of one of the general constraints, but we have no
guarantee that we have selected all the nodes needed
to make the matching consequent rci true.
But this is easy to fix. We must not only form
MI nodes(4), w), but in addition, for all i (1&lt; i &lt; n)
we must form Minodes(cri A Ki , s), where s ranges
over all the nodes in M that satisfy ai. More pre-
cisely, we define a new model M&apos; by taking as nodes
all the nodes in all these models (that is, we take the
union of all the nodes in all these models) and we
define the M&apos; relations and valuation to be the re-
striction of the relations and valuation in M to this
subset.
The new model M&apos; has two nice properties.
Firstly, it is clear that it makes 4 true at w and more-
over, whenever it makes one of the ai true it makes
the corresponding Ki true also. (This follows because
of our choice of the nodes of M&apos;; essentially we&apos;re
making multiple use of the selection lemma here.)
Secondly, it is clear that M&apos; is finite, for its nodes
were obtained as a finite union of finite sets. Indeed
by making use of lemma 3.1 and the size lemma we
can give an upper bound on the size of M&apos; in terms
of the number of symbols in 4). (This is just a mat-
ter of counting the number of general constraints in
4,, the number of distinct propositional variables in
the ai, and the number of modal operators in the
and rci; we leave the details to the reader.) Thus the
decidability result follows: given a wff 4, of our frag-
ment, bounded search through finite models suffices
to determine whether or not 4) is satisfiable.
Alas, this is not a very powerful result. The frag-
ment simply is not expressive enough to function as
a stand-alone formalism. Its Achilles heel lies in the
strong condition imposed on the ai. There are two
problems. First, because the ai cannot contain oc-
currences of features or path equations, many impor-
tant constraints that stand-alone feature might have
to impose cannot be expressed. Second, it is far from
clear that the restriction to extensional models is re-
alistic for stand alone formalisms. Certainly if we
were trying to capture the leading ideas of HPSG it
would not be; the freedom to decorate different nodes
with the same sortal information plays an important
role in HPSG.
Can some of the restrictions on the ai be dropped?
As the proof of the result shows, there is no obvious
way to achieve this: as soon as we allow features
or path equations in the ai, the assumption of ex-
tensionality no longer helps us find an upper bound
on the number of satisfying nodes, and the proof no
longer goes through. Essentially what is needed is
a way of strengthening lemma 3.1, but it is hard to
find a useful way of doing this. Even imposing an
acyclicity assumption on our models doesn&apos;t seem to
help. As the results of the next section show, this is
no accident. The combination of and is intrin-
sically dangerous.
</bodyText>
<sectionHeader confidence="0.991242" genericHeader="method">
4 Undecidability
</sectionHeader>
<bodyText confidence="0.999970555555556">
The starting point for this section is the undecidabil-
ity result for the full LKR language (see [Blackburn
and Spaan 1991, 1992]) which was proved using re-
duction from a certain undecidable tiling problem.
We&apos;re going to strengthen this undecidability result,
and we&apos;re going to do so by using further tiling ar-
guments. As the use of tiling arguments seem to be
something of a novelty in the computational linguis-
tics literature, we include a little background discus-
sion of the method.
Tiling arguments are a well known proof tech-
nique in computer science for establishing com-
putability and complexity results. (In fact, tiling
arguments are used to introduce the basic concepts
of complexity, decidability and undecidability in
[Lewis and Papadimitriou 1981], one of the standard
introductions to theoretical computer science.) They
are also a popular method for analysing the complex-
ity of logics; both [Harel 1983] and [Harel 1986] are
excellent guides to the versatility of the method for
this application.
One of the most attractive aspects of tiling prob-
lems is that they are extremely simple to visualise.
A tile T is just a 1 x 1 square, fixed in orientation,
that has coloured edges right(T), left(T), up(T), and
down(T) taken from some denumerable set. A tiling
problem takes the following form: given a finite set T
</bodyText>
<page confidence="0.99763">
34
</page>
<bodyText confidence="0.989300673469388">
of tile types, can we cover a certain part of Z x Z (Z
denotes the integers) using only tiles of this type, in
such a way that adjacent tiles have the same colour
on the common edge, and such that the tiling obeys
certain constraints? For example, consider the fol-
lowing problem. Suppose T consists of the following
four types of tile:
Can an 8 by 4 rectangle be tiled with the fourth
type of tile placed in the left hand corner? The an-
swer is &apos;yes&apos; — but we&apos;ll leave it to the reader to work
out how to do it.
There exist complete tiling problems for many
complexity classes. In the proof that follows we make
use of a certain 11? complete tiling problem, namely
the problem of tiling the entire positive quadrant of
the plane, that is, the problem of tiling N x N where
N is the set of natural numbers.
We begin with the following remark: by inspection
of the undecidability proof for LKR* in [Blackburn
and Spaan 1991, 1992], it is immediate that we still
have undecidability if we restrict the language to for-
mulas that consist of a conjunction of formulas of the
form 4)1 where 01 and 02 are LKR formulas
with negations applied to atoms only, and 02 is sat-
isfiable. (The stipulation that 02 must be satisfiable
prevents it from playing the role of False and thus
smuggling in illicit negations.) Call this language
L. . Let&apos;s see if we can strengthen this result fur-
ther.
So, suppose we look at L- formulas with V as the
only binary boolean connective in 01 and 02 . In this
case, we show that the corresponding satisfiability
problem is still undecidable by constructing another
reduction from N x N tiling.
Let T = ..., TO be a set of tiles. We con-
struct a formula 0 such that:
T tiles N x N if 0 is satisfiable.
First of all we will ensure that, if 0 is satisfiable
in a model M, then M contains a gridlike structure.
The nodes of M (henceforth W), play the role of
points in a grid, R,. is the right successor relation,
and /?.. is the upward successor relation. Define:
Ogrid = (True (r)(u) (u)(r))•
Clearly Ogrid forces gridlike models.
Next we must tile the model. To do this we use
propositional variables 11, , tk, such that ti is true
at some node w, if tile Ti is placed at w. To force a
proper tiling, we need to satisfy the following three
requirements:
</bodyText>
<figure confidence="0.422361363636364">
1. There is exactly one tile placed at each node.
01 = (True V Li) A A oi
i=1 1&lt;i&lt;j&lt;k
2. If Ti is the tile at w, and Ti is a tile such that
righl(Ti) left(73), then ti should not be true
at any R,. successor of w:
o2= A (ti (r)--43)
rigida,* lefta,)
3. Similarly for up successors:
= A (ii (u)-,t;)
down(Ti)
</figure>
<bodyText confidence="0.996687777777778">
Let 0 be ed
grid A 01 A 02 A Os. It is not too difficult to
prove that 0 is satisfiable if T tiles N x N, which im-
plies that the satisfiability problem for our fragment
of L- is undecidable.
Are there weaker undecidable fragments? Yes: we
can remove True from 0. We do this by using a
new propositional variable PT which plays the role of
True. Insisting that
</bodyText>
<sectionHeader confidence="0.281103" genericHeader="method">
PT A (PT [r]PT) A (PT [u]PT)
</sectionHeader>
<bodyText confidence="0.9849785">
ensures that PT behaves like True.
Are even weaker fragments undecidable? Yes: we
can ensure that V occurs at most once in each clause.
In fact we only have to rewrite part of 01 (namely,
True V12), for this is the only place in 0 where
V occurs. We use new variables b2, , bk_i for this
purpose and we ensure that bi is true if ti is true for
some j &lt; i. We do this as follows:
</bodyText>
<equation confidence="0.997851666666667">
(b2 V i2) A
(b3 b2 V ta) A
(14-1 bk-aV 4-2) A
</equation>
<bodyText confidence="0.8885395">
(True bk-i V tk )
Clearly this has the desired effect.
</bodyText>
<sectionHeader confidence="0.999086" genericHeader="conclusions">
5 Discussion
</sectionHeader>
<bodyText confidence="0.9949005">
The results of this investigation are easy to sum-
marise: the ability to express both re-entrancy and
</bodyText>
<page confidence="0.997462">
35
</page>
<bodyText confidence="0.999945409090909">
generalisations about feature structures lead to algo-
rithmically unsolvable satisfiability problems even if
most Boolean expressivity is dropped. What are the
implications of these results&apos;?
Stand-alone feature formalisms offer (elegant) ex-
pressive power in a way that is compatible with
the lexically driven nature of much current linguis-
tic theorising. One of their disadvantages (at least
in their current incarnations) is that they tend to
hide computationally useful information. For exam-
ple, as [Johnson 1992] points out, it is difficult even
to formulate such demands as offline parsability for
existing stand-alone formalisms; the configurational
information required is difficult to isolate. The prob-
lem is that stand-alone formalisms tend to be too
homogeneous. It is certainly elegant to treat infor-
mation concerning complex categories and configu-
rational information simply as &apos;features&apos;; but unless
this is done sensitively it runs the risk of &apos;reducing&apos;
a computationally easy problem to an uncomputable
one.
Now, much current work on feature logic can be
seen as attempts to overcome the computational
bluntness of stand-alone formalisms by making vis-
ible computationally useful structure. For exam-
ple, recent work on typed feature structures (see
[Carpenter 1992]) explicitly introduces the type in-
heritance structure into the semantics; whereas in
[Blackburn et a/. 1993] composite entities consisting
of trees fibered across feature structures are con-
strained using two distinct &apos;layers&apos; of modal lan-
guage. What is common to both these examples is
the recognition that linguistic theories typically have
subtle internal architectures. Only when feature log-
ics become far more sensitive to the fine grain of lin-
guistic architectures will it become realistic to hope
for general decidability results.
Acknowledgements We would like to thank the
anonymous referees for their comments on the ab-
stract. Patrick Blackburn would like to acknowl-
edge the financial support of the Netherlands Or-
ganization for the Advancement of Research (project
NF 102/62-356 &apos;Structural and Semantic Parallels in
Natural Languages and Programming Languages&apos;).
</bodyText>
<sectionHeader confidence="0.999462" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.995748534482759">
[Blackburn and Spaan 1991] Blackburn, P. and
Spaan, E.: 1991, On the Complexity of At-
tribute Value Logics. Proceedings of the Eighth
Amsterdam Colloquium, edited by P. Dekker
and M. Stokhof, Philosophy Department, Ams-
terdam University, The Netherlands.
[Blackburn and Spaan 1992] Blackburn, P. and
Spaan, E.: 1992, A Modal Perspective on the
Computational Complexity of Attribute Value
Grammar. To appear in Journal of Logic, Lan-
guage and Information.
[Blackburn et al. 1993] Blackburn, P., Gardent, C.,
and Meyer-Viol, W.: 1993, Talking about Trees.
This volume.
[Carpenter 1992] Carpenter, B.: 1992, The Logic of
Typed Feature Structures, Cambridge University
Press.
[Gazdar et al. 1985] Gazdar, G.: Klein, E., Pullum,
G., and Sag, S.: 1985, Generalised Phrase Struc-
ture Grammar. Basil Blackwell.
[Harel 1983] Harel, D.: 1983, Recurring dominoes:
making the highly undecidable highly under-
standable, in Proc. of the Conference on Foun-
dations of Computing Theory, Springer Lecture
Notes in Computer Science 158, 177-194.
[Hare! 1984] Harel, D.: 1984, Propositional Dy-
namic Logic, in Handbook of Philosophical
Logic, 2, edited by D. Gabbay and F. Guen-
thner, Reidel.
[Harel 1986] Harel, D.: 1986, Effective transforma-
tions on infinite trees, with applications to high
undecidability, dominoes, and fairness, Journal
of the ACM, 33(1), 224-248.
[Johnson 1992] Johnson, M.: 1992, Computing with
features as formulas, manuscript, Cognitive and
Linguistic Sciences Department, Brown Univer-
sity.
[Kasper and Rounds 1986] Kasper, R. and Rounds,
W.: 1986, A logical semantics for feature struc-
tures, in Proceedings of the 24th Annual Meeting
of the Association for Computational Linguis-
tics, Columbia University, New York, 257-266.
[Kasper and Rounds 1990] Kasper, R. and Rounds,
W.: 1990, The Logic of Unification in Grammar,
Linguistics and Philosophy 13, 33-58.
[Kaplan and Bresnan 1982] Kaplan, K. and Bres-
nan, J.: 1982, Lexical functional grammar: A
formal system for grammatical representation,
in The Mental Representation of Grammatical
Relations, edited by Joan Bresnan, MIT Press,
173-281.
[Lewis and Papadimitriou 1981] Lewis, H. and Pa-
padimitriou, C.: 1981, Elements of the Theory
of Computation, Prentice-Hall.
[Pollard and Sag 1987] Pollard, C. and Sag, I.:
Information-Based Syntax and Semantics: Vol-
ume 1 - Fundamentals. CSLI Lecture Notes, 13,
Stanford.
</reference>
<page confidence="0.998924">
36
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.798858">
<title confidence="0.9990595">Decidability and Undecidability in stand-alone Feature Logics</title>
<author confidence="0.999893">Patrick Blackburn</author>
<affiliation confidence="0.999941">Department of Philosophy, University of Utrecht</affiliation>
<address confidence="0.998866">Heidelberglaan 8, 3584 CS Utrecht, The Netherlands</address>
<email confidence="0.814161">patrickaphil.ruu.n1</email>
<author confidence="0.998915">Edith Spaan</author>
<affiliation confidence="0.999957">Department of Computer Science, SUNY at Buffalo</affiliation>
<address confidence="0.999668">226 Bell Hall, Buffalo, NY 14260, United States of America</address>
<email confidence="0.999381">spaan©cs.buffalo.EDU</email>
<abstract confidence="0.999141125">This paper investigates the complexity of the satisfiability problem for feature logics strong enough to code entire grammars unaided. We show that feature logics capable of both enforcing re-entrancy and stating linguistic generalisations will have undecidable satisfiability problems even when most Boolean expressivity has been discarded. We exhibit a decidable fragment, but the restrictions imposed to ensure decidability render it unfit for stand-alone use. The import of these results is discussed, and we conclude that there is a need for feature logics that are less homogeneous in their treatment of linguistic structure.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>P Blackburn</author>
<author>E Spaan</author>
</authors>
<title>On the Complexity of Attribute Value Logics.</title>
<date>1991</date>
<booktitle>Proceedings of the Eighth Amsterdam Colloquium, edited</booktitle>
<institution>Philosophy Department, Amsterdam University, The Netherlands.</institution>
<marker>[Blackburn and Spaan 1991]</marker>
<rawString>Blackburn, P. and Spaan, E.: 1991, On the Complexity of Attribute Value Logics. Proceedings of the Eighth Amsterdam Colloquium, edited by P. Dekker and M. Stokhof, Philosophy Department, Amsterdam University, The Netherlands.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Blackburn</author>
<author>E Spaan</author>
</authors>
<title>A Modal Perspective on the Computational Complexity of Attribute Value Grammar.</title>
<date>1992</date>
<journal>Journal of Logic, Language and Information.</journal>
<note>To appear in</note>
<marker>[Blackburn and Spaan 1992]</marker>
<rawString>Blackburn, P. and Spaan, E.: 1992, A Modal Perspective on the Computational Complexity of Attribute Value Grammar. To appear in Journal of Logic, Language and Information.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Blackburn</author>
<author>C Gardent</author>
<author>W Meyer-Viol</author>
</authors>
<title>Talking about Trees. This volume.</title>
<date>1993</date>
<marker>[Blackburn et al. 1993]</marker>
<rawString>Blackburn, P., Gardent, C., and Meyer-Viol, W.: 1993, Talking about Trees. This volume.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Carpenter</author>
</authors>
<title>The Logic of Typed Feature Structures,</title>
<date>1992</date>
<publisher>Cambridge University Press.</publisher>
<marker>[Carpenter 1992]</marker>
<rawString>Carpenter, B.: 1992, The Logic of Typed Feature Structures, Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Klein Gazdar</author>
<author>E Pullum</author>
<author>G</author>
<author>S Sag</author>
</authors>
<title>Generalised Phrase Structure Grammar.</title>
<date>1985</date>
<publisher>Basil Blackwell.</publisher>
<marker>[Gazdar et al. 1985]</marker>
<rawString>Gazdar, G.: Klein, E., Pullum, G., and Sag, S.: 1985, Generalised Phrase Structure Grammar. Basil Blackwell.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Harel</author>
</authors>
<title>Recurring dominoes: making the highly undecidable highly understandable,</title>
<date>1983</date>
<booktitle>in Proc. of the Conference on Foundations of Computing Theory, Springer Lecture Notes in Computer Science 158,</booktitle>
<pages>177--194</pages>
<marker>[Harel 1983]</marker>
<rawString>Harel, D.: 1983, Recurring dominoes: making the highly undecidable highly understandable, in Proc. of the Conference on Foundations of Computing Theory, Springer Lecture Notes in Computer Science 158, 177-194.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Harel</author>
</authors>
<title>Propositional Dynamic Logic,</title>
<date>1984</date>
<booktitle>in Handbook of Philosophical Logic,</booktitle>
<volume>2</volume>
<location>Reidel.</location>
<marker>[Hare! 1984]</marker>
<rawString>Harel, D.: 1984, Propositional Dynamic Logic, in Handbook of Philosophical Logic, 2, edited by D. Gabbay and F. Guenthner, Reidel.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Harel</author>
</authors>
<title>Effective transformations on infinite trees, with applications to high undecidability, dominoes, and fairness,</title>
<date>1986</date>
<journal>Journal of the ACM,</journal>
<volume>33</volume>
<issue>1</issue>
<pages>224--248</pages>
<marker>[Harel 1986]</marker>
<rawString>Harel, D.: 1986, Effective transformations on infinite trees, with applications to high undecidability, dominoes, and fairness, Journal of the ACM, 33(1), 224-248.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Johnson</author>
</authors>
<title>Computing with features as formulas,</title>
<date>1992</date>
<institution>Cognitive and Linguistic Sciences Department, Brown University.</institution>
<note>manuscript,</note>
<marker>[Johnson 1992]</marker>
<rawString>Johnson, M.: 1992, Computing with features as formulas, manuscript, Cognitive and Linguistic Sciences Department, Brown University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Kasper</author>
<author>W Rounds</author>
</authors>
<title>A logical semantics for feature structures,</title>
<date>1986</date>
<booktitle>in Proceedings of the 24th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>257--266</pages>
<institution>Columbia University,</institution>
<location>New York,</location>
<marker>[Kasper and Rounds 1986]</marker>
<rawString>Kasper, R. and Rounds, W.: 1986, A logical semantics for feature structures, in Proceedings of the 24th Annual Meeting of the Association for Computational Linguistics, Columbia University, New York, 257-266.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Kasper</author>
<author>W Rounds</author>
</authors>
<date>1990</date>
<journal>The Logic of Unification in Grammar, Linguistics and Philosophy</journal>
<volume>13</volume>
<pages>33--58</pages>
<marker>[Kasper and Rounds 1990]</marker>
<rawString>Kasper, R. and Rounds, W.: 1990, The Logic of Unification in Grammar, Linguistics and Philosophy 13, 33-58.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Kaplan</author>
<author>J Bresnan</author>
</authors>
<title>Lexical functional grammar: A formal system for grammatical representation, in The Mental Representation of Grammatical Relations, edited by Joan Bresnan,</title>
<date>1982</date>
<pages>173--281</pages>
<publisher>MIT Press,</publisher>
<marker>[Kaplan and Bresnan 1982]</marker>
<rawString>Kaplan, K. and Bresnan, J.: 1982, Lexical functional grammar: A formal system for grammatical representation, in The Mental Representation of Grammatical Relations, edited by Joan Bresnan, MIT Press, 173-281.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Lewis</author>
<author>C Papadimitriou</author>
</authors>
<date>1981</date>
<journal>Elements of the Theory of Computation, Prentice-Hall.</journal>
<marker>[Lewis and Papadimitriou 1981]</marker>
<rawString>Lewis, H. and Papadimitriou, C.: 1981, Elements of the Theory of Computation, Prentice-Hall.</rawString>
</citation>
<citation valid="false">
<authors>
<author>C Pollard</author>
<author>I Sag</author>
</authors>
<title>Information-Based Syntax and Semantics: Volume 1 - Fundamentals.</title>
<journal>CSLI Lecture Notes,</journal>
<volume>13</volume>
<location>Stanford.</location>
<marker>[Pollard and Sag 1987]</marker>
<rawString>Pollard, C. and Sag, I.: Information-Based Syntax and Semantics: Volume 1 - Fundamentals. CSLI Lecture Notes, 13, Stanford.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>