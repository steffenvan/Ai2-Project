<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000003">
<note confidence="0.794125">
FROM WATER TO WINE:
GENERATING NATURAL LANGUAGE TEXT
FROM TODAY&apos;S APPLICATIONS PROGRAMS 1
</note>
<address confidence="0.715463333333333">
David D. McDonald
2 Harrison Avenue
Northampton, MA 01060
</address>
<email confidence="0.997106">
MCDONALD@CS.UMASS.EDU
</email>
<sectionHeader confidence="0.972355" genericHeader="abstract">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.999492666666667">
In this paper we present a means of compensating
for the semantic deficits of linguistically naive
underlying application programs without com-
promising principled grammatical treatments in
natural language generation. We present a method
for building an interface from today&apos;s underlying
application programs to the linguistic realization
component Mumble-86. The goal of the paper is not
to discuss how Mumble works, but to describe how
one exploits its capabilities. We provide examples
from current generation projects using Mumble as
their linguistic component.
</bodyText>
<sectionHeader confidence="0.989032" genericHeader="introduction">
INTRODUCTION
</sectionHeader>
<bodyText confidence="0.999950857142857">
Work in artificial intelligence has two goals: on
the one hand to do concrete work that can be used in
actual systems today, on the other to establish strong
theoretical foundations that will allow us to build
more sophisticated systems tomorrow.
Unfortunately, since the field is so young and so few
problems are well understood, these two goals are
often at odds.
Natural language generation is no exception. The
years of research in linguistics have made problems
in syntax comparatively well understood.
Nevertheless, we should not restrict ourselves to just
generating single, isolated sentences until the
problems of lexical semantics, discourse structure,
and conceptual modeling are understood as well. We
must find ways to facilitate both efforts,
modularizing our systems so that the parts that handle
well understood processes need not be compromised
to accomodate weaknesses in other parts of the
system. This paper is on how to support such
modularity in a natural language generator.
</bodyText>
<note confidence="0.953859428571429">
1 This work was supported in part by DARPA contracts
N00014-87-K0238 at the Univerisity of Massachusetts and
DAAA 15-87-00006 CDRLA002 at BBN Laboratories, and by
the Rome Air Development Center contract number AF30602-
81-C-0169, task number 174398 at the University of
Massachusetts.
Marie W. Meteer
</note>
<address confidence="0.512133666666667">
BBN Laboratories
10 Moulton St.
Cambridge MA 02338
</address>
<email confidence="0.881306">
MMETEER@G.BBN.COM
</email>
<bodyText confidence="0.999738130434783">
In the present case, the well understood process is
linguistic realization, and the weaknesses are in the
conceptual models and representations of the
programs underlying the generator. To bridge this
gap, we present a specification language, to be
used as input to the linguistic realization component
Mumble-86.2 This language provides the designer of
a planning component with a vocabulary of linguistic
resources (i.e. words, phrases, syntactic
constructions) and a straightforward means of
directing their composition. The specification
language facilitates interfacing Mumble to a wide
range of underlying programs and planners. For
simple programs not built with language in mind, we
show a straightforward means of using predefined
templates to map underlying objects to complex
linguistic structures. For systems with more
sophistication in text planning, we show how the
compositionality and flexibility of the specification
language can be used to make their task easier. What
is template driven at one end of the range can be built
compositionally at the other; what is stipulated at one
end can be reasoned about at the other.
</bodyText>
<sectionHeader confidence="0.926231" genericHeader="method">
A MOTIVATING EXAMPLE
</sectionHeader>
<bodyText confidence="0.999935583333333">
Consider the description &amp;quot;53rd Mechanized
Division&amp;quot;. In most programs today a sufficient
representation of the object it names could be just the
symbol 53RD-MECHANIZED-DIVISION. The print
name of the symbol conveys all the information that a
person reading the code needs to know, without it
actually playing a role in the program&apos;s reasoning. If
all we cared about were a single communicative
context, we might consider implementing the link
between the symbol and the description as though the
phrase were one long word without any internal
structure. This expedient treatment would severely
</bodyText>
<footnote confidence="0.2785435">
2 For a comprehensive description of Mumble-86, see Meteer,
McDonald, Anderson, Forster, Gay, Huettner, &amp; Sibun 1987.
</footnote>
<page confidence="0.999543">
41
</page>
<bodyText confidence="0.9999379375">
limit our options, however. Indefinite references,
such as &amp;quot;a mechanized division&amp;quot;, and subsequent
references, &amp;quot;the division&amp;quot;, would have to be handled
separately. Pronominalization would not be possible
since there are no associated features such as number,
gender, and person. Furthermore, since an artificial
word would have no internal syntactic structure, a
speech production program would have no
information on which to base intonation. A better
treatment is to introduce into the interface itself some
of the generality and structure that the underlying
representation is missing.
In the ALBM interface being developed at BBN,
we associate an object like 53RD-MECHANIZED-
DIVISION with the application of a general template to
an explicit set of arguments as shown below:
</bodyText>
<equation confidence="0.8172732">
(define-default-specification
&apos;53rd-mechanized-division
:template-name armed-forces-unit-name
:arguments (&amp;quot;53rd&amp;quot; &amp;quot;Mechanized&amp;quot; &amp;quot;Division&amp;quot;) )
FIGURE 1
</equation>
<bodyText confidence="0.999081625">
By going to this slightly greater effort, we have
supplied a hook for handling subsequent reference or
other abstractions (&amp;quot;the 53rd and 42nd mechanized
divisions&amp;quot;) without first requiring that the underlying
program contain the necessary semantic distinctions
and linguistic information. We return to this
example later and show how the template named in
Figure 1 builds an input specification for Mumble.
</bodyText>
<sectionHeader confidence="0.9010285" genericHeader="method">
MUMBLE&apos;S PLACE
IN THE GENERATION PROCESS.
</sectionHeader>
<bodyText confidence="0.992806479166667">
A key question is what information the input
specifications to Mumble represent. This amounts to
asking how we take the generation process to divide
into subprocesses---what decisions have already been
made and are reflected in the specifications, and
which ones remain. Since we have positioned the
level of the specification language so as to fit the
decomposition reflected in our own work and to
expedite the use of Mumble-86 by other researchers,
the answer can be given quite precisely. For a more
complete discussion of our approach and how it
contrasts with other work, see (McDonald, Meteer, &amp;
Pustejovsky, 1987). Overall we can divide the
generation process into three coarse stages:
Underlying program -- Developed inde-
pendently of the generator per se, this will be the
expert diagnostician, cooperative database, ICAI
tutor, etc. that the human users want to talk with.
Some event within this underlying program will
determine the goals the utterances are to achieve and
initiate the generation process.
Planning -- This process determines how the
goals can be achieved in a given context. This
includes selecting the information to be
communicated (or omitted), determining what
perspectives and rhetorical organization the
information should be given, and choosing a mapping
for the information onto the linguistic resources that
the language provides (i.e. open-class words and
syntactic constructions).
Realization -- This process carries out the
planner&apos;s specifications to produce an actual text. It
has the responsibility for insuring that the text is
grammatical, and will handle the bulk if not all of the
syntactic and morphological decision making.
In these terms, Mumble-86 is a realization
component.3 As such, we expect any system that uses
it to be able to supply the following kinds of
information about each utterance that it wants
produced, couching the information in terms of our
specification language. Mumble-86 is agnostic as to
whether this information was assembled by a
theoretically interesting planning component or
merely stipulated in predefined templates.
(a) The units from which the utterance is to be
composed. The mapping for each unit to its intended
linguistic resource will either have been already
made or will be fully defined for later execution.
</bodyText>
<listItem confidence="0.991017555555555">
(b) The functional relationships among the units,
e.g. predication, head, modifier, given, theme, etc.,
that direct or constrain the units&apos; organization within
the text.
(c) Lexical choice. As the primary means of
delimiting what information is or is not
communicated and what perspectives and
connotations are presented, all open class words are
choosen by the planner.
</listItem>
<footnote confidence="0.998612571428571">
3 We also refer to Mumble as a &amp;quot;linguistic component&amp;quot;,
reflecting the fact that all of the planners and underlying
programs that have been used with Mumble to date have
concentrated on conceptual issues and left all of the linguistic
efforts to it; this designation may have to change in the coming
years as the semantic and discourse level contributions of earlier
components become more significant.
</footnote>
<page confidence="0.999489">
42
</page>
<bodyText confidence="0.999932">
We see our specification language as providing a
medium for the results of a planner&apos;s decisions. The
syntax of the language provides a flexible,
compositional notation by which a planner may view
the potential linguistic form of the utterance it is
constructing without having to understand the myriad
details entailed by descriptions at the level of the
surface structure. In the next section, we describe the
syntax of the specification language. We then look at
how predefined templates can be used to abstract
away some of the details to make it easier for a
planner to construct them.
</bodyText>
<sectionHeader confidence="0.596854" genericHeader="method">
THE INPUT SPECIFICATION LANGUAGE
</sectionHeader>
<bodyText confidence="0.952413382352941">
Mumble&apos;s input specifications may be seen as
expressions over a vocabulary of elementary terms
and a syntax for their composition. In defining this
language, our choice of terms and compositional
operators was driven by what appears to be most
useful at the linguistic level. The simplest
expressions in the language, kernel specifications,
represent the choice of a class of phrases with a
lexical head and the specification of its arguments.
This reflects our belief that one almost never chooses
just to use a certain word, but rather to describe an
action with a verb and a specific set arguments for
example (see also Kegl, 1987). The result of
realizing a kernel is a phrasal unit comparable to an
elementary tree of a Tree Adjoining Grammar. (See
Joshi, 1987, for a discussion of properties of a TAG
which make them well suited to generation.)
Formally, a kernel consists of a realization function
and a list of arguments which are applied to it, where
a realization function is typically a class of phrases
distinguished by the characteristics of the syntactic
contexts in which they may appear. Executing the
realization function consists of choosing among the
phrases and instantiating the choice.
Larger, more complex utterances are formed by
composing kernels: joining them syntactically
according to the relationships between them. This
process is analogous to adjunction in a TAG. In
Mumble, these compositional expressions are called
bundles. They have three major parts:
(1) The head is either a kernel or a bundle; it is
realized first, as an &amp;quot;initial tree&amp;quot; into which other
specifications are attached; every bundle must have a
head.
</bodyText>
<listItem confidence="0.969960363636364">
(2) Further-specifications have two parts, a
specification (either a kernel or a bundle) and an
attachment function, which constrains where the new
tree may be adjoined to the surface structure already
built; these correspond to the &amp;quot;auxiliary trees&amp;quot; of a
TAG; a bundle may have any number of further
specifications.
(3) Accessories contain information about
language-specific syntactic details, such as tense and
number. Each bundle type has a specific set of
obligatory and optional accessories associated with it.
</listItem>
<bodyText confidence="0.998415666666667">
Note that bundles are not constrained as to the size of
the text they produce: they may produce a single
noun phrase or an entire paragraph.
Figure 2 shows a representation of the input
specification for the description &amp;quot;53rd Mechanized
Division&amp;quot; discussed at the beginning of the paper. In
the next section we describe how this specification
could be built from an object in the underlying
program.
</bodyText>
<figure confidence="0.957281176470588">
#&lt;bundle general-np
:head #&lt;kernel :realization-function
np-common-noun
:arguments (&amp;quot;division&amp;quot;) &gt;
:further-specifications
((:specification
#&lt;kernel :realization-function adjective
:arguments (&amp;quot;53rd&amp;quot;)&gt;
:attachment-function restrictive-modifier)
(:specification
#&lt;kernel:realization-function adjective
:arguments (&amp;quot;mechanized&amp;quot;)&gt;
:attachment-function restrictive-modifier))
:accessories (:number singular
:gender neuter
:person third
:determiner-policy no-determiner)&gt;
</figure>
<figureCaption confidence="0.588236">
FIGURE 2
</figureCaption>
<bodyText confidence="0.97870675">
Specifications are implemented as structured
objects, indicated by the &amp;quot;#&lt; &gt;&amp;quot; convention of
CommonLisp; the first symbol after the &amp;quot;&lt;&amp;quot; gives the
object&apos;s type. Other symbols are either object names
(e.g. &amp;quot;general-np&amp;quot;), or in a few cases print forms of
whole objects (such as the accessories and their
values). Strings in double quotes (e.g. &amp;quot;53rd&amp;quot;)
designate words.
</bodyText>
<page confidence="0.999391">
43
</page>
<sectionHeader confidence="0.668787" genericHeader="method">
DIRECT MAPPING: THE SIMPLE CASE
</sectionHeader>
<bodyText confidence="0.99981168">
The granularity and vocabulary of the input
specification language are designed to be well suited
for generating natural language. In principle the
semantic organization could match the structure of
the specification language exactly. If this were the
case, the mapping between units in the underlying
application program and the specifications to the
generator would be direct and one to one. However,
we cannot assume that today&apos;s underlying program
will have the same granularity or be able to reason in
the same vocabulary. For example, while the
accessories NUMBER, GENDER, and PERSON in the
specification above are necessary to determine the
correct pronoun, few underlying programs working
with mechanized divisions would bother to represent
their gender. Rather than force a planner to deal in
these terms, we provide a framework for building
specifications piecemeal by applying templates that
can be specialized to the application. Templates are
abstractions of specifications, which stipulate some of
the terms in the specification and parameterize
others. An object in the underlying program may be
mapped to a template through a default specification,
as illustrated in Figure 1 and repeated below along
with the template ARMED -FORCES-UNIT-NAME:
</bodyText>
<figure confidence="0.928772">
(define-default-specification
&apos;53rd-mechanized-division
.:template-name armed-forces-unit-name
:arguments (&amp;quot;53rd&amp;quot; &amp;quot;Mechanized&amp;quot; &amp;quot;Division&amp;quot;) )
(define-specification-template
armed-forces-unit-name
(number type size)
(let ((K (make-a-kernel &apos;np-common-noun size))
(B (make-a-bundle &apos;general-np)))
(set-bundle-head B K)
(neuter-&amp;-third-person 8)
(singular B)
(no-determiner B)
(add-specializing-description
(property-realized-as-an-adjective number)
B)
(add-specializing-description
(property-realized-as-an-adjective type)
B)
B))
FIGURE 3
</figure>
<bodyText confidence="0.999708857142857">
As a formal entity, this template is essentially a
procedure for assembling the data structures that
make up a specification. It is a Lisp program and
draws on a set of predefined functions (e.g. set-
bundle-head, no-determiner) to simplify the
statement of the necessary actions. Every template is
required to provide all of the elements that make up a
properly formed realization specification. In this
case a bundle for a noun phrase is being assembled,
and so there must be a kernel built for the head of the
bundle and values given for all the accessories that
bundles of that type require. Since the phrases
specified by this particular template are compositions
linguistically, i.e. they involve the adjunction of two
modifiers to the inital np-common-noun, the template
includes operations (&amp;quot;add-specializing-description&amp;quot;)
that add the sources of the modifiers using the proper
attachment function.
These same techniques may be used to generate
longer texts. The following example differs from the
last one in three ways:
</bodyText>
<listItem confidence="0.973642555555556">
(1) The templates are building larger structures:
discourse units which produce multiple sentences and
clause bundles which produce complex sentences.
(2) Default mappings are defined between classes
of objects and templates rather than having to define a
mapping for each instance of the class.
(3) Templates can be called explicitly from other
templates with a dynamically chosen set of
arguments.
</listItem>
<bodyText confidence="0.999829727272727">
The example is from one of the generation tasks
in the ALBM domain: to produce a &amp;quot;mission
restatement&amp;quot; paragraph describing the essential tasks
in some operation. These tasks are presented to the
generator as a simple list of TASK-OBJECTS,
expressing the who, what, when, where, and why of
the task, along with a dependency graph representing
the relations between them. Figure 4 shows an
example of a task object and a portion of a mission
restatment paragraph produced by our current
prototype of the text planner.
</bodyText>
<table confidence="0.6157942">
#&lt;unit T01.ATTACK4
parent: #&lt;unit TASK.OBJECT&gt;
slots:
unit: #&lt;unit 10TH-cos#&gt;
action: #&lt;unit ATTACK&gt;
objective: #&lt;unit NORTHEAST&gt;
intent: #&lt;unit SECURE.OHJECTIVES&gt; &gt;
&amp;quot;10th (U.S.) Corps attacks to the northeast to
secure objectives. 10th (U.S.) Corps exploits east
of Thuringer Wald.&amp;quot;
</table>
<footnote confidence="0.4790965">
FIGURE 4
4 1-or brevity and clarity we use a textbook frame style rather
than showing the actual ICEE underlying representation; we also
show only the slots which directly impact this discussion.
</footnote>
<page confidence="0.998872">
44
</page>
<bodyText confidence="0.999929875">
Our prototype text planner takes advantage of the
uniformity of the objects in the underlying program
that motivates the text and the uniformity in the form
of the paragraphs to be produced. These uniformities
allow us to use predefined templates for these
paragraphs in much the same way as McKeown used
schemas to produce the overall organization of
definitions of data base attributes (McKeown, 1985).
Note that there are two very important assumptions
inherent in this approach: First, the information
needed is explicitly represented in data structures in
the underlying program. Second, those data
structures are stable, that is, in the lifetime of the
project, the structures will not change, or if they do,
then the specific templates that access them must
change as well.
</bodyText>
<figure confidence="0.97777871875">
(define-default-specification
(k:unit `K::task.object)
:template-name express-task
:arguments 0)
(define-specification-template express-task5 0
(let* ((r-fn (instantiate-mapping
(k:unit
(k:get.value self &apos;k::action))))
(agent (instantiate-mapping
(k:unit
(k:get.value self &apos;k::unit))))
(k (make-a-kernel r-fn agent))
(loc (when
(k:get.value self &apos;K::objective)
(make-a-further-specification
&apos;location-modifier
(instantiate-mapping
(k:unit
(k:get.value self
&apos;K: :objective)))
)))
(intent (when
(k:get.value self &apos;K::intent)
(make-a-further-specification
&apos;rationale-modifier
(k:unit
(k:get.value self
&apos;K: :intent))
))))
(funcall-template &apos;current-event-with-modifiers
k loc intent)))
FIGURE 5
</figure>
<footnote confidence="0.355003">
Self is bound to the instance being mapped at the time the
mapping occurs; in this case, it is bound to the unit tol.attack.
</footnote>
<bodyText confidence="0.999374666666667">
The top level function for generating the mission
paragraph builds a discourse unit bundle with the
first task-object as the head of the bundle and the rest
as an ordered list of further-specifications. Since the
relations between the task objects in this example is
simply sequential-temporal, the default attachment
function &amp;quot;new sentence&amp;quot; is used, resulting a sequence
of separate sentences, one for each task.
Figure 5 shows the default specifications for the
class task-object and the template it references.
This template is a specialist which picks out the
information from the task object to be included in the
mission paragraph. Note that the modularity of the
task objects is different from that of the actual
sentences which express them. The action and unit
combine to form the matrix of the sentence and other
slots function as adjuncts, such as the location and
intent. The template shown in Figure 6 combines
these elements into a clause bundle and sets the
accessories to unmarked (not a question or command)
and simple present tense. These features are
stipulated as part of the style of these paragraphs
rather than stemming from anything in the
underlying representation.
</bodyText>
<figure confidence="0.990901111111111">
(define-template current-event-with-modifiers
(event &amp;rest modifiers)
(let ((b (make-a-bundle &apos;general-clause))
(set-bundle-head b event)
(present-tense b)
(unmarked b)
(dolist Cm modifers)
(add-already-built-further-specification m b)
b))
</figure>
<figureCaption confidence="0.677471">
FIGURE 6
</figureCaption>
<bodyText confidence="0.9998761875">
In the examples described above, our use of
templates is a shorthand for building realization
specifications. As such it is appropriate for the very
simple text planning that typifies today&apos;s generation
applications: Already formed objects and
expressions in the underlying application program
can be associated directly with semi-custom templates
with the English words introduced as arguments. In
more complex text planning where, for example, the
same objects are presented from different
perspectives depending on the communicative
situation, there is unlikely to already be any
expression with the right properties, and it will be the
planner&apos;s task to construct one. Here too, our facility
for mapping objects to specifications will be very
useful.
</bodyText>
<page confidence="0.999192">
45
</page>
<sectionHeader confidence="0.863709" genericHeader="method">
COMPOSING SPECIFICATIONS
</sectionHeader>
<bodyText confidence="0.99976965">
In this section we look ahead to the development
of general planners with the ability to dynamically
select and orchestrate information from the
underlying program to fit the occasion. One of a
planner&apos;s prime abilities will be to appreciate the
functions and consequences of alternative forms and
combinations by which the same body of information
can be communicated. Our specification language
permits such alternatives to be simply stated. We can
see this in an illustration taken from our ongoing
work with the KRS system in use at the Rome Air
Development Center. KRS (&amp;quot;Chris&amp;quot;) is a rule based
system for mission planning. Its internal
representation is based on instantiating relations
represented as lists of symbols: for example the three
relations shown below in Figure 7 (&amp;quot;facts&amp;quot; in the
lefthand side of one of KRS&apos;s production rules),
along with their English realizations as given by the
direct replacement generator presently included with
KRS.
</bodyText>
<equation confidence="0.989315333333333">
(target OCA1002 BE50318)
(PowA BE50318 BE50318-Search-Radar)
(IS-A 8E50318-Search-Radar Electronics)
</equation>
<bodyText confidence="0.939405">
The target of OCAI002 is BE50318. Part of
BE50318 is BE50318-Search-Radar. BE50318-
Search-Radar radiates.
</bodyText>
<figureCaption confidence="0.727244">
FIGURE 7
</figureCaption>
<bodyText confidence="0.998457931506849">
While perhaps good enough to serve its purpose
(i.e. as part of the KRS rule-editor), this text is
unnatural--no person would ever say it. Stylistically
it is chunky and awkward, but more importantly, it
actually mis-communicates the relative value of the
three facts by giving them equal weight in the
utterance.
A sophisticated text planner would want to convey
not just propositional information but also to indicate
its rhetorical significance, e.g. what is important,
what is unusual. In the present case, the fact about the
assignment of the target was specified by the user and
is thus a given. The fact that the target has a search
radar may or may not already be known. The fact
that this particular radar is known to be active is the
most significant, since it is this fact that has an impact
on the planning of the mission (i.e. there now have to
be radar-suppression aircraft included).
Depending on whether or not the existence of the
search radar is known, a much improved rendering
of the three facts could be one of these two:
&amp;quot;The target has an active search radar&amp;quot;
&amp;quot;The target&apos;s search radar is active&amp;quot;
Given that we will have already established
mappings to suitable templates for each of the three
facts independently, the specification of a single
sentence expressing all three becomes a matter of
combining them into a single specification, varying
their positions as bundle heads or further
specifications and specifying the appropriate
attachment functions. This ability to combine parts
without affecting their internal structure is one of the
most powerful aspects of our specification language.
The specification for &amp;quot;The target has an active
search radar&amp;quot; (Figure 8) would be built by using the
second fact, &amp;quot;part of&apos;, as the backbone of the bundle,
supplying the head and thereby the main verb has.
The first fact--(target ... BE50318).—iS then folded
in as the way of describing BE50318 (interpreting the
fact as ascribing the functional role of &amp;quot;target&amp;quot; to its
second argument, the &amp;quot;battle element&amp;quot;), and the third
fact-- ( isa ... electronics) --becomes a modifier in
the description of the search radar.
Alternatively, to specify &amp;quot;The target&apos;s search
radar is active&amp;quot; (Figure 9), one would position the
third fact as the head of the bundle and use the first
two as the characterization of the search radar. As
indicated on the two figures, these specifications are
assembled from exactly the same three partial
specifications, but combined in different orders with
different attachment functions.
Note that the pretty-printing of these
specifications is a little simpler than the earlier ones
so as to conserve space, and that it includes another
field--&amp;quot;underlying-object&amp;quot;--to make the origins of
the different parts of the specification clearer.
One other point that may be unexpected is the fact
that the Figures include two instances of the
specification for the search radar, one as the second
argument to have as we would expect, and a second
embedded within the first as part of the &amp;quot;clause&amp;quot;
specification for (ISA ... electronics). Of course,
if this second instance were missing--say as the result
of some planning-level abbreviation in recognition
that only the adjective within that specification was
going to actually appear in the final text--then the
specifications in the two figures would not just be
simple rearrangements of the same parts (a
generalization we consider valuable); instead we
have the selection of the adjective done as part of
realization as one of the normal choices for simple
predications, under control of the position where the
specification is attached, i.e. as a modifier to an NP.
</bodyText>
<page confidence="0.997742">
46
</page>
<figure confidence="0.997311403669724">
#&lt;bundle general-clause
:underlying-object (POWA ... search-radar)
:head
#&lt;kernel HAVE-as-possession
( #&lt;bundle general-np
:underlying-object 8E50318
:head #&lt;kernel NP-common-noun
(&amp;quot;target&amp;quot;)&gt;
:accessories (:number singular
:gender neuter
:person third
:determiner-policy
always-definite)&gt;
#&lt;bundle general-np
:underlying-object BE50318-search-radar
:head #&lt;kernel NP-common-noun
(&amp;quot;radar&amp;quot;)&gt;
:accessories (:number singular
:gender neuter
:person third
:determiner-policy
always-definite)
:further-specifications
((:specification
#&lt;kernel common-noun
(&amp;quot;search&amp;quot;)&gt;
:attachment-function classifier)
(:specification
#&lt;bundle general-clause
:underlying-object (ISA...electronics)
:head
#&lt;kernel predication_to-be
(#&lt;bundle general-np
:underlying-object
BE50318-search-radar
:head #&lt;kernel NP-common-noun
(&amp;quot;radar&amp;quot;)&gt;
:accessories (:number singular
:gender neuter
:person third
:determiner-policy
always-definite)
:further-specifications
((:specification
#&lt;kernel common-noun
(&amp;quot;search&amp;quot;)&gt;
:attachment-function
classifier))&gt;
#&lt;kernel ADJP-adjective
(&amp;quot;active&amp;quot;)&gt; ) »
:attachment-function restrictive-modifier
))&gt; )&gt;
:accessories
(:unmarked
:tense-modal present)&gt;
#&lt;bundle general-clause
:underlying-object (ISA...electronics)
:head
#&lt;kernel predication_to-be
( #&lt;bundle general-np
:underlying-object BE50318-search-radar
:head
#&lt;kernel NP-common-noun
(&amp;quot;radar&amp;quot;)&gt;
:accessories (:number singular
:gender neuter
:person third
:determiner-policy
always-definite)
:further-specifications
((:specification
#&lt;kernel common-noun
(&amp;quot;search&amp;quot;)&gt;
:attachment-function classifier))
(:specification
#&lt;kernel HAVE-as-possession
( #&lt;bundle general-np
:underlying-object BE50318
:head #&lt;kernel NP-common-noun
(&amp;quot;target&amp;quot;)&gt;
:accessories (:number singular
:gender neuter
:person third
:determiner-policy
always-definite)&gt;
#&lt;bundle general-np
:underlying-object
BE50318-search-radar
:head #&lt;kernel NP-common-noun
(&amp;quot;radar&amp;quot;)&gt;
:accessories (:number singular
:gender neuter
:person third
:determiner-policy
always-definite)
:further-specifications
((:specification
#&lt;kernel common-noun
(&amp;quot;search&amp;quot;)&gt;
:attachment-function
classifier))
:attachment-function possessive ))&gt;
#&lt;kernel ADJP-adjective
(&amp;quot;active&amp;quot;)&gt; )&gt;
:accessories
(:unmarked
:tense-modal present)&gt;
&apos;The target has an active search radar.&amp;quot; &amp;quot;The target&apos;s search radar is active.&amp;quot;
FIGURE 8 FIGURE 9
</figure>
<page confidence="0.997774">
47
</page>
<sectionHeader confidence="0.994144" genericHeader="conclusions">
CONCLUSION
</sectionHeader>
<bodyText confidence="0.999808930232558">
The specification language has been completely
implemented and used in-house since the fall of 1986.
The templates and the specifics of how objects and
expressions in underlying applications and planners
are to be linked to Mumble-86 have evolved over that
time and may continue to evolve somewhat as we get
more experience with other applications. Mumble-
86 itself is currently being used both for applications
and as a research tool at a variety of sites including
the University of Massachusetts, BBN Labs, RADC,
and University of Pennsylvania.
As part of an excercise in learning how to use
Mumble-86, two researchers from RADC, Sharon
Walter and Doug White, recently extended the
program to generate in KRS&apos;s domain. It took them
only two days to learn the specification language,
build input specifications, and make the necessary
grammatical and lexical extensions to generate
several sentences in their domain, including those
shown in Figure 7. Neither had used Mumble-86
before.
In conclusion we would like to emphasize two
main points. The first is the importance of
modularity in design and portability of the modules
so that research can concentrate on new and hard
problems without having to waste effort reinventing
the wheel. Mumble-86 has been developed to be just
such a portable module. It has the responsibility for
all syntactic decisions without making presumptions
about the semantic model of the application program
that uses it.
Our second point is that a designer should not
compromise the integrity of a well developed module
to accomodate one which is less well developed when
the two are brought together in the same system.
This is the purpose of the input specification language
we have introduced in this paper. In developing this
language, we have clarified what decisions have to be
made outside Mumble-86 and which decisions are its
responsibility, thus circumscribing its sphere of
influence and making it more useful as a domain
independent linguistic component and as a tool for
research in text planning and discourse structure.
</bodyText>
<sectionHeader confidence="0.99906" genericHeader="references">
REFERENCES
</sectionHeader>
<reference confidence="0.999683272727273">
Joshi, Aravind K. (1987a) &amp;quot;The Relevance of Tree Adjoining
Grammar to Generation&amp;quot;, in Kempen (ed.), p. 233-252.
Joshi, Aravind K. (1987b) &amp;quot;Word-Order Variation in Natural
Language Generation&amp;quot;, AAAI-87 Proceedings, p. 550-555.
Kegl, Judy, (1987) &amp;quot;The Boundary Between Word
Knowledge and World Knowledge&amp;quot;, Proceedings of
Theoretical Issues in Natural Language Processing&amp;quot;,
Memoranda in Computer and Cognitive Science, New
Mexico State University, p. 26-31.
Kempen (ed.) (1987) Natural Language Generation , Martinus
Nijoff Publishers, Dordrecht, The Netherlands.
McDonald, David D., Marie W. Meteer, &amp; James D.
Pustejovsky (1987) &amp;quot;Factors Contributing to Efficiency in
Natural Language Generation&amp;quot;, in Kempen (ed.), p. 159-
182.
McKeown, Kathleen R. (1985) &amp;quot;Discourse Strategies for
Generating Natural Language Text&amp;quot;, Artificial Intelligence
27, p. 1-42.
Meteer, Marie W., David D. McDonald, Scott Anderson,
David Forster, Linda Gay, Alison Heuttner, &amp; Penelope
Sibun, &amp;quot;Mumble-86: Design and Implementation&amp;quot;, UMass
Technical Report 87-87, 173 pages.
</reference>
<page confidence="0.999352">
48
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.611014">
<title confidence="0.990116333333333">FROM WATER TO WINE: NATURAL LANGUAGE TEXT TODAY&apos;S APPLICATIONS PROGRAMS 1</title>
<author confidence="0.999914">David D McDonald</author>
<address confidence="0.8266175">2 Harrison Avenue Northampton, MA 01060</address>
<email confidence="0.979059">MCDONALD@CS.UMASS.EDU</email>
<abstract confidence="0.998712230769231">In this paper we present a means of compensating for the semantic deficits of linguistically naive underlying application programs without compromising principled grammatical treatments in natural language generation. We present a method for building an interface from today&apos;s underlying application programs to the linguistic realization component Mumble-86. The goal of the paper is not to discuss how Mumble works, but to describe how one exploits its capabilities. We provide examples from current generation projects using Mumble as their linguistic component.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Aravind K Joshi</author>
</authors>
<title>The Relevance of Tree Adjoining Grammar to Generation&amp;quot;,</title>
<date>1987</date>
<pages>233--252</pages>
<editor>in Kempen (ed.),</editor>
<contexts>
<context position="9845" citStr="Joshi, 1987" startWordPosition="1505" endWordPosition="1506">ge, our choice of terms and compositional operators was driven by what appears to be most useful at the linguistic level. The simplest expressions in the language, kernel specifications, represent the choice of a class of phrases with a lexical head and the specification of its arguments. This reflects our belief that one almost never chooses just to use a certain word, but rather to describe an action with a verb and a specific set arguments for example (see also Kegl, 1987). The result of realizing a kernel is a phrasal unit comparable to an elementary tree of a Tree Adjoining Grammar. (See Joshi, 1987, for a discussion of properties of a TAG which make them well suited to generation.) Formally, a kernel consists of a realization function and a list of arguments which are applied to it, where a realization function is typically a class of phrases distinguished by the characteristics of the syntactic contexts in which they may appear. Executing the realization function consists of choosing among the phrases and instantiating the choice. Larger, more complex utterances are formed by composing kernels: joining them syntactically according to the relationships between them. This process is anal</context>
</contexts>
<marker>Joshi, 1987</marker>
<rawString>Joshi, Aravind K. (1987a) &amp;quot;The Relevance of Tree Adjoining Grammar to Generation&amp;quot;, in Kempen (ed.), p. 233-252.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Aravind K Joshi</author>
</authors>
<title>Word-Order Variation in Natural Language Generation&amp;quot;,</title>
<date>1987</date>
<booktitle>AAAI-87 Proceedings,</booktitle>
<pages>550--555</pages>
<contexts>
<context position="9845" citStr="Joshi, 1987" startWordPosition="1505" endWordPosition="1506">ge, our choice of terms and compositional operators was driven by what appears to be most useful at the linguistic level. The simplest expressions in the language, kernel specifications, represent the choice of a class of phrases with a lexical head and the specification of its arguments. This reflects our belief that one almost never chooses just to use a certain word, but rather to describe an action with a verb and a specific set arguments for example (see also Kegl, 1987). The result of realizing a kernel is a phrasal unit comparable to an elementary tree of a Tree Adjoining Grammar. (See Joshi, 1987, for a discussion of properties of a TAG which make them well suited to generation.) Formally, a kernel consists of a realization function and a list of arguments which are applied to it, where a realization function is typically a class of phrases distinguished by the characteristics of the syntactic contexts in which they may appear. Executing the realization function consists of choosing among the phrases and instantiating the choice. Larger, more complex utterances are formed by composing kernels: joining them syntactically according to the relationships between them. This process is anal</context>
</contexts>
<marker>Joshi, 1987</marker>
<rawString>Joshi, Aravind K. (1987b) &amp;quot;Word-Order Variation in Natural Language Generation&amp;quot;, AAAI-87 Proceedings, p. 550-555.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Judy Kegl</author>
</authors>
<title>The Boundary Between Word Knowledge and World Knowledge&amp;quot;,</title>
<date>1987</date>
<booktitle>Proceedings of Theoretical Issues in Natural Language Processing&amp;quot;, Memoranda in Computer and Cognitive Science,</booktitle>
<pages>26--31</pages>
<institution>Mexico State University,</institution>
<location>New</location>
<contexts>
<context position="9714" citStr="Kegl, 1987" startWordPosition="1482" endWordPosition="1483">ations may be seen as expressions over a vocabulary of elementary terms and a syntax for their composition. In defining this language, our choice of terms and compositional operators was driven by what appears to be most useful at the linguistic level. The simplest expressions in the language, kernel specifications, represent the choice of a class of phrases with a lexical head and the specification of its arguments. This reflects our belief that one almost never chooses just to use a certain word, but rather to describe an action with a verb and a specific set arguments for example (see also Kegl, 1987). The result of realizing a kernel is a phrasal unit comparable to an elementary tree of a Tree Adjoining Grammar. (See Joshi, 1987, for a discussion of properties of a TAG which make them well suited to generation.) Formally, a kernel consists of a realization function and a list of arguments which are applied to it, where a realization function is typically a class of phrases distinguished by the characteristics of the syntactic contexts in which they may appear. Executing the realization function consists of choosing among the phrases and instantiating the choice. Larger, more complex utter</context>
</contexts>
<marker>Kegl, 1987</marker>
<rawString>Kegl, Judy, (1987) &amp;quot;The Boundary Between Word Knowledge and World Knowledge&amp;quot;, Proceedings of Theoretical Issues in Natural Language Processing&amp;quot;, Memoranda in Computer and Cognitive Science, New Mexico State University, p. 26-31.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kempen</author>
</authors>
<date>1987</date>
<booktitle>Natural Language Generation , Martinus Nijoff Publishers,</booktitle>
<location>Dordrecht, The Netherlands.</location>
<marker>Kempen, 1987</marker>
<rawString>Kempen (ed.) (1987) Natural Language Generation , Martinus Nijoff Publishers, Dordrecht, The Netherlands.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David D McDonald</author>
<author>Marie W Meteer</author>
<author>James D Pustejovsky</author>
</authors>
<title>Factors Contributing to Efficiency in Natural Language Generation&amp;quot;,</title>
<date>1987</date>
<pages>159--182</pages>
<editor>in Kempen (ed.),</editor>
<contexts>
<context position="5999" citStr="McDonald, Meteer, &amp; Pustejovsky, 1987" startWordPosition="891" endWordPosition="895">ERATION PROCESS. A key question is what information the input specifications to Mumble represent. This amounts to asking how we take the generation process to divide into subprocesses---what decisions have already been made and are reflected in the specifications, and which ones remain. Since we have positioned the level of the specification language so as to fit the decomposition reflected in our own work and to expedite the use of Mumble-86 by other researchers, the answer can be given quite precisely. For a more complete discussion of our approach and how it contrasts with other work, see (McDonald, Meteer, &amp; Pustejovsky, 1987). Overall we can divide the generation process into three coarse stages: Underlying program -- Developed independently of the generator per se, this will be the expert diagnostician, cooperative database, ICAI tutor, etc. that the human users want to talk with. Some event within this underlying program will determine the goals the utterances are to achieve and initiate the generation process. Planning -- This process determines how the goals can be achieved in a given context. This includes selecting the information to be communicated (or omitted), determining what perspectives and rhetorical</context>
</contexts>
<marker>McDonald, Meteer, Pustejovsky, 1987</marker>
<rawString>McDonald, David D., Marie W. Meteer, &amp; James D. Pustejovsky (1987) &amp;quot;Factors Contributing to Efficiency in Natural Language Generation&amp;quot;, in Kempen (ed.), p. 159-182.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kathleen R McKeown</author>
</authors>
<title>Discourse Strategies for Generating Natural Language Text&amp;quot;,</title>
<date>1985</date>
<journal>Artificial Intelligence</journal>
<volume>27</volume>
<pages>1--42</pages>
<contexts>
<context position="17152" citStr="McKeown, 1985" startWordPosition="2565" endWordPosition="2566">nger Wald.&amp;quot; FIGURE 4 4 1-or brevity and clarity we use a textbook frame style rather than showing the actual ICEE underlying representation; we also show only the slots which directly impact this discussion. 44 Our prototype text planner takes advantage of the uniformity of the objects in the underlying program that motivates the text and the uniformity in the form of the paragraphs to be produced. These uniformities allow us to use predefined templates for these paragraphs in much the same way as McKeown used schemas to produce the overall organization of definitions of data base attributes (McKeown, 1985). Note that there are two very important assumptions inherent in this approach: First, the information needed is explicitly represented in data structures in the underlying program. Second, those data structures are stable, that is, in the lifetime of the project, the structures will not change, or if they do, then the specific templates that access them must change as well. (define-default-specification (k:unit `K::task.object) :template-name express-task :arguments 0) (define-specification-template express-task5 0 (let* ((r-fn (instantiate-mapping (k:unit (k:get.value self &apos;k::action)))) (ag</context>
</contexts>
<marker>McKeown, 1985</marker>
<rawString>McKeown, Kathleen R. (1985) &amp;quot;Discourse Strategies for Generating Natural Language Text&amp;quot;, Artificial Intelligence 27, p. 1-42.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Marie W Meteer</author>
<author>David D McDonald</author>
<author>Scott Anderson</author>
<author>David Forster</author>
<author>Linda Gay</author>
</authors>
<title>Alison Heuttner, &amp; Penelope Sibun, &amp;quot;Mumble-86: Design and Implementation&amp;quot;,</title>
<tech>UMass Technical Report 87-87,</tech>
<pages>173</pages>
<marker>Meteer, McDonald, Anderson, Forster, Gay, </marker>
<rawString>Meteer, Marie W., David D. McDonald, Scott Anderson, David Forster, Linda Gay, Alison Heuttner, &amp; Penelope Sibun, &amp;quot;Mumble-86: Design and Implementation&amp;quot;, UMass Technical Report 87-87, 173 pages.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>