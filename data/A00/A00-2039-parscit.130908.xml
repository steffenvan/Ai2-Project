<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000002">
<title confidence="0.997555">
Finite-State Reduplication in One-Level Prosodic Morphology
</title>
<author confidence="0.996756">
Markus Walther
</author>
<affiliation confidence="0.998555">
University of Marburg
</affiliation>
<address confidence="0.967964">
FB09/IGS, Wilhelm-Ropke-Str. 6A, D-35032 Marburg, Germany
</address>
<email confidence="0.998644">
Markus.Walther@mailer.uni-marburg.de
</email>
<sectionHeader confidence="0.99386" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999587454545455">
Reduplication, a central instance of prosodic mor-
phology, is particularly challenging for state-of-
the-art computational morphology, since it involves
copying of some part of a phonological string. In
this paper I advocate a finite-state method that com-
bines enriched lexical representations via intersec-
tion to implement the copying. The proposal in-
cludes a resource-conscious variant of automata and
can benefit from the existence of lazy algorithms.
Finally, the implementation of a complex case from
Koasati is presented.
</bodyText>
<sectionHeader confidence="0.9988" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999931942307692">
In the past two decades computational morphology
has been quite successful in dealing with the chal-
lenges posed by natural language word patterns.
Using finite-state methods, it has been possible to
describe both word formation and the concomi-
tant phonological modifications in many languages,
ranging from straightforward concatenative combi-
nation (Koskenniemi, 1983) over Semitic-style non-
concatenative intercalation (Beesley (1996), Kiraz
(1994)) to circumfixional long-distance dependen-
cies (Beesley, 1998).
However, Sproat (1992) observes that, despite
the existence of &amp;quot;working systems that are capa-
ble of doing a great deal of morphological analy-
sis&amp;quot;, &amp;quot;there are still outstanding problems and ar-
eas which have not received much serious attention&amp;quot;
(ibid., 123). Problem areas in his view include sub-
tractive morphology, infixation, the proper inclu-
sion of prosodic structure and, in particular, redu-
plication: &amp;quot;From a computational point of view, one
point cannot be overstressed: the copying required
in reduplication places reduplication in a class apart
from all other morphology.&amp;quot; (ibid., 60). Productive
reduplication is so troublesome for a formal account
based on regular languages (or regular relations)
because unbounded total instances like Indonesian
noun plural (orang-orang &apos;men&apos;) are isomorphic to
the copy language ww, which is context-sensitive.
In the rest of this paper I will lay out a proposal
for handling reduplication with finite-state methods.
As a starting point, I adopt Bird &amp; Ellison (1994)&apos;s
One-Level Phonology, a monostratal constraint-
based framework where phonological representa-
tions, morphemes and generalizations are all finite-
state automata (FSAs) and constraint combination
is accomplished via automata intersection. While
it is possible to transfer much of the present pro-
posal to the transducer-based setting that is often
preferred nowadays, the monostratal approach still
offers an attractive alternative due to its easy blend
with monostratal grammars such as HPSG and the
good prospects for machine learning of its surface-
true constraints (Ellison (1992), Belz (1998)).
After a brief survey of important kinds of redupli-
cation in §2, section §3 explains the necessary ex-
tensions of One-Level Phonology to deal with the
challenges presented by reduplication, within the
larger domain of prosodic morphology in general.
A worked-out example from Koasati in §4 illus-
trates the interplay of the various components in an
implemented analysis, before some conclusions are
drawn in section §5.
</bodyText>
<sectionHeader confidence="0.996349" genericHeader="introduction">
2 Reduplication
</sectionHeader>
<bodyText confidence="0.9940775">
A well-known case from the context-sensitivity
debate of the eighties is the N-o-N reduplicative
construction from Bambara (Northwestern Mande,
(Culy, 1985)):
</bodyText>
<listItem confidence="0.9899352">
(1) a. wulu-o-wulu &apos;whichever dog&apos;
b. wulunyinina-o-wulunyinina
&apos;whichever dog searcher&apos;
c. wulunyininafilela-o-wulunyininafilela
&apos;whoever watches dog searchers&apos;
</listItem>
<bodyText confidence="0.8469435">
Beyond total copying, (1) also illustrates the pos-
sibility of so-called fixed-melody parts in redupli-
</bodyText>
<page confidence="0.996823">
296
</page>
<bodyText confidence="0.997908">
cation: a constant /o/ intervenes between base (i.e.
original) and reduplicant (i.e. copied part, in bold
print). I
The next case from Semai expressive minor redu-
plication (Mon-Khmer, Hendricks (1998)) high-
lights the possibility of an interaction between redu-
plication and internal truncation:
</bodyText>
<listItem confidence="0.9691352">
(2) a. c?c:t et-chit &apos;sweet&apos;
b. drjah dh-drph &apos;appearance of nod-
ding constantly&apos;
c. cfail cl-cfail &apos;appearance of flick-
ering red object&apos;
</listItem>
<bodyText confidence="0.99511">
Reduplication copies the initial and final segment of
the base, skipping all of its interior segments, which
may be of arbitrary length.
A final case comes from Koasati punctual-aspect
reduplication (Muscogean, (Kimball, 1988)):
</bodyText>
<listItem confidence="0.796995375">
(3) a. ta.has.pin tiahas-t16:-pin
&apos;to be light in weight&apos;
b. la.pat.kin 11 apat-I16: -kin
&apos;to be narrow
c. ak.lát.lin al k-hi
&apos;to be loose&apos;
d. ok.cak.kon o-caldcon
&apos;to be green or blue&apos;
</listItem>
<bodyText confidence="0.9994286875">
Koasati is particularly interesting, because it shows
that copy and original need not always be adjacent
— here the reduplicant is infixed into its own base —
and also because it illustrates that the copy may be
phonologically modified: the /h/ in the copied part
of (3).c,d is best analysed as a voiceless vowel, i.e.
the phonetically closest consonantal expression of
its source. Moreover, the locus of the infixed redu-
plicant is predictable on prosodic grounds, as it is
inserted after the first heavy syllable of the base.
Heavy syllables in Koasati are long (C)VV or closed
(C)VC. Prosodic influence is also responsible for
the length alternation of its fixed-melody part /o(o)/,
since the heaviness requirement for the penultimate,
stressed, syllable of the word causes long Rid if the
reduplicant constitutes that syllable.
</bodyText>
<footnote confidence="0.501725166666667">
tCuly (1985), who presents a superset of the data under (1)
in the context of a formal proof of context-sensitivity, shows
that the reduplicative construction in fact can copy the outcome
of a recursive agentive construction, thereby becoming truly
unbounded. He emphasizes the fact that it is &amp;quot;very productive,
with few, if any restrictions on the choice of the noun&amp;quot; (p.346).
</footnote>
<sectionHeader confidence="0.999874" genericHeader="method">
3 Finite-State Methods
</sectionHeader>
<bodyText confidence="0.9999258">
The present proposal differs from the state-labelled
automata employed in One-Level Phonology by re-
turning to conventional arc-labelled ones, but shares
the idea that labels denote sets, which is advanta-
geous for compact automata.
</bodyText>
<subsectionHeader confidence="0.997943">
3.1 Enriched Representations
</subsectionHeader>
<bodyText confidence="0.9884056">
As motivated in §2, an appropriate automaton repre-
sentation of morphemes that may undergo redupli-
cation should provide generic support for three key
operations: (i) copying or repetition of symbols, (ii)
truncation or skipping, and (iii) infixation.
For copying, the idea is to enrich the FSA rep-
resenting a morpheme by encoding stepwise repeti-
tion locally. For every content arc i 4 j we add a
repeat.
reverse repeat arc j i. Following repeat arcs,
we can now move backwards within a string, as we
shall see in more detail below.
For truncation, a similar local encoding is avail-
able: For every content arc i 4 j, add another skip
arc i 8/23 j. This allows us to move forward while
suppressing the spellout of c.
A generic recipe for infvcation ensures that seg-
mental material can be inserted anywhere within
an existing morpheme FSA. A possible representa-
tional enrichment therefore adds a self loop i 4 i
labelled with the symbol alphabet E to every state i
of the FSA.2
Each of the three enrichments presupposes an
epsilon-free automaton in order to be wellbehaved.
This requirement in particular ensures that techni-
cal arcs (skip, repeat) are in 1:1 correspondence
with content arcs, which is essential for unambigu-
ous positional movement: e.g. add_skips(a eb)
would ambiguously require 1 or 2 skips to supress
the spellout of b, because it creates a disjunction of
the empty string c with skip. It is perhaps worth
emphasizing that there is no special interpretation
whatsoever for these technical arcs: the standard au-
tomaton semantics is unaffected. As a consequence,
skip and repeat will be a visible part of the output
in word form generation and must be allowed in the
input for parsing as well.
Taken together, the three enrichments yield an
automaton for Bambara wu/u, shown in figure 1.a.
While skipping is not necessary for this example,
</bodyText>
<equation confidence="0.716128">
E . . .
</equation>
<footnote confidence="0.703457">
4 4 is: it will host the fixed-melody /o/. The
2This can be seen as an application of the ignore operator
of Kaplan and Kay (1994), where E&apos; is being ignored.
</footnote>
<page confidence="0.987239">
297
</page>
<bodyText confidence="0.988267">
repeat arcs will of course facilitate copying, as we (5) sega skip* sega repeat* seg;isego* segi
shall see in a moment.
</bodyText>
<figureCaption confidence="0.9842825">
Figure 1: Enriched automata for wu/u (a.), Bambara
N-o-N reduplication (b.)
</figureCaption>
<subsectionHeader confidence="0.999937">
3.2 Copying as Intersection
</subsectionHeader>
<bodyText confidence="0.989788203125">
Bird &amp; Ellison (1992) came close to discovering
a useful device for reduplication when they noted
that automaton intersection has at least indexed-
grammar power (ibid., p.48). They demonstrated
their claim by showing that odd-length strings of
indefinite length like the one described by the
regular expression (abcde f g)+ can be repeated
by intersecting them with an automaton accept-
ing only strings of even length: the result is
(a bcdef gabcdef g)±.
Generalizing from their artifical example, let us
first make one additional minor enrichment by tag-
ging the edges of the reduplicative portion of a
base with synchronization bits :1, while using
the opposite value :0 for the interior part (see fig-
ure 1.a). This gives us a segment-independent
handle on those edges and a regular expression
seg:iseg:o*seg:i for the whole synchronized portion
(seg abbreviates the set of phonological segments).
Assuming repeat-enriched bases, a total redupli-
cation morpheme can now be seen as a partial word
specification which mentions two synchronized por-
tions separated by an arbitrary-length move back-
wards:
(4) seg:iseg:0* sega repeat* segAseg,0* seg:i
Moreover, total reduplicative copying now simply
is intersection of the base and (4), or — in the Bam-
bara case — a simple variant that adds the /o/ (figure
1.b). Disregarding self loops for the moment, the
reader may verify that no expansion of the kleene-
starred repeat that traverses less than ibasel seg-
ments will satisfy the demand for two synchronized
portions. Semai requires another slight variant of
(4) which skips the interior of the base in the redu-
plicant:
The identification of copying with intersection not
only allows for great flexibility in describing the full
range of actual reduplicative constructions with reg-
ular expressions, it also reuses the central operation
for constraint combination that is independently re-
quired for one-level morphology and phonology.
Any improvement in efficient implementation of
intersection therefore has immediate benefits for
grammar computation as a whole. In contrast, a
hypothetical setup where a dedicated total copy de-
vice is sandwiched between finite-state transducers
seems much less elegant and may require additional
machinery to detect copies during parsing.
Note that it is in fact possible to compute
reduplication-as-intersection over an entire lexicon
of bases (see figure 3 for an example), provided that
repeat arcs are added individually to each base. En-
riched base FSAs can then be unioned together and
undergo further automaton transformations such as
determinization or minimization. This restriction
is necessary because our finite-state method cannot
express token identity as normally required in string
repetition. Rather than identifying the same token, it
addresses the same string position, using the weaker
notion of type identity. Therefore, application of the
method is only safe if strings are effectively isolated
from one another, which is exactly what per-base
enrichment achieves. See §3.4 for a suggestion on
how to lift the restriction in practice.
</bodyText>
<subsectionHeader confidence="0.992314">
3.3 Resource Consciousness
</subsectionHeader>
<bodyText confidence="0.999778842105263">
One pays a certain price for allowing general repe-
tition and infixation: because of its self loops and
technical arcs, the automaton of figure 1.a over-
generates wildly. Also, during intersection, self
loops can absorb other morphemes in unexpected
ways. A possible diagnosis of the underlying de-
fect is that we need to distinguish between produc-
ers and consumers of information. In analogy to
LFG&apos;s constraint vs constraining equations, infor-
mation may only be consumed if it has been pro-
duced at least once.
For automata, let us spend a P/C bit per arc, with
P/C=1 for producers and P/C=0 for consumer arcs.
In open interpretation mode, then, intersection com-
bines the P/C bits of compatible arcs via logical OR,
making producers dominant. It follows that a re-
source may be multiply consumed, which has obvi-
ous advantages for our application, the multiple re-
alization of string symbols. A final step of closed in-
</bodyText>
<page confidence="0.988448">
298
</page>
<bodyText confidence="0.9779778">
terpretation prunes all consumer-only arcs that sur-
vived constraint interaction, in what may be seen
as intersection with the universal producer language
under logical-AND combination of P/C bits.
Using these resource-conscious notions, we can
now model both the default absence of material and
purely contextual requirements as consumer-type
information: unless satisfied by lexical resources
that have been explicitly produced, the correspond-
ing arcs will not be part of the result. By convention,
producers are displayed in bold. Thus, the exact re-
sult of figure 1.a II 1.b after closed interpretation is:
W:1 a:01;021;0 o repeat&apos; repeat* w u:01:13 u:1
This expression also illustrates that, for parsing,
strings like wu/uowu/u need to be consumer-self-
loop-enriched via a small preprocessing step, be-
cause intersection with the grammar would other-
wise fail due to unmentioned technical arcs such as
repeat. Because our proposal is fully declarative,
parsing then reduces to intersecting the enriched
parse string with the grammar-and-lexicon automa-
ton (whose construction will itself involve intersec-
tion) in closed interpretation mode, followed by a
check for nonemptiness of the result. Whereas the
original parse string was underspecified for mor-
phological categories, the parse result for a realis-
tic morphology system will, in addition to technical
arcs, contain fully specified category arcs in some
predefined linearization order, which can be effi-
ciently retrieved if desired.
</bodyText>
<subsectionHeader confidence="0.816438">
3.4 On-demand Algorithms
</subsectionHeader>
<bodyText confidence="0.999991">
It is clear that the above method is particularly at-
tractive if some of its operations can be performed
online, since a fullform lexicon of productive redu-
plications is clearly undesirable e.g. for Bambara. I
therefore consider briefly questions of efficient im-
plementation of these operations.
Mohri et al. (1998) identify the existence of a
local computation rule as the main precondition3
for a lazy implementation of automaton operations,
i.e. one where results are only computed when
demanded by subsequent operations. Such imple-
mentations are very advantageous when large in-
termediate automata may be constructed but only a
small part of them is visited for any particular in-
put. They show that such a rule exists for composi-
</bodyText>
<footnote confidence="0.517500666666667">
3A second condition is that no state is visited that has not
been discovered from the start state. It is easy to implement (6)
so that this condition is fulfilled as well.
</footnote>
<bodyText confidence="0.8314085">
tion 0, hence also for our operation of intersection
(A 11 B range(identity(A) o identity(B))).
Fortunately, the three enrichment steps all have
local computation rules as well:
</bodyText>
<equation confidence="0.988665">
repeat
q2 —4 qi
skip
Q1 —t Q2
</equation>
<bodyText confidence="0.999915666666667">
The impact of the existence of lazy implementa-
tions for enrichment operations is twofold: we can
(a) now maintain minimized base lexicons for stor-
age efficiency and add enrichments lazily to the cur-
rently pursued string hypothesis only, possibly mod-
ulated by exception diacritics that control when en-
richment should or should not happen.4 And (b),
laziness suffices to make the proposed reduplication
method reasonably time-efficient, despite the larger
number of online operations. Actual benchmarks
from a pilot implementation are reported elsewhere
(Walther, submitted).
</bodyText>
<sectionHeader confidence="0.995972" genericHeader="method">
4 A Worked Example
</sectionHeader>
<bodyText confidence="0.989439555555556">
In this section I show how to implement the Koasati
case from (3) using the FSA Utilities toolbox (van
Noord, 1997). FSA Utilities is a Prolog-based
finite-state toolkit and extendible regular expression
compiler. It is freely available and encourages rapid
prototyping.
Figure 2 displays the regular expression opera-
tors that will be used (italicized operators are mod-
ifications or extensions). The grammar will be pre-
</bodyText>
<equation confidence="0.8866437">
[ empty string
[El, E2 , ,En] concatenation of Ei
{El, E2, ,En) union of Ei
E* Kleene closure
E^ optionality
El &amp; E2 intersection
X --&gt; ( Y Z) monotonic rule
X --+YCX
S complement set of S
Head(arg I, . . . argN) (parametrized)
</equation>
<bodyText confidence="0.340178">
:= Body macro definition
</bodyText>
<figureCaption confidence="0.994591">
Figure 2: Regular expression operators
</figureCaption>
<bodyText confidence="0.9539185">
sented below in a piecewise fashion, with line num-
bers added for easy reference.
</bodyText>
<footnote confidence="0.94091">
4See Walther (submitted) for further details. With determin-
istic automata, the question of how to recover from a wrong
string hypothesis during parsing is not an issue.
</footnote>
<figure confidence="0.987433333333333">
(6) a. q2
b. qi 4 q2
c. q = q -4 q
</figure>
<page confidence="0.996485">
299
</page>
<bodyText confidence="0.999949857142857">
Starting with the definition of stems (line 1), we
add the three enrichments to the bare phonological
string (2). However, the innermost producer-type
string constructed by stringToAutomaton (3) is
intersected with phonological constraints (5,6) that
need to see the string only, minus its enrichments.
This is akin to lexical rule application.
</bodyText>
<figure confidence="0.948464142857143">
1 stem(FirstSeg, String) :=
2 add_repeats(add_skips(add_self_loops(
3 [FirstSeg, stringToAutomaton(String)]
4 &amp; ignore_technical_symbols_in(
5 moraification&amp;mark_first_heavy_syllable
6 &amp; positional_classification)))).
7
8 underspecified_for_voicing(BaseSpec) :=
9 ( producer(BaseSpec &amp; vowel),
10 [producer(h),consumer(skip)] }.
11
12 tahaspin := stem([], &amp;quot;tahaspin&amp;quot;).
13 aklatlin := stem(underspecified_for_
14 voicing(low),&amp;quot;klatlin&amp;quot;).
</figure>
<bodyText confidence="0.998332928571429">
Lines 8-10 capture the V/h alternation that is char-
acteristic for vowel-initial stems under reduplica-
tion, with the vocalic alternant constituting the de-
fault used in isolated pronunciation. In contrast,
the /h/ alternant is concatenated with a consumer-
type skip that requires a producer from elsewhere.
Lines 12-14 define two example stems.
The following constraint (15-18) enriches a
prosodically underspecified string with moras
— abstract units of syllable weight (Hayes,
1995) —, a prerequisite to locating (213-24) and
synchronization-marking (25-31) the first heavy
syllable after which the reduplicative infix will be
inserted.
</bodyText>
<figure confidence="0.968473875">
15 moraification :=
16 ( vowel --&gt; ( mora / sigma )
17 ( consonant --&gt; ( mora / consonant
18 ( consonant --&gt; ( (- mora) / vowel
19
20 first_(X) := [not_contains(X), X].
21 heavy_rime := [consumer(mora),
22 consumer (mora)].
23 heavy_syllable := [consumer(- mora),
24 heavy_rime].
25 mark_first_heavy_syllable :=
26 [first_(heavy_rime)&amp;synced_constituent,
27 synced_constituent].
28 right_synced := [consumer(-&apos;:1&apos;&amp;seg) *,
29 consumer(&apos;:1&apos;&amp;seg)].
30 synced_constituent :=
</figure>
<page confidence="0.98069925">
31 [consumer(&apos;:1&apos;&amp;seg), right_synced].
32 positional_classification :=
33 [consumer(initial),consumer(medial) *,
34 consumer(final)].
</page>
<figure confidence="0.9763842">
A A A
I I I ,
Note that both the constituent before (td a h a 3:1)
A A
I I
</figure>
<bodyText confidence="0.985126266666667">
and after (p:i i n1) the infixation site need to be
marked. Also, it turns out to be useful to classify
base string positions for easy reference in the redu-
plicative morpheme, which motivates lines 32-34.
The main part now is the reduplicative morpheme
itself (35), which looks like a mixture of Bambara
and Semai: the spellout of the base is followed by it-
erated repeats (36) to move back to its synchronized
initial position (37), which — recall /h/ — is required
to be consonantal. The rest of the base is skipped
before insertion of the fixed-melody part /o(o)/ oc-
curs (38, 42-44). Proceeding with the interrupted
realization of the base, we identify its beginning as
a synchronized syllable onset (, mora), followed
by a right-synchronized string (39-40).
</bodyText>
<figure confidence="0.9615222">
35 punctual_aspect_reduplication :=
36 [synced_constituent, producer(repeat)*,
37 consumer(&apos;:1&apos; &amp; initial &amp; consonant),
38 producer(skip) *, fixed_melody,
39 consumer(&apos;:1&apos; &amp; seg &amp; mora),
40 right_synced].
41
42 fixed_melody :=
43 [producer(o &amp; &apos;:1&apos; &amp; medial &amp; mora),
44 producer(o &amp; &apos;:1&apos; &amp; medial &amp; mora)&amp;quot;].
</figure>
<figureCaption confidence="0.9425225">
Finally, some obvious word_level_con-
s traints need to be defined (45-54), before the
central intersection of stem and punctual-aspect
reduplication (57) completes our Koasati fragment:
</figureCaption>
<figure confidence="0.744313230769231">
45 word_level_constraints :=
46 last_segment_is_moraic &amp;
47 last_two_sylls_are_heavy.
48
49 last_segment_is_moraic :=
50 [consumer(sigma) *, consumer(mora)3.
51
52 last_two_sylls_are_heavy :=
53 [consumer(sigma) *,
54 heavy_syllable,heavy_syllable].
55
56 wordform(Stem):=closed_interpretation(
57 word_level_constraints &amp; Stem &amp;
</figure>
<page confidence="0.577753">
58 punctual_aspect_reduplication).
</page>
<bodyText confidence="0.998085666666667">
The result of wordform({tahaspin, aklatlin})
is shown in figure 3 ( [ and ] are aliases for initial
and final position).
Space precludes the description of a final automa-
ton operation called Bounded Local Optimization
(Walther, 1999) that turns out to be useful here to
</bodyText>
<figure confidence="0.976383936170213">
)&amp;
300
a_mora :0
0
0 0
s_mora_ 1
(I) 0 repeat (I)
0 repeat re eat
re
eat
repeat
o_mora_:0
i_mora_:
skip
skip
41)
o_mora_.
skip
1:0
.0
_II10
o_mora_:0
skip
S.
re
at
repeat
s p
mora :0
rt:1
0
0
a_mora_:1
0
k_mora_:1
OS
ARk AD. skip
s P
o_mcfralP:oc&apos;
kip
repeat
0
t_mora_:0
p:1
(h_mora_:1
repeat
0 OS
</figure>
<figureCaption confidence="0.999926">
Figure 3: Koasati reduplications tahas-too-pin, ak-ho(o)-latlin
</figureCaption>
<bodyText confidence="0.999964857142857">
ban unattested free length variation, as found e.g.
in ak-ho(o)-latlin where the length of o is yet to
be determined. Suffice to say that a parametriza-
tion of Bounded Local Optimization would prune
the moraic arc 16 -4 19 in figure 3 by considering it
costlier than the non-moraic arc 16 -4 18, thereby
eliminating the last source of indeterminacy.
</bodyText>
<sectionHeader confidence="0.999348" genericHeader="conclusions">
5 Conclusion
</sectionHeader>
<bodyText confidence="0.9999655">
This paper has presented a novel finite-state method
for reduplication that is applicable for both un-
bounded total cases, truncated or otherwise phono-
logically modified types and infixing instances. The
key ingredients of the proposal are suitably en-
riched automaton representations, the identification
of reduplicative copying with automaton intersec-
tion and a resource-conscious interpretation that
differentiates between two types of arc symbols,
namely producers and consumers of information.
After demonstrating the existence of efficient on-
demand algorithms to reduplication&apos;s central oper-
ations, a case study from Koasati has shown that
all of the above ingredients may be necessary in the
analysis of a single complex piece of prosodic mor-
phology.
It is worth mentioning that our method can be
transferred into a two-level transducer setting with-
out major difficulties (Walther, 1999, appendix B).
I conclude that the one-level approach to redu-
plicative prosodic morphology presents an attractive
way of extending finite-state techniques to difficult
phenomena that hitherto resisted elegant computa-
tional analyses.
</bodyText>
<sectionHeader confidence="0.999023" genericHeader="acknowledgments">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.99979375">
The research in this paper has been funded by
the German research agency DFG under grant WI
853/4-1. Particular thanks go to the anonymous re-
viewers for very useful comments.
</bodyText>
<sectionHeader confidence="0.995062" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.71346548">
Kenneth R. Beesley. 1996. Arabic finite-state mor-
phological analysis and generation. In Proceed-
ings of COLING-96, volume I, pages 89-94.
Kenneth R. Beesley. 1998. Constraining separated
morphotactic dependencies in finite-state gram-
mars. In Proceedings of FSMNLP&apos;98, Bilkent
University, Turkey.
Anja Belz. 1998. Discovering phonotactic finite-
state automata by genetic search. In Proceedings
of COLING-ACL &apos;98, volume II, pages 1472-74.
Steven Bird and T. Mark Ellison. 1992. One-Level
Phonology: Autosegmental representations and
rules as finite-state automata. Technical report,
Centre for Cognitive Science, University of Ed-
inburgh. EUCCS/RP-51.
Steven Bird and T. Mark Ellison. 1994. One-
Level Phonology. Computational Linguistics,
20(1):55-90.
Chris Culy. 1985. The complexity of the vocab-
ulary of Bambara. Linguistics and Philosophy,
8:345-351.
T. Mark Ellison. 1992. Machine Learning of
Phonological Representations. Ph.D. thesis,
University of Western Australia, Perth.
Bruce Hayes. 1995. Metrical stress theory: prin-
</reference>
<page confidence="0.984295">
301
</page>
<reference confidence="0.999082813953488">
ciples and case studies. University of Chicago
Press.
Sean Hendricks. 1998. Reduplication without
prosodic templates: A case from Semai. Handout
from talk given at LSA annual meeting, January
Ron Kaplan and Martin Kay. 1994. Regular mod-
els of phonological rule systems. Computational
Linguistics, 20(3): 331-78.
Geoffrey Kimball. 1988. Koasati reduplication. In
W. Shipley, editor, In honour of Mary Haas:
from the Haas Festival Conference on Native
American Linguistics, pages 431-42. Mouton de
Gruyter, Berlin.
George Anton Kiraz. 1994. Multi-tape two-level
morphology: a case study in Semitic nonlinear
morphology. In Proceedings of COLING &apos;94,
volume 1, pages 180-186.
Kimmo Koskenniemi. 1983. Two-Level Morphol-
ogy: A General Computational Model for Word-
Form Recognition and Production. Ph.D. thesis,
University of Helsinki.
Mehryar Mohri, Fernando Pereira, and Michael Ri-
ley. 1998. A rational design for a weighted finite-
state transducer library. In D. Wood and S. Yu,
editors, Automata Implementation. Second Inter-
national Workshop on implementing Automata,
WIA &apos;97, volume 1436 of Lecture Notes in Com-
puter Science, pages 144-58. Springer Verlag.
Richard Sproat. 1992. Morphology and Computa-
tion. MIT Press, Cambridge, Mass.
Gertjan van Noord. 1997. FSA Utilities: A
toolbox to manipulate finite-state automata. In
Darrell Raymond, Derrick Wood, and Sheng
Yu, editors, Automata Implementation, volume
1260 of Lecture Notes in Computer Science,
pages 87-108. Springer Verlag. (Software under
http://grid.let.rug.n1/,...,vannoord/Fsa4
Markus Walther. 1999. One-Level Prosodic Mor-
phology. Marburger Arbeiten zur Linguistik 1,
University of Marburg. 64 pp.
(http://www.uni-marburg.de/linguistik/mal).
Markus Walther. submitted. On finite-state redupli-
cation. In COLING-2000.
</reference>
<page confidence="0.998722">
302
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.569124">
<title confidence="0.999735">Finite-State Reduplication in One-Level Prosodic Morphology</title>
<author confidence="0.999982">Markus Walther</author>
<affiliation confidence="0.999989">University of Marburg</affiliation>
<address confidence="0.99799">FB09/IGS, Wilhelm-Ropke-Str. 6A, D-35032 Marburg, Germany</address>
<abstract confidence="0.935299">Reduplication, a central instance of prosodic morphology, is particularly challenging for state-ofthe-art computational morphology, since it involves copying of some part of a phonological string. In this paper I advocate a finite-state method that combines enriched lexical representations via intersection to implement the copying. The proposal includes a resource-conscious variant of automata and can benefit from the existence of lazy algorithms. Finally, the implementation of a complex case from Koasati is presented.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Kenneth R Beesley</author>
</authors>
<title>Arabic finite-state morphological analysis and generation.</title>
<date>1996</date>
<booktitle>In Proceedings of COLING-96, volume I,</booktitle>
<pages>89--94</pages>
<contexts>
<context position="1175" citStr="Beesley (1996)" startWordPosition="155" endWordPosition="156">source-conscious variant of automata and can benefit from the existence of lazy algorithms. Finally, the implementation of a complex case from Koasati is presented. 1 Introduction In the past two decades computational morphology has been quite successful in dealing with the challenges posed by natural language word patterns. Using finite-state methods, it has been possible to describe both word formation and the concomitant phonological modifications in many languages, ranging from straightforward concatenative combination (Koskenniemi, 1983) over Semitic-style nonconcatenative intercalation (Beesley (1996), Kiraz (1994)) to circumfixional long-distance dependencies (Beesley, 1998). However, Sproat (1992) observes that, despite the existence of &amp;quot;working systems that are capable of doing a great deal of morphological analysis&amp;quot;, &amp;quot;there are still outstanding problems and areas which have not received much serious attention&amp;quot; (ibid., 123). Problem areas in his view include subtractive morphology, infixation, the proper inclusion of prosodic structure and, in particular, reduplication: &amp;quot;From a computational point of view, one point cannot be overstressed: the copying required in reduplication places r</context>
</contexts>
<marker>Beesley, 1996</marker>
<rawString>Kenneth R. Beesley. 1996. Arabic finite-state morphological analysis and generation. In Proceedings of COLING-96, volume I, pages 89-94.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth R Beesley</author>
</authors>
<title>Constraining separated morphotactic dependencies in finite-state grammars.</title>
<date>1998</date>
<booktitle>In Proceedings of FSMNLP&apos;98,</booktitle>
<institution>Bilkent University, Turkey.</institution>
<contexts>
<context position="1251" citStr="Beesley, 1998" startWordPosition="164" endWordPosition="165">azy algorithms. Finally, the implementation of a complex case from Koasati is presented. 1 Introduction In the past two decades computational morphology has been quite successful in dealing with the challenges posed by natural language word patterns. Using finite-state methods, it has been possible to describe both word formation and the concomitant phonological modifications in many languages, ranging from straightforward concatenative combination (Koskenniemi, 1983) over Semitic-style nonconcatenative intercalation (Beesley (1996), Kiraz (1994)) to circumfixional long-distance dependencies (Beesley, 1998). However, Sproat (1992) observes that, despite the existence of &amp;quot;working systems that are capable of doing a great deal of morphological analysis&amp;quot;, &amp;quot;there are still outstanding problems and areas which have not received much serious attention&amp;quot; (ibid., 123). Problem areas in his view include subtractive morphology, infixation, the proper inclusion of prosodic structure and, in particular, reduplication: &amp;quot;From a computational point of view, one point cannot be overstressed: the copying required in reduplication places reduplication in a class apart from all other morphology.&amp;quot; (ibid., 60). Produ</context>
</contexts>
<marker>Beesley, 1998</marker>
<rawString>Kenneth R. Beesley. 1998. Constraining separated morphotactic dependencies in finite-state grammars. In Proceedings of FSMNLP&apos;98, Bilkent University, Turkey.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Anja Belz</author>
</authors>
<title>Discovering phonotactic finitestate automata by genetic search.</title>
<date>1998</date>
<booktitle>In Proceedings of COLING-ACL &apos;98,</booktitle>
<volume>volume II,</volume>
<pages>1472--74</pages>
<contexts>
<context position="2858" citStr="Belz (1998)" startWordPosition="403" endWordPosition="404">rd &amp; Ellison (1994)&apos;s One-Level Phonology, a monostratal constraintbased framework where phonological representations, morphemes and generalizations are all finitestate automata (FSAs) and constraint combination is accomplished via automata intersection. While it is possible to transfer much of the present proposal to the transducer-based setting that is often preferred nowadays, the monostratal approach still offers an attractive alternative due to its easy blend with monostratal grammars such as HPSG and the good prospects for machine learning of its surfacetrue constraints (Ellison (1992), Belz (1998)). After a brief survey of important kinds of reduplication in §2, section §3 explains the necessary extensions of One-Level Phonology to deal with the challenges presented by reduplication, within the larger domain of prosodic morphology in general. A worked-out example from Koasati in §4 illustrates the interplay of the various components in an implemented analysis, before some conclusions are drawn in section §5. 2 Reduplication A well-known case from the context-sensitivity debate of the eighties is the N-o-N reduplicative construction from Bambara (Northwestern Mande, (Culy, 1985)): (1) a</context>
</contexts>
<marker>Belz, 1998</marker>
<rawString>Anja Belz. 1998. Discovering phonotactic finitestate automata by genetic search. In Proceedings of COLING-ACL &apos;98, volume II, pages 1472-74.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Steven Bird</author>
<author>T Mark Ellison</author>
</authors>
<title>One-Level Phonology: Autosegmental representations and rules as finite-state automata.</title>
<date>1992</date>
<tech>Technical report,</tech>
<institution>Centre for Cognitive Science, University of Edinburgh.</institution>
<contexts>
<context position="8327" citStr="Bird &amp; Ellison (1992)" startWordPosition="1276" endWordPosition="1279">tion and must be allowed in the input for parsing as well. Taken together, the three enrichments yield an automaton for Bambara wu/u, shown in figure 1.a. While skipping is not necessary for this example, E . . . 4 4 is: it will host the fixed-melody /o/. The 2This can be seen as an application of the ignore operator of Kaplan and Kay (1994), where E&apos; is being ignored. 297 repeat arcs will of course facilitate copying, as we (5) sega skip* sega repeat* seg;isego* segi shall see in a moment. Figure 1: Enriched automata for wu/u (a.), Bambara N-o-N reduplication (b.) 3.2 Copying as Intersection Bird &amp; Ellison (1992) came close to discovering a useful device for reduplication when they noted that automaton intersection has at least indexedgrammar power (ibid., p.48). They demonstrated their claim by showing that odd-length strings of indefinite length like the one described by the regular expression (abcde f g)+ can be repeated by intersecting them with an automaton accepting only strings of even length: the result is (a bcdef gabcdef g)±. Generalizing from their artifical example, let us first make one additional minor enrichment by tagging the edges of the reduplicative portion of a base with synchroniz</context>
</contexts>
<marker>Bird, Ellison, 1992</marker>
<rawString>Steven Bird and T. Mark Ellison. 1992. One-Level Phonology: Autosegmental representations and rules as finite-state automata. Technical report, Centre for Cognitive Science, University of Edinburgh. EUCCS/RP-51.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Steven Bird</author>
<author>T Mark Ellison</author>
</authors>
<date>1994</date>
<booktitle>OneLevel Phonology. Computational Linguistics,</booktitle>
<pages>20--1</pages>
<contexts>
<context position="2266" citStr="Bird &amp; Ellison (1994)" startWordPosition="317" endWordPosition="320">duplication: &amp;quot;From a computational point of view, one point cannot be overstressed: the copying required in reduplication places reduplication in a class apart from all other morphology.&amp;quot; (ibid., 60). Productive reduplication is so troublesome for a formal account based on regular languages (or regular relations) because unbounded total instances like Indonesian noun plural (orang-orang &apos;men&apos;) are isomorphic to the copy language ww, which is context-sensitive. In the rest of this paper I will lay out a proposal for handling reduplication with finite-state methods. As a starting point, I adopt Bird &amp; Ellison (1994)&apos;s One-Level Phonology, a monostratal constraintbased framework where phonological representations, morphemes and generalizations are all finitestate automata (FSAs) and constraint combination is accomplished via automata intersection. While it is possible to transfer much of the present proposal to the transducer-based setting that is often preferred nowadays, the monostratal approach still offers an attractive alternative due to its easy blend with monostratal grammars such as HPSG and the good prospects for machine learning of its surfacetrue constraints (Ellison (1992), Belz (1998)). After</context>
</contexts>
<marker>Bird, Ellison, 1994</marker>
<rawString>Steven Bird and T. Mark Ellison. 1994. OneLevel Phonology. Computational Linguistics, 20(1):55-90.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Chris Culy</author>
</authors>
<title>The complexity of the vocabulary of Bambara. Linguistics and Philosophy,</title>
<date>1985</date>
<pages>8--345</pages>
<contexts>
<context position="3450" citStr="Culy, 1985" startWordPosition="492" endWordPosition="493">(1992), Belz (1998)). After a brief survey of important kinds of reduplication in §2, section §3 explains the necessary extensions of One-Level Phonology to deal with the challenges presented by reduplication, within the larger domain of prosodic morphology in general. A worked-out example from Koasati in §4 illustrates the interplay of the various components in an implemented analysis, before some conclusions are drawn in section §5. 2 Reduplication A well-known case from the context-sensitivity debate of the eighties is the N-o-N reduplicative construction from Bambara (Northwestern Mande, (Culy, 1985)): (1) a. wulu-o-wulu &apos;whichever dog&apos; b. wulunyinina-o-wulunyinina &apos;whichever dog searcher&apos; c. wulunyininafilela-o-wulunyininafilela &apos;whoever watches dog searchers&apos; Beyond total copying, (1) also illustrates the possibility of so-called fixed-melody parts in redupli296 cation: a constant /o/ intervenes between base (i.e. original) and reduplicant (i.e. copied part, in bold print). I The next case from Semai expressive minor reduplication (Mon-Khmer, Hendricks (1998)) highlights the possibility of an interaction between reduplication and internal truncation: (2) a. c?c:t et-chit &apos;sweet&apos; b. drja</context>
<context position="5409" citStr="Culy (1985)" startWordPosition="789" endWordPosition="790">ied: the /h/ in the copied part of (3).c,d is best analysed as a voiceless vowel, i.e. the phonetically closest consonantal expression of its source. Moreover, the locus of the infixed reduplicant is predictable on prosodic grounds, as it is inserted after the first heavy syllable of the base. Heavy syllables in Koasati are long (C)VV or closed (C)VC. Prosodic influence is also responsible for the length alternation of its fixed-melody part /o(o)/, since the heaviness requirement for the penultimate, stressed, syllable of the word causes long Rid if the reduplicant constitutes that syllable. tCuly (1985), who presents a superset of the data under (1) in the context of a formal proof of context-sensitivity, shows that the reduplicative construction in fact can copy the outcome of a recursive agentive construction, thereby becoming truly unbounded. He emphasizes the fact that it is &amp;quot;very productive, with few, if any restrictions on the choice of the noun&amp;quot; (p.346). 3 Finite-State Methods The present proposal differs from the state-labelled automata employed in One-Level Phonology by returning to conventional arc-labelled ones, but shares the idea that labels denote sets, which is advantageous fo</context>
</contexts>
<marker>Culy, 1985</marker>
<rawString>Chris Culy. 1985. The complexity of the vocabulary of Bambara. Linguistics and Philosophy, 8:345-351.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Mark Ellison</author>
</authors>
<title>Machine Learning of Phonological Representations.</title>
<date>1992</date>
<tech>Ph.D. thesis,</tech>
<institution>University of Western Australia,</institution>
<location>Perth.</location>
<contexts>
<context position="2845" citStr="Ellison (1992)" startWordPosition="401" endWordPosition="402">oint, I adopt Bird &amp; Ellison (1994)&apos;s One-Level Phonology, a monostratal constraintbased framework where phonological representations, morphemes and generalizations are all finitestate automata (FSAs) and constraint combination is accomplished via automata intersection. While it is possible to transfer much of the present proposal to the transducer-based setting that is often preferred nowadays, the monostratal approach still offers an attractive alternative due to its easy blend with monostratal grammars such as HPSG and the good prospects for machine learning of its surfacetrue constraints (Ellison (1992), Belz (1998)). After a brief survey of important kinds of reduplication in §2, section §3 explains the necessary extensions of One-Level Phonology to deal with the challenges presented by reduplication, within the larger domain of prosodic morphology in general. A worked-out example from Koasati in §4 illustrates the interplay of the various components in an implemented analysis, before some conclusions are drawn in section §5. 2 Reduplication A well-known case from the context-sensitivity debate of the eighties is the N-o-N reduplicative construction from Bambara (Northwestern Mande, (Culy, </context>
<context position="8327" citStr="Ellison (1992)" startWordPosition="1278" endWordPosition="1279">d must be allowed in the input for parsing as well. Taken together, the three enrichments yield an automaton for Bambara wu/u, shown in figure 1.a. While skipping is not necessary for this example, E . . . 4 4 is: it will host the fixed-melody /o/. The 2This can be seen as an application of the ignore operator of Kaplan and Kay (1994), where E&apos; is being ignored. 297 repeat arcs will of course facilitate copying, as we (5) sega skip* sega repeat* seg;isego* segi shall see in a moment. Figure 1: Enriched automata for wu/u (a.), Bambara N-o-N reduplication (b.) 3.2 Copying as Intersection Bird &amp; Ellison (1992) came close to discovering a useful device for reduplication when they noted that automaton intersection has at least indexedgrammar power (ibid., p.48). They demonstrated their claim by showing that odd-length strings of indefinite length like the one described by the regular expression (abcde f g)+ can be repeated by intersecting them with an automaton accepting only strings of even length: the result is (a bcdef gabcdef g)±. Generalizing from their artifical example, let us first make one additional minor enrichment by tagging the edges of the reduplicative portion of a base with synchroniz</context>
</contexts>
<marker>Ellison, 1992</marker>
<rawString>T. Mark Ellison. 1992. Machine Learning of Phonological Representations. Ph.D. thesis, University of Western Australia, Perth.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bruce Hayes</author>
</authors>
<title>Metrical stress theory: principles and case studies.</title>
<date>1995</date>
<publisher>University of Chicago Press.</publisher>
<contexts>
<context position="17813" citStr="Hayes, 1995" startWordPosition="2742" endWordPosition="2743">(h),consumer(skip)] }. 11 12 tahaspin := stem([], &amp;quot;tahaspin&amp;quot;). 13 aklatlin := stem(underspecified_for_ 14 voicing(low),&amp;quot;klatlin&amp;quot;). Lines 8-10 capture the V/h alternation that is characteristic for vowel-initial stems under reduplication, with the vocalic alternant constituting the default used in isolated pronunciation. In contrast, the /h/ alternant is concatenated with a consumertype skip that requires a producer from elsewhere. Lines 12-14 define two example stems. The following constraint (15-18) enriches a prosodically underspecified string with moras — abstract units of syllable weight (Hayes, 1995) —, a prerequisite to locating (213-24) and synchronization-marking (25-31) the first heavy syllable after which the reduplicative infix will be inserted. 15 moraification := 16 ( vowel --&gt; ( mora / sigma ) 17 ( consonant --&gt; ( mora / consonant 18 ( consonant --&gt; ( (- mora) / vowel 19 20 first_(X) := [not_contains(X), X]. 21 heavy_rime := [consumer(mora), 22 consumer (mora)]. 23 heavy_syllable := [consumer(- mora), 24 heavy_rime]. 25 mark_first_heavy_syllable := 26 [first_(heavy_rime)&amp;synced_constituent, 27 synced_constituent]. 28 right_synced := [consumer(-&apos;:1&apos;&amp;seg) *, 29 consumer(&apos;:1&apos;&amp;seg)].</context>
</contexts>
<marker>Hayes, 1995</marker>
<rawString>Bruce Hayes. 1995. Metrical stress theory: principles and case studies. University of Chicago Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Sean Hendricks</author>
</authors>
<title>Reduplication without prosodic templates: A case from Semai. Handout from talk given at LSA annual meeting,</title>
<date>1998</date>
<contexts>
<context position="3920" citStr="Hendricks (1998)" startWordPosition="554" endWordPosition="555">wn case from the context-sensitivity debate of the eighties is the N-o-N reduplicative construction from Bambara (Northwestern Mande, (Culy, 1985)): (1) a. wulu-o-wulu &apos;whichever dog&apos; b. wulunyinina-o-wulunyinina &apos;whichever dog searcher&apos; c. wulunyininafilela-o-wulunyininafilela &apos;whoever watches dog searchers&apos; Beyond total copying, (1) also illustrates the possibility of so-called fixed-melody parts in redupli296 cation: a constant /o/ intervenes between base (i.e. original) and reduplicant (i.e. copied part, in bold print). I The next case from Semai expressive minor reduplication (Mon-Khmer, Hendricks (1998)) highlights the possibility of an interaction between reduplication and internal truncation: (2) a. c?c:t et-chit &apos;sweet&apos; b. drjah dh-drph &apos;appearance of nodding constantly&apos; c. cfail cl-cfail &apos;appearance of flickering red object&apos; Reduplication copies the initial and final segment of the base, skipping all of its interior segments, which may be of arbitrary length. A final case comes from Koasati punctual-aspect reduplication (Muscogean, (Kimball, 1988)): (3) a. ta.has.pin tiahas-t16:-pin &apos;to be light in weight&apos; b. la.pat.kin 11 apat-I16: -kin &apos;to be narrow c. ak.lát.lin al k-hi &apos;to be loose&apos; </context>
</contexts>
<marker>Hendricks, 1998</marker>
<rawString>Sean Hendricks. 1998. Reduplication without prosodic templates: A case from Semai. Handout from talk given at LSA annual meeting, January</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ron Kaplan</author>
<author>Martin Kay</author>
</authors>
<title>Regular models of phonological rule systems.</title>
<date>1994</date>
<journal>Computational Linguistics,</journal>
<volume>20</volume>
<issue>3</issue>
<pages>331--78</pages>
<contexts>
<context position="8049" citStr="Kaplan and Kay (1994)" startWordPosition="1230" endWordPosition="1233"> the empty string c with skip. It is perhaps worth emphasizing that there is no special interpretation whatsoever for these technical arcs: the standard automaton semantics is unaffected. As a consequence, skip and repeat will be a visible part of the output in word form generation and must be allowed in the input for parsing as well. Taken together, the three enrichments yield an automaton for Bambara wu/u, shown in figure 1.a. While skipping is not necessary for this example, E . . . 4 4 is: it will host the fixed-melody /o/. The 2This can be seen as an application of the ignore operator of Kaplan and Kay (1994), where E&apos; is being ignored. 297 repeat arcs will of course facilitate copying, as we (5) sega skip* sega repeat* seg;isego* segi shall see in a moment. Figure 1: Enriched automata for wu/u (a.), Bambara N-o-N reduplication (b.) 3.2 Copying as Intersection Bird &amp; Ellison (1992) came close to discovering a useful device for reduplication when they noted that automaton intersection has at least indexedgrammar power (ibid., p.48). They demonstrated their claim by showing that odd-length strings of indefinite length like the one described by the regular expression (abcde f g)+ can be repeated by i</context>
</contexts>
<marker>Kaplan, Kay, 1994</marker>
<rawString>Ron Kaplan and Martin Kay. 1994. Regular models of phonological rule systems. Computational Linguistics, 20(3): 331-78.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Geoffrey Kimball</author>
</authors>
<title>Koasati reduplication.</title>
<date>1988</date>
<booktitle>In honour of Mary Haas: from the Haas Festival Conference on Native American Linguistics,</booktitle>
<pages>431--42</pages>
<editor>In W. Shipley, editor,</editor>
<location>Berlin.</location>
<contexts>
<context position="4377" citStr="Kimball, 1988" startWordPosition="622" endWordPosition="623">ase (i.e. original) and reduplicant (i.e. copied part, in bold print). I The next case from Semai expressive minor reduplication (Mon-Khmer, Hendricks (1998)) highlights the possibility of an interaction between reduplication and internal truncation: (2) a. c?c:t et-chit &apos;sweet&apos; b. drjah dh-drph &apos;appearance of nodding constantly&apos; c. cfail cl-cfail &apos;appearance of flickering red object&apos; Reduplication copies the initial and final segment of the base, skipping all of its interior segments, which may be of arbitrary length. A final case comes from Koasati punctual-aspect reduplication (Muscogean, (Kimball, 1988)): (3) a. ta.has.pin tiahas-t16:-pin &apos;to be light in weight&apos; b. la.pat.kin 11 apat-I16: -kin &apos;to be narrow c. ak.lát.lin al k-hi &apos;to be loose&apos; d. ok.cak.kon o-caldcon &apos;to be green or blue&apos; Koasati is particularly interesting, because it shows that copy and original need not always be adjacent — here the reduplicant is infixed into its own base — and also because it illustrates that the copy may be phonologically modified: the /h/ in the copied part of (3).c,d is best analysed as a voiceless vowel, i.e. the phonetically closest consonantal expression of its source. Moreover, the locus of the in</context>
</contexts>
<marker>Kimball, 1988</marker>
<rawString>Geoffrey Kimball. 1988. Koasati reduplication. In W. Shipley, editor, In honour of Mary Haas: from the Haas Festival Conference on Native American Linguistics, pages 431-42. Mouton de Gruyter, Berlin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>George Anton Kiraz</author>
</authors>
<title>Multi-tape two-level morphology: a case study in Semitic nonlinear morphology.</title>
<date>1994</date>
<booktitle>In Proceedings of COLING &apos;94,</booktitle>
<volume>1</volume>
<pages>180--186</pages>
<contexts>
<context position="1189" citStr="Kiraz (1994)" startWordPosition="157" endWordPosition="158"> variant of automata and can benefit from the existence of lazy algorithms. Finally, the implementation of a complex case from Koasati is presented. 1 Introduction In the past two decades computational morphology has been quite successful in dealing with the challenges posed by natural language word patterns. Using finite-state methods, it has been possible to describe both word formation and the concomitant phonological modifications in many languages, ranging from straightforward concatenative combination (Koskenniemi, 1983) over Semitic-style nonconcatenative intercalation (Beesley (1996), Kiraz (1994)) to circumfixional long-distance dependencies (Beesley, 1998). However, Sproat (1992) observes that, despite the existence of &amp;quot;working systems that are capable of doing a great deal of morphological analysis&amp;quot;, &amp;quot;there are still outstanding problems and areas which have not received much serious attention&amp;quot; (ibid., 123). Problem areas in his view include subtractive morphology, infixation, the proper inclusion of prosodic structure and, in particular, reduplication: &amp;quot;From a computational point of view, one point cannot be overstressed: the copying required in reduplication places reduplication i</context>
</contexts>
<marker>Kiraz, 1994</marker>
<rawString>George Anton Kiraz. 1994. Multi-tape two-level morphology: a case study in Semitic nonlinear morphology. In Proceedings of COLING &apos;94, volume 1, pages 180-186.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kimmo Koskenniemi</author>
</authors>
<title>Two-Level Morphology: A General Computational Model for WordForm Recognition and Production.</title>
<date>1983</date>
<tech>Ph.D. thesis,</tech>
<institution>University of Helsinki.</institution>
<contexts>
<context position="1109" citStr="Koskenniemi, 1983" startWordPosition="148" endWordPosition="149"> via intersection to implement the copying. The proposal includes a resource-conscious variant of automata and can benefit from the existence of lazy algorithms. Finally, the implementation of a complex case from Koasati is presented. 1 Introduction In the past two decades computational morphology has been quite successful in dealing with the challenges posed by natural language word patterns. Using finite-state methods, it has been possible to describe both word formation and the concomitant phonological modifications in many languages, ranging from straightforward concatenative combination (Koskenniemi, 1983) over Semitic-style nonconcatenative intercalation (Beesley (1996), Kiraz (1994)) to circumfixional long-distance dependencies (Beesley, 1998). However, Sproat (1992) observes that, despite the existence of &amp;quot;working systems that are capable of doing a great deal of morphological analysis&amp;quot;, &amp;quot;there are still outstanding problems and areas which have not received much serious attention&amp;quot; (ibid., 123). Problem areas in his view include subtractive morphology, infixation, the proper inclusion of prosodic structure and, in particular, reduplication: &amp;quot;From a computational point of view, one point cann</context>
</contexts>
<marker>Koskenniemi, 1983</marker>
<rawString>Kimmo Koskenniemi. 1983. Two-Level Morphology: A General Computational Model for WordForm Recognition and Production. Ph.D. thesis, University of Helsinki.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mehryar Mohri</author>
<author>Fernando Pereira</author>
<author>Michael Riley</author>
</authors>
<title>A rational design for a weighted finitestate transducer library.</title>
<date>1998</date>
<booktitle>Automata Implementation. Second International Workshop on implementing Automata, WIA &apos;97,</booktitle>
<volume>1436</volume>
<pages>144--58</pages>
<editor>In D. Wood and S. Yu, editors,</editor>
<publisher>Springer Verlag.</publisher>
<contexts>
<context position="14160" citStr="Mohri et al. (1998)" startWordPosition="2179" endWordPosition="2182">inal parse string was underspecified for morphological categories, the parse result for a realistic morphology system will, in addition to technical arcs, contain fully specified category arcs in some predefined linearization order, which can be efficiently retrieved if desired. 3.4 On-demand Algorithms It is clear that the above method is particularly attractive if some of its operations can be performed online, since a fullform lexicon of productive reduplications is clearly undesirable e.g. for Bambara. I therefore consider briefly questions of efficient implementation of these operations. Mohri et al. (1998) identify the existence of a local computation rule as the main precondition3 for a lazy implementation of automaton operations, i.e. one where results are only computed when demanded by subsequent operations. Such implementations are very advantageous when large intermediate automata may be constructed but only a small part of them is visited for any particular input. They show that such a rule exists for composi3A second condition is that no state is visited that has not been discovered from the start state. It is easy to implement (6) so that this condition is fulfilled as well. tion 0, hen</context>
</contexts>
<marker>Mohri, Pereira, Riley, 1998</marker>
<rawString>Mehryar Mohri, Fernando Pereira, and Michael Riley. 1998. A rational design for a weighted finitestate transducer library. In D. Wood and S. Yu, editors, Automata Implementation. Second International Workshop on implementing Automata, WIA &apos;97, volume 1436 of Lecture Notes in Computer Science, pages 144-58. Springer Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Richard Sproat</author>
</authors>
<title>Morphology and Computation.</title>
<date>1992</date>
<publisher>MIT Press,</publisher>
<location>Cambridge, Mass.</location>
<contexts>
<context position="1275" citStr="Sproat (1992)" startWordPosition="167" endWordPosition="168">the implementation of a complex case from Koasati is presented. 1 Introduction In the past two decades computational morphology has been quite successful in dealing with the challenges posed by natural language word patterns. Using finite-state methods, it has been possible to describe both word formation and the concomitant phonological modifications in many languages, ranging from straightforward concatenative combination (Koskenniemi, 1983) over Semitic-style nonconcatenative intercalation (Beesley (1996), Kiraz (1994)) to circumfixional long-distance dependencies (Beesley, 1998). However, Sproat (1992) observes that, despite the existence of &amp;quot;working systems that are capable of doing a great deal of morphological analysis&amp;quot;, &amp;quot;there are still outstanding problems and areas which have not received much serious attention&amp;quot; (ibid., 123). Problem areas in his view include subtractive morphology, infixation, the proper inclusion of prosodic structure and, in particular, reduplication: &amp;quot;From a computational point of view, one point cannot be overstressed: the copying required in reduplication places reduplication in a class apart from all other morphology.&amp;quot; (ibid., 60). Productive reduplication is s</context>
</contexts>
<marker>Sproat, 1992</marker>
<rawString>Richard Sproat. 1992. Morphology and Computation. MIT Press, Cambridge, Mass.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gertjan van Noord</author>
</authors>
<title>FSA Utilities: A toolbox to manipulate finite-state automata.</title>
<date>1997</date>
<booktitle>Automata Implementation,</booktitle>
<volume>1260</volume>
<pages>87--108</pages>
<editor>In Darrell Raymond, Derrick Wood, and Sheng Yu, editors,</editor>
<publisher>Springer Verlag. (Software</publisher>
<note>under http://grid.let.rug.n1/,...,vannoord/Fsa4</note>
<marker>van Noord, 1997</marker>
<rawString>Gertjan van Noord. 1997. FSA Utilities: A toolbox to manipulate finite-state automata. In Darrell Raymond, Derrick Wood, and Sheng Yu, editors, Automata Implementation, volume 1260 of Lecture Notes in Computer Science, pages 87-108. Springer Verlag. (Software under http://grid.let.rug.n1/,...,vannoord/Fsa4</rawString>
</citation>
<citation valid="true">
<authors>
<author>Markus Walther</author>
</authors>
<title>One-Level Prosodic Morphology. Marburger Arbeiten zur Linguistik 1,</title>
<date>1999</date>
<journal>University of Marburg.</journal>
<volume>64</volume>
<pages>pp. (http://www.uni-marburg.de/linguistik/mal).</pages>
<contexts>
<context position="20500" citStr="Walther, 1999" startWordPosition="3132" endWordPosition="3133">asati fragment: 45 word_level_constraints := 46 last_segment_is_moraic &amp; 47 last_two_sylls_are_heavy. 48 49 last_segment_is_moraic := 50 [consumer(sigma) *, consumer(mora)3. 51 52 last_two_sylls_are_heavy := 53 [consumer(sigma) *, 54 heavy_syllable,heavy_syllable]. 55 56 wordform(Stem):=closed_interpretation( 57 word_level_constraints &amp; Stem &amp; 58 punctual_aspect_reduplication). The result of wordform({tahaspin, aklatlin}) is shown in figure 3 ( [ and ] are aliases for initial and final position). Space precludes the description of a final automaton operation called Bounded Local Optimization (Walther, 1999) that turns out to be useful here to )&amp; 300 a_mora :0 0 0 0 s_mora_ 1 (I) 0 repeat (I) 0 repeat re eat re eat repeat o_mora_:0 i_mora_: skip skip 41) o_mora_. skip 1:0 .0 _II10 o_mora_:0 skip S. re at repeat s p mora :0 rt:1 0 0 a_mora_:1 0 k_mora_:1 OS ARk AD. skip s P o_mcfralP:oc&apos; kip repeat 0 t_mora_:0 p:1 (h_mora_:1 repeat 0 OS Figure 3: Koasati reduplications tahas-too-pin, ak-ho(o)-latlin ban unattested free length variation, as found e.g. in ak-ho(o)-latlin where the length of o is yet to be determined. Suffice to say that a parametrization of Bounded Local Optimization would prune the</context>
</contexts>
<marker>Walther, 1999</marker>
<rawString>Markus Walther. 1999. One-Level Prosodic Morphology. Marburger Arbeiten zur Linguistik 1, University of Marburg. 64 pp. (http://www.uni-marburg.de/linguistik/mal).</rawString>
</citation>
<citation valid="false">
<authors>
<author>submitted</author>
</authors>
<title>On finite-state reduplication.</title>
<booktitle>In COLING-2000.</booktitle>
<marker>submitted, </marker>
<rawString>Markus Walther. submitted. On finite-state reduplication. In COLING-2000.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>