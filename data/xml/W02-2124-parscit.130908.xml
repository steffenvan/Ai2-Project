<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.929081">
Use of Description logic and SDRT in an NLG system
</title>
<author confidence="0.59083">
Adil El Ghali
</author>
<affiliation confidence="0.4100875">
LATTICE
Denis Diderot University - Paris
</affiliation>
<email confidence="0.995647">
adil@linguist.jussieu.fr
</email>
<sectionHeader confidence="0.999436" genericHeader="abstract">
1 Introduction
</sectionHeader>
<bodyText confidence="0.996420315789474">
The standard architecture of an NLG system pro-
posed in (Reiter and Dale, 2000) is schematized in
Figure 1.1. The tool used by a module and the data
structure of its output are not defined precisely. Ac-
cording to Reiter and Dale, they vary from one au-
thor to the other one. However, we believe that cer-
tain tools broadly used by the AI or NLU community
are appropriate for NLG tasks. So, we reformulate
more precisely Figure 1.1 as Figure 1.2.
The paper follows this Figure 1.2: section 3 jus-
tifies the use of a description logic for the content
determination task and its ouput, a “message”; sec-
tion 4 justifies the use of SDRT for the document
structuring task and its output, a “document plan”;
section 5 briefly exposes the use of a lexicalized for-
malism in the tactical component. Each section is
illustrated by means of GePhoX, a generator which
produces texts explaining the steps taken by a proof
assistant, PhoX. So we start by presenting GePhoX.
</bodyText>
<sectionHeader confidence="0.979002" genericHeader="keywords">
2 GePhoX
</sectionHeader>
<bodyText confidence="0.999837222222222">
PhoX is an extensible proof assistant based on
higher order logic, which was developped to help
mathematicians building proofs and teaching math-
ematics (Raffalli and Roziere, 2002). Like other
proof assistants, PhoX works in an interactive way.
The user (a mathematician) gives first the theorem
to be proved (a goal). PhoX returns a list of sub-
goals which should be easier to prove than the initial
goal. The user enters a command to guide PhoX in
choosing or achieving a subgoal. The proof is thus
computed top-down from goals to evidences. The
user’s commands forma Proof script. PhoX output
is a list of successive goals equivalent to a Proof tree.
Both the Proof script and PhoX output are dif-
ficult to read (even for a mathematician), as the
reader can see for him/herself in Table 1 and Table
2. Hence, the necessity of an NLG system to get an
easy to read version of the proof.
GePhoX is given as input both the Proof script
and the succesive goals of PhoX output. It can
produce texts during the interactive session (from
an incomplete proof). This is quite useful to help
the mathematician user: before entering a new com-
mand in the Proof script, he/she can read a text re-
minding him/her what he/she has been doing so far.
Taking into account the Proof script in GePhoX
input is one of the main originalities of our generator
</bodyText>
<figure confidence="0.948022567567568">
Text Text
Figure 1.1 Figure 1.2
Standard architecture of an NLG system Architecture of an NLG system
with data structures
message
Document
Structuring
Document Planner
Tactical component
Micro−planner
Document plan
representation
Surface
realiser
Semantic
Lexicalized
Surface realiser
Lexicalized
Micro−planner
Semantic
Dependency tree
SDRS
Communicative
goals
Communicative
goals
logical form
Document
structuring
à la SDRT
Content
Determination
with a
description logic
Content
Determination
goalVp,d: N(d =�N0 -. 3q, r : N(r &lt; d ∧ p = q * d + r))
</figure>
<listItem confidence="0.639663333333333">
1. intros.
2. elim −4 H well founded.N.
3. intros.
4. elim −1 d −3 a lesseq.case1.N.
5. next.
6. intros 3 ∧.
7. next −3.
8. instance ?1 N0.
9. instance ?2 a.
10. intro.
11. trivial.
12. local a&apos; = a - d.
13. elim −1 a&apos; H3.
14. trivial.
15. elim lesseq.S rsub.N.
16. elim −1 [case] H0.
17. trivial =H1 H5.
18. trivial.
19. lefts H5 ∧ 3.
20. intros ∧ 3.
21. next −3.
22. instance ?4 r.
23. instance ?3 S q.
24. rewrite mul.lS.N −r add.associative.N −r H8.
25. intro.
26. trivial.
27. save euclide exists.
</listItem>
<tableCaption confidence="0.995735">
Table 1: Proof script for Euclidian division
</tableCaption>
<bodyText confidence="0.77903">
Here is the goal:
</bodyText>
<equation confidence="0.890603571428571">
goal 1/1
|- /\p,d:N (d != N0 -&gt;
\/q,r:N (r &lt; d &amp; p = q * d + r))
End of goals.
%PhoX% intros.
1 goal created.
New goal is:
goal 1/1
H:= N p
H0 := N d
H1 := d != N0
|- \/q,r:N (r &lt; d &amp; p = q * d + r)
End of goals.
. . .
</equation>
<tableCaption confidence="0.834628">
Table 2: PhoX output for Euclidian division
</tableCaption>
<bodyText confidence="0.952116714285714">
(similar generators, such as PROVERB (Huang and
Fiedler, 1997), take as input only the Proof tree). It
makes it possible for GePhoX to start from an in-
complete proof and to identify the reasoning strate-
gies that have been used (reasoning by contradiction,
by induction ), while it is very hard (if not impossi-
ble) to retrieve this information from a Proof tree
with its quite numerous deduction steps.
Another originality of GePhoX is that it takes into
account the knowledge of the user who can be ei-
ther a mathematician using PhoX or a person more
or less novice in mathematics. For the same proof,
GePhoX can generate several texts according to a
(GePhoX) user model.
</bodyText>
<sectionHeader confidence="0.447993" genericHeader="introduction">
3 Using a descrition logic (DL)
</sectionHeader>
<bodyText confidence="0.999965">
The knowledge representation system Kl-ONE
(Branchman et al., 1979), was the first DL. It was
created to formalize semantic networks and frames
with the introduction of T-Boxes and A-Boxes (re-
spectively for terminological and assertional knowl-
edge). Kl-ONE has been broadly used in the NLG
community to formalize the domain model. On the
other hand, this is not the case for the more recent
DLs. Nevertheless, they present at least two ad-
vantages compared to Kl-ONE : 1) for a large va-
riety of DLs, sound and complete algorithms have
been developped for main inference problems such
as subsumption, concepts satisfiability and consis-
tency (Donini et al., 1996); 2) the relations between
instances and classes are well defined for all the con-
structors and their mathematical and computational
properties have been studied in detail. So we believe
that DLs are appropriate for the content determina-
tion task as shown in 3.2. Let us first present DLs
briefly.
</bodyText>
<subsectionHeader confidence="0.999537">
3.1 A brief Introduction to DL
</subsectionHeader>
<bodyText confidence="0.99957">
The three fundamental notions of DLs are individ-
uals (representing objects in the domain), concepts
(describing sets of individuals), and roles (repre-
senting binary relations between individuals). A
description logic is characterized by a set of con-
structors that allow us to build complex concepts
and roles from atomic ones. The set of constructors
which seem useful for GePhoX and their syntax are
shown in Table 3; examples of concepts and roles
with their semantic are shown underneath Table 3.
</bodyText>
<tableCaption confidence="0.997146">
Table 3: Syntax of standard constructors
</tableCaption>
<figure confidence="0.988552548387097">
Constructor (abbreviation)
atomic concept
top
bottom
conjonction
disjonction (U)
complement (C)
univ. quant.
exist. quant. (E)
numeral restrictions (Ar)
collection of individuals (O)
atomic role
roles conjonction (R)
inverse role
role composition
A
VR.C
P
R−1
Syntax
Q ∧ R
QoR
T
L
C ∧ D
CVD
,C
3R.C
{a1,. . .,an}
&gt;n R.C , &lt;n R.C
Examples of concepts with their semantic
</figure>
<equation confidence="0.9073142">
Theorem, Variable, {H1}, 3CHOOSE.User
{ x / Theorem(x) } : Theorem concept
{ x / Variable(x) } : Variable concept
{ H1} : concept constructed by the O constructor on individual
H1
{ x / 3 u : User, CHOOSE(u,x) }
Examples of roles with their semantic
IMPLIES, PROVE
{ x,y / IMPLIES(x,y) } : x implies y
{ x,y / PROVE(x,y) } : x prove y
</equation>
<bodyText confidence="0.998623833333333">
Let us underline that the choice of constructors
is domain dependent. Constructors other than those
used in GePhoX (e.g. temporal extension) can be
used for other domains (e.g. domain with non trivial
temporal information), without altering the mathe-
matical and computational properties.
</bodyText>
<subsectionHeader confidence="0.999432">
3.2 Content determination in DL
</subsectionHeader>
<bodyText confidence="0.998995545454545">
The Domain model is the set of concepts and roles
necessary to express the input of the generator. More
formally, let TD be a TBox, such that each input
I can be descibed by means of an ABox AD cor-
responding to TD. The knowledge base ED =
(TD, AD) is called knowledge base for the domain
(or domain model) and noted DKB. The User model
is a knowledge base EU = (TU, AU) such that TU
and AU are respectivly subsets of TD and AD. EU
is noted UKB. Table 4 shows a part of the DKB for
GePhoX.
</bodyText>
<table confidence="0.978849785714286">
Goal MathObj
Subgoal Axiom
Hypothese Theorem
Rules well_founded
Intro lesseq.case1
Elim add.associative
Rewrite Operator
Trivial LogicalOper
Left Exist
ReasonningStrategy Forall
ByInduction LAnd
ByContradiction ArithOper
. . . Add
. . . Multi
</table>
<tableCaption confidence="0.998465">
Table 4: GePhoX Domain model
</tableCaption>
<bodyText confidence="0.956388583333333">
The content determination module performs four
tasks as schematized in Figure 2.
Translation: The input of the generator (asser-
tional information) is first translated into concepts
of the TBox. For that purpose, a correspondancy
between the elements of the input and concepts and
roles in the DKB is established. The O constructor
is used to keep information about the individuals oc-
curring in the input. For example, command 2 in Ta-
ble 1 with individual H is translated into the concept
C0 .= ]EliminationWell founded.Hypothese
{H}, and commands 8 to 11 are translated into
</bodyText>
<subsubsectionHeader confidence="0.365221">
C1 =. ]ByInduction {p}.
</subsubsectionHeader>
<bodyText confidence="0.794345166666667">
Selection: The selection task consists in choosing
the relevant concepts among those constructed in the
translation phase in regard of the UKB. For example,
if C0 is an unknown concept for the user, a concept
C must be looked up in the UKB such as C approxi-
mates C0.
</bodyText>
<figureCaption confidence="0.998138">
Figure 2: Content Determination Tasks
</figureCaption>
<bodyText confidence="0.991752333333333">
Verification: At this point, the coherence of all the
concepts of the selection is verified. For example if
the user tries to reason by induction on a real num-
ber, GePhoX tells him/her that it is not possible.
Instanciation: Thanks to the informations about
individuals which have been kept in the translation
phase (with the use of the O constructor), the instan-
ciation task is straightforward. Table 5 shows some
instanciated concepts for the Euclidian division.
</bodyText>
<listItem confidence="0.633903363636364">
1. 3p1 E Entier
named(p1, p)
choose(user, p1)
2. 3d1 E EntierNonNul
named(d1, d)
choose(user, d1)
3. 3f1 E Formula
constant(f1, 3q,r: N (r &lt; d n p = q.d + r))
4. prove(user, f1)
induction(f1, p1)
. . .
</listItem>
<tableCaption confidence="0.976849">
Table 5: DL-Message for Euclidian division
</tableCaption>
<figure confidence="0.9970645">
Assertional
Input
Terminological
Concepts
Selection
Verification
Concepts
Translation
TBox
Instanciation
Logical Form
ABox
</figure>
<bodyText confidence="0.999820666666667">
As it is well known, designing knowledge bases
(DKB and UKB) and translating the input of the gen-
erator into concepts and roles of the DL is an heavy
task which has to be achieved for each generator.
However, with a DL, the selection, verification and
instanciation tasks are domain independent: algo-
rithms and their implementation are reusable. More-
over, when using a DL for the content determination
task, the “message” is a first order logic formula (a
standard representation shared by a large commu-
nity) which takes into account the user knowledge
and whose coherence has been checked.
</bodyText>
<sectionHeader confidence="0.961994" genericHeader="method">
4 Using SDRT for document structuring
</sectionHeader>
<bodyText confidence="0.99996025">
We adopt SDRT (Segmented Discourse Representa-
tion Theory (Asher, 1993; Asher and Lascarides,
1998)). The reasons for this choice can be found
in (Danlos et al., 2001). Let us present SDRT briefly.
</bodyText>
<subsectionHeader confidence="0.996968">
4.1 A brief introduction to SDRT
</subsectionHeader>
<bodyText confidence="0.999896473684211">
SDRT which was designed first for text understand-
ing, was introduced as an extension of DRT (Dis-
course Representation Theory, (Kamp and Reyle,
1993)) in order to account for specific properties of
discourse structure. SDRT can be viewed as a super-
layer on DRT whose expressiveness is enhanced by
the use of discourse relations. Thus the DRT struc-
tures (Discourse Representation Structures or DRS)
are handled as basic discourse units in SDRT.
DRSs are ”boxed” first order logic formulae. For-
mally, a DRS is a couple of sets (U,Con). U (the
universe) is the set of discourse referents. Con con-
tains the truth conditions representing the meaning
of the discourse.
A SDRS is a pair (U,Con), see Figure 3. U is a
set of labels of DRS or SDRS which can be viewed
as “speech act discourse referents” (Asher and Las-
carides, 1998). Con is a set of conditions on labels
of the form:
</bodyText>
<listItem confidence="0.9863864">
• ir : K, where ir is a label from U and K is a (S)DRS
• R(iri, irk), where iri and irk are labels and R a discourse
relation. Discourse relations are inferred non-monotically
by means of a defeasible glue logic exploiting lexical and
world knowledge.
</listItem>
<subsectionHeader confidence="0.997393">
4.2 Building a SDRS
</subsectionHeader>
<bodyText confidence="0.999755">
Starting from a “message” encoded into a logical
form, the document structuring module builds a
</bodyText>
<figureCaption confidence="0.996289">
Figure 3: SDRS for Max fell. John pushed him.
</figureCaption>
<bodyText confidence="0.999837888888889">
SDRS. In a first step, the logical form is translated
into a DRS. In case of a purely existential formula1,
this could just amount to putting all the variables
into the universe of the DRS and split the formula
into elementary conjoined conditions. However,
there is an important difference between SDRSs and
logical forms. SDRSs represent discourses and their
variables are discourse referents. Logical forms rep-
resent meanings and their variables are pure logical
variables. Therefore, it has to be decided which vari-
ables in the logical form become discourse referents
(the linguistic consequences of this decision are ex-
plained in section 5). For that purpose, logically
equivalent formulae are computed through two op-
erations called reification and dereification. From a
formula such as Ies, e2 cause(es, e2), the causal re-
lation can be reified to get If, es, e2 cause(f, es, e2).
Then fappears in the final SDRS as a discourse refer-
ent. Conversely, from If, es, e2 cause(f, es, e2), the
causal relation can be dereified if no other condition
than cause(f, es, e2) has fas an argument. It is not in
the scope of this paper to explain when the reifica-
tion and dereification operations should be applied.
After this first step, the document structuring task
amounts to building a SDRS from a DRS and to go on
recursively on each embedded (S)DRSs. This pro-
cess is schematized below.
</bodyText>
<table confidence="0.990091692307692">
-1 -2 -3
universe1
-1 : condition1
condition7
universe
condition1
condition2 universe2
condition3 −→ -2 : condition2
condition4 condition5
condition5
condition6 universe3
condition7 -3 :
condition4
</table>
<tableCaption confidence="0.7157215">
R1(-1, -2) ↔ condition3
R2(-2, -3) ↔ condition6
</tableCaption>
<bodyText confidence="0.992697">
Let us first examine the principles governing the
splitting of the conditions. All the conditions in the
</bodyText>
<footnote confidence="0.851434">
1More complex formulas are not considered here.
</footnote>
<listItem confidence="0.8986828">
DRS have to be expressed in the SDRS. Two cases
arise:
• either a condition in the DRS appears as a condition in
one of the sub-DRS; that is the case for condition1 which
appears in the sub-DRS labelled Ir1;
• or it is expressed through a discourse relation; that is
the case for condition3 with R1(Ir1, Ir2) ↔ condition3,
which means that R1(Ir1, Ir2) must have condition3
among its consequences: no other element is in charge
of expressing condition3.
</listItem>
<bodyText confidence="0.98979175">
To establish discourse relations, the SDRT condi-
tions are reversed. As an illustration, in SDRT for
text understanding, there is the Axiom for Narration
2. This axiom states that if Narration holds between
two SDRSs Tr1 and Tr2, then the main event (me) of
Tr1 happens before the main event of Tr2.
For text generation, this axiom is reversed in the
rule below (Roussarie, 2000, p. 154).
</bodyText>
<listItem confidence="0.9988325">
• If k1 and k2 are DRS the main eventualities of which are
not states,
• and if the me of k1 occurs before the me of k2,
• then Narration(Ir1, Ir2) is valid when Ir1 and Ir2 respec-
</listItem>
<bodyText confidence="0.966532666666667">
tively label k1 and k2.
As another example, the condition cause(e1, e2)
can be expressed through Result(Tr1, Tr2) or Expla-
nation(Tr2, Tr1) when Tr1 and Tr2 label the sub-DRSs
that contain the descriptions of e1 and e2 respec-
tively.
Let us now examine how we determine the uni-
verses of sub-DRSs, i.e. discourse referents, while
observing two technical constraints, namely:
</bodyText>
<listItem confidence="0.990591666666667">
• the arguments of any condition in a sub-DRS
must appear in the universe of this DRS;
• the universes of all the sub-DRSs have to be dis-
</listItem>
<bodyText confidence="0.958512727272727">
joint. This constraint is the counterpart of the
following constraint in understanding: “partial
DRSs introduce new discourse referents”
These two constraints are not independent. As-
suming that the first constraint is respected, the sec-
ond one can be respected with the following mech-
anism: if a variable x already appears in a preced-
ing sub-DRS labelled Trx, then a brand new variable
y is created in the universe of the current sub-DRS
labelled Try and the condition y = x is added into
the conditions of Try. The discourse referent y will
2✷(Narration(Ir1, Ir2) → me(Ir1) &lt; me(Ir2))
be generated as an anaphora if Trx is available to Try
(Asher, 1993), otherwise it will be generated as a
definite or demonstrative NP.
Document structuring module a` la SDRT base on
the principles we have just exposed can be used for
any generator (whose “message” is first order logic
formula). The algorithm and the rules to establish
discours relations (obtained by reversing the rules in
NLU) are generic. Below an example of SDRS in
GePhoX.
</bodyText>
<page confidence="0.259117">
π3π4
</page>
<tableCaption confidence="0.707868">
Table 6: SDRS for Euclidian division
</tableCaption>
<sectionHeader confidence="0.836042" genericHeader="method">
5 Generating a text from a SDRS
</sectionHeader>
<bodyText confidence="0.984099181818182">
A SDRS can be given as the input of existing tacti-
cal components. Here, we illustrate the process of
generating a text from a SDRS using G-TAG (Dan-
los, 2000) whose architecture is represented at the
bottom of Figure 1.2.
The microplanner is based on a lexicalized
conceptual-semantic interface. This interface is
made up of concepts; each concept is associated
with a lexical data base. In our model, a concept
is either a term in the T-Box or a discourse relation.
A lexical data base for a given concept records the
lexemes lexicalizing it with their argument structure,
and the mappings between the conceptual and se-
mantic arguments. The process of generating a se-
mantic dependency tree from a SDRS (U,Con) is re-
cursive:
- an element Tri in U is generated as a clause if Tri
labels a DRS and recursively as a text (possibly
a complex sentence) if Tri labels a SDRS.
- a condition R(Tri, Trj) in Con is generated as a
text “Si. Cue Sj.” or as a complex sentence
“Si Cue Sj.”, where Si generates Tri, Sj Trj,
</bodyText>
<figure confidence="0.994869285714286">
π1π2
x u e1 yve2
user(u) entier-non-nul(y)
π3 : π1 : entier(x) π2 : named(y,’d’)
named(x,p) choose(e2,u,y)
choose(e1,x,y) v = u
Parallel(π1,π2)
x1 fwe3
π4 : formula(f) Narration(π3,π4)
constant(f,∃q,r:N ... )
prove(e3,v,f)
induction(e3,x’)
w=u
x1 = x
</figure>
<bodyText confidence="0.798196">
and Cue is a cue phrase which is encoded in
the lexical data base associated with R (Cue
may be empty).
- a condition π : K in Con where K is a DRS
(U,Con) is generated as a clause according to
the following constraints (which are the coun-
terpart of constraints in understanding)3:
</bodyText>
<listItem confidence="0.9687935">
• a discourse referent is generated as an NP or a tensed verb.
• conditions guide lexical choices. Conditions such as x =
</listItem>
<bodyText confidence="0.990213666666667">
John correspond to proper names. Equality conditions
between discourse referents (e.g. x = y) give rise to
(pronominal or nominal) anaphora. The other conditions,
e.g. prove(e1, x, y), are lexicalized through the lexical
data base associated with the concept (prove).
The surface realizer is based on a TAG grammar
which is a set of lexical data bases. A data base for a
given lexical entry encodes the syntactic structures
realizing it with their syntactic arguments. With
such a TAG grammar and a morphological module,
the text is computed in a deterministic way from the
semantic dependency tree.
</bodyText>
<sectionHeader confidence="0.999506" genericHeader="conclusions">
6 Conclusion
</sectionHeader>
<bodyText confidence="0.999989">
We have shown in this paper how to integrate DL,
SDRT, and a lexicalized grammar into an NLG sys-
tem. Moreover, GePhoX illustrates the applicabilty
of our system, which is currently being implemented
in Java. The development of the document planner
of GePhoX is work in progress. The goal is to in-
terface this module with CLEF (Meunier and Reyes,
1999), an implementation of G-TAG. We intend to
produce a text as shown in Table 7.
</bodyText>
<sectionHeader confidence="0.999284" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.965915413043478">
N. Asher and A. Lascarides. 1998. The semantics and
pragmatics of presupposition. Journal of Semantics,
15(3):239–300.
N. Asher. 1993. Reference to Abstract Objects in Dis-
course. Kluwer, Dordrecht.
R. Branchman, R. Bobrow, P. Cohen, J. Klovstad,
B. Webber, and W. Woods. 1979. Research in nat-
ural language understanding. Technical Report 4274,
Bolt. Beranek and Newman, Cambridge MA.
3With these constraints, an element which is reified, e.g.
cause(f, e1, e2), gives rise to an NP or a verb (the cause of, pro-
voke) and an element which is not reified, e.g. cause(e1, e2),
gives rise to a modifier on e1 or e2 with e1 and e2 generated
either as verbs or NPs.
Table 7: A Text of proof for Euclidian division
L. Danlos, B. Gaiffe, and L. Roussarie. 2001. Document
structring a` la SDRT. In ACL’2001 Toulouse Proceed-
ing.
L. Danlos. 2000. G-TAG: A lexicalized formalism for
text generation inspired by Tree Adjoining Grammar.
In A. Abeill´e and O. Rambow, editors, Tree Adjoining
Grammars: formalisms, linguistics analysis and pro-
cessing, pages 343–370. CSLI Publications, Stanford.
F. Donini, M. Lenzerini, D. Nardi, and A. Schaerf. 1996.
Reasoning in description logics. In G. Brewka, edi-
tor, Principles of Knowledge Representation and Rea-
soning, Studies in Logic, Language and Information.
CLSI Publications.
X. Huang and A. Fiedler. 1997. Proof verbalization as
an application of NLG. In IJCAI (2), pages 965–972.
H. Kamp and U. Reyle. 1993. From Discourse to Logic.
Kluwer Academic Publishers, Dordrecht, The Nether-
lands.
F. Meunier and R. Reyes. 1999. La plate forme de
d´eveloppement de g´en´erateurs de textes CLEF. In
Actes du 2`e Colloque Francophone sur la G´en´eation
Automatique de Textes, GAT’99, Grenoble.
C. Raffalli and P. Roziere, 2002. The PhoX Proof checker
documentation. LAMA, Universit´e de Savoie / Uni-
versit´e Paris 7.
E. Reiter and R. Dale. 2000. Building Natural Language
Generation Systems. Cambridge University Press.
L. Roussarie. 2000. Un mod`ele th´eorique d’inf´erences
de structures s´emantiques et discursives dans le cadre
de la g´en´eration automatique de textes. Th`ese de doc-
torat en linguistique, Universit´e Denis Diderot, Paris 7.
</reference>
<figure confidence="0.255104285714286">
Theorem.
`dp,d:IN (d =� 0 --+ 3q,r:IN (r &lt; d n p = q.d + r))
Proof. Let us choose p, d two natural numbers with
d =� 0. We prove the following by induction on p:
3q,r:IN (r &lt; d n p = q.d + r). Let take a a strictly positive
natural. We assume
`db:IN (b &lt; a --+ 3q,r:IN (r &lt; d n b = q.d + r))
</figure>
<bodyText confidence="0.999873714285714">
and we must prove 3q,r:IN (r &lt; d n a = q.d + r). We dis-
tinguish two cases: a &lt; d and d &lt; a. In the first case,
we choose q = 0 and r = a. In the second case, we take
a&apos; = a − d. Using the induction hypothesis on a!, we find
two naturals q, r such that r &lt; d and a&apos; = q.d + r. We take
S q and r as quotient and remaining for the division of a. We
must prove a = S q.d + r which is immediate.
</bodyText>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.253777">
<title confidence="0.995991">Use of Description logic and SDRT in an NLG system</title>
<author confidence="0.7117765">Adil El_Denis Diderot University</author>
<email confidence="0.481797">adil@linguist.jussieu.fr</email>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>N Asher</author>
<author>A Lascarides</author>
</authors>
<title>The semantics and pragmatics of presupposition.</title>
<date>1998</date>
<journal>Journal of Semantics,</journal>
<volume>15</volume>
<issue>3</issue>
<contexts>
<context position="10307" citStr="Asher and Lascarides, 1998" startWordPosition="1783" endWordPosition="1786">tor into concepts and roles of the DL is an heavy task which has to be achieved for each generator. However, with a DL, the selection, verification and instanciation tasks are domain independent: algorithms and their implementation are reusable. Moreover, when using a DL for the content determination task, the “message” is a first order logic formula (a standard representation shared by a large community) which takes into account the user knowledge and whose coherence has been checked. 4 Using SDRT for document structuring We adopt SDRT (Segmented Discourse Representation Theory (Asher, 1993; Asher and Lascarides, 1998)). The reasons for this choice can be found in (Danlos et al., 2001). Let us present SDRT briefly. 4.1 A brief introduction to SDRT SDRT which was designed first for text understanding, was introduced as an extension of DRT (Discourse Representation Theory, (Kamp and Reyle, 1993)) in order to account for specific properties of discourse structure. SDRT can be viewed as a superlayer on DRT whose expressiveness is enhanced by the use of discourse relations. Thus the DRT structures (Discourse Representation Structures or DRS) are handled as basic discourse units in SDRT. DRSs are ”boxed” first or</context>
</contexts>
<marker>Asher, Lascarides, 1998</marker>
<rawString>N. Asher and A. Lascarides. 1998. The semantics and pragmatics of presupposition. Journal of Semantics, 15(3):239–300.</rawString>
</citation>
<citation valid="true">
<authors>
<author>N Asher</author>
</authors>
<title>Reference to Abstract Objects in Discourse.</title>
<date>1993</date>
<publisher>Kluwer,</publisher>
<location>Dordrecht.</location>
<contexts>
<context position="10278" citStr="Asher, 1993" startWordPosition="1781" endWordPosition="1782">of the generator into concepts and roles of the DL is an heavy task which has to be achieved for each generator. However, with a DL, the selection, verification and instanciation tasks are domain independent: algorithms and their implementation are reusable. Moreover, when using a DL for the content determination task, the “message” is a first order logic formula (a standard representation shared by a large community) which takes into account the user knowledge and whose coherence has been checked. 4 Using SDRT for document structuring We adopt SDRT (Segmented Discourse Representation Theory (Asher, 1993; Asher and Lascarides, 1998)). The reasons for this choice can be found in (Danlos et al., 2001). Let us present SDRT briefly. 4.1 A brief introduction to SDRT SDRT which was designed first for text understanding, was introduced as an extension of DRT (Discourse Representation Theory, (Kamp and Reyle, 1993)) in order to account for specific properties of discourse structure. SDRT can be viewed as a superlayer on DRT whose expressiveness is enhanced by the use of discourse relations. Thus the DRT structures (Discourse Representation Structures or DRS) are handled as basic discourse units in SD</context>
<context position="15696" citStr="Asher, 1993" startWordPosition="2713" endWordPosition="2714">of the following constraint in understanding: “partial DRSs introduce new discourse referents” These two constraints are not independent. Assuming that the first constraint is respected, the second one can be respected with the following mechanism: if a variable x already appears in a preceding sub-DRS labelled Trx, then a brand new variable y is created in the universe of the current sub-DRS labelled Try and the condition y = x is added into the conditions of Try. The discourse referent y will 2✷(Narration(Ir1, Ir2) → me(Ir1) &lt; me(Ir2)) be generated as an anaphora if Trx is available to Try (Asher, 1993), otherwise it will be generated as a definite or demonstrative NP. Document structuring module a` la SDRT base on the principles we have just exposed can be used for any generator (whose “message” is first order logic formula). The algorithm and the rules to establish discours relations (obtained by reversing the rules in NLU) are generic. Below an example of SDRS in GePhoX. π3π4 Table 6: SDRS for Euclidian division 5 Generating a text from a SDRS A SDRS can be given as the input of existing tactical components. Here, we illustrate the process of generating a text from a SDRS using G-TAG (Dan</context>
</contexts>
<marker>Asher, 1993</marker>
<rawString>N. Asher. 1993. Reference to Abstract Objects in Discourse. Kluwer, Dordrecht.</rawString>
</citation>
<citation valid="false">
<authors>
<author>R Branchman</author>
<author>R Bobrow</author>
<author>P Cohen</author>
<author>J Klovstad</author>
<author>B Webber</author>
<author>W Woods</author>
</authors>
<title>Research in natural language understanding.</title>
<date>1979</date>
<tech>Technical Report 4274,</tech>
<contexts>
<context position="4595" citStr="Branchman et al., 1979" startWordPosition="823" endWordPosition="826">n incomplete proof and to identify the reasoning strategies that have been used (reasoning by contradiction, by induction ), while it is very hard (if not impossible) to retrieve this information from a Proof tree with its quite numerous deduction steps. Another originality of GePhoX is that it takes into account the knowledge of the user who can be either a mathematician using PhoX or a person more or less novice in mathematics. For the same proof, GePhoX can generate several texts according to a (GePhoX) user model. 3 Using a descrition logic (DL) The knowledge representation system Kl-ONE (Branchman et al., 1979), was the first DL. It was created to formalize semantic networks and frames with the introduction of T-Boxes and A-Boxes (respectively for terminological and assertional knowledge). Kl-ONE has been broadly used in the NLG community to formalize the domain model. On the other hand, this is not the case for the more recent DLs. Nevertheless, they present at least two advantages compared to Kl-ONE : 1) for a large variety of DLs, sound and complete algorithms have been developped for main inference problems such as subsumption, concepts satisfiability and consistency (Donini et al., 1996); 2) th</context>
</contexts>
<marker>Branchman, Bobrow, Cohen, Klovstad, Webber, Woods, 1979</marker>
<rawString>R. Branchman, R. Bobrow, P. Cohen, J. Klovstad, B. Webber, and W. Woods. 1979. Research in natural language understanding. Technical Report 4274, Bolt. Beranek and Newman, Cambridge MA. 3With these constraints, an element which is reified, e.g. cause(f, e1, e2), gives rise to an NP or a verb (the cause of, provoke) and an element which is not reified, e.g. cause(e1, e2), gives rise to a modifier on e1 or e2 with e1 and e2 generated either as verbs or NPs.</rawString>
</citation>
<citation valid="false">
<title>Table 7: A Text of proof for Euclidian division</title>
<marker></marker>
<rawString>Table 7: A Text of proof for Euclidian division</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Danlos</author>
<author>B Gaiffe</author>
<author>L Roussarie</author>
</authors>
<title>Document structring a` la SDRT.</title>
<date>2001</date>
<booktitle>In ACL’2001 Toulouse Proceeding.</booktitle>
<contexts>
<context position="10375" citStr="Danlos et al., 2001" startWordPosition="1796" endWordPosition="1799">eved for each generator. However, with a DL, the selection, verification and instanciation tasks are domain independent: algorithms and their implementation are reusable. Moreover, when using a DL for the content determination task, the “message” is a first order logic formula (a standard representation shared by a large community) which takes into account the user knowledge and whose coherence has been checked. 4 Using SDRT for document structuring We adopt SDRT (Segmented Discourse Representation Theory (Asher, 1993; Asher and Lascarides, 1998)). The reasons for this choice can be found in (Danlos et al., 2001). Let us present SDRT briefly. 4.1 A brief introduction to SDRT SDRT which was designed first for text understanding, was introduced as an extension of DRT (Discourse Representation Theory, (Kamp and Reyle, 1993)) in order to account for specific properties of discourse structure. SDRT can be viewed as a superlayer on DRT whose expressiveness is enhanced by the use of discourse relations. Thus the DRT structures (Discourse Representation Structures or DRS) are handled as basic discourse units in SDRT. DRSs are ”boxed” first order logic formulae. Formally, a DRS is a couple of sets (U,Con). U (</context>
</contexts>
<marker>Danlos, Gaiffe, Roussarie, 2001</marker>
<rawString>L. Danlos, B. Gaiffe, and L. Roussarie. 2001. Document structring a` la SDRT. In ACL’2001 Toulouse Proceeding.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Danlos</author>
</authors>
<title>G-TAG: A lexicalized formalism for text generation inspired by Tree Adjoining Grammar.</title>
<date>2000</date>
<pages>343--370</pages>
<editor>In A. Abeill´e and O. Rambow, editors,</editor>
<publisher>CSLI Publications, Stanford.</publisher>
<contexts>
<context position="16306" citStr="Danlos, 2000" startWordPosition="2819" endWordPosition="2821">93), otherwise it will be generated as a definite or demonstrative NP. Document structuring module a` la SDRT base on the principles we have just exposed can be used for any generator (whose “message” is first order logic formula). The algorithm and the rules to establish discours relations (obtained by reversing the rules in NLU) are generic. Below an example of SDRS in GePhoX. π3π4 Table 6: SDRS for Euclidian division 5 Generating a text from a SDRS A SDRS can be given as the input of existing tactical components. Here, we illustrate the process of generating a text from a SDRS using G-TAG (Danlos, 2000) whose architecture is represented at the bottom of Figure 1.2. The microplanner is based on a lexicalized conceptual-semantic interface. This interface is made up of concepts; each concept is associated with a lexical data base. In our model, a concept is either a term in the T-Box or a discourse relation. A lexical data base for a given concept records the lexemes lexicalizing it with their argument structure, and the mappings between the conceptual and semantic arguments. The process of generating a semantic dependency tree from a SDRS (U,Con) is recursive: - an element Tri in U is generate</context>
</contexts>
<marker>Danlos, 2000</marker>
<rawString>L. Danlos. 2000. G-TAG: A lexicalized formalism for text generation inspired by Tree Adjoining Grammar. In A. Abeill´e and O. Rambow, editors, Tree Adjoining Grammars: formalisms, linguistics analysis and processing, pages 343–370. CSLI Publications, Stanford.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Donini</author>
<author>M Lenzerini</author>
<author>D Nardi</author>
<author>A Schaerf</author>
</authors>
<title>Reasoning in description logics.</title>
<date>1996</date>
<booktitle>Principles of Knowledge Representation and Reasoning, Studies in Logic, Language and Information.</booktitle>
<editor>In G. Brewka, editor,</editor>
<publisher>CLSI Publications.</publisher>
<contexts>
<context position="5188" citStr="Donini et al., 1996" startWordPosition="922" endWordPosition="925">NE (Branchman et al., 1979), was the first DL. It was created to formalize semantic networks and frames with the introduction of T-Boxes and A-Boxes (respectively for terminological and assertional knowledge). Kl-ONE has been broadly used in the NLG community to formalize the domain model. On the other hand, this is not the case for the more recent DLs. Nevertheless, they present at least two advantages compared to Kl-ONE : 1) for a large variety of DLs, sound and complete algorithms have been developped for main inference problems such as subsumption, concepts satisfiability and consistency (Donini et al., 1996); 2) the relations between instances and classes are well defined for all the constructors and their mathematical and computational properties have been studied in detail. So we believe that DLs are appropriate for the content determination task as shown in 3.2. Let us first present DLs briefly. 3.1 A brief Introduction to DL The three fundamental notions of DLs are individuals (representing objects in the domain), concepts (describing sets of individuals), and roles (representing binary relations between individuals). A description logic is characterized by a set of constructors that allow us</context>
</contexts>
<marker>Donini, Lenzerini, Nardi, Schaerf, 1996</marker>
<rawString>F. Donini, M. Lenzerini, D. Nardi, and A. Schaerf. 1996. Reasoning in description logics. In G. Brewka, editor, Principles of Knowledge Representation and Reasoning, Studies in Logic, Language and Information. CLSI Publications.</rawString>
</citation>
<citation valid="true">
<authors>
<author>X Huang</author>
<author>A Fiedler</author>
</authors>
<title>Proof verbalization as an application of NLG.</title>
<date>1997</date>
<booktitle>In IJCAI (2),</booktitle>
<pages>965--972</pages>
<contexts>
<context position="3887" citStr="Huang and Fiedler, 1997" startWordPosition="700" endWordPosition="703">lim −1 [case] H0. 17. trivial =H1 H5. 18. trivial. 19. lefts H5 ∧ 3. 20. intros ∧ 3. 21. next −3. 22. instance ?4 r. 23. instance ?3 S q. 24. rewrite mul.lS.N −r add.associative.N −r H8. 25. intro. 26. trivial. 27. save euclide exists. Table 1: Proof script for Euclidian division Here is the goal: goal 1/1 |- /\p,d:N (d != N0 -&gt; \/q,r:N (r &lt; d &amp; p = q * d + r)) End of goals. %PhoX% intros. 1 goal created. New goal is: goal 1/1 H:= N p H0 := N d H1 := d != N0 |- \/q,r:N (r &lt; d &amp; p = q * d + r) End of goals. . . . Table 2: PhoX output for Euclidian division (similar generators, such as PROVERB (Huang and Fiedler, 1997), take as input only the Proof tree). It makes it possible for GePhoX to start from an incomplete proof and to identify the reasoning strategies that have been used (reasoning by contradiction, by induction ), while it is very hard (if not impossible) to retrieve this information from a Proof tree with its quite numerous deduction steps. Another originality of GePhoX is that it takes into account the knowledge of the user who can be either a mathematician using PhoX or a person more or less novice in mathematics. For the same proof, GePhoX can generate several texts according to a (GePhoX) use</context>
</contexts>
<marker>Huang, Fiedler, 1997</marker>
<rawString>X. Huang and A. Fiedler. 1997. Proof verbalization as an application of NLG. In IJCAI (2), pages 965–972.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Kamp</author>
<author>U Reyle</author>
</authors>
<title>From Discourse to Logic.</title>
<date>1993</date>
<publisher>Kluwer Academic Publishers,</publisher>
<location>Dordrecht, The Netherlands.</location>
<contexts>
<context position="10587" citStr="Kamp and Reyle, 1993" startWordPosition="1831" endWordPosition="1834">t determination task, the “message” is a first order logic formula (a standard representation shared by a large community) which takes into account the user knowledge and whose coherence has been checked. 4 Using SDRT for document structuring We adopt SDRT (Segmented Discourse Representation Theory (Asher, 1993; Asher and Lascarides, 1998)). The reasons for this choice can be found in (Danlos et al., 2001). Let us present SDRT briefly. 4.1 A brief introduction to SDRT SDRT which was designed first for text understanding, was introduced as an extension of DRT (Discourse Representation Theory, (Kamp and Reyle, 1993)) in order to account for specific properties of discourse structure. SDRT can be viewed as a superlayer on DRT whose expressiveness is enhanced by the use of discourse relations. Thus the DRT structures (Discourse Representation Structures or DRS) are handled as basic discourse units in SDRT. DRSs are ”boxed” first order logic formulae. Formally, a DRS is a couple of sets (U,Con). U (the universe) is the set of discourse referents. Con contains the truth conditions representing the meaning of the discourse. A SDRS is a pair (U,Con), see Figure 3. U is a set of labels of DRS or SDRS which can </context>
</contexts>
<marker>Kamp, Reyle, 1993</marker>
<rawString>H. Kamp and U. Reyle. 1993. From Discourse to Logic. Kluwer Academic Publishers, Dordrecht, The Netherlands.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Meunier</author>
<author>R Reyes</author>
</authors>
<title>La plate forme de d´eveloppement de g´en´erateurs de textes CLEF.</title>
<date>1999</date>
<booktitle>In Actes du 2`e Colloque Francophone sur la G´en´eation Automatique de Textes, GAT’99,</booktitle>
<location>Grenoble.</location>
<marker>Meunier, Reyes, 1999</marker>
<rawString>F. Meunier and R. Reyes. 1999. La plate forme de d´eveloppement de g´en´erateurs de textes CLEF. In Actes du 2`e Colloque Francophone sur la G´en´eation Automatique de Textes, GAT’99, Grenoble.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Raffalli</author>
<author>P Roziere</author>
</authors>
<date>2002</date>
<booktitle>The PhoX Proof checker documentation. LAMA, Universit´e de Savoie / Universit´e Paris 7.</booktitle>
<contexts>
<context position="1290" citStr="Raffalli and Roziere, 2002" startWordPosition="217" endWordPosition="220">ption logic for the content determination task and its ouput, a “message”; section 4 justifies the use of SDRT for the document structuring task and its output, a “document plan”; section 5 briefly exposes the use of a lexicalized formalism in the tactical component. Each section is illustrated by means of GePhoX, a generator which produces texts explaining the steps taken by a proof assistant, PhoX. So we start by presenting GePhoX. 2 GePhoX PhoX is an extensible proof assistant based on higher order logic, which was developped to help mathematicians building proofs and teaching mathematics (Raffalli and Roziere, 2002). Like other proof assistants, PhoX works in an interactive way. The user (a mathematician) gives first the theorem to be proved (a goal). PhoX returns a list of subgoals which should be easier to prove than the initial goal. The user enters a command to guide PhoX in choosing or achieving a subgoal. The proof is thus computed top-down from goals to evidences. The user’s commands forma Proof script. PhoX output is a list of successive goals equivalent to a Proof tree. Both the Proof script and PhoX output are difficult to read (even for a mathematician), as the reader can see for him/herself i</context>
</contexts>
<marker>Raffalli, Roziere, 2002</marker>
<rawString>C. Raffalli and P. Roziere, 2002. The PhoX Proof checker documentation. LAMA, Universit´e de Savoie / Universit´e Paris 7.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Reiter</author>
<author>R Dale</author>
</authors>
<title>Building Natural Language Generation Systems.</title>
<date>2000</date>
<publisher>Cambridge University Press.</publisher>
<marker>Reiter, Dale, 2000</marker>
<rawString>E. Reiter and R. Dale. 2000. Building Natural Language Generation Systems. Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Roussarie</author>
</authors>
<title>Un mod`ele th´eorique d’inf´erences de structures s´emantiques et discursives dans le cadre de la g´en´eration automatique de textes. Th`ese de doctorat en linguistique, Universit´e Denis Diderot,</title>
<date>2000</date>
<location>Paris</location>
<contexts>
<context position="14342" citStr="Roussarie, 2000" startWordPosition="2473" endWordPosition="2474">is expressed through a discourse relation; that is the case for condition3 with R1(Ir1, Ir2) ↔ condition3, which means that R1(Ir1, Ir2) must have condition3 among its consequences: no other element is in charge of expressing condition3. To establish discourse relations, the SDRT conditions are reversed. As an illustration, in SDRT for text understanding, there is the Axiom for Narration 2. This axiom states that if Narration holds between two SDRSs Tr1 and Tr2, then the main event (me) of Tr1 happens before the main event of Tr2. For text generation, this axiom is reversed in the rule below (Roussarie, 2000, p. 154). • If k1 and k2 are DRS the main eventualities of which are not states, • and if the me of k1 occurs before the me of k2, • then Narration(Ir1, Ir2) is valid when Ir1 and Ir2 respectively label k1 and k2. As another example, the condition cause(e1, e2) can be expressed through Result(Tr1, Tr2) or Explanation(Tr2, Tr1) when Tr1 and Tr2 label the sub-DRSs that contain the descriptions of e1 and e2 respectively. Let us now examine how we determine the universes of sub-DRSs, i.e. discourse referents, while observing two technical constraints, namely: • the arguments of any condition in a</context>
</contexts>
<marker>Roussarie, 2000</marker>
<rawString>L. Roussarie. 2000. Un mod`ele th´eorique d’inf´erences de structures s´emantiques et discursives dans le cadre de la g´en´eration automatique de textes. Th`ese de doctorat en linguistique, Universit´e Denis Diderot, Paris 7.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>