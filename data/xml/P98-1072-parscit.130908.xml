<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.803505">
Semantic-Head Based Resolution of Scopal Ambiguities*
</title>
<author confidence="0.69411">
Bjorn Gamback
</author>
<note confidence="0.590165875">
Information and
Language Engineering
SICS, Box 1263
S-164 29 Kista, Sweden
Computational Linguistics
University of Helsinki
P.O. Box 4
SF-00014 Helsinki, Finland
</note>
<author confidence="0.918825">
Johan Bos
</author>
<affiliation confidence="0.916525">
Computational Linguistics
University of the Saarland
</affiliation>
<address confidence="0.7649995">
Postfach 15 11 50
D-66041 Saarbriicken, Germany
</address>
<email confidence="0.9669435">
bos@coli.uni-sb.de
gamback@sics.se
</email>
<sectionHeader confidence="0.993236" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.998742090909091">
We introduce an algorithm for scope resolution in
underspecified semantic representations. Scope pref-
erences are suggested on the basis of semantic argu-
ment structure. The major novelty of this approach
is that, while maintaining an (scopally) underspec-
ified semantic representation, we at the same time
suggest a resolution possibility. The algorithm has
been implemented and tested in a large-scale system
and fared quite well: 28% of the utterances were
ambiguous, 80% of these were correctly interpreted,
leaving errors in only 5.7% of the utterance set.
</bodyText>
<sectionHeader confidence="0.998418" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999975176470588">
Scopal ambiguities are problematic for language
processing systems; resolving them might lead
to combinatorial explosion. In applications like
transfer-based machine translation, resolution
can be avoided if transfer takes place at a rep-
resentational level encoding scopal ambiguities.
The key idea is to have a common representa-
tion for all the possible interpretations of an am-
biguous expression, as in Alshawi et al. (1991).
Scopal ambiguities in the source language can
then carry over to the target language. Recent
research has termed this underspecification (see
e.g., Konig and Reyle (1997), Pinkal (1996)).
A problem with underspecification is, how-
ever, that structural restrictions are not en-
coded. Clear scope configurations (preferences)
in the source language are easily lost:
</bodyText>
<listItem confidence="0.99311225">
(1) das pafit auch nicht
that fits also not
&apos;that does not fit either&apos;
(2) ich kanni sie nicht verstehen ei
</listItem>
<footnote confidence="0.488245">
I can you not understand
&apos;I cannot understand you&apos;
</footnote>
<note confidence="0.7615014">
This work was funded by BMBF (German Federal
Ministry of Education, Science, Research, and Technol-
ogy) grant 01 IV 101 R. Thanks to Christian Lieske,
Scott McGlashan, Yoshiki Mori, Manfred Finical, CJ
Rupp, and Karsten Worm for many useful discussions.
</note>
<bodyText confidence="0.999622482758621">
In (1) the focus particle `auch&apos; outscopes the
negation &apos;nicht&apos;. The preferred reading in (2) is
the one where &apos;nicht&apos; has scope over the modal
lann&apos;. In both cases, the syntactic configu-
rational information for German supports the
preferred scoping: the operator with the widest
scope is c-commanding the operator with nar-
row scope. Preserving the suggested scope res-
olution restrictions from the source language
would be necessary for a correct interpretation.
However, the configurational restrictions do not
easily carry over to English; there is no verb
movement in the English sentence of (2), so &apos;not&apos;
does not c-command &apos;can&apos; in this case.
In this paper we focus on the underspecifi-
cation of scope introduced by quantifying noun
phrases, adverbs, and particles. The representa-
tions we will use resembles Underspecified Dis-
course Representation Structures (Reyle, 1993)
and Hole Semantics (Bos, 1996).
Our Underspecified Semantic Representation,
USR, is introduced in Section 2. Section 3 shows
how USRs are built up in a compositional se-
mantics. Section 4 is the main part of the paper.
It introduces an algorithm in which structural
constraints are used to resolve underspecified
scope in USR structures. Section 5 describes an
implementation of the algorithm and evaluates
how well it fares on real dialogue examples.
</bodyText>
<sectionHeader confidence="0.960661" genericHeader="method">
2 Underspecified Semantics: USR
</sectionHeader>
<bodyText confidence="0.9884675">
The representation we will use, USR, is a ter-
tiary term containing the following pieces of se-
mantic information: a top label, a set of labeled
conditions, and a set of constraints. The condi-
tions represent ordinary predicates, quantifiers,
pronouns, operators, etc., all being uniquely la-
beled, making it easier to refer to a particular
condition. Scope (appearing in quantifiers and
operators) is represented in an underspecified
way by variables (&amp;quot;holes&amp;quot;) ranging over labels.
</bodyText>
<page confidence="0.999028">
433
</page>
<bodyText confidence="0.999792857142857">
Labels are written as In, holes as hâ€ž, and vari-
ables over individuals as in. The labelling allows
us to state meta-level constraints on the rela-
tions between conditions. A constraint 1 &lt; h is
a relation between a label and a hole: 1 is either
equal to or subordinated to h (the labeled con-
dition is within the scope denoted by the hole).
</bodyText>
<equation confidence="0.977656285714286">
11 : decl(hi),
12 : pron(ii),
13 : passen(i2,i1),
14 : auch(h2),
15 : nicht(h3),
16 : group(12,13)
(top) (conditions) (constraints)
</equation>
<figureCaption confidence="0.803269555555556">
Figure 1: The USR for Vas pait auch nicht&apos;.
Fig. 1 shows the USR for (1). The top label
introduces the entire structure and points to the
declarative sentence mood operator, outscop-
ing all other elements. The pronoun Vas&apos; is
pron, marking unresolved anaphora. `auch&apos; and
&apos;nicht&apos; are handled as operators. The verb con-
dition (passen) and its pronoun subject are in
the same scope unit, represented by a grouping.
</figureCaption>
<bodyText confidence="0.991373166666667">
The first three constraints state that neither
the verb, nor the two particles outscope the
mood operator. The last two put the verb in-
formation in the scope of the particles. (NB: no
restrictions are placed on the particles&apos; relative
scope.) Fig. 2 shows the subordination relations.
</bodyText>
<equation confidence="0.883630333333333">
li:decl(hi
14:auch(h2) &lt; 15:nicht h3)
16:
</equation>
<figureCaption confidence="0.980535">
Figure 2: Scopal relations in the USR.
</figureCaption>
<bodyText confidence="0.9999638">
A USR is interpreted with respect to a &amp;quot;plug-
ging&amp;quot;, a mapping from holes to labels (Bos,
1996). The number of readings the USR encodes
equals the number of possible pluggings. Here,
two pluggings do not violate the &lt; constraints:
</bodyText>
<equation confidence="0.9961075">
th1 = 14, h2 = 15 h3 = 16
h1 = 15 h2 = 16 h3 = 14
</equation>
<bodyText confidence="0.999367083333333">
The plugging in (3) resembles the reading where
`auch&apos; outscopes &apos;nicht&apos;: the label for &apos;nicht&apos;, 15,
is taken to &amp;quot;plug&amp;quot; the hole for `auch&apos;, h2, while
`auch&apos; (14) is plugging the top hole of the sen-
tence, h1. In contrast, the plugging in (4) gives
the reading where the negation has wide scope.
With a plugging, a USR can be translated
to a Discourse Representation Structure, DRS
(Kamp and Reyle, 1993): a pron condition in-
troduces a discourse marker which should be
linked to an antecedent, group is a merge be-
tween DRSs, passen a one place predicate, etc.
</bodyText>
<subsectionHeader confidence="0.606684">
3 Construction of USRs
</subsectionHeader>
<bodyText confidence="0.999986151515151">
In addition to underspecification, we let two
other principles guide the semantic construc-
tion: lexicalization (keep as much as possible of
the semantics lexicalized) and compositionality
(a phrase&apos;s interpretation is a function of its sub-
phrases&apos; interpretations). The grammar rules al-
low for addition of already manifest information
(e.g., from the lexicon) and three ways of pass-
ing non-manifest information (e.g., about com-
plements sought): trivial composition, functor-
argument and modifier-argument application.
Trivial composition occurs in grammar rules
which are semantically unary branching, i.e., the
semantics of at the most one of the daughter
(right-hand side) nodes need to influence the in-
terpretation of the mother (left-hand side) node.
The application type rules appear on se-
mantically binary branching rules: In functor-
argument application the bulk of the semantic
information is passed between the mother node
and the functor (semantic head). In modifier-
argument application the argument is the se-
mantic head, so most information is passed up
from that. (Most notably, the label identifying
the entire structure will be the one of the head
daughter. We will refer to it as the main label.)
The difference between the two application
types pertains to the (semantic) subcategoriza-
tion schemes: In functor-argument application
(5), the functor subcategorizes for the argument,
the argument may optionally subcategorize for
the functor, and the mother&apos;s subcategorization
list is the functor&apos;s, minus the argument:
</bodyText>
<figure confidence="0.76022475">
Mother
(5) r main-label
subcat
r main-label le 1
subcat (ala)
Functor (head) r main-label U1
subcat (a) V ( )
Argument (nonhead)
</figure>
<bodyText confidence="0.9995075">
In modifier-argument application (6), Modi-
fier subcategorizes for Argument (only), while
Argument does not subcategorize for Modifier.
Its subcat list is passed unchanged to Mother.
</bodyText>
<figure confidence="0.994541625">
1
14 &lt; h1,
&lt;
{ 16 &lt; h1 , )
16 &lt;h2,
16 &lt; h3
13 :passen
12 :pron
</figure>
<page confidence="0.732336">
434
</page>
<equation confidence="0.362126333333333">
Argument (head)
r main-label Label&apos; 1 main-label
subcat (111) j L subcat
</equation>
<sectionHeader confidence="0.861941" genericHeader="method">
4 A Resolution Algorithm
</sectionHeader>
<bodyText confidence="0.998974470588235">
Previous approaches to scopal resolution have
mainly been treating the scopal constraints sep-
arately from the rest of the semantic structure
and argued that contextual information must be
taken into account for correct resolution. How-
ever, the SRI Core Language Engine used a
straight-forward approach (Moran and Pereira,
1992). Variables for the unresolved scoped were
asserted at the lexical level together with some
constraints on the resolution. Constraints could
also be added in grammar rules, albeit in a
somewhat ad hoc manner. Most of the sco-
pal resolution constraints were, though, pro-
vided by a separate knowledge-base specifying
the inter-relation of different scope-bearing op-
erators. The constraints were applied in a pro-
cess subsequent to the semantic construction.
</bodyText>
<subsectionHeader confidence="0.988304">
4.1 Lexical entries
</subsectionHeader>
<bodyText confidence="0.954596277777778">
In contrast, we want to be able to capture
the constraints already given by the function-
argument structure of an utterance and provide
a possible resolution of the scopal ambiguities.
This resolution should be built up during the
construction of (the rest of) the semantic repre-
sentation. Thus we introduce a set of features
(called holeinfo) on each grammatical category.
On terminals, the features in this set will nor-
mally have the values shown in (7), indicating
that the category does not contain a hole (isa-
hole has the value no), i.e., it is a nonscope-
bearing element. sb-label, the semantic-head
based resolution label, is the label of the element
of the substructure below it having widest scope.
In the lexicon, it is the entry&apos;s own main label.
[sb-lab el MainLabel
holeinfo
</bodyText>
<equation confidence="0.434949">
(7) isa-hole no
</equation>
<bodyText confidence="0.947634333333333">
hole no
Scope-bearing categories (quantifiers, parti-
cles, etc.) introduce holes and get the feature
setting of (8). The feature hole points to the
hole introduced. (Finite verbs are also treated
this way: they are assumed to introduce a hole
for the scope of the sentence mood operator.)
[sb- lab el
holeinfo
</bodyText>
<listItem confidence="0.5960945">
(8) isa-hole
hole
</listItem>
<subsectionHeader confidence="0.988812">
4.2 Grammar rules
</subsectionHeader>
<bodyText confidence="0.999855823529412">
When the holeinfo information is built up in the
analysis tree, the sb-labels are passed up as the
main labels (i.e., from the semantic head daugh-
ter to the mother node), unless the nonhead
daughter of a binary branching node contains
a hole. In that case, the hole is plugged with
the sb-label of the head daughter and the sb-
label of the mother node is that of the nonhead
daughter. The effect being that a scope-bearing
nonhead daughter is given scope over the head
daughter. On the top-most level of the gram-
mar, the hole of the sentence mood operator is
plugged with the sb-label of the full structure.
Concretely, grammar rules of both application
types pass holeinfo as follows. If the nonhead
daughter does not contain a hole, holeinfo is
unchanged from head daughter to mother node:
</bodyText>
<figure confidence="0.6060335">
Mother
(9) [ holeinfo
Head
[ holeinfo
</figure>
<bodyText confidence="0.999722">
However, if the nonhead daughter does con-
tain a hole, it is plugged with the sb-label of the
head daughter and the mother node gets its sb-
label from the nonhead daughter. The rest of
the holeinfo still come from the head daughter:
</bodyText>
<figure confidence="0.941259">
Mother
sb-label 1
hole ]
isa-hole 2
3
Head Nonhead
[ sb-lab el HeadLabel sb- lab el
isa-hole El
hole
isa-hole yes
hole
Hole
</figure>
<bodyText confidence="0.999294">
The hole to be plugged is here identified by
the hole feature of the nonhead daughter. To
show the preferred scopal resolution, a relation
&apos;Hole =sb HeadLabel&apos;, a semantic-head based
plugging, is introduced into the USR.
</bodyText>
<subsectionHeader confidence="0.999135">
4.3 Resolution Example
</subsectionHeader>
<bodyText confidence="0.999874285714286">
We will illustrate the rules with an example.
The utterance (1) &apos;clas pat auch nicht&apos; has the
semantic argument structure shown in Fig. 3,
where Node[L, H] stands for the node Node hav-
ing an sb-label L and hole feature value H.
The verb passen is first applied to the subject
`das&apos;. The sb-label of `passen&apos; is its main label
</bodyText>
<figure confidence="0.998882">
(a) I
Modifier (nonhead)
Mother
(6) r main-label
L subcat
MainLabel ]]
yes
Hole
Nonhead
[ holeinfo [isa-hole no
</figure>
<page confidence="0.998977">
435
</page>
<bodyText confidence="0.9999685">
(the grouping label 16). Its hole feature points
to h1, the mood operator&apos;s scope unit. The pro-
noun contains no hole (is nonscope-bearing), so
we have the first case above, rule (9), in which
the mother node&apos;s holeinfo is identical to that
of the head daughter, as indicated in the figure.
</bodyText>
<equation confidence="0.761976">
[14 ,h1]
auch[14,h2]
nicht[15,h3] S[16,h1]
das[12,no] passen[16,h1J
</equation>
<figureCaption confidence="0.990619">
Figure 3: Semantic argument structure
</figureCaption>
<bodyText confidence="0.969269444444445">
Next, the modifier &apos;nicht&apos; is applied to the ver-
bal structure, giving the case with the nonhead
daughter containing a hole, rule (10). For this
hole we add a &apos;113 =sb 16&apos; to the USR: The la-
bel plugging the hole is the sb-label of the head
daughter. The sb-label of the resulting struc-
ture is 15, the sb-label of the modifier. The pro-
cess is repeated for `auch&apos; so that its hole, h2, is
plugged with 15, the label of its argument. We
have reached the end of the analysis and h1, the
remaining hole of the entire structure is plugged
by the structure&apos;s sb-label, which is now 14. In
total, three semantic-head based plugging con-
straints are added to the USR in Fig. 1:
(11) h1 :=8b 14, h2 =--sb 15, hs 7----sb 16
Giving a scope preference corresponding to the
plugging (3), the reading with auch outscoping
nicht, resulting in the correct interpretation.
</bodyText>
<subsectionHeader confidence="0.999203">
4.4 Coordination
</subsectionHeader>
<bodyText confidence="0.999939142857143">
Sentence coordinations, discourse relation ad-
verbs, and the like add a special case. These
categories force the scopal elements of their sen-
tential complements to be resolved locally, or in
other words, introduce a new hole which should
be above the top holes of both complements.
They get the lexical setting
</bodyText>
<figure confidence="0.3808405">
[[ sb-label MainLabel
holeinfo I]
(12) isa-hole island
hole Hole
</figure>
<bodyText confidence="0.992863">
So, isa-hole indicates which type of hole a
structure contains. The values are no, yes,
and island. island is used to override the ar-
gument structure to produce a plugging where
the top holes of the sentential complements get
plugged with their own sb-labels. This compli-
cates the implementation of rules (9) and (10)
a bit; they must also account for the fact that a
daughter node may carry an island type hole.
</bodyText>
<sectionHeader confidence="0.957674" genericHeader="evaluation">
5 Implementation and Evaluation
</sectionHeader>
<bodyText confidence="0.999947903225806">
The resolution algorithm described in Section 4
has been implemented in Verbmobil, a system
which translates spoken German and Japanese
into English (Bub et al., 1997). The under-
specified semantic representation technique we
have used in this paper reflects the core seman-
tic part of the Verbmobil Interface Term, VIT
(Bos et al., 1998). The aim of VIT is to de-
scribe a consistent interface structure between
the different language analysis modules within
Verbmobil. Thus, in contrast to our USR, VIT
is a representation that encodes all the linguistic
information of an utterance; in addition to the
USR semantic structure of Sectiom 2, the Verb-
mobil Interface Term contains prosodic, syntac-
tic, and discourse related information.
In order to evaluate the algorithm, the results
of the pluggings obtained for four dialogues in
the Verbmobil test set were checked (Table 1).
We only consider utterances for which the
VITs contain more than two holes: The num-
ber of scope-bearing operators is the number of
holes minus one. Thus, a VIT with one hole only
trivially contains the top hole of the utterance
(i.e., the hole for the sentence mood predicate;
introduced by the main verb).
A VIT with two holes contains the top hole
and the hole for one scope-taking element. How-
ever, the mood-predicate will always have scope
over the remaining proposition, so resolution is
still trivial.
</bodyText>
<tableCaption confidence="0.999225">
Table 1: Results of evaluation
</tableCaption>
<table confidence="0.999120142857143">
Dial. Utt. # Correct utt. / # holes
Id. &lt;2 3 4 &gt;5
B1 48 34 9/11 1/2 1/1 79
B2 41 26 5/8 2/3 4/4 73
B7 48 36 7/8 0/1 3/3 83
RHQ1 91 68 10/11 5/6 4/6 83
Total 228 164 31/38 8/12 12/14 80
</table>
<bodyText confidence="0.6147934">
The dialogues evaluated are identified as three of the
&amp;quot;Blaubeuren&amp;quot; dialogues (B1, B2, and B7) and one of
the &amp;quot;Reithinger-Herweg-Quantz&amp;quot; dialogues (RHQ1).
These four together form the standard test-set for the
German language modules of the Verbmobil system.
</bodyText>
<figure confidence="0.559749">
S[15,111]
</figure>
<page confidence="0.997223">
436
</page>
<bodyText confidence="0.999984775">
For VITs with three or more holes, we have
true ambiguities. Column 3 gives the number
of utterances with no ambiguity (&lt; 2 holes),
the columns following look at the ambiguous
sentences. Most commonly the utterances con-
tained one true ambiguity (3 holes, as in Fig. 2).
Utterances with more than two ambiguities (&gt; 5
holes) are rare and have been grouped together.
Even though the algorithm is fairly straight-
forward, resolution based on semantic argument
structure fares quite well. Only 64 (28%) of the
228 utterances are truely ambiguous (i.e., con-
tain more than two holes). The default scoping
introduced by the algorithm is the preferred one
for 80% of the ambiguous utterances, leaving er-
rors in just 13 (5.7%) of the utterances overall.
Looking closer at these cases, the reasons for
the failures divide as: the relative scope of two
particles did not conform to the c-command
structure assigned by syntax (one case); an in-
definite noun phrase should have received wide
scope (3), or narrow scope (1); an adverb should
have had wide scope (3); combination of (a
modal) verb movement and negated question
(1); technical construction problem in VIT (4).
The resolution algorithm has been imple-
mented in Verbmobil in both the German se-
mantic processing (Bos et al., 1996) and the
(substantially smaller) Japanese one (Gamback
et al., 1996). Evaluating the performance of
the resolution algorithm on the standard test
suite for the Japanese parts of Verbmobil (the
&amp;quot;RDS1&amp;quot; reference dialogue), we found that only
7 of the 36 sentences in the dialogue contained
more than two holes. All but one of the ambi-
guities were correctly resolved by the algorithm.
Even though the number of sentences tested cer-
tainly is too small to draw any real conclusions
from, the correctness rate still indicates that the
algorithm is applicable also to Japanese.
</bodyText>
<sectionHeader confidence="0.999743" genericHeader="conclusions">
6 Conclusions
</sectionHeader>
<bodyText confidence="0.99999575">
We have presented an algorithm for scope res-
olution in underspecified semantic representa-
tions. Scope preferences are suggested on the
basis of semantic argument structure, letting
the nonhead daughter node outscope the head
daughter in case both daughter nodes are scope-
bearing. The algorithm was evaluated on four
&amp;quot;real-life&amp;quot; dialogues and fared quite well: about
80% of the utterances containing scopal ambi-
guities were correctly interpreted by the sug-
gested resolution, leaving scopal resolution er-
rors in only 5.7% of the overall utterances.
The algorithm is computationally cheap and
quite straight-forward, yet its predictions are
relatively accurate. Our results indicate that
for a practical system, more sophisticated ap-
proaches to scopal resolution (i.e., based on
the relations between different scope-bearing el-
ements and/or contextual information) will not
add much to the overall system performance.
</bodyText>
<sectionHeader confidence="0.998906" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999813142857143">
Alshawi H., D.M. Carter, B. Gamback, and M.
Rayner. 1991. Translation by quasi logical form
transfer. Proc. 29th ACL, pp. 161-168, University
of California, Berkeley.
Bos J. 1996. Predicate logic unplugged. Proc. 10th
Amsterdam Colloquium, pp. 133-142, University
of Amsterdam, Holland.
Bos J., B. Gamb5,ck, C. Lieske, Y. Mori, M. Pinlcal,
and K. Worm. 1996. Compositional semantics in
Verbmobil. Proc. 16th COLING, vol. 1, pp. 131-
136, Kobenhavn, Denmark.
Bos J., B. Buschbeck-Wolf, M. Dorna, and C.J.
Rupp 1998. Managing information at linguistic
interfaces. Proc. 17th COLING and 36th ACL,
Montreal, Canada.
Bub T., W. Wahlster, and A. Waibel. 1997. Verb-
mobil: The combination of deep and shallow pro-
cessing for spontaneous speech translation. Proc.
Int. Conf. on Acoustics, Speech and Signal Pro-
cessing, pp. 71-74, MÃ¼nchen, Germany.
Gamback B., C. Lieske, and Y. Mori. 1996. Under-
specified Japanese semantics in a machine trans-
lation system. Proc. 11th Pacific Asia Conf. on
Language, Information and Computation, pp. 53-
62, Seoul, Korea.
Kamp H. and U. Reyle. 1993. From Discourse to
Logic. Kluwer, Dordrecht, Holland.
Kiinig E. and U. Reyle. 1997. A general reason-
ing scheme for underspecified representations. In
H. J. Ohlbach and U. Reyle, eds, Logic and its
Applications. Festschrift for Dov Gabbay. Part I.
Kluwer, Dordrecht, Holland.
Moran D.B. and F.C.N. Pereira. 1992. Quanti-
fier scoping. In Alshawi H., ed. The Core Lan-
guage Engine. The MIT Press, Cambridge, Mas-
sachusetts, pp. 149-172.
Pinkal M. 1996. Radical underspecification. Proc.
10th Amsterdam Colloquium, pp. 587-606, Uni-
versity of Amsterdam, Holland.
Reyle U. 1993. Dealing with ambiguities by under-
specification: Construction, representation and
deduction. Journal of Semantics, 10:123-179.
</reference>
<page confidence="0.998633">
437
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.433447">
<title confidence="0.998932">Semantic-Head Based Resolution of Scopal Ambiguities*</title>
<author confidence="0.994622">Bjorn Gamback</author>
<affiliation confidence="0.811539">Information and Language Engineering</affiliation>
<address confidence="0.9658765">SICS, Box 1263 S-164 29 Kista, Sweden</address>
<affiliation confidence="0.9906525">Computational Linguistics University of Helsinki</affiliation>
<address confidence="0.986369">P.O. Box 4 SF-00014 Helsinki, Finland</address>
<author confidence="0.998903">Johan Bos</author>
<affiliation confidence="0.997605">Computational Linguistics University of the Saarland</affiliation>
<address confidence="0.924304">Postfach 15 11 50 D-66041 Saarbriicken, Germany</address>
<email confidence="0.940404">bos@coli.uni-sb.degamback@sics.se</email>
<abstract confidence="0.994227666666667">We introduce an algorithm for scope resolution in underspecified semantic representations. Scope preferences are suggested on the basis of semantic argument structure. The major novelty of this approach is that, while maintaining an (scopally) underspecified semantic representation, we at the same time suggest a resolution possibility. The algorithm has been implemented and tested in a large-scale system and fared quite well: 28% of the utterances were ambiguous, 80% of these were correctly interpreted, leaving errors in only 5.7% of the utterance set.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>H Alshawi</author>
<author>D M Carter</author>
<author>B Gamback</author>
<author>M Rayner</author>
</authors>
<title>Translation by quasi logical form transfer.</title>
<date>1991</date>
<booktitle>Proc. 29th ACL,</booktitle>
<pages>161--168</pages>
<institution>University of California, Berkeley.</institution>
<contexts>
<context position="1385" citStr="Alshawi et al. (1991)" startWordPosition="194" endWordPosition="197">sted in a large-scale system and fared quite well: 28% of the utterances were ambiguous, 80% of these were correctly interpreted, leaving errors in only 5.7% of the utterance set. 1 Introduction Scopal ambiguities are problematic for language processing systems; resolving them might lead to combinatorial explosion. In applications like transfer-based machine translation, resolution can be avoided if transfer takes place at a representational level encoding scopal ambiguities. The key idea is to have a common representation for all the possible interpretations of an ambiguous expression, as in Alshawi et al. (1991). Scopal ambiguities in the source language can then carry over to the target language. Recent research has termed this underspecification (see e.g., Konig and Reyle (1997), Pinkal (1996)). A problem with underspecification is, however, that structural restrictions are not encoded. Clear scope configurations (preferences) in the source language are easily lost: (1) das pafit auch nicht that fits also not &apos;that does not fit either&apos; (2) ich kanni sie nicht verstehen ei I can you not understand &apos;I cannot understand you&apos; This work was funded by BMBF (German Federal Ministry of Education, Science, </context>
</contexts>
<marker>Alshawi, Carter, Gamback, Rayner, 1991</marker>
<rawString>Alshawi H., D.M. Carter, B. Gamback, and M. Rayner. 1991. Translation by quasi logical form transfer. Proc. 29th ACL, pp. 161-168, University of California, Berkeley.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Bos</author>
</authors>
<title>Predicate logic unplugged.</title>
<date>1996</date>
<booktitle>Proc. 10th Amsterdam Colloquium,</booktitle>
<pages>133--142</pages>
<institution>University of Amsterdam,</institution>
<location>Holland.</location>
<contexts>
<context position="3068" citStr="Bos, 1996" startWordPosition="460" endWordPosition="461">ding the operator with narrow scope. Preserving the suggested scope resolution restrictions from the source language would be necessary for a correct interpretation. However, the configurational restrictions do not easily carry over to English; there is no verb movement in the English sentence of (2), so &apos;not&apos; does not c-command &apos;can&apos; in this case. In this paper we focus on the underspecification of scope introduced by quantifying noun phrases, adverbs, and particles. The representations we will use resembles Underspecified Discourse Representation Structures (Reyle, 1993) and Hole Semantics (Bos, 1996). Our Underspecified Semantic Representation, USR, is introduced in Section 2. Section 3 shows how USRs are built up in a compositional semantics. Section 4 is the main part of the paper. It introduces an algorithm in which structural constraints are used to resolve underspecified scope in USR structures. Section 5 describes an implementation of the algorithm and evaluates how well it fares on real dialogue examples. 2 Underspecified Semantics: USR The representation we will use, USR, is a tertiary term containing the following pieces of semantic information: a top label, a set of labeled cond</context>
<context position="5345" citStr="Bos, 1996" startWordPosition="839" endWordPosition="840">auch&apos; and &apos;nicht&apos; are handled as operators. The verb condition (passen) and its pronoun subject are in the same scope unit, represented by a grouping. The first three constraints state that neither the verb, nor the two particles outscope the mood operator. The last two put the verb information in the scope of the particles. (NB: no restrictions are placed on the particles&apos; relative scope.) Fig. 2 shows the subordination relations. li:decl(hi 14:auch(h2) &lt; 15:nicht h3) 16: Figure 2: Scopal relations in the USR. A USR is interpreted with respect to a &amp;quot;plugging&amp;quot;, a mapping from holes to labels (Bos, 1996). The number of readings the USR encodes equals the number of possible pluggings. Here, two pluggings do not violate the &lt; constraints: th1 = 14, h2 = 15 h3 = 16 h1 = 15 h2 = 16 h3 = 14 The plugging in (3) resembles the reading where `auch&apos; outscopes &apos;nicht&apos;: the label for &apos;nicht&apos;, 15, is taken to &amp;quot;plug&amp;quot; the hole for `auch&apos;, h2, while `auch&apos; (14) is plugging the top hole of the sentence, h1. In contrast, the plugging in (4) gives the reading where the negation has wide scope. With a plugging, a USR can be translated to a Discourse Representation Structure, DRS (Kamp and Reyle, 1993): a pron co</context>
</contexts>
<marker>Bos, 1996</marker>
<rawString>Bos J. 1996. Predicate logic unplugged. Proc. 10th Amsterdam Colloquium, pp. 133-142, University of Amsterdam, Holland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Bos</author>
<author>B Gamb5</author>
<author>C Lieske ck</author>
<author>Y Mori</author>
<author>M Pinlcal</author>
<author>K Worm</author>
</authors>
<date>1996</date>
<booktitle>Compositional semantics in Verbmobil. Proc. 16th COLING,</booktitle>
<volume>1</volume>
<pages>131--136</pages>
<location>Kobenhavn, Denmark.</location>
<marker>Bos, Gamb5, ck, Mori, Pinlcal, Worm, 1996</marker>
<rawString>Bos J., B. Gamb5,ck, C. Lieske, Y. Mori, M. Pinlcal, and K. Worm. 1996. Compositional semantics in Verbmobil. Proc. 16th COLING, vol. 1, pp. 131-136, Kobenhavn, Denmark.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Bos</author>
<author>B Buschbeck-Wolf</author>
<author>M Dorna</author>
<author>C J Rupp</author>
</authors>
<title>Managing information at linguistic interfaces.</title>
<date>1998</date>
<booktitle>Proc. 17th COLING and 36th ACL,</booktitle>
<location>Montreal, Canada.</location>
<contexts>
<context position="14361" citStr="Bos et al., 1998" startWordPosition="2351" endWordPosition="2354">lugging where the top holes of the sentential complements get plugged with their own sb-labels. This complicates the implementation of rules (9) and (10) a bit; they must also account for the fact that a daughter node may carry an island type hole. 5 Implementation and Evaluation The resolution algorithm described in Section 4 has been implemented in Verbmobil, a system which translates spoken German and Japanese into English (Bub et al., 1997). The underspecified semantic representation technique we have used in this paper reflects the core semantic part of the Verbmobil Interface Term, VIT (Bos et al., 1998). The aim of VIT is to describe a consistent interface structure between the different language analysis modules within Verbmobil. Thus, in contrast to our USR, VIT is a representation that encodes all the linguistic information of an utterance; in addition to the USR semantic structure of Sectiom 2, the Verbmobil Interface Term contains prosodic, syntactic, and discourse related information. In order to evaluate the algorithm, the results of the pluggings obtained for four dialogues in the Verbmobil test set were checked (Table 1). We only consider utterances for which the VITs contain more t</context>
</contexts>
<marker>Bos, Buschbeck-Wolf, Dorna, Rupp, 1998</marker>
<rawString>Bos J., B. Buschbeck-Wolf, M. Dorna, and C.J. Rupp 1998. Managing information at linguistic interfaces. Proc. 17th COLING and 36th ACL, Montreal, Canada.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Bub</author>
<author>W Wahlster</author>
<author>A Waibel</author>
</authors>
<title>Verbmobil: The combination of deep and shallow processing for spontaneous speech translation.</title>
<date>1997</date>
<booktitle>Proc. Int. Conf. on Acoustics, Speech and Signal Processing,</booktitle>
<pages>71--74</pages>
<location>MÃ¼nchen, Germany.</location>
<contexts>
<context position="14192" citStr="Bub et al., 1997" startWordPosition="2323" endWordPosition="2326">Hole So, isa-hole indicates which type of hole a structure contains. The values are no, yes, and island. island is used to override the argument structure to produce a plugging where the top holes of the sentential complements get plugged with their own sb-labels. This complicates the implementation of rules (9) and (10) a bit; they must also account for the fact that a daughter node may carry an island type hole. 5 Implementation and Evaluation The resolution algorithm described in Section 4 has been implemented in Verbmobil, a system which translates spoken German and Japanese into English (Bub et al., 1997). The underspecified semantic representation technique we have used in this paper reflects the core semantic part of the Verbmobil Interface Term, VIT (Bos et al., 1998). The aim of VIT is to describe a consistent interface structure between the different language analysis modules within Verbmobil. Thus, in contrast to our USR, VIT is a representation that encodes all the linguistic information of an utterance; in addition to the USR semantic structure of Sectiom 2, the Verbmobil Interface Term contains prosodic, syntactic, and discourse related information. In order to evaluate the algorithm,</context>
</contexts>
<marker>Bub, Wahlster, Waibel, 1997</marker>
<rawString>Bub T., W. Wahlster, and A. Waibel. 1997. Verbmobil: The combination of deep and shallow processing for spontaneous speech translation. Proc. Int. Conf. on Acoustics, Speech and Signal Processing, pp. 71-74, MÃ¼nchen, Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Gamback</author>
<author>C Lieske</author>
<author>Y Mori</author>
</authors>
<title>Underspecified Japanese semantics in a machine translation system.</title>
<date>1996</date>
<booktitle>Proc. 11th Pacific Asia Conf. on Language, Information and Computation,</booktitle>
<pages>53--62</pages>
<location>Seoul,</location>
<contexts>
<context position="17240" citStr="Gamback et al., 1996" startWordPosition="2841" endWordPosition="2844">e utterances overall. Looking closer at these cases, the reasons for the failures divide as: the relative scope of two particles did not conform to the c-command structure assigned by syntax (one case); an indefinite noun phrase should have received wide scope (3), or narrow scope (1); an adverb should have had wide scope (3); combination of (a modal) verb movement and negated question (1); technical construction problem in VIT (4). The resolution algorithm has been implemented in Verbmobil in both the German semantic processing (Bos et al., 1996) and the (substantially smaller) Japanese one (Gamback et al., 1996). Evaluating the performance of the resolution algorithm on the standard test suite for the Japanese parts of Verbmobil (the &amp;quot;RDS1&amp;quot; reference dialogue), we found that only 7 of the 36 sentences in the dialogue contained more than two holes. All but one of the ambiguities were correctly resolved by the algorithm. Even though the number of sentences tested certainly is too small to draw any real conclusions from, the correctness rate still indicates that the algorithm is applicable also to Japanese. 6 Conclusions We have presented an algorithm for scope resolution in underspecified semantic repr</context>
</contexts>
<marker>Gamback, Lieske, Mori, 1996</marker>
<rawString>Gamback B., C. Lieske, and Y. Mori. 1996. Underspecified Japanese semantics in a machine translation system. Proc. 11th Pacific Asia Conf. on Language, Information and Computation, pp. 53-62, Seoul, Korea.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Kamp</author>
<author>U Reyle</author>
</authors>
<date>1993</date>
<booktitle>From Discourse to Logic.</booktitle>
<publisher>Kluwer,</publisher>
<location>Dordrecht, Holland.</location>
<contexts>
<context position="5934" citStr="Kamp and Reyle, 1993" startWordPosition="948" endWordPosition="951">from holes to labels (Bos, 1996). The number of readings the USR encodes equals the number of possible pluggings. Here, two pluggings do not violate the &lt; constraints: th1 = 14, h2 = 15 h3 = 16 h1 = 15 h2 = 16 h3 = 14 The plugging in (3) resembles the reading where `auch&apos; outscopes &apos;nicht&apos;: the label for &apos;nicht&apos;, 15, is taken to &amp;quot;plug&amp;quot; the hole for `auch&apos;, h2, while `auch&apos; (14) is plugging the top hole of the sentence, h1. In contrast, the plugging in (4) gives the reading where the negation has wide scope. With a plugging, a USR can be translated to a Discourse Representation Structure, DRS (Kamp and Reyle, 1993): a pron condition introduces a discourse marker which should be linked to an antecedent, group is a merge between DRSs, passen a one place predicate, etc. 3 Construction of USRs In addition to underspecification, we let two other principles guide the semantic construction: lexicalization (keep as much as possible of the semantics lexicalized) and compositionality (a phrase&apos;s interpretation is a function of its subphrases&apos; interpretations). The grammar rules allow for addition of already manifest information (e.g., from the lexicon) and three ways of passing non-manifest information (e.g., abo</context>
</contexts>
<marker>Kamp, Reyle, 1993</marker>
<rawString>Kamp H. and U. Reyle. 1993. From Discourse to Logic. Kluwer, Dordrecht, Holland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Kiinig</author>
<author>U Reyle</author>
</authors>
<title>A general reasoning scheme for underspecified representations. In</title>
<date>1997</date>
<publisher>Kluwer,</publisher>
<location>Dordrecht, Holland.</location>
<marker>Kiinig, Reyle, 1997</marker>
<rawString>Kiinig E. and U. Reyle. 1997. A general reasoning scheme for underspecified representations. In H. J. Ohlbach and U. Reyle, eds, Logic and its Applications. Festschrift for Dov Gabbay. Part I. Kluwer, Dordrecht, Holland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D B Moran</author>
<author>F C N Pereira</author>
</authors>
<title>Quantifier scoping.</title>
<date>1992</date>
<booktitle>In Alshawi H., ed. The Core Language Engine. The</booktitle>
<pages>149--172</pages>
<publisher>MIT Press,</publisher>
<location>Cambridge, Massachusetts,</location>
<contexts>
<context position="8448" citStr="Moran and Pereira, 1992" startWordPosition="1342" endWordPosition="1345">categorizes for Argument (only), while Argument does not subcategorize for Modifier. Its subcat list is passed unchanged to Mother. 1 14 &lt; h1, &lt; { 16 &lt; h1 , ) 16 &lt;h2, 16 &lt; h3 13 :passen 12 :pron 434 Argument (head) r main-label Label&apos; 1 main-label subcat (111) j L subcat 4 A Resolution Algorithm Previous approaches to scopal resolution have mainly been treating the scopal constraints separately from the rest of the semantic structure and argued that contextual information must be taken into account for correct resolution. However, the SRI Core Language Engine used a straight-forward approach (Moran and Pereira, 1992). Variables for the unresolved scoped were asserted at the lexical level together with some constraints on the resolution. Constraints could also be added in grammar rules, albeit in a somewhat ad hoc manner. Most of the scopal resolution constraints were, though, provided by a separate knowledge-base specifying the inter-relation of different scope-bearing operators. The constraints were applied in a process subsequent to the semantic construction. 4.1 Lexical entries In contrast, we want to be able to capture the constraints already given by the functionargument structure of an utterance and</context>
</contexts>
<marker>Moran, Pereira, 1992</marker>
<rawString>Moran D.B. and F.C.N. Pereira. 1992. Quantifier scoping. In Alshawi H., ed. The Core Language Engine. The MIT Press, Cambridge, Massachusetts, pp. 149-172.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Pinkal</author>
</authors>
<title>Radical underspecification.</title>
<date>1996</date>
<booktitle>Proc. 10th Amsterdam Colloquium,</booktitle>
<pages>587--606</pages>
<institution>University of Amsterdam,</institution>
<location>Holland.</location>
<contexts>
<context position="1572" citStr="Pinkal (1996)" startWordPosition="224" endWordPosition="225">Scopal ambiguities are problematic for language processing systems; resolving them might lead to combinatorial explosion. In applications like transfer-based machine translation, resolution can be avoided if transfer takes place at a representational level encoding scopal ambiguities. The key idea is to have a common representation for all the possible interpretations of an ambiguous expression, as in Alshawi et al. (1991). Scopal ambiguities in the source language can then carry over to the target language. Recent research has termed this underspecification (see e.g., Konig and Reyle (1997), Pinkal (1996)). A problem with underspecification is, however, that structural restrictions are not encoded. Clear scope configurations (preferences) in the source language are easily lost: (1) das pafit auch nicht that fits also not &apos;that does not fit either&apos; (2) ich kanni sie nicht verstehen ei I can you not understand &apos;I cannot understand you&apos; This work was funded by BMBF (German Federal Ministry of Education, Science, Research, and Technology) grant 01 IV 101 R. Thanks to Christian Lieske, Scott McGlashan, Yoshiki Mori, Manfred Finical, CJ Rupp, and Karsten Worm for many useful discussions. In (1) the </context>
</contexts>
<marker>Pinkal, 1996</marker>
<rawString>Pinkal M. 1996. Radical underspecification. Proc. 10th Amsterdam Colloquium, pp. 587-606, University of Amsterdam, Holland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>U Reyle</author>
</authors>
<title>Dealing with ambiguities by underspecification: Construction, representation and deduction.</title>
<date>1993</date>
<journal>Journal of Semantics,</journal>
<pages>10--123</pages>
<contexts>
<context position="3037" citStr="Reyle, 1993" startWordPosition="455" endWordPosition="456">with the widest scope is c-commanding the operator with narrow scope. Preserving the suggested scope resolution restrictions from the source language would be necessary for a correct interpretation. However, the configurational restrictions do not easily carry over to English; there is no verb movement in the English sentence of (2), so &apos;not&apos; does not c-command &apos;can&apos; in this case. In this paper we focus on the underspecification of scope introduced by quantifying noun phrases, adverbs, and particles. The representations we will use resembles Underspecified Discourse Representation Structures (Reyle, 1993) and Hole Semantics (Bos, 1996). Our Underspecified Semantic Representation, USR, is introduced in Section 2. Section 3 shows how USRs are built up in a compositional semantics. Section 4 is the main part of the paper. It introduces an algorithm in which structural constraints are used to resolve underspecified scope in USR structures. Section 5 describes an implementation of the algorithm and evaluates how well it fares on real dialogue examples. 2 Underspecified Semantics: USR The representation we will use, USR, is a tertiary term containing the following pieces of semantic information: a t</context>
<context position="5934" citStr="Reyle, 1993" startWordPosition="950" endWordPosition="951">s to labels (Bos, 1996). The number of readings the USR encodes equals the number of possible pluggings. Here, two pluggings do not violate the &lt; constraints: th1 = 14, h2 = 15 h3 = 16 h1 = 15 h2 = 16 h3 = 14 The plugging in (3) resembles the reading where `auch&apos; outscopes &apos;nicht&apos;: the label for &apos;nicht&apos;, 15, is taken to &amp;quot;plug&amp;quot; the hole for `auch&apos;, h2, while `auch&apos; (14) is plugging the top hole of the sentence, h1. In contrast, the plugging in (4) gives the reading where the negation has wide scope. With a plugging, a USR can be translated to a Discourse Representation Structure, DRS (Kamp and Reyle, 1993): a pron condition introduces a discourse marker which should be linked to an antecedent, group is a merge between DRSs, passen a one place predicate, etc. 3 Construction of USRs In addition to underspecification, we let two other principles guide the semantic construction: lexicalization (keep as much as possible of the semantics lexicalized) and compositionality (a phrase&apos;s interpretation is a function of its subphrases&apos; interpretations). The grammar rules allow for addition of already manifest information (e.g., from the lexicon) and three ways of passing non-manifest information (e.g., abo</context>
</contexts>
<marker>Reyle, 1993</marker>
<rawString>Reyle U. 1993. Dealing with ambiguities by underspecification: Construction, representation and deduction. Journal of Semantics, 10:123-179.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>