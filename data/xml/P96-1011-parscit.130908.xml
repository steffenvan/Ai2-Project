<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000008">
<title confidence="0.999378">
Efficient Normal-Form Parsing
for Combinatory Categorial Grammar*
</title>
<author confidence="0.999028">
Jason Eisner
</author>
<affiliation confidence="0.998348">
Dept. of Computer and Information Science
University of Pennsylvania
</affiliation>
<address confidence="0.861805">
200 S. 33rd St., Philadelphia, PA 19104-6389, USA
</address>
<email confidence="0.980555">
jeisnertlinc.cis.upenn.edu
</email>
<sectionHeader confidence="0.994237" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9996223125">
Under categorial grammars that have pow-
erful rules like composition, a simple
n-word sentence can have exponentially
many parses. Generating all parses is ineffi-
cient and obscures whatever true semantic
ambiguities are in the input. This paper
addresses the problem for a fairly general
form of Combinatory Categorial Grammar,
by means of an efficient, correct, and easy
to implement normal-form parsing tech-
nique. The parser is proved to find ex-
actly one parse in each semantic equiv-
alence class of allowable parses; that is,
spurious ambiguity (as carefully defined)
is shown to be both safely and completely
eliminated.
</bodyText>
<sectionHeader confidence="0.998736" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.995168375">
Combinatory Categorial Grammar (Steedman,
1990), like other &amp;quot;flexible&amp;quot; categorial grammars,
suffers from spurious ambiguity (Wittenburg, 1986).
The non-standard constituents that are so crucial to
CCG&apos;s analyses in (1), and in its account of into-
national focus (Prevost &amp; Steedman, 1994), remain
available even in simpler sentences. This renders (2)
syntactically ambiguous.
</bodyText>
<listItem confidence="0.999365571428571">
(1) a. Coordination: [[John likes]s/Np, and
[Mary pretends to like&apos;s/Nip], the big
galoot in the corner.
b. Extraction: Everybody at this party
[whom [John likes]siNp ] is a big galoot.
(2) a. John [likes Mary]s Np.
b. [John likesisiNp Mary.
</listItem>
<bodyText confidence="0.987594333333333">
The practical problem of &amp;quot;extra&amp;quot; parses in (2) be-
comes exponentially worse for longer strings, which
can have up to a Catalan number of parses. An
</bodyText>
<footnote confidence="0.6979128">
This material is based upon work supported under
a National Science Foundation Graduate Fellowship. I
have been grateful for the advice of Aravind Joshi, Nobo
Komagata, Seth Kulick, Michael Niv, Mark Steedman,
and three anonymous reviewers.
</footnote>
<bodyText confidence="0.99923975">
exhaustive parser serves up 252 CCG parses of (3),
which must be sifted through, at considerable cost,
in order to identify the two distinct meanings for
further processing.&apos;
</bodyText>
<listItem confidence="0.773524">
(3) the galoot in the corner
</listItem>
<equation confidence="0.833428142857143">
NP/N N (N \N)/NP NP/N
that I said Mary
(N \N)/(S/NP) S/(S \NP) (S \NP)/S SAS \NP)
pretends to
(svp)/(sinf \ NP) (Sinf \NP)/(Ssten, \NP)
like
(sstenivp)/Np
</equation>
<bodyText confidence="0.999687157894737">
This paper presents a simple and flexible CCG
parsing technique that prevents any such explosion
of redundant CCG derivations. In particular, it is
proved in §4.2 that the method constructs exactly
one syntactic structure per semantic reading—e.g.,
just two parses for (3). All other parses are sup-
pressed by simple normal-form constraints that are
enforced throughout the parsing process. This ap-
proach works because CCG&apos;s spurious ambiguities
arise (as is shown) in only a small set of circum-
stances. Although similar work has been attempted
in the past, with varying degrees of success (Kart-
tunen, 1986; Wittenburg, 1986; Pareschi &amp; Steed-
man, 1987; Bouma, 1989; Hepple &amp; Morrill, 1989;
Ki5nig, 1989; Vijay-Shanker &amp; Weir, 1990; Hepple,
1990; Moortgat, 1990; Hendriks, 1993; Niv, 1994),
this appears to be the first full normal-form result
for a categorial formalism having more than context-
free power.
</bodyText>
<sectionHeader confidence="0.979111" genericHeader="introduction">
2 Definitions and Related Work
</sectionHeader>
<bodyText confidence="0.9893106">
CCG may be regarded as a generalization of context-
free grammar (CFG)—one where a grammar has
infinitely many nonterminals and phrase-structure
rules. In addition to the familiar atomic nonter-
minal categories (typically S for sentences, N for
</bodyText>
<footnote confidence="0.806335833333333">
1Namely, Mary pretends to like the galoot in 168
parses and the corner in 84. One might try a statis-
tical approach to ambiguity resolution, discarding the
low-probability parses, but it is unclear how to model
and train any probabilities when no single parse can be
taken as the standard of correctness.
</footnote>
<page confidence="0.998922">
79
</page>
<bodyText confidence="0.999269">
nouns, NP for noun phrases, etc.), CCG allows in- signs different types to &amp;quot;John likes&amp;quot; and &amp;quot;Mary pre-
finitely many slashed categories. If x and y are tends to like,&amp;quot; thus losing the ability to conjoin such
categories, then x/y (respectively x\y) is the cat- constituents or subcategorize for them as a class.
egory of an incomplete x that is missing a y at its (Pareschi &amp; Steedman, 1987) do tackle the CCG
right (respectively left). Thus verb phrases are an- case, but (Hepple, 1987) shows their algorithm to
alyzed as subjectless sentences S \NP, while &amp;quot;John be incomplete.
likes&amp;quot; is an objectless sentence or S/NP. A complex 3 Overview of the Parsing Strategy
category like ( (S \NP) \ (S \NP))/N may be written as As is well known, general CFG parsing methods
S \NP \ (S \NP)/N, under a convention that slashes are can be applied directly to CCG. Any sort of chart
left-associative. parser or non-deterministic shift-reduce parser will
The results herein apply to the TAG-equivalent do. Such a parser repeatedly decides whether two
CCG formalization given in (Joshi et al., 1991).2 adjacent constituents, such as S/NP and NP/N, should
In this variety of CCG, every (non-lexical) phrase- be combined into a larger constituent such as S/N.
structure rule is an instance of one of the following The role of the grammar is to state which combi-
binary-rule templates (where n 0): nations are allowed. The key to efficiency, we will
(4) Forward generalized composition &gt;Bn: see, is for the parser to be less permissive than the
xly Y Inzn • • • 12z2 lizi Inn • • • I2z2 lizi grammar—for it to say &amp;quot;no, redundant&amp;quot; in some
Backward generalized composition &lt;Bn: cases where the grammar says &amp;quot;yes, grammatical.&amp;quot;
Y Inzn • • I2z2 lizi \Y x Inzn • • • I I (5) shows the constituents that untrammeled
,2z2 ,izi CCG will find in the course of parsing &amp;quot;John likes
Instances with n = 0 are called application rules, and Mary.&amp;quot; The spurious ambiguity problem is not that
instances with n &gt; 1 are called composition rules. In the grammar allows (5c), but that the grammar al-
a given rule, x,y,z1...zn would be instantiated as lows both (5f) and (5g)—distinct parses of the same
categories like NP, S/NP, or S \NP \ (S\NP)/N. Each of string, with the same meaning.
11 through ln would be instantiated as either / or \ (5) a. [John]si(s\Np)
A fixed CCG grammar need not include every b. [likes](swp)/Np
phrase-structure rule matching these templates. In- c. [John likes]siNp
deed, (Joshi et al., 1991) place certain restrictions d. [Mary]Np
on the rule set of a CCG grammar, including a re- e. [likes Mary]s \Np
quirement that the rule degree n is bounded over the f. [[John likes] Mary]s to be disallowed
set. The results of the present paper apply to such g. [John [likes Mary]]s
restricted grammars and also more generally, to any The proposal is to construct all constituents
CCG-style grammar with a decidable rule set. shown in (5) except for (5f). If we slightly con-
Even as restricted by (Joshi et al., 1991), CCGs strain the use of the grammar rules, the parser will
have the &amp;quot;mildly context-sensitive&amp;quot; expressive power still produce (5c) and (5d)—constituents that are
of Tree Adjoining Grammars (TAGs). Most work indispensable in contexts like (1)—while refusing to
on spurious ambiguity has focused on categorial for- combine those constituents into (51). The relevant
malisms with substantially less power. (Hepple, rule S/NP NP S will actually be blocked when it
1990) and (Hendriks, 1993), the most rigorous pieces attempts to construct (5f). Although rule-blocking
of work, each establish a normal form for the syn- may eliminate an analysis of the sentence, as it does
tactic calculus of (Lambek, 1958), which is weakly here, a semantically equivalent analysis such as (5g)
context-free. (Konig, 1989; Moortgat, 1990) have will always be derivable along some other route.
also studied the Lambek calculus case. (Hepple In general, our goal is to discover exactly one anal-
Morrill, 1989), who introduced the idea of normal- ysis for each &lt;substring, meaning&gt; pair. By prac-
form parsing, consider only a small CCG frag- ticing &amp;quot;birth control&amp;quot; for each bottom-up generation
ment that lacks backward or order-changing com- of constituents in this way, we avoid a population
position; (Niv, 1994) extends this result but does explosion of parsing options. &amp;quot;John likes Mary&amp;quot; has
not show completeness. (Wittenburg, 1987) assumes only one reading semantically, so just one of its anal-
a CCG fragment lacking order-changing or higher- yses (5f)–(5g) is discovered while parsing (6). Only
order composition; furthermore, his revision of the that analysis, and not the other, is allowed to con-
combinators creates new, conjoinable constituents tinue on and be built into the final parse of (6).
that conventional CCG rejects. (Bouma, 1989) pro- (6) that galoot in the corner that thinks [John
poses to replace composition with a new combina- likes MarAs
tor, but the resulting product-grammar scheme as- For a chart parser, where each chart cell stores the
analyses of some substring, this strategy says that
2This formalization sweeps any type-raising into the 80
lexicon, as has been proposed on linguistic grounds
(Dowty, 1988; Steedman, 1991, and others). It also
treats conjunction lexically, by giving &amp;quot;and&amp;quot; the gener-
alized category x\x/x and barring it from composition.
all analyses in a cell are to be semantically distinct.
(Karttunen, 1986) suggests enforcing that property
directly—by comparing each new analysis semanti-
cally with existing analyses in the cell, and refus-
ing to add it if redundant—but (Hepple &amp; Morrill,
1989) observe briefly that this is inefficient for large
charts.3 The following sections show how to obtain
effectively the same result without doing any seman-
tic interpretation or comparison at all.
</bodyText>
<sectionHeader confidence="0.97269" genericHeader="method">
4 A Normal Form for &amp;quot;Pure&amp;quot; CCG
</sectionHeader>
<bodyText confidence="0.999912">
It is convenient to begin with a special case. Sup-
pose the CCG grammar includes not some but all
instances of the binary rule templates in (4). (As
always, a separate lexicon specifies the possible cat-
egories of each word.) If we group a sentence&apos;s parses
into semantic equivalence classes, it always turns out
that exactly one parse in each class satisfies the fol-
lowing simple declarative constraints:
</bodyText>
<listItem confidence="0.805538">
(7) a. No constituent produced by &gt;Bn, any
n&gt; 1, ever serves as the primary (left)
argument to &gt;Bn&apos;, any n&apos; _&gt; 0.
b. No constituent produced by &lt;Bn, any
n 1, ever serves as the primary (right)
argument to &lt;Bn&apos;, any n&apos; _&gt; 0.
</listItem>
<bodyText confidence="0.999011571428571">
The notation here is from (4). More colloquially,
(7) says that the output of rightward (leftward) com-
position may not compose or apply over anything to
is right (left). A parse tree or subtree that satisfies
(7) is said to be in normal form (NF).
As an example, consider the effect of these restric-
tions on the simple sentence &amp;quot;John likes Mary.&amp;quot; Ig-
noring the tags —OT, —FC, and —BC for the moment,
(8a) is a normal-form parse. Its competitor (813) is
not, nor is any larger tree containing (8b). But non-
3How inefficient? (i) has exponentially many seman-
tically distinct parses: n = 10 yields 82,756,612 parses
in (2°) = 48,620 equivalence classes. Karttunen&apos;s
io
method must therefore add 48,620 representative parses
to the appropriate chart cell, first comparing each one
against all the previously added parses—of which there
are 48,620/2 on average—to ensure it is not semantically
redundant. (Additional comparisons are needed to reject
parses other than the lucky 48,620.) Adding a parse can
therefore take exponential time.
</bodyText>
<equation confidence="0.662605">
TI TI
S/S S/S SiS S S\S S\S S\S
</equation>
<bodyText confidence="0.929922090909091">
Structure sharing does not appear to help: parses that
are grouped in a parse forest have only their syntactic
category in common, not their meaning. Karttunen&apos;s ap-
proach must tease such parses apart and compare their
various meanings individually against each new candi-
date. By contrast, the method proposed below is purely
syntactic—just like any &amp;quot;ordinary&amp;quot; parser—so it never
needs to unpack a subforest, and can run in polynomial
time.
standard constituents are allowed when necessary:
(8c) is in normal form (cf. (1)).
</bodyText>
<equation confidence="0.7830558">
(8) a. S—OT
S/(S\NP)–oT S\NP–OT
John (S\NP)/NP–oT NP–OT
likes Mary
forward application blocked by (7a)
(equivalently, notpermittcd by (10a))
S/NP–Fc NP–OT
Mary
S/(S\NP)-0T (S\NP)/NP-0T
John likes
N\N–oT
(N\N)/(S/NP)-0T S/NP–Fc
whom
S/(S\NP)–oT (S\NP)/NP–oT
John likes
</equation>
<bodyText confidence="0.998167785714286">
It is not hard to see that (7a) eliminates all but
right-branching parses of &amp;quot;forward chains&amp;quot; like A/B
B/C C or A/B/C C/D D/E/F/G G/H, and that (7b)
eliminates all but left-branching parses of &amp;quot;backward
chains.&amp;quot; (Thus every functor will get its arguments,
if possible, before it becomes an argument itself.)
But it is hardly obvious that (7) eliminates all of
CCG &apos;s spurious ambiguity. One might worry about
unexpected interactions involving crossing compo-
sition rules like A/B B \C –4- A \ C. Significantly, it
turns out that (7) really does suffice; the proof is
in §4.2.
It is trivial to modify any sort of CCG parser
to find only the normal-form parses. No seman-
tics is necessary; simply block any rule use that
would violate (7). In general, detecting violations
will not hurt performance by more than a constant
factor. Indeed, one might implement (7) by modi-
fying CCG&apos;s phrase-structure grammar. Each ordi-
nary CCG category is split into three categories that
bear the respective tags from (9). The 24 templates
schematized in (10) replace the two templates of (4).
Any CFG-style method can still parse the resulting
spuriosity-free grammar, with tagged parses as in
(8). In particular, the polynomial-time, polynomial-
space CCG chart parser of (Vijay-Shanker &amp; Weir,
1993) can be trivially adapted to respect the con-
straints by tagging chart entries.
</bodyText>
<page confidence="0.987472">
81
</page>
<listItem confidence="0.99605125">
(9) —FC output of &gt;Bn, some n &gt; 1 (a forward composition rule)
—BC output of &lt;Bn, some n&gt; 1 (a backward composition rule)
—OT output of &gt;BO or &lt;BO (an application rule), or lexical item
(10) a. Forward application &gt;BO: xiy—BC y
</listItem>
<figure confidence="0.77267840625">
xiy—OT y—_FBCc
x—OT
y—OT
{y—Fc
b. Backward application &lt;BO: y—BC } { ,
x\y—Fc }
y —0T
x\y—OT
x—IDT
/y—BC InZn &amp;quot; • 12Z2 Inzn • • I2z2 11.24--FC
c. Fwd. composition &gt;Bn (n 1): { xx/y—oT Y Inzn • • • -4 X IriZri • • • 12z2
y inzn 122:22 IlizzillsocT
d. Bwd. composition &lt;Bn (n &gt; 1): inzn • • • I2z2
Y InZn • • • 12Z2 X \y—FC
Inzn • • • 12z2 x \ y—oT
-4 X InZri • l22liZi
AC1AC2 • • • Acn • f (g(ci)(c2) • • • (cn))
-4 X InZn • •4* 12Z2 11Z1
AC1AC2 ...Acn•i(g(ci)(c2) • • (cn))
x/y
4 Inzn • •1122.2 11Z1
y lnzn • • • I2z2 x\y
4 4
b. A/C/F
A/C/E E/F
A/C/D D/E
A/B B/C/D
AxAy.f(g(h(k(x)))(y))
A/C/F
AIB B/C/D DIE E/F
h k
C.
</figure>
<listItem confidence="0.677822333333333">
(11) a. Syn/sem for &gt;Bn (n 0):
b. Syn/sem for &lt;Bn (n 0):
(12) a. A/C/F
</listItem>
<sectionHeader confidence="0.3918215" genericHeader="method">
A/C/D D/F
A/B B/C/D D/E E/F
</sectionHeader>
<bodyText confidence="0.999865888888889">
It is interesting to note a rough resemblance be-
tween the tagged version of CCG in (10) and the
tagged Lambek calculus L*, which (Hendriks, 1993)
developed to eliminate spurious ambiguity from the
Lambek calculus L. Although differences between
CCG and L mean that the details are quite different,
each system works by marking the output of certain
rules, to prevent such output from serving as input
to certain other rules.
</bodyText>
<subsectionHeader confidence="0.999404">
4.1 Semantic equivalence
</subsectionHeader>
<bodyText confidence="0.999580857142857">
We wish to establish that each semantic equivalence
class contains exactly one NF parse. But what does
&amp;quot;semantically equivalent&amp;quot; mean? Let us adopt a
standard model-theoretic view.
For each leaf (i.e., lexeme) of a given syntax tree,
the lexicon specifies a lexical interpretation from the
model. CCG then provides a derived interpretation
in the model for the complete tree. The standard
CCG theory builds the semantics compositionally,
guided by the syntax, according to (11). We may
therefore regard a syntax tree as a static &amp;quot;recipe&amp;quot; for
combining word meanings into a phrase meaning.
One might choose to say that two parses are se-
mantically equivalent if they derive the same phrase
meaning. However, such a definition would make
spurious ambiguity sensitive to the fine-grained se-
mantics of the lexicon. Are the two analyses of
VP/VP VP VP \VP semantically equivalent? If the
lexemes involved are &amp;quot;softly knock twice,&amp;quot; then yes,
as softly(twice(knock)) and twice(softly(knock)) ar-
guably denote a common function in the semantic
model. Yet for &amp;quot;intentionally knock twice&amp;quot; this is
not the case: these adverbs do not commute, and
the semantics are distinct.
It would be difficult to make such subtle distinc-
tions rapidly. Let us instead use a narrower, &amp;quot;inten-
sional&amp;quot; definition of spurious ambiguity. The trees in
(12a—b) will be considered equivalent because they
specify the same &amp;quot;recipe,&amp;quot; shown in (12c). No mat-
ter what lexical interpretations f,g,h,k are fed into
the leaves A/B, B/C/D, D/E, E/F, both the trees end
up with the same derived interpretation, namely a
model element that can be determined from f,g,h,k
by calculating AxAy.f(g(h(k(x)))(y)).
By contrast, the two readings of &amp;quot;softly knock
</bodyText>
<page confidence="0.997073">
82
</page>
<bodyText confidence="0.969661976190476">
twice&amp;quot; are considered to be distinct, since the parses -+
specify different recipes. That is, given a suitably Q fit NF T NF(a)
free choice of meanings for the words, the two parses 131 /32 132 7
can be made to pick out two different VP-type func- This construction resembles a well-known normal-
tions in the model. The parser is therefore conser- form reduction procedure that (Hepple 8.6 Morrill,
vative and keeps both parses.&apos; 1989) propose (without proving completeness) for a
4.2 Normal-form parsing is safe Sz complete small fragment of CCG.
The motivation for producing only NF parses (as The proof of theorem 2 (completeness) is longer
defined by (7)) lies in the following existence and and more subtle. First it shows, by a simple induc-
uniqueness theorems for CCG. tion, that since a and a&apos; disagree they must disagree
Theorem 1 Assuming &amp;quot;pure CCG,&amp;quot; where all pos- in at least one of these ways:
sible rules are in the grammar, any parse tree a is se- (a) There are trees /3, -y and rules R R&apos; such that
mantically equivalent to some NF parse tree NF(a). &lt;R, #,7&gt; is a subtree of a and &lt;R&apos;, 0,7&gt; is a
(This says the NF parser is safe for pure CCG: we subtree of a&apos;. (For example, S/S S \ S may form
will not lose any readings by generating just normal a constituent by either &lt;Blx or &gt;Bix.)
forms.) (b) There is a tree 7 that appears as a subtree of
Theorem 2 Given distinct NF trees a 0 a&apos; (on the both a and a&apos;, but combines to the left in one
same sequence of leaves). Then a and a&apos; are not case and to the right in the other.
semantically equivalent. Either condition, the proof shows, leads to different
(This says that the NF parser is complete: generat- &amp;quot;immediate scope&amp;quot; relations in the full trees a and a&apos;
ing only normal forms eliminates all spurious ambi- (in the sense in which f takes immediate scope over
guity.) g in f(g(x)) but not in f(h(g(x))) or g(f(x))). Con-
Detailed proofs of these theorems are available on dition (a) is straightforward. Condition (b) splits
the al-T-1g archive, but can only be sketched here. into a case where -y serves as a secondary argument
Theorem 1 is proved by a constructive induction on inside both a and a&apos;, and a case where it is a primary
the order of a, given below and illustrated in (13): argument in a or a&apos;. The latter case requires consid-
• For a a leaf, put NF(a) = a. eration of 7&apos;s ancestors; the NF properties crucially
• (&lt;R, 0,7&gt; denotes the parse tree formed by com- rule out counterexamples here.
bining subtrees 13, 7 via rule R.) The notion of scope is relevant because semantic
If a = &lt;R,/3,7&gt;, then take NF(a) = interpretations for CCG constituents can be written
&lt;R, NF(#),NF(-y)&gt;, which exists by inductive as restricted lambda terms, in such a way that con-
hypothesis, unless this is not an NF tree. In stituents having distinct terms must have different
the latter case, WLOG, R is a forward rule and interpretations in the model (for suitable interpreta-
NF(#) = &lt;Q, 13i, /32&gt; for some forward com- tions of the words, as in §4.1). Theorem 2 is proved
position rule Q. Pure CCG turns out to pro- by showing that the terms for a and a&apos; differ some-
vide forward rules S and T such that a&apos; = where, so correspond to different semantic recipes.
&lt;S, , NF(&lt;T, , 7&gt;)&gt; is a constituent and Similar theorems for the Lambek calculus were
is semantically equivalent to a. Moreover, since previously shown by (Hepple, 1990; Hendriks, 1993).
131 serves as the primary subtree of the NF tree The present proofs for CCG establish a result that
NF(#), fi1. cannot be the output of forward com- has long been suspected: the spurious ambiguity
position, and is NF besides. Therefore a&apos; is NF: problem is not actually very widespread in CCG.
take NF(a) = a&apos;. Theorem 2 says all cases of spurious ambiguity
</bodyText>
<figureCaption confidence="0.896025407407407">
(13) If NF(13) not output of fwd. composition, can be eliminated through the construction given
a = (1=-!-.f NF(a) in theorem 1. But that construction merely en-
13 7 NF (#) (-y) sures a right-branching structure for &amp;quot;forward con-
stituent chains&amp;quot; (such as A/B B/C C or A/B/C C/D
D/E/F/G G/H), and a left-branching structure for
backward constituent chains. So these familiar
chains are the only source of spurious ambiguity in
CCG.
5 Extending the Approach to
&amp;quot;Restricted&amp;quot; CCG
The &amp;quot;pure&amp;quot; CCG of §4 is a fiction. Real CCG gram-
mars can and do choose a subset of the possible rules.
else a = 83
# 7 NF(0) -y
4(Hepple &amp; Morrill, 1989; Hepple, 1990; Hendriks,
1993) appear to share this view of semantic equivalence.
Unlike (Karttunen, 1986), they try to eliminate only
parses whose denotations (or at least A-terms) are sys-
tematically equivalent, not parses that happen to have
the same denotation through an accident of the lexicon.
For instance, to rule out (14), the (crossing) back- as a magnet for a&apos;s semantic class. The proof of
ward rule N/N 11\11 N/N must be omitted from theorem 1 (see (13)) actually shows how to con-
English grammar. struct NF(a) in 0(1) time from the values of NF on
(14) [theNpiN RbigN/N [that likes JohniN\NIN/N smaller constituents. Hence, an appropriate parser
galootN IN }NP can compute and cache the NF of each parse in 0(1)
If some rules are removed from a &amp;quot;pure&amp;quot; CCG time as it is added to the chart. It can detect redun-
grammar, some parses will become unavailable. dant parses by noting (via an 0(1) array lookup)
</figureCaption>
<bodyText confidence="0.98434951724138">
Theorem 2 remains true (&lt; 1 NF per reading). that their NFs have been previously computed.
Whether theorem 1 (&gt; 1 NF per reading) remains Figure (1) gives an efficient CKY-style algorithm
true depends on what set of rules is removed. For based on this insight. (Parsing strategies besides
most linguistically reasonable choices, the proof of CKY would also work, in particular (Vijay-Shanker
theorem 1 will go through,&apos; so that the normal-form Si Weir, 1993)) The management of cached NFs in
parser of §4 remains safe. But imagine removing steps 9, 12, and especially 16 ensures that duplicate
only the rule B/C C B: this leaves the string A/B NFs never enter the oldNFs array: thus any alter-
B/C C with a left-branching parse that has no (legal) native copy of a.nf has the same array coordinates
NF equivalent. used for a.nf itself, because it was built from identi-
In the sort of restricted grammar where theorem 1 cal subtrees.
does not obtain, can we still find one (possibly non- The function PreferableTo(c, r) (step 15) pro-
NF) parse per equivalence class? Yes: a different vides flexibility about which parse represents its
kind of efficient parser can be built for this case. class. PreferableTo may be defined at whim to
Since the new parser must be able to generate a choose the parse discovered first, the more left-
non-NF parse when no equivalent NF parse is avail- branching parse, or the parse with fewer non-
able, its method of controlling spurious ambiguity standard constituents. Alternatively, PreferableTo
cannot be to enforce the constraints (7). The old may call an intonation or discourse module to pick
parser refused to build non-NF constituents; the new the parse that better reflects the topic-focus divi-
parser will refuse to build constituents that are se- sion of the sentence. (A variant algorithm ignores
mantically equivalent to already-built constituents. PreferableTo and constructs one parse forest per
This idea originates with (Karttunen, 1986). reading. Each forest can later be unpacked into in-
However, we can take advantage of the core result dividual equivalent parse trees, if desired.)
of this paper, theorems 1 and 2, to do Karttunen&apos;s (Vijay-Shanker Sz Weir, 1990) also give a method
redundancy check in 0(1) time—no worse than the for removing &amp;quot;one well-known source&amp;quot; of spurious
normal-form parser&apos;s check for —FC and –BC tags. ambiguity from restricted CCGs; §4.2 above shows
(Karttunen&apos;s version takes worst-case exponential that this is in fact the only source. However, their
time for each redundancy check: see footnote §3.) method relies on the grammaticality of certain inter-
The insight is that theorems 1 and 2 estab- mediate forms, and so can fail if the CCG rules can
lish a one-to-one map between semantic equivalence be arbitrarily restricted. In addition, their method
classes and normal forms of the pure (unrestricted) is less efficient than the present one: it considers
CCG: parses in pairs, not singly, and does not remove any
(15) Two parses a, a&apos; of the pure CCG are parse until the entire parse forest has been built.
semantically equivalent if they have the 6 Extensions to the CCG Formalism
same normal form: NF(a)= NF(a&apos;). In addition to the Bn (&amp;quot;generalized composition&amp;quot;)
The NF function is defined recursively by §4.2&apos;s rules given in §2, which give CCG power equivalent
proof of theorem 1; semantic equivalence is also to TAG, rules based on the S (&amp;quot;substitution&amp;quot;) and
defined independently of the grammar. So (15) is T (&amp;quot;type-raising&amp;quot;) combinators can be linguistically
meaningful and true even if a, a&apos; are produced by useful. S provides another rule template, used in
a restricted CCG. The tree NF(a) may not be a the analysis of parasitic gaps (Steedman, 1987; Sz-
legal parse under the restricted grammar. How- abolcsi, 1989):
ever, it is still a perfectly good data structure that (16) a. &gt;s: x/y liz y liz --+ x liz
can be maintained outside the parse chart, to serve 11
f g Az. f(z)(g(z))
b. &lt;S: y liz x\Y liz –+ x liz
Although S interacts with Bn to produce another
source of spurious ambiguity, illustrated in (17), the
additional ambiguity is not hard to remove. It can
be shown that when the restriction (18) is used to-
gether with (7), the system again finds exactly one
84
&apos;For the proof to work, the rules S and T must be
available in the restricted grammar, given that R and Q
are. This is usually true: since (7) favors standard con-
stituents and prefers application to composition, most
grammars will not block the NF derivation while allow-
ing a non-NF one. (On the other hand, the NF parse of
A/B B/C C/D/E uses &gt;B2 twice, while the non-NF parse
gets by with &gt;B2 and &gt;B1.)
</bodyText>
<listItem confidence="0.993088136363636">
1. for i := 1 to n
2. C[i — 1, i] := LexCate(word[i]) (* word i stretches from point i — 1 to point i *)
3. for width := 2 to n
4. for start := 0 to n — width
5. end := start + width
6. for mid := start + 1 to end — 1
7. for each parse tree a = &lt;R, 1 3 , 7&gt; that could be formed by combining some
0 E C[start, mid] with some 7 E C[mid, end] by a rule R of the (restricted) grammar
8. a .nf := NF(a) (* can be computed in constant time using the .nf fields of 0, 7, and
other constituents already in C. Subtrees are also NF trees. *)
9. existing NF := oldNFs[a.nf .rule, a .nf deftchild .segno, a. ntrightchild .seqno]
10. if undefined( existing NF) (* the first parse with this NF *)
11. a .nf. seqno := (counter := counter + 1) (* number the new NF &amp; add it to oldN Fs *)
12. oldNFs[a.nf .rule, a .nf . leftchild .segno , a .nf .rightchild . s eqno] := a .nf
13. add a to C[start, end]
14. a .nf. currparse := a
15. elsif Pref erableTo(a, existing NF .currpar se) (* replace reigning parse? *)
16. a .nf := existing NF (* use cached copy of NF, not new one *)
17. remove a . nf. currparse from C[start, end]
18. add a to C[start, end]
19. a .n.f. currparse := a
20. return(all parses from C[0, n] having root category S)
</listItem>
<figureCaption confidence="0.985062">
Figure 1: Canonicalizing CCG parser that handles arbitrary restrictions on the rule set. (In practice, a
simpler normal-form parser will suffice for most grammars.)
</figureCaption>
<figure confidence="0.688561785714286">
parse from every equivalence class.
(17) a. VP0/NP (&lt;sx)
VP i/NP (&lt;Sx) VPAVP1
VP2/NP VPI \VP2/NP yesterday
filed [without-reading]
b. VP /NP (&lt;Sx)
VP2/NP VP0\VP2/NP (&lt;B2)
VP1\VP2/NP VPAVP1
(18) a. No constituent produced by &gt;Bn, any
n &gt; 2, ever serves as the primary (left)
argument to &gt;S.
b. No constituent produced by &lt;Bn, any
n &gt; 2, ever serves as the primary (right)
argument to &lt;S.
</figure>
<bodyText confidence="0.999302761904762">
Type-raising presents a greater problem. Vari-
ous new spurious ambiguities arise if it is permit-
ted freely in the grammar. In principle one could
proceed without grammatical type-raising: (Dowty,
1988; Steedman, 1991) have argued on linguistic
grounds that type-raising should be treated as a
mere lexical redundancy property. That is, when-
ever the lexicon contains an entry of a certain cate-
gory X, with semantics x, it also contains one with
(say) category T/ (T \X) and interpretation Ap.p(x).
As one might expect, this move only sweeps the
problem under the rug. If type-raising is lexical,
then the definitions of this paper do not recognize
(19) as a spurious ambiguity, because the two parses
are now, technically speaking, analyses of different
sentences. Nor do they recognize the redundancy in
(20), because—just as for the example &amp;quot;softly knock
twice&amp;quot; in §4.1—it is contingent on a kind of lexical
coincidence, namely that a type-raised subject com-
mutes with a (generically) type-raised object. Such
ambiguities are left to future work.
</bodyText>
<listItem confidence="0.964829">
(19) POhnNp lefts Npis vs. POlinsi(s NP) lefts Npjs
(20) [S/(S\NPs) [S\Nps/NP0/Nri TVT/spo)]]sisi
vs. [S/(S\Nps) S\Nps/nPo/Npd TVT/Npo)]sisi
</listItem>
<sectionHeader confidence="0.990377" genericHeader="conclusions">
7 Conclusions
</sectionHeader>
<bodyText confidence="0.9856">
The main contribution of this work has been formal:
to establish a normal form for parses of &amp;quot;pure&amp;quot; Corn-
binatory Categorial Grammar. Given a sentence,
every reading that is available to the grammar has
exactly one normal-form parse, no matter how many
parses it has in toto.
A result worth remembering is that, although
TAG-equivalent CCG allows free interaction among
forward, backward, and crossed composition rules of
any degree, two simple constraints serve to eliminate
all spurious ambiguity. It turns out that all spuri-
ous ambiguity arises from associative &amp;quot;chains&amp;quot; such
as A/B B/C C or A/B/C C/D D/E\F/G G/H. (Wit-
8 5
tenburg, 1987; Hepple &amp; Morrill, 1989) anticipate
this result, at least for some fragments of CCG, but
leave the proof to future work.
These normal-form results for pure CCG lead di-
rectly to useful parsers for real, restricted CCG
grammars. Two parsing algorithms have been pre-
sented for practical use. One algorithm finds only
normal forms; this simply and safely eliminates spu-
rious ambiguity under most real CCG grammars.
The other, more complex algorithm solves the spu-
rious ambiguity problem for any CCG grammar, by
using normal forms as an efficient tool for grouping
semantically equivalent parses. Both algorithms are
safe, complete, and efficient.
In closing, it should be repeated that the results
provided are for the TAG-equivalent Bn (general-
ized composition) formalism of (Joshi et al., 1991),
optionally extended with the S (substitution) rules
of (Szabolcsi, 1989). The technique eliminates all
spurious ambiguities resulting from the interaction
of these rules. Future work should continue by
eliminating the spurious ambiguities that arise from
grammatical or lexical type-raising.
</bodyText>
<sectionHeader confidence="0.998849" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999229607142857">
Gosse Bouma. 1989. Efficient processing of flexible
categorial grammar. In Proceedings of the Fourth
Conference of the European Chapter of the Associ-
ation for Computational Linguistics, 19-26, Uni-
versity of Manchester, April.
David Dowty. 1988. Type raising, functional com-
position, and non-constituent conjunction. In R.
Oehrle, E. Bach and D. Wheeler, editors, Catego-
rial Grammars and Natural Language Structures.
Reidel.
Mark Hepple. 1987. Methods for parsing combina-
tory categorial grammar and the spurious ambi-
guity problem. Unpublished M.Sc. thesis, Centre
for Cognitive Science, University of Edinburgh.
Mark Hepple. 1990. The Grammar and Process-
ing of Order and Dependency: A Categorial Ap-
proach. Ph.D. thesis, University of Edinburgh.
Mark Hepple and Glyn Morrill. 1989. Parsing and
derivational equivalence. In Proceedings of the
Fourth Conference of the European Chapter of the
Association for Computational Linguistics, 10-18,
University of Manchester, April.
Herman Hendriks. 1993. Studied Flexibility: Cate-
gories and Types in Syntax and Semantics. Ph.D.
thesis, Institute for Logic, Language, and Compu-
tation, University of Amsterdam.
Aravind Joshi, K. Vijay-Shanker, and David Weir.
1991. The convergence of mildly context-sensitive
grammar formalisms. In Foundational Issues in
Natural Language Processing, MIT Press.
Lauri Karttunen. 1986. Radical lexicalism. Report
No. CSLI-86-68, CSLI, Stanford University.
E. Konig. 1989. Parsing as natural deduction. In
Proceedings of the 27th Annual Meeting of the As-
sociation for Computational Linguistics, Vancou-
ver.
J. Lambek. 1958. The mathematics of sen-
tence structure. American Mathematical Monthly
65:154-169.
Michael Moortgat. 1990. Unambiguous proof repre-
sentations for the Lambek Calculus. In Proceed-
ings of the Seventh Amsterdam Colloquium.
Michael Niv. 1994. A psycholinguistically moti-
vated parser for CCG. In Proceedings of the 32nd
Annual Meeting of the Association for Computa-
tional Linguistics, Las Cruces, NM, June.
Remo Pareschi and Mark Steedman. A lazy way to
chart parse with combinatory grammars. In Pro-
ceedings of the 25th Annual Meeting of the As-
sociation for Computational Linguistics, Stanford
University, July.
Scott Prevost and Mark Steedman. 1994. Specify-
ing intonation from context for speech synthesis.
Speech Communication, 15:139-153.
Mark Steedman. 1990. Gapping as constituent coor-
dination. Linguistics and Philosophy, 13:207-264.
Mark Steedman. 1991. Structure and intonation.
Language, 67:260-296.
Mark Steedman. 1987. Combinatory grammars and
parasitic gaps. Natural Language and Linguistic
Theory, 5:403-439.
Anna Szabolcsi. 1989. Bound variables in syntax:
Are there any? In R. Bartsch, J. van Benthem,
and P. van Emde Boas (eds.), Semantics and Con-
textual Expression, 295-318. Foris, Dordrecht.
K. Vijay-Shanker and David Weir. 1990. Polyno-
mial time parsing of combinatory categorial gram-
mars. In Proceedings of the 28th Annual Meeting
of the Association for Computational Linguistics.
K. Vijay-Shanker and David Weir. 1993. Parsing
some constrained grammar formalisms. Compu-
tational Linguistics, 19(4):591-636.
K. Vijay-Shanker and David Weir. 1994. The equiv-
alence of four extensions of context-free gram-
mars. Mathematical Systems Theory, 27:511-546.
Kent Wittenburg. 1986. Natural Language Pars-
ing with Combinatory Categorial Grammar in a
Graph-Unification-Based Formalism. Ph.D. the-
sis, University of Texas.
Kent Wittenburg. 1987. Predictive combinators:
A method for efficient parsing of Combinatory
Categorial Grammars. In Proceedings of the 25th
Annual Meeting of the Association for Computa-
tional Linguistics, Stanford University, July.
</reference>
<page confidence="0.998567">
86
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.876176">
<title confidence="0.9997155">Efficient Normal-Form Parsing for Combinatory Categorial Grammar*</title>
<author confidence="0.999986">Jason Eisner</author>
<affiliation confidence="0.9996285">Dept. of Computer and Information Science University of Pennsylvania</affiliation>
<address confidence="0.999903">200 S. 33rd St., Philadelphia, PA 19104-6389, USA</address>
<email confidence="0.999878">jeisnertlinc.cis.upenn.edu</email>
<abstract confidence="0.992263529411765">Under categorial grammars that have powerful rules like composition, a simple n-word sentence can have exponentially many parses. Generating all parses is inefficient and obscures whatever true semantic ambiguities are in the input. This paper addresses the problem for a fairly general form of Combinatory Categorial Grammar, by means of an efficient, correct, and easy to implement normal-form parsing tech- The parser is proved to find exone in each semantic equivalence class of allowable parses; that is, spurious ambiguity (as carefully defined) is shown to be both safely and completely eliminated.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Gosse Bouma</author>
</authors>
<title>Efficient processing of flexible categorial grammar.</title>
<date>1989</date>
<booktitle>In Proceedings of the Fourth Conference of the European Chapter of the Association for Computational Linguistics,</booktitle>
<institution>University of Manchester,</institution>
<contexts>
<context position="2899" citStr="Bouma, 1989" startWordPosition="445" endWordPosition="446">g technique that prevents any such explosion of redundant CCG derivations. In particular, it is proved in §4.2 that the method constructs exactly one syntactic structure per semantic reading—e.g., just two parses for (3). All other parses are suppressed by simple normal-form constraints that are enforced throughout the parsing process. This approach works because CCG&apos;s spurious ambiguities arise (as is shown) in only a small set of circumstances. Although similar work has been attempted in the past, with varying degrees of success (Karttunen, 1986; Wittenburg, 1986; Pareschi &amp; Steedman, 1987; Bouma, 1989; Hepple &amp; Morrill, 1989; Ki5nig, 1989; Vijay-Shanker &amp; Weir, 1990; Hepple, 1990; Moortgat, 1990; Hendriks, 1993; Niv, 1994), this appears to be the first full normal-form result for a categorial formalism having more than contextfree power. 2 Definitions and Related Work CCG may be regarded as a generalization of contextfree grammar (CFG)—one where a grammar has infinitely many nonterminals and phrase-structure rules. In addition to the familiar atomic nonterminal categories (typically S for sentences, N for 1Namely, Mary pretends to like the galoot in 168 parses and the corner in 84. One mig</context>
<context position="8543" citStr="Bouma, 1989" startWordPosition="1384" endWordPosition="1385">om- of constituents in this way, we avoid a population position; (Niv, 1994) extends this result but does explosion of parsing options. &amp;quot;John likes Mary&amp;quot; has not show completeness. (Wittenburg, 1987) assumes only one reading semantically, so just one of its anala CCG fragment lacking order-changing or higher- yses (5f)–(5g) is discovered while parsing (6). Only order composition; furthermore, his revision of the that analysis, and not the other, is allowed to concombinators creates new, conjoinable constituents tinue on and be built into the final parse of (6). that conventional CCG rejects. (Bouma, 1989) pro- (6) that galoot in the corner that thinks [John poses to replace composition with a new combina- likes MarAs tor, but the resulting product-grammar scheme as- For a chart parser, where each chart cell stores the analyses of some substring, this strategy says that 2This formalization sweeps any type-raising into the 80 lexicon, as has been proposed on linguistic grounds (Dowty, 1988; Steedman, 1991, and others). It also treats conjunction lexically, by giving &amp;quot;and&amp;quot; the generalized category x\x/x and barring it from composition. all analyses in a cell are to be semantically distinct. (Kart</context>
</contexts>
<marker>Bouma, 1989</marker>
<rawString>Gosse Bouma. 1989. Efficient processing of flexible categorial grammar. In Proceedings of the Fourth Conference of the European Chapter of the Association for Computational Linguistics, 19-26, University of Manchester, April.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Dowty</author>
</authors>
<title>Type raising, functional composition, and non-constituent conjunction. In</title>
<date>1988</date>
<booktitle>Categorial Grammars and Natural Language Structures.</booktitle>
<editor>R. Oehrle, E. Bach and D. Wheeler, editors,</editor>
<publisher>Reidel.</publisher>
<contexts>
<context position="8933" citStr="Dowty, 1988" startWordPosition="1447" endWordPosition="1448">ore, his revision of the that analysis, and not the other, is allowed to concombinators creates new, conjoinable constituents tinue on and be built into the final parse of (6). that conventional CCG rejects. (Bouma, 1989) pro- (6) that galoot in the corner that thinks [John poses to replace composition with a new combina- likes MarAs tor, but the resulting product-grammar scheme as- For a chart parser, where each chart cell stores the analyses of some substring, this strategy says that 2This formalization sweeps any type-raising into the 80 lexicon, as has been proposed on linguistic grounds (Dowty, 1988; Steedman, 1991, and others). It also treats conjunction lexically, by giving &amp;quot;and&amp;quot; the generalized category x\x/x and barring it from composition. all analyses in a cell are to be semantically distinct. (Karttunen, 1986) suggests enforcing that property directly—by comparing each new analysis semantically with existing analyses in the cell, and refusing to add it if redundant—but (Hepple &amp; Morrill, 1989) observe briefly that this is inefficient for large charts.3 The following sections show how to obtain effectively the same result without doing any semantic interpretation or comparison at a</context>
<context position="28461" citStr="Dowty, 1988" startWordPosition="4869" endWordPosition="4870">fice for most grammars.) parse from every equivalence class. (17) a. VP0/NP (&lt;sx) VP i/NP (&lt;Sx) VPAVP1 VP2/NP VPI \VP2/NP yesterday filed [without-reading] b. VP /NP (&lt;Sx) VP2/NP VP0\VP2/NP (&lt;B2) VP1\VP2/NP VPAVP1 (18) a. No constituent produced by &gt;Bn, any n &gt; 2, ever serves as the primary (left) argument to &gt;S. b. No constituent produced by &lt;Bn, any n &gt; 2, ever serves as the primary (right) argument to &lt;S. Type-raising presents a greater problem. Various new spurious ambiguities arise if it is permitted freely in the grammar. In principle one could proceed without grammatical type-raising: (Dowty, 1988; Steedman, 1991) have argued on linguistic grounds that type-raising should be treated as a mere lexical redundancy property. That is, whenever the lexicon contains an entry of a certain category X, with semantics x, it also contains one with (say) category T/ (T \X) and interpretation Ap.p(x). As one might expect, this move only sweeps the problem under the rug. If type-raising is lexical, then the definitions of this paper do not recognize (19) as a spurious ambiguity, because the two parses are now, technically speaking, analyses of different sentences. Nor do they recognize the redundancy</context>
</contexts>
<marker>Dowty, 1988</marker>
<rawString>David Dowty. 1988. Type raising, functional composition, and non-constituent conjunction. In R. Oehrle, E. Bach and D. Wheeler, editors, Categorial Grammars and Natural Language Structures. Reidel.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Hepple</author>
</authors>
<title>Methods for parsing combinatory categorial grammar and the spurious ambiguity problem. Unpublished M.Sc. thesis,</title>
<date>1987</date>
<institution>Centre for Cognitive Science, University of Edinburgh.</institution>
<contexts>
<context position="4205" citStr="Hepple, 1987" startWordPosition="662" endWordPosition="663"> but it is unclear how to model and train any probabilities when no single parse can be taken as the standard of correctness. 79 nouns, NP for noun phrases, etc.), CCG allows in- signs different types to &amp;quot;John likes&amp;quot; and &amp;quot;Mary prefinitely many slashed categories. If x and y are tends to like,&amp;quot; thus losing the ability to conjoin such categories, then x/y (respectively x\y) is the cat- constituents or subcategorize for them as a class. egory of an incomplete x that is missing a y at its (Pareschi &amp; Steedman, 1987) do tackle the CCG right (respectively left). Thus verb phrases are an- case, but (Hepple, 1987) shows their algorithm to alyzed as subjectless sentences S \NP, while &amp;quot;John be incomplete. likes&amp;quot; is an objectless sentence or S/NP. A complex 3 Overview of the Parsing Strategy category like ( (S \NP) \ (S \NP))/N may be written as As is well known, general CFG parsing methods S \NP \ (S \NP)/N, under a convention that slashes are can be applied directly to CCG. Any sort of chart left-associative. parser or non-deterministic shift-reduce parser will The results herein apply to the TAG-equivalent do. Such a parser repeatedly decides whether two CCG formalization given in (Joshi et al., 1991).</context>
</contexts>
<marker>Hepple, 1987</marker>
<rawString>Mark Hepple. 1987. Methods for parsing combinatory categorial grammar and the spurious ambiguity problem. Unpublished M.Sc. thesis, Centre for Cognitive Science, University of Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Hepple</author>
</authors>
<title>The Grammar and Processing of Order and Dependency: A Categorial Approach.</title>
<date>1990</date>
<tech>Ph.D. thesis,</tech>
<institution>University of Edinburgh.</institution>
<contexts>
<context position="2979" citStr="Hepple, 1990" startWordPosition="457" endWordPosition="458">articular, it is proved in §4.2 that the method constructs exactly one syntactic structure per semantic reading—e.g., just two parses for (3). All other parses are suppressed by simple normal-form constraints that are enforced throughout the parsing process. This approach works because CCG&apos;s spurious ambiguities arise (as is shown) in only a small set of circumstances. Although similar work has been attempted in the past, with varying degrees of success (Karttunen, 1986; Wittenburg, 1986; Pareschi &amp; Steedman, 1987; Bouma, 1989; Hepple &amp; Morrill, 1989; Ki5nig, 1989; Vijay-Shanker &amp; Weir, 1990; Hepple, 1990; Moortgat, 1990; Hendriks, 1993; Niv, 1994), this appears to be the first full normal-form result for a categorial formalism having more than contextfree power. 2 Definitions and Related Work CCG may be regarded as a generalization of contextfree grammar (CFG)—one where a grammar has infinitely many nonterminals and phrase-structure rules. In addition to the familiar atomic nonterminal categories (typically S for sentences, N for 1Namely, Mary pretends to like the galoot in 168 parses and the corner in 84. One might try a statistical approach to ambiguity resolution, discarding the low-probab</context>
<context position="19909" citStr="Hepple, 1990" startWordPosition="3355" endWordPosition="3356">e. In stituents having distinct terms must have different the latter case, WLOG, R is a forward rule and interpretations in the model (for suitable interpretaNF(#) = &lt;Q, 13i, /32&gt; for some forward com- tions of the words, as in §4.1). Theorem 2 is proved position rule Q. Pure CCG turns out to pro- by showing that the terms for a and a&apos; differ somevide forward rules S and T such that a&apos; = where, so correspond to different semantic recipes. &lt;S, , NF(&lt;T, , 7&gt;)&gt; is a constituent and Similar theorems for the Lambek calculus were is semantically equivalent to a. Moreover, since previously shown by (Hepple, 1990; Hendriks, 1993). 131 serves as the primary subtree of the NF tree The present proofs for CCG establish a result that NF(#), fi1. cannot be the output of forward com- has long been suspected: the spurious ambiguity position, and is NF besides. Therefore a&apos; is NF: problem is not actually very widespread in CCG. take NF(a) = a&apos;. Theorem 2 says all cases of spurious ambiguity (13) If NF(13) not output of fwd. composition, can be eliminated through the construction given a = (1=-!-.f NF(a) in theorem 1. But that construction merely en13 7 NF (#) (-y) sures a right-branching structure for &amp;quot;forward</context>
</contexts>
<marker>Hepple, 1990</marker>
<rawString>Mark Hepple. 1990. The Grammar and Processing of Order and Dependency: A Categorial Approach. Ph.D. thesis, University of Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Hepple</author>
<author>Glyn Morrill</author>
</authors>
<title>Parsing and derivational equivalence.</title>
<date>1989</date>
<booktitle>In Proceedings of the Fourth Conference of the European Chapter of the Association for Computational Linguistics,</booktitle>
<pages>10--18</pages>
<institution>University of Manchester,</institution>
<contexts>
<context position="2923" citStr="Hepple &amp; Morrill, 1989" startWordPosition="447" endWordPosition="450">hat prevents any such explosion of redundant CCG derivations. In particular, it is proved in §4.2 that the method constructs exactly one syntactic structure per semantic reading—e.g., just two parses for (3). All other parses are suppressed by simple normal-form constraints that are enforced throughout the parsing process. This approach works because CCG&apos;s spurious ambiguities arise (as is shown) in only a small set of circumstances. Although similar work has been attempted in the past, with varying degrees of success (Karttunen, 1986; Wittenburg, 1986; Pareschi &amp; Steedman, 1987; Bouma, 1989; Hepple &amp; Morrill, 1989; Ki5nig, 1989; Vijay-Shanker &amp; Weir, 1990; Hepple, 1990; Moortgat, 1990; Hendriks, 1993; Niv, 1994), this appears to be the first full normal-form result for a categorial formalism having more than contextfree power. 2 Definitions and Related Work CCG may be regarded as a generalization of contextfree grammar (CFG)—one where a grammar has infinitely many nonterminals and phrase-structure rules. In addition to the familiar atomic nonterminal categories (typically S for sentences, N for 1Namely, Mary pretends to like the galoot in 168 parses and the corner in 84. One might try a statistical app</context>
<context position="9342" citStr="Hepple &amp; Morrill, 1989" startWordPosition="1508" endWordPosition="1511"> parser, where each chart cell stores the analyses of some substring, this strategy says that 2This formalization sweeps any type-raising into the 80 lexicon, as has been proposed on linguistic grounds (Dowty, 1988; Steedman, 1991, and others). It also treats conjunction lexically, by giving &amp;quot;and&amp;quot; the generalized category x\x/x and barring it from composition. all analyses in a cell are to be semantically distinct. (Karttunen, 1986) suggests enforcing that property directly—by comparing each new analysis semantically with existing analyses in the cell, and refusing to add it if redundant—but (Hepple &amp; Morrill, 1989) observe briefly that this is inefficient for large charts.3 The following sections show how to obtain effectively the same result without doing any semantic interpretation or comparison at all. 4 A Normal Form for &amp;quot;Pure&amp;quot; CCG It is convenient to begin with a special case. Suppose the CCG grammar includes not some but all instances of the binary rule templates in (4). (As always, a separate lexicon specifies the possible categories of each word.) If we group a sentence&apos;s parses into semantic equivalence classes, it always turns out that exactly one parse in each class satisfies the following si</context>
<context position="20912" citStr="Hepple &amp; Morrill, 1989" startWordPosition="3532" endWordPosition="3535"> If NF(13) not output of fwd. composition, can be eliminated through the construction given a = (1=-!-.f NF(a) in theorem 1. But that construction merely en13 7 NF (#) (-y) sures a right-branching structure for &amp;quot;forward constituent chains&amp;quot; (such as A/B B/C C or A/B/C C/D D/E/F/G G/H), and a left-branching structure for backward constituent chains. So these familiar chains are the only source of spurious ambiguity in CCG. 5 Extending the Approach to &amp;quot;Restricted&amp;quot; CCG The &amp;quot;pure&amp;quot; CCG of §4 is a fiction. Real CCG grammars can and do choose a subset of the possible rules. else a = 83 # 7 NF(0) -y 4(Hepple &amp; Morrill, 1989; Hepple, 1990; Hendriks, 1993) appear to share this view of semantic equivalence. Unlike (Karttunen, 1986), they try to eliminate only parses whose denotations (or at least A-terms) are systematically equivalent, not parses that happen to have the same denotation through an accident of the lexicon. For instance, to rule out (14), the (crossing) back- as a magnet for a&apos;s semantic class. The proof of ward rule N/N 11\11 N/N must be omitted from theorem 1 (see (13)) actually shows how to conEnglish grammar. struct NF(a) in 0(1) time from the values of NF on (14) [theNpiN RbigN/N [that likes John</context>
<context position="30127" citStr="Hepple &amp; Morrill, 1989" startWordPosition="5132" endWordPosition="5135">een formal: to establish a normal form for parses of &amp;quot;pure&amp;quot; Cornbinatory Categorial Grammar. Given a sentence, every reading that is available to the grammar has exactly one normal-form parse, no matter how many parses it has in toto. A result worth remembering is that, although TAG-equivalent CCG allows free interaction among forward, backward, and crossed composition rules of any degree, two simple constraints serve to eliminate all spurious ambiguity. It turns out that all spurious ambiguity arises from associative &amp;quot;chains&amp;quot; such as A/B B/C C or A/B/C C/D D/E\F/G G/H. (Wit8 5 tenburg, 1987; Hepple &amp; Morrill, 1989) anticipate this result, at least for some fragments of CCG, but leave the proof to future work. These normal-form results for pure CCG lead directly to useful parsers for real, restricted CCG grammars. Two parsing algorithms have been presented for practical use. One algorithm finds only normal forms; this simply and safely eliminates spurious ambiguity under most real CCG grammars. The other, more complex algorithm solves the spurious ambiguity problem for any CCG grammar, by using normal forms as an efficient tool for grouping semantically equivalent parses. Both algorithms are safe, comple</context>
</contexts>
<marker>Hepple, Morrill, 1989</marker>
<rawString>Mark Hepple and Glyn Morrill. 1989. Parsing and derivational equivalence. In Proceedings of the Fourth Conference of the European Chapter of the Association for Computational Linguistics, 10-18, University of Manchester, April.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Herman Hendriks</author>
</authors>
<title>Studied Flexibility: Categories and Types in Syntax and Semantics.</title>
<date>1993</date>
<tech>Ph.D. thesis,</tech>
<institution>Institute for Logic, Language, and Computation, University of Amsterdam.</institution>
<contexts>
<context position="3011" citStr="Hendriks, 1993" startWordPosition="461" endWordPosition="462">2 that the method constructs exactly one syntactic structure per semantic reading—e.g., just two parses for (3). All other parses are suppressed by simple normal-form constraints that are enforced throughout the parsing process. This approach works because CCG&apos;s spurious ambiguities arise (as is shown) in only a small set of circumstances. Although similar work has been attempted in the past, with varying degrees of success (Karttunen, 1986; Wittenburg, 1986; Pareschi &amp; Steedman, 1987; Bouma, 1989; Hepple &amp; Morrill, 1989; Ki5nig, 1989; Vijay-Shanker &amp; Weir, 1990; Hepple, 1990; Moortgat, 1990; Hendriks, 1993; Niv, 1994), this appears to be the first full normal-form result for a categorial formalism having more than contextfree power. 2 Definitions and Related Work CCG may be regarded as a generalization of contextfree grammar (CFG)—one where a grammar has infinitely many nonterminals and phrase-structure rules. In addition to the familiar atomic nonterminal categories (typically S for sentences, N for 1Namely, Mary pretends to like the galoot in 168 parses and the corner in 84. One might try a statistical approach to ambiguity resolution, discarding the low-probability parses, but it is unclear </context>
<context position="7204" citStr="Hendriks, 1993" startWordPosition="1174" endWordPosition="1175">le grammar with a decidable rule set. shown in (5) except for (5f). If we slightly conEven as restricted by (Joshi et al., 1991), CCGs strain the use of the grammar rules, the parser will have the &amp;quot;mildly context-sensitive&amp;quot; expressive power still produce (5c) and (5d)—constituents that are of Tree Adjoining Grammars (TAGs). Most work indispensable in contexts like (1)—while refusing to on spurious ambiguity has focused on categorial for- combine those constituents into (51). The relevant malisms with substantially less power. (Hepple, rule S/NP NP S will actually be blocked when it 1990) and (Hendriks, 1993), the most rigorous pieces attempts to construct (5f). Although rule-blocking of work, each establish a normal form for the syn- may eliminate an analysis of the sentence, as it does tactic calculus of (Lambek, 1958), which is weakly here, a semantically equivalent analysis such as (5g) context-free. (Konig, 1989; Moortgat, 1990) have will always be derivable along some other route. also studied the Lambek calculus case. (Hepple In general, our goal is to discover exactly one analMorrill, 1989), who introduced the idea of normal- ysis for each &lt;substring, meaning&gt; pair. By pracform parsing, co</context>
<context position="14503" citStr="Hendriks, 1993" startWordPosition="2415" endWordPosition="2416">d. Bwd. composition &lt;Bn (n &gt; 1): inzn • • • I2z2 Y InZn • • • 12Z2 X \y—FC Inzn • • • 12z2 x \ y—oT -4 X InZri • l22liZi AC1AC2 • • • Acn • f (g(ci)(c2) • • • (cn)) -4 X InZn • •4* 12Z2 11Z1 AC1AC2 ...Acn•i(g(ci)(c2) • • (cn)) x/y 4 Inzn • •1122.2 11Z1 y lnzn • • • I2z2 x\y 4 4 b. A/C/F A/C/E E/F A/C/D D/E A/B B/C/D AxAy.f(g(h(k(x)))(y)) A/C/F AIB B/C/D DIE E/F h k C. (11) a. Syn/sem for &gt;Bn (n 0): b. Syn/sem for &lt;Bn (n 0): (12) a. A/C/F A/C/D D/F A/B B/C/D D/E E/F It is interesting to note a rough resemblance between the tagged version of CCG in (10) and the tagged Lambek calculus L*, which (Hendriks, 1993) developed to eliminate spurious ambiguity from the Lambek calculus L. Although differences between CCG and L mean that the details are quite different, each system works by marking the output of certain rules, to prevent such output from serving as input to certain other rules. 4.1 Semantic equivalence We wish to establish that each semantic equivalence class contains exactly one NF parse. But what does &amp;quot;semantically equivalent&amp;quot; mean? Let us adopt a standard model-theoretic view. For each leaf (i.e., lexeme) of a given syntax tree, the lexicon specifies a lexical interpretation from the model</context>
<context position="19926" citStr="Hendriks, 1993" startWordPosition="3357" endWordPosition="3358">s having distinct terms must have different the latter case, WLOG, R is a forward rule and interpretations in the model (for suitable interpretaNF(#) = &lt;Q, 13i, /32&gt; for some forward com- tions of the words, as in §4.1). Theorem 2 is proved position rule Q. Pure CCG turns out to pro- by showing that the terms for a and a&apos; differ somevide forward rules S and T such that a&apos; = where, so correspond to different semantic recipes. &lt;S, , NF(&lt;T, , 7&gt;)&gt; is a constituent and Similar theorems for the Lambek calculus were is semantically equivalent to a. Moreover, since previously shown by (Hepple, 1990; Hendriks, 1993). 131 serves as the primary subtree of the NF tree The present proofs for CCG establish a result that NF(#), fi1. cannot be the output of forward com- has long been suspected: the spurious ambiguity position, and is NF besides. Therefore a&apos; is NF: problem is not actually very widespread in CCG. take NF(a) = a&apos;. Theorem 2 says all cases of spurious ambiguity (13) If NF(13) not output of fwd. composition, can be eliminated through the construction given a = (1=-!-.f NF(a) in theorem 1. But that construction merely en13 7 NF (#) (-y) sures a right-branching structure for &amp;quot;forward constituent chai</context>
</contexts>
<marker>Hendriks, 1993</marker>
<rawString>Herman Hendriks. 1993. Studied Flexibility: Categories and Types in Syntax and Semantics. Ph.D. thesis, Institute for Logic, Language, and Computation, University of Amsterdam.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Aravind Joshi</author>
<author>K Vijay-Shanker</author>
<author>David Weir</author>
</authors>
<title>The convergence of mildly context-sensitive grammar formalisms.</title>
<date>1991</date>
<booktitle>In Foundational Issues in Natural Language Processing,</booktitle>
<publisher>MIT Press.</publisher>
<contexts>
<context position="4804" citStr="Joshi et al., 1991" startWordPosition="760" endWordPosition="763">, but (Hepple, 1987) shows their algorithm to alyzed as subjectless sentences S \NP, while &amp;quot;John be incomplete. likes&amp;quot; is an objectless sentence or S/NP. A complex 3 Overview of the Parsing Strategy category like ( (S \NP) \ (S \NP))/N may be written as As is well known, general CFG parsing methods S \NP \ (S \NP)/N, under a convention that slashes are can be applied directly to CCG. Any sort of chart left-associative. parser or non-deterministic shift-reduce parser will The results herein apply to the TAG-equivalent do. Such a parser repeatedly decides whether two CCG formalization given in (Joshi et al., 1991).2 adjacent constituents, such as S/NP and NP/N, should In this variety of CCG, every (non-lexical) phrase- be combined into a larger constituent such as S/N. structure rule is an instance of one of the following The role of the grammar is to state which combibinary-rule templates (where n 0): nations are allowed. The key to efficiency, we will (4) Forward generalized composition &gt;Bn: see, is for the parser to be less permissive than the xly Y Inzn • • • 12z2 lizi Inn • • • I2z2 lizi grammar—for it to say &amp;quot;no, redundant&amp;quot; in some Backward generalized composition &lt;Bn: cases where the grammar say</context>
<context position="6203" citStr="Joshi et al., 1991" startWordPosition="1008" endWordPosition="1011">th n = 0 are called application rules, and Mary.&amp;quot; The spurious ambiguity problem is not that instances with n &gt; 1 are called composition rules. In the grammar allows (5c), but that the grammar ala given rule, x,y,z1...zn would be instantiated as lows both (5f) and (5g)—distinct parses of the same categories like NP, S/NP, or S \NP \ (S\NP)/N. Each of string, with the same meaning. 11 through ln would be instantiated as either / or \ (5) a. [John]si(s\Np) A fixed CCG grammar need not include every b. [likes](swp)/Np phrase-structure rule matching these templates. In- c. [John likes]siNp deed, (Joshi et al., 1991) place certain restrictions d. [Mary]Np on the rule set of a CCG grammar, including a re- e. [likes Mary]s \Np quirement that the rule degree n is bounded over the f. [[John likes] Mary]s to be disallowed set. The results of the present paper apply to such g. [John [likes Mary]]s restricted grammars and also more generally, to any The proposal is to construct all constituents CCG-style grammar with a decidable rule set. shown in (5) except for (5f). If we slightly conEven as restricted by (Joshi et al., 1991), CCGs strain the use of the grammar rules, the parser will have the &amp;quot;mildly context-s</context>
</contexts>
<marker>Joshi, Vijay-Shanker, Weir, 1991</marker>
<rawString>Aravind Joshi, K. Vijay-Shanker, and David Weir. 1991. The convergence of mildly context-sensitive grammar formalisms. In Foundational Issues in Natural Language Processing, MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
</authors>
<date>1986</date>
<tech>Radical lexicalism. Report No. CSLI-86-68,</tech>
<institution>CSLI, Stanford University.</institution>
<contexts>
<context position="2841" citStr="Karttunen, 1986" startWordPosition="435" endWordPosition="437">enivp)/Np This paper presents a simple and flexible CCG parsing technique that prevents any such explosion of redundant CCG derivations. In particular, it is proved in §4.2 that the method constructs exactly one syntactic structure per semantic reading—e.g., just two parses for (3). All other parses are suppressed by simple normal-form constraints that are enforced throughout the parsing process. This approach works because CCG&apos;s spurious ambiguities arise (as is shown) in only a small set of circumstances. Although similar work has been attempted in the past, with varying degrees of success (Karttunen, 1986; Wittenburg, 1986; Pareschi &amp; Steedman, 1987; Bouma, 1989; Hepple &amp; Morrill, 1989; Ki5nig, 1989; Vijay-Shanker &amp; Weir, 1990; Hepple, 1990; Moortgat, 1990; Hendriks, 1993; Niv, 1994), this appears to be the first full normal-form result for a categorial formalism having more than contextfree power. 2 Definitions and Related Work CCG may be regarded as a generalization of contextfree grammar (CFG)—one where a grammar has infinitely many nonterminals and phrase-structure rules. In addition to the familiar atomic nonterminal categories (typically S for sentences, N for 1Namely, Mary pretends to l</context>
<context position="9155" citStr="Karttunen, 1986" startWordPosition="1481" endWordPosition="1482">989) pro- (6) that galoot in the corner that thinks [John poses to replace composition with a new combina- likes MarAs tor, but the resulting product-grammar scheme as- For a chart parser, where each chart cell stores the analyses of some substring, this strategy says that 2This formalization sweeps any type-raising into the 80 lexicon, as has been proposed on linguistic grounds (Dowty, 1988; Steedman, 1991, and others). It also treats conjunction lexically, by giving &amp;quot;and&amp;quot; the generalized category x\x/x and barring it from composition. all analyses in a cell are to be semantically distinct. (Karttunen, 1986) suggests enforcing that property directly—by comparing each new analysis semantically with existing analyses in the cell, and refusing to add it if redundant—but (Hepple &amp; Morrill, 1989) observe briefly that this is inefficient for large charts.3 The following sections show how to obtain effectively the same result without doing any semantic interpretation or comparison at all. 4 A Normal Form for &amp;quot;Pure&amp;quot; CCG It is convenient to begin with a special case. Suppose the CCG grammar includes not some but all instances of the binary rule templates in (4). (As always, a separate lexicon specifies th</context>
<context position="21019" citStr="Karttunen, 1986" startWordPosition="3549" endWordPosition="3550"> theorem 1. But that construction merely en13 7 NF (#) (-y) sures a right-branching structure for &amp;quot;forward constituent chains&amp;quot; (such as A/B B/C C or A/B/C C/D D/E/F/G G/H), and a left-branching structure for backward constituent chains. So these familiar chains are the only source of spurious ambiguity in CCG. 5 Extending the Approach to &amp;quot;Restricted&amp;quot; CCG The &amp;quot;pure&amp;quot; CCG of §4 is a fiction. Real CCG grammars can and do choose a subset of the possible rules. else a = 83 # 7 NF(0) -y 4(Hepple &amp; Morrill, 1989; Hepple, 1990; Hendriks, 1993) appear to share this view of semantic equivalence. Unlike (Karttunen, 1986), they try to eliminate only parses whose denotations (or at least A-terms) are systematically equivalent, not parses that happen to have the same denotation through an accident of the lexicon. For instance, to rule out (14), the (crossing) back- as a magnet for a&apos;s semantic class. The proof of ward rule N/N 11\11 N/N must be omitted from theorem 1 (see (13)) actually shows how to conEnglish grammar. struct NF(a) in 0(1) time from the values of NF on (14) [theNpiN RbigN/N [that likes JohniN\NIN/N smaller constituents. Hence, an appropriate parser galootN IN }NP can compute and cache the NF of </context>
<context position="23807" citStr="Karttunen, 1986" startWordPosition="4017" endWordPosition="4018">arse is avail- branching parse, or the parse with fewer nonable, its method of controlling spurious ambiguity standard constituents. Alternatively, PreferableTo cannot be to enforce the constraints (7). The old may call an intonation or discourse module to pick parser refused to build non-NF constituents; the new the parse that better reflects the topic-focus diviparser will refuse to build constituents that are se- sion of the sentence. (A variant algorithm ignores mantically equivalent to already-built constituents. PreferableTo and constructs one parse forest per This idea originates with (Karttunen, 1986). reading. Each forest can later be unpacked into inHowever, we can take advantage of the core result dividual equivalent parse trees, if desired.) of this paper, theorems 1 and 2, to do Karttunen&apos;s (Vijay-Shanker Sz Weir, 1990) also give a method redundancy check in 0(1) time—no worse than the for removing &amp;quot;one well-known source&amp;quot; of spurious normal-form parser&apos;s check for —FC and –BC tags. ambiguity from restricted CCGs; §4.2 above shows (Karttunen&apos;s version takes worst-case exponential that this is in fact the only source. However, their time for each redundancy check: see footnote §3.) meth</context>
</contexts>
<marker>Karttunen, 1986</marker>
<rawString>Lauri Karttunen. 1986. Radical lexicalism. Report No. CSLI-86-68, CSLI, Stanford University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Konig</author>
</authors>
<title>Parsing as natural deduction.</title>
<date>1989</date>
<booktitle>In Proceedings of the 27th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<location>Vancouver.</location>
<contexts>
<context position="7518" citStr="Konig, 1989" startWordPosition="1223" endWordPosition="1224">(TAGs). Most work indispensable in contexts like (1)—while refusing to on spurious ambiguity has focused on categorial for- combine those constituents into (51). The relevant malisms with substantially less power. (Hepple, rule S/NP NP S will actually be blocked when it 1990) and (Hendriks, 1993), the most rigorous pieces attempts to construct (5f). Although rule-blocking of work, each establish a normal form for the syn- may eliminate an analysis of the sentence, as it does tactic calculus of (Lambek, 1958), which is weakly here, a semantically equivalent analysis such as (5g) context-free. (Konig, 1989; Moortgat, 1990) have will always be derivable along some other route. also studied the Lambek calculus case. (Hepple In general, our goal is to discover exactly one analMorrill, 1989), who introduced the idea of normal- ysis for each &lt;substring, meaning&gt; pair. By pracform parsing, consider only a small CCG frag- ticing &amp;quot;birth control&amp;quot; for each bottom-up generation ment that lacks backward or order-changing com- of constituents in this way, we avoid a population position; (Niv, 1994) extends this result but does explosion of parsing options. &amp;quot;John likes Mary&amp;quot; has not show completeness. (Witte</context>
</contexts>
<marker>Konig, 1989</marker>
<rawString>E. Konig. 1989. Parsing as natural deduction. In Proceedings of the 27th Annual Meeting of the Association for Computational Linguistics, Vancouver.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Lambek</author>
</authors>
<title>The mathematics of sentence structure.</title>
<date>1958</date>
<journal>American Mathematical Monthly</journal>
<pages>65--154</pages>
<contexts>
<context position="7420" citStr="Lambek, 1958" startWordPosition="1209" endWordPosition="1210">tive&amp;quot; expressive power still produce (5c) and (5d)—constituents that are of Tree Adjoining Grammars (TAGs). Most work indispensable in contexts like (1)—while refusing to on spurious ambiguity has focused on categorial for- combine those constituents into (51). The relevant malisms with substantially less power. (Hepple, rule S/NP NP S will actually be blocked when it 1990) and (Hendriks, 1993), the most rigorous pieces attempts to construct (5f). Although rule-blocking of work, each establish a normal form for the syn- may eliminate an analysis of the sentence, as it does tactic calculus of (Lambek, 1958), which is weakly here, a semantically equivalent analysis such as (5g) context-free. (Konig, 1989; Moortgat, 1990) have will always be derivable along some other route. also studied the Lambek calculus case. (Hepple In general, our goal is to discover exactly one analMorrill, 1989), who introduced the idea of normal- ysis for each &lt;substring, meaning&gt; pair. By pracform parsing, consider only a small CCG frag- ticing &amp;quot;birth control&amp;quot; for each bottom-up generation ment that lacks backward or order-changing com- of constituents in this way, we avoid a population position; (Niv, 1994) extends this</context>
</contexts>
<marker>Lambek, 1958</marker>
<rawString>J. Lambek. 1958. The mathematics of sentence structure. American Mathematical Monthly 65:154-169.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Moortgat</author>
</authors>
<title>Unambiguous proof representations for the Lambek Calculus.</title>
<date>1990</date>
<booktitle>In Proceedings of the Seventh</booktitle>
<location>Amsterdam Colloquium.</location>
<contexts>
<context position="2995" citStr="Moortgat, 1990" startWordPosition="459" endWordPosition="460">is proved in §4.2 that the method constructs exactly one syntactic structure per semantic reading—e.g., just two parses for (3). All other parses are suppressed by simple normal-form constraints that are enforced throughout the parsing process. This approach works because CCG&apos;s spurious ambiguities arise (as is shown) in only a small set of circumstances. Although similar work has been attempted in the past, with varying degrees of success (Karttunen, 1986; Wittenburg, 1986; Pareschi &amp; Steedman, 1987; Bouma, 1989; Hepple &amp; Morrill, 1989; Ki5nig, 1989; Vijay-Shanker &amp; Weir, 1990; Hepple, 1990; Moortgat, 1990; Hendriks, 1993; Niv, 1994), this appears to be the first full normal-form result for a categorial formalism having more than contextfree power. 2 Definitions and Related Work CCG may be regarded as a generalization of contextfree grammar (CFG)—one where a grammar has infinitely many nonterminals and phrase-structure rules. In addition to the familiar atomic nonterminal categories (typically S for sentences, N for 1Namely, Mary pretends to like the galoot in 168 parses and the corner in 84. One might try a statistical approach to ambiguity resolution, discarding the low-probability parses, bu</context>
<context position="7535" citStr="Moortgat, 1990" startWordPosition="1225" endWordPosition="1226">work indispensable in contexts like (1)—while refusing to on spurious ambiguity has focused on categorial for- combine those constituents into (51). The relevant malisms with substantially less power. (Hepple, rule S/NP NP S will actually be blocked when it 1990) and (Hendriks, 1993), the most rigorous pieces attempts to construct (5f). Although rule-blocking of work, each establish a normal form for the syn- may eliminate an analysis of the sentence, as it does tactic calculus of (Lambek, 1958), which is weakly here, a semantically equivalent analysis such as (5g) context-free. (Konig, 1989; Moortgat, 1990) have will always be derivable along some other route. also studied the Lambek calculus case. (Hepple In general, our goal is to discover exactly one analMorrill, 1989), who introduced the idea of normal- ysis for each &lt;substring, meaning&gt; pair. By pracform parsing, consider only a small CCG frag- ticing &amp;quot;birth control&amp;quot; for each bottom-up generation ment that lacks backward or order-changing com- of constituents in this way, we avoid a population position; (Niv, 1994) extends this result but does explosion of parsing options. &amp;quot;John likes Mary&amp;quot; has not show completeness. (Wittenburg, 1987) assu</context>
</contexts>
<marker>Moortgat, 1990</marker>
<rawString>Michael Moortgat. 1990. Unambiguous proof representations for the Lambek Calculus. In Proceedings of the Seventh Amsterdam Colloquium.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Niv</author>
</authors>
<title>A psycholinguistically motivated parser for CCG.</title>
<date>1994</date>
<booktitle>In Proceedings of the 32nd Annual Meeting of the Association for Computational Linguistics,</booktitle>
<location>Las Cruces, NM,</location>
<contexts>
<context position="3023" citStr="Niv, 1994" startWordPosition="463" endWordPosition="464">d constructs exactly one syntactic structure per semantic reading—e.g., just two parses for (3). All other parses are suppressed by simple normal-form constraints that are enforced throughout the parsing process. This approach works because CCG&apos;s spurious ambiguities arise (as is shown) in only a small set of circumstances. Although similar work has been attempted in the past, with varying degrees of success (Karttunen, 1986; Wittenburg, 1986; Pareschi &amp; Steedman, 1987; Bouma, 1989; Hepple &amp; Morrill, 1989; Ki5nig, 1989; Vijay-Shanker &amp; Weir, 1990; Hepple, 1990; Moortgat, 1990; Hendriks, 1993; Niv, 1994), this appears to be the first full normal-form result for a categorial formalism having more than contextfree power. 2 Definitions and Related Work CCG may be regarded as a generalization of contextfree grammar (CFG)—one where a grammar has infinitely many nonterminals and phrase-structure rules. In addition to the familiar atomic nonterminal categories (typically S for sentences, N for 1Namely, Mary pretends to like the galoot in 168 parses and the corner in 84. One might try a statistical approach to ambiguity resolution, discarding the low-probability parses, but it is unclear how to model</context>
<context position="8007" citStr="Niv, 1994" startWordPosition="1301" endWordPosition="1302">culus of (Lambek, 1958), which is weakly here, a semantically equivalent analysis such as (5g) context-free. (Konig, 1989; Moortgat, 1990) have will always be derivable along some other route. also studied the Lambek calculus case. (Hepple In general, our goal is to discover exactly one analMorrill, 1989), who introduced the idea of normal- ysis for each &lt;substring, meaning&gt; pair. By pracform parsing, consider only a small CCG frag- ticing &amp;quot;birth control&amp;quot; for each bottom-up generation ment that lacks backward or order-changing com- of constituents in this way, we avoid a population position; (Niv, 1994) extends this result but does explosion of parsing options. &amp;quot;John likes Mary&amp;quot; has not show completeness. (Wittenburg, 1987) assumes only one reading semantically, so just one of its anala CCG fragment lacking order-changing or higher- yses (5f)–(5g) is discovered while parsing (6). Only order composition; furthermore, his revision of the that analysis, and not the other, is allowed to concombinators creates new, conjoinable constituents tinue on and be built into the final parse of (6). that conventional CCG rejects. (Bouma, 1989) pro- (6) that galoot in the corner that thinks [John poses to r</context>
</contexts>
<marker>Niv, 1994</marker>
<rawString>Michael Niv. 1994. A psycholinguistically motivated parser for CCG. In Proceedings of the 32nd Annual Meeting of the Association for Computational Linguistics, Las Cruces, NM, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Remo Pareschi</author>
<author>Mark Steedman</author>
</authors>
<title>A lazy way to chart parse with combinatory grammars.</title>
<date></date>
<booktitle>In Proceedings of the 25th Annual Meeting of the Association</booktitle>
<institution>for Computational Linguistics, Stanford University,</institution>
<marker>Pareschi, Steedman, </marker>
<rawString>Remo Pareschi and Mark Steedman. A lazy way to chart parse with combinatory grammars. In Proceedings of the 25th Annual Meeting of the Association for Computational Linguistics, Stanford University, July.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Scott Prevost</author>
<author>Mark Steedman</author>
</authors>
<title>Specifying intonation from context for speech synthesis.</title>
<date>1994</date>
<journal>Speech Communication,</journal>
<pages>15--139</pages>
<contexts>
<context position="1159" citStr="Prevost &amp; Steedman, 1994" startWordPosition="164" endWordPosition="167">natory Categorial Grammar, by means of an efficient, correct, and easy to implement normal-form parsing technique. The parser is proved to find exactly one parse in each semantic equivalence class of allowable parses; that is, spurious ambiguity (as carefully defined) is shown to be both safely and completely eliminated. 1 Introduction Combinatory Categorial Grammar (Steedman, 1990), like other &amp;quot;flexible&amp;quot; categorial grammars, suffers from spurious ambiguity (Wittenburg, 1986). The non-standard constituents that are so crucial to CCG&apos;s analyses in (1), and in its account of intonational focus (Prevost &amp; Steedman, 1994), remain available even in simpler sentences. This renders (2) syntactically ambiguous. (1) a. Coordination: [[John likes]s/Np, and [Mary pretends to like&apos;s/Nip], the big galoot in the corner. b. Extraction: Everybody at this party [whom [John likes]siNp ] is a big galoot. (2) a. John [likes Mary]s Np. b. [John likesisiNp Mary. The practical problem of &amp;quot;extra&amp;quot; parses in (2) becomes exponentially worse for longer strings, which can have up to a Catalan number of parses. An This material is based upon work supported under a National Science Foundation Graduate Fellowship. I have been grateful fo</context>
</contexts>
<marker>Prevost, Steedman, 1994</marker>
<rawString>Scott Prevost and Mark Steedman. 1994. Specifying intonation from context for speech synthesis. Speech Communication, 15:139-153.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Steedman</author>
</authors>
<title>Gapping as constituent coordination.</title>
<date>1990</date>
<journal>Linguistics and Philosophy,</journal>
<pages>13--207</pages>
<contexts>
<context position="919" citStr="Steedman, 1990" startWordPosition="131" endWordPosition="132"> simple n-word sentence can have exponentially many parses. Generating all parses is inefficient and obscures whatever true semantic ambiguities are in the input. This paper addresses the problem for a fairly general form of Combinatory Categorial Grammar, by means of an efficient, correct, and easy to implement normal-form parsing technique. The parser is proved to find exactly one parse in each semantic equivalence class of allowable parses; that is, spurious ambiguity (as carefully defined) is shown to be both safely and completely eliminated. 1 Introduction Combinatory Categorial Grammar (Steedman, 1990), like other &amp;quot;flexible&amp;quot; categorial grammars, suffers from spurious ambiguity (Wittenburg, 1986). The non-standard constituents that are so crucial to CCG&apos;s analyses in (1), and in its account of intonational focus (Prevost &amp; Steedman, 1994), remain available even in simpler sentences. This renders (2) syntactically ambiguous. (1) a. Coordination: [[John likes]s/Np, and [Mary pretends to like&apos;s/Nip], the big galoot in the corner. b. Extraction: Everybody at this party [whom [John likes]siNp ] is a big galoot. (2) a. John [likes Mary]s Np. b. [John likesisiNp Mary. The practical problem of &amp;quot;extr</context>
</contexts>
<marker>Steedman, 1990</marker>
<rawString>Mark Steedman. 1990. Gapping as constituent coordination. Linguistics and Philosophy, 13:207-264.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Steedman</author>
</authors>
<date>1991</date>
<booktitle>Structure and intonation. Language,</booktitle>
<pages>67--260</pages>
<contexts>
<context position="8949" citStr="Steedman, 1991" startWordPosition="1449" endWordPosition="1450">sion of the that analysis, and not the other, is allowed to concombinators creates new, conjoinable constituents tinue on and be built into the final parse of (6). that conventional CCG rejects. (Bouma, 1989) pro- (6) that galoot in the corner that thinks [John poses to replace composition with a new combina- likes MarAs tor, but the resulting product-grammar scheme as- For a chart parser, where each chart cell stores the analyses of some substring, this strategy says that 2This formalization sweeps any type-raising into the 80 lexicon, as has been proposed on linguistic grounds (Dowty, 1988; Steedman, 1991, and others). It also treats conjunction lexically, by giving &amp;quot;and&amp;quot; the generalized category x\x/x and barring it from composition. all analyses in a cell are to be semantically distinct. (Karttunen, 1986) suggests enforcing that property directly—by comparing each new analysis semantically with existing analyses in the cell, and refusing to add it if redundant—but (Hepple &amp; Morrill, 1989) observe briefly that this is inefficient for large charts.3 The following sections show how to obtain effectively the same result without doing any semantic interpretation or comparison at all. 4 A Normal F</context>
<context position="28478" citStr="Steedman, 1991" startWordPosition="4871" endWordPosition="4872"> grammars.) parse from every equivalence class. (17) a. VP0/NP (&lt;sx) VP i/NP (&lt;Sx) VPAVP1 VP2/NP VPI \VP2/NP yesterday filed [without-reading] b. VP /NP (&lt;Sx) VP2/NP VP0\VP2/NP (&lt;B2) VP1\VP2/NP VPAVP1 (18) a. No constituent produced by &gt;Bn, any n &gt; 2, ever serves as the primary (left) argument to &gt;S. b. No constituent produced by &lt;Bn, any n &gt; 2, ever serves as the primary (right) argument to &lt;S. Type-raising presents a greater problem. Various new spurious ambiguities arise if it is permitted freely in the grammar. In principle one could proceed without grammatical type-raising: (Dowty, 1988; Steedman, 1991) have argued on linguistic grounds that type-raising should be treated as a mere lexical redundancy property. That is, whenever the lexicon contains an entry of a certain category X, with semantics x, it also contains one with (say) category T/ (T \X) and interpretation Ap.p(x). As one might expect, this move only sweeps the problem under the rug. If type-raising is lexical, then the definitions of this paper do not recognize (19) as a spurious ambiguity, because the two parses are now, technically speaking, analyses of different sentences. Nor do they recognize the redundancy in (20), because</context>
</contexts>
<marker>Steedman, 1991</marker>
<rawString>Mark Steedman. 1991. Structure and intonation. Language, 67:260-296.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Steedman</author>
</authors>
<title>Combinatory grammars and parasitic gaps.</title>
<date>1987</date>
<booktitle>Natural Language and Linguistic Theory,</booktitle>
<pages>5--403</pages>
<contexts>
<context position="2886" citStr="Steedman, 1987" startWordPosition="442" endWordPosition="444">xible CCG parsing technique that prevents any such explosion of redundant CCG derivations. In particular, it is proved in §4.2 that the method constructs exactly one syntactic structure per semantic reading—e.g., just two parses for (3). All other parses are suppressed by simple normal-form constraints that are enforced throughout the parsing process. This approach works because CCG&apos;s spurious ambiguities arise (as is shown) in only a small set of circumstances. Although similar work has been attempted in the past, with varying degrees of success (Karttunen, 1986; Wittenburg, 1986; Pareschi &amp; Steedman, 1987; Bouma, 1989; Hepple &amp; Morrill, 1989; Ki5nig, 1989; Vijay-Shanker &amp; Weir, 1990; Hepple, 1990; Moortgat, 1990; Hendriks, 1993; Niv, 1994), this appears to be the first full normal-form result for a categorial formalism having more than contextfree power. 2 Definitions and Related Work CCG may be regarded as a generalization of contextfree grammar (CFG)—one where a grammar has infinitely many nonterminals and phrase-structure rules. In addition to the familiar atomic nonterminal categories (typically S for sentences, N for 1Namely, Mary pretends to like the galoot in 168 parses and the corner i</context>
<context position="4109" citStr="Steedman, 1987" startWordPosition="646" endWordPosition="647">e might try a statistical approach to ambiguity resolution, discarding the low-probability parses, but it is unclear how to model and train any probabilities when no single parse can be taken as the standard of correctness. 79 nouns, NP for noun phrases, etc.), CCG allows in- signs different types to &amp;quot;John likes&amp;quot; and &amp;quot;Mary prefinitely many slashed categories. If x and y are tends to like,&amp;quot; thus losing the ability to conjoin such categories, then x/y (respectively x\y) is the cat- constituents or subcategorize for them as a class. egory of an incomplete x that is missing a y at its (Pareschi &amp; Steedman, 1987) do tackle the CCG right (respectively left). Thus verb phrases are an- case, but (Hepple, 1987) shows their algorithm to alyzed as subjectless sentences S \NP, while &amp;quot;John be incomplete. likes&amp;quot; is an objectless sentence or S/NP. A complex 3 Overview of the Parsing Strategy category like ( (S \NP) \ (S \NP))/N may be written as As is well known, general CFG parsing methods S \NP \ (S \NP)/N, under a convention that slashes are can be applied directly to CCG. Any sort of chart left-associative. parser or non-deterministic shift-reduce parser will The results herein apply to the TAG-equivalent d</context>
<context position="25563" citStr="Steedman, 1987" startWordPosition="4308" endWordPosition="4309">the 6 Extensions to the CCG Formalism same normal form: NF(a)= NF(a&apos;). In addition to the Bn (&amp;quot;generalized composition&amp;quot;) The NF function is defined recursively by §4.2&apos;s rules given in §2, which give CCG power equivalent proof of theorem 1; semantic equivalence is also to TAG, rules based on the S (&amp;quot;substitution&amp;quot;) and defined independently of the grammar. So (15) is T (&amp;quot;type-raising&amp;quot;) combinators can be linguistically meaningful and true even if a, a&apos; are produced by useful. S provides another rule template, used in a restricted CCG. The tree NF(a) may not be a the analysis of parasitic gaps (Steedman, 1987; Szlegal parse under the restricted grammar. How- abolcsi, 1989): ever, it is still a perfectly good data structure that (16) a. &gt;s: x/y liz y liz --+ x liz can be maintained outside the parse chart, to serve 11 f g Az. f(z)(g(z)) b. &lt;S: y liz x\Y liz –+ x liz Although S interacts with Bn to produce another source of spurious ambiguity, illustrated in (17), the additional ambiguity is not hard to remove. It can be shown that when the restriction (18) is used together with (7), the system again finds exactly one 84 &apos;For the proof to work, the rules S and T must be available in the restricted g</context>
</contexts>
<marker>Steedman, 1987</marker>
<rawString>Mark Steedman. 1987. Combinatory grammars and parasitic gaps. Natural Language and Linguistic Theory, 5:403-439.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Anna Szabolcsi</author>
</authors>
<title>Bound variables in syntax: Are there any? In</title>
<date>1989</date>
<booktitle>Semantics and Contextual Expression,</booktitle>
<pages>295--318</pages>
<editor>R. Bartsch, J. van Benthem, and P. van Emde Boas (eds.),</editor>
<location>Foris, Dordrecht.</location>
<marker>Szabolcsi, 1989</marker>
<rawString>Anna Szabolcsi. 1989. Bound variables in syntax: Are there any? In R. Bartsch, J. van Benthem, and P. van Emde Boas (eds.), Semantics and Contextual Expression, 295-318. Foris, Dordrecht.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shanker</author>
<author>David Weir</author>
</authors>
<title>Polynomial time parsing of combinatory categorial grammars.</title>
<date>1990</date>
<booktitle>In Proceedings of the 28th Annual Meeting of the Association for Computational Linguistics.</booktitle>
<contexts>
<context position="2965" citStr="Vijay-Shanker &amp; Weir, 1990" startWordPosition="453" endWordPosition="456">undant CCG derivations. In particular, it is proved in §4.2 that the method constructs exactly one syntactic structure per semantic reading—e.g., just two parses for (3). All other parses are suppressed by simple normal-form constraints that are enforced throughout the parsing process. This approach works because CCG&apos;s spurious ambiguities arise (as is shown) in only a small set of circumstances. Although similar work has been attempted in the past, with varying degrees of success (Karttunen, 1986; Wittenburg, 1986; Pareschi &amp; Steedman, 1987; Bouma, 1989; Hepple &amp; Morrill, 1989; Ki5nig, 1989; Vijay-Shanker &amp; Weir, 1990; Hepple, 1990; Moortgat, 1990; Hendriks, 1993; Niv, 1994), this appears to be the first full normal-form result for a categorial formalism having more than contextfree power. 2 Definitions and Related Work CCG may be regarded as a generalization of contextfree grammar (CFG)—one where a grammar has infinitely many nonterminals and phrase-structure rules. In addition to the familiar atomic nonterminal categories (typically S for sentences, N for 1Namely, Mary pretends to like the galoot in 168 parses and the corner in 84. One might try a statistical approach to ambiguity resolution, discarding </context>
</contexts>
<marker>Vijay-Shanker, Weir, 1990</marker>
<rawString>K. Vijay-Shanker and David Weir. 1990. Polynomial time parsing of combinatory categorial grammars. In Proceedings of the 28th Annual Meeting of the Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shanker</author>
<author>David Weir</author>
</authors>
<title>Parsing some constrained grammar formalisms.</title>
<date>1993</date>
<journal>Computational Linguistics,</journal>
<pages>19--4</pages>
<contexts>
<context position="13331" citStr="Vijay-Shanker &amp; Weir, 1993" startWordPosition="2166" endWordPosition="2169">arses. No semantics is necessary; simply block any rule use that would violate (7). In general, detecting violations will not hurt performance by more than a constant factor. Indeed, one might implement (7) by modifying CCG&apos;s phrase-structure grammar. Each ordinary CCG category is split into three categories that bear the respective tags from (9). The 24 templates schematized in (10) replace the two templates of (4). Any CFG-style method can still parse the resulting spuriosity-free grammar, with tagged parses as in (8). In particular, the polynomial-time, polynomialspace CCG chart parser of (Vijay-Shanker &amp; Weir, 1993) can be trivially adapted to respect the constraints by tagging chart entries. 81 (9) —FC output of &gt;Bn, some n &gt; 1 (a forward composition rule) —BC output of &lt;Bn, some n&gt; 1 (a backward composition rule) —OT output of &gt;BO or &lt;BO (an application rule), or lexical item (10) a. Forward application &gt;BO: xiy—BC y xiy—OT y—_FBCc x—OT y—OT {y—Fc b. Backward application &lt;BO: y—BC } { , x\y—Fc } y —0T x\y—OT x—IDT /y—BC InZn &amp;quot; • 12Z2 Inzn • • I2z2 11.24--FC c. Fwd. composition &gt;Bn (n 1): { xx/y—oT Y Inzn • • • -4 X IriZri • • • 12z2 y inzn 122:22 IlizzillsocT d. Bwd. composition &lt;Bn (n &gt; 1): inzn • • •</context>
</contexts>
<marker>Vijay-Shanker, Weir, 1993</marker>
<rawString>K. Vijay-Shanker and David Weir. 1993. Parsing some constrained grammar formalisms. Computational Linguistics, 19(4):591-636.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shanker</author>
<author>David Weir</author>
</authors>
<title>The equivalence of four extensions of context-free grammars.</title>
<date>1994</date>
<booktitle>Mathematical Systems Theory,</booktitle>
<pages>27--511</pages>
<marker>Vijay-Shanker, Weir, 1994</marker>
<rawString>K. Vijay-Shanker and David Weir. 1994. The equivalence of four extensions of context-free grammars. Mathematical Systems Theory, 27:511-546.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kent Wittenburg</author>
</authors>
<title>Natural Language Parsing with Combinatory Categorial Grammar in a Graph-Unification-Based Formalism.</title>
<date>1986</date>
<tech>Ph.D. thesis,</tech>
<institution>University of Texas.</institution>
<contexts>
<context position="1014" citStr="Wittenburg, 1986" startWordPosition="142" endWordPosition="143">ent and obscures whatever true semantic ambiguities are in the input. This paper addresses the problem for a fairly general form of Combinatory Categorial Grammar, by means of an efficient, correct, and easy to implement normal-form parsing technique. The parser is proved to find exactly one parse in each semantic equivalence class of allowable parses; that is, spurious ambiguity (as carefully defined) is shown to be both safely and completely eliminated. 1 Introduction Combinatory Categorial Grammar (Steedman, 1990), like other &amp;quot;flexible&amp;quot; categorial grammars, suffers from spurious ambiguity (Wittenburg, 1986). The non-standard constituents that are so crucial to CCG&apos;s analyses in (1), and in its account of intonational focus (Prevost &amp; Steedman, 1994), remain available even in simpler sentences. This renders (2) syntactically ambiguous. (1) a. Coordination: [[John likes]s/Np, and [Mary pretends to like&apos;s/Nip], the big galoot in the corner. b. Extraction: Everybody at this party [whom [John likes]siNp ] is a big galoot. (2) a. John [likes Mary]s Np. b. [John likesisiNp Mary. The practical problem of &amp;quot;extra&amp;quot; parses in (2) becomes exponentially worse for longer strings, which can have up to a Catalan</context>
<context position="2859" citStr="Wittenburg, 1986" startWordPosition="438" endWordPosition="439">per presents a simple and flexible CCG parsing technique that prevents any such explosion of redundant CCG derivations. In particular, it is proved in §4.2 that the method constructs exactly one syntactic structure per semantic reading—e.g., just two parses for (3). All other parses are suppressed by simple normal-form constraints that are enforced throughout the parsing process. This approach works because CCG&apos;s spurious ambiguities arise (as is shown) in only a small set of circumstances. Although similar work has been attempted in the past, with varying degrees of success (Karttunen, 1986; Wittenburg, 1986; Pareschi &amp; Steedman, 1987; Bouma, 1989; Hepple &amp; Morrill, 1989; Ki5nig, 1989; Vijay-Shanker &amp; Weir, 1990; Hepple, 1990; Moortgat, 1990; Hendriks, 1993; Niv, 1994), this appears to be the first full normal-form result for a categorial formalism having more than contextfree power. 2 Definitions and Related Work CCG may be regarded as a generalization of contextfree grammar (CFG)—one where a grammar has infinitely many nonterminals and phrase-structure rules. In addition to the familiar atomic nonterminal categories (typically S for sentences, N for 1Namely, Mary pretends to like the galoot in </context>
</contexts>
<marker>Wittenburg, 1986</marker>
<rawString>Kent Wittenburg. 1986. Natural Language Parsing with Combinatory Categorial Grammar in a Graph-Unification-Based Formalism. Ph.D. thesis, University of Texas.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kent Wittenburg</author>
</authors>
<title>Predictive combinators: A method for efficient parsing of Combinatory Categorial Grammars.</title>
<date>1987</date>
<booktitle>In Proceedings of the 25th Annual Meeting of the Association</booktitle>
<institution>for Computational Linguistics, Stanford University,</institution>
<contexts>
<context position="8130" citStr="Wittenburg, 1987" startWordPosition="1319" endWordPosition="1320"> 1989; Moortgat, 1990) have will always be derivable along some other route. also studied the Lambek calculus case. (Hepple In general, our goal is to discover exactly one analMorrill, 1989), who introduced the idea of normal- ysis for each &lt;substring, meaning&gt; pair. By pracform parsing, consider only a small CCG frag- ticing &amp;quot;birth control&amp;quot; for each bottom-up generation ment that lacks backward or order-changing com- of constituents in this way, we avoid a population position; (Niv, 1994) extends this result but does explosion of parsing options. &amp;quot;John likes Mary&amp;quot; has not show completeness. (Wittenburg, 1987) assumes only one reading semantically, so just one of its anala CCG fragment lacking order-changing or higher- yses (5f)–(5g) is discovered while parsing (6). Only order composition; furthermore, his revision of the that analysis, and not the other, is allowed to concombinators creates new, conjoinable constituents tinue on and be built into the final parse of (6). that conventional CCG rejects. (Bouma, 1989) pro- (6) that galoot in the corner that thinks [John poses to replace composition with a new combina- likes MarAs tor, but the resulting product-grammar scheme as- For a chart parser, wh</context>
</contexts>
<marker>Wittenburg, 1987</marker>
<rawString>Kent Wittenburg. 1987. Predictive combinators: A method for efficient parsing of Combinatory Categorial Grammars. In Proceedings of the 25th Annual Meeting of the Association for Computational Linguistics, Stanford University, July.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>