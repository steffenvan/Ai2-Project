<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000010">
<note confidence="0.7312704">
A LOGICAL SEMANTICS FOR FEATURE STRUCTURES
Robert T. Kasper and William C. Rounds
Electrical Engineering and Computer Science Department
University of Michigan
Ann Arbor, Michigan 48109
</note>
<sectionHeader confidence="0.971355" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999764419354839">
Unification-based grammar formalisms use struc-
tures containing sets of features to describe lin-
guistic objects. Although computational algo-
rithms for unification of feature structures have
been worked out in experimental research, these
algorithms become quite complicated, and a more
precise description of feature structures is desir-
able. We have developed a model in which de-
scriptions of feature structures can be regarded
as logical formulas, and interpreted by sets of di-
rected graphs which satisfy them. These graphs
are, in fact, transition graphs for a special type
of deterministic finite automaton.
This semantics for feature structures extends
the ideas of Pereira and Shieber [111, by providing
an interpretation for values which are specified
by disjunctions and path values, embedded within
disjunctions. Our interpretation differs from that
of Pereira and Shieber by using a logical model
in place of a denotational semantics. This logical
model yields a calculus of equivalences, which can
be used to simplify formulas.
Unification is attractive, because of its gener-
ality, but it is often computationally inefficient.
Our model allows a careful examination of the
computational complexity of unification. We
have shown that the consistency problem for for-
mulas with disjunctive values is NP-complete. To
deal with this complexity, we describe how dis-
junctive values can be specified in a way which
delays expansion to disjunctive normal form.
</bodyText>
<sectionHeader confidence="0.994056" genericHeader="keywords">
1 Background:
</sectionHeader>
<subsectionHeader confidence="0.920027">
Unification in Grammar
</subsectionHeader>
<bodyText confidence="0.999596214285714">
Several different approaches to natural lan-
guage grammar have developed the notion of
feature structures to describe linguistic objects.
These approaches include linguistic theories, such
as Generalized Phrase Structure Grammar (GPSG) [2],
Lexical Functional Grammar (LFG) [4], and Sys-
temic Grammar [3]. They also include grammar
formalisms which have been developed as com-
putational tools, such as Functional Unification
Grammar (FUG) [7], and PATR-II [14]. In these
computational formalisms, unification is the pri-
mary operation for matching and combining fea-
ture structures.
Feature structures are called by several differ-
ent names, including f-structures in LFG, and
functional descriptions in FUG. Although they
differ in details, each approach uses structures
containing sets of attributes. Each attribute is
composed of a label/value pair. A value may be
an atomic symbol, but it may also be a nested
feature structure.
The intuitive interpretation of feature struc-
tures may be clear to linguists who use them,
even in the absence of a precise definition. Of-
ten, a precise definition of a useful notation be-
comes possible only after it has been applied to
the description of a variety of phenomena. Then,
greater precision may become necessary for clari-
fication when the notation is used by many differ-
ent investigators. Our model has been developed
in the context of providing a precise interpreta-
tion for the feature structures which are used in
FUG and PATR-II. Some elements of this logi-
cal interpretation have been partially described
in Kay&apos;s work [8]. Our contribution is to give
a more complete algebraic account of the logi-
cal properties of feature structures, which can be
used explicitly for computational manipulation
and mathematical analysis. Proofs of the math-
ematical soundness and completeness of this log-
ical treatment, along with its relation to similar
logics, can be found in [12].
</bodyText>
<sectionHeader confidence="0.9533545" genericHeader="introduction">
2 Disjunction and
Non-Local Values
</sectionHeader>
<bodyText confidence="0.9999">
Karttunen [5] has shown that disjunction and
negation are desirable extensions to PATR-II
which are motivated by a wide range of linguistic
</bodyText>
<page confidence="0.991096">
257
</page>
<note confidence="0.9931354">
die = case : {nom ace} local path values in Section 5.4.
gender : fern 3 Logical Formulas for
agreement : number : sing Feature Structures
1
number : pl 1
</note>
<figureCaption confidence="0.969628">
Figure 1: A Feature Structure containing Value
Disjunction.
</figureCaption>
<bodyText confidence="0.999882266666667">
phenomena. He discusses specifying attributes by
disjunctive values, as shown in Figure 1. A value
disjunction specifies alternative values of a single
attribute. These alternative values may be either
atomic or complex. Disjunction of a more gen-
eral kind is an essential element of FUG. General
disjunction is used to specify alternative groups
of multiple attributes, as shown in Figure 2.
Karttunen describes a method by which the ba-
sic unification procedure can be extended to han-
dle negative and disjunctive values, and explains
some of the complications that result from intro-
ducing value disjunction. When two values, A
and B, are to be unified, and A is a disjunction,
we cannot actually unify B with both alternatives
of A, because one of the alternatives may become
incompatible with B through later unifications.
Instead we need to remember .a constraint that
at least one of the alternatives of A must remain
compatible with B.
An additional complication arises when one of
the alternatives of a disjunction contains a value
which is specified by a non-local path, a situa-
tion which occurs frequently in Functional Unifi-
cation Grammar. In Figure 2 the obj attribute in
the description of the adjunct attribute is given
the value &lt; actor &gt;, which means that the obj
attribute is to be unified with the value found
at the end of the path labeled by &lt; actor &gt; in
the outermost enclosing structure. This unifica-
tion with a non-local value can be performed only
when the alternative which contains it is the only
alternative remaining in the disjunction. Oth-
erwise, the case = objective attribute might be
added to the value of &lt; actor &gt; prematurely,
when the alternative containing adjunct is not
used. Thus, the constraints on alternatives of a
disjunction must also apply to any non-local val-
ues contained within those alternatives. These
complications, and the resulting proliferation of
constraints, provide a practical motivation for the
logical treatment given in this paper. We suggest
a solution to the problem of representing non-
The feature structure of Figure 1 can also be
represented by a type of logical formula:
</bodyText>
<figure confidence="0.77765025">
die = case : (nom V acc)
A agreement: (
(gender: fern A number: sing)
V number : pi)
</figure>
<bodyText confidence="0.99893575">
This type of formula differs from standard propo-
sitional logic in that a theoretically unlimited set
of atomic values is used in place of boolean val-
ues. The labels of attributes bear a superficial
resemblance to modal operators. Note that no
information is added or subtracted by rewriting
the feature matrix of Figure 1 as a logical formula.
These two forms may be regarded as notational
variants for expressing the same facts. While fea-
ture matrices seem to be a more appealing and
natural notation for displaying linguistic descrip-
tions, logical formulas provide a precise interpre-
tation which can be useful for computational and
mathematical purposes.
Given this intuitive introduction we proceed to
a more complete definition of this logic.
</bodyText>
<sectionHeader confidence="0.982234" genericHeader="method">
4 A Logical Semantics
</sectionHeader>
<bodyText confidence="0.999921909090909">
As Pereira and Shieber [11] have pointed out, a
grammatical formalism can be regarded in a way
similar to other representation languages. Often
it is useful to use a representation language which
is disctinct from the objects it represents. Thus,
it can be useful to make a distinction between the
domain of feature structures and the domain of
their descriptions. As we shall see, this distinc-
tion allows a variety of notational devices to be
used in descriptions, and interpreted in a consis-
tent way with a uniform kind of structure.
</bodyText>
<subsectionHeader confidence="0.999318">
4.1 Domain of Feature
Structures
</subsectionHeader>
<bodyText confidence="0.9980386">
The PATR-II system uses directed acyclic
graphs (dags) as an underlying representation for
feature structures. In order to build complex
feature structures, two primitive domains are re-
quired:
</bodyText>
<page confidence="0.991638">
258
</page>
<figure confidence="0.995831533333334">
cat = s
sub j = [ case = nominative
[
voice &lt; ub
= active
to . &gt;
voice = passive
goal .&lt; sub j &gt;
cat = pp
adjunct = prep = by
obj =&lt; actor &gt;= [
1 [ mood = declarative 1
[ mood = interrogative I
case = objective ,
II
</figure>
<figureCaption confidence="0.992586">
Figure 2: Disjunctive specification containing non-local values, using the notation of FUG.
</figureCaption>
<sectionHeader confidence="0.9035155" genericHeader="method">
1. atoms (A)
2. labels (L)
</sectionHeader>
<bodyText confidence="0.973921571428571">
The elements of both domains are symbols, usu-
ally denoted by character strings. Attribute la-
bels (e.g., &amp;quot;case&amp;quot;) are used to mark edges in a
dag, and atoms (e.g., &amp;quot;gen&amp;quot;) are used as prim-
itive values at vertices which have no outgoing
edges.
A dag may also be regarded as a transition
graph for a partially specified deterministic fi-
nite automaton (DFA). This automaton recog-
nises strings of labels, and has final states which
are atoms, as well as final states which encode no
information. An automaton is formally described
by a tuple
A= (Q, (5,0, F)
where L is the set of labels above, 6 is a partial
function from Q X L to Q, and where certain el-
ements of F may be atoms from the set A. We
require that A be connected, acyclic, and have no
transitions from any final states.
DFAs have several desirable properties as a do-
main for feature structures:
</bodyText>
<listItem confidence="0.966231333333333">
1. the value of any defined path can be denoted
by a state of the automaton;
2. finding the value of a path is interpreted by
running the automaton on the path string;
3. the automaton captures the crucial proper-
ties of shared structure:
(a) two paths which are unified have the
same state as a value,
(b) unification is equivalent to a state-
merge operation;
4. the techniques of automata theory become
available for use with feature structures.
</listItem>
<bodyText confidence="0.994053230769231">
A consequence of item 3 above is that the dis-
tinction between type identity and token identity
is clearly revealed by an automaton; two objects
are necessarily the same token, if and only if they
are represented by the same state.
One construct of automata theory, the Nerode
relation, is useful to describe equivalent paths. If
A is an automaton, we let P(A) be the set of all
paths of A, namely the set E L` : 6 (go, x)
is defined }. The Nerode relation N (A) is the
equivalence relation defined on paths of P(A) by
letting
x N (A) y &lt;=*. 6 (go, x) = (go, y).
</bodyText>
<subsectionHeader confidence="0.99912">
4.2 Domain of Descriptions:
Logical Formulas
</subsectionHeader>
<bodyText confidence="0.999950166666667">
We now define the domain FML of logical for-
mulas which describe feature structures. Figure 3
defines the syntax of well formed formulas. In the
following sections symbols from the Greek alpha-
bet are used to stand for arbitrary formulas in
FML. The formulas NIL and TOP are intended
to convey &amp;quot;no information&amp;quot; and &amp;quot;inconsistent in-
formation&amp;quot; respectively. Thus, NIL corresponds
to a unification variable, and TOP corresponds
to unification failure. A formula 1: 4 would indi-
cate that a value has attribute 1, which is itself a
value satisfying the condition 0.
</bodyText>
<page confidence="0.987643">
259
</page>
<figure confidence="0.997425166666667">
NIL
TOP
a E A
i&lt; &gt; , • • • , &lt; pn &gt;I where each pi EL*
1 : (0 where 1 E L and E FML
A 1,6
</figure>
<figureCaption confidence="0.999984">
Figure 3: The domain, FML, of logical formulas.
</figureCaption>
<bodyText confidence="0.999937357142857">
Conjunction and disjunction will have their or-
dinary logical meaning as operators in formulas.
An interesting result is that conjunction can be
used to describe unification. Unifying two struc-
tures requires finding a structure which has all
features of both structures; the conjunction of
two formulas describes the structures which sat-
isfy all conditions of both formulas.
One difference between feature structures and
their descriptions should be noted. In a feature
structure it is required that a particular attribute
have a unique value, while in descriptions it is
possible to specify, using conjunction, several val-
ues for the same attribute, as in the formula
</bodyText>
<equation confidence="0.504569">
subj : (person: 3) A subj : (number: sing).
</equation>
<bodyText confidence="0.997745266666666">
A feature structure satisfying such a description
will contain a unique value for the attribute,
which can be found by unifying all of the values
that are specified in the description.
Formulas may also contain sets of paths, de-
noting equivalence classes. Each element of the
set represents an existing path starting from the
initial state of an automaton, and all paths in the
set are required to have a common endpoint. If
E = i&lt; x &gt;,&lt; y &gt;11, we will sometimes write E
as &lt; x &gt;.&lt; y&gt;. This is the notation of PATR-
II for pairs of equivalent paths. In subsequent
sections we use E (sometimes with subscripts) to
stand for a set of paths that belong to the same
equivalence class.
</bodyText>
<subsectionHeader confidence="0.999362">
4.3 Interpretation of Formulas
</subsectionHeader>
<bodyText confidence="0.999050666666667">
We can now state inductively the exact con-
ditions under which an automaton A satisfies a
formula:
</bodyText>
<listItem confidence="0.986972">
1. A NIL always;
2. A TOP never;
3. A = a •:=:- A is the one-state automaton a
with no transitions;
4. A 1= E E is a subset of an equivalence
class of N (A);
5. A : -4=*- All is defined
and All =1);
6. A ct)Vti) A Hi) or A tk;
7..AAtk 4=4. A(kandAtP.
</listItem>
<bodyText confidence="0.827931">
where All is defined by a subgraph of the au-
tomaton A with start state 6(qo, 1), that is
if A = (Q, L, 6, go, F),
then A/1 = (Q&apos;, L, 8, gge, F&apos;);
where Q&apos; and F&apos; are formed from Q and F by
removing any states which are unreachable from
s(qo An, o.
Any formula an ula c be regarded as a specification
f orthe set of automata which satisfy it. In the
case of conjunctive formulas (containing no oc-
curences of disjunction) the set of automata satis-
fying the formula has a unique minimal element,
with respect to subsumption.1 For disjunctive
formulas there may be several minimal elements,
but always a finite number.
</bodyText>
<subsectionHeader confidence="0.999555">
4.4 Calculus of Formulas
</subsectionHeader>
<bodyText confidence="0.990333705882353">
It is possible to write many formulas which
have an identical interpretation. For example, the
formulas given in the equation below are satisfied
by the same set of automata.
case : (gen V acc v dat) A case : acc = case : acc
In this simple example it is clear that the right
side of the formula is equivalent to the left side,
and that it is simpler. In more complex examples
it is not always obvious when two formulas are
equivalent. Thus, we are led to state the laws of
equivalence shown in Figure 4. Note that equiv-
alence (26) is added only to make descriptions of
cyclic structures unsatisfiable.
IA subsumption order can be defined for the domain of
automata, just as it is defined for dags by Shieber [15].
A formal definition of subsumption for this domain ap-
pears in [12].
</bodyText>
<page confidence="0.967699">
260
</page>
<figure confidence="0.800441897435897">
Failure:
1: TOP = TOP
Conjunction (unification):
OATOP = TOP
0 A NIL = 11)
a A b = TOP, Va, .5 E A and a b
aA1:0 = TOP
1:0A1:0 =
Disjunction:
0 V NIL = NIL
0 V TOP = ck
1:0V1:0 =
Commutative:
0A0 = 0A0
0V0 = 0V0
Associative:
(Ab)AX = 0A(tbAX)
(66V)VX = OV(OVX)
Idempotent:
0 A 0 = 0
0 V 0 = 0
Distributive:
(OVVIAX = (OAX)V(lbAX)
414t = (96VX)A(OVX)
(Ak)VX
Absorption:
(0A0)V0 = 0
(0V0)A0 = 0
Path Equivalence:
Ei A E2 = E2 whenever El C E2
Ei A E2 = El A (E2 U {zY I z E Ei})
for any y such that ax : x E E1 and xY E E2
EAx:c = EA(A y:c)wherexEE
yEE
E = E A {z} if x is a prefix of a string in E
1 : E = {lw I w E El
{e} = NIL
E = TOP for any E such that there are strings
x, xy E E and y e
</figure>
<figureCaption confidence="0.99031">
Figure 4: Laws of Equivalence for Formulas.
</figureCaption>
<page confidence="0.855372">
261
</page>
<figure confidence="0.5575335">
5 Complexity of Disjunctive
Descriptions
</figure>
<bodyText confidence="0.997374666666667">
exponent depends on the number of disjunctions
in the formula (in the worst case).
To date, the primary benefit of using logical
formulas to describe feature structures has been
the clarification of several problems that arise
with disjunctive descriptions.
</bodyText>
<subsectionHeader confidence="0.964974">
5.1 NP-completeness of consistency
problem for formulas
</subsectionHeader>
<bodyText confidence="0.999902619047619">
One consequence of describing feature struc-
tures by logical formulas is that it is now rel-
atively easy to analyse the computational com-
plexity of various problems involving feature
structures. It turns out that the satisfiability
problem for CNF formulas of propositional logic
can be reduced to the consistency (or satisfia-
bility) problem for formulas in FML. Thus, the
consistency problem for formulas in FML is NP-
complete. It follows that any unification algo-
rithm for FML formulas will have non-polynomial
worst-case complexity (provided P 0 NP!), since
a correct unification algorithm must check for
consistency.
Note that disjunction is the source of this com-
plexity. If disjunction is eliminated from the do-
main of formulas, then the consistency problem is
in P. Thus systems, such as the original PATR-II,
which do not use disjunction in their descriptions
of feature structures, do not have to contend with
this source of NP-completeness.
</bodyText>
<subsectionHeader confidence="0.991037">
5.2 Disjunctive Normal Form
</subsectionHeader>
<bodyText confidence="0.832931666666667">
A formula is in disjunctive normal form (DNF)
if and only if it has the form 01 V .. . V On, where
each Oi is either
</bodyText>
<listItem confidence="0.8898">
1. a E A
2. th A ... A Om, where each tki is either
(a) II : ... : 1, : a, where a E A, and no
path occurs more than once
(b) i&lt; pi &gt;, ... , &lt; ph &gt;1, where each pi E
L*, and each set denotes an equivalence
class of paths, and all such sets disjoint.
</listItem>
<bodyText confidence="0.9996924">
The formal equivalences given in Figure 4 al-
low us to transform any satisfiable formula into
its disjunctive normal form, or to TOP if it is
not satisfiable. The algorithm for finding a nor-
mal form requires exponential time, where the
</bodyText>
<subsectionHeader confidence="0.995434">
5.3 Avoiding expansion to DNF
</subsectionHeader>
<bodyText confidence="0.999610791666667">
Most of the systems which are currently used
to implement unification-based grammars depend
on an expansion to disjunctive normal form in
order to compute with disjunctive descriptions.2
Such systems are exemplified by Definite Clause
Grammar [10], which eliminates disjunctive terms
by multiplying rules which contain them into al-
ternative clauses. Kay&apos;s parsing procedure for
Functional Unification Grammar [8] also requires
expanding functional descriptions to DNF before
they are used by the parser. This expansion may
not create much of a problem for grammars con-
taining a small number of disjunctions, but if the
grammar contains 100 disjunctions, the expan-
sion is clearly not feasible, due to the exponential
size of the DNF.
Ait-Kaci [1] has pointed out that the expan-
sion to DNF is not always necessary, in work with
type structures which are very similar to the fea-
ture structures that we have described here. Al-
though the NP-completeness result cited above
indicates that any unification algorithm for dis-
junctive formulas will have exponential complex-
ity in the worst case, it is possible to develop algo-
rithms which have an average complexity that is
less prohibitive. Since the exponent of the com-
plexity function depends on the number of dis-
junctions in a formula, one obvious way to im-
prove the unification algorithm is to reduce the
number of disjunctions in the formula before ex-
pansion to DNF. Fortunately the unification of
two descriptions frequently results in a reduction
of the number of alternatives that remain consis-
tent. Although the fully expanded formula may
be required as a final result, it is expedient to de-
lay the expansion whenever possible, until after
any desired unifications are performed.
The algebraic laws given in Figure 4 provide
a sound basis for simplifying formulas contain-
ing disjunctive values without expanding to DNF.
Our calculus differs from the calculus of Ait-
Kaci by providing a uniform set of equivalences
for formulas, including those that contain dis-
junction. These equivalences make it possible to
20ne exception is Karttunen&apos;s implementation, which
was described in Section 2, but it handles only value
disjunctions, and does not handle non-local path values
embedded within disjunctions.
</bodyText>
<page confidence="0.992535">
262
</page>
<bodyText confidence="0.999604">
eliminate inconsistent terms before expanding to
DNF. Each term thus eliminated may reduce, by
as much as half, the size of the expanded formula.
</bodyText>
<subsectionHeader confidence="0.999096">
5.4 Representing Non-local Paths
</subsectionHeader>
<bodyText confidence="0.999514357142857">
The logic contains no direct representation for
non-local paths of the type described in Sec-
tion 2. The reason is that these cannot be in-
terpreted without reference to the global con-
text of the formula in which they occur. Recall
that in Functional Unification Grammar a non-
local path denotes the value found by extracting
each of the attributes labeled by the path in suc-
cessively embedded feature structures, beginning
with the entire structure currently under consid-
eration. Stated formally, the desired interpreta-
tion of 1 :&lt; p&gt; is
A 1 :&lt; p &gt; in the context of 0
38 =0 and 3w E L*.
</bodyText>
<subsectionHeader confidence="0.732707">
Blw = A and 6(0,I) = 5(q0,, p).
</subsectionHeader>
<bodyText confidence="0.970754607142857">
This interpretation does not allow a direct com-
parison of the non-local path value with other
values in the formula. It remains an unknown
quantity unless the environment is known.
Instead of representing non-local paths directly
in the logic, we propose that they can be used
within a formula as a shorthand, but that all
paths in the formula must be expanded before
any other processing of the formula. This path
expansion is carried out according to the equiva-
lences 9 and 6.
After path expansion all strings of labels in a
formula denote transitions from a common origin,
so the expressions containing non-local paths can
be converted to the equivalence class notation,
using the schema
Consider the the passive voice alternative of the de-
scription of Figure 2, shown here in Figure 5.
This description is also represented by the first
formula of Figure 6. The formulas to the right in
Figure 6 are formed by
1. applying path expansion,
2. converting the attributes containing non-
local path values to formulas representing
equivalence classes of paths.
By following this procedure, the entire functional
description of Figure 2 can be represented by the
logical formula given in Figure 7.
</bodyText>
<figureCaption confidence="0.992374">
Figure 5: Functional Description containing
non-local values.
</figureCaption>
<figure confidence="0.999357944444444">
voice : passive
A goal :&lt; subj &gt;
A adjunct : (cat : pp
A prep: by
A obj :&lt; actor &gt;
A obj : case : objective)
voice : passive
A goal :&lt; aubj &gt;
A adjunct : cat : pp
A adjunct : prep :by
A adjunct : obj :&lt; actor &gt;
A adjunct : obj : case: objective
voice :passive
A 1&lt; goal &gt;,&lt; subj &gt;1
A adjunct : cat : pp
A adjunct : prep: by
A I&lt; adjunct obj &gt;,&lt; actor &gt;1
A adjunct : obj : case : objective
</figure>
<figureCaption confidence="0.9987125">
Figure 6: Conversion of non-local values to equiv-
alence classes of paths.
</figureCaption>
<figure confidence="0.959299636363636">
voice = passive
goal =&lt; subj &gt;
[cat = pp
prep = by
obj =&lt; actor &gt;
= [ case = objective 1
adjunct =
path
expansion
path
equivalence
</figure>
<page confidence="0.601101">
263
</page>
<figure confidence="0.9975771875">
cat : $
A subj: case : nominative
A
((voice : active
A l&lt; actor &gt;,&lt; subj &gt;I)
V
(voice : passive
A l&lt; goal &gt;,&lt; subj &gt;1
A adjunct: cat : pp
A adjunct: prep : by
A i&lt; adjunct obj &gt;,&lt; actor &gt;1
A adjunct : obj : case : objective))
A
(mood: declarative
V
mood : interrogative)
</figure>
<figureCaption confidence="0.897243">
Figure 7: Logical formula representing the de-
scription of Figure 2.
It is now possible to unify the description of
Figure 7 (call this X in the following discus-
sion) with another description, making use of the
equivalence classes to simplify the result. Con-
sider unifying X with the description
</figureCaption>
<bodyText confidence="0.942468">
Y = actor : case : nominative.
The commutative law (10) makes it possible to
unify Y with any of the conjuncts of X. If we
unify Y with the disjunction which contains the
voice attributes, we can use the distributive law
(16) to unify Y with both disjuncts. When Y is
unified with the term containing
i&lt; adjunct obj &gt;,&lt; actor &gt;1,
the equivalence (22) specifies that we can add the
term
adjunct: obj: case : nominative.
This term is incompatible with the term
adjunct : obj : case : objective,
and by applying the equivalences (6, 4, 1, and
2) we can transform the entire disjunct to TOP.
Equivalence (8) specifies that this disjunction can
be eliminated. Thus, we are able to use the
path equivalences during unification to reduce the
number of disjunctions in a formula without ex-
panding to DNF.
Note that path expansion does not require an
expansion to full DNF, since disjunctions are not
multiplied. While the DNF expansion of a for-
mula may be exponentially larger than the origi-
nal, the path expansion is at most quadratically
larger. The size of the formula with paths ex-
panded is at most n x p, where n is the length
of the original formula, and p is the length of the
longest path. Since p is generally much less than
n the size of the path expansion is usually not a
very large quadratic.
</bodyText>
<subsectionHeader confidence="0.937071">
5.5 Value Disjunction and
General Disjunction
</subsectionHeader>
<bodyText confidence="0.999981647058823">
The path expansion procedure illustrated in
Figure 6 can also be used to transform formulas
containing value disjucntion into formulas con-
taining general disjunction. For the reasons given
above, value disjunctions which contain non-local
path expressions must be converted into general
disjunctions for further simplification.
While it is possible to convert value disjunc-
tions into general disjunctions, it is not always
possible to convert general disjunctions into value
disjunctions. For example, the first disjunction
in the formula of Figure 7 cannot be converted
into a value disjunction. The left side of equiva-
lence (9) requires both disjuncts to begin with
a common label prefix. The terms of these
two disjuncts contain several different prefixes
(voice, actor, subj, goal, and adjunct), so they
cannot be combined into a common value.
Before the equivalences of section 4 were formu-
lated, the first author attempted to implement a
facility to represent disjunctive feature structures
with non-local paths using only value disjunction.
It seemed that the unification algorithm would be
simpler if it had to deal with disjuncti ns only
in the context of attribute values, rad- er than
in more general contexts. While it w possi-
ble to write down grammatical definitions using
only value disjunction, it was very difficult to
achieve a correct unification algorithm, because
each non-local path was much like an unknown
variable. The logical calculus presented here
clearly demonstrates that a representation of gen-
eral disjunction provides a more direct method to
determine the values for non-local paths.
</bodyText>
<page confidence="0.996637">
264
</page>
<sectionHeader confidence="0.99893" genericHeader="method">
6 Implementation
</sectionHeader>
<bodyText confidence="0.99999178125">
The calculus described here is currently being
implemented as a program which selectively ap-
plies the equivalences of Figure 4 to simplify for-
mulas. A strategy (or algorithm) for simplifying
formulas corresponds to choosing a particular or-
der in which to apply the equivalences whenever
more than one equivalence matches the form of
the formula. The program will make it possi-
ble to test and evaluate different strategies, with
the correctness of any such strategy following di-
rectly from the correctness of the calculus. While
this program is primarily of theoretical interest, it
might yield useful improvements to current meth-
ods for processing feature structures.
The original motivation for developing this
treatment of feature structures came from work
on an experimental parser based on Nigel [9], a
large systemic grammar of English. The parser is
being developed at the USC/Information Sciences
Institute by extending the PATR-II system of SRI
International. The systemic grammar has been
translated into the notation of Functional Uni-
fication Grammar, as described in [6]. Because
this grammar contains a large number (several
hundred) of disjunctions, it has been necessary to
extend the unification procedure so that it han-
dles disjunctive values containing non-local paths
without expansion to DNF. We now think that
this implementation of a relatively large grammar
can be made more tractable by applying some of
the transformations to feature descriptions which
have been suggested by the logical calculus.
</bodyText>
<sectionHeader confidence="0.998563" genericHeader="conclusions">
7 Conclusion
</sectionHeader>
<bodyText confidence="0.9946785">
We have given a precise logical interpreta-
tion for feature structures and their descriptions
which are used in unification-based grammar for-
malisms. This logic can be used to guide and im-
prove implementations of these grammars, and
the processors which use them. It has allowed
a closer examination of several sources of com-
plexity that are present in these grammars, par-
ticularly when they make use of disjunctive de-
scriptions. We have found a set logical equiva-
lences helpful in suggesting ways of coping with
this complexity.
It should be possible to augment this logic to
include characterisations of negation and implica-
tion, which we are now developing. It may also be
worthwhile to integrate the logic of feature struc-
tures with other grammatical formalisms based
on logic, such as DCG [10] and LFP [13].
</bodyText>
<reference confidence="0.998454">
Ait-Kaci, H. A New Model of Computa-
tion Based on a Calculus of Type Subsump-
tion. PhD thesis, University of Pennsylva-
nia, 1984.
[2] Gazdar, G., E. Klein, G.K. Pullum, and I.A.
Sag. Generalized Phrase Structure Gram-
mar. Blackwell Publishing, Oxford, Eng-
land, and Harvard University Press, Cam-
bridge, Massachusetts, 1985.
G.R. Kress, editor. Halliday: System and
Function in Language. Oxford University
Press, London, England, 1976.
[4] Kaplan, R. and J. Bresnan. Lexical Func-
tional Grammar: A Formal System for
Grammatical Representation. In J. Bresnan,
editor, The Mental Representation of Gram-
matical Relations. MIT Press, Cambridge,
Massachusetts, 1983.
Karttunen, L. Features and Values. In Pro-
ceedings of the Tenth International Confer-
ence on Computational Linguistics, Stanford
University, Stanford, California, July 2-7,
1984.
[6] Kasper, R. Systemic Grammar and Func-
tional Unification Grammar. In J. Ben-
son and W. Greaves, editors, Proceedings of
the leh International Systemics Workshop,
Norwood, New Jersey: Ablex (forthcoming).
[7] Kay, M. Functional Grammar. In Pro-
ceedings of the Fifth Annual Meeting of the
Berkeley Linguistics Society, Berkeley Lin-
guistics Society, Berkeley, California, Febru-
ary 17-19, 1979.
[5] Kay, M. Parsing in Functional Unification
Grammar. In D. Dowty, L. Kartunnen,
and A. Zwicky, editors, Natural Language
Parsing. Cambridge University Press, Cam-
bridge, England, 1985.
[9] Mann, W.C. and C. Matthiessen. Nigel:
A Systemic Grammar for Text Generation.
USC / Information Sciences Institute, RR-
83-105. Also appears in R. Benson and
J. Greaves, editors, Systemic Perspectives
on Discourse: Selected Papers Papers from
the Ninth International Systemics Work-
shop, Ablex, London, England, 1985.
</reference>
<figure confidence="0.99745275">
References
[1]
[3]
[5]
</figure>
<page confidence="0.987945">
265
</page>
<reference confidence="0.999874793103449">
[10] Pereira, F. C. N. and D. H. D. Warren. Defi-
nite clause grammars for language analysis —
a survey of the formalism and a comparison
with augmented transition networks. Artifi-
cial Intelligence, 13:231-278, 1980.
[11] Pereira, F. C. N. and S. M. Shieber. The se-
mantics of grammar formalisms seen as com-
puter languages. In Proceedings of the Tenth
International Conference on Computational
Linguistics, Stanford University, Stanford,
California, July 2-7, 1984.
[12] Rounds, W. C. and R. Kasper. A Complete
Logical Calculus for Record Strucutres Rep-
resenting Linguistic Information. Submitted
to the Symposium on Logic in Computer Sci-
ence, to be held June 16-18, 1986.
[13] Rounds, W. C. LFP: A Logic for Linguis-
tic Descriptions and an Analysis of its Com-
plexity. Submitted to Computational Lin-
guistics.
[14] Shieber, S. M. The design of a computer lan-
guage for linguistic information. In Proceed-
ings of the Tenth International Conference
on Computational Linguistics, Stanford Uni-
versity, Stanford, California, July 2-7, 1984.
[15] Shieber, S. M. An Introduction to
Unification-based Approaches to Grammar.
Chicago: University of Chicago Press, CSLI
Lecture Notes Series (forthcoming).
</reference>
<page confidence="0.998479">
266
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.642153">
<title confidence="0.999907">A LOGICAL SEMANTICS FOR FEATURE STRUCTURES</title>
<author confidence="0.999995">Robert T Kasper</author>
<author confidence="0.999995">William C Rounds</author>
<affiliation confidence="0.999805">Electrical Engineering and Computer Science Department University of Michigan</affiliation>
<address confidence="0.998478">Ann Arbor, Michigan 48109</address>
<abstract confidence="0.995113532894736">Unification-based grammar formalisms use structures containing sets of features to describe linguistic objects. Although computational algorithms for unification of feature structures have been worked out in experimental research, these algorithms become quite complicated, and a more precise description of feature structures is desirable. We have developed a model in which descriptions of feature structures can be regarded as logical formulas, and interpreted by sets of directed graphs which satisfy them. These graphs are, in fact, transition graphs for a special type of deterministic finite automaton. This semantics for feature structures extends the ideas of Pereira and Shieber [111, by providing an interpretation for values which are specified disjunctions and path embedded within Our interpretation differs that of Pereira and Shieber by using a logical model in place of a denotational semantics. This logical model yields a calculus of equivalences, which can be used to simplify formulas. Unification is attractive, because of its generality, but it is often computationally inefficient. Our model allows a careful examination of the computational complexity of unification. We have shown that the consistency problem for formulas with disjunctive values is NP-complete. To deal with this complexity, we describe how disjunctive values can be specified in a way which delays expansion to disjunctive normal form. 1 Background: Unification in Grammar Several different approaches to natural language grammar have developed the notion of feature structures to describe linguistic objects. These approaches include linguistic theories, such as Generalized Phrase Structure Grammar (GPSG) [2], Lexical Functional Grammar (LFG) [4], and Systemic Grammar [3]. They also include grammar formalisms which have been developed as computational tools, such as Functional Unification Grammar (FUG) [7], and PATR-II [14]. In these formalisms, the primary operation for matching and combining feature structures. Feature structures are called by several differnames, including LFG, and descriptions FUG. Although they differ in details, each approach uses structures containing sets of attributes. Each attribute is composed of a label/value pair. A value may be an atomic symbol, but it may also be a nested feature structure. The intuitive interpretation of feature structures may be clear to linguists who use them, even in the absence of a precise definition. Often, a precise definition of a useful notation becomes possible only after it has been applied to the description of a variety of phenomena. Then, greater precision may become necessary for clarification when the notation is used by many different investigators. Our model has been developed in the context of providing a precise interpretation for the feature structures which are used in FUG and PATR-II. Some elements of this logical interpretation have been partially described in Kay&apos;s work [8]. Our contribution is to give a more complete algebraic account of the logical properties of feature structures, which can be used explicitly for computational manipulation and mathematical analysis. Proofs of the mathematical soundness and completeness of this logical treatment, along with its relation to similar logics, can be found in [12]. 2 Disjunction and Non-Local Values Karttunen [5] has shown that disjunction and negation are desirable extensions to PATR-II which are motivated by a wide range of linguistic 257 die = case : {nom ace} local path values in Section 5.4. gender : fern 3 Logical Formulas for Feature Structures agreement : number : sing 1 number : pl 1 Figure 1: A Feature Structure containing Value Disjunction. phenomena. He discusses specifying attributes by values, as shown in Figure 1. A alternative values of a single attribute. These alternative values may be either atomic or complex. Disjunction of a more genkind is an essential element of FUG. used to specify alternative groups of multiple attributes, as shown in Figure 2. Karttunen describes a method by which the basic unification procedure can be extended to handle negative and disjunctive values, and explains some of the complications that result from introducing value disjunction. When two values, A and B, are to be unified, and A is a disjunction, we cannot actually unify B with both alternatives of A, because one of the alternatives may become incompatible with B through later unifications. Instead we need to remember .a constraint that at least one of the alternatives of A must remain compatible with B. An additional complication arises when one of the alternatives of a disjunction contains a value which is specified by a non-local path, a situation which occurs frequently in Functional Unifi- Grammar. In Figure 2 the in the description of the adjunct attribute is given value &lt; &gt;, means that the attribute is to be unified with the value found the end of the path labeled by &lt; &gt; in the outermost enclosing structure. This unification with a non-local value can be performed only when the alternative which contains it is the only alternative remaining in the disjunction. Oththe = objective might be to the value of &lt; &gt; the alternative containing not used. Thus, the constraints on alternatives of a disjunction must also apply to any non-local values contained within those alternatives. These complications, and the resulting proliferation of constraints, provide a practical motivation for the logical treatment given in this paper. We suggest solution to the problem of representing non- The feature structure of Figure 1 can also be represented by a type of logical formula: = : (nom ( fern sing) : This type of formula differs from standard propositional logic in that a theoretically unlimited set of atomic values is used in place of boolean values. The labels of attributes bear a superficial resemblance to modal operators. Note that no information is added or subtracted by rewriting the feature matrix of Figure 1 as a logical formula. These two forms may be regarded as notational variants for expressing the same facts. While feature matrices seem to be a more appealing and natural notation for displaying linguistic descriptions, logical formulas provide a precise interpretation which can be useful for computational and mathematical purposes.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>H Ait-Kaci</author>
</authors>
<title>A New Model of Computation Based on a Calculus of Type Subsumption.</title>
<date>1984</date>
<tech>PhD thesis,</tech>
<institution>University of Pennsylvania,</institution>
<marker>Ait-Kaci, 1984</marker>
<rawString>Ait-Kaci, H. A New Model of Computation Based on a Calculus of Type Subsumption. PhD thesis, University of Pennsylvania, 1984.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Gazdar</author>
<author>E Klein</author>
<author>G K Pullum</author>
<author>I A Sag</author>
</authors>
<title>Generalized Phrase Structure Grammar.</title>
<date>1985</date>
<publisher>Blackwell Publishing,</publisher>
<location>Oxford, England, and</location>
<marker>Gazdar, Klein, Pullum, Sag, 1985</marker>
<rawString>[2] Gazdar, G., E. Klein, G.K. Pullum, and I.A. Sag. Generalized Phrase Structure Grammar. Blackwell Publishing, Oxford, England, and Harvard University Press, Cambridge, Massachusetts, 1985.</rawString>
</citation>
<citation valid="true">
<date>1976</date>
<booktitle>System and Function in Language.</booktitle>
<editor>G.R. Kress, editor. Halliday:</editor>
<publisher>Oxford University Press,</publisher>
<location>London, England,</location>
<marker>1976</marker>
<rawString>G.R. Kress, editor. Halliday: System and Function in Language. Oxford University Press, London, England, 1976.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Kaplan</author>
<author>J Bresnan</author>
</authors>
<title>Lexical Functional Grammar: A Formal System for Grammatical Representation. In</title>
<date>1983</date>
<booktitle>The Mental Representation of Grammatical Relations.</booktitle>
<editor>J. Bresnan, editor,</editor>
<publisher>MIT Press,</publisher>
<location>Cambridge, Massachusetts,</location>
<marker>Kaplan, Bresnan, 1983</marker>
<rawString>[4] Kaplan, R. and J. Bresnan. Lexical Functional Grammar: A Formal System for Grammatical Representation. In J. Bresnan, editor, The Mental Representation of Grammatical Relations. MIT Press, Cambridge, Massachusetts, 1983.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Karttunen</author>
</authors>
<title>Features and Values.</title>
<date>1984</date>
<booktitle>In Proceedings of the Tenth International Conference on Computational Linguistics,</booktitle>
<location>Stanford University, Stanford, California,</location>
<marker>Karttunen, 1984</marker>
<rawString>Karttunen, L. Features and Values. In Proceedings of the Tenth International Conference on Computational Linguistics, Stanford University, Stanford, California, July 2-7, 1984.</rawString>
</citation>
<citation valid="false">
<authors>
<author>R Kasper</author>
</authors>
<title>Systemic Grammar and Functional Unification Grammar.</title>
<booktitle>Proceedings of the leh International Systemics Workshop,</booktitle>
<editor>In J. Benson and W. Greaves, editors,</editor>
<location>Norwood, New Jersey: Ablex (forthcoming).</location>
<marker>Kasper, </marker>
<rawString>[6] Kasper, R. Systemic Grammar and Functional Unification Grammar. In J. Benson and W. Greaves, editors, Proceedings of the leh International Systemics Workshop, Norwood, New Jersey: Ablex (forthcoming).</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Kay</author>
</authors>
<title>Functional Grammar.</title>
<date>1979</date>
<booktitle>In Proceedings of the Fifth Annual Meeting of the</booktitle>
<institution>Berkeley Linguistics Society, Berkeley Linguistics Society,</institution>
<location>Berkeley, California,</location>
<marker>Kay, 1979</marker>
<rawString>[7] Kay, M. Functional Grammar. In Proceedings of the Fifth Annual Meeting of the Berkeley Linguistics Society, Berkeley Linguistics Society, Berkeley, California, February 17-19, 1979.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Kay</author>
</authors>
<title>Parsing in Functional Unification Grammar. In</title>
<date>1985</date>
<editor>D. Dowty, L. Kartunnen, and A. Zwicky, editors,</editor>
<publisher>Cambridge University Press,</publisher>
<location>Cambridge, England,</location>
<marker>Kay, 1985</marker>
<rawString>[5] Kay, M. Parsing in Functional Unification Grammar. In D. Dowty, L. Kartunnen, and A. Zwicky, editors, Natural Language Parsing. Cambridge University Press, Cambridge, England, 1985.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W C Mann</author>
<author>C Matthiessen</author>
</authors>
<title>Nigel: A Systemic Grammar for Text Generation.</title>
<date>1985</date>
<booktitle>USC / Information Sciences Institute,</booktitle>
<pages>83--105</pages>
<editor>R. Benson and J. Greaves, editors,</editor>
<location>Ablex, London, England,</location>
<note>Also appears in</note>
<marker>Mann, Matthiessen, 1985</marker>
<rawString>[9] Mann, W.C. and C. Matthiessen. Nigel: A Systemic Grammar for Text Generation. USC / Information Sciences Institute, RR83-105. Also appears in R. Benson and J. Greaves, editors, Systemic Perspectives on Discourse: Selected Papers Papers from the Ninth International Systemics Workshop, Ablex, London, England, 1985.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F C N Pereira</author>
<author>D H D Warren</author>
</authors>
<title>Definite clause grammars for language analysis — a survey of the formalism and a comparison with augmented transition networks.</title>
<date>1980</date>
<journal>Artificial Intelligence,</journal>
<pages>13--231</pages>
<marker>Pereira, Warren, 1980</marker>
<rawString>[10] Pereira, F. C. N. and D. H. D. Warren. Definite clause grammars for language analysis — a survey of the formalism and a comparison with augmented transition networks. Artificial Intelligence, 13:231-278, 1980.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F C N Pereira</author>
<author>S M Shieber</author>
</authors>
<title>The semantics of grammar formalisms seen as computer languages.</title>
<date>1984</date>
<booktitle>In Proceedings of the Tenth International Conference on Computational Linguistics,</booktitle>
<location>Stanford University, Stanford, California,</location>
<marker>Pereira, Shieber, 1984</marker>
<rawString>[11] Pereira, F. C. N. and S. M. Shieber. The semantics of grammar formalisms seen as computer languages. In Proceedings of the Tenth International Conference on Computational Linguistics, Stanford University, Stanford, California, July 2-7, 1984.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W C Rounds</author>
<author>R Kasper</author>
</authors>
<title>A Complete Logical Calculus for Record Strucutres Representing Linguistic Information. Submitted to the</title>
<date>1986</date>
<booktitle>Symposium on Logic in Computer Science, to be held</booktitle>
<marker>Rounds, Kasper, 1986</marker>
<rawString>[12] Rounds, W. C. and R. Kasper. A Complete Logical Calculus for Record Strucutres Representing Linguistic Information. Submitted to the Symposium on Logic in Computer Science, to be held June 16-18, 1986.</rawString>
</citation>
<citation valid="false">
<authors>
<author>W C Rounds</author>
</authors>
<title>LFP: A Logic for Linguistic Descriptions and an Analysis of its Complexity.</title>
<note>Submitted to Computational Linguistics.</note>
<marker>Rounds, </marker>
<rawString>[13] Rounds, W. C. LFP: A Logic for Linguistic Descriptions and an Analysis of its Complexity. Submitted to Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S M Shieber</author>
</authors>
<title>The design of a computer language for linguistic information.</title>
<date>1984</date>
<booktitle>In Proceedings of the Tenth International Conference on Computational Linguistics,</booktitle>
<location>Stanford University, Stanford, California,</location>
<marker>Shieber, 1984</marker>
<rawString>[14] Shieber, S. M. The design of a computer language for linguistic information. In Proceedings of the Tenth International Conference on Computational Linguistics, Stanford University, Stanford, California, July 2-7, 1984.</rawString>
</citation>
<citation valid="false">
<authors>
<author>S M Shieber</author>
</authors>
<title>An Introduction to Unification-based Approaches to Grammar.</title>
<booktitle>CSLI Lecture Notes Series (forthcoming).</booktitle>
<publisher>University of Chicago Press,</publisher>
<location>Chicago:</location>
<marker>Shieber, </marker>
<rawString>[15] Shieber, S. M. An Introduction to Unification-based Approaches to Grammar. Chicago: University of Chicago Press, CSLI Lecture Notes Series (forthcoming).</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>