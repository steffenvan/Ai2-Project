<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.9581">
Constraint-Based Categorial Grammar
</title>
<author confidence="0.645242">
Gosse Bouma and Gertjan van Noord
</author>
<affiliation confidence="0.557840666666667">
Alfa-informatica and
Behavorial and Cognitive Neurosciences,
Rijksuniversiteit Groningen
</affiliation>
<email confidence="0.593977">
{gosse,vannoord}Olet.rug.n1
</email>
<sectionHeader confidence="0.979173" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999187181818182">
We propose a generalization of Categorial Grammar in
which lexical categories are defined by means of recur-
sive constraints. In particular, the introduction of re-
lational constraints allows one to capture the effects of
(recursive) lexical rules in a computationally attractive
manner. We illustrate the linguistic merits of the new
approach by showing how it accounts for the syntax of
Dutch cross-serial dependencies and the position and
scope of adjuncts in such constructions. Delayed evalu-
ation is used to process grammars containing recursive
constraints.
</bodyText>
<sectionHeader confidence="0.998216" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.996707739130435">
Combinations of Categorial Grammar (cG) and unifica-
tion naturally lead to the introduction of polymorphic
categories. Thus, Karttunen (1989) categorizes NP &apos;S as
x/x, where x is a verbal category, Zeevat et al. (1987)
assign the category x/(NP \x) to NP &apos;s, and Emms (1993)
extends the Lambek-calculus with polymorphic cate-
gories to account for coordination, quantifier scope, and
extraction.
The role of polymorphism has been restricted, how-
ever, by the fact that in previous work categories were
defined as feature structures using the simple, non-
recursive, constraints familiar from feature description
languages such as PATR. Relational constraints can be
used to define a range of polymorphic categories that
are beyond the expressive capabilities of previous ap-
proaches.
In particular, the introduction of relational con-
straints captures the effects of (recursive) lexical rules
in a computationally attractive manner. The addition
of such rules makes it feasible to consider truly &apos;lexical-
ist&apos; grammars, in which a powerful lexical component
is accompanied by a highly restricted syntactic compo-
nent, consisting of application only.
</bodyText>
<sectionHeader confidence="0.995364" genericHeader="method">
2 Recursive Constraints
</sectionHeader>
<bodyText confidence="0.999562583333333">
In CG, many grammatical concepts can only be de-
fined recursively. Dowty (1982) defines grammatical
functions such as subject and object as being the ul-
timate and penultimate &apos;argument-in&apos; of a verbal cate-
gory. Hoeksema (1984) defines verbs as exocentric cat-
egories reducible to S. Lexical rules frequently refer to
such concepts. For instance, a categorial lexical rule
of passive applies to verbs selecting an object and must
remove the subject.
In standard unification-based formalisms, these con-
cepts and the rules referring to such concepts cannot be
expressed directly.
</bodyText>
<subsectionHeader confidence="0.944642">
2.1 Subject-verb agreement
</subsectionHeader>
<bodyText confidence="0.7983475">
Consider a categorial treatment of subject-verb agree-
ment with intransitive ( NP[NOM]\S ) and transitive
</bodyText>
<equation confidence="0.977588857142857">
( (NP[Nom] \s)/NP[Acc] ) verbs defined as follows:
(1) /ex(walks, X) :-
iv(X).
/ex(kisses, X) :-
tv(X).
val [ cat s
dir `V
</equation>
<bodyText confidence="0.64906">
arg [cat np
case nom
</bodyText>
<footnote confidence="0.777392875">
val [ cat s
dir &amp;quot;
rcat np
[. case nom
cat np
case acc
Subject-verb agreement can be incorporated easily if
one reduces agreement to a form of sub categorization.
</footnote>
<figure confidence="0.976742714285714">
val
tv(
dir
arg
iv(
arg
).
</figure>
<page confidence="0.994216">
147
</page>
<bodyText confidence="0.9999538">
If, however, one wishes to distinguish these two pieces of
information (to avoid a proliferation of sub categoriza-
tion types or for morphological reasons, for instance), it
is not obvious how this could be done without recursive
constraints. For intransitive verbs one needs the con-
straint that (arg agr) = Agr (where Agr is some agree-
ment value), for transitive verbs that (val arg agr) =
Agr, and for ditransitive verbs that (val val arg agr)
Agr. The generalization is captured using the recursive
constraint sv_agreement (2). In (2) and below, we use
definite clauses to define lexical entries and constraints.
Note that lexical entries relate words to feature struc-
tures that are defined indirectly as a combination of
simple constraints (evaluated by means of unification)
and recursive constraints.&apos;
</bodyText>
<equation confidence="0.996015727272727">
(2) /ex(walks, X) :-
iv(X),
sv_agreement(sg3, X).
/ex(kisses, X) :-
tv(X),
sv_agreement(sg3, X).
[camp s).
sv_agreemen/(Agr,
agr Agr
sv_agreement(Agr,Y\X) :-
sv_agreement(Agr, X).
</equation>
<bodyText confidence="0.998857769230769">
Relational constraints can also be used to capture
the effect of lexical rules. In a lexicalist theory such
as CG, in which syntactic rules are considered to be
universally valid scheme&apos;s of functor-argument combi-
nation, lexical rules are an essential tool for capturing
language-specific generalizations. As Carpenter (1991)
observes, some of the rules that have been proposed
must be able to operate recursively. Predicative forma-
tion in English, for instance, uses a lexical rule turning
a category reducible to VP into a category reducing to
a VP-modifier (vP \vP). As a vP-modifier is reducible
to VP, the rule can (and sometimes must) be applied
recursively.
</bodyText>
<subsectionHeader confidence="0.999903">
2.2 Adjuncts as arguments
</subsectionHeader>
<bodyText confidence="0.999951666666667">
Miller (1992) proposes a lexical rule for French nouns
which adds an (modifying) adjective to the list of argu-
ments that the noun subcategorizes for. Since a noun
</bodyText>
<equation confidence="0.97112125">
val X
&apos;We use X/Y and Y\X as shorthand for dir &apos;/&apos;
arg Y
[val X
</equation>
<bodyText confidence="0.9974536">
and dir &apos;\&apos; , respectively and S, NP, and Adj as &apos;typed
arg Y
variables&apos; of type [ cat s ], [ cat np ] , and [ cat adj ] ,
can be modified by any number of adjectives, the rule
must be optional as well as recursive. The advantages
of using a lexical rule in this case is that it simplifies
accounting for agreement between nouns and adjectives
and that it enables an account of word order constraints
between arguments and modifiers of a noun in terms of
obliqueness.
The idea that modifiers are introduced by means of
a lexical rule can be extended to verbs. That is, ad-
juncts could be introduced by means of a recursive rule
that optionally adds these elements to verbal categories.
Such a rule would be an alternative for the standard cat-
egorial analysis of adjuncts as (endocentric) functors.
There is reason to consider this alternative.
In Dutch, for instance, the position of verb modifiers
is not fixed. Adjuncts can in principle occur anywhere
to the left of the verb:2
</bodyText>
<listItem confidence="0.87314">
(3) a. dat Johan opzettelijk een ongeluk
that J. deliberately an accident
veroorzaakt
causes
that J. deliberately causes an accident
b. dat Johan Marie opzettelijk
that J. M. deliberately
geen cadeau geeft
</listItem>
<bodyText confidence="0.943583230769231">
no present gives
that J. deliberately gave M. no present
There are several ways to account for this fact. One
can assign multiple categories to adjuncts or one can
assign a polymorphic category x/x to adjuncts, with x
restricted to &apos;verbal projections&apos; (Bouma, 1988).
Alternatively, one can assume that adjuncts are not
functors, but arguments of the verb. Since adjuncts are
optional, can be iterated, and can occur in several posi-
tions, this implies that verbs must be polymorphic. The
constraint add_adjuncts has this effect, as it optionally
adds one or more adjuncts as arguments to the &apos;initial&apos;
category of a verb:
</bodyText>
<equation confidence="0.920968769230769">
(4) lex(veroorzaken, X):-
add_adjuncis(X, NP \(NP \S))
/ex(geven, X) :-
add_adjuncts(X, NP\(NP\(NP\S))).
add_adjuncts(S,S).
add_adjuncts(Adj\X,Y) :-
add_adjuncts(X,Y).
add_adjuncts([dir D ,
val X [
arg A val Y
dir D ) :-
arg A
add_adjuncts(X,Y).
</equation>
<bodyText confidence="0.8457385">
2 As we want to abstract away from the effects of &apos;verb-
respectively, second&apos;, we present only examples of subordinate clauses.
</bodyText>
<page confidence="0.936328">
148
</page>
<bodyText confidence="0.9998835">
This constraint captures the effect of applying the
following (schematic) lexical rule recursively:
</bodyText>
<listItem confidence="0.847106">
(5) X1\ \ Xi \Xi+i \ \S/Y1 Y,
\ \Xi \Adj \Xj+i \ \S/Yi • • • Yn
</listItem>
<bodyText confidence="0.996613666666667">
The derivation of (3a) is given below (where X
indicates that add_adjuncts(Y ,X) is satisfied, and iv =
NP\s).
</bodyText>
<equation confidence="0.70326775">
(6) ... J. opzettelijk een ongeluk
NP ADJ NP
ADJ \IV
IV
</equation>
<bodyText confidence="0.999936071428571">
An interesting implication of this analysis is that in
a categorial setting the notion &apos;head&apos; can be equated
with the notion &apos;main functor&apos;. This has been pro-
posed by Barry and Pickering (1990), but they are
forced to assign a category containing Kleene-star op-
erators to verbal elements. The semantic counterpart
of such category-assignments is unclear. The present
proposal is an alternative for such assignments which
avoids introducing new categorial operators and which
does not lead to semantic complications (the semantics
of add_adjuncts is presented in section 3.3). Below we
argue that this analysis also allows for a straightforward
explanation of the distribution and scope of adjuncts in
verb phrases headed by a verbal complex.
</bodyText>
<sectionHeader confidence="0.996559" genericHeader="method">
3 Cross-Serial Dependencies
</sectionHeader>
<bodyText confidence="0.844179833333333">
In Dutch, verbs selecting an infinitival complement (e.g.
modals and perception verbs) give rise to so called cross-
serial dependencies. The arguments of the verbs in-
volved appear in the same order as the verbs in the
&apos;verb cluster&apos;:
(7) a. dat Ani Bea2 will kussen2.
dat An Bea wants to kiss
that An wants to kiss Bea
b. dat Ani Bea2 Cor3 will
dat An Bea Cor wants
zien2 kussen3. see Bea kiss Cor
to see kiss
that An wants to
The property of forming cross-serial dependencies is
a lexical property of the matrix verb. If this verb is a
&apos;trigger&apos; for cross-serial word order, this order is obliga-
tory, whereas if it is not, the infinitival complement will
follow the verb:
</bodyText>
<listItem confidence="0.991089142857143">
(8) a. *dat An wil Bea kussen.
b. dat An zich voornam Bea
that An Refl. planned Bea
te kussen.
to kiss
that An. planned to kiss Bea
c. *dat An zich Bea voornam te kussen.
</listItem>
<subsectionHeader confidence="0.99627">
3.1 Generalized Division
</subsectionHeader>
<bodyText confidence="0.995765625">
Categorial accounts of cross-serial dependencies ini-
tially made use of a syntactic rule of composition
(Steedman, 1985). Recognizing the lexical nature of
the process, more recent proposals have used either a
lexical rule of composition (Moortgat, 1988) or a lexical
rule of &apos;division&apos; (Hoeksema, 1991). Division is a rule
which enables a functor to inherit the arguments of its
argument:3
</bodyText>
<equation confidence="0.764931">
XIY(X/Z1...IZn)I(YIZ IZn)
</equation>
<bodyText confidence="0.9302775">
To generate cross-serial dependencies, a &apos;clishar-
monic&apos; version of this rule is needed:
</bodyText>
<figure confidence="0.694858444444444">
(9) XIY Zn\X)I(Zi\...Zn\Y)
Hoeksema proposes that verbs which trigger cross-
serial word order are subject to (9):
(10) ...An Bea wi/
NP NP Iv/iv
J.
(NpVv)/(Np\rv)
Np \INT
IV
</figure>
<bodyText confidence="0.99550225">
In a framework using recursive constraints, gener-
alized disharmonic division can be implemented as a
recursive constraint connecting the initial category of
such verbs with a derived category:
</bodyText>
<listItem confidence="0.3463824">
(11) lex(willen, X) :-
cross_serial(X,(NP \S)/(NP \S)).
/ex(zien, X) :-
cross_serial(X,(NP \(NP \S))/(NP \S)).
/ex(voornemen, (NPrefl \ (NP \ S))/(NP \S)).
</listItem>
<footnote confidence="0.68154175">
3Argument inheritance is used in HPSG to account for
verb clustering in German (Hinrichs and Nakazawa, 1989).
The HPSG analysis is essentially equivalent to Hoeksema&apos;s
account.
</footnote>
<figure confidence="0.9307692">
veroorzaaki
NP \IV
\ (AD.] \iv)
kussen
NP\iv
</figure>
<page confidence="0.942993">
149
</page>
<equation confidence="0.988377428571429">
(12) cross_serial(Out, In) :-
division(Out , In),
verb_cluster(Out).
division(X , X).
division((Z\X)/(Z\Y), X&apos; /Y&apos;) :-
division(X /Y, X&apos; /Y&apos;).
verb_cluster([ arg [ vc ]).
</equation>
<bodyText confidence="0.988773">
Only verbs that trigger the cross-serial order are sub-
ject to the division constraint. This accounts immedi-
ately for the fact that cross-serial orders do not arise
with all verbs selecting infinitival complements.
</bodyText>
<subsectionHeader confidence="0.997162">
3.2 Verb Clusters
</subsectionHeader>
<bodyText confidence="0.99998535">
The verb_cluster constraint ensures that cross-serial
word order is obligatory for verbs subject to
cross_serial. To rule out the ungrammatical (8a), for
instance, we assume that Bea kussen is not a verb clus-
ter. The verb kussen by itself, however, is unspecified
for vc, and thus (7a) is not excluded.
We do not assume that cross-serial verbs take lexical
arguments (as has sometimes been suggested), as that
would rule out the possibility of complex constituents to
the right of cross-serial verbs altogether. If one assumes
that a possible bracketing of the verb cluster in (7b) is
[wi/ [zien kussen]] (coordination and fronting data have
been used as arguments that this is indeed the case),
a cross-serial verb must be able to combine with non-
lexical verb clusters. Furthermore, if a verb selects a
particle, the particle can optionally be included in the
verb cluster, and thus can appear either to the right or
to the left of a governing cross-serial verb. For a verb
cluster containing two cross-serial verbs, for instance,
we have the following possibilities:
</bodyText>
<listItem confidence="0.955086857142857">
(13) a. dat An Bea heeft durven aan
that An Bea has dared part.
te spreken
to speak
that An has dared to speak to Bea.
b. dat An Bea heeft aan durven te spreken.
c. dat An Bea aan heeft durven te spreken.
</listItem>
<bodyText confidence="0.5661002">
A final piece of evidence for the the fact that cross-
serial verbs may take complex phrases as argument
stems from the observation that certain adjectival and
prepositional arguments can also appear as part of the
verb cluster:
</bodyText>
<listItem confidence="0.8363626">
(14) dat An dit aan Bea had duidelijk
that An this to Bea has clear
gemaakt
made
that An had made this clear to Bea
</listItem>
<bodyText confidence="0.998765833333333">
Cross-serial verbs select a H-vc argument. Therefore,
all phrases that are not verb clusters must be marked -
vc. In general, in combining a (verbal) functor with its
argument, it is the argument that determines whether
the resulting phrase is -vc. For instance, NP-arguments
always give rise to -vc phrases, whereas particles and
verbal arguments do not give rise to -vc phrases. This
suggests that NP&apos;s must be marked -vc, that particles
and verbs can remain unspecified for this feature, and
that in the syntactic rule for application the value of
the feature vc must be reentrant between argument
and resultant.
</bodyText>
<subsectionHeader confidence="0.985341">
3.3 The distribution and scope of
adjuncts
</subsectionHeader>
<bodyText confidence="0.991102810810811">
The analysis of cross-serial dependencies in terms of
argument inheritance interacts with the analysis of ad-
juncts presented in section 2.2. If a matrix verb inherits
the arguments of the verb it governs, it should be pos-
sible to find modifiers of the matrix verb between this
verb and one of its inherited arguments. This prediction
is borne out (15a). However, we also find structurally
similar examples in which the adjunct modifies the gov-
erned verb (15b). Finally, there are examples that are
ambiguous between a wide and narrow scope reading
(15c). We take it that the latter case is actually what
needs to be accounted for, i.e. examples such as (15a)
and (15b) are cases in which there is a strong prefer-
ence for a wide and narrow scope reading, respectively,
but we will remain silent about the (semantic) factors
determining such preferences.
(15) a. dat Frits Marie volgens mij lijkt
that F. M. to me seems
te ontwijken.
to avoid
It seems to me that F. avoids M.
b. dat Frits Marie opzettelijk lijkt
that F. M. deliberately seems
te ontwijken.
to avoid
It seems that F. deliberately avoids M.
c. dat Frits Marie de laatste tijd lijkt
that F. M. lately seems
te ontwijken.
to avoid
It seems lately as if F. avoids M.
It seems as if F. avoids M. lately
On the assumption that the lexical entries for lijken
en ontwijken are as in (16), example (15c) has two possi-
ble derivations ((17) and (18)). Procedurally speaking,
the rule that adds adjuncts can be applied either to the
matrix verb (after division has taken place) or to the
</bodyText>
<page confidence="0.99537">
150
</page>
<bodyText confidence="0.999748">
governed verb. In the latter case, the adjunct is &apos;inher-
ited&apos; by the matrix verb. Assuming that adjuncts take
scope over the verbs introducing them, this accounts
for the ambiguity observed above.
</bodyText>
<equation confidence="0.606288375">
(16) /ex(lijken, Verb):-
add_adjuncts(Verb, Verb`),
cross_serial(Verb&apos; , (NP\S)/(NP\S)).
lex(ontwijken, Verb):-
add_adjuncts(Verb,NPVNP\S)).
(17) ... de laatste tijd lijki te ontwijken
ADJ IV/IV TV
Tv/Tv
(ADJ\TV) /TV
ADJ\TV
TV
(18) . de Maisie tijd lijkt
ADJ IV/IV
(ADJ \TV)/(ADJ \TV)
ADJ\TV
TV
</equation>
<bodyText confidence="0.9997774">
The assumption that adjuncts scope over the verbs
introducing them can be implemented as follows. We
use a unification-based semantics in the spirit of Pereira
and Shieber (1987). Furthermore, the semantics is
head-driven, i.e. the semantics of a complex constituent
is reetrant with the semantics of its head (i.e. the func-
tor). The feature structure for a transitive verb in-
cluding semantics (taking two NP&apos;s of the generalized
quantifier type ((c, t) , t) as argument and assigning wide
scope to the subject) is:
</bodyText>
<equation confidence="0.5396836">
dir `V
[cat np
arg
sem (YAkiss(X,Y))^Sobi
sem SSubj
</equation>
<bodyText confidence="0.999784">
Thus, a lexical entry for a transitive verb can be de-
fined as follows (where TV refers to the feature struc-
ture in 19):
</bodyText>
<equation confidence="0.5070445">
(20) /ex(kussen, X) :-
add_adjuncts(X, TV).
</equation>
<bodyText confidence="0.862962">
The lexical rule for adding adjuncts can now be ex-
tended with a semantics:
</bodyText>
<equation confidence="0.907843428571429">
(21) add_adjuncts([ sem Sx x &apos;[ sem Sy ]y)
add_adj(X,Y ,Sx , Sy).
add_adj(S, S, Sem, Sem).
[val X i [val Y
add_adj( dir D , dir D ,Sx,Sy) :-
arg A arg A
add_adj(X,Y ,Sx , Sy).
</equation>
<bodyText confidence="0.999861034482759">
Each time an adjunct is added to the subcategoriza-
tion frame of a verb, the semantics of the adjunct is
&apos;applied&apos; to the semantics as it has been built up so far
(Sy), and the result (SA) is passed on. The final step in
the recursion unifies the semantics that is constructed
in this way with the semantics of the &apos;output&apos; category.
As an adjunct A1 that appears to the left of an adjunct
A2 in the string will be added to the subcategoriza-
tion frame of the governing verb after A2 is added, this
orders the (sentential) scope of adjuncts according to
left-to-right word order. Furthermore, since the scope
of adjuncts is now part of a verb&apos;s lexical semantics,
any functor taking such a verb as argument (e.g. verbs
selecting for an infinitival complement) will have the
semantics of these adjuncts in its scope.
Note that the alternative treatments of adjuncts men-
tioned in section 2.2 cannot account for the distribution
or scope of adjuncts in cross-serial dependency con-
structions. Multiple (i.e. a finite number of) catego-
rizations cannot account for all possible word orders,
since division implies that a trigger for cross-serial word
order may have any number of arguments, and thus,
that the number of csubcategorization frames&apos; for such
verbs is not fixed. The polymorphic solution (assigning
adjuncts the category x/x) does account for word or-
der, but cannot account for narrow scope readings, as
the adjunct will always modify the whole verb cluster
(i.e the matrix verb) and cannot be made to modify an
embedded verb only.
</bodyText>
<sectionHeader confidence="0.971229" genericHeader="method">
4 Processing
</sectionHeader>
<bodyText confidence="0.999800333333333">
The introduction of recursive lexical rules has repercus-
sions for processing as they lead to an infinite number
of lexical categories for a given lexical item or, if one
</bodyText>
<figure confidence="0.992804611111111">
te ontwijken
TV
ADJ\TV
(19)
val
val [ cat s
dir `V
arg [
cat np
sem (X^Sobi)&amp;quot; Ssubi
TV
[add_adj(
add_adj(X,Y ,Sx,SA).
val X
dir `V
,Y,Sx,Sy)
arg [cat adj
sem Sy A SA
</figure>
<page confidence="0.994001">
151
</page>
<bodyText confidence="0.99979992">
considers lexical rules as unary syntactic rules, to non-
branching derivations of unbounded length. In both
cases, a parser may not terminate. One of the main
advantages of modeling lexical rules by means of con-
straints is that it suggests a solution for this problem.
A control strategy which delays the evaluation of con-
straints until certain crucial bits of information are filled
in avoids non-termination and in practice leads to gram-
mars in which all constraints are fully evaluated at the
end of the parse-process.
Consider a grammar in which the only recursive con-
straint is add_adjuncts, as defined in section 2.2. The
introduction of recursive constraints in itself does not
solve the non-termination problem. If all solutions
for add_adjuncts are simply enumerated during lexical
look-up an infinite number of categories for any given
verb will result.
During processing, however, it is not necessarily the
case that we need to consider all solutions. Syntactic
processing can lead to a (partial) instantiation of the
arguments of a constraint. If the right pieces of infor-
mation are instantiated, the constraint will only have a
finite number of solutions.
Consider, for instance, a parse for the following
string.
</bodyText>
<table confidence="0.8205734">
(22) .. . J. opzettelijk een ongeluk veroorzaaki
NP ADJ NP Verb
NP \(ADJ\w)
ADJ \IV
NP
</table>
<bodyText confidence="0.966287888888889">
Even if the category of the verb is left completely
open initially, there is only one derivation for this string
that reduces to S (remember that the syntax uses appli-
cation only). This derivation provides the information
that the variable Verb must be a transitive verb select-
ing one additional adjunct, and with this information
it is easy to check whether the following constraint is
satisfied:
add_adjuncis(NP VADA(NP s )) NP \(NP \ s ))
This suggests that recursive constraints should not be
evaluated during lexical look-up, but that their evalu-
ation should be delayed until the arguments are suffi-
ciently instantiated.
To implement this delayed evaluation strategy, we
used the block facility of Sicstus Prolog. For each re-
cursive constraint, a block declaration defines what the
conditions are under which it may be evaluated. The
definition of add_adjuncts (with semantics omitted for
</bodyText>
<table confidence="0.394564454545455">
readability), for instance, now becomes:
(23) add_adjuncts([ arg Arg lx ,Y) :-
add_adjuncts(X, Y, Arg).
: - block add_adjuncts(?,?,—).
add_adjuncts(S, S, _).
add_adjuncts(Adj\X,Y , _) :-
add_adjuncts(X,Y). val Y
val X
add_adjuncts([ dir D , [ dir D ,A) :-
arg A arg A
add_adjuncts(X, Y).
</table>
<bodyText confidence="0.999918095238095">
We use add_adjuncts/2 to extract the information
that determines when add_adjuncts/3 is to be evalu-
ated. The block declaration states that add_adjuncts/3
may only be evaluated if the third argument (i.e. the
argument of the &apos;output&apos; category) is not a variable.
During lexical look-up, this argument is uninstantiated,
and thus, no evaluation takes place. As soon as a verb
combines with an argument, the argument category of
the verb is instantiated and add_adjuncts/3 will be eval-
uated. Note, however, that calls to add_adjuncts/3 are
recursive, and thus one evaluation step may lead to an-
other call to add_adjuncts/3, which in its turn will be
blocked until the argument has been instantiated suffi-
ciently. Thus, the recursive constraint is evaluated in-
crementally, with each syntactic application step lead-
ing to a new evaluation step of the blocked constraint.
The recursion will stop if an atomic category s is found.
Delayed evaluation leads to a processing model in
which the evaluation of lexical constraints and the con-
struction of derivational structure is completely inter-
twined.
</bodyText>
<subsectionHeader confidence="0.986176">
4.1 Other strategies
</subsectionHeader>
<bodyText confidence="0.9998663125">
The delayed evaluation techniques discussed above can
be easily implemented in parsers which rely on back-
tracking for their search. For the grammars that we
have worked with, a simple bottom-up (shift-reduce)
parser combined with delayed evaluation guarantees
termination of the parsing process.
To obtain an efficient parser more complicated search
strategies are required. However, chart-based search
techniques are not easily generalized for grammars
which make use of complex constraints. Even if the the-
oretical problems can be solved (Johnson, 1993; Dorre,
1993) severe practical problems might surface, if the
constraints are as complex as the ones proposed here.
As an alternative we have implemented chart-based
parsers using the &apos;non-interleaved pruning&apos; strategy
(terminology from (Maxwell III and Kaplan, 1994)).
</bodyText>
<page confidence="0.99459">
152
</page>
<bodyText confidence="0.990288070175439">
Using this strategy the parser first builds a parse-forest
for a sentence on the basis of the context-free backbone
of the grammar. In a second processing phase parses
are recovered on the basis of the parse forest and the
corresponding constraints are applied. This may be ad-
vantageous if the context-free backbone of the grammar
is &apos;informative&apos; enough to filter many unsuccessful par-
tial derivations that the parser otherwise would have to
check.
As clearly a CUG grammar does not contain such an
informative context-free backbone a further step is to
use &apos;selective feature movement&apos; (cf. again (Maxwell III
and Kaplan, 1994)). In this approach the base gram-
mar is compiled into an equivalent modified grammar
in which certain constraints from the base grammar are
converted to a more complex context-free backbone in
the modified grammar.
Again, this technique does not easily give good results
for grammars of the type described. It is not clear at all
where we should begin extracting appropriate features
for such a modified grammar, because most information
passing is simply too &apos;indirect&apos; to be easily compiled
into a context-free backbone.
We achieved the best results by using a &apos;hand-
fabricated&apos; context-free grammar as the first phase of
parsing. This context-free grammar builds a parse for-
est that is then used by the &apos;real&apos; grammar to obtain ap-
propriate representation(s) for the input sentence. This
turned out to reduce parsing times considerably.
Clearly such a strategy raises questions on the rela-
tion between this context-free grammar and the CUG
grammar. The context-free grammar is required to pro-
duce a superset of the derivations allowed by the CUG.
Given the problems mentioned above it is difficult to
show that this is indeed the case (if it were easy, then it
probably would also be easy to obtain such a context-
free grammar automatically).
The strategy can be described in somewhat more de-
tail as follows. The context-free phase of processing
builds a number of items defining the parse forest, in a
format that can be used by the second processing phase.
Such items are four-tuples
(R, Po, P, D)
where R is a rule name (consistent with the rule names
from the CUG), P0, P are string positions and D de-
scribes the string positions associated with each daugh-
ter of the rule (indicating which part of the string is
covered by that daughter).
Through a head-driven recursive descent the second
processing phase recovers derivations on the basis of
these items. Note that the delayed evaluation tech-
nique for complex constraints is essential here. Alter-
native solutions are obtained by backtracking. If the
first phase has done a good job in pruning many failing
search branches then this is not too expensive, and we
do not have to worry about the interaction of caching
and complex constraints.
</bodyText>
<sectionHeader confidence="0.998435" genericHeader="conclusions">
5 Final Remarks
</sectionHeader>
<bodyText confidence="0.999987777777778">
In sections 2 and 3 we have sketched an analysis of
cross-serial dependency constructions and its interac-
tion with the position and scope of adjuncts. The
rules given there are actually part of a larger frag-
ment that covers the syntax of Dutch verb clusters
in more detail. The fragment accounts for cross-
serial dependencies and extraposition constructions (in-
cluding cases of &apos;partial&apos; extraposition), infinitivus-pro-
participio, modal and participle inversion, the position
of particles in verb clusters, clitic climbing, partial VP-
topicalization, and verb second. In the larger fragment,
additional recursive constraints are introduced, but the
syntax is still restricted to application only.
The result of Carpenter (1991) emphasizes the impor-
tance of lexical rules. There is a tendency in both CG
and HPSG to rely more and more on mechanisms (such
as inheritance and lexical rules or recursive constraints)
that operate in the lexicon. The unrestricted generative
capacity of recursive lexical rules implies that the re-
maining role of syntax can be extremely simple. In the
examples above we have stressed this by giving an ac-
count for the syntax of cross-serial dependencies (a con-
struction that is, given some additional assumptions,
not context-free) using application only. In general,
such an approach seems promising, as it locates the
sources of complexity for a given grammar in one place,
namely the lexicon.
</bodyText>
<sectionHeader confidence="0.999275" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.991164666666667">
Guy Barry and Martin Pickering. 1990. Dependency
and coordination in categorial grammar. In G. Barry
and G. Morrill, editors, Studies in Categorial Gram-
mar. University of Edinburgh. Edinburgh Working
Papers in Cognitive Science 5.
Gosse Bouma. 1988. Modifiers and specifiers in cate-
gorial unification grammar. Linguistics, 26:21-46.
Bob Carpenter. 1991. The generative power of cat-
egorial grammars and head-driven phrase structure
grammars with lexical rules. Computational Linguis-
tics, 17(3):301-313.
Jochen Done. 1993. Generalizing earley deduction for
constraint-based grammars. In Jochen Doerre, edi-
tor, Computational Aspects of Constraint-Based Lin-
guistic Description. Dyana-2 Deliverable R1.2.A.
</reference>
<page confidence="0.989746">
153
</page>
<reference confidence="0.998808159090909">
David R. Dowty. 1982. Grammatical relations and
montague grammar. In Pauline Jacobson and Ge-
offrey Pullum, editors, The Nature of Syntactic Rep-
resentation, pages 79-130. Reidel, Dordrecht.
Martin Emms. 1993. Parsing with polymorphism. In
Sixth Conference of the European Chapter of the As-
sociation for Computational Linguistics, pages 120-
129.
Erhard Hinrichs and Tsuneko Nakazawa. 1989. Flipped
out: AUX in German. In Papers from the 25th
Annual Regional Meeting of the Chicago Linguistic
Society, pages 187-202. Chicago Linguistics Society,
Chicago.
Jack Hoeksema. 1984. Categorial Morphology. Ph.D.
thesis, Groningen University.
Jack Hoeksema. 1991. A categorial theory of reanalysis
phenomena. ms. RUG Groningen.
Mark Johnson. 1993. Memoization in constraint logic
programming. Paper presented at the First Work-
shop on Principles and Practice of Constraint Pro-
gramming, April 28-30, Newport, Rhode Island.
Lauri Karttunen. 1989. Radical lexicalism. In Mark R.
Baltin and Anthony S. Kroch, editors, Alternative
Conceptions of Phrase Structure, pages 43-65. Uni-
versity of Chicago Press.
John T. Maxwell III and Ronald M. Kaplan. 1994. The
interface between phrasal and functional constraints.
Computational Linguistics, 19(4):571-90.
Philip Miller. 1992. Clitics and Constituents in Phrase
Structure Grammar. Garland, New York.
Michael Moortgat. 1988. Categorial Investigations.
Ph.D. thesis, University of Amsterdam.
Fernando C.N. Pereira and Stuart M. Shieber. 1987.
Prolog and Natural Language Analysis. Center for
the Study of Language and Information Stanford.
Mark Steedman. 1985. Dependency and coordination
in the grammar of Dutch and English. Language,
61:523-68.
Henk Zeevat, Ewan Klein, and Jo Calder. 1987. Uni-
fication categorial grammar. In Nicholas Haddock,
Ewan Klein, and Glyn Morrill, editors, Categorial
Grammar, Unification Grammar and Parsing. Cen-
tre for Cognitive Science, University of Edinburgh.
Volume 1 of Working Papers in Cognitive Science.
</reference>
<page confidence="0.999765">
154
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.085489">
<title confidence="0.4810605">Constraint-Based Categorial Grammar Gosse Bouma and Gertjan van Noord Alfa-informatica and Behavorial and Cognitive Neurosciences,</title>
<author confidence="0.375743">Rijksuniversiteit Groningen</author>
<email confidence="0.358773">gosseOlet.rug.n1</email>
<email confidence="0.358773">vannoordOlet.rug.n1</email>
<abstract confidence="0.965548333333333">We propose a generalization of Categorial Grammar in which lexical categories are defined by means of recur-</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Guy Barry</author>
<author>Martin Pickering</author>
</authors>
<title>Dependency and coordination in categorial grammar.</title>
<date>1990</date>
<booktitle>Studies in Categorial Grammar. University of Edinburgh. Edinburgh Working Papers in Cognitive Science 5.</booktitle>
<editor>In G. Barry and G. Morrill, editors,</editor>
<contexts>
<context position="7594" citStr="Barry and Pickering (1990)" startWordPosition="1215" endWordPosition="1218"> from the effects of &apos;verbrespectively, second&apos;, we present only examples of subordinate clauses. 148 This constraint captures the effect of applying the following (schematic) lexical rule recursively: (5) X1\ \ Xi \Xi+i \ \S/Y1 Y, \ \Xi \Adj \Xj+i \ \S/Yi • • • Yn The derivation of (3a) is given below (where X indicates that add_adjuncts(Y ,X) is satisfied, and iv = NP\s). (6) ... J. opzettelijk een ongeluk NP ADJ NP ADJ \IV IV An interesting implication of this analysis is that in a categorial setting the notion &apos;head&apos; can be equated with the notion &apos;main functor&apos;. This has been proposed by Barry and Pickering (1990), but they are forced to assign a category containing Kleene-star operators to verbal elements. The semantic counterpart of such category-assignments is unclear. The present proposal is an alternative for such assignments which avoids introducing new categorial operators and which does not lead to semantic complications (the semantics of add_adjuncts is presented in section 3.3). Below we argue that this analysis also allows for a straightforward explanation of the distribution and scope of adjuncts in verb phrases headed by a verbal complex. 3 Cross-Serial Dependencies In Dutch, verbs selecti</context>
</contexts>
<marker>Barry, Pickering, 1990</marker>
<rawString>Guy Barry and Martin Pickering. 1990. Dependency and coordination in categorial grammar. In G. Barry and G. Morrill, editors, Studies in Categorial Grammar. University of Edinburgh. Edinburgh Working Papers in Cognitive Science 5.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gosse Bouma</author>
</authors>
<title>Modifiers and specifiers in categorial unification grammar.</title>
<date>1988</date>
<journal>Linguistics,</journal>
<pages>26--21</pages>
<contexts>
<context position="6337" citStr="Bouma, 1988" startWordPosition="1009" endWordPosition="1010">ve. In Dutch, for instance, the position of verb modifiers is not fixed. Adjuncts can in principle occur anywhere to the left of the verb:2 (3) a. dat Johan opzettelijk een ongeluk that J. deliberately an accident veroorzaakt causes that J. deliberately causes an accident b. dat Johan Marie opzettelijk that J. M. deliberately geen cadeau geeft no present gives that J. deliberately gave M. no present There are several ways to account for this fact. One can assign multiple categories to adjuncts or one can assign a polymorphic category x/x to adjuncts, with x restricted to &apos;verbal projections&apos; (Bouma, 1988). Alternatively, one can assume that adjuncts are not functors, but arguments of the verb. Since adjuncts are optional, can be iterated, and can occur in several positions, this implies that verbs must be polymorphic. The constraint add_adjuncts has this effect, as it optionally adds one or more adjuncts as arguments to the &apos;initial&apos; category of a verb: (4) lex(veroorzaken, X):- add_adjuncis(X, NP \(NP \S)) /ex(geven, X) :- add_adjuncts(X, NP\(NP\(NP\S))). add_adjuncts(S,S). add_adjuncts(Adj\X,Y) :- add_adjuncts(X,Y). add_adjuncts([dir D , val X [ arg A val Y dir D ) :- arg A add_adjuncts(X,Y)</context>
</contexts>
<marker>Bouma, 1988</marker>
<rawString>Gosse Bouma. 1988. Modifiers and specifiers in categorial unification grammar. Linguistics, 26:21-46.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bob Carpenter</author>
</authors>
<title>The generative power of categorial grammars and head-driven phrase structure grammars with lexical rules.</title>
<date>1991</date>
<journal>Computational Linguistics,</journal>
<pages>17--3</pages>
<contexts>
<context position="4293" citStr="Carpenter (1991)" startWordPosition="650" endWordPosition="651">irectly as a combination of simple constraints (evaluated by means of unification) and recursive constraints.&apos; (2) /ex(walks, X) :- iv(X), sv_agreement(sg3, X). /ex(kisses, X) :- tv(X), sv_agreement(sg3, X). [camp s). sv_agreemen/(Agr, agr Agr sv_agreement(Agr,Y\X) :- sv_agreement(Agr, X). Relational constraints can also be used to capture the effect of lexical rules. In a lexicalist theory such as CG, in which syntactic rules are considered to be universally valid scheme&apos;s of functor-argument combination, lexical rules are an essential tool for capturing language-specific generalizations. As Carpenter (1991) observes, some of the rules that have been proposed must be able to operate recursively. Predicative formation in English, for instance, uses a lexical rule turning a category reducible to VP into a category reducing to a VP-modifier (vP \vP). As a vP-modifier is reducible to VP, the rule can (and sometimes must) be applied recursively. 2.2 Adjuncts as arguments Miller (1992) proposes a lexical rule for French nouns which adds an (modifying) adjective to the list of arguments that the noun subcategorizes for. Since a noun val X &apos;We use X/Y and Y\X as shorthand for dir &apos;/&apos; arg Y [val X and dir</context>
<context position="25882" citStr="Carpenter (1991)" startWordPosition="4231" endWordPosition="4232"> with the position and scope of adjuncts. The rules given there are actually part of a larger fragment that covers the syntax of Dutch verb clusters in more detail. The fragment accounts for crossserial dependencies and extraposition constructions (including cases of &apos;partial&apos; extraposition), infinitivus-proparticipio, modal and participle inversion, the position of particles in verb clusters, clitic climbing, partial VPtopicalization, and verb second. In the larger fragment, additional recursive constraints are introduced, but the syntax is still restricted to application only. The result of Carpenter (1991) emphasizes the importance of lexical rules. There is a tendency in both CG and HPSG to rely more and more on mechanisms (such as inheritance and lexical rules or recursive constraints) that operate in the lexicon. The unrestricted generative capacity of recursive lexical rules implies that the remaining role of syntax can be extremely simple. In the examples above we have stressed this by giving an account for the syntax of cross-serial dependencies (a construction that is, given some additional assumptions, not context-free) using application only. In general, such an approach seems promisin</context>
</contexts>
<marker>Carpenter, 1991</marker>
<rawString>Bob Carpenter. 1991. The generative power of categorial grammars and head-driven phrase structure grammars with lexical rules. Computational Linguistics, 17(3):301-313.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jochen Done</author>
</authors>
<title>Generalizing earley deduction for constraint-based grammars.</title>
<date>1993</date>
<booktitle>In Jochen Doerre, editor, Computational Aspects of Constraint-Based Linguistic Description. Dyana-2 Deliverable R1.2.A.</booktitle>
<marker>Done, 1993</marker>
<rawString>Jochen Done. 1993. Generalizing earley deduction for constraint-based grammars. In Jochen Doerre, editor, Computational Aspects of Constraint-Based Linguistic Description. Dyana-2 Deliverable R1.2.A.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David R Dowty</author>
</authors>
<title>Grammatical relations and montague grammar.</title>
<date>1982</date>
<booktitle>The Nature of Syntactic Representation,</booktitle>
<pages>79--130</pages>
<editor>In Pauline Jacobson and Geoffrey Pullum, editors,</editor>
<location>Reidel, Dordrecht.</location>
<contexts>
<context position="2015" citStr="Dowty (1982)" startWordPosition="290" endWordPosition="291">Relational constraints can be used to define a range of polymorphic categories that are beyond the expressive capabilities of previous approaches. In particular, the introduction of relational constraints captures the effects of (recursive) lexical rules in a computationally attractive manner. The addition of such rules makes it feasible to consider truly &apos;lexicalist&apos; grammars, in which a powerful lexical component is accompanied by a highly restricted syntactic component, consisting of application only. 2 Recursive Constraints In CG, many grammatical concepts can only be defined recursively. Dowty (1982) defines grammatical functions such as subject and object as being the ultimate and penultimate &apos;argument-in&apos; of a verbal category. Hoeksema (1984) defines verbs as exocentric categories reducible to S. Lexical rules frequently refer to such concepts. For instance, a categorial lexical rule of passive applies to verbs selecting an object and must remove the subject. In standard unification-based formalisms, these concepts and the rules referring to such concepts cannot be expressed directly. 2.1 Subject-verb agreement Consider a categorial treatment of subject-verb agreement with intransitive </context>
</contexts>
<marker>Dowty, 1982</marker>
<rawString>David R. Dowty. 1982. Grammatical relations and montague grammar. In Pauline Jacobson and Geoffrey Pullum, editors, The Nature of Syntactic Representation, pages 79-130. Reidel, Dordrecht.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Martin Emms</author>
</authors>
<title>Parsing with polymorphism.</title>
<date>1993</date>
<booktitle>In Sixth Conference of the European Chapter of the Association for Computational Linguistics,</booktitle>
<pages>120--129</pages>
<contexts>
<context position="1046" citStr="Emms (1993)" startWordPosition="148" endWordPosition="149"> rules in a computationally attractive manner. We illustrate the linguistic merits of the new approach by showing how it accounts for the syntax of Dutch cross-serial dependencies and the position and scope of adjuncts in such constructions. Delayed evaluation is used to process grammars containing recursive constraints. 1 Introduction Combinations of Categorial Grammar (cG) and unification naturally lead to the introduction of polymorphic categories. Thus, Karttunen (1989) categorizes NP &apos;S as x/x, where x is a verbal category, Zeevat et al. (1987) assign the category x/(NP \x) to NP &apos;s, and Emms (1993) extends the Lambek-calculus with polymorphic categories to account for coordination, quantifier scope, and extraction. The role of polymorphism has been restricted, however, by the fact that in previous work categories were defined as feature structures using the simple, nonrecursive, constraints familiar from feature description languages such as PATR. Relational constraints can be used to define a range of polymorphic categories that are beyond the expressive capabilities of previous approaches. In particular, the introduction of relational constraints captures the effects of (recursive) le</context>
</contexts>
<marker>Emms, 1993</marker>
<rawString>Martin Emms. 1993. Parsing with polymorphism. In Sixth Conference of the European Chapter of the Association for Computational Linguistics, pages 120-129.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Erhard Hinrichs</author>
<author>Tsuneko Nakazawa</author>
</authors>
<title>Flipped out: AUX in German.</title>
<date>1989</date>
<booktitle>In Papers from the 25th Annual Regional Meeting of the Chicago Linguistic Society,</booktitle>
<pages>187--202</pages>
<publisher>Chicago Linguistics Society,</publisher>
<location>Chicago.</location>
<contexts>
<context position="10173" citStr="Hinrichs and Nakazawa, 1989" startWordPosition="1632" endWordPosition="1635">) XIY Zn\X)I(Zi\...Zn\Y) Hoeksema proposes that verbs which trigger crossserial word order are subject to (9): (10) ...An Bea wi/ NP NP Iv/iv J. (NpVv)/(Np\rv) Np \INT IV In a framework using recursive constraints, generalized disharmonic division can be implemented as a recursive constraint connecting the initial category of such verbs with a derived category: (11) lex(willen, X) :- cross_serial(X,(NP \S)/(NP \S)). /ex(zien, X) :- cross_serial(X,(NP \(NP \S))/(NP \S)). /ex(voornemen, (NPrefl \ (NP \ S))/(NP \S)). 3Argument inheritance is used in HPSG to account for verb clustering in German (Hinrichs and Nakazawa, 1989). The HPSG analysis is essentially equivalent to Hoeksema&apos;s account. veroorzaaki NP \IV \ (AD.] \iv) kussen NP\iv 149 (12) cross_serial(Out, In) :- division(Out , In), verb_cluster(Out). division(X , X). division((Z\X)/(Z\Y), X&apos; /Y&apos;) :- division(X /Y, X&apos; /Y&apos;). verb_cluster([ arg [ vc ]). Only verbs that trigger the cross-serial order are subject to the division constraint. This accounts immediately for the fact that cross-serial orders do not arise with all verbs selecting infinitival complements. 3.2 Verb Clusters The verb_cluster constraint ensures that cross-serial word order is obligatory </context>
</contexts>
<marker>Hinrichs, Nakazawa, 1989</marker>
<rawString>Erhard Hinrichs and Tsuneko Nakazawa. 1989. Flipped out: AUX in German. In Papers from the 25th Annual Regional Meeting of the Chicago Linguistic Society, pages 187-202. Chicago Linguistics Society, Chicago.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jack Hoeksema</author>
</authors>
<title>Categorial Morphology.</title>
<date>1984</date>
<tech>Ph.D. thesis,</tech>
<institution>Groningen University.</institution>
<contexts>
<context position="2162" citStr="Hoeksema (1984)" startWordPosition="313" endWordPosition="314">s. In particular, the introduction of relational constraints captures the effects of (recursive) lexical rules in a computationally attractive manner. The addition of such rules makes it feasible to consider truly &apos;lexicalist&apos; grammars, in which a powerful lexical component is accompanied by a highly restricted syntactic component, consisting of application only. 2 Recursive Constraints In CG, many grammatical concepts can only be defined recursively. Dowty (1982) defines grammatical functions such as subject and object as being the ultimate and penultimate &apos;argument-in&apos; of a verbal category. Hoeksema (1984) defines verbs as exocentric categories reducible to S. Lexical rules frequently refer to such concepts. For instance, a categorial lexical rule of passive applies to verbs selecting an object and must remove the subject. In standard unification-based formalisms, these concepts and the rules referring to such concepts cannot be expressed directly. 2.1 Subject-verb agreement Consider a categorial treatment of subject-verb agreement with intransitive ( NP[NOM]\S ) and transitive ( (NP[Nom] \s)/NP[Acc] ) verbs defined as follows: (1) /ex(walks, X) :- iv(X). /ex(kisses, X) :- tv(X). val [ cat s di</context>
</contexts>
<marker>Hoeksema, 1984</marker>
<rawString>Jack Hoeksema. 1984. Categorial Morphology. Ph.D. thesis, Groningen University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jack Hoeksema</author>
</authors>
<title>A categorial theory of reanalysis phenomena.</title>
<date>1991</date>
<journal>ms. RUG Groningen.</journal>
<contexts>
<context position="9341" citStr="Hoeksema, 1991" startWordPosition="1509" endWordPosition="1510">-serial word order, this order is obligatory, whereas if it is not, the infinitival complement will follow the verb: (8) a. *dat An wil Bea kussen. b. dat An zich voornam Bea that An Refl. planned Bea te kussen. to kiss that An. planned to kiss Bea c. *dat An zich Bea voornam te kussen. 3.1 Generalized Division Categorial accounts of cross-serial dependencies initially made use of a syntactic rule of composition (Steedman, 1985). Recognizing the lexical nature of the process, more recent proposals have used either a lexical rule of composition (Moortgat, 1988) or a lexical rule of &apos;division&apos; (Hoeksema, 1991). Division is a rule which enables a functor to inherit the arguments of its argument:3 XIY(X/Z1...IZn)I(YIZ IZn) To generate cross-serial dependencies, a &apos;clisharmonic&apos; version of this rule is needed: (9) XIY Zn\X)I(Zi\...Zn\Y) Hoeksema proposes that verbs which trigger crossserial word order are subject to (9): (10) ...An Bea wi/ NP NP Iv/iv J. (NpVv)/(Np\rv) Np \INT IV In a framework using recursive constraints, generalized disharmonic division can be implemented as a recursive constraint connecting the initial category of such verbs with a derived category: (11) lex(willen, X) :- cross_ser</context>
</contexts>
<marker>Hoeksema, 1991</marker>
<rawString>Jack Hoeksema. 1991. A categorial theory of reanalysis phenomena. ms. RUG Groningen.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Johnson</author>
</authors>
<title>Memoization in constraint logic programming.</title>
<date>1993</date>
<booktitle>Paper presented at the First Workshop on Principles and Practice of Constraint Programming,</booktitle>
<location>Newport, Rhode Island.</location>
<contexts>
<context position="22041" citStr="Johnson, 1993" startWordPosition="3611" endWordPosition="3612"> structure is completely intertwined. 4.1 Other strategies The delayed evaluation techniques discussed above can be easily implemented in parsers which rely on backtracking for their search. For the grammars that we have worked with, a simple bottom-up (shift-reduce) parser combined with delayed evaluation guarantees termination of the parsing process. To obtain an efficient parser more complicated search strategies are required. However, chart-based search techniques are not easily generalized for grammars which make use of complex constraints. Even if the theoretical problems can be solved (Johnson, 1993; Dorre, 1993) severe practical problems might surface, if the constraints are as complex as the ones proposed here. As an alternative we have implemented chart-based parsers using the &apos;non-interleaved pruning&apos; strategy (terminology from (Maxwell III and Kaplan, 1994)). 152 Using this strategy the parser first builds a parse-forest for a sentence on the basis of the context-free backbone of the grammar. In a second processing phase parses are recovered on the basis of the parse forest and the corresponding constraints are applied. This may be advantageous if the context-free backbone of the gr</context>
</contexts>
<marker>Johnson, 1993</marker>
<rawString>Mark Johnson. 1993. Memoization in constraint logic programming. Paper presented at the First Workshop on Principles and Practice of Constraint Programming, April 28-30, Newport, Rhode Island.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
</authors>
<title>Radical lexicalism.</title>
<date>1989</date>
<booktitle>Alternative Conceptions of Phrase Structure,</booktitle>
<pages>43--65</pages>
<editor>In Mark R. Baltin and Anthony S. Kroch, editors,</editor>
<publisher>University of Chicago Press.</publisher>
<contexts>
<context position="913" citStr="Karttunen (1989)" startWordPosition="122" endWordPosition="123"> recursive constraints. In particular, the introduction of relational constraints allows one to capture the effects of (recursive) lexical rules in a computationally attractive manner. We illustrate the linguistic merits of the new approach by showing how it accounts for the syntax of Dutch cross-serial dependencies and the position and scope of adjuncts in such constructions. Delayed evaluation is used to process grammars containing recursive constraints. 1 Introduction Combinations of Categorial Grammar (cG) and unification naturally lead to the introduction of polymorphic categories. Thus, Karttunen (1989) categorizes NP &apos;S as x/x, where x is a verbal category, Zeevat et al. (1987) assign the category x/(NP \x) to NP &apos;s, and Emms (1993) extends the Lambek-calculus with polymorphic categories to account for coordination, quantifier scope, and extraction. The role of polymorphism has been restricted, however, by the fact that in previous work categories were defined as feature structures using the simple, nonrecursive, constraints familiar from feature description languages such as PATR. Relational constraints can be used to define a range of polymorphic categories that are beyond the expressive </context>
</contexts>
<marker>Karttunen, 1989</marker>
<rawString>Lauri Karttunen. 1989. Radical lexicalism. In Mark R. Baltin and Anthony S. Kroch, editors, Alternative Conceptions of Phrase Structure, pages 43-65. University of Chicago Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John T Maxwell</author>
<author>Ronald M Kaplan</author>
</authors>
<title>The interface between phrasal and functional constraints.</title>
<date>1994</date>
<journal>Computational Linguistics,</journal>
<pages>19--4</pages>
<marker>Maxwell, Kaplan, 1994</marker>
<rawString>John T. Maxwell III and Ronald M. Kaplan. 1994. The interface between phrasal and functional constraints. Computational Linguistics, 19(4):571-90.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Philip Miller</author>
</authors>
<title>Clitics and Constituents</title>
<date>1992</date>
<booktitle>in Phrase Structure Grammar.</booktitle>
<publisher>Garland,</publisher>
<location>New York.</location>
<contexts>
<context position="4672" citStr="Miller (1992)" startWordPosition="713" endWordPosition="714">list theory such as CG, in which syntactic rules are considered to be universally valid scheme&apos;s of functor-argument combination, lexical rules are an essential tool for capturing language-specific generalizations. As Carpenter (1991) observes, some of the rules that have been proposed must be able to operate recursively. Predicative formation in English, for instance, uses a lexical rule turning a category reducible to VP into a category reducing to a VP-modifier (vP \vP). As a vP-modifier is reducible to VP, the rule can (and sometimes must) be applied recursively. 2.2 Adjuncts as arguments Miller (1992) proposes a lexical rule for French nouns which adds an (modifying) adjective to the list of arguments that the noun subcategorizes for. Since a noun val X &apos;We use X/Y and Y\X as shorthand for dir &apos;/&apos; arg Y [val X and dir &apos;\&apos; , respectively and S, NP, and Adj as &apos;typed arg Y variables&apos; of type [ cat s ], [ cat np ] , and [ cat adj ] , can be modified by any number of adjectives, the rule must be optional as well as recursive. The advantages of using a lexical rule in this case is that it simplifies accounting for agreement between nouns and adjectives and that it enables an account of word ord</context>
</contexts>
<marker>Miller, 1992</marker>
<rawString>Philip Miller. 1992. Clitics and Constituents in Phrase Structure Grammar. Garland, New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Moortgat</author>
</authors>
<title>Categorial Investigations.</title>
<date>1988</date>
<tech>Ph.D. thesis,</tech>
<institution>University of Amsterdam.</institution>
<contexts>
<context position="9292" citStr="Moortgat, 1988" startWordPosition="1501" endWordPosition="1502">atrix verb. If this verb is a &apos;trigger&apos; for cross-serial word order, this order is obligatory, whereas if it is not, the infinitival complement will follow the verb: (8) a. *dat An wil Bea kussen. b. dat An zich voornam Bea that An Refl. planned Bea te kussen. to kiss that An. planned to kiss Bea c. *dat An zich Bea voornam te kussen. 3.1 Generalized Division Categorial accounts of cross-serial dependencies initially made use of a syntactic rule of composition (Steedman, 1985). Recognizing the lexical nature of the process, more recent proposals have used either a lexical rule of composition (Moortgat, 1988) or a lexical rule of &apos;division&apos; (Hoeksema, 1991). Division is a rule which enables a functor to inherit the arguments of its argument:3 XIY(X/Z1...IZn)I(YIZ IZn) To generate cross-serial dependencies, a &apos;clisharmonic&apos; version of this rule is needed: (9) XIY Zn\X)I(Zi\...Zn\Y) Hoeksema proposes that verbs which trigger crossserial word order are subject to (9): (10) ...An Bea wi/ NP NP Iv/iv J. (NpVv)/(Np\rv) Np \INT IV In a framework using recursive constraints, generalized disharmonic division can be implemented as a recursive constraint connecting the initial category of such verbs with a d</context>
</contexts>
<marker>Moortgat, 1988</marker>
<rawString>Michael Moortgat. 1988. Categorial Investigations. Ph.D. thesis, University of Amsterdam.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fernando C N Pereira</author>
<author>Stuart M Shieber</author>
</authors>
<title>Prolog and Natural Language Analysis. Center for the Study of Language and Information Stanford.</title>
<date>1987</date>
<contexts>
<context position="15184" citStr="Pereira and Shieber (1987)" startWordPosition="2475" endWordPosition="2478">ct is &apos;inherited&apos; by the matrix verb. Assuming that adjuncts take scope over the verbs introducing them, this accounts for the ambiguity observed above. (16) /ex(lijken, Verb):- add_adjuncts(Verb, Verb`), cross_serial(Verb&apos; , (NP\S)/(NP\S)). lex(ontwijken, Verb):- add_adjuncts(Verb,NPVNP\S)). (17) ... de laatste tijd lijki te ontwijken ADJ IV/IV TV Tv/Tv (ADJ\TV) /TV ADJ\TV TV (18) . de Maisie tijd lijkt ADJ IV/IV (ADJ \TV)/(ADJ \TV) ADJ\TV TV The assumption that adjuncts scope over the verbs introducing them can be implemented as follows. We use a unification-based semantics in the spirit of Pereira and Shieber (1987). Furthermore, the semantics is head-driven, i.e. the semantics of a complex constituent is reetrant with the semantics of its head (i.e. the functor). The feature structure for a transitive verb including semantics (taking two NP&apos;s of the generalized quantifier type ((c, t) , t) as argument and assigning wide scope to the subject) is: dir `V [cat np arg sem (YAkiss(X,Y))^Sobi sem SSubj Thus, a lexical entry for a transitive verb can be defined as follows (where TV refers to the feature structure in 19): (20) /ex(kussen, X) :- add_adjuncts(X, TV). The lexical rule for adding adjuncts can now b</context>
</contexts>
<marker>Pereira, Shieber, 1987</marker>
<rawString>Fernando C.N. Pereira and Stuart M. Shieber. 1987. Prolog and Natural Language Analysis. Center for the Study of Language and Information Stanford.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Steedman</author>
</authors>
<title>Dependency and coordination in the grammar of Dutch</title>
<date>1985</date>
<pages>61--523</pages>
<contexts>
<context position="9158" citStr="Steedman, 1985" startWordPosition="1481" endWordPosition="1482">ussen3. see Bea kiss Cor to see kiss that An wants to The property of forming cross-serial dependencies is a lexical property of the matrix verb. If this verb is a &apos;trigger&apos; for cross-serial word order, this order is obligatory, whereas if it is not, the infinitival complement will follow the verb: (8) a. *dat An wil Bea kussen. b. dat An zich voornam Bea that An Refl. planned Bea te kussen. to kiss that An. planned to kiss Bea c. *dat An zich Bea voornam te kussen. 3.1 Generalized Division Categorial accounts of cross-serial dependencies initially made use of a syntactic rule of composition (Steedman, 1985). Recognizing the lexical nature of the process, more recent proposals have used either a lexical rule of composition (Moortgat, 1988) or a lexical rule of &apos;division&apos; (Hoeksema, 1991). Division is a rule which enables a functor to inherit the arguments of its argument:3 XIY(X/Z1...IZn)I(YIZ IZn) To generate cross-serial dependencies, a &apos;clisharmonic&apos; version of this rule is needed: (9) XIY Zn\X)I(Zi\...Zn\Y) Hoeksema proposes that verbs which trigger crossserial word order are subject to (9): (10) ...An Bea wi/ NP NP Iv/iv J. (NpVv)/(Np\rv) Np \INT IV In a framework using recursive constraints</context>
</contexts>
<marker>Steedman, 1985</marker>
<rawString>Mark Steedman. 1985. Dependency and coordination in the grammar of Dutch and English. Language, 61:523-68.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Henk Zeevat</author>
<author>Ewan Klein</author>
<author>Jo Calder</author>
</authors>
<title>Unification categorial grammar.</title>
<date>1987</date>
<booktitle>Categorial Grammar, Unification Grammar and Parsing. Centre for Cognitive Science, University of Edinburgh. Volume 1 of Working Papers in Cognitive Science.</booktitle>
<editor>In Nicholas Haddock, Ewan Klein, and Glyn Morrill, editors,</editor>
<contexts>
<context position="990" citStr="Zeevat et al. (1987)" startWordPosition="135" endWordPosition="138">straints allows one to capture the effects of (recursive) lexical rules in a computationally attractive manner. We illustrate the linguistic merits of the new approach by showing how it accounts for the syntax of Dutch cross-serial dependencies and the position and scope of adjuncts in such constructions. Delayed evaluation is used to process grammars containing recursive constraints. 1 Introduction Combinations of Categorial Grammar (cG) and unification naturally lead to the introduction of polymorphic categories. Thus, Karttunen (1989) categorizes NP &apos;S as x/x, where x is a verbal category, Zeevat et al. (1987) assign the category x/(NP \x) to NP &apos;s, and Emms (1993) extends the Lambek-calculus with polymorphic categories to account for coordination, quantifier scope, and extraction. The role of polymorphism has been restricted, however, by the fact that in previous work categories were defined as feature structures using the simple, nonrecursive, constraints familiar from feature description languages such as PATR. Relational constraints can be used to define a range of polymorphic categories that are beyond the expressive capabilities of previous approaches. In particular, the introduction of relat</context>
</contexts>
<marker>Zeevat, Klein, Calder, 1987</marker>
<rawString>Henk Zeevat, Ewan Klein, and Jo Calder. 1987. Unification categorial grammar. In Nicholas Haddock, Ewan Klein, and Glyn Morrill, editors, Categorial Grammar, Unification Grammar and Parsing. Centre for Cognitive Science, University of Edinburgh. Volume 1 of Working Papers in Cognitive Science.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>