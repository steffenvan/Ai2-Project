<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.975616">
Group Theory and Linguistic Processing*
</title>
<author confidence="0.947388">
Marc Dymetman
</author>
<affiliation confidence="0.8607">
Xerox Research Centre Europe
</affiliation>
<address confidence="0.7588385">
6, chemin de Maupertuis
38240 Meylan, France
</address>
<email confidence="0.97457">
Marc.Dymetman@xrce.xerox.com
</email>
<sectionHeader confidence="0.999799" genericHeader="abstract">
1 Introduction
</sectionHeader>
<bodyText confidence="0.99973885">
There is currently much interest in bringing together
the tradition of categorial grammar, and especially the
Lambek calculus (Lambek, 1958), with the more recent
paradigm of linear logic (Girard, 1987) to which it has
strong ties. One active research area concerns the de-
sign of non-commutative versions of linear logic (Abr-
usci, 1991; More, 1993) which can be sensitive to word
order while retaining the hypothetical reasoning capabil-
ities of standard (commutative) linear logic that make it
so well-adapted to handling such phenomena as quanti-
fier scoping (Dalrymple et al., 1995).
Some connections between the Lambek calculus and
group structure have long been known (van Benthem,
1986), and linear logic itself has some aspects strongly
reminiscent of groups (the producer/consumer duality of
a formula A with its linear negation Al), but no serious
attempt has been made so far to base a theory of linguis-
tic description solely on group structure.
This paper presents such a model, G-granunars (for
&amp;quot;group grammars&amp;quot;), and argues that:
</bodyText>
<listItem confidence="0.961018333333333">
• The standard group-theoretic notion of conjugacy,
which is central in 0-grammars, is well-suited to
a uniform description of commutative and non-
commutative aspects of language;
• The use of conjugacy provides an elegant approach
to long-distance dependency and scoping phenom-
ena, both in parsing and in generation;
• 0-grammars give a symmetrical account of the
semantics-phonology relation, from which it is easy
to extract, via simple group calculations, rewriting
systems computing this relation for the parsing and
generation modes.
</listItem>
<sectionHeader confidence="0.937237" genericHeader="keywords">
2 Group Computation
</sectionHeader>
<bodyText confidence="0.680777">
A MONOID Al is a set M together with a product Al x
</bodyText>
<listItem confidence="0.8684212">
Al —&gt; Al, written (a, b) ab, such that:
• This product is associative;
• There is an element 1 E AI (the neutral element)
with la = al = a for all a EM.
• This paper is an abridged version of Group Theory and Gram-
</listItem>
<page confidence="0.742789">
matical Description, TR-MLTT-033, XRCE, April 1998; available
on the CMP-LG archive at the address: http://xxxlanl.gov/abs/cmp-
10805002.
</page>
<bodyText confidence="0.953185642857143">
A GROUP is a monoid in which every element a has an
inverse a-1 such that a- la = aa-1 = 1.
A PREORDER on a set is a reflexive and transitive re-
lation on this set. When the relation is also symmetrical,
that is, R(x, y) R(y, x), then the preorder is called an
EQUIVALENCE RELATION. When it is antisymmetrical,
that is that is, R(x, y) A R(y, x) x = y, it is called a
PARTIAL ORDER.
A preorder R on a group G will be said to be COM-
PATIBLE with the group product iff, whenever R(x, y)
and R(s&apos; , yl), then R(xx&apos; , yy&apos;).
Normal submonoids of a group. We consider a com-
patible preorder notated x y on a group G. The fol-
lowing properties, for any x, y E G, are immediate:
</bodyText>
<equation confidence="0.99574425">
x y &lt;=&gt; 1 1;XY
x y 1 x 1 ;
x-+1 1
x-+1 yxy-1 —&gt; 1, for any y E G.
</equation>
<bodyText confidence="0.978820933333333">
Two elements x, x&apos; in a group G are said to be CONJU-
GATE if there exists y E G such that x&apos; = yxy. The
fourth property above says that the set Al of elements
x E G such that x 1 is a set which contains along with
an element all its conjugates, that is, a NORMAL subset
of G. As Al is clearly a submonoid of G, it will be called
a NORMAL SUBMONOID Of G.
Conversely, it is easy to show that with any nor-
mal submonoid M of G one can associate a pre-
order compatible with G. Indeed let&apos;s define x y
as xy-1 E Al.The relation is clearly reflex-
ive and transitive, hence is a preorder. It is also
compatible with G, for if x1 -4 yi and x2 —&gt; y9, then
-, --
x2y2-1 and yi(x2y21 )yi1 are in Al; hence
</bodyText>
<listItem confidence="0.798716">
• •
</listItem>
<subsectionHeader confidence="0.50313">
S1X2Y2-1Y1-1 = Xi Yi-1 M.X2Y2--1-1 ls In Al, im-
</subsectionHeader>
<bodyText confidence="0.914455142857143">
plying that xi x2 -+ y1 y2. that is, that the preorder is
compatible.&apos;
If S is a subset of G, the intersection of all normal
submonoids of G containing S (resp. of all subgroups
of G containing S) is a normal submonoid of G (resp. a
i In general M is not a subgroup of G. It is if x y implies
y x, that is, if the compatible preorder 4 is an equivalence re-
</bodyText>
<footnote confidence="0.9878395">
lation (and, therefore, a CONGRUENCE) on G. When this is the case,
Al is a NORMAL SUBGROUP of G. This notion plays a pivotal role in
classical algebra. Its generalization to subnzonoids of G is basic for the
algebraic theory of computation presented here.
</footnote>
<page confidence="0.996347">
348
</page>
<bodyText confidence="0.94532908">
normal subgroup of G) and is called the NORMAL SuB-
MONOID CLOSURE NM(S) of S in G (resp. the NOR-
MAL SUBGROUP CLOSURE NG(S) of S in G).
The free group over V. We now consider an arbitrary
set V. called the VOCABULARY, and we form the so-
called SET OF ATOMS ON V, which is notated V U V-1
and is obtained by taking both elements v in V and the
formal inverses v-1 of these elements.
We now consider the set F(V) consisting of the empty
string, notated 1, and of strings of the form x x2...xn,
where xi is an atom on V. It is assumed that such a
string is REDUCED, that is, never contains two consecu-
tive atoms which are inverse of each other: no substring
vv-1 or v-1 v is allowed to appear in a reduced string.
When a and /3 are two reduced strings, their concate-
nation a/3 can be reduced by eliminating all substrings of
the form v v-1 or v-1v. It can be proven that the reduced
string 7 obtained in this way is independent of the order
of such eliminations. In this way, a product on F(V)
is defined, and it is easily shown that F(V) becomes a
(non-commutative) group, called the FREE GROUP over
V (Hungerford, 1974).
Group computation. We will say that an ordered pair
GCS = (V, R) is a GROUP COMPUTATION STRUCTURE
if:
</bodyText>
<equation confidence="0.98955825">
1 V is a set, called the VOCABULARY, or the set of
GENERATORS
2. R is a subset of F( V), called the LEXICON, or the
set of RELATORS.2
</equation>
<bodyText confidence="0.922074096774193">
The submonoid closure NM(R) of R in F (V) is called
the RESULT MONOID of the group computation structure
GCS. The elements of NM(R) will be called COMPU-
TATION RESULTS, or simply RESULTS.
If r is a relator, and if a is an arbitrary element of
F( V), then arc -1 will be called a QUASI-RELATOR of
the group computation structure. It is easily seen that
the set RN of quasi-relators is equal to the normal sub-
set closure of R in F( V), and that NM(RN) is equal to
NM(R).
A COMPUTATION relative to GC S is a finite sequence
c = (r1, , r„) of quasi-relators. The product r1 • • • r„
in F( V) is evidently a result, and is called the RESULT
OF THE COMPUTATION c. It can be shown that the result
monoid is entirely covered in this way: each result is
the result of some computation. A computation can thus
be seen as a &amp;quot;witness&amp;quot;, or as a &amp;quot;proof-, of the fact that
a given element of F(V) is a result of the computation
structure.3
For specific computation tasks, one focusses on results
of a certain sort, for instance results which express a re-
lationship of input-output, where input and output are
2For readers familiar with group theory, this terminology will evoke
the classical notion of group PRESENTATION through generators and
relators. The main difference with our definition is that, in the classical
case, the set of relators is taken to be symmetrical, that is, to contain
r —1 if it contains r. When this additional assumption is made, our
preorder becomes an equivalence relation.
3The analogy with the view in constructive logics is clear. There
what we call a result is called a forniala or a type, and what we call a
computation is called a proof.
</bodyText>
<equation confidence="0.983963333333333">
j john-1
1 louise-1
p paris-1
m man
w woman-1
r (A) ran-1
A-1 s (A,B) B-1 saw-1
E-1 (E,A) A-1 in-1
t(N) N-1 the
ev(N,X,P[X] ) P[X]-1 a-1 X
a sm(N,X,P[X] ) P[X]1 a-1 X
N-1 tt(N,X,P[X] ) P[X]-1 a-1
</equation>
<figureCaption confidence="0.999523">
Figure 1: A 0-grammar for a fragment of English
</figureCaption>
<bodyText confidence="0.725905071428572">
assumed to belong to certain object types. For exam-
ple, in computational linguistics, one is often interested
in results which express a relationship between a fixed
semantic input and a possible textual output (generation
mode) or conversely in results which express a relation-
ship between a fixed textual input and a possible seman-
tic output (parsing mode).
If GCS = (V, R) is a group computation structure,
and if A is a given subset of F(V), then we will call
the pair GCSA = (GCS, A) a GROUP COMPUTATION
STRUCTURE WITH ACCEPTORS. We will say that A
is the set of acceptors, or the Punic INTERFACE, of
GC SA. A result of GCS which belongs to the public
interface will be called a PUBLIC RESULT of GC S A.
</bodyText>
<sectionHeader confidence="0.950938" genericHeader="introduction">
3 G-Grammars
</sectionHeader>
<bodyText confidence="0.997943833333333">
We will now show how the formal concepts introduced
above can be applied to the problems of grammatical
description and computation. We start by introducing
a grammar, which we will call a 0-GRAMMAR (for
&amp;quot;Group Grammar&amp;quot;), for a fragment of English (see Fig.
1).
A 0-grammar is a group computation structure with
acceptors over a vocabulary V = V109 U
Phon con-
sisting of a set of logical forms I/tog and a disjoint
set of phonological elements (in the example, words)
liphon . Examples of phonological elements are johtz,
saw, every, examples of logical forms j, s ( j , 1),
ev (m, x , sm(w , y , s (x , y) ) ); these logical forms can
be glossed respectively as &amp;quot;john&amp;quot;, &amp;quot;john saw louise&amp;quot; and
&amp;quot;for every man x, for some woman y,x saw y&amp;quot;.
The grammar lexicon, or set of relators, R is given as a
list of &amp;quot;lexical schemes&amp;quot;. An example is given in Fig. I.
Each line is a lexical scheme and represents a set of re-
lators in F( V). The first line is a ground scheme, which
corresponds to the single relator j john-1, and so are
the next four lines. The fifth line is a non-ground scheme,
which corresponds to an infinite set of relators, obtained
by instanciating the term meta-variable A (notated in up-
percase) to a logical form. So are the remaining lines.
We use Greek letters for expression meta-variables such
as a, which can be replaced by an arbitrary expression
of F(V); thus, whereas the term meta-variables A, B,
range over logical forms, the expression meta-variables
a, 0, ..., range over products of logical forms and phono-
</bodyText>
<equation confidence="0.716109666666667">
N-1 every-1
N-1 some-1
X a tharl
</equation>
<page confidence="0.989033">
349
</page>
<bodyText confidence="0.998682484848485">
logical elements (or their inverses) in F(V).4
The notation P [x] is employed to express the fact
that a logical form containing an argument identifier x
is equal to the application of the abstraction P to x. The
meta-variable X in P [X] ranges over such identifiers (x,
y, z, ...), which are notated in lower-case italics (and are
always ground). The meta-variable P ranges over logi-
cal form abstractions missing one argument (for instance
.\z. s ( j , z)). When matching meta-variables in logical
forms, we will allow limited use of higher-order unifica-
tion. For instance, one can match P [X] to s ( j , x) by
taking P = Az.s(j, z) and X = .r.
The vocabulary and the set of relators that we have just
specified define a group computation structure GCS =
(V, R). We will now describe a set of acceptors A for
this computation structure. We take A to be the set of
elements of F( V) which are products of the following
form:
where S is a logical form (S stands for &amp;quot;semantics&amp;quot;),
and where each Wi is a phonological element (W stands
for &amp;quot;word&amp;quot;). The expression above is a way of encoding
the ordered pair consisting of the logical form S and the
phonological string 11-1 W.) 11,, (that is, the inverse of
the product I V„ -1 11;, • • • TV
A public result SWn -1117„ _1-1 ... -1 in the
group computation structure with acceptors ((V, R), A)
— the G-grammar —will be interpreted as meaning that
the logical form S can be expressed as the phonological
string 1171 I V2 .• • • Wrz •
Let us give an example of a public result relative to the
grammar of Fig. 1.
We consider the relators (instanciations of relator
schemes):
</bodyText>
<equation confidence="0.999993">
ri = j —1 s ( j , 1) 1-1 saw-1
r.) = 1 louise-1
r3 = j john-1
</equation>
<bodyText confidence="0.57385">
and the quasi-relators:
</bodyText>
<equation confidence="0.983274555555556">
r1&apos; = j
r2&apos; = ( j saw) T2 ( j saw) -1
r3&apos; = r3
Then we have:
r1&apos; r2&apos; r3&apos; =
j j —1 s (j , 1) 1-1 saw-1 j-1 •
j saw 1 louise-1 saw-1 j-1 •
-1 ,
j john-1 = s ( j , 1) louise-1 saw john&apos;
</equation>
<bodyText confidence="0.8191686">
which means that s ( j , 1) louise-1 saw-ljohn-1 is the
result of a computation ( r &apos; , r2 &apos; , r3&apos; ) . This result
is obviously a public one, which means that the logi-
cal form s (j 1) can be verbalized as the phonological
string john saw louise.
</bodyText>
<footnote confidence="0.6814714">
4 Expression meta-variables are employed in the grammar for form-
ing the set of conjugates a exp a-1 of certain expressions exp (in
our example, exp is ev(N, X, P[X] ) P[X] —1, sm;N, X, P[X] )
P [X] —1, or X). Conjugacy allows the enclosed material exp to move
as a black in expressions of F( V), see sections 3. and 4.
</footnote>
<figure confidence="0.8806135">
every N x-1 a P[X]
--1
a some N X-1 a P [X]
N that a-1 X-1a P[X]
</figure>
<figureCaption confidence="0.998578">
Figure 2: Generation-oriented rules
</figureCaption>
<sectionHeader confidence="0.996202" genericHeader="method">
4 Generation
</sectionHeader>
<bodyText confidence="0.987514541666667">
Applying directly, as we have just done, the definition of
a group computation structure in order to obtain public
results can be somewhat unintuitive. It is often easier to
use the preorder . If, for a, b, c E F (V), abc is a rela-
tor, then abc -+ 1, and therefore b a-lc-1. Taking this
remark into account, it is possible to write the relators of
our G-grammar as the &amp;quot;rewriting rules&amp;quot; of Fig. 2; we use
the notation —• instead of -4 to distinguish these rules
from the parsing rules which will be introduced in the
next section.
The rules of Fig. 2 have a systematic structure. The
left-hand side of each rule consists of a single logical
form, taken from the corresponding relator in the G-
grammar; the right-hand side is obtained by &amp;quot;moving&amp;quot;
all the remaining elements in the relator to the right of
the arrow.
Because the rules of Fig. 2 privilege the rewriting of
a logical form into an expression of F (V), they are
called generation-oriented rules associated with the 0-
grammar.
Using these rules, and the fact that the preorder
is compatible with the product of F(V), the fact that
s ( j , 1 ) louise-1 saw- Volin-1 is a public result can be
obtained in a simpler way than previously. We have:
</bodyText>
<equation confidence="0.704590333333333">
s (j ,1) • j saw 1
j john
1 louise
</equation>
<bodyText confidence="0.972922666666667">
by the seventh, first and second rules (properly instanci-
ated), and therefore, by transitivity and compatibility of
the preorder:
</bodyText>
<equation confidence="0.4171514">
s (j ,1) j saw 1
john saw 1 john saw louise
which proves that s ( j , 1) john saw louise,
which is equivalent to saying that s ( j , 1)
louise-1 sa-w-ijohn-1 is a public result.
</equation>
<bodyText confidence="0.981115">
Some other generation examples are given in Fig. 3.
The first example is straightforward and works simi-
larly to the one we have just seen: from the logical form
i(s (j,1) ,p) one can derive the phonological string
john saw louise in paris.
</bodyText>
<equation confidence="0.953807833333333">
john
1 louise
paris
m man
w woman
r (A) —• A ran
s (A, B) —1 A saw B
i(E,A) E in A
t (N) the N
ev (N, X, P [X] )
sm(N,X,P[X] )
tt (N, X, P [X] )
</equation>
<page confidence="0.957016">
350
</page>
<figure confidence="0.990086451612903">
( s ( j , 1) ,p)
s (j , 1) in p
j saw 1 in p
John saw 1 in p
John saw louise in p
John saw louise in paris
ev(m,x,sm(w,y, s (x,y) ) )
-1 -1
a every m x a sm(w,y, s
a-1 every m x-1 a 0-1 some
-1
-u a every man x-1
0-1 some woman y-1 x saw y
-• a1 every man x-1 a x saw some woman
-
(by taking )3 = saw-1 x-1)
-1. every man saw some woman
(by taking a = 1)
sm(w,y,ev(m,x, s (x,y) ) )
,3-1 some w y-1 j3 ev(m,x, s (x,y) ) )
43-1 -1 -1 -1
some w y a every in x a s (x,y)
0-1
some woman y-1 /3
-1 -
a every man x1 a x saw y
/3-1-1 pn
some woman y every man saw y
(by taking a =1)
every man saw some woman
(by taking I3 = saw-1 man-1 every-1)
</figure>
<figureCaption confidence="0.999893">
Figure 3: Generation examples
</figureCaption>
<bodyText confidence="0.997829">
Long-distance movement and quantifiers The sec-
ond and third examples are parallel to each other and
show the derivation of the same string every&apos; man saw
some woman from two different logical forms. The
penultimate and last steps of each example are the most
interesting. In the penultimate step of the second exam-
ple, is instanciated to saw-1 x-1. This has the effect of
&amp;quot;moving&amp;quot; as a whole the expression some woman y-1
to the position just before y, and therefore to allow for the
cancellation of y-1 and y. The net effect is thus to &amp;quot;re-
place&amp;quot; the identifier y by the string some woman; in the
last step a is instanciated to the neutral element 1, which
has the effect of replacing x by every man. In the penul-
timate step of the third example, a is instanciated to the
neutral element, which has the effect of replacing x by ev-
ery man; then /3 is instanciated to saw-1 man-1 every&apos; ,
which has the effect of replacing y by some woman.
Remark In all cases in which an expression similar to
a al ... am a-1 appears (with the ai arbitrary vo-
cabulary elements), it is easily seen that, by giving a an
appropriate value in F(17), the ai ... am can move ar-
bitrarily to the left or to the right, but only together in
solidarity; they can also freely permute cyclically, that
is, by giving an appropriate value to a, the expression
a al ... am a-1 can take on the value ak ak+1 • • •
am al ... ak _1 (other permutations are in general not
possible). The values given to the a, 0, etc., in the exam-
ples of this paper can be understood intuitively in terms
of these two properties.
We see that, by this mechanism of concerted move-
ment, quantified noun phrases can move to whatever
place is assigned to them after the expansion of their
&amp;quot;scope&amp;quot; predicate, a place which was unpredictable at
the time of the expansion of the quantified logical form.
The identifiers act as &amp;quot;target markers&amp;quot; for the quantified
noun phrase: the only way to &amp;quot;get rid&amp;quot; of an identifier x
is by moving x-1, and therefore with it the correspond-
ing quantified noun phrase, to a place where it can cancel
with x.
</bodyText>
<sectionHeader confidence="0.979485" genericHeader="conclusions">
5 Parsing
</sectionHeader>
<bodyText confidence="0.954280571428571">
To the compatible preorder -4 on F (V) there corre-
sponds a &amp;quot;reverse&amp;quot; compatible preorder defined as
a -7 b iff -4 a, or, equivalently, a-1 -&gt; 6-1. The nor-
mal submonoid M&apos; in F(V) associated with is the
inverse monoid of the normal submonoid M associated
with -&gt; , that is, M&apos; contains a if M contains a-1.
It is then clear that one can present the relations:
</bodyText>
<equation confidence="0.89388825">
j john-1 -+ 1
A-1r (A) ran-1 -+ 1
a sm(N,X, P [X] ) [X] -1a-1X N-1 some-1 ---÷ 1
etc.
</equation>
<bodyText confidence="0.666119">
in the equivalent way:
john j&apos;-- 1
ran r (A) -1A 1
some N X-la P [X] (N, X, P [X] ) -1a-1 1
etc.
in
the --r
every a ev(N,X,P[X] ) P [x] -1 a-1 X N-1
</bodyText>
<subsubsectionHeader confidence="0.272389">
some
</subsubsectionHeader>
<bodyText confidence="0.571797">
that a sm(11&apos; P (X] ) P[X] -1 a-1 X N-1
N-1 tt (N,X, P [X] ) P [X]-1 a-1 X a
</bodyText>
<figureCaption confidence="0.997128">
Figure 4: Parsing-oriented rules
</figureCaption>
<bodyText confidence="0.999315785714286">
Suppose now that we move to the right of the -7 ar-
row all elements appearing on the left of it, but for the
single phonological element of each relator. We obtain
the rules of Fig. 4, which we call the &amp;quot;parsing-oriented&amp;quot;
rules associated with the G-grammar.
By the same reasoning as in the generation case, it is
easy to show that any derivation using these rules and
leading to the relation PS-, LF, where PS is a phono-
logical string and LF a logical form, corresponds to a
public result LF PS-1 in the G-grammar.
A few parsing examples are given in Fig. 5; they are
the converses of the generation examples given earlier.
In the first example, we first rewrite each of the
phonological elements into the expression appearing on
</bodyText>
<figure confidence="0.940224655172414">
(x,y) )
w y-i s(x,y)
John j
louise 1
paris p
man —r in
1110/nan --r W
ran A-1 r(A)
saw A1 s(A,B) B-1
E-1 i(E,A) A-I
t (N) N-1
351
jolm saw louise in paris
- j A-1 s(A,B) B-1 1 E-1 i(E,C) C-1 p
s(j,B) B-1 1 E-1 i(E,p)
- s(i,l) E-1 i(E,P)
- i(s(j, 1),P)
every man saw some woman
- ev(N,x,P[x] ) P[x]-1 a-1 x 14-1 m A-1 s(A,B) B-1 sm(M,Y,Q[y] ) 4[Y]-1 0-1 Y
- ev(m,x,P[x] ) P[x] —1 a-1 x A-1 s(A,B) B-1 13 sm(w,y,Q[Y] ) 4[Y)-1 0-1 Y
- x A-1 ev(m,x,P[x] ) P[x] —1 s(A,B) B-1 13 sm(w,y,Q[y] ) Q[y]1 0-1 y
X A-1 eV (In, P [X] P[x]-1 s(A,B) Q[y] —1 sm(w,y,4[y] ) B-1 y
-7 ev(m,x,P[x] ) P[x]-1 s(x,Y) Q[y]1 sm(w,Y,Q[y] )
and then either:
—r ev(m,x,P[x] ) P[x]-1 sm(w,y,s (x,y) )
-7 ev(m,x,sm(w,y,s(x,y) ) )
or:
—r ev(m,x,s (x.,Y) ) 4[Y] sm(w,Y,Q[y] )
- sm(w,y,ev(m,x,s (x,y) )
</figure>
<figureCaption confidence="0.999675">
Figure 5: Parsing examples
</figureCaption>
<bodyText confidence="0.997225476190476">
m—i
the right-hand side of the rules (and where the meta-
variables have been renamed in the standard way to avoid
name clashes). The rewriting has taken place in par-
allel, which is of course permitted (we could have ob-
tained the same result by rewriting the words one by
one). We then perform certain unifications: A is uni-
fied with j, C with p; then B is unified to 1.5 Finally E
is unified with s Ci , 1 ) , and we obtain the logical form
i(s(j,1),p). In this last step, it might seem feasible
to unify E to i(E,p) instead, but that is in fact forbid-
den for it would mean that the logical form i ( E, p) is
not a finite tree, as we do require. This condition pre-
vents &amp;quot;self-cancellation&amp;quot; of a logical form with a logical
form that it strictly contains.
Quantifier scoping In the second example, we start
by unifying m with N and w with M; then we &amp;quot;move&amp;quot;
P [x] -1 next to s (A, B) by taking a = x A-1 ;6 then
again we &amp;quot;move&amp;quot; Q [y] —1 next to s (A, B) by taking g
= B sm(w, y, Q [y] ) —1; x is then unified with A and y
with B. This leads to the expression:
</bodyText>
<equation confidence="0.701759">
ev(m,x,P[x] )P [x]-1s (x,y)Q[y]-1sm(w,y,Q[y] )
</equation>
<bodyText confidence="0.969778083333333">
where we now have a choice. We can either
unify s (x,y) with Q[y], or with P [x] . In the
5Another possibility at this point would be to unify 1 with E rather
than with B. This would lead to the construction of the logical form
i (1,p), and, after unification of E with that logical form, would con-
duct to the output s Ii, ± ( 1 ,P) I. If one wants to prevent this output,
several approaches are possible. The first one consists in typing the log-
ical form with syntactic categories. The second one is to have some no-
tion of logical-form well-formedness (or perhaps interpretability) dis-
allowing the logical forms i (1 ,p) [louise in paris] or ± It (w) ,p)
[(the woman) in paris], although it might allow the form t (1 (w, A) )
[the (woman in paris)].
6We have assumed that the meta-variables corresponding to identi-
fiers in P and Q have been instanciated to arbitrary, but different, values
sand y. See (Dymetman, 1998) for a discussion of this point.
first case, we continue by now unifying P [x]
with sm (w, y, s (x, y) ) , leading to the output
ev(m,x, sm (w,y, s (x,y) ) ). In the sec-
ond case, we continue by now unifying Q [y]
with ev (m, x, s (x, y ) ) , leading to the output
sm(w,y, ev (m,x, s (x,y) ). The two possible
quantifier scopings for the input string are thus obtained,
each corresponding to a certain order of performing the
unifications.
</bodyText>
<sectionHeader confidence="0.998334" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.975132">
Thanks to Christian Retore, Eric de la Clergerie, Alain
Lecomte and Aarne Ranta for comments and discussion.
</bodyText>
<sectionHeader confidence="0.998563" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.994301222222222">
V.M. Abrusci. 1991. Phase semantics and sequent cal-
culus for pure non-commutative classical linear logic.
Journal of Symbolic Logic, 56(4).
M. Dalrymple, J. Lamping, F. Pereira, and V. Saraswat.
1995. Linear logic for meaning assembly. In Proc.
CLNLP, Edinburgh.
Marc Dymetman. 1998. Group computation and its ap-
plications to linguistic description. (in preparation).
J.Y. Girard. 1987. Linear logic. Theoretical Computer
Science, 50(1).
Thomas W. Hungerford. 1974. Algebra. Springer-
Verlag.
J. Lambek. 1958. The mathematics of sentence struc-
ture. American Mathematical Monthly, 65:154-168.
C. More. 1993. Reseaux et sequents ordonnes. Ph.D.
thesis, Univ. Paris 7.
Johan van Benthem. 1986. Essays in Logical Semantics.
D. Reidel, Dordrecht, Holland.
</reference>
<page confidence="0.998259">
352
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.692078">
<title confidence="0.99938">Group Theory and Linguistic Processing*</title>
<author confidence="0.999678">Marc Dymetman</author>
<affiliation confidence="0.925804">Xerox Research Centre Europe</affiliation>
<address confidence="0.874375">6, chemin de Maupertuis 38240 Meylan, France</address>
<email confidence="0.90804">Marc.Dymetman@xrce.xerox.com</email>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>V M Abrusci</author>
</authors>
<title>Phase semantics and sequent calculus for pure non-commutative classical linear logic.</title>
<date>1991</date>
<journal>Journal of Symbolic Logic,</journal>
<volume>56</volume>
<issue>4</issue>
<marker>Abrusci, 1991</marker>
<rawString>V.M. Abrusci. 1991. Phase semantics and sequent calculus for pure non-commutative classical linear logic. Journal of Symbolic Logic, 56(4).</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Dalrymple</author>
<author>J Lamping</author>
<author>F Pereira</author>
<author>V Saraswat</author>
</authors>
<title>Linear logic for meaning assembly.</title>
<date>1995</date>
<booktitle>In Proc. CLNLP,</booktitle>
<location>Edinburgh.</location>
<contexts>
<context position="755" citStr="Dalrymple et al., 1995" startWordPosition="108" endWordPosition="111">.Dymetman@xrce.xerox.com 1 Introduction There is currently much interest in bringing together the tradition of categorial grammar, and especially the Lambek calculus (Lambek, 1958), with the more recent paradigm of linear logic (Girard, 1987) to which it has strong ties. One active research area concerns the design of non-commutative versions of linear logic (Abrusci, 1991; More, 1993) which can be sensitive to word order while retaining the hypothetical reasoning capabilities of standard (commutative) linear logic that make it so well-adapted to handling such phenomena as quantifier scoping (Dalrymple et al., 1995). Some connections between the Lambek calculus and group structure have long been known (van Benthem, 1986), and linear logic itself has some aspects strongly reminiscent of groups (the producer/consumer duality of a formula A with its linear negation Al), but no serious attempt has been made so far to base a theory of linguistic description solely on group structure. This paper presents such a model, G-granunars (for &amp;quot;group grammars&amp;quot;), and argues that: • The standard group-theoretic notion of conjugacy, which is central in 0-grammars, is well-suited to a uniform description of commutative and</context>
</contexts>
<marker>Dalrymple, Lamping, Pereira, Saraswat, 1995</marker>
<rawString>M. Dalrymple, J. Lamping, F. Pereira, and V. Saraswat. 1995. Linear logic for meaning assembly. In Proc. CLNLP, Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Marc Dymetman</author>
</authors>
<title>Group computation and its applications to linguistic description. (in</title>
<date>1998</date>
<journal>Theoretical Computer Science,</journal>
<volume>50</volume>
<issue>1</issue>
<marker>Dymetman, 1998</marker>
<rawString>Marc Dymetman. 1998. Group computation and its applications to linguistic description. (in preparation). J.Y. Girard. 1987. Linear logic. Theoretical Computer Science, 50(1).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Thomas W Hungerford</author>
</authors>
<date>1974</date>
<publisher>Algebra. SpringerVerlag.</publisher>
<contexts>
<context position="5379" citStr="Hungerford, 1974" startWordPosition="1002" endWordPosition="1003">is an atom on V. It is assumed that such a string is REDUCED, that is, never contains two consecutive atoms which are inverse of each other: no substring vv-1 or v-1 v is allowed to appear in a reduced string. When a and /3 are two reduced strings, their concatenation a/3 can be reduced by eliminating all substrings of the form v v-1 or v-1v. It can be proven that the reduced string 7 obtained in this way is independent of the order of such eliminations. In this way, a product on F(V) is defined, and it is easily shown that F(V) becomes a (non-commutative) group, called the FREE GROUP over V (Hungerford, 1974). Group computation. We will say that an ordered pair GCS = (V, R) is a GROUP COMPUTATION STRUCTURE if: 1 V is a set, called the VOCABULARY, or the set of GENERATORS 2. R is a subset of F( V), called the LEXICON, or the set of RELATORS.2 The submonoid closure NM(R) of R in F (V) is called the RESULT MONOID of the group computation structure GCS. The elements of NM(R) will be called COMPUTATION RESULTS, or simply RESULTS. If r is a relator, and if a is an arbitrary element of F( V), then arc -1 will be called a QUASI-RELATOR of the group computation structure. It is easily seen that the set RN </context>
</contexts>
<marker>Hungerford, 1974</marker>
<rawString>Thomas W. Hungerford. 1974. Algebra. SpringerVerlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Lambek</author>
</authors>
<title>The mathematics of sentence structure.</title>
<date>1958</date>
<journal>American Mathematical Monthly,</journal>
<pages>65--154</pages>
<marker>Lambek, 1958</marker>
<rawString>J. Lambek. 1958. The mathematics of sentence structure. American Mathematical Monthly, 65:154-168.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C More</author>
</authors>
<title>Reseaux et sequents ordonnes.</title>
<date>1993</date>
<tech>Ph.D. thesis,</tech>
<institution>Univ. Paris</institution>
<marker>More, 1993</marker>
<rawString>C. More. 1993. Reseaux et sequents ordonnes. Ph.D. thesis, Univ. Paris 7.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Johan van Benthem</author>
</authors>
<date>1986</date>
<booktitle>Essays in Logical Semantics. D.</booktitle>
<location>Reidel, Dordrecht, Holland.</location>
<marker>van Benthem, 1986</marker>
<rawString>Johan van Benthem. 1986. Essays in Logical Semantics. D. Reidel, Dordrecht, Holland.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>