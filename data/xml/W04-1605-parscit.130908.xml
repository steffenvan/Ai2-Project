<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000479">
<note confidence="0.8262624">
Systematic Verb Stem Generation for Arabic ∗
Jim Yaghi Sane M Yagi
DocRec Ltd., Department of English,
34 Strathaven Place, Atawhai, University of Sharjah,
Nelson, New Zealand. Sharjah, U.A.E.
</note>
<email confidence="0.945559">
jim@docrec.com saneyagi@yahoo.com
</email>
<sectionHeader confidence="0.982191" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999592578947368">
Performing root-based searching, concordancing,
and grammar checking in Arabic requires an
efficient method for matching stems with roots and
vice versa. Such mapping is complicated by the
hundreds of manifestations of the same root. An
algorithm based on the generation method used by
native speakers is proposed here to provide a map-
ping from roots to stems. Verb roots are classified
by the types of their radicals and the stems they
generate. Roots are moulded with morphosemantic
and morphosyntactic patterns to generate stems
modified for tense, voice, and mode, and affixed
for different subject number, gender, and person.
The surface forms of applicable morphophonemic
transformations are then derived using finite state
machines. This paper defines what is meant by
‘stem’, describes a stem generation engine that the
authors developed, and outlines how a generated
stem database is compiled for all Arabic verbs.
</bodyText>
<sectionHeader confidence="0.771581" genericHeader="method">
I Introduction
</sectionHeader>
<bodyText confidence="0.977010563829787">
Morphological parsers and analysers for Arabic are
required to dissect an input word and analyse its
components in order to perform even the simplest
of language processing tasks. The letters of the
majority of Arabic words undergo transformations
rendering their roots unrecognisable. Without the
root, it is difficult to identify a word’s morphose-
mantic template, which is necessary for pinpointing
its meaning, or its morphosyntactic pattern, which
is essential for realising properties of the verb,
such as its tense, voice, and mode, and its subject’s
number, gender, and person. It is fundamental that
an analyser be able to reverse the transformations
a word undergoes in order to match the separated
root and template with the untransformed ones in its
database. Unfortunately, defining rules to reverse
transformations is not simple.
∗ The authors wish to thank the anonymous reviewers of this
article as their suggestions have improved it significantly.
Research in Arabic morphology has primarily fo-
cused on morphological analysis rather than stem
generation.
Sliding window algorithms (El-Affendi, 1999)
use an approximate string matching approach of
input words against lists of roots, morpholog-
ical patterns, prefixes, and suffixes. Algebraic
algorithms (El-Affendi, 1991), on the other hand,
assign binary values to morphological patterns and
input words, then perform some simple algebraic
operations to decompose a word into a stem and
affixes. Permutation algorithms (Al-Shalabi and
Evens, 1998) use the input word’s letters to generate
all possible trilateral or quadrilateral sequences
without violation of the original order of the letters
which is then compared with items in a dictionary of
roots until a match is found. Linguistic algorithms
(Thalouth and Al-Dannan, 1990; Yagi and Harous,
2003) remove letters from an input word that belong
to prefixes and suffixes and place the remainder
of the word into a list. The members of this list
are then tested for a match with a dictionary of
morphological patterns.
The primary drawback of many of these tech-
niques is that they attempt to analyse using the infor-
mation found in the letters of the input word. When
roots form words, root letters are often transformed
by replacement, fusion, inversion, or deletion, and
their positions are lost between stem and affix let-
ters. Most attempts use various closest match algo-
rithms, which introduce a high level of uncertainty.
In this paper, we define Arabic verb stems such that
root radicals, morphological patterns, and transfor-
mations are formally specified. When stems are
defined this way, input words can be mapped to cor-
rect stem definitions, ensuring that transformations
match root radicals rather than estimate them.
Morphological transformation in our definition
is largely built around finite state morphology
(Beesley, 2001) which assumes that these trans-
formations can be represented in terms of regular
relations between regular language forms. Beesley
(2001) uses finite state transducers to encode the
intersection between roots, morphological patterns,
and the transformation rules that account for mor-
phophonemic phenomena such as assimilation,
deletion, epenthesis, metathesis, etc.
In this paper, a description of the database re-
quired for stem generation is presented, followed by
a definition of stem generation. Then the database
together with the definition are used to implement a
stem generation engine. This is followed by a sug-
gestion for optimising stem generation. Finally, a
database of generated stems is compiled in a format
useful to various applications that the conclusion al-
ludes to.
In the course of this paper, roots are represented
in terms of their ordered sequence of three or four
radicals in a set notation, i.e., {F,M,L,Q}. When
the capitalised Roman characters F, M, L, and Q
are used, they represent a radical variable or place
holder. They stand for First Radical (F), Medial
Radical (M), Last Radical in a trilateral root (L), and
Last Radical in a quadrilateral root (Q).
For readability, all Arabic script used here is fol-
lowed by an orthographic transliteration between
parentheses, using the Buckwalter standard1. Buck-
walter’s orthographic transliteration provides a one-
to-one character mapping from Arabic to US-ASCII
characters. With the exception of a few charac-
ters, this transliteration scheme attempts to match
the sounds of the Roman letters to the Arabic ones.
The following list is a subset of the less obvious
transliterations used here: 3 (@), cs (Y), &amp;quot; (a), �(i),
&apos; (u), &apos; (o), and &apos; (~).
</bodyText>
<sectionHeader confidence="0.505425" genericHeader="method">
2 Stem Generation Database
</sectionHeader>
<figure confidence="0.98590775">
root id
F
M
L
R
TemplateList
string id
string
</figure>
<figureCaption confidence="0.8149125">
Figure 1: The stem generation database tables and
their relations.
</figureCaption>
<footnote confidence="0.887154">
1The complete table of orthographic transliteration may be
found at http://www.qamus.org/transliteration.htm
</footnote>
<bodyText confidence="0.999667551020408">
Arabic stems can be generated if lists of all roots
and all morphological patterns are provided. It is
necessary that this data be coupled with a database
that links the roots with their morphological patterns
(or templates) so that only valid stems are gener-
ated for each root. The roots in this database may
be moulded with morphosemantic and morphosyn-
tactic patterns to generate intermediate form stems.
The stems may then be transformed into final surface
forms with a number of specific morphophonemic
rules using a finite state transducer compiling lan-
guage.
Figure 1 shows a summary of the stem generation
tables and their relations. The RootsList table con-
tains all verb roots from the popular Arabic dictio-
nary, Al-Waseet, (Mustapha et al., 1972), with F, M,
L, and Q representing the table fields for up to four
radicals per root. A root identifier is used to link
this table to the Template table. The Template table
lists all morphosemantic and morphosyntactic pat-
terns used to generate stems from roots of a certain
type. This table also specifies the syntactic proper-
ties of stems (voice and tense) generated by using the
template entry. The MainDictionary table links the
RootsList and Template tables together and specifies
which entries apply to which roots.
Stems generated with these tables are unaffixed
stems. The affix id field links each entry to a subject
pronominal affix table that uses transformation rules
generating affixed stems. Although object pronom-
inal affixes are not dealt with in this paper, they are
generally agglutinating in nature and therefore cause
no morphophonemic alterations to a stem. They
can be added for generation or removed for analysis
without affecting the stem at all.
Affixation and transformation rules are both
specified using PERL regular expressions (Friedl,
2002). Regular expressions (Regexp) is an alge-
braic language that is used for building finite state
transducers (FSTs) that accept regular languages. In
the next section, Regexp is used to perform morpho-
phonemic transformations and to generate affixed
forms of stems. If generated stems are to be useful
for root extraction and morphological analysis, it is
essential at every stage of generation to be able to
track exactly which letters are members of the root
radical set, which belong to the template, and what
transformations occur on the untransformed stem
producing the final surface form.
</bodyText>
<sectionHeader confidence="0.719191" genericHeader="method">
3 Definition of Stem Generation
</sectionHeader>
<bodyText confidence="0.99959">
In order to be useful in analysis applications, Arabic
stems need to be in a surface form which will only
undergo agglutinating changes for any further mor-
</bodyText>
<figure confidence="0.9967732">
RootsList
MainDictionary
stem id
RootsList-&gt;root id
entry-&gt;entry id
Template
entry id
TemplatesList-&gt;string_id
RootType
Pattern
Variant
Voice
Tense
Transform-&gt;transform_id
Affixes-&gt;affix_id
</figure>
<bodyText confidence="0.999797105263158">
phological modification. Stems should be defined in
terms of the root radicals, morphosemantic and mor-
phosyntactic template letters, and morphophonemic
alterations. By doing so, inversing stem transforma-
tions becomes trivial. We require the automatic stem
generator to always be aware of the origin of each of
the letters in stems it generates and to be able to dis-
tinguish between letters in the original radical set or
in the template string. The stem generator may then
be used to compile a complete list of all affixed stems
from database roots while retaining all transforma-
tion information. The resulting list of stems may
then be turned into a searchable index that holds the
complete morphological analysis and classification
for each entry.
Since originally Arabic words can have a maxi-
mum of four root radicals, a root radical set R is
defined in terms of the ordered letters of the root as
follows:
</bodyText>
<equation confidence="0.995172">
R = {rF, rM, rL, rQ} (1)
</equation>
<bodyText confidence="0.999931375">
In the database, pattern, root, variant, and voice-
tense ids identify a particular morphological pattern
s. Templates are used to generate a stem from a root.
The text of s is defined in terms of the letters and di-
acritics of the template in sequence (x1...xl) and the
radical position markers or place holders (hF, hM,
hL, and hQ), that indicate the positions that letters
of the root should be slotted into:
</bodyText>
<equation confidence="0.991157">
s = x1x2...hF...hM...hL...hQ...xn (2)
</equation>
<bodyText confidence="0.996557111111111">
Stem Generator (SG) uses regular expressions as
the language for compiling FSTs for morphophone-
mic transformations. Transformation rules take into
account the context of root radicals in terms of their
positions in the template and the nature of the tem-
plate letters that surround them. Transformations
are performed using combinations of regular expres-
sion rules applied in sequence, in a manner similar to
how humans are subconsciously trained to process
the individual transformations. The resulting tem-
plate between one morphophonemic transformation
and the next is an intermediate template. However,
in order to aid the next transformation, the trans-
formed radicals are marked by inserting their place
holders before them. For example, hF Žَ hM ’َ hL Êَ
(FraMsaLma) is an intermediate template formed
by the root radical set R ={Ž, ’, Ê} ({r, s, m})
and the morphological pattern s = hFَ hMَ hLَ
(FaMaLa).
To create the initial intermediate template i0 from
the radical set R and morphological pattern s, a
function Regexp(String, SrchPat, ReplStr) is
defined to compile FSTs from regular expressions.
The function accepts in its first argument a string
that is tested for a match with the search pattern
(SrchPat) in its second argument. If SrchPat
is found, the matching characters in String are
replaced with the replace string (ReplStr). This
function is assumed to accept the standard PERL
regular expression syntax.
A function, CompileIntermediate(R, s), ac-
cepts the radical set R and morphological pattern
s to compile the first intermediate template i0. A
regular expression is built to make this transforma-
tion. It searches the morphological pattern text for
radical place holders and inserts their respective
radical values after them. Since Regexp performs
substitutions instead of insertions, replacing each
marker with itself followed by its radical value is
effectively equivalent to inserting its radical value
after it. Let p be a search pattern that matches all
occurrences of place holders hF, hM, hL, or hQ
in the morphological pattern, then an initial inter-
mediate form i0 may be compiled in the following
manner:
</bodyText>
<equation confidence="0.9987945">
i0 = CompileIntermediate(R, s)
= Regexp(s, p, pRp)
= {x1...hFrF...hMrM...hLrL...hQrQ...xn}
(3)
</equation>
<bodyText confidence="0.99351275">
Let T = {t1...tm} be the transformation rules ap-
plied on each intermediate template to create subse-
quent intermediate templates. Transformation rules
are defined as:
</bodyText>
<equation confidence="0.987693">
tj = (SrchPatj, ReplStrj) (4)
</equation>
<bodyText confidence="0.9986714">
A second function Transform(i, t) is required to
perform transformations. A subsequent intermedi-
ate template ij+1 is the recursive result of transform-
ing the current intermediate template ij with the next
rule tj+1. Each transformation is defined as:
</bodyText>
<equation confidence="0.994318666666667">
ij+1 = Transform(ij, tj+1) for 0 ≤ j &lt; m
= Regexp(ij, SrchPatj+1, ReplStrj+1)
(5)
</equation>
<bodyText confidence="0.99985625">
At any point in the transformation process, the
current transformed state of radicals (R′) and tem-
plate string (s′) may be decomposed from the current
intermediate template as follows:
</bodyText>
<equation confidence="0.99801">
CompileIntermediate−1(ij) = (R′, s′) (6)
</equation>
<bodyText confidence="0.999994666666667">
To turn final intermediate template im into a
proper stem, a regular expression is built that
deletes the place holders from the intermediate
template. To do this with a regular expression, the
place holders matched are replaced with the null
string during the matching process as follows:
</bodyText>
<equation confidence="0.980464">
Regexp(im, p, null) (7)
</equation>
<bodyText confidence="0.999059071428572">
Basic stems are only modified for tense and voice.
Additional morphosyntactic templates or affixation
rules further modify proper stems for person, gen-
der, number, and mode. Affixation rules are regu-
lar expressions like transformation rules. However,
these rules modify final intermediate templates by
adding prefixes, infixes, or suffixes, or modifying or
deleting stem letters. They require knowledge of
the radical positions and occasionally their morpho-
phonemic origins. Adding affixes to a stem operates
on the intermediate template which retains the nec-
essary information.
Let a be the affixation rule that is being applied to
a certain intermediate template:
</bodyText>
<equation confidence="0.971365">
a = (SrchPat, ReplStr) (8)
</equation>
<bodyText confidence="0.996465666666667">
Now using the function Transform that was
defined earlier, affixes are added to im to produce
the intermediate affixed template im+1:
</bodyText>
<equation confidence="0.998764333333333">
im+1 = Transform(im, a)
= Regexp(im, SrchPat, ReplStr)
(9)
</equation>
<bodyText confidence="0.9988825">
To convert for output im+1 to an affixed stem, one
may remove place holders using the following:
</bodyText>
<equation confidence="0.95925">
Regexp(im+1, p, null) (10)
</equation>
<bodyText confidence="0.999907666666667">
With this definition, generated stems are de-
scribed by intermediate templates. Intermediate
templates retain knowledge of the current state of
template and radical letters without losing the abil-
ity to recall their origins. This algorithm, therefore,
would avoid guesswork in the identification of root
radicals. Automatic rule-based stem generation
and analysis are both facilitated by this feature of
intermediate templates.
</bodyText>
<sectionHeader confidence="0.879519" genericHeader="method">
4 Stem Generation Engine
</sectionHeader>
<bodyText confidence="0.9998594">
A stem generation engine may be built on the ba-
sis of the definition just advanced. The three com-
ponents, Stem Transformer, Afixer, and Slotter, ap-
plied in sequence, make up SG. Stem Transformer
applies the appropriate transformation rules to the
morphological pattern, Afixer adds specific affixes
to the transformed template; and Slotter applies the
radicals to the transformed affixed template to pro-
duce the final affixed stem.
SG begins with a stem ID from the MainDic-
tionary table as input to Stem Transformer (See Fig-
ure 1). The root and entry associated with the stem
ID are used to identify the radicals of the root, the
morphological pattern string, a list of transformation
rules, and an affix table ID.
</bodyText>
<figureCaption confidence="0.988507">
Figure 2: Stem Transformer
</figureCaption>
<bodyText confidence="0.995232933333333">
Stem Transformer applies transformation rules
that are localised to the root radicals and letters
of the template in the contexts of one another. To
prepare the template and root for transformation, the
engine begins by marking radicals in the template.
Stem Transformer is applied incrementally using
the current radical set, the template string, and one
transformation rule per pass, as in Figure 2. The out-
put of each pass is fed back into Stem Transformer in
the form of the jth-rule-transformed template string
and radicals, along with the (j +1)th transformation
rule. When all rules associated with the template are
exhausted, the resultant template string and radicals
are output to the next phase.
To illustrate, assume the morphological pattern
</bodyText>
<equation confidence="0.740081666666667">
s = I hFe hM, hL, (AiFotaMaLa), the radical set
R ={ 3, J, j} ({@,k,r}), and the transformation rule
set T = {1,12}.
</equation>
<figure confidence="0.988855">
template_string
when i&lt;n
F M L R
final when i=n
template_string
Intermediate Stem
Decompose
Compose
F M L R
final when i=n
replace_string
i=0 ...n
i transform_rule
th
Transformed
Intermediate Stem
Transform
Stem Transformer
search_pattern
</figure>
<bodyText confidence="0.993784">
Stem Transformer generates a proper stem using
the following steps:
Equation 3 above creates the initial intermediate
template when passed the radical set and morpho-
logical template, thus producing:
</bodyText>
<equation confidence="0.992764666666667">
i0 = CompileIntermediate(R, s)
= ِmhF ْŒَu hM ºَ hL Žَ
(AiF@taMkaLra)
</equation>
<bodyText confidence="0.9822276">
The first transformation rule t1 = 1, t1 ∈ T is a
regular expression that searches for a u (t) following
hF and replaces u (t) with a copy of rF. To trans-
form i0 into i1 with rule t1, Equation 5 is used, thus
producing:
</bodyText>
<equation confidence="0.995853666666667">
i1 = Transform(i0, t1)
= ِm hF ْŒَŒ hM ºَ hL Žَ
(AiF@o@aMkaLra)
</equation>
<bodyText confidence="0.966913666666667">
Next, a gemination rule t2 = 12, t2 ∈ T is applied
to i1. The gemination regular expression searches
for an unvowelled letter followed by a vowelled du-
plicate and replaces it with the geminated vowelled
letter. Once more, Equation 5 is used to make the
transformation:
</bodyText>
<equation confidence="0.996071666666667">
i2 = Transform(i1, t2)
= ِm hF HŒ hM ºَ hL Žَ
(AiF@—aMkaLra)
</equation>
<bodyText confidence="0.999866333333333">
To obtain the proper stem from the intermediate
template, the final intermediate template i2 may be
substituted into Equation 7:
</bodyText>
<equation confidence="0.982669">
Stem = Regexp(i2, p, null)
= •َ»َ HŒِm
(Ai@—akara)
</equation>
<bodyText confidence="0.998307714285714">
To summarise, the final output of Stem Trans-
former is a root moulded into a template and a
template-transformed radical set. These outputs
are used as input to the affxation phase which
succeeds stem transformation. Affxer, applied
iteratively to the product of Stem Transformer,
outputs 14 different subject-pronominally affxed
</bodyText>
<figureCaption confidence="0.997884">
Figure 3: The Affxer Phase
</figureCaption>
<bodyText confidence="0.988902733333333">
morphosyntactic forms for every input except
the imperative which only produces 5. There are
9 different tense-voice-mode combinations per
subject pronominal affx, so most roots produce 117
affxed stems per dictionary entry. Affxer is run
with different replace strings that are specific to the
type of affx being produced. It modifies copies of
the transformed stem from the previous phase, as in
Figure 3. Using the example cited shortly before,
Affxer is passed the last intermediate template im
and the affx regular expression a. In this example,
a is a regular expression that searches for hLrL and
replaces it with hLrLَ uْ (LrLato); this corresponds
to the past active third person feminine singular
affx.
</bodyText>
<equation confidence="0.96834125">
Now applying Equation 9 produces:
i3 = Transform(i2, a)
= ِmhF HŒhM ºَ hL Žَ ْu
(AiF@—aMkaLrato)
</equation>
<bodyText confidence="0.9996048">
In the last stage of stem generation, Slotter re-
places the place holders in the transformed template
with the transformed radical set, producing the final
form of the affxed stem. For the example, the result
of applying Equation 10 is:
</bodyText>
<equation confidence="0.9884285">
H
Regexp(i3, p, null) = ْu•َ »َŒ m
</equation>
<page confidence="0.481578">
ِ
</page>
<figure confidence="0.985432352941176">
(Ai@—akarato)
from Stem Transformer
F M L R
final final
template—string
template—string
Intermediate Word
Decompose
Compose
F M L R
Generic Intermediate
Stem Match
Transformed
Intermediate Stem
replace—string (affix)
Transform
Affixer
</figure>
<figureCaption confidence="0.999789">
Figure 4: The Slotter Phase
</figureCaption>
<sectionHeader confidence="0.972336" genericHeader="method">
5 Optimisation
</sectionHeader>
<bodyText confidence="0.997562458333333">
Data produced for the use of SG was designed
initially with no knowledge of the actual patterns
and repetitions that occur with morphophonemic
and affix transformation rules. In fact, SG is made
to create stems this way: A root is added to a
morphosemantic template, then morphosyntactic
templates are applied to it, inducing in some pat-
terns morphophonemic transformation. However,
while this may be useful in many language teaching
tools, it is extremely inefficient. The original data
was used to discover patterns that would allow
stems to be created in an optimal manner.
Following the classification in Yaghi (2004), there
are 70 verb root types associated with 44 theoreti-
cally possible morphological patterns. There is an
element of repetition present in the classification. In
addition, the Template table lists sequences of rules
that operate on morphological patterns in a manner
similar to how native speakers alter patterns phone-
mically. These rules could be composed into a sin-
gle FST that yields the surface form.
For example, in the previous section, the mor-
phophonemic transformation rule set T = {1,12}
could have been written into one rule. In its non-
optimised form the rule duplicates rF in place of
u (t) creating intermediate form ِm hF ْŒ َŒ hM ºَ hL Žَ
(AiF@o@aMkaLra) and then deletes the first of the
duplicate letters and replaces it with a gemination di-
acritic that is placed on the second repeat letter. The
resulting surface form is •َ»َ HŒِm(Ai@~akara). Instead,
one rule could achieve the surface form by replac-
ing the letter u (t) in the template with a geminated
Œ (@) yielding the same result.
Compiling separate regular expressions for each
transformation rule is costly in terms of processing
time especially when used with back-references, as
SG does. Back-references group a sub-pattern and
refer to it either in the search pattern or substitute
string. Such patterns are not constant and are re-
quired to be recompiled for every string they are
used with. It is desirable, therefore, to minimise the
number of times patterns are compiled. To optimise
further, the transformation may be made on the mor-
phological pattern itself, thus producing a sound sur-
face form template. This procedure would eliminate
the need to perform morphophonemic transforma-
tions on stems.
Each template entry in the Template table (see
Figure 1) is given a new field containing the surface
form template. This is a copy of the morphological
pattern with morphophonemic transformations ap-
plied. A coding scheme is adopted that continues
to retain letter origins and radical positions in the
template so that this will not affect affixation. Any
transformations that affect the morphological pat-
tern alone are applied without further consideration.
The coding scheme uses the Roman characters F, M,
L, and Q to represent place holders in the templates.
Each place holder is followed by a single digit in-
dicating the type of transformation that occurs to
the radical slotted in that position. The codes have
the following meanings: 0=no alteration, 1=dele-
tion, 2=substitution, 3=gemination. If the code used
is 2, then the very next letter is used to replace the
radical to which the code belongs.
Take for example, the Template table entry for the
root type 17 (all roots with F=× (w) and L=Ý (y)), its
morphological pattern ِm hFْ َuhMَ hLَ (AiFotaMaLa),
and its variant (ID 0). The morphophonemic
transformation rules applied to the template are
T={20,12,31,34,112}. These rules correspond to
the following:
</bodyText>
<listItem confidence="0.999247333333333">
• 20=change rF to a duplicate of the next letter
u (t)
• 12=geminate duplicate letters
• 31=delete diacritic after the Ý (y) in position hL
• 34=convert Ý (y) to m (A)
• 112=convert m to Ù (Y)
</listItem>
<figure confidence="0.969291882352941">
Affixed Word
from Affixer
F M L R
template_string
replace F literal with F value
replace M literal with M value
replace L literal with L value
replace R literal with R value
template_string
template_string
template_string
final
Transform
Transform
Transform
Transform
Slotter
</figure>
<table confidence="0.975683333333333">
Surface Form ِm rF2uH rM0َ rL2Ù (Ai F2t~a M0a L2Y)
Affix rLÝْ ُuÊَ m ( L2yotumaA)
Combined Result ِm rF2uH rM0َ rL2Ýْ ُuÊَ m (Ai F2t~a M0a L2yotumaA)
</table>
<tableCaption confidence="0.999871">
Table 1: Surface form template aligned with an affix entry rule.
</tableCaption>
<bodyText confidence="0.995395125">
The surface form template can be rewritten as
ِmhF2uH hMَ hL2Ù (AiF2t~aM0aL2Y). This can be
used to form stems such as Ùَ‹vHِm (Ait~adaY) by slot-
ting the root {×, Š, Ý} ({w,d,y}).
The affix tables use a similar notation for coding
their rules. Every affix rule indicates a change to be
made to the surface form template and begins with a
place holder followed by a code 0 or 2 unless the rule
redefines the entire template in which case the entry
begins with a 0. Radical place holders in affix rules
define changes to the surface form template. These
changes affect the template from the given radical
position to the very next radical position or the end
of the template, whichever is first.
Affix rules with code 0 following radical place
holders signify that no change should be made to
that section of the surface form template. However,
a code 2 after a place holder modifies the surface
form template in that position by replacing the letter
that follows the code with the rest of that segment of
the rule. Affix rules using code 2 after place holders
override any other code for that position in the sur-
face form template because affixation modifies mor-
phophonemically transformed stems.
Creating affixed stems from templates and
affixes formatted in this way becomes far more
optimal. If a surface form template was specified
as mrF2HurM0َrL2Ù (AiF2t~aM0aL2Y) and it
wasِto be combined with the affix rule rL2Ýْ ُu Êَ m
(L2yotumaA) then SG simply needs to align the
affix rule with the surface form template using the
place holder symbol in the affix rule and replace
appropriately as in Table 1.
With the resulting affixed surface form template
SG may retain the radicals of the original root where
they are unchanged, delete radicals marked with
code 1 and 3, and substitute letters following code
2 in place of their position holders. If the example
above is used with the root {×, Š, Ý} ({w, d, y}),
the final stem is: nÌَ wُÚْ ‹vHِm (Ait~adayotumaA, mean-
ing &amp;quot;the two of you have accepted compensation for
damage&amp;quot;).
To use the original regular expression transfor-
mations would take an average of 18000 seconds
to produce a total of 2.2 million valid stems in the
database. With the optimised coding scheme, the
time taken is reduced to a mere 720 seconds; that is
4% of the original time taken.
</bodyText>
<sectionHeader confidence="0.893654" genericHeader="method">
6 Generated Stem Database Compiler
</sectionHeader>
<figureCaption confidence="0.951495">
Figure 5: Output from the Stem Generation CGI
</figureCaption>
<bodyText confidence="0.99979705">
Once the dictionary database has been completed
and debugged, an implementation of SG generates
for every root, template, and affix the entire list of
stems derived from a single root and all the pos-
sible template and affix combinations that may ap-
ply to that root entry. The average number of dic-
tionary entries that a root can generate is approxi-
mately 2.5. Considering that each entry generates
117 different affixed stems, this yields an average of
approximately 300 affixed stems per root. However,
some roots (e.g., {º,u,o} ({k,t,b})) produce 13
different entries, which makes approximately 1,500
affixed stems for each of such roots.
The generated list is later loaded into a B-Tree
structured database file that allows fast stem search
and entry retrieval.
A web CGI was built that uses the Stem Genera-
tion Engine to produce all affixed stems of any given
root. A section of the results of this appears in Fig-
ure 5.
</bodyText>
<sectionHeader confidence="0.996909" genericHeader="conclusions">
7 Conclusions
</sectionHeader>
<bodyText confidence="0.999970019230769">
In this paper, we have discussed our attempt at imi-
tating the process used by Arabic speakers in gener-
ating stems from roots. We formulated a definition
of the process, facilitating an encoding of Arabic
stems. The encoding represents stems in terms of
their components while still allowing a simple map-
ping to their final surface forms. A stem’s compo-
nents are a root, morphosemantic and morphosyn-
tactic templates, and any morphophonemic alter-
ations that the stem may have underwent. In do-
ing so, the problem has been reduced to the much
smaller task of obtaining stems for the words sub-
ject to analysis, and then matching these against the
surface forms of the pre-analysed stems. The encod-
ing retains most of the information essential to stem
generation and analysis, allowing us to trace the var-
ious transformations that root radicals undergo when
inflected. Root extractors and morphological anal-
ysers can match an input word with a defined verb
stem, then use the information in the definition to de-
termine with certainty the stem’s root and morpho-
logical pattern’s meaning. The authors intend to use
a similar strategy to define stems for Arabic nouns.
Mapping from words to defined stems is now
much easier. The stem generation algorithm here
attempts to produce a comprehensive list of all
inflected stems. Any verb may be found in this
list if some simple conjoin removal rules are first
applied. Conjoins are defined here as single letter
conjunctions, future or question particles, emphasis
affixes, or object pronominal suffixes that aggluti-
nate to a verb stem. Because conjoins may attach
to a verb stem in sequence and without causing
any morphological alteration, extracting stems
from Arabic words becomes similar to extracting
stems from English words. In fact, many of the
Arabic word analysis approaches reviewed in the
introduction to this paper would yield more accurate
results if applied to stem extraction instead of root
extraction. It would become possible to use for this
purpose conventional linguistic, pattern matching,
or algebraic algorithms.
The dictionary database described here can be
used to form the core of a morphological analyser
that derives the root of an input word, identifies its
stem, and classifies its morphosemantic and mor-
phosyntactic templates. An analyser based on these
principles may be used in many useful applications,
some of which are detailed in Yaghi (2004). Exam-
ple applications include root, lemma based, and ex-
act word analysis, searching, incremental searching,
and concordancing.
</bodyText>
<sectionHeader confidence="0.993927" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.995571795918367">
S. S. Al-Fedaghi and F. S. Al-Anzi. 1989. A
New Algorithm to Generate Arabic Root-Pattern
Forms. In Proceedings of the 11th National Com-
puter Conference and Exhibition, pages 391–400,
Dhahran, Saudi Arabia, March.
Riyad Al-Shalabi and Martha Evens. 1998. A
Computational Morphology System for Arabic.
In Proceedings of the COLING/ACL98, pages
66–72, Montrɴeal, Quɴebec, Canada, August.
Kenneth R Beesley. 2001. Finite-State Morpho-
logical Analysis and Generation of Arabic at Xe-
rox Research: Status and Plans in 2001. In ARA-
BIC Language Processing: Status and Prospects,
Toulouse, France, July. Arabic NLP Workshop at
ACL/EACL 2001.
Mohammed A. El-Affendi. 1991. An Algebraic Al-
gorithm for Arabic Morphological Analysis. The
Arabian Journal for Science and Engineering,
16(4B).
Mohammed A. El-Affendi. 1999. Performing Ara-
bic Morphological Search on the Internet: A Slid-
ing Window Approximate Matching Algorithm
and its Performance. Technical report, CCIS Re-
port King Saud University.
Jeffery E. F. Friedl. 2002. Mastering Regular Ex-
pressions. O’Reilly, 2nd edition, July.
Lama Hamandi, Rached Zantout, and Ahmed Gues-
soum. 2002. Design and Implementation of an
Arabic Morphological Analysis System. In Pro-
ceedings of the International Conference on Re-
search Trends in Science and Technology 2002,
pages 325–331, Beirut, Lebanon.
Ibrahim Mustapha, Ahmed H. Al-Zayat, Hamid Ab-
delQadir, and Mohammed Ali Al-Najjar, editors.
1972. Al-Moajam Al-Waseet. Cairo Arab Lan-
guage Academy, Cairo, Egypt.
B. Thalouth and A. Al-Dannan. 1990. A Compre-
hensive Arabic Morphological Analyzer Genera-
tor. In Pierre Mackay, editor, Computers and the
Arabic Language. Hemisphere Publishing, New
York.
Jim Yaghi. 2004. Computational Arabic Verb Mor-
phology: Analysis and Generation. Master’s the-
sis, University of Auckland.
Sane M. Yagi and Saad Harous. 2003. Arabic Mor-
phology: An Algorithm and Statistics. In Pro-
ceedings of the 2003 International Conference on
Artificial Intelligence (IC-AI 2003), Las Vegas,
Nevada.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.000776">
<title confidence="0.999484">Verb Stem Generation for Arabic</title>
<author confidence="0.99594">Jim Yaghi Sane M Yagi</author>
<abstract confidence="0.987253433090025">of of jim@docrec.com saneyagi@yahoo.com Abstract and grammar checking in Arabic requires an efficient method for matching stems with roots and mapping is complicated by the of manifestations of the same algorithm based on the generation method used by speakers is proposed here to provide a from roots to roots are classified by the types of their radicals and the stems they are moulded with morphosemantic and morphosyntactic patterns to generate stems for affixed different subject The surface forms of applicable morphophonemic transformations are then derived using finite state paper defines what is meant by a stem generation engine that the outlines how a generated database is compiled for all Arabic Morphological parsers and analysers for Arabic are required to dissect an input word and analyse its components in order to perform even the simplest language processing letters of the majority of Arabic words undergo transformations their roots the is difficult to identify a is necessary for pinpointing its morphosyntactic essential for realising properties of the as its its is fundamental that an analyser be able to reverse the transformations a word undergoes in order to match the separated root and template with the untransformed ones in its rules to reverse is not authors wish to thank the anonymous reviewers of this as their suggestions have improved it in Arabic morphology has primarily cused on morphological analysis rather than stem window algorithms 1999) use an approximate string matching approach of words against lists of 1991), the other assign binary values to morphological patterns and perform some simple algebraic operations to decompose a word into a stem and algorithms and 1998) the input letters to generate all possible trilateral or quadrilateral sequences without violation of the original order of the letters which is then compared with items in a dictionary of until a match is algorithms and 1990; and letters from an input word that belong to prefixes and suffixes and place the remainder the word into a members of this list are then tested for a match with a dictionary of primary drawback of many of these is that they attempt to analyse using the found in the letters of the input form letters are often transformed positions are lost between stem and affix attempts use various closest match introduce a high level of this define Arabic verb stems such that are formally stems are this words can be mapped to stem that transformations root radicals rather than estimate Morphological transformation in our definition is largely built around finite state morphology 2001) assumes that these formations can be represented in terms of regular between regular language finite state transducers to encode the between the transformation rules that account for phenomena such as this description of the database for stem generation is by definition of stem the database together with the definition are used to implement a generation is followed by a for optimising stem database of generated stems is compiled in a format to various applications that the conclusion the course of this are represented in terms of their ordered sequence of three or four in a set capitalised Roman characters Q represent a radical variable or place stand for First Radical Radical in a trilateral root Radical in a quadrilateral root Arabic script used here is lowed by an orthographic transliteration between the Buckwalter orthographic transliteration provides a character mapping from Arabic to the exception of a few transliteration scheme attempts to match sounds of the Roman letters to the Arabic The following list is a subset of the less obvious used cs Generation Database root id F M L R TemplateList string id string stem generation database tables and complete table of orthographic transliteration may be at Arabic stems can be generated if lists of all roots all morphological patterns are is necessary that this data be coupled with a database that links the roots with their morphological patterns that only valid stems are for each roots in this database may moulded with morphosemantic and patterns to generate intermediate form The stems may then be transformed into final surface forms with a number of specific morphophonemic using a finite state transducer compiling a summary of the stem generation and their all verb roots from the popular Arabic et 1972), Q representing the table fields for up to four per root identifier is used to link table to the all morphosemantic and morphosyntactic terns used to generate stems from roots of a certain table also specifies the syntactic of stems and by using the links the together and specifies entries apply to which Stems generated with these tables are unaffixed id links each entry to a subject pronominal affix table that uses transformation rules affixed object affixes are not dealt with in this are generally agglutinating in nature and therefore cause morphophonemic alterations to a can be added for generation or removed for analysis affecting the stem at Affixation and transformation rules are both using PERL regular expressions expressions an braic language that is used for building finite state accept regular next is used to perform phonemic transformations and to generate affixed of generated stems are to be useful root extraction and morphological is essential at every stage of generation to be able to track exactly which letters are members of the root belong to the what transformations occur on the untransformed stem the final surface of Stem Generation order to be useful in analysis stems need to be in a surface form which will only agglutinating changes for any further RootsList MainDictionary stem id id id Template entry id TemplatesList-&gt;string_id RootType Pattern Variant Voice Tense Transform-&gt;transform_id Affixes-&gt;affix_id should be defined in of the root and template morphophonemic doing stem becomes require the automatic stem generator to always be aware of the origin of each of letters in stems it generates and to be able to tinguish between letters in the original radical set or the template stem generator may then be used to compile a complete list of all affixed stems database roots while retaining all resulting list of stems may then be turned into a searchable index that holds the complete morphological analysis and classification each originally Arabic words can have a of four root root radical set defined in terms of the ordered letters of the root as the tense ids identify a particular morphological pattern are used to generate a stem from a text of defined in terms of the letters and of the template in sequence the position markers or place holders indicate the positions that letters the root should be slotted (2) Generator regular expressions as language for compiling FSTs for rules take into account the context of root radicals in terms of their in the template and the nature of the letters that surround performed using combinations of regular rules applied in a manner similar to how humans are subconsciously trained to process individual resulting plate between one morphophonemic transformation the next is an intermediate order to aid the next formed radicals are marked by inserting their place before an intermediate template formed the root radical set the morphological pattern create the initial intermediate template radical set morphological pattern SrchPat, to compile FSTs from regular The function accepts in its first argument a string that is tested for a match with the search pattern its second matching characters in with the replace string function is assumed to accept the standard PERL expression the radical set morphological pattern compile the first intermediate template expression is built to make this searches the morphological pattern text for radical place holders and inserts their respective values after instead of each marker with itself followed by its radical value is effectively equivalent to inserting its radical value a search pattern that matches all of place holders the morphological an initial form be compiled in the following p, (3) the transformation rules on each intermediate template to create intermediate rules defined second function required to subsequent template the recursive result of the current intermediate template the next transformation is defined for 0 &lt; m (5) any point in the transformation transformed state of radicals string be decomposed from the current template as = turn final intermediate template into a regular expression is built that deletes the place holders from the intermediate do this with a regular place holders matched are replaced with the null during the matching process as p, stems are only modified for tense and Additional morphosyntactic templates or affixation further modify proper stems for rules are expressions like transformation these rules modify final intermediate templates by modifying or stem require knowledge of radical positions and occasionally their affixes to a stem operates the intermediate template which retains the the affixation rule that is being applied to certain intermediate using the function was are added to to produce intermediate affixed template SrchPat, (9) convert for output an affixed remove place holders using the p, this stems are by intermediate templates retain knowledge of the current state of and radical letters without losing the to recall their would avoid guesswork in the identification of root stem generation and analysis are both facilitated by this feature of Generation Engine stem generation engine may be built on the of the definition just three in up Transformer applies the appropriate transformation rules to the specific affixes the transformed the to the transformed affixed template to the final affixed begins with a stem ID from the as input to Transformer root and entry associated with the stem are used to identify the radicals of the pattern list of transformation an affix table Transformer Transformer transformation rules that are localised to the root radicals and letters the template in the contexts of one the template and root for begins by marking radicals in the Transformer applied incrementally using current radical template one rule per in Figure put of each pass is fed back into Stem Transformer in form of the template string with the transformation all rules associated with the template are resultant template string and radicals output to the next the morphological pattern radical set the transformation rule template_string when i&lt;n F M L R final when i=n template_string Intermediate Stem Decompose Compose F M L R final when i=n replace_string i=0 ...n i transform_rule th Intermediate Stem Transform Stem Transformer search_pattern Stem Transformer generates a proper stem using following creates the initial intermediate when passed the radical set and CompileIntermediate(R, s) first transformation rule 1, a expression that searches for a replaces a copy of rule gemination rule 12, applied gemination regular expression searches an unvowelled letter followed by a vowelled plicate and replaces it with the geminated vowelled used to make the To obtain the proper stem from the intermediate final intermediate template be into Equation = p, null) final output of Stem former is a root moulded into a template and a radical outputs are used as input to the affxation phase which stem to the product of Stem affxed Affxer Phase morphosyntactic forms for every input except imperative which only produces are combinations per pronominal most roots produce stems per dictionary is run with different replace strings that are specific to the of affx being modifies copies of transformed stem from the previous in the example cited shortly is passed the last intermediate template the affx regular expression this a regular expression that searches for it with corresponds to the past active third person feminine singular applying Equation a) the last stage of stem places the place holders in the transformed template the transformed radical the final of the affxed the result applying Equation H p, null) = »َŒ m ِ</abstract>
<title confidence="0.625084642857143">from Stem Transformer F M L R final final Intermediate Word Decompose Compose F M L R Generic Intermediate Stem Match Intermediate Stem (affix) Transform Affixer Slotter Phase</title>
<abstract confidence="0.976657405940594">Data produced for the use of SG was designed initially with no knowledge of the actual patterns and repetitions that occur with morphophonemic affix transformation is made create stems this root is added to a morphosyntactic are applied to in some morphophonemic while this may be useful in many language teaching is extremely original data was used to discover patterns that would allow to be created in an optimal the classification in Yaghi root types associated with possible morphological is an of repetition present in the lists sequences of rules that operate on morphological patterns in a manner to how native speakers alter patterns rules could be composed into a FST that yields the surface the previous transformation rule set have been written into one its form the rule duplicates place of intermediate form َŒ then deletes the first of the letters and replaces it with a gemination that is placed on the second repeat surface form is rule could achieve the surface form by the letter the template with a geminated the same Compiling separate regular expressions for each transformation rule is costly in terms of processing especially when used with group a and refer to it either in the search pattern or substitute patterns are not constant and are quired to be recompiled for every string they are is minimise the of times patterns are optimise transformation may be made on the pattern producing a sound form procedure would eliminate need to perform morphophonemic on template entry in the given a new field containing the surface is a copy of the morphological with morphophonemic transformations coding scheme is adopted that continues to retain letter origins and radical positions in the so that this will not affect that affect the morphological alone are applied without further coding scheme uses the Roman characters Q to represent place holders in the place holder is followed by a single digit dicating the type of transformation that occurs to radical slotted in that codes have following the code used the very next letter is used to replace the to which the code for entry for the type roots with pattern its variant morphophonemic transformation rules applied to the template are rules correspond to • a duplicate of the next letter • duplicate letters • diacritic after the Ý position • Ý • Ù Affixed Word from Affixer F M L R template_string replace F literal with F value replace M literal with M value replace L literal with L value replace R literal with R value template_string template_string template_string final Transform Transform Transform Transform Slotter Surface Form m ( Affix Combined Result m form template aligned with an affix entry The surface form template can be rewritten as can be to form stems such as the root The affix tables use a similar notation for coding affix rule indicates a change to be made to the surface form template and begins with a holder followed by a code the rule redefines the entire template in which case the entry with a place holders in affix rules changes to the surface form changes affect the template from the given radical position to the very next radical position or the end the is rules with code radical place holders signify that no change should be made to section of the surface form code a place holder modifies the surface form template in that position by replacing the letter that follows the code with the rest of that segment of rules using code place holders any other code for that position in the form template because affixation modifies transformed Creating affixed stems from templates and affixes formatted in this way becomes far more a surface form template was specified it be combined with the affix rule m SG simply needs to align the affix rule with the surface form template using the place holder symbol in the affix rule and replace as in Table With the resulting affixed surface form template SG may retain the radicals of the original root where are radicals marked with substitute letters following code place of their position the example is used with the root final stem two of you have accepted compensation for use the original regular expression would take an average of produce a total of valid stems in the the optimised coding taken is reduced to a mere is the original time Stem Database Compiler from the Stem Generation CGI Once the dictionary database has been completed implementation of SG generates every affix the entire list of derived from a single root and all the template and affix combinations that may to that root average number of entries that a root can generate is that each entry generates affixed yields an average of stems per roots makes approximately stems for each of such generated list is later loaded into a structured database file that allows fast stem search entry web CGI was built that uses the Stem tion Engine to produce all affixed stems of any given section of the results of this appears in this have discussed our attempt at the process used by Arabic speakers in stems from formulated a definition the an encoding of Arabic encoding represents stems in terms of components while still allowing a simple to their final surface are a and any morphophonemic that the stem may have problem has been reduced to the much task of obtaining stems for the words to then matching these against the forms of the ing retains most of the information essential to stem and us to trace the ious transformations that root radicals undergo when extractors and morphological ysers can match an input word with a defined verb use the information in the definition to with certainty the root and authors intend to use similar strategy to define stems for Arabic Mapping from words to defined stems is now stem generation algorithm here attempts to produce a comprehensive list of all verb may be found in this list if some simple conjoin removal rules are first are defined here as single letter or question object pronominal suffixes that to a verb conjoins may attach to a verb stem in sequence and without causing morphological stems from Arabic words becomes similar to extracting from English of the Arabic word analysis approaches reviewed in the</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>S S Al-Fedaghi</author>
<author>F S Al-Anzi</author>
</authors>
<title>A New Algorithm to Generate Arabic Root-Pattern Forms.</title>
<date>1989</date>
<booktitle>In Proceedings of the 11th National Computer Conference and Exhibition,</booktitle>
<pages>391--400</pages>
<location>Dhahran, Saudi Arabia,</location>
<marker>Al-Fedaghi, Al-Anzi, 1989</marker>
<rawString>S. S. Al-Fedaghi and F. S. Al-Anzi. 1989. A New Algorithm to Generate Arabic Root-Pattern Forms. In Proceedings of the 11th National Computer Conference and Exhibition, pages 391–400, Dhahran, Saudi Arabia, March.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Riyad Al-Shalabi</author>
<author>Martha Evens</author>
</authors>
<title>A Computational Morphology System for Arabic.</title>
<date>1998</date>
<booktitle>In Proceedings of the COLING/ACL98,</booktitle>
<pages>66--72</pages>
<location>Montrɴeal, Quɴebec, Canada,</location>
<contexts>
<context position="2688" citStr="Al-Shalabi and Evens, 1998" startWordPosition="397" endWordPosition="400">eviewers of this article as their suggestions have improved it significantly. Research in Arabic morphology has primarily focused on morphological analysis rather than stem generation. Sliding window algorithms (El-Affendi, 1999) use an approximate string matching approach of input words against lists of roots, morphological patterns, prefixes, and suffixes. Algebraic algorithms (El-Affendi, 1991), on the other hand, assign binary values to morphological patterns and input words, then perform some simple algebraic operations to decompose a word into a stem and affixes. Permutation algorithms (Al-Shalabi and Evens, 1998) use the input word’s letters to generate all possible trilateral or quadrilateral sequences without violation of the original order of the letters which is then compared with items in a dictionary of roots until a match is found. Linguistic algorithms (Thalouth and Al-Dannan, 1990; Yagi and Harous, 2003) remove letters from an input word that belong to prefixes and suffixes and place the remainder of the word into a list. The members of this list are then tested for a match with a dictionary of morphological patterns. The primary drawback of many of these techniques is that they attempt to an</context>
</contexts>
<marker>Al-Shalabi, Evens, 1998</marker>
<rawString>Riyad Al-Shalabi and Martha Evens. 1998. A Computational Morphology System for Arabic. In Proceedings of the COLING/ACL98, pages 66–72, Montrɴeal, Quɴebec, Canada, August.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth R Beesley</author>
</authors>
<title>Finite-State Morphological Analysis and Generation of Arabic at Xerox Research: Status and Plans in</title>
<date>2001</date>
<booktitle>In ARABIC Language Processing: Status and Prospects,</booktitle>
<location>Toulouse, France,</location>
<contexts>
<context position="4031" citStr="Beesley, 2001" startWordPosition="614" endWordPosition="615">replacement, fusion, inversion, or deletion, and their positions are lost between stem and affix letters. Most attempts use various closest match algorithms, which introduce a high level of uncertainty. In this paper, we define Arabic verb stems such that root radicals, morphological patterns, and transformations are formally specified. When stems are defined this way, input words can be mapped to correct stem definitions, ensuring that transformations match root radicals rather than estimate them. Morphological transformation in our definition is largely built around finite state morphology (Beesley, 2001) which assumes that these transformations can be represented in terms of regular relations between regular language forms. Beesley (2001) uses finite state transducers to encode the intersection between roots, morphological patterns, and the transformation rules that account for morphophonemic phenomena such as assimilation, deletion, epenthesis, metathesis, etc. In this paper, a description of the database required for stem generation is presented, followed by a definition of stem generation. Then the database together with the definition are used to implement a stem generation engine. This i</context>
</contexts>
<marker>Beesley, 2001</marker>
<rawString>Kenneth R Beesley. 2001. Finite-State Morphological Analysis and Generation of Arabic at Xerox Research: Status and Plans in 2001. In ARABIC Language Processing: Status and Prospects, Toulouse, France, July. Arabic NLP Workshop at ACL/EACL 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mohammed A El-Affendi</author>
</authors>
<title>An Algebraic Algorithm for Arabic Morphological Analysis. The Arabian Journal for Science and Engineering,</title>
<date>1991</date>
<contexts>
<context position="2461" citStr="El-Affendi, 1991" startWordPosition="365" endWordPosition="366">ergoes in order to match the separated root and template with the untransformed ones in its database. Unfortunately, defining rules to reverse transformations is not simple. ∗ The authors wish to thank the anonymous reviewers of this article as their suggestions have improved it significantly. Research in Arabic morphology has primarily focused on morphological analysis rather than stem generation. Sliding window algorithms (El-Affendi, 1999) use an approximate string matching approach of input words against lists of roots, morphological patterns, prefixes, and suffixes. Algebraic algorithms (El-Affendi, 1991), on the other hand, assign binary values to morphological patterns and input words, then perform some simple algebraic operations to decompose a word into a stem and affixes. Permutation algorithms (Al-Shalabi and Evens, 1998) use the input word’s letters to generate all possible trilateral or quadrilateral sequences without violation of the original order of the letters which is then compared with items in a dictionary of roots until a match is found. Linguistic algorithms (Thalouth and Al-Dannan, 1990; Yagi and Harous, 2003) remove letters from an input word that belong to prefixes and suff</context>
</contexts>
<marker>El-Affendi, 1991</marker>
<rawString>Mohammed A. El-Affendi. 1991. An Algebraic Algorithm for Arabic Morphological Analysis. The Arabian Journal for Science and Engineering, 16(4B).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mohammed A El-Affendi</author>
</authors>
<title>Performing Arabic Morphological Search on the Internet: A Sliding Window Approximate Matching Algorithm and its Performance.</title>
<date>1999</date>
<tech>Technical report, CCIS Report</tech>
<institution>King Saud University.</institution>
<contexts>
<context position="2290" citStr="El-Affendi, 1999" startWordPosition="342" endWordPosition="343">erb, such as its tense, voice, and mode, and its subject’s number, gender, and person. It is fundamental that an analyser be able to reverse the transformations a word undergoes in order to match the separated root and template with the untransformed ones in its database. Unfortunately, defining rules to reverse transformations is not simple. ∗ The authors wish to thank the anonymous reviewers of this article as their suggestions have improved it significantly. Research in Arabic morphology has primarily focused on morphological analysis rather than stem generation. Sliding window algorithms (El-Affendi, 1999) use an approximate string matching approach of input words against lists of roots, morphological patterns, prefixes, and suffixes. Algebraic algorithms (El-Affendi, 1991), on the other hand, assign binary values to morphological patterns and input words, then perform some simple algebraic operations to decompose a word into a stem and affixes. Permutation algorithms (Al-Shalabi and Evens, 1998) use the input word’s letters to generate all possible trilateral or quadrilateral sequences without violation of the original order of the letters which is then compared with items in a dictionary of r</context>
</contexts>
<marker>El-Affendi, 1999</marker>
<rawString>Mohammed A. El-Affendi. 1999. Performing Arabic Morphological Search on the Internet: A Sliding Window Approximate Matching Algorithm and its Performance. Technical report, CCIS Report King Saud University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jeffery E F Friedl</author>
</authors>
<title>Mastering Regular Expressions.</title>
<date>2002</date>
<note>O’Reilly, 2nd edition,</note>
<contexts>
<context position="7823" citStr="Friedl, 2002" startWordPosition="1218" endWordPosition="1219">bles together and specifies which entries apply to which roots. Stems generated with these tables are unaffixed stems. The affix id field links each entry to a subject pronominal affix table that uses transformation rules generating affixed stems. Although object pronominal affixes are not dealt with in this paper, they are generally agglutinating in nature and therefore cause no morphophonemic alterations to a stem. They can be added for generation or removed for analysis without affecting the stem at all. Affixation and transformation rules are both specified using PERL regular expressions (Friedl, 2002). Regular expressions (Regexp) is an algebraic language that is used for building finite state transducers (FSTs) that accept regular languages. In the next section, Regexp is used to perform morphophonemic transformations and to generate affixed forms of stems. If generated stems are to be useful for root extraction and morphological analysis, it is essential at every stage of generation to be able to track exactly which letters are members of the root radical set, which belong to the template, and what transformations occur on the untransformed stem producing the final surface form. 3 Defini</context>
</contexts>
<marker>Friedl, 2002</marker>
<rawString>Jeffery E. F. Friedl. 2002. Mastering Regular Expressions. O’Reilly, 2nd edition, July.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lama Hamandi</author>
<author>Rached Zantout</author>
<author>Ahmed Guessoum</author>
</authors>
<title>Design and Implementation of an Arabic Morphological Analysis System.</title>
<date>2002</date>
<booktitle>In Proceedings of the International Conference on Research Trends in Science and Technology</booktitle>
<pages>325--331</pages>
<location>Beirut, Lebanon.</location>
<marker>Hamandi, Zantout, Guessoum, 2002</marker>
<rawString>Lama Hamandi, Rached Zantout, and Ahmed Guessoum. 2002. Design and Implementation of an Arabic Morphological Analysis System. In Proceedings of the International Conference on Research Trends in Science and Technology 2002, pages 325–331, Beirut, Lebanon.</rawString>
</citation>
<citation valid="true">
<title>Al-Moajam Al-Waseet. Cairo Arab Language Academy,</title>
<date>1972</date>
<editor>Ibrahim Mustapha, Ahmed H. Al-Zayat, Hamid AbdelQadir, and Mohammed Ali Al-Najjar, editors.</editor>
<location>Cairo, Egypt.</location>
<marker>1972</marker>
<rawString>Ibrahim Mustapha, Ahmed H. Al-Zayat, Hamid AbdelQadir, and Mohammed Ali Al-Najjar, editors. 1972. Al-Moajam Al-Waseet. Cairo Arab Language Academy, Cairo, Egypt.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Thalouth</author>
<author>A Al-Dannan</author>
</authors>
<title>A Comprehensive Arabic Morphological Analyzer Generator.</title>
<date>1990</date>
<booktitle>In Pierre Mackay, editor, Computers and the Arabic Language.</booktitle>
<publisher>Hemisphere Publishing,</publisher>
<location>New York.</location>
<contexts>
<context position="2970" citStr="Thalouth and Al-Dannan, 1990" startWordPosition="441" endWordPosition="444">t words against lists of roots, morphological patterns, prefixes, and suffixes. Algebraic algorithms (El-Affendi, 1991), on the other hand, assign binary values to morphological patterns and input words, then perform some simple algebraic operations to decompose a word into a stem and affixes. Permutation algorithms (Al-Shalabi and Evens, 1998) use the input word’s letters to generate all possible trilateral or quadrilateral sequences without violation of the original order of the letters which is then compared with items in a dictionary of roots until a match is found. Linguistic algorithms (Thalouth and Al-Dannan, 1990; Yagi and Harous, 2003) remove letters from an input word that belong to prefixes and suffixes and place the remainder of the word into a list. The members of this list are then tested for a match with a dictionary of morphological patterns. The primary drawback of many of these techniques is that they attempt to analyse using the information found in the letters of the input word. When roots form words, root letters are often transformed by replacement, fusion, inversion, or deletion, and their positions are lost between stem and affix letters. Most attempts use various closest match algorit</context>
</contexts>
<marker>Thalouth, Al-Dannan, 1990</marker>
<rawString>B. Thalouth and A. Al-Dannan. 1990. A Comprehensive Arabic Morphological Analyzer Generator. In Pierre Mackay, editor, Computers and the Arabic Language. Hemisphere Publishing, New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jim Yaghi</author>
</authors>
<title>Computational Arabic Verb Morphology: Analysis and Generation. Master’s thesis,</title>
<date>2004</date>
<institution>University of Auckland.</institution>
<contexts>
<context position="20193" citStr="Yaghi (2004)" startWordPosition="3194" endWordPosition="3195">uced for the use of SG was designed initially with no knowledge of the actual patterns and repetitions that occur with morphophonemic and affix transformation rules. In fact, SG is made to create stems this way: A root is added to a morphosemantic template, then morphosyntactic templates are applied to it, inducing in some patterns morphophonemic transformation. However, while this may be useful in many language teaching tools, it is extremely inefficient. The original data was used to discover patterns that would allow stems to be created in an optimal manner. Following the classification in Yaghi (2004), there are 70 verb root types associated with 44 theoretically possible morphological patterns. There is an element of repetition present in the classification. In addition, the Template table lists sequences of rules that operate on morphological patterns in a manner similar to how native speakers alter patterns phonemically. These rules could be composed into a single FST that yields the surface form. For example, in the previous section, the morphophonemic transformation rule set T = {1,12} could have been written into one rule. In its nonoptimised form the rule duplicates rF in place of u</context>
</contexts>
<marker>Yaghi, 2004</marker>
<rawString>Jim Yaghi. 2004. Computational Arabic Verb Morphology: Analysis and Generation. Master’s thesis, University of Auckland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Sane M Yagi</author>
<author>Saad Harous</author>
</authors>
<title>Arabic Morphology: An Algorithm and Statistics.</title>
<date>2003</date>
<booktitle>In Proceedings of the 2003 International Conference on Artificial Intelligence (IC-AI</booktitle>
<location>Las Vegas, Nevada.</location>
<contexts>
<context position="2994" citStr="Yagi and Harous, 2003" startWordPosition="445" endWordPosition="448">, morphological patterns, prefixes, and suffixes. Algebraic algorithms (El-Affendi, 1991), on the other hand, assign binary values to morphological patterns and input words, then perform some simple algebraic operations to decompose a word into a stem and affixes. Permutation algorithms (Al-Shalabi and Evens, 1998) use the input word’s letters to generate all possible trilateral or quadrilateral sequences without violation of the original order of the letters which is then compared with items in a dictionary of roots until a match is found. Linguistic algorithms (Thalouth and Al-Dannan, 1990; Yagi and Harous, 2003) remove letters from an input word that belong to prefixes and suffixes and place the remainder of the word into a list. The members of this list are then tested for a match with a dictionary of morphological patterns. The primary drawback of many of these techniques is that they attempt to analyse using the information found in the letters of the input word. When roots form words, root letters are often transformed by replacement, fusion, inversion, or deletion, and their positions are lost between stem and affix letters. Most attempts use various closest match algorithms, which introduce a h</context>
</contexts>
<marker>Yagi, Harous, 2003</marker>
<rawString>Sane M. Yagi and Saad Harous. 2003. Arabic Morphology: An Algorithm and Statistics. In Proceedings of the 2003 International Conference on Artificial Intelligence (IC-AI 2003), Las Vegas, Nevada.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>