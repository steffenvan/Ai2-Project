<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000009">
<title confidence="0.9961445">
TuLiPA: Towards a Multi-Formalism Parsing Environment for
Grammar Engineering
</title>
<author confidence="0.823196">
Laura Kallmeyer Timm Lichte Wolfgang Maier
</author>
<address confidence="0.767285666666667">
SFB 441 SFB 441 SFB 441
Universit¨at T¨ubingen Universit¨at T¨ubingen Universit¨at T¨ubingen
D-72074, T¨ubingen, Germany D-72074, T¨ubingen, Germany D-72074, T¨ubingen, Germany
</address>
<email confidence="0.971205">
lk@sfs.uni-tuebingen.de timm.lichte@uni-tuebingen.de wo.maier@uni-tuebingen.de
</email>
<author confidence="0.913753">
Yannick Parmentier
</author>
<affiliation confidence="0.505785">
CNRS - LORIA
</affiliation>
<address confidence="0.663927">
Nancy Universit´e
F-54506, Vandœuvre, France
</address>
<email confidence="0.992982">
parmenti@loria.fr
</email>
<author confidence="0.799208">
Johannes Dellert
</author>
<address confidence="0.471676571428571">
SFB 441 - SfS
Universit¨at T¨ubingen
D-72074, T¨ubingen, Germany
Kilian Evang
SFB 441 - SfS
Universit¨at T¨ubingen
D-72074, T¨ubingen, Germany
</address>
<email confidence="0.994085">
{jdellert,kevang}@sfs.uni-tuebingen.de
</email>
<sectionHeader confidence="0.995548" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9937915">
In this paper, we present an open-source
parsing environment (T¨ubingen Linguistic
Parsing Architecture, TuLiPA) which uses
Range Concatenation Grammar (RCG)
as a pivot formalism, thus opening the
way to the parsing of several mildly
context-sensitive formalisms. This en-
vironment currently supports tree-based
grammars (namely Tree-Adjoining Gram-
mars (TAG) and Multi-Component Tree-
Adjoining Grammars with Tree Tuples
(TT-MCTAG)) and allows computation not
only of syntactic structures, but also of the
corresponding semantic representations. It
is used for the development of a tree-based
grammar for German.
</bodyText>
<sectionHeader confidence="0.99895" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999899461538462">
Grammars and lexicons represent important lin-
guistic resources for many NLP applications,
among which one may cite dialog systems, auto-
matic summarization or machine translation. De-
veloping such resources is known to be a complex
task that needs useful tools such as parsers and
generators (Erbach, 1992).
Furthermore, there is a lack of a common frame-
work allowing for multi-formalism grammar engi-
neering. Thus, many formalisms have been pro-
posed to model natural language, each coming
with specific implementations. Having a com-
mon framework would facilitate the comparison
</bodyText>
<note confidence="0.723346">
© 2008. Licensed under the Creative Commons
</note>
<footnote confidence="0.967403">
Attribution-Noncommercial-Share Alike 3.0 Unported li-
cense (http://creativecommons.org/licenses/by-nc-sa/3.0/).
Some rights reserved.
</footnote>
<bodyText confidence="0.999627419354839">
between formalisms (e.g., in terms of parsing com-
plexity in practice), and would allow for a better
sharing of resources (e.g., having a common lex-
icon, from which different features would be ex-
tracted depending on the target formalism).
In this context, we present a parsing environ-
ment relying on a general architecture that can
be used for parsing with mildly context-sensitive
(MCS) formalisms1 (Joshi, 1987). Its underly-
ing idea is to use Range Concatenation Grammar
(RCG) as a pivot formalism, for RCG has been
shown to strictly include MCS languages while be-
ing parsable in polynomial time (Boullier, 2000).
Currently, this architecture supports tree-based
grammars (Tree-Adjoining Grammars and Multi-
Component Tree-Adjoining Grammars with Tree
Tuples (Lichte, 2007)). More precisely, tree-
based grammars are first converted into equivalent
RCGs, which are then used for parsing. The result
of RCG parsing is finally interpreted to extract a
derivation structure for the input grammar, as well
as to perform additional processings (e.g., seman-
tic calculus, extraction of dependency views).
The paper is structured as follows. In section 2,
we present the architecture of the TuLiPA parsing
environment and show how the use of RCG as a
pivot formalism makes it easier to design a modu-
lar system that can be extended to support several
dimensions (syntax, semantics) and/or formalisms.
In section 3, we give some desiderata for gram-
mar engineering and present TuLiPA’s current state
</bodyText>
<footnote confidence="0.998052714285714">
1A formalism is said to be mildly context sensitive (MCS)
iff (i) it generates limited cross-serial dependencies, (ii) it is
polynomially parsable, and (iii) the string languages gener-
ated by the formalism have the constant growth property (e.g.,
{a294|n ≥ 0} does not have this property). Examples of MCS
formalisms include Tree-Adjoining Grammars, Combinatory
Categorial Grammars and Linear Indexed Grammars.
</footnote>
<page confidence="0.500898">
1
</page>
<note confidence="0.8560105">
Coling 2008: Proceedings of the workshop on Grammar Engineering Across Frameworks, pages 1–8
Manchester, August 2008
</note>
<bodyText confidence="0.9999254">
with respect to these. In section 4, we compare
this system with existing approaches for parsing
and more generally for grammar engineering. Fi-
nally, in section 5, we conclude by presenting fu-
ture work.
</bodyText>
<sectionHeader confidence="0.842369" genericHeader="introduction">
2 Range Concatenation Grammar as a
pivot formalism
</sectionHeader>
<bodyText confidence="0.981135">
The main idea underlying TuLiPA is to use RCG
as a pivot formalism for RCG has appealing for-
mal properties (e.g., a generative capacity lying be-
yond Linear Context Free Rewriting Systems and
a polynomial parsing complexity) and there ex-
ist efficient algorithms, for RCG parsing (Boullier,
2000) and for grammar transformation into RCG
(Boullier, 1998; Boullier, 1999).
Parsing with TuLiPA is thus a 3-step process:
</bodyText>
<listItem confidence="0.9796713">
1. The input tree-based grammar is converted
into an RCG (using the algorithm of
Kallmeyer and Parmentier (2008) when deal-
ing with TT-MCTAG).
2. The resulting RCG is used for parsing the in-
put string using an extension of the parsing
algorithm of Boullier (2000).
3. The RCG derivation structure is interpreted to
extract the derivation and derived trees with
respect to the input grammar.
</listItem>
<bodyText confidence="0.9996628">
The use of RCG as a pivot formalism, and thus
of an RCG parser as a core component of the sys-
tem, leads to a modular architecture. In turns, this
makes TuLiPA more easily extensible, either in
terms of functionalities, or in terms of formalisms.
</bodyText>
<subsectionHeader confidence="0.9689325">
2.1 Adding functionalities to the parsing
environment
</subsectionHeader>
<bodyText confidence="0.999952">
As an illustration of TuLiPA’s extensibility, one
may consider two extensions applied to the system
recently.
First, a semantic calculus using the syn-
tax/semantics interface for TAG proposed by Gar-
dent and Kallmeyer (2003) has been added. This
interface associates each tree with flat semantic
formulas. The arguments of these formulas are
unification variables, which are co-indexed with
features labelling the nodes of the syntactic tree.
During classical TAG derivation, trees are com-
bined, triggering unifications of the feature struc-
tures labelling nodes. As a result of these unifica-
tions, the arguments of the semantic formulas are
unified (see Fig. 1).
</bodyText>
<equation confidence="0.915668833333333">
S
NP↓- VP
NPS V NP↓y NP,
John loves Mary
name(j,john) love(t,y) name(m,mary)
❀ love(j,m),name(j,john),name(m,mary)
</equation>
<figureCaption confidence="0.9588105">
Figure 1: Semantic calculus in Feature-Based
TAG.
</figureCaption>
<bodyText confidence="0.999962275">
In our system, the semantic support has been in-
tegrated by (i) extending the internal tree objects to
include semantic formulas (the RCG-conversion is
kept unchanged), and (ii) extending the construc-
tion of the derived tree (step 3) so that during the
interpretation of the RCG derivation in terms of
tree combinations, the semantic formulas are car-
ried and updated with respect to the feature unifi-
cations performed.
Secondly, let us consider lexical disambigua-
tion. Because of the high redundancy lying within
lexicalized formalisms such as lexicalized TAG,
it is common to consider tree schemata having a
frontier node marked for anchoring (i.e., lexical-
ization). At parsing time, the tree schemata are
anchored according to the input string. This an-
choring selects a subgrammar supposed to cover
the input string. Unfortunately, this subgrammar
may contain many trees that either do not lead to
a parse or for which we know a priori that they
cannot be combined within the same derivation
(so we should not predict a derivation from one
of these trees to another during parsing). As a re-
sult, the parser could have poor performance be-
cause of the many derivation paths that have to
be explored. Bonfante et al. (2004) proposed to
polarize the structures of the grammar, and to ap-
ply an automaton-based filtering of the compatible
structures. The idea is the following. One compute
polarities representing the needs/resources brought
by a given tree (or tree tuple for TT-MCTAG).
A substitution or foot node with category NP re-
flects a need for an NP (written NP-). In the same
way, an NP root node reflects a resource of type
NP (written NP+). Then you build an automaton
whose edges correspond to trees, and states to po-
larities brought by trees along the path. The au-
tomaton is then traversed to extract all paths lead-
ing to a final state with a neutral polarity for each
category and +1 for the axiom (see Fig. 2, the state
</bodyText>
<page confidence="0.997246">
2
</page>
<figure confidence="0.99693575">
trans.
proper.
0 1
NP+
</figure>
<figureCaption confidence="0.7762295">
Figure 3: Towards a multi-formalism parsing envi-
ronment.
</figureCaption>
<figure confidence="0.99918505">
noun.
det.
3
5
7
S+
7 is the only valid state and {proper., trans., det.,
noun.} the only compatible set of trees).
0 John 1 1 eats 2 2 a 3 3 cake 4
det.
intrans.
2
S+
4
S+
noun.
S+ NP+
6
S+ NP-
S+ NP-
</figure>
<figureCaption confidence="0.999907">
Figure 2: Polarity-based lexical disambiguation.
</figureCaption>
<bodyText confidence="0.99999">
In our context, this polarity filtering has been
added before step 1, leaving untouched the core
RCG conversion and parsing steps. The idea is
to compute the sets of compatible trees (or tree
tuples for TT-MCTAG) and to convert these sets
separately. Indeed the RCG has to encode only
valid adjunctions/substitutions. Thanks to this
automaton-based “clustering” of the compatible
tree (or tree tuples), we avoid predicting incompat-
ible derivations. Note that the time saved by using
a polarity-based filter is not negligible, especially
when parsing long sentences.2
</bodyText>
<subsectionHeader confidence="0.835468">
2.2 Adding formalisms to the parsing
environment
</subsectionHeader>
<bodyText confidence="0.999952055555555">
Of course, the two extensions introduced in the
previous section may have been added to other
modular architectures as well. The main gain
brought by RCG is the possibility to parse not
only tree-based grammars, but other formalisms
provided they can be encoded into RCG. In our
system, only TAG and TT-MCTAG have been
considered so far. Nonetheless, Boullier (1998)
and Søgaard (2007) have defined transformations
into RCG for other mildly context-sensitive for-
malisms.3
To sum up, the idea would be to keep the core
RCG parser, and to extend TuLiPA with a specific
conversion module for each targeted formalism.
On top of these conversion modules, one should
also provide interpretation modules allowing to de-
code the RCG derivation forest in terms of the in-
put formalism (see Fig. 3).
</bodyText>
<footnote confidence="0.9549505">
2An evaluation of the gain brought by this technique when
using Interaction Grammar is given by Bonfante et al. (2004).
3These include Multi-Component Tree-Adjoining Gram-
mar, Linear Indexed Grammar, Head Grammar, Coupled
Context Free Grammar, Right Linear Unification Grammar
and Synchronous Unification Grammar.
</footnote>
<bodyText confidence="0.999987466666667">
An important point remains to be discussed. It
concerns the role of lexicalization with respect to
the formalism used. Indeed, the tree-based gram-
mar formalisms currently supported (TAG and TT-
MCTAG) both share the same lexicalization pro-
cess (i.e., tree anchoring). Thus the lexicon format
is common to these formalisms. As we will see
below, it corresponds to a 2-layer lexicon made of
inflected forms and lemma respectively, the latter
selecting specific grammatical structures. When
parsing other formalisms, it is still unclear whether
one can use the same lexicon format, and if not
what kind of general lexicon management module
should be added to the parser (in particular to deal
with morphology).
</bodyText>
<sectionHeader confidence="0.489165" genericHeader="method">
3 Towards a complete grammar
engineering environment
</sectionHeader>
<bodyText confidence="0.999984285714286">
So far, we have seen how to use a generic parsing
architecture relying on RCG to parse different for-
malisms. In this section, we adopt a broader view
and enumerate some requirements for a linguistic
resource development environment. We also see
to what extent these requirements are fulfilled (or
partially fulfilled) within the TuLiPA system.
</bodyText>
<subsectionHeader confidence="0.995397">
3.1 Grammar engineering with TuLiPA
</subsectionHeader>
<bodyText confidence="0.999991769230769">
As advocated by Erbach (1992), grammar en-
gineering needs “tools for testing the grammar
with respect to consistency, coverage, overgener-
ation and accuracy”. These characteristics may
be taken into account by different interacting soft-
ware. Thus, consistency can be checked by a semi-
automatic grammar production device, such as the
XMG system of Duchier et al. (2004). Overgen-
eration is mainly checked by a generator (or by
a parser with adequate test suites), and coverage
and accuracy by a parser. In our case, the TuLiPA
system provides an entry point for using a gram-
mar production system (and a lexicon conversion
</bodyText>
<page confidence="0.993544">
3
</page>
<bodyText confidence="0.999932224489796">
tool introduced below), while including a parser.
Note that TuLiPA does not include any generator,
nonetheless it uses the same lexicon format as the
GenI surface realizer for TAG4.
TuLiPA’s input grammar is designed using
XMG, which is a metagrammar compiler for tree-
based formalisms. In other terms, the linguist de-
fines a factorized description of the grammar (the
so-called metagrammar) in the XMG language.
Briefly, an XMG metagrammar consists of (i) ele-
mentary tree fragments represented as tree descrip-
tion logic formulas, and (ii) conjunctive and dis-
junctive combinations of these tree fragments to
describe actual TAG tree schemata.5 This meta-
grammar is then compiled by the XMG system to
produce a tree grammar in an XML format. Note
that the resulting grammar contains tree schemata
(i.e., unlexicalized trees). To lexicalize these, the
linguist defines a lexicon mapping words with cor-
responding sets of trees. Following XTAG (2001),
this lexicon is a 2-layer lexicon made of morpho-
logical and lemma specifications. The motivation
of this 2-layer format is (i) to express linguistic
generalizations at the lexicon level, and (ii) to al-
low the parser to only select a subgrammar accord-
ing to a given sentence, thus reducing parsing com-
plexity. TuLiPA comes with a lexicon conversion
tool (namely lexConverter) allowing to write a lex-
icon in a user-friendly text format and to convert it
into XML. An example of an entry of such a lexi-
con is given in Fig. 4.
The morphological specification consists of a
word, the corresponding lemma and morphologi-
cal features. The main pieces of information con-
tained in the lemma specification are the *ENTRY
field, which refers to the lemma, the *CAT field
referring to the syntactic category of the anchor
node, the *SEM field containing some semantic in-
formation allowing for semantic instantiation, the
*FAM field, which contains the name of the tree
family to be anchored, the *FILTERS field which
consists of a feature structure constraining by uni-
fication the trees of a given family that can be
anchored by the given lemma (used for instance
for non-passivable verbs), the *EQUATIONS field
allowing for the definition of equations targeting
named nodes of the trees, and the *COANCHORS
field, which allows for the specification of co-
anchors (such as by in the verb to come by).
</bodyText>
<footnote confidence="0.993345">
4http://trac.loria.fr/˜geni
5See (Crabb´e, 2005) for a presentation on how to use the
XMG formalism for describing a core TAG for French.
</footnote>
<table confidence="0.766173357142857">
Morphological specification:
vergisst vergessen [pos=v,num=sg,per=3]
Lemma specification:
*ENTRY: vergessen
*CAT: v
*SEM: BinaryRel[pred=vergessen]
*ACC: 1
*FAM: Vnp2
*FILTERS: []
*EX:
*EQUATIONS:
NParg1 cas = nom
NParg2 cas = acc
*COANCHORS:
</table>
<figureCaption confidence="0.996879">
Figure 4: Morphological and lemma specification
of vergisst.
</figureCaption>
<bodyText confidence="0.999862333333333">
From these XML resources, TuLiPA parses a
string, corresponding either to a sentence or a con-
stituent (noun phrase, prepositional phrase, etc.),
and computes several output pieces of informa-
tion, namely (for TAG and TT-MCTAG): deriva-
tion/derived trees, semantic representations (com-
puted from underspecified representations using
the utool software6, or dependency views of the
derivation trees (using the DTool software7).
</bodyText>
<subsectionHeader confidence="0.997678">
3.2 Grammar debugging
</subsectionHeader>
<bodyText confidence="0.998538933333333">
The engineering process introduced in the preced-
ing section belongs to a development cycle, where
one first designs a grammar and corresponding
lexicons using XMG, then checks these with the
parser, fixes them, parses again, and so on.
To facilitate grammar debugging, TuLiPA in-
cludes both a verbose and a robust mode allow-
ing respectively to (i) produce a log of the RCG-
conversion, RCG-parsing and RCG-derivation in-
terpretation, and (ii) display mismatching features
leading to incomplete derivations. More precisely,
in robust mode, the parser displays derivations step
by step, highlighting feature unification failures.
TuLiPA’s options can be activated via an intu-
itive Graphical User Interface (see Fig. 5).
</bodyText>
<footnote confidence="0.98105325">
6See http://www.coli.uni-saarland.de/
projects/chorus/utool/, with courtesy of Alexander
Koller.
7With courtesy of Marco Kuhlmann.
</footnote>
<page confidence="0.995269">
4
</page>
<figureCaption confidence="0.998898">
Figure 5: TuLiPA’s Graphical User Interface.
</figureCaption>
<subsectionHeader confidence="0.980799">
3.3 Towards a functional common interface
</subsectionHeader>
<bodyText confidence="0.94312275">
Unfortunately, as mentioned above, the linguist
has to move back-and-forth from the gram-
mar/lexicon descriptions to the parser, i.e., each
time the parser reports grammar errors, the linguist
fixes these and then recomputes the XML files and
then parses again. To avoid this tedious task of re-
sources re-compilation, we started developing an
Eclipse8 plug-in for the TuLiPA system. Thus, the
linguist will be able to manage all these resources,
and to call the parser, the metagrammar compiler,
and the lexConverter from a common interface (see
Fig. 6).
</bodyText>
<figureCaption confidence="0.995084">
Figure 6: TuLiPA’s eclipse plug-in.
</figureCaption>
<bodyText confidence="0.993234666666667">
The motivation for this plug-in comes from
the observation that designing electronic gram-
mars is a task comparable to designing source
</bodyText>
<footnote confidence="0.565392">
8Seehttp://www.eclipse.org
</footnote>
<bodyText confidence="0.999819">
code. A powerful grammar engineering environ-
ment should thus come with development facili-
ties such as precise debugging information, syntax
highlighting, etc. Using the Eclipse open-source
development platform allows for reusing several
components inherited from the software develop-
ment community, such as plug-ins for version con-
trol, editors coupled with explorers, etc.
Eventually, one point worth considering in the
context of grammar development concerns data en-
coding. To our knowledge, only few environments
provide support for UTF-8 encoding, thus guaran-
tying the coverage of a wide set of charsets and
languages. In TuLiPA, we added an UTF-8 sup-
port (in the lexConverter), thus allowing to design
a TAG for Korean (work in progress).
</bodyText>
<subsectionHeader confidence="0.996342">
3.4 Usability of the TuLiPA system
</subsectionHeader>
<bodyText confidence="0.999971344827586">
As mentioned above, the TuLiPA system is made
of several interacting components, that one cur-
rently has to install separately. Nonetheless, much
attention has been paid to make this installation
process as easy as possible and compatible with
all major platforms.9
XMG and lexConverter can be installed by com-
piling their sources (using a make command).
TuLiPA is developed in Java and released as an ex-
ecutable jar. No compilation is needed for it, the
only requirement is the Gecode/GecodeJ library10
(available as a binary package for many platforms).
Finally, the TuLiPA eclipse plug-in can be installed
easily from eclipse itself. All these tools are re-
leased under Free software licenses (either GNU
GPL or Eclipse Public License).
This environment is being used (i) at the Univer-
sity of T¨ubingen, in the context of the development
of a TT-MCTAG for German describing both syn-
tax and semantics, and (ii) at LORIA Nancy, in the
development of an XTAG-based metagrammar for
English. The German grammar, called GerTT (for
German Tree Tuples), is released under a LGPL li-
cense for Linguistic Resources11 and is presented
in (Kallmeyer et al., 2008). The test-suite cur-
rently used to check the grammar is hand-crafted.
A more systematic evaluation of the grammar is in
preparation, using the Test Suite for Natural Lan-
guage Processing (Lehmann et al., 1996).
</bodyText>
<footnote confidence="0.985809">
9Seehttp://sourcesup.cru.fr/tulipa.
10See http://www.gecode.org/gecodej.
11See http://infolingu.univ-mlv.
fr/DonneesLinguistiques/
Lexiques-Grammaires/lgpllr.html
</footnote>
<page confidence="0.996732">
5
</page>
<sectionHeader confidence="0.97014" genericHeader="method">
4 Comparison with existing approaches
</sectionHeader>
<subsectionHeader confidence="0.918965">
4.1 Engineering environments for tree-based
grammar formalisms
</subsectionHeader>
<bodyText confidence="0.999962386363637">
To our knowledge, there is currently no available
parsing environment for multi-component TAG.
Existing grammar engineering environments for
TAG include the DyALog system12 described in
Villemonte de la Clergerie (2005). DyALog is a
compiler for a logic programming language using
tabulation and dynamic programming techniques.
This compiler has been used to implement efficient
parsing algorithms for several formalisms, includ-
ing TAG and RCG. Unfortunately, it does not in-
clude any built-in GUI and requires a good know-
ledge of the GNU build tools to compile parsers.
This makes it relatively difficult to use. DyALog’s
main quality lies in its efficiency in terms of pars-
ing time and its capacity to handle very large re-
sources. Unlike TuLiPA, it does not compute se-
mantic representations.
The closest approach to TuLiPA corresponds to
the SemTAG system13, which extends TAG parsers
compiled with DyALog with a semantic calculus
module (Gardent and Parmentier, 2007). Unlike
TuLiPA, this system only supports TAG, and does
not provide any graphical output allowing to easily
check the result of parsing.
Note that, for grammar designers mainly inter-
ested in TAG, SemTAG and TuLiPA can be seen
as complementary tools. Indeed, one may use
TuLiPA to develop the grammar and check spe-
cific syntactic structures thanks to its intuitive pars-
ing environment. Once the grammar is stable, one
may use SemTAG in batch processing to parse
corpuses and build semantic representations using
large grammars. This combination of these 2 sys-
tems is made easier by the fact that both use the
same input formats (a metagrammar in the XMG
language and a text-based lexicon). This approach
is the one being adopted for the development of a
French TAG equipped with semantics.
For Interaction Grammar (Perrier, 2000), there
exists an engineering environment gathering the
XMG metagrammar compiler and an eLEtrOstatic
PARser (LEOPAR).14 This environment is be-
ing used to develop an Interaction Grammar for
French. TuLiPA’s lexical disambiguation module
</bodyText>
<footnote confidence="0.98978075">
12Seehttp://dyalog.gforge.inria.fr
13See http://trac.loria.fr/˜semconst
14See http://www.loria.fr/equipes/
calligramme/leopar/
</footnote>
<bodyText confidence="0.998659666666667">
reuses techniques introduced by LEOPAR. Unlike
TuLiPA, LEOPAR does not currently support se-
mantic information.
</bodyText>
<subsectionHeader confidence="0.947248">
4.2 Engineering environments for other
grammar formalisms
</subsectionHeader>
<bodyText confidence="0.999825888888889">
For other formalisms, there exist state-of-the-art
grammar engineering environments that have been
used for many years to design large deep grammars
for several languages.
For Lexical Functional Grammar, one may cite
the Xerox Linguistic Environment (XLE).15 For
Head-driven Phrase Structure Grammar, the main
available systems are the Linguistic Knowledge
Base (LKB)16 and the TRALE system.17 For
Combinatory Categorial Grammar, one may cite
the OpenCCG library18 and the C&amp;C parser.19
These environments have been used to develop
broad-coverage resources equipped with semantics
and include both a generator and a parser. Un-
like TuLiPA, they represent advanced projects, that
have been used for dialog and machine translation
applications. They are mainly tailored for a spe-
cific formalism.20
</bodyText>
<sectionHeader confidence="0.998514" genericHeader="method">
5 Future work
</sectionHeader>
<bodyText confidence="0.999943571428571">
In this section, we give some prospective views
concerning engineering environments in general,
and TuLiPA in particular. We first distinguish be-
tween 2 main usages of grammar engineering en-
vironments, namely a pedagogical usage and an
application-oriented usage, and finally give some
comments about multi-formalism.
</bodyText>
<subsectionHeader confidence="0.99878">
5.1 Pedagogical usage
</subsectionHeader>
<bodyText confidence="0.999896">
Developing grammars in a pedagogical context
needs facilities allowing for inspection of the struc-
tures of the grammar, step-by-step parsing (or gen-
eration), along with an intuitive interface. The idea
is to abstract away from technical aspects related to
implementation (intermediate data structures, opti-
mizations, etc.).
</bodyText>
<footnote confidence="0.9140764">
15See http://www2.parc.com/isl/groups/
nltt/xle/
16Seehttp://wiki.delph-in.net/moin
17See http://milca.sfs.uni-tuebingen.de/
A4/Course/trale/
18Seehttp://openccg.sourceforge.net/
19Seehttp://svn.ask.it.usyd.edu.au/trac/
candc/wiki
20Nonetheless, Beavers (2002) encoded a CCG in the
LKB’s Type Description Language.
</footnote>
<page confidence="0.998867">
6
</page>
<bodyText confidence="0.999990571428572">
The question whether to provide graphical or
text-based editors can be discussed. As advo-
cated by Baldridge et al. (2007), a low-level text-
based specification can offer more flexibility and
bring less frustration to the grammar designer, es-
pecially when such a specification can be graph-
ically interpreted. This is the approach chosen
by XMG, where the grammar is defined via an
(advanced or not) editor such as gedit or emacs.
Within TuLiPA, we chose to go further by using
the Eclipse platform. Currently, it allows for dis-
playing a summary of the content of a metagram-
mar or lexicon on a side panel, while editing these
on a middle panel. These two panels are linked
via a jump functionality. The next steps concern
(i) the plugging of a graphical viewer to display
the (meta)grammar structures independently from
a given parse, and (ii) the extension of the eclipse
plug-in so that one can easily consistently modify
entries of the metagrammar or lexicon (especially
when these are split over several files).
</bodyText>
<subsectionHeader confidence="0.984893">
5.2 Application-oriented usage
</subsectionHeader>
<bodyText confidence="0.99916792">
When dealing with applications, one may demand
more from the grammar engineering environment,
especially in terms of efficiency and robustness
(support for larger resources, partial parsing, etc.).
Efficiency needs optimizations in the parsing
engine making it possible to support grammars
containing several thousands of structures. One
interesting question concerns the compilation of a
grammar either off-line or on-line. In DyALog’s
approach, the grammar is compiled off-line into
a logical automaton encoding all possible deriva-
tions. This off-line compilation can take some
minutes with a TAG having 6000 trees, but the re-
sulting parser can parse sentences within a second.
In TuLiPA’s approach, the grammar is compiled
into an RCG on-line. While giving satisfactory re-
sults on reduced resources21, it may lead to trou-
bles when scaling up. This is especially true for
TAG (the TT-MCTAG formalism is by definition a
factorized formalism compared with TAG). In the
future, it would be useful to look for a way to pre-
compile a TAG into an RCG off-line, thus saving
the conversion time.
Another important feature of grammar engineer-
ing environments consists of its debugging func-
</bodyText>
<footnote confidence="0.91308025">
21For a TT-MCTAG counting about 300 sets of trees and an
and-crafted lexicon made of about 300 of words, a 10-word
sentence is parsed (and a semantic representation computed)
within seconds.
</footnote>
<bodyText confidence="0.99929425">
tionalities. Among these, one may cite unit and
integration testing. It would be useful to extend
the TuLiPA system to provide a module for gen-
erating test-suites for a given grammar. The idea
would be to record the coverage and analyses of
a grammar at a given time. Once the grammar is
further developed, these snapshots would allow for
regression testing.
</bodyText>
<subsectionHeader confidence="0.988635">
5.3 About multi-formalism
</subsectionHeader>
<bodyText confidence="0.999993166666667">
We already mentioned that TuLiPA was opening
a way towards multi-formalism by relying on an
RCG core. It is worth noticing that the XMG
system was also designed to be further extensi-
ble. Indeed, a metagrammar in XMG corresponds
to the combination of elementary structures. One
may think of designing a library of such structures,
these would be dependent on the target gram-
mar formalism. The combinations may represent
general linguistic concepts and would be shared
by different grammar implementations, following
ideas presented by Bender et al. (2005).
</bodyText>
<sectionHeader confidence="0.999234" genericHeader="conclusions">
6 Conclusion
</sectionHeader>
<bodyText confidence="0.999978380952381">
In this paper, we have presented a multi-formalism
parsing architecture using RCG as a pivot formal-
ism to parse mildly context-sensitive formalisms
(currently TAG and TT-MCTAG). This system has
been designed to facilitate grammar development
by providing user-friendly interfaces, along with
several functionalities (e.g., dependency extrac-
tion, derivation/derived tree display and semantic
calculus). It is currently used for developing a core
grammar for German.
At the moment, we are working on the extension
of this architecture to include a fully functional
Eclipse plug-in. Other current tasks concern op-
timizations to support large scale parsing and the
extension of the syntactic and semantic coverage
of the German grammar under development.
In a near future, we plan to evaluate the parser
and the German grammar (parsing time, correction
of syntactic and semantic outputs) with respect to
a standard test-suite such as the TSNLP (Lehmann
et al., 1996).
</bodyText>
<sectionHeader confidence="0.99828" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.949943">
This work has been supported by the Deutsche
Forschungsgemeinschaft (DFG) and the Deutscher
Akademischer Austausch Dienst (DAAD, grant
</bodyText>
<page confidence="0.997786">
7
</page>
<bodyText confidence="0.995218">
A/06/71039). We are grateful to three anonymous
reviewers for valuable comments on this work.
</bodyText>
<sectionHeader confidence="0.989522" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999543558823529">
Baldridge, Jason, Sudipta Chatterjee, Alexis Palmer,
and Ben Wing. 2007. DotCCG and VisCCG: Wiki
and programming paradigms for improved grammar
engineering with OpenCCG. In King, Tracy Hol-
loway and Emily M. Bender, editors, Proceedings of
the GEAF07 workshop, pages 5–25, Stanford, CA.
CSLI.
Beavers, John. 2002. Documentation: A CCG Imple-
mentation for the LKB. LinGO Working Paper No.
2002-08, CSLI, Stanford University, Stanford, CA.
Bender, Emily, Dan Flickinger, Frederik Fouvry, and
Melanie Siegel. 2005. Shared representation in mul-
tilingual grammar engineering. Research on Lan-
guage &amp; Computation, 3(2):131–138.
Bonfante, Guillaume, Bruno Guillaume, and Guy Per-
rier. 2004. Polarization and abstraction of grammat-
ical formalisms as methods for lexical disambigua-
tion. In Proceedings of the International Conference
on Computational Linguistics (CoLing 2004), pages
303–309, Geneva, Switzerland.
Boullier, Pierre. 1998. Proposal for a natural lan-
guage processing syntactic backbone. Rapport de
Recherche 3342, INRIA.
Boullier, Pierre. 1999. On TAG and Multicomponent
TAG Parsing. Rapport de Recherche 3668, INRIA.
Boullier, Pierre. 2000. Range concatenation gram-
mars. In Proceedings of the International Workshop
on Parsing Technologies (IWPT 2000), pages 53–64,
Trento, Italy.
Crabb´e, Benoit. 2005. Grammatical development with
XMG. In Proceedings of the conference on Logical
Aspects of Computational Linguistics 2005 (LACL
05), pages 84–100, Bordeaux, France.
Duchier, Denys, Joseph Le Roux, and Yannick Parmen-
tier. 2004. The Metagrammar Compiler: An NLP
Application with a Multi-paradigm Architecture. In
Proceedings of the 2nd International Mozart/Oz
Conference (MOZ’2004), pages 175–187, Charleroi,
Belgium.
Erbach, Gregor. 1992. Tools for grammar engineer-
ing. In 3rd Conference on Applied Natural Lan-
guage Processing, pages 243–244, Trento, Italy.
Gardent, Claire and Laura Kallmeyer. 2003. Semantic
Construction in FTAG. In Proceedings of the Con-
ference of the European chapter of the Association
for Computational Linguistics (EACL 2003), pages
123–130, Budapest, Hungary.
Gardent, Claire and Yannick Parmentier. 2007. Sem-
tag: a platform for specifying tree adjoining gram-
mars and performing tag-based semantic construc-
tion. In Proceedings of the International Confer-
ence of the Association for Computational Linguis-
tics (ACL 2007), Companion Volume Proceedings of
the Demo and Poster Sessions, pages 13–16, Prague,
Czech Republic.
Joshi, Aravind K. 1987. An introduction to Tree Ad-
joining Grammars. In Manaster-Ramer, A., editor,
Mathematics ofLanguage, pages 87–114. John Ben-
jamins, Amsterdam.
Kallmeyer, Laura and Yannick Parmentier. 2008. On
the relation between Multicomponent Tree Adjoin-
ing Grammars with Tree Tuples (TT-MCTAG) and
Range Concatenation Grammars (RCG). In Pro-
ceedings of the 2nd International Conference on
Language and Automata Theories and Applications
(LATA 2008), pages 277–288, Tarragona, Spain.
Kallmeyer, Laura, Timm Lichte, Wolfgang Maier, Yan-
nick Parmentier, and Johannes Dellert. 2008. De-
velopping an MCTAG for German with an RCG-
based Parser. In Proceedings of the Language, Re-
source and Evaluation Conference (LREC 2008),
Marrakech, Morocco.
Lehmann, Sabine, Stephan Oepen, Sylvie Regnier-
Prost, Klaus Netter, Veronika Lux, Judith Klein,
Kirsten Falkedal, Frederik Fouvry, Dominique Esti-
val, Eva Dauphin, Herv´e Compagnion, Judith Baur,
Lorna Balkan, and Doug Arnold. 1996. TSNLP —
Test Suites for Natural Language Processing. In Pro-
ceedings of the International Conference on Compu-
tational Linguistics (Coling 1996), volume 2, pages
711–716, Copenhagen, Denmark.
Lichte, Timm. 2007. An MCTAG with tuples for co-
herent constructions in German. In Proceedings of
the 12th Conference on Formal Grammar, Dublin,
Ireland.
Perrier, Guy. 2000. Interaction grammars. In Pro-
ceedings of the International Conference on Compu-
tational Linguistics (CoLing 2000), pages 600–606,
Saarbruecken, Germany.
Søgaard, Anders. 2007. Complexity, expressivity and
logic of linguistic theories. Ph.D. thesis, University
of Copenhagen, Copenhagen, Denmark.
Villemonte de la Clergerie, ´Eric. 2005. DyALog: a
tabular logic programming based environment for
NLP. In Proceedings of the workshop on Constraint
Satisfaction for Language Processing (CSLP 2005),
pages 18–33, Barcelona, Spain.
XTAG-Research-Group. 2001. A lexicalized tree
adjoining grammar for english. Technical Re-
port IRCS-01-03, IRCS, University of Pennsylva-
nia. Available at http://www.cis.upenn.
edu/˜xtag/gramrelease.html.
</reference>
<page confidence="0.998485">
8
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.124429">
<title confidence="0.988098">TuLiPA: Towards a Multi-Formalism Parsing Environment Grammar Engineering</title>
<author confidence="0.996478">Laura Kallmeyer Timm Lichte Wolfgang Maier</author>
<affiliation confidence="0.74765">SFB 441 SFB 441 SFB 441 Universit¨at T¨ubingen Universit¨at T¨ubingen Universit¨at</affiliation>
<address confidence="0.994615">D-72074, T¨ubingen, Germany D-72074, T¨ubingen, Germany D-72074, T¨ubingen, Germany</address>
<email confidence="0.948148">lk@sfs.uni-tuebingen.detimm.lichte@uni-tuebingen.dewo.maier@uni-tuebingen.de</email>
<author confidence="0.843535">Yannick</author>
<affiliation confidence="0.917889">CNRS - Nancy</affiliation>
<address confidence="0.991171">F-54506, Vandœuvre, France</address>
<email confidence="0.990589">parmenti@loria.fr</email>
<author confidence="0.836042">Johannes</author>
<affiliation confidence="0.8402885">SFB 441 - Universit¨at</affiliation>
<address confidence="0.99137">D-72074, T¨ubingen, Germany</address>
<author confidence="0.921254">Kilian</author>
<affiliation confidence="0.8950425">SFB 441 - Universit¨at</affiliation>
<address confidence="0.986054">D-72074, T¨ubingen, Germany</address>
<abstract confidence="0.98203305882353">In this paper, we present an open-source parsing environment (T¨ubingen Linguistic Parsing Architecture, TuLiPA) which uses Range Concatenation Grammar (RCG) as a pivot formalism, thus opening the way to the parsing of several mildly context-sensitive formalisms. This environment currently supports tree-based grammars (namely Tree-Adjoining Grammars (TAG) and Multi-Component Tree- Adjoining Grammars with Tree Tuples (TT-MCTAG)) and allows computation not only of syntactic structures, but also of the corresponding semantic representations. It is used for the development of a tree-based grammar for German.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Jason Baldridge</author>
<author>Sudipta Chatterjee</author>
<author>Alexis Palmer</author>
<author>Ben Wing</author>
</authors>
<title>DotCCG and VisCCG: Wiki and programming paradigms for improved grammar engineering with OpenCCG.</title>
<date>2007</date>
<booktitle>Proceedings of the GEAF07 workshop,</booktitle>
<pages>5--25</pages>
<editor>In King, Tracy Holloway and Emily M. Bender, editors,</editor>
<publisher>CSLI.</publisher>
<location>Stanford, CA.</location>
<contexts>
<context position="23550" citStr="Baldridge et al. (2007)" startWordPosition="3583" endWordPosition="3586">g (or generation), along with an intuitive interface. The idea is to abstract away from technical aspects related to implementation (intermediate data structures, optimizations, etc.). 15See http://www2.parc.com/isl/groups/ nltt/xle/ 16Seehttp://wiki.delph-in.net/moin 17See http://milca.sfs.uni-tuebingen.de/ A4/Course/trale/ 18Seehttp://openccg.sourceforge.net/ 19Seehttp://svn.ask.it.usyd.edu.au/trac/ candc/wiki 20Nonetheless, Beavers (2002) encoded a CCG in the LKB’s Type Description Language. 6 The question whether to provide graphical or text-based editors can be discussed. As advocated by Baldridge et al. (2007), a low-level textbased specification can offer more flexibility and bring less frustration to the grammar designer, especially when such a specification can be graphically interpreted. This is the approach chosen by XMG, where the grammar is defined via an (advanced or not) editor such as gedit or emacs. Within TuLiPA, we chose to go further by using the Eclipse platform. Currently, it allows for displaying a summary of the content of a metagrammar or lexicon on a side panel, while editing these on a middle panel. These two panels are linked via a jump functionality. The next steps concern (i</context>
</contexts>
<marker>Baldridge, Chatterjee, Palmer, Wing, 2007</marker>
<rawString>Baldridge, Jason, Sudipta Chatterjee, Alexis Palmer, and Ben Wing. 2007. DotCCG and VisCCG: Wiki and programming paradigms for improved grammar engineering with OpenCCG. In King, Tracy Holloway and Emily M. Bender, editors, Proceedings of the GEAF07 workshop, pages 5–25, Stanford, CA. CSLI.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John Beavers</author>
</authors>
<title>Documentation: A CCG Implementation for the LKB.</title>
<date>2002</date>
<tech>LinGO Working Paper No. 2002-08,</tech>
<institution>CSLI, Stanford University,</institution>
<location>Stanford, CA.</location>
<contexts>
<context position="23372" citStr="Beavers (2002)" startWordPosition="3555" endWordPosition="3556">malism. 5.1 Pedagogical usage Developing grammars in a pedagogical context needs facilities allowing for inspection of the structures of the grammar, step-by-step parsing (or generation), along with an intuitive interface. The idea is to abstract away from technical aspects related to implementation (intermediate data structures, optimizations, etc.). 15See http://www2.parc.com/isl/groups/ nltt/xle/ 16Seehttp://wiki.delph-in.net/moin 17See http://milca.sfs.uni-tuebingen.de/ A4/Course/trale/ 18Seehttp://openccg.sourceforge.net/ 19Seehttp://svn.ask.it.usyd.edu.au/trac/ candc/wiki 20Nonetheless, Beavers (2002) encoded a CCG in the LKB’s Type Description Language. 6 The question whether to provide graphical or text-based editors can be discussed. As advocated by Baldridge et al. (2007), a low-level textbased specification can offer more flexibility and bring less frustration to the grammar designer, especially when such a specification can be graphically interpreted. This is the approach chosen by XMG, where the grammar is defined via an (advanced or not) editor such as gedit or emacs. Within TuLiPA, we chose to go further by using the Eclipse platform. Currently, it allows for displaying a summary </context>
</contexts>
<marker>Beavers, 2002</marker>
<rawString>Beavers, John. 2002. Documentation: A CCG Implementation for the LKB. LinGO Working Paper No. 2002-08, CSLI, Stanford University, Stanford, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Emily Bender</author>
<author>Dan Flickinger</author>
<author>Frederik Fouvry</author>
<author>Melanie Siegel</author>
</authors>
<title>Shared representation in multilingual grammar engineering.</title>
<date>2005</date>
<journal>Research on Language &amp; Computation,</journal>
<volume>3</volume>
<issue>2</issue>
<contexts>
<context position="26784" citStr="Bender et al. (2005)" startWordPosition="4103" endWordPosition="4106">ots would allow for regression testing. 5.3 About multi-formalism We already mentioned that TuLiPA was opening a way towards multi-formalism by relying on an RCG core. It is worth noticing that the XMG system was also designed to be further extensible. Indeed, a metagrammar in XMG corresponds to the combination of elementary structures. One may think of designing a library of such structures, these would be dependent on the target grammar formalism. The combinations may represent general linguistic concepts and would be shared by different grammar implementations, following ideas presented by Bender et al. (2005). 6 Conclusion In this paper, we have presented a multi-formalism parsing architecture using RCG as a pivot formalism to parse mildly context-sensitive formalisms (currently TAG and TT-MCTAG). This system has been designed to facilitate grammar development by providing user-friendly interfaces, along with several functionalities (e.g., dependency extraction, derivation/derived tree display and semantic calculus). It is currently used for developing a core grammar for German. At the moment, we are working on the extension of this architecture to include a fully functional Eclipse plug-in. Other</context>
</contexts>
<marker>Bender, Flickinger, Fouvry, Siegel, 2005</marker>
<rawString>Bender, Emily, Dan Flickinger, Frederik Fouvry, and Melanie Siegel. 2005. Shared representation in multilingual grammar engineering. Research on Language &amp; Computation, 3(2):131–138.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Guillaume Bonfante</author>
<author>Bruno Guillaume</author>
<author>Guy Perrier</author>
</authors>
<title>Polarization and abstraction of grammatical formalisms as methods for lexical disambiguation.</title>
<date>2004</date>
<booktitle>In Proceedings of the International Conference on Computational Linguistics (CoLing</booktitle>
<pages>303--309</pages>
<location>Geneva, Switzerland.</location>
<contexts>
<context position="7481" citStr="Bonfante et al. (2004)" startWordPosition="1122" endWordPosition="1125">having a frontier node marked for anchoring (i.e., lexicalization). At parsing time, the tree schemata are anchored according to the input string. This anchoring selects a subgrammar supposed to cover the input string. Unfortunately, this subgrammar may contain many trees that either do not lead to a parse or for which we know a priori that they cannot be combined within the same derivation (so we should not predict a derivation from one of these trees to another during parsing). As a result, the parser could have poor performance because of the many derivation paths that have to be explored. Bonfante et al. (2004) proposed to polarize the structures of the grammar, and to apply an automaton-based filtering of the compatible structures. The idea is the following. One compute polarities representing the needs/resources brought by a given tree (or tree tuple for TT-MCTAG). A substitution or foot node with category NP reflects a need for an NP (written NP-). In the same way, an NP root node reflects a resource of type NP (written NP+). Then you build an automaton whose edges correspond to trees, and states to polarities brought by trees along the path. The automaton is then traversed to extract all paths l</context>
<context position="10042" citStr="Bonfante et al. (2004)" startWordPosition="1561" endWordPosition="1564">m, only TAG and TT-MCTAG have been considered so far. Nonetheless, Boullier (1998) and Søgaard (2007) have defined transformations into RCG for other mildly context-sensitive formalisms.3 To sum up, the idea would be to keep the core RCG parser, and to extend TuLiPA with a specific conversion module for each targeted formalism. On top of these conversion modules, one should also provide interpretation modules allowing to decode the RCG derivation forest in terms of the input formalism (see Fig. 3). 2An evaluation of the gain brought by this technique when using Interaction Grammar is given by Bonfante et al. (2004). 3These include Multi-Component Tree-Adjoining Grammar, Linear Indexed Grammar, Head Grammar, Coupled Context Free Grammar, Right Linear Unification Grammar and Synchronous Unification Grammar. An important point remains to be discussed. It concerns the role of lexicalization with respect to the formalism used. Indeed, the tree-based grammar formalisms currently supported (TAG and TTMCTAG) both share the same lexicalization process (i.e., tree anchoring). Thus the lexicon format is common to these formalisms. As we will see below, it corresponds to a 2-layer lexicon made of inflected forms an</context>
</contexts>
<marker>Bonfante, Guillaume, Perrier, 2004</marker>
<rawString>Bonfante, Guillaume, Bruno Guillaume, and Guy Perrier. 2004. Polarization and abstraction of grammatical formalisms as methods for lexical disambiguation. In Proceedings of the International Conference on Computational Linguistics (CoLing 2004), pages 303–309, Geneva, Switzerland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Pierre Boullier</author>
</authors>
<title>Proposal for a natural language processing syntactic backbone.</title>
<date>1998</date>
<booktitle>Rapport de Recherche 3342, INRIA.</booktitle>
<contexts>
<context position="4679" citStr="Boullier, 1998" startWordPosition="671" endWordPosition="672">gust 2008 with respect to these. In section 4, we compare this system with existing approaches for parsing and more generally for grammar engineering. Finally, in section 5, we conclude by presenting future work. 2 Range Concatenation Grammar as a pivot formalism The main idea underlying TuLiPA is to use RCG as a pivot formalism for RCG has appealing formal properties (e.g., a generative capacity lying beyond Linear Context Free Rewriting Systems and a polynomial parsing complexity) and there exist efficient algorithms, for RCG parsing (Boullier, 2000) and for grammar transformation into RCG (Boullier, 1998; Boullier, 1999). Parsing with TuLiPA is thus a 3-step process: 1. The input tree-based grammar is converted into an RCG (using the algorithm of Kallmeyer and Parmentier (2008) when dealing with TT-MCTAG). 2. The resulting RCG is used for parsing the input string using an extension of the parsing algorithm of Boullier (2000). 3. The RCG derivation structure is interpreted to extract the derivation and derived trees with respect to the input grammar. The use of RCG as a pivot formalism, and thus of an RCG parser as a core component of the system, leads to a modular architecture. In turns, this</context>
<context position="9502" citStr="Boullier (1998)" startWordPosition="1473" endWordPosition="1474">e compatible tree (or tree tuples), we avoid predicting incompatible derivations. Note that the time saved by using a polarity-based filter is not negligible, especially when parsing long sentences.2 2.2 Adding formalisms to the parsing environment Of course, the two extensions introduced in the previous section may have been added to other modular architectures as well. The main gain brought by RCG is the possibility to parse not only tree-based grammars, but other formalisms provided they can be encoded into RCG. In our system, only TAG and TT-MCTAG have been considered so far. Nonetheless, Boullier (1998) and Søgaard (2007) have defined transformations into RCG for other mildly context-sensitive formalisms.3 To sum up, the idea would be to keep the core RCG parser, and to extend TuLiPA with a specific conversion module for each targeted formalism. On top of these conversion modules, one should also provide interpretation modules allowing to decode the RCG derivation forest in terms of the input formalism (see Fig. 3). 2An evaluation of the gain brought by this technique when using Interaction Grammar is given by Bonfante et al. (2004). 3These include Multi-Component Tree-Adjoining Grammar, Lin</context>
</contexts>
<marker>Boullier, 1998</marker>
<rawString>Boullier, Pierre. 1998. Proposal for a natural language processing syntactic backbone. Rapport de Recherche 3342, INRIA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Pierre Boullier</author>
</authors>
<date>1999</date>
<booktitle>On TAG and Multicomponent TAG Parsing. Rapport de Recherche 3668, INRIA.</booktitle>
<contexts>
<context position="4696" citStr="Boullier, 1999" startWordPosition="673" endWordPosition="674">espect to these. In section 4, we compare this system with existing approaches for parsing and more generally for grammar engineering. Finally, in section 5, we conclude by presenting future work. 2 Range Concatenation Grammar as a pivot formalism The main idea underlying TuLiPA is to use RCG as a pivot formalism for RCG has appealing formal properties (e.g., a generative capacity lying beyond Linear Context Free Rewriting Systems and a polynomial parsing complexity) and there exist efficient algorithms, for RCG parsing (Boullier, 2000) and for grammar transformation into RCG (Boullier, 1998; Boullier, 1999). Parsing with TuLiPA is thus a 3-step process: 1. The input tree-based grammar is converted into an RCG (using the algorithm of Kallmeyer and Parmentier (2008) when dealing with TT-MCTAG). 2. The resulting RCG is used for parsing the input string using an extension of the parsing algorithm of Boullier (2000). 3. The RCG derivation structure is interpreted to extract the derivation and derived trees with respect to the input grammar. The use of RCG as a pivot formalism, and thus of an RCG parser as a core component of the system, leads to a modular architecture. In turns, this makes TuLiPA mor</context>
</contexts>
<marker>Boullier, 1999</marker>
<rawString>Boullier, Pierre. 1999. On TAG and Multicomponent TAG Parsing. Rapport de Recherche 3668, INRIA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Pierre Boullier</author>
</authors>
<title>Range concatenation grammars.</title>
<date>2000</date>
<booktitle>In Proceedings of the International Workshop on Parsing Technologies (IWPT</booktitle>
<pages>53--64</pages>
<location>Trento, Italy.</location>
<contexts>
<context position="2672" citStr="Boullier, 2000" startWordPosition="363" endWordPosition="364">. between formalisms (e.g., in terms of parsing complexity in practice), and would allow for a better sharing of resources (e.g., having a common lexicon, from which different features would be extracted depending on the target formalism). In this context, we present a parsing environment relying on a general architecture that can be used for parsing with mildly context-sensitive (MCS) formalisms1 (Joshi, 1987). Its underlying idea is to use Range Concatenation Grammar (RCG) as a pivot formalism, for RCG has been shown to strictly include MCS languages while being parsable in polynomial time (Boullier, 2000). Currently, this architecture supports tree-based grammars (Tree-Adjoining Grammars and MultiComponent Tree-Adjoining Grammars with Tree Tuples (Lichte, 2007)). More precisely, treebased grammars are first converted into equivalent RCGs, which are then used for parsing. The result of RCG parsing is finally interpreted to extract a derivation structure for the input grammar, as well as to perform additional processings (e.g., semantic calculus, extraction of dependency views). The paper is structured as follows. In section 2, we present the architecture of the TuLiPA parsing environment and sh</context>
<context position="4623" citStr="Boullier, 2000" startWordPosition="663" endWordPosition="664">r Engineering Across Frameworks, pages 1–8 Manchester, August 2008 with respect to these. In section 4, we compare this system with existing approaches for parsing and more generally for grammar engineering. Finally, in section 5, we conclude by presenting future work. 2 Range Concatenation Grammar as a pivot formalism The main idea underlying TuLiPA is to use RCG as a pivot formalism for RCG has appealing formal properties (e.g., a generative capacity lying beyond Linear Context Free Rewriting Systems and a polynomial parsing complexity) and there exist efficient algorithms, for RCG parsing (Boullier, 2000) and for grammar transformation into RCG (Boullier, 1998; Boullier, 1999). Parsing with TuLiPA is thus a 3-step process: 1. The input tree-based grammar is converted into an RCG (using the algorithm of Kallmeyer and Parmentier (2008) when dealing with TT-MCTAG). 2. The resulting RCG is used for parsing the input string using an extension of the parsing algorithm of Boullier (2000). 3. The RCG derivation structure is interpreted to extract the derivation and derived trees with respect to the input grammar. The use of RCG as a pivot formalism, and thus of an RCG parser as a core component of the</context>
</contexts>
<marker>Boullier, 2000</marker>
<rawString>Boullier, Pierre. 2000. Range concatenation grammars. In Proceedings of the International Workshop on Parsing Technologies (IWPT 2000), pages 53–64, Trento, Italy.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Benoit Crabb´e</author>
</authors>
<title>Grammatical development with XMG.</title>
<date>2005</date>
<journal>LACL</journal>
<booktitle>In Proceedings of the conference on Logical Aspects of Computational Linguistics</booktitle>
<volume>05</volume>
<pages>84--100</pages>
<location>Bordeaux, France.</location>
<marker>Crabb´e, 2005</marker>
<rawString>Crabb´e, Benoit. 2005. Grammatical development with XMG. In Proceedings of the conference on Logical Aspects of Computational Linguistics 2005 (LACL 05), pages 84–100, Bordeaux, France.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Denys Duchier</author>
<author>Joseph Le Roux</author>
<author>Yannick Parmentier</author>
</authors>
<title>The Metagrammar Compiler: An NLP Application with a Multi-paradigm Architecture.</title>
<date>2004</date>
<booktitle>In Proceedings of the 2nd International Mozart/Oz Conference (MOZ’2004),</booktitle>
<pages>175--187</pages>
<location>Charleroi, Belgium.</location>
<marker>Duchier, Le Roux, Parmentier, 2004</marker>
<rawString>Duchier, Denys, Joseph Le Roux, and Yannick Parmentier. 2004. The Metagrammar Compiler: An NLP Application with a Multi-paradigm Architecture. In Proceedings of the 2nd International Mozart/Oz Conference (MOZ’2004), pages 175–187, Charleroi, Belgium.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gregor Erbach</author>
</authors>
<title>Tools for grammar engineering.</title>
<date>1992</date>
<booktitle>In 3rd Conference on Applied Natural Language Processing,</booktitle>
<pages>243--244</pages>
<location>Trento, Italy.</location>
<contexts>
<context position="1609" citStr="Erbach, 1992" startWordPosition="205" endWordPosition="206">ars (namely Tree-Adjoining Grammars (TAG) and Multi-Component TreeAdjoining Grammars with Tree Tuples (TT-MCTAG)) and allows computation not only of syntactic structures, but also of the corresponding semantic representations. It is used for the development of a tree-based grammar for German. 1 Introduction Grammars and lexicons represent important linguistic resources for many NLP applications, among which one may cite dialog systems, automatic summarization or machine translation. Developing such resources is known to be a complex task that needs useful tools such as parsers and generators (Erbach, 1992). Furthermore, there is a lack of a common framework allowing for multi-formalism grammar engineering. Thus, many formalisms have been proposed to model natural language, each coming with specific implementations. Having a common framework would facilitate the comparison © 2008. Licensed under the Creative Commons Attribution-Noncommercial-Share Alike 3.0 Unported license (http://creativecommons.org/licenses/by-nc-sa/3.0/). Some rights reserved. between formalisms (e.g., in terms of parsing complexity in practice), and would allow for a better sharing of resources (e.g., having a common lexico</context>
<context position="11405" citStr="Erbach (1992)" startWordPosition="1770" endWordPosition="1771"> same lexicon format, and if not what kind of general lexicon management module should be added to the parser (in particular to deal with morphology). 3 Towards a complete grammar engineering environment So far, we have seen how to use a generic parsing architecture relying on RCG to parse different formalisms. In this section, we adopt a broader view and enumerate some requirements for a linguistic resource development environment. We also see to what extent these requirements are fulfilled (or partially fulfilled) within the TuLiPA system. 3.1 Grammar engineering with TuLiPA As advocated by Erbach (1992), grammar engineering needs “tools for testing the grammar with respect to consistency, coverage, overgeneration and accuracy”. These characteristics may be taken into account by different interacting software. Thus, consistency can be checked by a semiautomatic grammar production device, such as the XMG system of Duchier et al. (2004). Overgeneration is mainly checked by a generator (or by a parser with adequate test suites), and coverage and accuracy by a parser. In our case, the TuLiPA system provides an entry point for using a grammar production system (and a lexicon conversion 3 tool intr</context>
</contexts>
<marker>Erbach, 1992</marker>
<rawString>Erbach, Gregor. 1992. Tools for grammar engineering. In 3rd Conference on Applied Natural Language Processing, pages 243–244, Trento, Italy.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Claire Gardent</author>
<author>Laura Kallmeyer</author>
</authors>
<title>Semantic Construction in FTAG.</title>
<date>2003</date>
<booktitle>In Proceedings of the Conference of the European chapter of the Association for Computational Linguistics (EACL</booktitle>
<pages>123--130</pages>
<location>Budapest, Hungary.</location>
<contexts>
<context position="5656" citStr="Gardent and Kallmeyer (2003)" startWordPosition="829" endWordPosition="833">n structure is interpreted to extract the derivation and derived trees with respect to the input grammar. The use of RCG as a pivot formalism, and thus of an RCG parser as a core component of the system, leads to a modular architecture. In turns, this makes TuLiPA more easily extensible, either in terms of functionalities, or in terms of formalisms. 2.1 Adding functionalities to the parsing environment As an illustration of TuLiPA’s extensibility, one may consider two extensions applied to the system recently. First, a semantic calculus using the syntax/semantics interface for TAG proposed by Gardent and Kallmeyer (2003) has been added. This interface associates each tree with flat semantic formulas. The arguments of these formulas are unification variables, which are co-indexed with features labelling the nodes of the syntactic tree. During classical TAG derivation, trees are combined, triggering unifications of the feature structures labelling nodes. As a result of these unifications, the arguments of the semantic formulas are unified (see Fig. 1). S NP↓- VP NPS V NP↓y NP, John loves Mary name(j,john) love(t,y) name(m,mary) ❀ love(j,m),name(j,john),name(m,mary) Figure 1: Semantic calculus in Feature-Based T</context>
</contexts>
<marker>Gardent, Kallmeyer, 2003</marker>
<rawString>Gardent, Claire and Laura Kallmeyer. 2003. Semantic Construction in FTAG. In Proceedings of the Conference of the European chapter of the Association for Computational Linguistics (EACL 2003), pages 123–130, Budapest, Hungary.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Claire Gardent</author>
<author>Yannick Parmentier</author>
</authors>
<title>Semtag: a platform for specifying tree adjoining grammars and performing tag-based semantic construction.</title>
<date>2007</date>
<booktitle>In Proceedings of the International Conference of the Association for Computational Linguistics (ACL 2007), Companion Volume Proceedings of the Demo and Poster Sessions,</booktitle>
<pages>13--16</pages>
<location>Prague, Czech Republic.</location>
<contexts>
<context position="20278" citStr="Gardent and Parmentier, 2007" startWordPosition="3131" endWordPosition="3134">r has been used to implement efficient parsing algorithms for several formalisms, including TAG and RCG. Unfortunately, it does not include any built-in GUI and requires a good knowledge of the GNU build tools to compile parsers. This makes it relatively difficult to use. DyALog’s main quality lies in its efficiency in terms of parsing time and its capacity to handle very large resources. Unlike TuLiPA, it does not compute semantic representations. The closest approach to TuLiPA corresponds to the SemTAG system13, which extends TAG parsers compiled with DyALog with a semantic calculus module (Gardent and Parmentier, 2007). Unlike TuLiPA, this system only supports TAG, and does not provide any graphical output allowing to easily check the result of parsing. Note that, for grammar designers mainly interested in TAG, SemTAG and TuLiPA can be seen as complementary tools. Indeed, one may use TuLiPA to develop the grammar and check specific syntactic structures thanks to its intuitive parsing environment. Once the grammar is stable, one may use SemTAG in batch processing to parse corpuses and build semantic representations using large grammars. This combination of these 2 systems is made easier by the fact that both</context>
</contexts>
<marker>Gardent, Parmentier, 2007</marker>
<rawString>Gardent, Claire and Yannick Parmentier. 2007. Semtag: a platform for specifying tree adjoining grammars and performing tag-based semantic construction. In Proceedings of the International Conference of the Association for Computational Linguistics (ACL 2007), Companion Volume Proceedings of the Demo and Poster Sessions, pages 13–16, Prague, Czech Republic.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Aravind K Joshi</author>
</authors>
<title>An introduction to Tree Adjoining Grammars.</title>
<date>1987</date>
<booktitle>Mathematics ofLanguage,</booktitle>
<pages>87--114</pages>
<editor>In Manaster-Ramer, A., editor,</editor>
<publisher>John Benjamins,</publisher>
<location>Amsterdam.</location>
<contexts>
<context position="2471" citStr="Joshi, 1987" startWordPosition="329" endWordPosition="330">litate the comparison © 2008. Licensed under the Creative Commons Attribution-Noncommercial-Share Alike 3.0 Unported license (http://creativecommons.org/licenses/by-nc-sa/3.0/). Some rights reserved. between formalisms (e.g., in terms of parsing complexity in practice), and would allow for a better sharing of resources (e.g., having a common lexicon, from which different features would be extracted depending on the target formalism). In this context, we present a parsing environment relying on a general architecture that can be used for parsing with mildly context-sensitive (MCS) formalisms1 (Joshi, 1987). Its underlying idea is to use Range Concatenation Grammar (RCG) as a pivot formalism, for RCG has been shown to strictly include MCS languages while being parsable in polynomial time (Boullier, 2000). Currently, this architecture supports tree-based grammars (Tree-Adjoining Grammars and MultiComponent Tree-Adjoining Grammars with Tree Tuples (Lichte, 2007)). More precisely, treebased grammars are first converted into equivalent RCGs, which are then used for parsing. The result of RCG parsing is finally interpreted to extract a derivation structure for the input grammar, as well as to perform</context>
</contexts>
<marker>Joshi, 1987</marker>
<rawString>Joshi, Aravind K. 1987. An introduction to Tree Adjoining Grammars. In Manaster-Ramer, A., editor, Mathematics ofLanguage, pages 87–114. John Benjamins, Amsterdam.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Laura Kallmeyer</author>
<author>Yannick Parmentier</author>
</authors>
<title>On the relation between Multicomponent Tree Adjoining Grammars with Tree Tuples (TT-MCTAG) and Range Concatenation Grammars (RCG).</title>
<date>2008</date>
<booktitle>In Proceedings of the 2nd International Conference on Language and Automata Theories and Applications (LATA</booktitle>
<pages>277--288</pages>
<location>Tarragona,</location>
<contexts>
<context position="4856" citStr="Kallmeyer and Parmentier (2008)" startWordPosition="697" endWordPosition="700">in section 5, we conclude by presenting future work. 2 Range Concatenation Grammar as a pivot formalism The main idea underlying TuLiPA is to use RCG as a pivot formalism for RCG has appealing formal properties (e.g., a generative capacity lying beyond Linear Context Free Rewriting Systems and a polynomial parsing complexity) and there exist efficient algorithms, for RCG parsing (Boullier, 2000) and for grammar transformation into RCG (Boullier, 1998; Boullier, 1999). Parsing with TuLiPA is thus a 3-step process: 1. The input tree-based grammar is converted into an RCG (using the algorithm of Kallmeyer and Parmentier (2008) when dealing with TT-MCTAG). 2. The resulting RCG is used for parsing the input string using an extension of the parsing algorithm of Boullier (2000). 3. The RCG derivation structure is interpreted to extract the derivation and derived trees with respect to the input grammar. The use of RCG as a pivot formalism, and thus of an RCG parser as a core component of the system, leads to a modular architecture. In turns, this makes TuLiPA more easily extensible, either in terms of functionalities, or in terms of formalisms. 2.1 Adding functionalities to the parsing environment As an illustration of </context>
</contexts>
<marker>Kallmeyer, Parmentier, 2008</marker>
<rawString>Kallmeyer, Laura and Yannick Parmentier. 2008. On the relation between Multicomponent Tree Adjoining Grammars with Tree Tuples (TT-MCTAG) and Range Concatenation Grammars (RCG). In Proceedings of the 2nd International Conference on Language and Automata Theories and Applications (LATA 2008), pages 277–288, Tarragona, Spain.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Laura Kallmeyer</author>
<author>Timm Lichte</author>
<author>Wolfgang Maier</author>
<author>Yannick Parmentier</author>
<author>Johannes Dellert</author>
</authors>
<title>Developping an MCTAG for German with an RCGbased Parser.</title>
<date>2008</date>
<booktitle>In Proceedings of the Language, Resource and Evaluation Conference (LREC 2008),</booktitle>
<location>Marrakech, Morocco.</location>
<contexts>
<context position="18833" citStr="Kallmeyer et al., 2008" startWordPosition="2927" endWordPosition="2930">ckage for many platforms). Finally, the TuLiPA eclipse plug-in can be installed easily from eclipse itself. All these tools are released under Free software licenses (either GNU GPL or Eclipse Public License). This environment is being used (i) at the University of T¨ubingen, in the context of the development of a TT-MCTAG for German describing both syntax and semantics, and (ii) at LORIA Nancy, in the development of an XTAG-based metagrammar for English. The German grammar, called GerTT (for German Tree Tuples), is released under a LGPL license for Linguistic Resources11 and is presented in (Kallmeyer et al., 2008). The test-suite currently used to check the grammar is hand-crafted. A more systematic evaluation of the grammar is in preparation, using the Test Suite for Natural Language Processing (Lehmann et al., 1996). 9Seehttp://sourcesup.cru.fr/tulipa. 10See http://www.gecode.org/gecodej. 11See http://infolingu.univ-mlv. fr/DonneesLinguistiques/ Lexiques-Grammaires/lgpllr.html 5 4 Comparison with existing approaches 4.1 Engineering environments for tree-based grammar formalisms To our knowledge, there is currently no available parsing environment for multi-component TAG. Existing grammar engineering </context>
</contexts>
<marker>Kallmeyer, Lichte, Maier, Parmentier, Dellert, 2008</marker>
<rawString>Kallmeyer, Laura, Timm Lichte, Wolfgang Maier, Yannick Parmentier, and Johannes Dellert. 2008. Developping an MCTAG for German with an RCGbased Parser. In Proceedings of the Language, Resource and Evaluation Conference (LREC 2008), Marrakech, Morocco.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Sabine Lehmann</author>
<author>Stephan Oepen</author>
<author>Sylvie RegnierProst</author>
<author>Klaus Netter</author>
<author>Veronika Lux</author>
<author>Judith Klein</author>
<author>Kirsten Falkedal</author>
<author>Frederik Fouvry</author>
<author>Dominique Estival</author>
<author>Eva Dauphin</author>
<author>Herv´e Compagnion</author>
<author>Judith Baur</author>
<author>Lorna Balkan</author>
<author>Doug Arnold</author>
</authors>
<title>TSNLP — Test Suites for Natural Language Processing.</title>
<date>1996</date>
<booktitle>In Proceedings of the International Conference on Computational Linguistics (Coling</booktitle>
<volume>2</volume>
<pages>711--716</pages>
<location>Copenhagen, Denmark.</location>
<contexts>
<context position="19041" citStr="Lehmann et al., 1996" startWordPosition="2961" endWordPosition="2964">This environment is being used (i) at the University of T¨ubingen, in the context of the development of a TT-MCTAG for German describing both syntax and semantics, and (ii) at LORIA Nancy, in the development of an XTAG-based metagrammar for English. The German grammar, called GerTT (for German Tree Tuples), is released under a LGPL license for Linguistic Resources11 and is presented in (Kallmeyer et al., 2008). The test-suite currently used to check the grammar is hand-crafted. A more systematic evaluation of the grammar is in preparation, using the Test Suite for Natural Language Processing (Lehmann et al., 1996). 9Seehttp://sourcesup.cru.fr/tulipa. 10See http://www.gecode.org/gecodej. 11See http://infolingu.univ-mlv. fr/DonneesLinguistiques/ Lexiques-Grammaires/lgpllr.html 5 4 Comparison with existing approaches 4.1 Engineering environments for tree-based grammar formalisms To our knowledge, there is currently no available parsing environment for multi-component TAG. Existing grammar engineering environments for TAG include the DyALog system12 described in Villemonte de la Clergerie (2005). DyALog is a compiler for a logic programming language using tabulation and dynamic programming techniques. This</context>
</contexts>
<marker>Lehmann, Oepen, RegnierProst, Netter, Lux, Klein, Falkedal, Fouvry, Estival, Dauphin, Compagnion, Baur, Balkan, Arnold, 1996</marker>
<rawString>Lehmann, Sabine, Stephan Oepen, Sylvie RegnierProst, Klaus Netter, Veronika Lux, Judith Klein, Kirsten Falkedal, Frederik Fouvry, Dominique Estival, Eva Dauphin, Herv´e Compagnion, Judith Baur, Lorna Balkan, and Doug Arnold. 1996. TSNLP — Test Suites for Natural Language Processing. In Proceedings of the International Conference on Computational Linguistics (Coling 1996), volume 2, pages 711–716, Copenhagen, Denmark.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Timm Lichte</author>
</authors>
<title>An MCTAG with tuples for coherent constructions in German.</title>
<date>2007</date>
<booktitle>In Proceedings of the 12th Conference on Formal Grammar,</booktitle>
<location>Dublin, Ireland.</location>
<contexts>
<context position="2831" citStr="Lichte, 2007" startWordPosition="381" endWordPosition="382">hich different features would be extracted depending on the target formalism). In this context, we present a parsing environment relying on a general architecture that can be used for parsing with mildly context-sensitive (MCS) formalisms1 (Joshi, 1987). Its underlying idea is to use Range Concatenation Grammar (RCG) as a pivot formalism, for RCG has been shown to strictly include MCS languages while being parsable in polynomial time (Boullier, 2000). Currently, this architecture supports tree-based grammars (Tree-Adjoining Grammars and MultiComponent Tree-Adjoining Grammars with Tree Tuples (Lichte, 2007)). More precisely, treebased grammars are first converted into equivalent RCGs, which are then used for parsing. The result of RCG parsing is finally interpreted to extract a derivation structure for the input grammar, as well as to perform additional processings (e.g., semantic calculus, extraction of dependency views). The paper is structured as follows. In section 2, we present the architecture of the TuLiPA parsing environment and show how the use of RCG as a pivot formalism makes it easier to design a modular system that can be extended to support several dimensions (syntax, semantics) an</context>
</contexts>
<marker>Lichte, 2007</marker>
<rawString>Lichte, Timm. 2007. An MCTAG with tuples for coherent constructions in German. In Proceedings of the 12th Conference on Formal Grammar, Dublin, Ireland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Guy Perrier</author>
</authors>
<title>Interaction grammars.</title>
<date>2000</date>
<booktitle>In Proceedings of the International Conference on Computational Linguistics (CoLing</booktitle>
<pages>600--606</pages>
<location>Saarbruecken, Germany.</location>
<contexts>
<context position="21107" citStr="Perrier, 2000" startWordPosition="3270" endWordPosition="3271">can be seen as complementary tools. Indeed, one may use TuLiPA to develop the grammar and check specific syntactic structures thanks to its intuitive parsing environment. Once the grammar is stable, one may use SemTAG in batch processing to parse corpuses and build semantic representations using large grammars. This combination of these 2 systems is made easier by the fact that both use the same input formats (a metagrammar in the XMG language and a text-based lexicon). This approach is the one being adopted for the development of a French TAG equipped with semantics. For Interaction Grammar (Perrier, 2000), there exists an engineering environment gathering the XMG metagrammar compiler and an eLEtrOstatic PARser (LEOPAR).14 This environment is being used to develop an Interaction Grammar for French. TuLiPA’s lexical disambiguation module 12Seehttp://dyalog.gforge.inria.fr 13See http://trac.loria.fr/˜semconst 14See http://www.loria.fr/equipes/ calligramme/leopar/ reuses techniques introduced by LEOPAR. Unlike TuLiPA, LEOPAR does not currently support semantic information. 4.2 Engineering environments for other grammar formalisms For other formalisms, there exist state-of-the-art grammar engineeri</context>
</contexts>
<marker>Perrier, 2000</marker>
<rawString>Perrier, Guy. 2000. Interaction grammars. In Proceedings of the International Conference on Computational Linguistics (CoLing 2000), pages 600–606, Saarbruecken, Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Anders Søgaard</author>
</authors>
<title>Complexity, expressivity and logic of linguistic theories.</title>
<date>2007</date>
<tech>Ph.D. thesis,</tech>
<institution>University of Copenhagen,</institution>
<location>Copenhagen, Denmark.</location>
<contexts>
<context position="9521" citStr="Søgaard (2007)" startWordPosition="1476" endWordPosition="1477">r tree tuples), we avoid predicting incompatible derivations. Note that the time saved by using a polarity-based filter is not negligible, especially when parsing long sentences.2 2.2 Adding formalisms to the parsing environment Of course, the two extensions introduced in the previous section may have been added to other modular architectures as well. The main gain brought by RCG is the possibility to parse not only tree-based grammars, but other formalisms provided they can be encoded into RCG. In our system, only TAG and TT-MCTAG have been considered so far. Nonetheless, Boullier (1998) and Søgaard (2007) have defined transformations into RCG for other mildly context-sensitive formalisms.3 To sum up, the idea would be to keep the core RCG parser, and to extend TuLiPA with a specific conversion module for each targeted formalism. On top of these conversion modules, one should also provide interpretation modules allowing to decode the RCG derivation forest in terms of the input formalism (see Fig. 3). 2An evaluation of the gain brought by this technique when using Interaction Grammar is given by Bonfante et al. (2004). 3These include Multi-Component Tree-Adjoining Grammar, Linear Indexed Grammar</context>
</contexts>
<marker>Søgaard, 2007</marker>
<rawString>Søgaard, Anders. 2007. Complexity, expressivity and logic of linguistic theories. Ph.D. thesis, University of Copenhagen, Copenhagen, Denmark.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Villemonte de la Clergerie</author>
<author>´Eric</author>
</authors>
<title>DyALog: a tabular logic programming based environment for NLP.</title>
<date>2005</date>
<booktitle>In Proceedings of the workshop on Constraint Satisfaction for Language Processing (CSLP</booktitle>
<pages>18--33</pages>
<location>Barcelona,</location>
<marker>Clergerie, ´Eric, 2005</marker>
<rawString>Villemonte de la Clergerie, ´Eric. 2005. DyALog: a tabular logic programming based environment for NLP. In Proceedings of the workshop on Constraint Satisfaction for Language Processing (CSLP 2005), pages 18–33, Barcelona, Spain.</rawString>
</citation>
<citation valid="true">
<authors>
<author>XTAG-Research-Group</author>
</authors>
<title>A lexicalized tree adjoining grammar for english.</title>
<date>2001</date>
<tech>Technical Report IRCS-01-03,</tech>
<institution>IRCS, University of Pennsylvania.</institution>
<note>Available at http://www.cis.upenn. edu/˜xtag/gramrelease.html.</note>
<marker>XTAG-Research-Group, 2001</marker>
<rawString>XTAG-Research-Group. 2001. A lexicalized tree adjoining grammar for english. Technical Report IRCS-01-03, IRCS, University of Pennsylvania. Available at http://www.cis.upenn. edu/˜xtag/gramrelease.html.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>