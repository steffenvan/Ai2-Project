<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<sectionHeader confidence="0.341584" genericHeader="abstract">
PARSING AS NATURAL DEDUCTION
</sectionHeader>
<address confidence="0.515799">
Esther Konig
Universitat Stuttgart
Institut fiir Maschinelle Sprachverarbeitung,
Keplerstrasse 17, D-7000 Stuttgart 1, FRG
</address>
<sectionHeader confidence="0.952497" genericHeader="keywords">
Abstract
</sectionHeader>
<bodyText confidence="0.9999700625">
The logic behind parsers for categorial grammars
can be formalized in several different ways. Lam-
bek Calculus (LC) constitutes an example for a na-
tural deduction&apos; style parsing method.
In natural language processing, the task of a
parser usually consists in finding derivations for all
different readings of a sentence. The original Lam-
bek Calculus, when it is used as a parser/theorem
prover, has the undesirable property of allowing for
the derivation of more than one proof for a reading
of a sentence, in the general case.
In order to overcome this inconvenience and to
turn Lambek Calculus into a reasonable parsing
method, we show the existence of &amp;quot;relative&amp;quot; normal
form proof trees and make use of their properties to
constrain the proof procedure in the desired way.
</bodyText>
<sectionHeader confidence="0.999092" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.987396981818182">
Sophisticated techniques have been developed for
the implementation of parsers for (augmented) con-
text-free grammars. [Pereira/Warren 19831 gave a
characterization of these parsers as being resolu-
tion based theorem provers. Resolution might be
taken as an instance of Hilbert-style theorem pro-
ving, where there is one inference rule (e.g. Modus
Ponens or some other kind of Cut Rule) which al-
lows for deriving theorems from a set of axioms.
In the case of parsing, the grammar rules and the
lexicon would be the axioms.
When categorial grammars were discovered for
computational linguistics, the most obvious way
to design parsers for categorial grammars seemed
1&amp;quot;natural deduction&amp;quot; is used here in its broad sense, i.e.
natural deduction as opposed to Hilbert-style deduction
to apply the existing methods: The few combi-
nation rules and the lexicon constitute the set of
axioms, from which theorems are derived by a
resolution rule. However, this strategy leads to
unsatisfactory results, in so far as extended ca-
tegorial grammars, which make use of combina-
tion rules like functional composition and type
raising, provide for a proliferation of derivations
for the same reading of a sentence. This pheno-
menon has been dubbed the spurious ambiguity
problem [Pareschi/Steedman 1987]. One solution
to this problem is to describe normal forms for
equivalent derivations and to use this knowledge
to prune the search space of the parsing process
[Hepple/Morrill 1989].
Other approaches to cope with the problem of
spurious ambiguity take into account the peculari-
ties of categorial grammars compared to grammars
with &amp;quot;context-free skeleton&amp;quot;. One characteristic of
categorial grammars is the shift of information from
the grammar rules into the lexicon: grammar rules
are mere combination schemata whereas syntactic
categories do not have to be atomic items as in the
&amp;quot;context-free&amp;quot; formalisms, but can also be structu-
red objects as well.
The inference rule of a Hilbert-style deduction
system does not refer to the internal structure of
the propositions which it deals with. The alterna-
tive to Hilbert-style deduction is natural deduction
(in the broad sense of the word) which is &amp;quot;natural&amp;quot;
in so far as at least some of the inference rules of
a natural deduction system describe explicitly how
logical operators have to be treated. Therefore na-
tural deduction style proof systems are in principle
good candidates to function as a framework for ca-
tegorial grammar parsers. If one considers catego-
ries as formulae, then a proof system would have
to refer to the operators which are used in those
formulae.
</bodyText>
<page confidence="0.99423">
272
</page>
<bodyText confidence="0.995494794117647">
The natural deduction approach to parsing with
categorial grammars splits up into two general
mainstreams both of which use the Gentzen se-
quent representation to state the corresponding
calculi. The first alternative is to take a general
purpose calculus and propose an adequate transla-
tion of categories into formulae of this logic. An
example for this approach has been carried out
by Pareschi [Pareschi 1988], [Pareschi 1989]. On
the other hand, one might use a specialized cal-
culus. Lambek proposed such a calculus for ca-
tegorial grammar more than three decades ago
[Lambek 1958].
The aim of this paper is to describe how Lam-
bek Calculus can be implemented in such a way
that it serves as an efficient parsing mechanism. To
achieve this goal, the main drawback of the original
Lambek Calculus, which consists of a version of the
&amp;quot;spurious ambiguity problem&amp;quot;, has to be overcome.
In Lambek Calculus, this overgeneration of deriva-
tions is due to the fact that the calculus itself does
not give enough constraints on the order in which
the inference rules have to be applied.
In section 2 of the paper, we present Lambek
Calculus in more detail. Section 3 consists of the
proof for the existence of normal form proof trees
relative to the readings of a sentence. Based on
this result, the parsing mechanism is described in
section 4.
head of a complex category is the head of its value
category. The category in the succedens of a se-
quent is called goal category. The category which
is &amp;quot;decomposed&amp;quot; by an inference rule application is
called current functor.
</bodyText>
<figure confidence="0.802170666666667">
Basic Category:
a constant
Rightward Looking Category:
</figure>
<construct confidence="0.4567925">
if value and argument are categories,
then (value/argument) is a category
</construct>
<subsectionHeader confidence="0.676725">
Leftward Looking Category:
</subsectionHeader>
<bodyText confidence="0.4744635">
if value and argument are categories,
then (value\argument) is a category
</bodyText>
<figureCaption confidence="0.998195">
Figure 1: Definition of categories
</figureCaption>
<equation confidence="0.942983125">
axiom scheme
(axiom) x —+ x
logical rules
(/:left)
(/:right)
(\left)
(\ :right)
T non-empty sequence of categories;
1.1, V sequences; x, y, z categories.
T v U, x , V z
U,(x I y),T, V z
1,
T y)
T y U,x, V z
U,T , (x\y), V -. z
T (x\y)
</equation>
<figureCaption confidence="0.997888">
Figure 2: Cut-free and product-free LC
</figureCaption>
<sectionHeader confidence="0.960812" genericHeader="method">
2 Lambek Calculus
</sectionHeader>
<bodyText confidence="0.968156166666666">
In the following, we restrain ourselves to cut-
free and product-free Lambek Calculus, a calculus
which still allows us to infer infinitely many deri-
ved rules such as Geach-rule, functional composi-
tion etc. [Zielonka 19811. The cut-free and product-
free Lambek Calculus is given in figures 1 and 2.
Be aware of the fact that we did not adopt Lam-
bek&apos;s representation of complex categories. Proofs
in Lambek Calculus can be represented as trees
whose nodes are annotated with sequents. An ex-
ample is given in figure 3. A lexical lookup step
which replaces lexemes by their corresponding ca-
tegories has to precede the actual theorem proving
process. For this reason, the categories in the an-
tecedens of the input sequent will also be called le-
xical categories. We introduce the notions of head,
goal category, and current functor: The head of
a category is its &amp;quot;innermost&amp;quot; value category: The
head of a basic category is the category itself. The
the president of Iceland
np/n, n, (n \n)/np, np np
n, (n\n)/np, np n np np
np np n, n\n n
n —■ n n n
</bodyText>
<figureCaption confidence="0.9948">
Figure 3: Sample proof tree
</figureCaption>
<subsectionHeader confidence="0.997977">
2.1 Unification Lambek Calculus
</subsectionHeader>
<bodyText confidence="0.999965">
Lambek Calculus, as such, is a propositional cal-
culus. There is no room to express additional con-
straints concerning the combination of categories.
Clearly, some kind of feature handling mechanism
is needed to enable the grammar writer to state e.g.
conditions on the agreement of morpho-syntactic
features or to describe control phenomena. For
the reason of linguistic expressiveness and to facili-
tate the description of the parsing algorithm below,
</bodyText>
<page confidence="0.989525">
273
</page>
<bodyText confidence="0.999178476190476">
we extend Lambek Calculus to Unification Lambek
Calculus (ULC).
First, the definition of basic category must be
adapted: a basic category consists of an atomic
category name and feature description. (For the
definition of feature descriptions or feature terms
see [Smolka 1988].) For complex categories, the
same recursive definition applies as before. The
syntax for categories in ULC is given informally in
figure 4 which shows the category of a control verb
like &amp;quot;persuade&amp;quot;. We assume that variable names
for feature descriptions are local to each category
in a sequent. The (/:left)- and (\:left)-inference
rules have to take care of the substitutions which
are involved in handling the variables in the exten-
ded categories (figure 5). Heed that the substitu-
tion function a. has scope over a whole sequent, and
therefore, over a complete subproof, and not only
over a single category. In this way, correct varia-
ble bindings for hypothetic categories, which are
introduced by &amp;quot;right&amp;quot;-rules, are guaranteed.
</bodyText>
<equation confidence="0.502356">
((s([&lt;pred&gt;:persuade])
&lt;subj&gt;:Subj
&lt;obj&gt;:Obj
&lt;vcomp&gt;:VComp])
\np(Subj)
)/(s(VComp)
\np(Obj))
)/np(Obj)
</equation>
<figureCaption confidence="0.989393">
Figure 4: Sample category
</figureCaption>
<figure confidence="0.435913">
T—. y2 a(U, x , V z) a(Y1) = a(Y2)
U, (z I yi), T, V —• z
</figure>
<figureCaption confidence="0.99902">
Figure 5: (/:left)-rule in ULC
</figureCaption>
<sectionHeader confidence="0.978485" genericHeader="method">
3 Normal Proof Trees
</sectionHeader>
<bodyText confidence="0.9998094">
The sentence in figure 3 has two other proofs, which
are listed in figure 6, although one would like to
contribute only one syntactic or semantic reading
to it. In this section, we show that such a set of a
possibly abundant number of proofs for the same
reading of a sequent possesses one distinguished
member which can be regarded as the represen-
tative or the normal form proof tree for this set.
In order to be able to use the notion of a &amp;quot;rea-
ding&amp;quot; more precisely, we undertake the following
definition of structures which determine readings
for our purposes. Because of their similarity to syn-
tax trees as used with context-free grammars, we
also call them &amp;quot;syntax trees&amp;quot; for the sake of sim-
plicity. Since, on the semantic level, the use of a
&amp;quot;left&amp;quot;-rule in Lambek Calculus corresponds to the
functional application of a functor term to some
argument and the &amp;quot;right&amp;quot;-rules are equivalent to
functional abstraction [van Benthem 1986], it is es-
sential that in a syntax tree, a trace for each of
these steps in a derivation be represented. Then it
is guaranteed that the semantic representation of
a sentence can be constructed from a syntax tree
which is annotated by the appropriate partial se-
mantic expressions of whatever semantic represen-
tation language one chooses. Structurally distinct
syntax trees amount to different semantic expres-
sions.
A syntax tree t condenses the information of a
proof for a sequent s in the following way:
</bodyText>
<listItem confidence="0.807819923076923">
1. Labels of single-node trees, are either lexical
categories or arguments of lexical categories.
2. The root of a non-trivial tree has either
(a) one daughter tree whose root is labelled
with the value category of the root&apos;s la-
bel. This case catches the application of
a &amp;quot;right&amp;quot;-inference rule; or
(b) two daughter trees. The label of the root
node is the value category, the label of the
root of one daughter is the functor, and
the label of the root of the other daugh-
ter is the argument category of an appli-
cation of a &amp;quot;left&amp;quot;-inference rule.
</listItem>
<bodyText confidence="0.9977948">
Since the size of a proof for a sequent is cor-
related linearily to the number of operators which
occur in the sequent, different proof trees for the
same sequent do not differ in terms of size - they
are merely structurally distinct. The task of defi-
</bodyText>
<figure confidence="0.909724875">
np/n, n, (n\ n)/np, np np
np np np/n, n, n\ n np
n n np/n, n np
n --0 n np np
np/n, n, (n\n)/np, np np
.np np np/n, n, n\n ---■ np
n, n\n n np np
n n n n
</figure>
<figureCaption confidence="0.999151">
Figure 6: Extra proofs
</figureCaption>
<page confidence="0.985309">
274
</page>
<bodyText confidence="0.999892423076923">
fling those relative normal forms of proofs, which
we are aiming at, amounts to describing proof trees
of a certain structure which can be more easily cor-
related with syntax trees as would possibly be the
case for other proofs of the same set of proofs.
The outline of the proof for the existence of nor-
mal form proof trees in Lambek Calculus is the fol-
lowing: Each proof tree of the set of proof trees for
one reading of a sentence, i.e. a sequent, is map-
ped onto the syntax tree which represents this rea-
ding. By a proof reconstruction procedure (PR),
this syntax tree can be mapped onto exactly one
of the initial proof trees which will be identified as
being the normal form proof tree for that set of
proof trees.
It is obvious that the mapping from proof trees
onto syntax trees (Syntax Tree Construction - SC)
partitions the set of proof trees for all readings of
a sentence into a finite number of disjoint subsets,
i.e. equivalence classes of proof trees. Proof trees
of one of these subsets share the property of ha-
ving the same syntax tree, i.e. reading. Hence, the
single proof tree which is reconstructed from such a
syntax tree can be safely taken as a representative
for the subset which it belongs to. In figure 7, this
argument is restated more formally.
</bodyText>
<figure confidence="0.882326625">
proof syntax normal
trees trees proofs
P11
t 1 P 1 1
Pim
Pnl
• in Pnl
Pns
</figure>
<figureCaption confidence="0.999688">
Figure 7: Outline of the proof for normal forms
</figureCaption>
<bodyText confidence="0.982549945945946">
We want to prove the following theorem:
Theorem 1 The ,set of proofs for a sequent can
be partitioned into equivalence classes according to
their corresponding syntax trees. There is exactly
one proof per equivalence class which can be iden-
tified as its normal proof.
This theorem splits up into two lemmata, the first
of which is:
Lemma 1 For every proof tree, there exists exactly
one syntax tree.
The proof for lemma 1 consists of constructing the
required syntax tree for a given proof tree.
The preparative step of the syntax tree con-
struction procedure SC consists of augmenting le-
xical categories with (partial) syntax trees. Partial
syntax trees are represented by .X-expressions to in-
dicate which subtrees have to be found in order to
make the tree complete. The notation for a cate-
gory c paired with its (partial) syntax tree t is c : I.
A basic category is associated with the tree con-
sisting of one node labelled with the name of the
category.
Complex categories are mapped onto partial
binary syntax trees represented by .\-expressions.
We omit the detailed construction procedure for
partial syntax trees on the lexical level, and give
an example (see fig. 8) and an intuitive characte-
rization instead. Such a partial tree has to be built
up in such a way that it is a &amp;quot;nesting&amp;quot; of functional
applications, i.e. one distinguished leaf is labelled
with the functor category which this tree is associa-
ted with, all other leaves are labelled with variables
bound by A-operators. The list of node labels along
the path from the distinguished node to the root
node must show the &amp;quot;unfolding&amp;quot; of the functor ca-
tegory towards its head category. Such a path is
dubbed projection line.
</bodyText>
<figureCaption confidence="0.995851">
Figure 8: Category and its partial syntax tree
</figureCaption>
<bodyText confidence="0.999833615384615">
On the basis of these augmented categories, the
overall syntax tree can be built up together with
the proof for a sequent. As it has already been
discussed above, a &amp;quot;left&amp;quot;-rule performs a functio-
nal application of a function ti to an argument
expression ta, which we will abbreviate by ti [ta].
&amp;quot;right&amp;quot;-rules turn an expression t„ into a function
(i.e. partial syntax tree) ti = Atatt, by means of
A-abstraction over t a. However, in order to retain
the information on the category of the argument
and on the direction, we use the functor category
itself as the root node label instead of the afore
mentioned .A-expression.
</bodyText>
<equation confidence="0.9653855">
(s\np)/np :
&apos;s\np&apos;
&apos;(s\np)/np&apos; x1 /
AxiAx2
</equation>
<page confidence="0.994267">
275
</page>
<bodyText confidence="0.999978571428571">
The steps for the construction of a syntax tree
along with a proof are encoded as annotations of
the categories in Lambek Calculus (see figure 9).
An example for a result of Syntax Tree Construc-
tion is shown in figure 10 where &amp;quot;input&amp;quot; syntax
trees are listed below the corresponding sequent,
and &amp;quot;output&amp;quot; syntax trees are displayed above their
sequents, if shown at all.
Since there is a one-to-one correspondence bet-
ween proof steps and syntax tree construction
steps, exactly one syntax tree is constructed per
successful proof for a sequent. This leads us to the
next step of the proof for the existence of normal
forms, which is paraphrased by lemma 2.
</bodyText>
<construct confidence="0.905757">
Lemma 2 From every syntax tree, a unique proof
tree can be reconstructed.
</construct>
<bodyText confidence="0.984436">
The proof for this lemma is again a constructive
one: By a recursive traversal of a syntax tree, we
obtain the normal form proof tree. (The formula-
tion of the algorithm does not always properly di-
stinguish between the nodes of a tree and the node
labels.)
</bodyText>
<equation confidence="0.980340166666667">
(axiom) x : t —• x : t
(/:left) T y:t. U, z:t fit,d, V --. z:t
(/:right) (1;707,(rz:ity),(t)
(\left) T U, z:t frt.], V z:t
U,T, (s\y):tf, V z:t
(\right)T rAT07,gy),(t)
</equation>
<bodyText confidence="0.855469666666667">
T non-empty sequence of categories;
11, V sequences; x, y, z categories;
t, ta, tf partial syntax trees.
</bodyText>
<figureCaption confidence="0.980177">
Figure 9: Syntax Tree Construction in LC
</figureCaption>
<subsubsectionHeader confidence="0.604324">
Proof Reconstruction (PR)
</subsubsectionHeader>
<bodyText confidence="0.699278">
Input: A syntax tree t with root node label g.
</bodyText>
<listItem confidence="0.862965666666667">
Output: A proof tree p whose root sequent s with
antecedens A and goal category g, and whose i
daughter proofs pi (i = 0,1,2) are determined by
the following method:
Method:
• If t consists of the single node g, p consists
of an s which is an instantiation of the axiom
scheme with g g. $ has no daughters.
• If g is a complex category x/y resp. x\y and
has one daughter tree ti, the antecedens A is
the list of all leaves of t without the leftmost
resp. the rightmost leaf. $ has one daughter
</listItem>
<bodyText confidence="0.98187">
proof which is determined by applying Proof
Reconstruction to the daughter tree of g.
</bodyText>
<listItem confidence="0.869773888888889">
• Jig is a basic category and has two daughter
trees t1 and t2, then A is the list of all leaves
of t. s has two daughter proof trees pi and
P2. C is the label of the leaf whose projection
line ends at the root g. ti is the sister tree
of this leaf. pi is obtained by applying PR to
t1. p2 is the result of applying PR to t2 which
remains after cutting off the two subtrees C
and ti from t.
</listItem>
<bodyText confidence="0.9995595">
Thus, all proofs of an equivalence class are map-
ped onto one single proof by a composition of the
two functions Syntax Tree Construction and Proof
Reconstruction. 0
</bodyText>
<sectionHeader confidence="0.981739" genericHeader="method">
4 The Parser
</sectionHeader>
<bodyText confidence="0.9999920625">
We showed the existence of relative normal form
proof trees by the detour on syntax trees, assu-
ming that all possible proof trees have been gene-
rated beforehand. This is obviously not the way
one wants to take when parsing a sentence. The
goal is to construct the normal form proof directly.
For this purpose, a description of the properties
which distinguish normal form proofs from non-
normal form proofs is required.
The essence of a proof tree is its nesting of cur-
rent functors which can be regarded as a partial or-
der on the set of current functors occuring in this
specific proof tree. Since the current functors of
two different rule applications might, coincidently,
be the same form of category, obviously some kind
of information is missing which would make all cur-
rent functors of a proof tree (and hence of a syntax
tree) pairwise distinct. This happens by stating
which subsequence the head of the current functor
spans over. As for information on a subsequence,
it is sufficient to know where it starts and where it
ends.
Here is the point where we make use of the ex-
pressiveness of ULC. We do not only add the start
and end position information to the head of a com-
plex category but also to its other basic subcate-
gories, since this information will be used e.g. for
making up subgoals. We make use of obvious oon-
straints among the positional indices of subcatego-
ries of the same category. The category in figure 11
spans from position 2 to 3, its head spans from 1
to 3 if its argument category spans from 1 to 2.
</bodyText>
<page confidence="0.995512">
276
</page>
<table confidence="0.58442075">
whom mary loves &apos;rel&apos;Crell(sInp)&apos;,/sInpVs&apos;Crip&apos;, is\npV(s\np)Inpi, ))))
rel/(s/np), np, (s\np)/np rel
Ax &apos;rel&apos;( x), &apos;np&apos;, AxiAx2&apos;s&apos;( x2, &apos;s\ne( &apos;(s\np)/np&apos;, ))
&apos; s I np1(&apos; s&apos;(&apos; , &apos; s\np&apos;(&apos; (s\np)Ine , )))
np, (s\np)/np s/np rel rel
&apos;np&apos;, Axi Ax2 &apos;s&apos;( x2, is\npi(&apos;(s\np)Inpi, x1))
np, (s\np)/np, np s
&apos;np&apos;, Ax1Ax2 &apos;s&apos;( x2, is\npV(s\np)Ine, xi)), &apos;np&apos;
np—np np, s\np —+ s
&apos;np&apos; Ax2&apos;si(x2,1 s\npV(s\np)Ine, &apos;np&apos;))
np —+ np s —+ s
&apos;np&apos; 1.91(inpi, &apos;s\npV(s\np)/np&apos;, &apos;np&apos;))
</table>
<figureCaption confidence="0.925754">
Figure 10: Sample syntax tree construction
</figureCaption>
<bodyText confidence="0.997038666666667">
The augmentation of categories by their positional
indices is done most efficiently during the lexical
lookup step.
</bodyText>
<equation confidence="0.9915065">
s([&lt;start&gt; : 1, &lt;end&gt; : 3 ])
\np([&lt;start&gt; : 1, &lt;end&gt; : 2])
</equation>
<figureCaption confidence="0.961605">
Figure 11: Category with position features
</figureCaption>
<bodyText confidence="0.894029407407407">
We can now formulate what we have learned
from the Proof Reconstruction (PR) procedure.
Since it works top-down on a syntax tree, the cha-
racteristics of the partial order on current functors
given by their nesting in a proof tree are the follo-
wing
Nesting Constraints:
1 Right-Rule Preference: Complex categories on
the righthand side of the arrow become cur-
rent functors before complex categories on the
lefthand side.
2. Current Functor Unfolding: Once a lefthand
side category is chosen for current functor it
has to be &amp;quot;unfolded&amp;quot; completely, i.e. in the
next inference step, its value category has to
become current functor unless it is a basic ca-
tegory.
3. Goal Criterium: A lefthand side functor ca-
tegory can only become current functor if its
head category is unifiable with the goal cate-
gory of the sequent where it occurs.
Condition 3 is too weak if it is stated on the
background of propositional Lambek Calculus only.
It would allow for proof trees whose nesting of cur-
rent functors does not coincide with the nesting of
current functors in the corresponding syntax tree
(see figure 12).
</bodyText>
<figureCaption confidence="0.826787">
Figure 12: Non-normal form proof
</figureCaption>
<bodyText confidence="0.9979685">
The outline of the parsing/theorem proving al-
gorithm P is:
</bodyText>
<listItem confidence="0.8051734">
• A&apos; sequent is proved if it is an instance of the
axiom scheme.
• Otherwise, choose an inference rule by obey-
ing the nesting constraints and try to prove
the premises of the rule.
</listItem>
<bodyText confidence="0.8279408">
Algorithm P is sound with respect to LC be-
cause it has been derived from LC by adding re-
strictions, and not by relaxing original constraints.
It is also complete with regard to LC, because the
restrictions are just as many as needed to rule out
proof trees of the &amp;quot;spurious ambiguity&amp;quot; kind accor-
ding to theorem 1.
s/s, s/s, s, s\s, s\s s
s/s, s, s\s, s\s s
s, s\s, s\s s
</bodyText>
<page confidence="0.941351">
277
</page>
<subsectionHeader confidence="0.923765">
4.1 Further Improvements
</subsectionHeader>
<bodyText confidence="0.9999685">
The performance of the parser/theorem prover can
be improved further by adding at least the two fol-
lowing ingredients:
The positional indices can help to decide where
sequences in the &amp;quot;left&amp;quot;-rules have to be split up to
form the appropriate subsequences of the premises.
In [van Benthem 1986], it was observed that
theorems in LC possess a so-called count invariant,
which can be used to filter out unpromising sugge-
stions for (sub-)proofs during the inference process.
</bodyText>
<sectionHeader confidence="0.9993" genericHeader="conclusions">
5 Conclusion
</sectionHeader>
<bodyText confidence="0.999973925925926">
The cut-free and product-free part of Lambek Cal-
culus has been augmented by certain constraints in
order to yield only normal form proofs, i.e. only one
proof per &amp;quot;reading&amp;quot; of a sentence. Thus, theorem
provers for Lambek Calculus become realistic tools
to be employed as parsers for categorial grammar.
General efficiency considerations would be of in-
terest. Unconstrained Lambek Calculus seems to
be absolutely inefficient, i.e. exponential. So far, no
results are known as to how the use of the nesting
constraints and the count invariant filter systema-
tically affect the complexity. At least intuitively,
it seems clear that their effects are drastic, because
due to the former, considerably fewer proofs are ge-
nerated at all, and due to the latter, substantially
fewer irrelevant sub-proofs are pursued.
From a linguistic standpoint, for example, the
following questions have to be discussed: How does
Lambek Calculus interact with a sophisticated le-
xicon containing e.g. lexical rules? Which would
be linguistically desirable extensions of the infe-
rence rule system that would not throw over the
properties (e.g. normal form proof) of the original
Lambek Calculus?
An implementation of the normal form theorem
prover is currently being used for experimentation
concerning these questions.
</bodyText>
<sectionHeader confidence="0.999395" genericHeader="acknowledgments">
6 Acknowledgements
</sectionHeader>
<bodyText confidence="0.997998875">
The research reported in this paper is supported
by the LILOG project, and a doctoral fellowship,
both from IBM Deutschland GmbH, and by the
Esprit Basic Research Action Project 3175 (DY-
ANA). I thank Jochen DOrre, Glyn Morrill, Remo
Pareschi, and Henk Zeevat for discussion and criti-
cism, and Fiona McKinnon for proof-reading. All
errors are my own.
</bodyText>
<sectionHeader confidence="0.999019" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.9999703">
[Calder/Klein/Zeevat 1988] Calder, J.; E. Klein
and H. Zeevat(1988): Unification Categorial
Grammar: A Concise, Extendable Grammar for
Natural Language Processing. In: Proceedings
of the 12th International Conference Computa-
tional Linguistics, Budapest.
[Gallier 1986] Gallier, J.H. (1986): Logic for Com-
puter Science. Foundations of Automatic Theo-
rem Proving. Harper and Row, New York.
[Hepple/Morrill 1989] Hepple, M. and G. Morrill
(1989): Parsing and derivational equivalence. In:
Proceedings of the Association for Computatio-
nal Linguistics, European Chapter, Manchester,
UK.
[Lambek 1958] Lambek, J. (1958): The mathe-
matics of sentence structure. In: Amer. Math.
Monthly 65, 154-170.
[Moortgat 1988] Moortgat, M. (1988): Categorial
Investigations. Logical and Linguistic Aspects of
the Lambek Calculus. Foris Publications.
[Pareschi 1988] Pareschi, R. (1988): A Definite
Clause Version of Categorial Grammar. In: Proc.
of the 26th Annual Meeting of the Association
for Computational Linguistics. Buffalo, N.Y.
[Pareschi 1989] Pareschi, R. (1989): Type-Driven
Natural Language Analysis. Dissertation, Uni-
versity of Edinburgh.
[Pareschi/Steedman 1987] Pareschi, R. and M.
Steedman (1987): A Lazy Way to Chart-Parse
with Categorial Grammars. In: Proc. 25th An-
nual Meeting of the Association for Computatio-
nal Linguistics, Stanford; 81-88.
[Pereira/Warren 1983] Pereira, F.C.N and D.H.D.
Warren (1983): Parsing as Deduction. In: Pro-
ceedings of the 21st Annual Meeting of the As-
sociation of Computational Linguistics, Boston;
137-144.
[Smolka 1988] Smolka, G. (1988): A Feature Logic
with Subsorts. Lilog-Report 33, IBM Deutsch-
land GmbH, Stuttgart.
</reference>
<page confidence="0.966337">
278
</page>
<reference confidence="0.999891818181818">
[Uszkoreit 1986] Uszkoreit, H. (1986): Categorial
Unification Grammar. In: Proceedings of the
11th International Conference on Computational
Linguistics, Bonn.
[van Benthem 1986] Benthem, J. v. (1986): Essays
In Logical Semantics. Reidel, Dordrecht.
[Zielonka 1981] Zielonka, W. (1981): Axiomatiza-
bility of Ajdukiewicz-Lambek Calculus by Me-
ans of Cancellation Schemes. In: Zeitschrift fiir
mathematische Logik und Grundlagen der Ma-
thematik, 27, 215-224.
</reference>
<page confidence="0.998567">
279
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.909427">
<title confidence="0.999619">PARSING AS NATURAL DEDUCTION</title>
<author confidence="0.999917">Esther Konig</author>
<affiliation confidence="0.9986275">Universitat Stuttgart Institut fiir Maschinelle Sprachverarbeitung,</affiliation>
<address confidence="0.921055">Keplerstrasse 17, D-7000 Stuttgart 1, FRG</address>
<abstract confidence="0.999345823529412">The logic behind parsers for categorial grammars can be formalized in several different ways. Lambek Calculus (LC) constitutes an example for a natural deduction&apos; style parsing method. In natural language processing, the task of a parser usually consists in finding derivations for all different readings of a sentence. The original Lambek Calculus, when it is used as a parser/theorem prover, has the undesirable property of allowing for the derivation of more than one proof for a reading of a sentence, in the general case. In order to overcome this inconvenience and to turn Lambek Calculus into a reasonable parsing method, we show the existence of &amp;quot;relative&amp;quot; normal form proof trees and make use of their properties to constrain the proof procedure in the desired way.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<authors>
<author>J Calder</author>
<author>E Klein</author>
<author>H Zeevat</author>
</authors>
<title>Unification Categorial Grammar: A Concise, Extendable Grammar for Natural Language Processing. In:</title>
<booktitle>Proceedings of the 12th International Conference Computational Linguistics,</booktitle>
<location>Budapest.</location>
<marker>[Calder/Klein/Zeevat 1988]</marker>
<rawString>Calder, J.; E. Klein and H. Zeevat(1988): Unification Categorial Grammar: A Concise, Extendable Grammar for Natural Language Processing. In: Proceedings of the 12th International Conference Computational Linguistics, Budapest.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J H Gallier</author>
</authors>
<title>Logic for Computer Science. Foundations of Automatic Theorem Proving. Harper and Row,</title>
<date>1986</date>
<location>New York.</location>
<marker>[Gallier 1986]</marker>
<rawString>Gallier, J.H. (1986): Logic for Computer Science. Foundations of Automatic Theorem Proving. Harper and Row, New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Hepple</author>
<author>G Morrill</author>
</authors>
<title>Parsing and derivational equivalence. In:</title>
<date>1989</date>
<booktitle>Proceedings of the Association for Computational Linguistics, European Chapter,</booktitle>
<location>Manchester, UK.</location>
<marker>[Hepple/Morrill 1989]</marker>
<rawString>Hepple, M. and G. Morrill (1989): Parsing and derivational equivalence. In: Proceedings of the Association for Computational Linguistics, European Chapter, Manchester, UK.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Lambek</author>
</authors>
<title>The mathematics of sentence structure.</title>
<date>1958</date>
<journal>In: Amer. Math. Monthly</journal>
<volume>65</volume>
<pages>154--170</pages>
<marker>[Lambek 1958]</marker>
<rawString>Lambek, J. (1958): The mathematics of sentence structure. In: Amer. Math. Monthly 65, 154-170.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Moortgat</author>
</authors>
<title>Categorial Investigations. Logical and Linguistic Aspects of the Lambek Calculus.</title>
<date>1988</date>
<publisher>Foris Publications.</publisher>
<marker>[Moortgat 1988]</marker>
<rawString>Moortgat, M. (1988): Categorial Investigations. Logical and Linguistic Aspects of the Lambek Calculus. Foris Publications.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Pareschi</author>
</authors>
<title>A Definite Clause Version of Categorial Grammar. In:</title>
<date>1988</date>
<booktitle>Proc. of the 26th Annual Meeting of the Association for Computational Linguistics.</booktitle>
<location>Buffalo, N.Y.</location>
<marker>[Pareschi 1988]</marker>
<rawString>Pareschi, R. (1988): A Definite Clause Version of Categorial Grammar. In: Proc. of the 26th Annual Meeting of the Association for Computational Linguistics. Buffalo, N.Y.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Pareschi</author>
</authors>
<title>Type-Driven Natural Language Analysis. Dissertation,</title>
<date>1989</date>
<institution>University of Edinburgh.</institution>
<marker>[Pareschi 1989]</marker>
<rawString>Pareschi, R. (1989): Type-Driven Natural Language Analysis. Dissertation, University of Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Pareschi</author>
<author>M Steedman</author>
</authors>
<title>A Lazy Way to Chart-Parse with Categorial Grammars. In:</title>
<date>1987</date>
<booktitle>Proc. 25th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>81--88</pages>
<location>Stanford;</location>
<marker>[Pareschi/Steedman 1987]</marker>
<rawString>Pareschi, R. and M. Steedman (1987): A Lazy Way to Chart-Parse with Categorial Grammars. In: Proc. 25th Annual Meeting of the Association for Computational Linguistics, Stanford; 81-88.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F C N Pereira</author>
<author>D H D Warren</author>
</authors>
<title>Parsing as Deduction. In:</title>
<date>1983</date>
<booktitle>Proceedings of the 21st Annual Meeting of the Association of Computational Linguistics,</booktitle>
<pages>137--144</pages>
<location>Boston;</location>
<marker>[Pereira/Warren 1983]</marker>
<rawString>Pereira, F.C.N and D.H.D. Warren (1983): Parsing as Deduction. In: Proceedings of the 21st Annual Meeting of the Association of Computational Linguistics, Boston; 137-144.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Smolka</author>
</authors>
<title>A Feature Logic with Subsorts.</title>
<date>1988</date>
<booktitle>Lilog-Report 33, IBM Deutschland GmbH,</booktitle>
<location>Stuttgart.</location>
<marker>[Smolka 1988]</marker>
<rawString>Smolka, G. (1988): A Feature Logic with Subsorts. Lilog-Report 33, IBM Deutschland GmbH, Stuttgart.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Uszkoreit</author>
</authors>
<title>Categorial Unification Grammar. In:</title>
<date>1986</date>
<booktitle>Proceedings of the 11th International Conference on Computational Linguistics,</booktitle>
<location>Bonn.</location>
<marker>[Uszkoreit 1986]</marker>
<rawString>Uszkoreit, H. (1986): Categorial Unification Grammar. In: Proceedings of the 11th International Conference on Computational Linguistics, Bonn.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J v Benthem</author>
</authors>
<title>Essays In Logical Semantics.</title>
<date>1986</date>
<location>Reidel, Dordrecht.</location>
<marker>[van Benthem 1986]</marker>
<rawString>Benthem, J. v. (1986): Essays In Logical Semantics. Reidel, Dordrecht.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W Zielonka</author>
</authors>
<title>Axiomatizability of Ajdukiewicz-Lambek Calculus by Means of Cancellation Schemes. In:</title>
<date>1981</date>
<booktitle>Zeitschrift fiir mathematische Logik und Grundlagen der Mathematik,</booktitle>
<volume>27</volume>
<pages>215--224</pages>
<marker>[Zielonka 1981]</marker>
<rawString>Zielonka, W. (1981): Axiomatizability of Ajdukiewicz-Lambek Calculus by Means of Cancellation Schemes. In: Zeitschrift fiir mathematische Logik und Grundlagen der Mathematik, 27, 215-224.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>