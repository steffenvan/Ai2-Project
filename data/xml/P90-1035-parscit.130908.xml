<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000008">
<sectionHeader confidence="0.562936" genericHeader="abstract">
DETERMINISTIC LEFT TO RIGHT PARSING OF
TREE ADJOINING LANGUAGES*
</sectionHeader>
<author confidence="0.985216">
Yves Schabes
</author>
<affiliation confidence="0.935487333333333">
Depi of Computer &amp; Information Science
University of Pennsylvania
Philadelphia, PA 19104-089, USA
</affiliation>
<email confidence="0.991931">
schabes@linc.cis.upenn.edu
</email>
<author confidence="0.985179">
K. Vijay-Shanker
</author>
<affiliation confidence="0.859750666666667">
Dept. of Computer &amp; Information Science
University of Delaware
Newark, DE 19716, USA
</affiliation>
<email confidence="0.996556">
vijay@udel.edu
</email>
<sectionHeader confidence="0.995621" genericHeader="introduction">
Abstract
</sectionHeader>
<bodyText confidence="0.99995955">
We define a set of deterministic bottom-up left to right
parsers which analyze a subset of Tree Adjoining Lan-
guages. The LR parsing strategy for Context Free
Grammars is extended to Tree Adjoining Grammars
(TAGs). We use a machine, called Bottom-up Embed-
ded Push Down Automaton (BEPDA), that recognizes
in a bottom-up fashion the set of Tree Adjoining Lan-
guages (and exactly this set). Each parser consists of a
finite state control that drives the moves of a Bottom-up
Embedded Pushdown Automaton. The parsers handle
deterministically some context-sensitive Tree Adjoining
Languages.
In this paper, we informally describe the BEPDA then
given a parsing table, we explain the LR parsing algo-
rithm. We then show how to construct an LR(0) parsing
table (no lookahead). An example of a context-sensitive
language recognized deterministically is given. Then,
we explain informally the construction of SLR(1) pars-
ing tables for BEPDA. We conclude with a discussion
of our parsing method and current work.
</bodyText>
<sectionHeader confidence="0.999131" genericHeader="method">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999893">
LR(k) parsers for Context Free Grammars (Knuth, 1965)
consist of a finite state control (constructed given a CFG)
that drives deterministically with k lookahead symbols
a push down stack, while scanning the input from left
to right. It has been shown that they recognize exactly
the set of languages recognized by deterministic push
down automata. LR(k) parsers for CFGs have been
proven useful for compilers as well as recently for nat-
ural language processing. For natural language process-
ing, although LR(k) parsers are not powerful enough,
</bodyText>
<footnote confidence="0.7497815">
&amp;quot;The first author is partially supported by Darpa grant N0014-85-
1(0018, ARO grant DAAL03-89-C-0031PRI NSF grant-1R184-10413
A02. We are extremely grateful to Bernard Lang and David Weir for
their valuable suggestions.
</footnote>
<bodyText confidence="0.99483225">
conflicts between multiple choices are solved by pseudo-
parallelism (Lang, 1974, Tortilla, 1987). This gives rise
to a class of powerful yet efficient parsers for natural
languages. It is in this context that we study determin-
istic (LR(k)-style) parsing of TAGs.
The set of Tree Adjoining Languages is a strict su-
perset of the set of Context Free Languages (CFLs).
For example, the cross serial dependency construction
in Dutch can be generated by a TAG. I Walters (1970),
R6vesz (1971), Turnbull and Lee (1979) investigated
deterministic parsing of the class of context-sensitive
languages. However they used Turing machines which
recognize languages much more powerful than Tree Ad-
joining Languages. So far no deterministic bottom-up
parser has been proposed for any member of the class
of the so-called &amp;quot;mildly context sensitive&amp;quot; formalisms
(Joshi, 1985) in which Tree Adjoining Grammars fal1.2
Since the set of Tree Adjoining Languages (TALs) is a
strict superset of the set of Context Free Languages, in
order to define LR-type parsers for TAGs, we need to
use a more powerful configuration then a finite state au-
tomaton driving a push down stack. We investigate the
design of deterministic left to right bottom up parsers for
TAGs in which a finite state control drives the moves
of a Bottom-up Embedded Push Down Stack. The class
of corresponding non-deterministic automata recognizes
exactly the set of TALs.
We focus our attention on showing how a bottom-
up embedded pushdown automaton is deterministically
driven given a parsing table. To illustrate the building
of a parsing table, we consider the simplest case, i.e.
building of LR(0) items and the corresponding LR(0)
</bodyText>
<footnote confidence="0.984485125">
1The parsers that we develop in this paper can parse these con-
structions deterministically (see Figure 5).
2Tree Adjoining Granunars, Modified Head Grammars, Linear In-
dexed Grammars and Categorial Grammars (all of which generate
the same subclass of context-sensitive languages) fall in the class of
the so-called &amp;quot;mildly context sensitive&amp;quot; formalisms. The Embedded
Push Down Automaton recognizes exactly this set of languages (Vijay-
Shanker 1987).
</footnote>
<page confidence="0.996743">
276
</page>
<bodyText confidence="0.99984125">
parsing table for a given TAG. An example for a TAG
generating a context-sensitive language is given in Fig-
ure 5. Finally, we consider the construction of SLR(1)
parsing tables.
We assume that the reader is familiar with TAGs. We
refer the reader to Joshi (1987) for an introduction to
TAGs. We will assume that the trees can be combined
by adjunction only.
</bodyText>
<sectionHeader confidence="0.978083" genericHeader="method">
2 Automata Models of Tags
</sectionHeader>
<bodyText confidence="0.999940407407408">
Before we discuss the Bottom-up Embedded Push-
down Automaton (BEPDA) which we use in our parser,
we will introduce the Embedded Pushdown Automaton
(EPDA). An EPDA is similar to a pushdown automaton
(PDA) except that the storage of an EPDA is a sequence
of pushdown stores. A move of an EPDA (see Figure 1)
allows for the introduction of bounded pushdowns above
and below the current top pushdown. Informally, this
move can be thought of as corresponding to the adjoin-
ing operation move in TAGs with the pushdowns intro-
duced above and below the current pushdown reflecting
the tree structure to the left and right of the foot node of
an auxiliary being adjoined. The spine (path from root
to foot node) is left on the previous stack.
The generalization of a PDA to an EPDA whose stor-
age is a sequence of pushdowns captures the generaliza-
tion of the nature of the derived trees of a CFG to the
nature of derived trees of a TAG. From Thatcher (1971),
we can observe that the path set of a CFG (i.e. the set
of all paths ftom root to leaves in trees derived by a
CFG) is a regular set. On the other hand, the path set
of a TAG is a CR. This follows from the nature of the
adjoining operation of TAGs, which suggests stacking
along the path from root to a leaf. For example, as we
traverse down a path in a tree 7 (in Figure 1), if ad-
junction, say by occurs then the spine of fi has to be
traversed before we can resume the path in 7.
</bodyText>
<figureCaption confidence="0.99671">
Figure 1: Embedded Pushdown Automaton
</figureCaption>
<page confidence="0.983376">
277
</page>
<sectionHeader confidence="0.9202625" genericHeader="method">
3 Bottom-up Embedded Push-
down Automaton3
</sectionHeader>
<bodyText confidence="0.999976206896552">
For any TAG G. an EPDA can be designed such that
its moves correspond to a top-down parse of a string
generated by G (EPDA characterizes exactly the set of
Tree Adjoining Languages, Vijay- Shanker, 1987). If
we wish to design a bottom-up parser, say by adopting
a shift reduce parsing strategy, we have to consider the
nature of a reduce move of such a parser (i.e. using
EPDA storage). This reduce move, for example applied
after completely considering an auxiliary tree, must be
allowed to &apos;remove&apos; some bounded pushdowns above
and below some (not necessarily bounded) pushdown.
Thus (see Figure 2), the reduce move is like the dual of
the wrapping move performed by an EPDA.
Therefore, we introduce Bottom-up Embedded Push-
down Automaton (BEPDA), whose moves are dual of
an EPDA. The two moves of a BEPDA are the unwrap
move depicted in Figure 2 — which is an inverse of
the wrap move of an EPDA — and the introduction of
new pushdowns on top of the previous pushdown (push
move). In an EPDA, when the top pushdown is emp-
tied, the next pushdown automatically becomes the new
top pushdown. The inverse of this step is to allow for
the introduction of new pushdowns above the previous
top pushdown. These are the two moves allowed in a
BEPDA, the various steps in our parsers are sequences
of one or more such moves.
Due to space constraints, we do not show the equiva-
lence between BEPDA and EPDA apart from noting that
the moves of the two machines are dual of each other.
</bodyText>
<sectionHeader confidence="0.990801" genericHeader="method">
4 LR Parsing Algorithm
</sectionHeader>
<bodyText confidence="0.974250111111111">
An LR parser consists of an input, an output, a sequence
of stacks, a driver program, and a parsing table that has
three parts (ACTION. GOTOright and GOTOf„t). The
parsing program is the same for all LR parsers, only
the parsing tables change from one grammar to another.
The parsing program reads characters from the input one
character at a time. The program uses the sequence of
stacks to store states.
The parsing table consists of three parts, a pars-
ing action function ACTION and two gob o functions
GOTOright and GOTOf „t. The program driving the
LR parser first determines the state i currently on top
of the top stack and the current input token ar. Then it
consults the ACTION table entry for state i and token
3 The need to use bottean-up version of an RDA in LR style pars-
ing of TAGs was suggested to us by Bernard Lang and David Weir.
Also their suggestions played an instrumanal role in the definition of
BEPDA, for example restriction on the moves allowed.
</bodyText>
<figure confidence="0.998136045454545">
U1VWRAP move
Bounded number
of stacks
of bounded size
Rounded number
of slack elements
Unbounded number
of stack elements
Bounded number
of stacks
of bounded size
PUSH
—11w-
PUSH move
UNWRAP
EPDA
Wye
read only input gape
Finite sok
Control
stack of stacks
BEPDA
</figure>
<figureCaption confidence="0.999522">
Figure 2: Bottom-up Embedded Pushdown Automaton
</figureCaption>
<bodyText confidence="0.9979575">
a„ The entry in the action table can have one of the
following five values:
</bodyText>
<listItem confidence="0.991130090909091">
• Shift j (sj), where j is a state;
• Resume Right of 6 at address dot (rs60d00),
where 6 is an elementary Wee and dot is the ad-
dress of a node in 6;
• Reduce Root of the auxiliary tree p in which the
last adjunction on the spine was performed at ad-
dress star (rd/3(star);
• Accept (ace);
• Error, no action applies, the parsers rejects the in-
put string (errors are associated with empty table
entries).
</listItem>
<bodyText confidence="0.98637885">
The function GOTOright and GOTO/„t take a state
i and an auxiliary tree /3 and produce a state j.
An example of a parsing table for a grammar gener-
ating L = {anbnecncin 0} is given in Figure 5.
We denote an instantaneous description of the
BEFDA by a pair whose first component is the sequence
of pushdowns and whose second component is the un-
expanded input:
(1Itm • • •till • • - - • • sw, ar .anS)
In the above sequence of pushdowns, the stacks are
piled up from left to right. II stands for the bottom of a
stack. sty is the top element of the top stack, s1 is the
bottom element of the top stack, t1 is the top element
of the bottom stack and tm is the bottom element of the
bottom stack.
The initial configuration of the parser is set to:
(110, al • anS)
where 0 is the start state and al • - - an$ is the input string
to be read with an end marker ($). 278
Suppose the parser reaches the configuration:
(litm • • &apos;till &apos; &apos; Iliw • &apos; arar+1 • • • anS)
The next move of the parser is determined by reading
a,., the current input token and the state i on top of the
sequence of stacks, and then consulting the parsing table
entry for ACTIONN, ad. The parser keeps applying the
move associated with ACTION[i, at.] until acceptance or
war occurs. The following moves are possible:
ACTION[i, = shift state j (sj). The parser exe-
cutes a push move, entering the configuration:
(Him • • till • Iliw •i1Ii,ar-Fi • an$)
(ii) ACITON[i, = resume right of 6 at address dot
(rs6Odot). The parser is coming to the right and
below of the node at address dot in 6, say t, on which
an auxiliary tree has been adjoined. The information
identifying the auxiliary tree is in the sequence of
stacks and must be recovered. There are two cases:
Case 1: 71 does not subsume a foot node. Let k
be the number of terminal symbols subsumed by 77.
Before applying this move, the current configuration
looks like:
</bodyText>
<subsubsectionHeader confidence="0.456881">
th—llikiiIIiII ar an$)
</subsubsectionHeader>
<bodyText confidence="0.9846056">
The k top first stacks are merged into one stack
and the stack urn is pushed on top of it, where
172 = GOTOloot[ik , for some auxiliary tree f3 that
can be adjoined in 6 at 9, and the parser enters the
configuration:
</bodyText>
<equation confidence="0.845629">
(11 &apos; • • • ar • • • atz$)
Case 2: t subsumes the foot node of 6. Let k (resp,
</equation>
<bodyText confidence="0.932947927272727">
k&apos;) be the number of terminal symbols to the right
(resp. to the left) of the foot node subsumed by n.
Before applying this move, the configuration looks
like:
(11&apos; • • • • •Ilnisi sillik - • • PIP, ar • • an$) the right of it. The four positions of the dot are anno-
The k&apos; stacks below the k + 2th stack from the top tated by la, lb, ra, rb (resp. left above, left below, right
as well as the k +1 top stacks are rewritten onto the above, right below): In practice, only two dot
k+2th stack and the stack Ilrn is pushed on top of it, positions can be used (to the left and to the right of
where at = GOTOf oot[nk,+i, i3] for some auxiliary a node). However, for sake of simplicity, we will use
tree # that can be adjoined in 5 at rj, and the parser four different dot positions. A dotted tree is defined
enters the configuration: as a tree with exactly one dotted symbol. Furthermore,
(II .• • link,+1 • sink. .. • n ik •i1ifrn, ar • • • a„53) some nodes in the dotted tree can be marked with a star.
(iii) ACTIONp, = reduce root of an auxiliary tree A star on a node expresses the fact that an adjunction
in which the last adjunction on the spine was per- has been performed on the corresponding node. A dot-
fonned at address star (rdflastar). The parser has ted tree is referred as [a, dot, pos, stars], where a is a
finished the recognition of the auxiliary tree #. It tree, dot is the address of the dot, pos is the position of
must remove all information about f3 and continue the dot (la, lb, ra or rb) and stars is a list of nodes in
the recognition of the tree in which /1 was adjoined. a annotated by a star.
The parser executes an unwrap move. Let k (resp. Given a dotted tree with the dot above and to the left
k) be the number of terminal symbols to the left of the root, we define a tree traversal of a dotted tree (as
(resp. to the right) of the foot node of f3. Let C be shown in the Figure 3) that will enable us to scan the
the node at address star in ig (( = nil if star is not frontier of an elementary tree from left to right while try-
set). Let p be the number of terminal symbols to ing to recognize possible adjunctions between the above
the left of the foot node subsumed by C (p = 0 if and below positions of the dot of interior nodes.
= nil). p + k&apos; + 1 symbols from the top of the
sequence of stacks popped. Then k p single ele-
ment stacks below the new top stack are unwrapped.
Let j be the new top element of the top stack. Let
m = GOTOright[j, j is popped and the single
element stack urn is pushed on top of the top stack.
By keeping track of the auxiliary trees being reduced,
it is possible to output a parse instead of acceptance or
an error.
The parser recognizes the derived tree inside out: it
extracts recursively the innermost auxiliary tree that has
no adjunction performed in it.
5 LR(0) Parsing Tables
This section explain how to construct an Lizq parsing
table given a TAG. The construction is an extension
of the one used for CFGs. Similarly to Schabes and
Joshi (1988), we extend the notion of dotted rules to
trees. We define the closure operations that correspond
to adjunction. Then we explain how transitions between
states are defined. We give in Figure 5 an example of
a finite state automaton used to build the parsing table
for a TAG (see Figure 5) generating a context-sensitive
language.
We first explain preliminary concepts (originally de-
fined to construct an Earley-type parser for TAGs) that
will be used by the algorithm. Dotted rules are extended
to trees. Then we recall a tree traversal that the algo-
rithm will mimic in order to scan the input from left to
right.
A dotted symbol is defined as a symbol associated
with a dot above or below and either to the left or to
</bodyText>
<table confidence="0.943602827586207">
279
Figure 3: Left to Right Tree Traversal
A state in the finite state automaton is defined to be
a set of dotted trees closed under the following opera-
tions: Adjunction Prediction, Left Completion, Move
Dot Down, Move Dot Up and Skip Node (See Fig-
ure 4).4
Adjunction Prediction predicts all possible auxiliary
trees that can be adjoining at a given node. Left Com-
pletion occurs when an auxiliary tree is recognized up
to its foot node. AU trees in which that tree can be
adjoined are pulled back with the node on which ad-
junction has been performed added to the list of stars.
Move Dot Down moves the dot down the links. Move
Dot Up moves the dot up the links. Skip Node moves
the dot up on the right hand side of a node on which no
adjunction has been performed.
All the states in the finite state automaton (FSA) must
be closed under the closure operations. The FSA is
4These operations correspond to processors in the Earley-type
parser for TAGS.
. A A A • ■
L A, B
A
Adjunction Predktjoñ Move Dot lip Move Dot Down
A A A -,-- A
A-i-- Skip nods
.A
Left Completion
</table>
<figureCaption confidence="0.993967">
Figure 4: Closure Operations
</figureCaption>
<bodyText confidence="0.9964924">
build as follows. In states set 0, we put all initial trees
with a dot to the left and above the root. The state is
then closed. Then recursively we build new states with
the following transitions (we refer to Figure 5 for an
example of such a construction).
</bodyText>
<listItem confidence="0.860791913043478">
• A transition on a (where a is a terminal symbol)
from Si to Si occurs if and only if in Si there is a
dotted tree 16, dot, la, stars] in which the dot is to
the left and above a terminal symbol a; Sj consists
of the closure of the set of dotted trees of the form
[6, dot, ra, stars].
• A transition on #right from Si to Si occurs if in
Si there is a dotted tree [6, dot, rb, stars] such that
the dot is to the right and below a node on which
,8 can be adjoined; Si consists of the closure of the
set of dotted trees of the form [5, dot, ra, stars&apos;].
If the dotted node of (6, dot, rb, stars] is not on the
spine of 6, star&apos; consists of all the nodes in star
that strictly dominate the dotted node. When the
dotted node is on the spine, stars&apos; consists of all
the nodes in star that strictly dominate the dotted
node, if there are some, otherwise stars&apos; = {do*
• A Skip foot of [3, dot, lb, stars] transition from
Si to Si occurs if in Si there is a dotted tree
[19, dot, lb, stars] such that the dot is to the left
and below the foot node of the auxiliary tree 0; Si
consists of the closure of the set of dotted trees of
the form [13, dot, rb, stars].
</listItem>
<bodyText confidence="0.9640914">
The parsing table is constructed from the FSA built as
above. In the following, we write trans(i, r) for set of
states in the FSA reached from state i on the transition
labeled by a.
The actions for ACTION(i, a) are:
</bodyText>
<listItem confidence="0.971946769230769">
• Shift j (sc(j)). It applies iff j E trans(i, a).
5Nodes on the path from root node to foot node. 280
• Resume Right of (6, dot, rb, stars] (rs6(gdot).
It applies iff in state i there is a dotted tree
(6, dot, rb, stars], where dot E stars.
• Reduce Root of # (rd0@s2ar). It applies iff in
state i there is a dotted tree [13, 0, ra, {star}], where
/3 is an auxiliary tree.s
• Accept occurs iff a is the end marker (a = $) and
there is a dotted tree [a, 0, ra, {star}], where a is
an initial tree and the dot is to the right and above
the root node.
• Error, if none of the above applies.
</listItem>
<bodyText confidence="0.996290071428571">
The GOTO table encodes the transitions in the
FSA on non-terminal symbols. It is indexed by
a state and by gright or Ploott for all auxiliary
trees #: j E GOTO(i, label) ill there is a tran-
sition from i to j on the given label (label E
emrioreght&apos;thanfif&amp;quot;ot infleiascantionauxis ilpioa.STYsibt7in}.an entry of the ac-
tion table, the grammar is not LR(0): there is a conflict
of action, the grammar cannot be parsed deterministi-
cally without lookahead.
An example of a finite state automaton used for the
construction of the LR(0) table for a TAO (trees cri, 131
in Figure 5) generating7 L Ian b&apos; e cn d&amp;quot; &gt; 01, its
corresponding parsing table is given and an example of
sequences of moves are given in Figure 5.
</bodyText>
<subsectionHeader confidence="0.394304">
60 is the address of the root node.
</subsectionHeader>
<bodyText confidence="0.901714166666667">
7In the given TAG (trees a and 131), if we omit a and c, we obtain
a TAG that is similar to the one for the Dutch cross-serial construction.
This grammar can still be bandied by an 1-R(0) parser.
In the trees a and (3, no stand for null adjunction constraint (i.e.
no auxiliary tree can be adjoined on a node with null adjunction
constraint).
</bodyText>
<figure confidence="0.99779577631579">
TAG for L = la&amp;quot; bn ecndn) Finite State Automaton for a BUDA Recognizing L = {eV ecnd&amp;quot;}
a Ss d
b Anac
S.
a
Az
Ala
Az
b aSd aSd aSd
1
A\ &amp;quot; A\
S.c. b b „snag
A62 A A
aSd&apos;aSdaSO aSd
A\ .A\ it\
bSc b %de b Sc b Snac
4
&amp;gm
10
9rik a S* 4
a V&apos; d &amp;quot;
Smac b !lac
a .So d a S. d
Li S c .
LiSmc
Ala Az a S&apos;&amp;quot; d
a d a S* d Li Sfia.c..„
bSc bSc
Cr
11 12 3
cAz a St d Ala-N
a So d A\ 47
A\ b SJi a s: d a s* I t 10
b Sate b Sc b Smile
FC.N.4)
/...._ fit
8
...&amp;quot;
--1 .--.\
A\
no na RA me las /al
-
a 5* e a S• cl a 5* d aSeaSdaSd
4&apos; 4&apos; oet\ A\ A\ ./N
bSe bScbSc bSnac bSnacbliac
Ma Ma
.1 ‘.. ■•••1
•S S a S d
i. I ....A\e
e e - -MC
ik A
aSd .4 S d
AN A\
b b Side}
IA Av A /k
aSd aS.d a S. d aSd
A\ . A\ A\ A\
Li S.c Li Smac b Sc b SRac
2,
es d a•SdaSd
A\ A\ ,01‘
Li Sc b Sac? b Snac
Ala S&apos; S
• I I
a 5° d a &apos; d a &apos;a
.
bSc b Sc
S. So
I&apos;
e
aSd aSd
b Smac b Sma.c
IN
a S d
((n) (th)
b S,„, c
</figure>
<table confidence="0.886046">
PARSING ACTION GOTO
foot right
a b c d e 1 $ 13 13
0 s2 - sl
1 aCC
2 s2 s3
3 s9 s4 6
4 rsag0 rsaCk0 rsa00 rsoid0 rsa00 rsa00 5
5 ace
6 s7
7 s8
8 rd/36— rti/30— /3rel— rd/.30— rc1/3@— rd/3c-
9 s9 s4 10
10 s 1 1
11 rsj3 rs/3 rs(302 rs$612 rs/362 rs/3cr2 12
12 s13
13 rdificf rdflEt2 rd#02 rd,M2 rdft rdt362
Example of LR(0) Parsing Table
Parser configuration Next move
(110112,
</table>
<equation confidence="0.8926694375">
(110, abbeccdd$)
a bbeccdd$)
(110112112, bbeccddS)
(110112112113. beccddS)
(11011211203119, cccddS)
(0112112113119114, ccddS)
(1101121121131191140o, cads)
(11011211211311911411101111, cads)
(110112112113114 9 10 11116. cddS)
(110112112113114 9 10 1 1 116117. drIS)
(11°112112113114 9 10 1 1 060709, d$)
(110112114 9 100 12. d$)
(110112114 9 1011121113, 5)
(110115, $)
s2
s2
</equation>
<page confidence="0.747776">
53
</page>
<figure confidence="0.942072769230769">
59
54
rscr@O
all
rsfi 2
57
58
rd/3—
s13
rdiM2
aCC
Example of sequences of moves
sj Shift j; rs5ndet F. Resume Right of 6 at dot; rdflOstar Reduce Root of 13 with star at address star; $ a end of input.
</figure>
<figureCaption confidence="0.999444">
Figure 5: Example of the construction of an LR(0) parser for a TAG recognizing L = fan bnecndn}
</figureCaption>
<page confidence="0.969291">
281
</page>
<sectionHeader confidence="0.955864" genericHeader="method">
6 SLR(1) Parsing Tables
</sectionHeader>
<bodyText confidence="0.9998594375">
The tables that we have constructed are LR(0) tables.
The Resume Right and Reduce Root moves are per-
formed regardless of the next input token. The accu-
racy of the parsing table can be improved by comput-
ing lookaheads. FIRST and FOLLOW can be extended
to dotted trees.8 FIRST of a dotted tree corresponds to
the set of left most symbols appearing below the subtree
dominated by the dotted node. FOLLOW of a dotted tree
defines the set of tokens that can appear in a derivation
immediately following the dotted node. Once FIRST
and FOLLOW computed, the LR(0) parsing table can
be improved to an SLR(1) table: Resume Right and Re-
duce Root are applicable only on the input tokens in the
follow set of the dotted tree.
For example, the SLR(1) table for the TAG built with
trees al and 01 is given in Figure 6.
</bodyText>
<figure confidence="0.937943647058824">
PARSING ACTION GOTO
foot right
albcfd e $ 001
0 s2 r sl
1 ACC
2 s2 s3
3 99 s4 6
4 rsa00 5
5 ACC
6 97
7 s8
8 rd— MOO-
9 s9 94 10
10 sll
11 rs/34112 12
12 s13
13 rd/362 rd082
</figure>
<figureCaption confidence="0.999986">
Figure 6: Example of SLR(1) Parsing Table
</figureCaption>
<bodyText confidence="0.999971333333333">
By associating dotted trees with lookaheads, one can
also compute LR(k) items in the finite state automaton
in order to build LR(k) parsing tables.
</bodyText>
<sectionHeader confidence="0.978025" genericHeader="method">
7 Current Research
</sectionHeader>
<bodyText confidence="0.975982928571429">
The deterministic parsers we have developed do not sat-
isfy an important property satisfied by LR parsers for
CFG. This property is often described as the viable pre-
fix property which states that as long as the portion of
the input considered so far leads to some stack configu-
ration (i.e. does not lead to error), it is always possible
to find a suffix to obtain a string in the language.
Our parsers do not satisfy this property because the
left completion move is not a &apos;reduce&apos; move. This move
8Due to the lack of space, we do not define FIRST and FOLLOW.
However, we explain the basic principles used for the computation of
FIRST and FOLLOW. 282
applies when we have reached a bottom-left end (to the
left of the foot node) of an auxiliary tree, say 13. If we
had considered this move to be a reduce move, then by
popping appropriate amount of elements off the storage
would allow us to figure out which tree (into which fi
was adjoined), say a, to proceed with. Rather than us-
ing this information (that is available in the storage of
the BEPDA), by putting left completion in the closure
operations, we apply a move that is akin to the predict
move of Earley parser. That is we continue by consider-
ing every possible nodes 3 could have been adjoined at,
which could include nodes in trees that were not used
so far. However, we do not accept incorrect strings, we
only lose the prefix property (for an example see Fig-
ure 7). As a consequence, errors are always detected but
not as soon as possible.
</bodyText>
<table confidence="0.996515375">
[Parser configuration Next move
(110, aabeccdd$) s2
(110112, aboccdn) s2
(110112112, beccdd$) s3
(1101121121(3, eccda) s4
(110112(143114, ccrid$) rsce0510
(110112112113114116, cc4d$) s7
(110112112(1jf406117, ads) error
</table>
<figureCaption confidence="0.99974">
Figure 7: Example of error detecting
</figureCaption>
<bodyText confidence="0.999992794117647">
The reason why we did not consider the left comple-
tion move to be a reduce move is related to the restric-
tions on moves of BEPDA which is weakly equivalent
to TAGs (perhaps also due to the fact that left to right
parsing may not be most natural for parsing TAGs which
produce trees with context-free path sets). In CFOs,
where there is only horizontal stacking, a single reduc-
tion step is used to account for the application of rule
in left to right parsing. On the other hand, with TAGs,
if a tree is used successfully, it appears that a prediction
move and more than one reduction move are necessary
for auxiliary tree. In left to right parsing, a prediction is
made to start an auxiliary tree fiat top left end; a reduc-
tion is appropriate to recover the node 13 was adjoined at
the left completion stage; a reduction is needed again at
resume right state to resume the right end of /3; finally a
reduction is needed at the right completion stage. In our
algorithm, reductions are used at right resume stage and
reduce right state. Even if a reduction step is applied at
left completion stage, an encoding of the fact that left
part of 13 (as well as the left part of trees adjoined on
the spine of OP) has been completed has to be restored in
the storage (note in a reduction move of any shift reduce
parser for CFGs, any information about the rule used is
discarded once reduction step applied). So far we have
not been able to apply a reduction step at the left com-
pletion stage, reinsert the left part of ft and yet maintain
the correct sequence in the storage so that the right part
of /3 can be recovered at the resume right stage. We are
considering alternative strategies for shift reduce parsing
with BEPDA as well as considering whether there are
other automata models equivalent to TAGs better suited
for deterministic left to right parsing of tree-adjoining
languages.
</bodyText>
<sectionHeader confidence="0.931618" genericHeader="conclusions">
Conclusion
</sectionHeader>
<bodyText confidence="0.999970652173913">
We have introduced a bottom-up machine (Bottom-up
Embedded Push Down Automaton) that enabled us to
define LR-like parsers for TAGs. The machine recog-
nizes in a bottom-up fashion exactly the set of Tree Ad-
joining Languages.
We described the LR parsing algorithm and a method
for computing LR(0) parsing tables. We also men-
tioned the possibility of building SLR(k) parsing tables
by defining the notions of FIRST and FOLLOW sets for
TAGs.
As shown for the example, no lookaheads are nec-
essary to parse deterministically the language L =
{ann ecn da In &gt; 0}. If instead of using e, we had the
empty string c in the initial tree, LR(0)-like parser will
not be enough. On the other hand SLR(1)-like parser
will suffice.
We have noted that our parsers do not satisfy the valid
prefix property. As a consequence, errors are always
detected but not as soon as possible.
Similar to the work of Lang (1974) and Tomita (1987)
extending LR parsers for arbitrary CFOs, the LR parsers
for TAGs can be extended to solve by pseudo-parallelism
the conflicts of moves.
</bodyText>
<sectionHeader confidence="0.999231" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999554428571429">
Joshi, Aravind K., 1985. How Much Context-
Sensitivity is Necessary for Characterizing Struc-
tural Descriptions—Tree Adjoining Grammars. In
Dowty, D., Kartturten, L., and Zwicky, A. (editors),
Natural Language Processing—Theoretical, Compu-
tational and Psychological Perspectives. Cambridge
University Press, New York. Originally presented in
a Workshop on Natural Language Parsing at Ohio
State University, Columbus, Ohio, May 1983.
Joshi, Aravind K., 1987. An Introduction to Tree Ad-
joining Grammars. In Mariaster-Ramer, A. (editor),
Mathematics of Language. John Benjamins, Amster-
dam.
Knuth, D. E., 1965. On the translation of languages
from left to right. Inf. Control 8:607-639. 283
Lang, Bernard, 1974. Deterministic Techniques for Effi-
cient Non-Deterministic Parsers. In Loeckx, Jacques
(editor), Automata, Languages and Programming,
2nd Colloquium, University of Saarbriicken. Lecture
Notes in Computer Science, Springer Verlag.
Revesz, G., 1971. Unilateral context sensitive gram-
mars and left to right parsing. I. Comput. System Sci.
5:337-352.
Schabes, Yves and Joshi, Aravind K., June 1988. An
Earley-Type Parsing Algorithm for Tree Adjoining
Grammars. In 20 Meeting of the Association for
Computational Linguistics (ACL&apos;88). Buffalo.
Thatcher, J. W., 1971. Characterizing Derivations Trees
of Context Free Grammars through a Generalization
of Finite Automata Theory. .1. Comput. Syst. Sci.
5:365-396.
Tomita, Masaru, 1987. An Efficient Augmented-
Context-Free Parsing Algorithm. Computational Lin-
guistics 13:31-46.
Turnbull, C. J. M. and Lee, E. S., 1979. Generalized
Deterministic Left to Right Parsing. Acta Informatica
12:187-207.
Vijay-Shanker, K., 1987. A Study of Tree Adjoining
Grammars. PhD thesis, Department of Computer and
Information Science, University of Pennsylvania.
Walters, D.A., 1970. Deterministic Context-Sensitive
Languages. inf. Control 17:14-40.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.929746">
<title confidence="0.9985125">DETERMINISTIC LEFT TO RIGHT PARSING OF TREE ADJOINING LANGUAGES*</title>
<author confidence="0.992491">Yves Schabes</author>
<affiliation confidence="0.9998735">Depi of Computer &amp; Information Science University of Pennsylvania</affiliation>
<address confidence="0.999165">Philadelphia, PA 19104-089, USA</address>
<email confidence="0.999622">schabes@linc.cis.upenn.edu</email>
<author confidence="0.996995">K Vijay-Shanker</author>
<affiliation confidence="0.999952">Dept. of Computer &amp; Information Science University of Delaware</affiliation>
<address confidence="0.988698">Newark, DE 19716, USA</address>
<email confidence="0.999617">vijay@udel.edu</email>
<abstract confidence="0.997500095238095">We define a set of deterministic bottom-up left to right parsers which analyze a subset of Tree Adjoining Languages. The LR parsing strategy for Context Free Grammars is extended to Tree Adjoining Grammars (TAGs). We use a machine, called Bottom-up Embedded Push Down Automaton (BEPDA), that recognizes in a bottom-up fashion the set of Tree Adjoining Languages (and exactly this set). Each parser consists of a finite state control that drives the moves of a Bottom-up Embedded Pushdown Automaton. The parsers handle deterministically some context-sensitive Tree Adjoining Languages. In this paper, we informally describe the BEPDA then given a parsing table, we explain the LR parsing algorithm. We then show how to construct an LR(0) parsing table (no lookahead). An example of a context-sensitive language recognized deterministically is given. Then, we explain informally the construction of SLR(1) parsing tables for BEPDA. We conclude with a discussion of our parsing method and current work.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<authors>
<author>Aravind K Joshi</author>
</authors>
<title>How Much ContextSensitivity is Necessary for Characterizing Structural Descriptions—Tree Adjoining Grammars.</title>
<date>1985</date>
<booktitle>Natural Language Processing—Theoretical, Computational and Psychological Perspectives.</booktitle>
<editor>In Dowty, D., Kartturten, L., and Zwicky, A. (editors),</editor>
<publisher>Cambridge University Press,</publisher>
<institution>Ohio State University,</institution>
<location>New York.</location>
<contexts>
<context position="2963" citStr="Joshi, 1985" startWordPosition="450" endWordPosition="451"> parsing of TAGs. The set of Tree Adjoining Languages is a strict superset of the set of Context Free Languages (CFLs). For example, the cross serial dependency construction in Dutch can be generated by a TAG. I Walters (1970), R6vesz (1971), Turnbull and Lee (1979) investigated deterministic parsing of the class of context-sensitive languages. However they used Turing machines which recognize languages much more powerful than Tree Adjoining Languages. So far no deterministic bottom-up parser has been proposed for any member of the class of the so-called &amp;quot;mildly context sensitive&amp;quot; formalisms (Joshi, 1985) in which Tree Adjoining Grammars fal1.2 Since the set of Tree Adjoining Languages (TALs) is a strict superset of the set of Context Free Languages, in order to define LR-type parsers for TAGs, we need to use a more powerful configuration then a finite state automaton driving a push down stack. We investigate the design of deterministic left to right bottom up parsers for TAGs in which a finite state control drives the moves of a Bottom-up Embedded Push Down Stack. The class of corresponding non-deterministic automata recognizes exactly the set of TALs. We focus our attention on showing how a </context>
</contexts>
<marker>Joshi, 1985</marker>
<rawString>Joshi, Aravind K., 1985. How Much ContextSensitivity is Necessary for Characterizing Structural Descriptions—Tree Adjoining Grammars. In Dowty, D., Kartturten, L., and Zwicky, A. (editors), Natural Language Processing—Theoretical, Computational and Psychological Perspectives. Cambridge University Press, New York. Originally presented in a Workshop on Natural Language Parsing at Ohio State University, Columbus, Ohio, May 1983.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Aravind K Joshi</author>
</authors>
<title>An Introduction to Tree Adjoining Grammars.</title>
<date>1987</date>
<booktitle>Mathematics of Language. John Benjamins,</booktitle>
<editor>In Mariaster-Ramer, A. (editor),</editor>
<location>Amsterdam.</location>
<contexts>
<context position="4500" citStr="Joshi (1987)" startWordPosition="698" endWordPosition="699"> 5). 2Tree Adjoining Granunars, Modified Head Grammars, Linear Indexed Grammars and Categorial Grammars (all of which generate the same subclass of context-sensitive languages) fall in the class of the so-called &amp;quot;mildly context sensitive&amp;quot; formalisms. The Embedded Push Down Automaton recognizes exactly this set of languages (VijayShanker 1987). 276 parsing table for a given TAG. An example for a TAG generating a context-sensitive language is given in Figure 5. Finally, we consider the construction of SLR(1) parsing tables. We assume that the reader is familiar with TAGs. We refer the reader to Joshi (1987) for an introduction to TAGs. We will assume that the trees can be combined by adjunction only. 2 Automata Models of Tags Before we discuss the Bottom-up Embedded Pushdown Automaton (BEPDA) which we use in our parser, we will introduce the Embedded Pushdown Automaton (EPDA). An EPDA is similar to a pushdown automaton (PDA) except that the storage of an EPDA is a sequence of pushdown stores. A move of an EPDA (see Figure 1) allows for the introduction of bounded pushdowns above and below the current top pushdown. Informally, this move can be thought of as corresponding to the adjoining operatio</context>
</contexts>
<marker>Joshi, 1987</marker>
<rawString>Joshi, Aravind K., 1987. An Introduction to Tree Adjoining Grammars. In Mariaster-Ramer, A. (editor), Mathematics of Language. John Benjamins, Amsterdam.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D E Knuth</author>
</authors>
<title>On the translation of languages from left to right.</title>
<date>1965</date>
<journal>Inf. Control</journal>
<pages>8--607</pages>
<contexts>
<context position="1397" citStr="Knuth, 1965" startWordPosition="208" endWordPosition="209">f a Bottom-up Embedded Pushdown Automaton. The parsers handle deterministically some context-sensitive Tree Adjoining Languages. In this paper, we informally describe the BEPDA then given a parsing table, we explain the LR parsing algorithm. We then show how to construct an LR(0) parsing table (no lookahead). An example of a context-sensitive language recognized deterministically is given. Then, we explain informally the construction of SLR(1) parsing tables for BEPDA. We conclude with a discussion of our parsing method and current work. 1 Introduction LR(k) parsers for Context Free Grammars (Knuth, 1965) consist of a finite state control (constructed given a CFG) that drives deterministically with k lookahead symbols a push down stack, while scanning the input from left to right. It has been shown that they recognize exactly the set of languages recognized by deterministic push down automata. LR(k) parsers for CFGs have been proven useful for compilers as well as recently for natural language processing. For natural language processing, although LR(k) parsers are not powerful enough, &amp;quot;The first author is partially supported by Darpa grant N0014-85- 1(0018, ARO grant DAAL03-89-C-0031PRI NSF gr</context>
</contexts>
<marker>Knuth, 1965</marker>
<rawString>Knuth, D. E., 1965. On the translation of languages from left to right. Inf. Control 8:607-639. 283</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bernard Lang</author>
</authors>
<title>Deterministic Techniques for Efficient Non-Deterministic Parsers.</title>
<date>1974</date>
<booktitle>Automata, Languages and Programming, 2nd Colloquium, University of Saarbriicken. Lecture Notes in Computer Science,</booktitle>
<editor>In Loeckx, Jacques (editor),</editor>
<publisher>Springer Verlag.</publisher>
<contexts>
<context position="2185" citStr="Lang, 1974" startWordPosition="328" endWordPosition="329">. It has been shown that they recognize exactly the set of languages recognized by deterministic push down automata. LR(k) parsers for CFGs have been proven useful for compilers as well as recently for natural language processing. For natural language processing, although LR(k) parsers are not powerful enough, &amp;quot;The first author is partially supported by Darpa grant N0014-85- 1(0018, ARO grant DAAL03-89-C-0031PRI NSF grant-1R184-10413 A02. We are extremely grateful to Bernard Lang and David Weir for their valuable suggestions. conflicts between multiple choices are solved by pseudoparallelism (Lang, 1974, Tortilla, 1987). This gives rise to a class of powerful yet efficient parsers for natural languages. It is in this context that we study deterministic (LR(k)-style) parsing of TAGs. The set of Tree Adjoining Languages is a strict superset of the set of Context Free Languages (CFLs). For example, the cross serial dependency construction in Dutch can be generated by a TAG. I Walters (1970), R6vesz (1971), Turnbull and Lee (1979) investigated deterministic parsing of the class of context-sensitive languages. However they used Turing machines which recognize languages much more powerful than Tre</context>
</contexts>
<marker>Lang, 1974</marker>
<rawString>Lang, Bernard, 1974. Deterministic Techniques for Efficient Non-Deterministic Parsers. In Loeckx, Jacques (editor), Automata, Languages and Programming, 2nd Colloquium, University of Saarbriicken. Lecture Notes in Computer Science, Springer Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Revesz</author>
</authors>
<title>Unilateral context sensitive grammars and left to right parsing.</title>
<date>1971</date>
<journal>I. Comput. System Sci.</journal>
<pages>5--337</pages>
<marker>Revesz, 1971</marker>
<rawString>Revesz, G., 1971. Unilateral context sensitive grammars and left to right parsing. I. Comput. System Sci. 5:337-352.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yves Schabes</author>
<author>Aravind K Joshi</author>
</authors>
<title>An Earley-Type Parsing Algorithm for Tree Adjoining Grammars.</title>
<date>1988</date>
<booktitle>In 20 Meeting of the Association for Computational Linguistics (ACL&apos;88).</booktitle>
<location>Buffalo.</location>
<contexts>
<context position="14607" citStr="Schabes and Joshi (1988)" startWordPosition="2627" endWordPosition="2630">k are unwrapped. Let j be the new top element of the top stack. Let m = GOTOright[j, j is popped and the single element stack urn is pushed on top of the top stack. By keeping track of the auxiliary trees being reduced, it is possible to output a parse instead of acceptance or an error. The parser recognizes the derived tree inside out: it extracts recursively the innermost auxiliary tree that has no adjunction performed in it. 5 LR(0) Parsing Tables This section explain how to construct an Lizq parsing table given a TAG. The construction is an extension of the one used for CFGs. Similarly to Schabes and Joshi (1988), we extend the notion of dotted rules to trees. We define the closure operations that correspond to adjunction. Then we explain how transitions between states are defined. We give in Figure 5 an example of a finite state automaton used to build the parsing table for a TAG (see Figure 5) generating a context-sensitive language. We first explain preliminary concepts (originally defined to construct an Earley-type parser for TAGs) that will be used by the algorithm. Dotted rules are extended to trees. Then we recall a tree traversal that the algorithm will mimic in order to scan the input from l</context>
</contexts>
<marker>Schabes, Joshi, 1988</marker>
<rawString>Schabes, Yves and Joshi, Aravind K., June 1988. An Earley-Type Parsing Algorithm for Tree Adjoining Grammars. In 20 Meeting of the Association for Computational Linguistics (ACL&apos;88). Buffalo.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J W Thatcher</author>
</authors>
<title>Characterizing Derivations Trees of Context Free Grammars through a Generalization of Finite Automata Theory.</title>
<date>1971</date>
<journal>1. Comput. Syst. Sci.</journal>
<pages>5--365</pages>
<contexts>
<context position="5567" citStr="Thatcher (1971)" startWordPosition="890" endWordPosition="891">on of bounded pushdowns above and below the current top pushdown. Informally, this move can be thought of as corresponding to the adjoining operation move in TAGs with the pushdowns introduced above and below the current pushdown reflecting the tree structure to the left and right of the foot node of an auxiliary being adjoined. The spine (path from root to foot node) is left on the previous stack. The generalization of a PDA to an EPDA whose storage is a sequence of pushdowns captures the generalization of the nature of the derived trees of a CFG to the nature of derived trees of a TAG. From Thatcher (1971), we can observe that the path set of a CFG (i.e. the set of all paths ftom root to leaves in trees derived by a CFG) is a regular set. On the other hand, the path set of a TAG is a CR. This follows from the nature of the adjoining operation of TAGs, which suggests stacking along the path from root to a leaf. For example, as we traverse down a path in a tree 7 (in Figure 1), if adjunction, say by occurs then the spine of fi has to be traversed before we can resume the path in 7. Figure 1: Embedded Pushdown Automaton 277 3 Bottom-up Embedded Pushdown Automaton3 For any TAG G. an EPDA can be des</context>
</contexts>
<marker>Thatcher, 1971</marker>
<rawString>Thatcher, J. W., 1971. Characterizing Derivations Trees of Context Free Grammars through a Generalization of Finite Automata Theory. .1. Comput. Syst. Sci. 5:365-396.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Masaru Tomita</author>
</authors>
<title>An Efficient AugmentedContext-Free Parsing Algorithm.</title>
<date>1987</date>
<journal>Computational Linguistics</journal>
<pages>13--31</pages>
<marker>Tomita, 1987</marker>
<rawString>Tomita, Masaru, 1987. An Efficient AugmentedContext-Free Parsing Algorithm. Computational Linguistics 13:31-46.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C J M Turnbull</author>
<author>E S Lee</author>
</authors>
<title>Generalized Deterministic Left to Right Parsing.</title>
<date>1979</date>
<journal>Acta Informatica</journal>
<pages>12--187</pages>
<contexts>
<context position="2617" citStr="Turnbull and Lee (1979)" startWordPosition="399" endWordPosition="402"> grant-1R184-10413 A02. We are extremely grateful to Bernard Lang and David Weir for their valuable suggestions. conflicts between multiple choices are solved by pseudoparallelism (Lang, 1974, Tortilla, 1987). This gives rise to a class of powerful yet efficient parsers for natural languages. It is in this context that we study deterministic (LR(k)-style) parsing of TAGs. The set of Tree Adjoining Languages is a strict superset of the set of Context Free Languages (CFLs). For example, the cross serial dependency construction in Dutch can be generated by a TAG. I Walters (1970), R6vesz (1971), Turnbull and Lee (1979) investigated deterministic parsing of the class of context-sensitive languages. However they used Turing machines which recognize languages much more powerful than Tree Adjoining Languages. So far no deterministic bottom-up parser has been proposed for any member of the class of the so-called &amp;quot;mildly context sensitive&amp;quot; formalisms (Joshi, 1985) in which Tree Adjoining Grammars fal1.2 Since the set of Tree Adjoining Languages (TALs) is a strict superset of the set of Context Free Languages, in order to define LR-type parsers for TAGs, we need to use a more powerful configuration then a finite s</context>
</contexts>
<marker>Turnbull, Lee, 1979</marker>
<rawString>Turnbull, C. J. M. and Lee, E. S., 1979. Generalized Deterministic Left to Right Parsing. Acta Informatica 12:187-207.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shanker</author>
</authors>
<title>A Study of Tree Adjoining Grammars.</title>
<date>1987</date>
<tech>PhD thesis,</tech>
<institution>Department of Computer and Information Science, University of Pennsylvania.</institution>
<marker>Vijay-Shanker, 1987</marker>
<rawString>Vijay-Shanker, K., 1987. A Study of Tree Adjoining Grammars. PhD thesis, Department of Computer and Information Science, University of Pennsylvania.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D A Walters</author>
</authors>
<title>Deterministic Context-Sensitive Languages.</title>
<date>1970</date>
<journal>inf. Control</journal>
<pages>17--14</pages>
<contexts>
<context position="2577" citStr="Walters (1970)" startWordPosition="395" endWordPosition="396">O grant DAAL03-89-C-0031PRI NSF grant-1R184-10413 A02. We are extremely grateful to Bernard Lang and David Weir for their valuable suggestions. conflicts between multiple choices are solved by pseudoparallelism (Lang, 1974, Tortilla, 1987). This gives rise to a class of powerful yet efficient parsers for natural languages. It is in this context that we study deterministic (LR(k)-style) parsing of TAGs. The set of Tree Adjoining Languages is a strict superset of the set of Context Free Languages (CFLs). For example, the cross serial dependency construction in Dutch can be generated by a TAG. I Walters (1970), R6vesz (1971), Turnbull and Lee (1979) investigated deterministic parsing of the class of context-sensitive languages. However they used Turing machines which recognize languages much more powerful than Tree Adjoining Languages. So far no deterministic bottom-up parser has been proposed for any member of the class of the so-called &amp;quot;mildly context sensitive&amp;quot; formalisms (Joshi, 1985) in which Tree Adjoining Grammars fal1.2 Since the set of Tree Adjoining Languages (TALs) is a strict superset of the set of Context Free Languages, in order to define LR-type parsers for TAGs, we need to use a mor</context>
</contexts>
<marker>Walters, 1970</marker>
<rawString>Walters, D.A., 1970. Deterministic Context-Sensitive Languages. inf. Control 17:14-40.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>