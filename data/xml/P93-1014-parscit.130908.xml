<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<note confidence="0.856612333333333">
A UNIFICATION-BASED PARSER FOR RELATIONAL
GRAMMAR
David E. Johnson
</note>
<sectionHeader confidence="0.313046" genericHeader="abstract">
IBM Research Division
</sectionHeader>
<address confidence="0.704384">
P.O. Box 218
Yorktown Heights, NY 10598
</address>
<email confidence="0.937173">
djohns@watson.ibm.corn
</email>
<address confidence="0.7122545">
Adam Meyers
Linguistics Department
New York University
New York, NY 10003
</address>
<email confidence="0.992652">
meyers@acf2.nyu.edu
</email>
<note confidence="0.652454">
Lawrence S. Moss
</note>
<author confidence="0.507404">
Mathematics Department
</author>
<affiliation confidence="0.965527">
Indiana University
</affiliation>
<address confidence="0.618757">
Bloomington, IN 47401
</address>
<email confidence="0.9978">
lmoss@indiana.edu
</email>
<sectionHeader confidence="0.989505" genericHeader="keywords">
Abstract
</sectionHeader>
<bodyText confidence="0.999981307692308">
We present an implemented unification-based
parser for relational grammars developed within
the stratified feature grammar (SFG) frame-
work, which generalizes Kasper-Rounds logic to
handle relational grammar analyses. We first in-
troduce the key aspects of SFG and a lexicalized,
graph-based variant of the framework suitable for
implementing relational grammars. We then de-
scribe a head-driven chart parser for lexicalized
SFG. The basic parsing operation is essentially
ordinary feature-structure unification augmented
with an operation of label unification to build the
stratified features characteristic of SFG.
</bodyText>
<sectionHeader confidence="0.997908" genericHeader="introduction">
INTRODUCTION
</sectionHeader>
<bodyText confidence="0.99952448">
Although the impact of relational grammar
(RG) on theoretical linguistics has been substan-
tial, it has never previously been put in a form
suitable for computational use. RG&apos;s multiple syn-
tactic strata would seem to preclude its use in the
kind of monotonic, unification-based parsing sys-
tem many now consider standard ([1], [11]). How-
ever, recent work by Johnson and Moss [2] on a
Kasper-Rounds (KR) style logic-based formalism
[5] for RG, called Stratified Feature Grammar
(SFG), has demonstrated that even RG&apos;s multiple
strata are amenable to a feature-structure treat-
ment.
Based on this work, we have developed a
unification-based, chart parser for a lexical ver-
sion of SFG suitable for building computational
relational grammars. A lexicalized SFG is sim-
ply a collection of stratified feature graphs (S-
graphs), each of which is anchored to a lexical
item, analogous to lexicalized TAGs [10]. The ba-
sic parsing operation of the system is S-graph
unification (S-unification): This is essentially
ordinary feature-structure unification augmented
with an operation of label unification to build the
stratified features characteristic of SFG.
</bodyText>
<sectionHeader confidence="0.99888" genericHeader="related work">
RELATED WORK
</sectionHeader>
<bodyText confidence="0.99934125">
Rounds and Manaster-Ramer [9] suggested en-
coding multiple strata in terms of a &amp;quot;level&amp;quot; at-
tribute, using path equations to state correspon-
dences across strata. Unfortunately, &amp;quot;unchanged&amp;quot;
relations in a stratum must be explicitly &amp;quot;car-
ried over&amp;quot; via path equations to the next stra-
tum. Even worse, these &amp;quot;carry over&amp;quot; equations
vary from case to case. SFG avoids this problem.
</bodyText>
<sectionHeader confidence="0.997278" genericHeader="method">
STRATIFIED FEATURE GRAM-
MAR
</sectionHeader>
<bodyText confidence="0.989235222222222">
SFG&apos;s key innovation is the generalization of
the concept feature to a sequence of so-called re-
lational signs (R-signs). The interpretation of
a stratified feature is that each R-sign in a se-
quence denotes a primitive relation in different
strata. 1
For instance, in Joe gave Mary tea there are,
at the clause level, four sister arcs (arcs with the
same source node), as shown in Figure 1: one
arc labeled [H] with target gave, indicating gave
is the head of the clause; one with label [1] and
target Joe, indicating Joe is both the predicate-
argument, and surface subject, of the clause; one
with label [3,2] and target Mary, indicating that
&apos;We use the following R-signs: 1 (subject), 2 (direct
object), 3 (indirect object), 8 (chOmeur), Cat (Category),
C (comp), F (flag), H (head), LOC (locative), M (marked),
as well as the special Null R-signs 0 and/, explained below.
</bodyText>
<figure confidence="0.916061166666667">
9 7
[Cat] S
[1] Joe
[H] gave
[3,2] Mary
[2,8] tea
</figure>
<figureCaption confidence="0.999976">
Figure 1: S-graph for Joe gave Mary tea.
</figureCaption>
<bodyText confidence="0.9741681">
Mary is the predicate-argument indirect object,
but the surface direct object, of the clause; and
one with label [2,8] and target tea, indicating tea
is the predicate-argument direct object, but sur-
face chameur, of the clause. Such a structure is
called a stratified feature graph (S-graph).
This situation could be described in SFG logic
with the following formula (the significance of the
different label delimiters (,), [, ] is explained be-
low):
</bodyText>
<equation confidence="0.9855525">
R1 := [H] : gave A [1) : Joe
A [3, 2) : Mary A [2, 8) : tea .
</equation>
<bodyText confidence="0.999974142857143">
In RG, the clause-level syntactic information
captured in R1 combines two statements: one
characterizing gave as taking an initial 1, initial
2 and initial 3 (Ditransitive); and one character-
izing the concomitant &amp;quot;advancement&amp;quot; of the 3 to
2 and the &amp;quot;demotion&amp;quot; of the 2 to 8 (Dative). In
SFG, these two statements would be:
</bodyText>
<equation confidence="0.980688333333333">
Ditransitive :=
[H] : gave A [1) : T A [2) : T A [3) : T ;
Dative := (3, 2) : T 8c (2, 8) : T.
</equation>
<bodyText confidence="0.996830734693878">
Ditransitive involves standard Boolean con-
junction (A). Dative, however, involves an opera-
tor, St, unique to SFG. Formulas involving &amp; are
called extension formulas and they have a more
complicated semantics. For example, Dative has
the following informal interpretation: Two dis-
tinct arcs with labels 3 and 2 may be &amp;quot;extended&amp;quot;
to (3,2) and (2,8) respectively. Extension formulas
are, in a sense, the heart of the SFG description
language, for without them RG analyses could not
be properly represented. 2
2 We gloss over many technicalities, e.g., the SFG notion
data justification and the formal semantics of stratified fea-
tures; cf. PI.
RG-style analyses can be captured in terms of
rules such as those above. Moreover, since the
above formulas state positive constraints, they can
be represented as S-graphs corresponding to the
minimal satisfying models of the respective formu-
las. We compile the various rules and their com-
binations into Rule Graphs and associate sets of
these with appropriate lexical anchors, resulting
in a lexicalized grammar. 3
S-graphs are formally feature structures: given
a collection of sister arcs, the stratified labels are
required to be functional. However, as shown in
the example, the individual R-signs are not. More-
over, the lengths of the labels can vary, and this
crucial property is how SFG avoids the &amp;quot;carry
over&amp;quot; problem. S-graphs also include a strict par-
tial order on arcs to represent linear precedence
(cf. [3], [9]). The SFG description language in-
cludes a class of linear precedence statements,
e.g., (1] -&lt; (H] means that in a constituent &amp;quot;the
final subject precedes the head&amp;quot;.
Given a set RS of R-signs, a (stratified) fea-
ture (or label) is a sequence of R-signs which may
be closed on the left or right or both. Closed sides
are indicated with square brackets and open sides
with parentheses. For example, [2, 1) denotes a la-
bel that is closed on the left and open on the right,
and [3, 2, 1, 0] denotes a label that is closed on both
sides. Labels of the form [- • -I are called (totally)
closed; of the form (• • .) (totally) open; and
the others partially closed (open) or closed
(open) on the right (left), as appropriate.
Let Br denote the set of features over RS*. Br
is partially ordered by the smallest relation E per-
mitting extension along open sides. For example,
</bodyText>
<listItem confidence="0.552956">
(3) g (3,2) c [3, 2, 1) E [3, 2, 1, 0].
</listItem>
<bodyText confidence="0.999167636363636">
Each feature 1 subsuming (E) a feature f provides
a partial description of f. The left-closed bracket [
allows reference to the &amp;quot;deepest&amp;quot; (initial) R-sign of
a left-closed feature; the right-closed bracket ] to
the &amp;quot;most surfacy&amp;quot; (final) R-sign of a right-closed
feature. The totally closed features are maximal
(completely defined) and with respect to label uni-
fication, defined below, act like ordinary (atomic)
features.
Formal definitions of S-graph and other defini-
tions implicit in our work are provided in [2].
</bodyText>
<footnote confidence="0.454954">
3 We ignore negative constraints here.
</footnote>
<page confidence="0.989486">
98
</page>
<sectionHeader confidence="0.728334" genericHeader="method">
AN EXAMPLE
</sectionHeader>
<bodyText confidence="0.998803647058824">
Figure 2 depicts the essential aspects of the S-
graph for John seemed ill. Focus on the features
[0,1] and [2,1,0], both of which have the NP John
as target (indicated by the i&apos;s). The R-sign 0 is
a member of Null, a distinguished set of R-signs,
members of which can only occur next to brackets
[ or ]. The prefix [2,1) of the label [2,1,0] is the
SFG representation of RG&apos;s unaccusative analysis
of adjectives. The suffix (1,0] of [2,1,0]; the prefix
[0,1) of the label [0,1] in the matrix clause; and the
structure-sharing collectively represent the raising
of the embedded subject (cf. Figure 3).
Given an S-graph G, Null R-signs permit the
definitions of the predicate-argument graph,
and the surface graph, of G. The predicate-
argument graph corresponds to all arcs whose la-
bels do not begin with a Null R-sign; the rele-
vant R-signs are the first ones. The surface graph
corresponds to all arcs whose labels do not end
with a Null R-sign; the relevant R-signs are the
final ones. In the example, the arc labeled [0,1]
is not a predicate-argument arc, indicating that
John bears no predicate-argument relation to the
top clause. And the arc labeled [2,1,0] is not a
surface arc, indicating that John bears no surface
relation to the embedded phrase headed by ill.
The surface graph is shown in Figure 4 and
the predicate-argument graph in Figure 5. No-
tice that the surface graph is a tree. The tree-
hood of surface graphs is part of the defini-
tion of S-graph and provides the foundation for
our parsing algorithm; it is the SFG analog to
the &amp;quot;context-free backbone&amp;quot; typical of unification-
based systems [11].
</bodyText>
<sectionHeader confidence="0.534406" genericHeader="method">
LEXICALIZED SFG
</sectionHeader>
<bodyText confidence="0.999103571428572">
Given a finite collection of rule graphs, we could
construct the finite set of S-graphs reflecting all
consistent combinations of rule graphs and then
associate each word with the collection of derived
graphs it anchors. However, we actually only con-
struct all the derived graphs not involving extrac-
tions. Since extractions can affect almost any arc,
compiling them into lexicalized S-graphs would be
impractical. Instead, extractions are handled by
a novel mechanism involving multi-rooted graphs
(cf. Concluding Remarks).
We assume that all lexically governed rules such
as Passive, Dative Advancement and Raising are
compiled into the lexical entries governing them.
</bodyText>
<figure confidence="0.951876555555556">
[Cat] VP
-
[0, 1] i John
_
[H] seemed
[Cat] AP
[C] [2, 1, 0] i
[H] _
ill
</figure>
<figureCaption confidence="0.9994035">
Figure 3: Raising Rule Graph
Figure 4: Surface Graph for John seemed ill
</figureCaption>
<figure confidence="0.998482857142857">
[Cat] VP
[H] seemed
[Cat] AP
a
[C] [2) John
[H] in
-
</figure>
<figureCaption confidence="0.990556">
Figure 5: Predicate-Argument Graph for John
seemed ill
Figure 2: S-graph for John seemed ill
</figureCaption>
<figure confidence="0.998574">
[0,1) A
I
[C] A
[Cat] VP
-
(1] i John
....._
[H] seemed
[C] [[Cat] AP 1
[H] in
- -
-
</figure>
<page confidence="0.987308">
99
</page>
<bodyText confidence="0.997820266666667">
Thus, given has four entries (Ditransitive, Ditran-
sitive + Dative, Passive, Dative + Passive). This
aspect of our framework is reminiscent of LFG
[4] and HPSG [7], except that in SFG, relational
structure is transparently recorded in the stratified
features. Moreover, SFG relies neither on LFG-
style annotated CFG rules and equation solving
nor on HPSG-style SUBCAT lists.
We illustrate below the process of constructing
a lexical entry for given from rule graphs (ignor-
ing morphology). The rule graphs used are for
Ditransitive, Dative and (Agentless) Passive con-
structions. Combined, they yield a ditransitive-
dative-passive S-graph for the use of given occur-
ring in Joe was given tea (cf. Figure 6).
</bodyText>
<figure confidence="0.999484166666667">
[Cat] S
[0, 1] i Joe
[H] was
[Cat] VP
[H] given
[3, 2, 1, 0]
[2,8]
- [1, 8, 0]
_
[C]
N
tea
</figure>
<figureCaption confidence="0.996569">
Figure 6: S-graph for Joe was given tea.
</figureCaption>
<equation confidence="0.750642166666667">
(DI U DAT) UPAS:
_
[H] given
[3, 2, 1)
[2,8)
[1, 8, 0]
</equation>
<bodyText confidence="0.9996655">
The idea behind label unification is that
two compatible labels combine to yield a label
with maximal nonempty overlap. Left (right)
closed labels unify with left (right) open labels to
yield left (right) closed labels. There are ten types
of label unification, determined by the four types
of bracket pairs: totally closed (open), closed only
on the left (right). However, in parsing (as op-
posed to building a lexicalized grammar), we stip-
ulate that successful label unification must result
in a totally closed label. Additionally, we assume
that all labels in well-formed lexicalized graphs
(the input graphs to the parsing algorithm) are at
least partially closed. This leaves only four cases:
</bodyText>
<table confidence="0.595061">
- Case 1. [a] U [a] = [a]
Case 2. [a) U [a[3] = [a[3]
_ Case 3. (a] U [pa] = [8a]
(2, 1) Case 4. [af3) U (f3-y] = [0-y]
[1,8,0] Note: a, 0,-y E &apos;R.S* and )3 is the longest com-
.. _ mon, nonempty string.
</table>
<figure confidence="0.9721937">
DItransitive:
given
DATive:
DI U DAT:
[H] given
[3,2)
[2,8)
[1)
_
PASsive:
</figure>
<page confidence="0.871381">
100
</page>
<bodyText confidence="0.965824">
The following list provides examples of each.
</bodyText>
<listItem confidence="0.9830185">
1. [1,0] U [1,0] [1,0]
2. [1) U [1,0] = [1,0]
3. (1,0] U [2,1,0] = [2,1,0]
4. [2,1) U (1,0] = [2,1,0]
</listItem>
<bodyText confidence="0.999637769230769">
Case 1 is the same as ordinary label unifica-
tion under identity. Besides their roles in unifying
rule-graphs, Cases 2, 3 and 4 are typically used
in parsing bounded control constructions (e.g.,
&amp;quot;equi&amp;quot; and &amp;quot;raising&amp;quot;) and extractions by means
of &amp;quot;splicing&amp;quot; Null R-signs onto the open ends of
labels and closing off the labels in the process. We
note in passing that cases involving totally open
labels may not result in unique unifications, e.g.,
(1,2) U (2, 1) can be either (2,1,2) or (1,2,1). In
practice, such aberrant cases seem not to arise.
Label unification thus plays a central role in build-
ing a lexicalized grammar and in parsing.
</bodyText>
<sectionHeader confidence="0.938367" genericHeader="method">
THE PARSING ALGORITHM
</sectionHeader>
<bodyText confidence="0.973277875">
S-unification is like normal feature structure
unification ([1], [11]), except that in certain cases
two arcs with distinct labels 1 and l&apos; are replaced
by a single arc whose label is obtained by unifying
1 and 1&apos;.
S-unification is implemented via the procedures
Unify-Nodes, Unify-Arcs, and Unify-Sets-of-
Arcs:
</bodyText>
<listItem confidence="0.9939705">
1. Unify-Nodes(n,n1 consists of the steps:
a. Unify label(n) and label(n&apos;), where node
labels unify under identity
b. Unify-Sets-of-Arcs(Out-Arcs(n), Out-
Arcs(0)
2. Unify-Arcs(A,A1 consists of the steps:
a. Unify label(A) and label(A&apos;)
b. Unify-Nodes(target(A),target(A1)
</listItem>
<sectionHeader confidence="0.4982" genericHeader="method">
3. Unify-Sets-of-Arcs(Seti, Set2),
</sectionHeader>
<bodyText confidence="0.990645102564102">
where Seti = , Ak} and Set2
{Am, , An}, returns a set of arcs Set3, de-
rived as follows:
a. For each arc Ai E Seti, attempt to find
some arc A&apos;i E Set2, such that Step 2a
of Unify-arcs(Ai, AO succeeds. If Step
2a succeeds, proceed to Step 2b and re-
move A&apos;, from Set2. There are three pos-
sibilities:
i. If no Xi can be found, Ai E Set3.
ii. If Step 2a and 2b both succeed, then
Unify-arcs(Ai, E Set3.
iii. If Step 2a succeeds, but Step 2b
fails, then the procedure fails.
b. Add each remaining arc in Set2 to Set3.
We note that the result of S-unification can be a
set of S-graphs. In our experience, the unification
of linguistically well-formed lexical S-graphs has
never returned more than one S-graph. Hence,
S-unification is stipulated to fail if the result is
not unique. Also note that due to the nature of
label unification, the unification procedure does
not guarantee that the unification of two S-graphs
will be functional and thus well-formed. To insure
functionality, we filter the output.
We distinguish several classes of Arc: (i) Sur-
face Arc vs. Non-Surface, determined by absence
or presence of a Null R-sign in a label&apos;s last
position; (ii) Structural Arc vs. Constraint Arc
(stipulated by the grammar writer); and (iii) Re-
lational Arc vs. Category Arc, determined by the
kind of label (category arcs are atomic and have
R-signs like Case, Number, Gender, etc.). The
parser looks for arcs to complete that are Sur-
face, Structural and Relational (SSR).
A simplified version of the parsing algorithm
is sketched below. It uses the predicates Left-
Precedence , Right-Precedence and Com-
plete:
</bodyText>
<listItem confidence="0.893269263157895">
1. Precedence: Let Qi = [ni, L„ Rd, F
E SSR-Out-Arcs(n) such that Target(F)
= Anchor(Graph(ni)), and A E SSR-Out-
Arcs(n2) be an incomplete terminal arc.
Then:
A. Left-Precedence(A, ni) is true iff:
a. All surface arcs which must follow
F are incomplete.
b. A can precede F.
c. All surface arcs which must both
precede F and follow A are com-
plete.
B. Right-Precedence(A, ni) is true if:
a. All surface arcs which must precede
F are complete.
b. A can follow F.
c. All surface arcs which must both
follow F and precede A are com-
plete.
</listItem>
<page confidence="0.967705">
101
</page>
<listItem confidence="0.494068">
2. Complete : A node is complete if it is either
a lexical anchor or else has (obligatory) out-
going SSR arcs, all of which are complete. An
arc is complete if its target is complete.
</listItem>
<bodyText confidence="0.985923333333333">
The algorithm is head-driven [8] and was in-
spired by parsing algorithms for lexicalized TAGs
([6], [101).
</bodyText>
<subsectionHeader confidence="0.893523">
Simplified Parsing Algorithm:
</subsectionHeader>
<bodyText confidence="0.512847">
Input: A string of words w1, . • • , wk.
Output: A chart containing all possible parses.
Method:
</bodyText>
<listItem confidence="0.948331166666667">
A. Initialization:
1. Create a list of k state-sets
, Sk, each empty.
2. For c = 1, . . . , k, for each
Graph(ni) of wc, add [ni, c — 1, c]
to Sc.
</listItem>
<subsectionHeader confidence="0.61664">
B. Completions:
</subsectionHeader>
<bodyText confidence="0.8062765">
For c = 1, k, do repeatedly until no
more states can be added to Sc:
</bodyText>
<listItem confidence="0.613747">
1. Leftward Completion:
For all
</listItem>
<equation confidence="0.382645375">
Q, = [rti, c] E Se,
Qi = [nil L31 Li] E Sr„, such that
Complete(nj) and
A E SSR-Out-Arcs(ni), such that
Left-Precedence(A,N)
IF Unify-at-end- of-Path(n,, n3, A)
n:,
THEN Add [n&apos;.„ Li, c] to Sc
</equation>
<listItem confidence="0.4004585">
2. Rightward Completion:
For all
</listItem>
<equation confidence="0.660911">
Qi = Li, Rd E SR,
Q3 = [ni, 174, E Sc such that
Complete(n3), and
A E SSR-Out-Arcs(n,), such that
Right-Precedence(A,n,)
IF Unify- at- end- of-P ath(n„ nj , A)
THEN Add [74, L,, c] to Sc.
</equation>
<bodyText confidence="0.998726754385965">
To illustrate, we step through the chart for John
seemed ill ( cf. Figure 7). In the string 0 John 1
seemed 2 ill 3, where the integers represent string
positions, each word w is associated via the lexi-
calized grammar with a finite set of anchored S-
graphs. For expository convenience, we will as-
sume counterfactually that for each w there is only
one S-graph G. with root rw and anchor w. Also
in the simplified case, we assume that the anchor
is always the target of an arc whose source is the
root. This is true in our example, but false in
general.
For each G., r. has one or more outgoing
SSR arcs, the set of which we denote SSR-Out-
Arcs(rw ). For each w between integers x and y
in the string, the Initialization step (step A of the
algorithm) adds [nm, x, y] to state set y. We de-
note state Q in state-set Ss as state i:Q. For an
input string co = w1, , w, initialization cre-
ates n state-sets and for 1 &lt; i &lt; n, adds states
i : Q3,1 &lt; j &lt; k, to Si , one for each of the k
S-graphs G., associated with w. After initializa-
tion, the example chart consists of states 1:1, 2:1,
3:1.
Then the parser traverses the chart from left to
right starting with state-set 1 (step B of the algo-
rithm), using left and right completions, according
to whether left or right precedence conditions are
used. Each completion looks in a state-set to the
left of Sc for a state meeting a set of conditions.
In the example, for c = 1, step B of the algorithm
does not find any states in any state-set preced-
ing S1 to test, so the parser advances c to 2. A
left completion succeeds with Q, = state 2:1 =
[ni, 1,2] and Q3 = state 1:1 = [ni, 0, 1]. State 2:2
= [74, 0, 2] is added to state-set 52, where n&apos;s =
Unify-at-end-of-Path(ni, ni, [0, 1)). Label [0, 1) is
closed off to yield [0, 1] in the output graph, since
no further R-signs may be added to the label once
the arc bearing the label is complete.
The precedence constraints are interpreted as
strict partial orders on the sets of outgoing SSR
arcs of each node (in contrast to the totally or-
dered lexicalized TAGs). Arc [0, 1) satisfies left-
precedence because: (i) [0, 1) is an incomplete ter-
minal arc, where a terminal arc is an SSR arc,
the target of which has no incomplete outgoing
surface arcs; (ii) all surface arcs (here, only [C])
which must follow the [H] arc are incomplete; (iii)
[0 1) can precede [H]; and (iv) there are no (incom-
plete) surface arcs which must occur between [0 1)
and [H]. (We say can in (iii) because the parser
accomodates variable word order.)
The parser precedes to state-set S3. A right
completion succeeds with Q = state 2:2 = 0, 2]
and c2; = state 3:1 = [77.; , 2, 3]. State 3:2 =
[7-4&apos;, 0, 3] is added to state set 53, n&apos;i = Unify-at-
</bodyText>
<page confidence="0.995062">
102
</page>
<table confidence="0.930252137931035">
1:1 I 2:1 I RP=2 3:1 I RP=3
VP IH1
c] AP&apos;
I 11.
seemed AP
(1,0
seemed
NP •
LP=0 RP=1 LP=1 LP=2
N I i. [0,1) NP ill
John NP ill
John
2:2 I RP=2 3:2 I RP=3
VP • lc.]
[H] 1. [CI AP*
seemed AP MI&apos;
(1,01 ill
John seemed ill
[0,1)
LPO LP=0
HP* VP •
(HJ. [0,1) [ 31.
John •
Lseemed
[2,1,0]
NP.
[H] i.
John
John seemed
</table>
<figureCaption confidence="0.996725">
Figure 7: Chart for John seemed ill.
</figureCaption>
<bodyText confidence="0.999891555555556">
end-of-Path(nii, n, [C]). State 3:2 is a successful
parse because n:&apos; is complete and spans the entire
input string.
To sum up: a completion finds a state Qi =
[7-4, L„ Ri] and a state Qi = [ni , Li , Ri] in adja-
cent state-sets (Li = Rj or Ri = Li) such that
ni is incomplete and nj is complete. Each success-
ful completion completes an arc A E SSR-Out-
Arcs(ni) by unifying nj with the target of A. Left
completion operates on a state Qi = [ni, Li, c]
in the current state-set S, looking for a state
Qi = [ni, L3, Ly] in state-set SL, to complete some
arc A E SSR-Out-Arcs(ni). Right completion is
the same as left completion except that the roles
of the two states are reversed: in both cases, suc-
cess adds a new state to the current state-set Sc.
The parser completes arcs first leftward from the
anchor and then rightward from the anchor.
</bodyText>
<sectionHeader confidence="0.995484" genericHeader="conclusions">
CONCLUDING REMARKS
</sectionHeader>
<bodyText confidence="0.999978">
The algorithm described above is simpler than
the one we have implemented in a number of ways.
We end by briefly mentioning some aspects of the
</bodyText>
<figure confidence="0.946055">
VP
PP
IFI [M]
in NP
</figure>
<figureCaption confidence="0.999236">
Figure 8: Example: in
</figureCaption>
<figure confidence="0.704531">
what
</figure>
<figureCaption confidence="0.999532">
Figure 9: Example: What
</figureCaption>
<bodyText confidence="0.992867130434782">
general algorithm.
Optional Arcs: On encountering an optional
arc, the parser considers two paths, skipping the
optional arc on one and attempting to complete it
on the other.
Constraint Arcs These are reminiscent of
LFG constraint equations. For a parse to be good,
each constraint arc must unify with a structural
arc.
Multi-tiered S-graphs: These are S-graphs
having a non-terminal incomplete arc I (e.g., the
[LOC] arc in Figure 8. Essentially, the parser
searches I depth-first for incomplete terminal arcs
to complete.
Pseudo-R-signs: These are names of sets of
R-signs. For a parse to be good, each pseudo-R-
sign must unify with a member of the set it names.
Extractions: Our approach is novel: it uses
pseudo-R-signs and multirooted S-graphs, illus-
trated in Figure 9, where p is the primary root and
d, the dangling root, is the source of a &amp;quot;slashed
arc&amp;quot; with label of the form (b, /J (b a pseudo-
R-sign). Since well-formed final parses must be
</bodyText>
<figure confidence="0.982340333333333">
[H]
[LOC]
[c]
</figure>
<page confidence="0.997531">
103
</page>
<bodyText confidence="0.999718272727273">
single-rooted, slashed arcs must eventually unify
with another arc.
To sum up: We have developed a unification-
based, chart parser for relational grammars based
on the SFG formalism presented by Johnson and
Moss [2]. The system involves compiling (combi-
nations) of rules graphs and their associated lexi-
cal anchors into a lexicalized grammar, which can
then be parsed in the same spirit as lexicalized
TAGs. Note, though, that SFG does not use an
adjunction (or substitution) operation.
</bodyText>
<sectionHeader confidence="0.998877" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999958153846154">
[1] Bob Carpenter. The Logic of Typed Feature
Structures. Cambridge UP, Cambridge, 1992.
[2] David E. Johnson and Lawrence S. Moss.
Some formal properties of stratified feature
grammars. To appear in Annals of Mathe-
matics and Artificial Intelligence, 1993.
[3] David E. Johnson and Paul M. Postal. Arc
Pair Grammar. Princeton University Press,
1980.
[4] Ronald Kaplan and Joan Bresnan. Lexical-
functional grammar, a formal system for
grammatical representation. In J. Bresnan,
editor, The Mental Representation of Gram-
matical Relations. MIT Press, 1982.
[5] Robert Kasper and William C. Rounds. The
logic of unification in grammar. Linguistics
and Philosophy, 13:35-58, 1990.
[6] Alberto Lavelli and Giorgio Satta. Bidirec-
tional parsing of lexicalized tree adjoining
grammars. In Proceedings of the 5th Confer-
ence of the European Chapter of the Associa-
tion of Computational Linguistics, 1991.
[7] Carl Pollard and Ivan Sag. Information-based
Syntax and Semantics. CSLI Lecture Notes.
University of Chicago Press, Chicago, 1987.
[8] Derek Proudian and Carl Pollard. Parsing
head-driven phrase structure grammar. In
Proceedings of the 23rd Annual Meeting of the
ACL, 1985.
[9] William C. Rounds and Alexis Manaster-
Ramer. A logical version of functional gram-
mar. In Proceedings of The 25th Annual
Meeting of the Association for Computational
Linguistics, 1987.
[10] Yves Schabes. Mathematical and Compu-
tational Properties of Lexicalized Grammars.
PhD thesis, University of Pennsylvania, 1990.
[11] Stuart Shieber. Constraint-Based Grammar
Formalisms. MIT Press, 1992.
</reference>
<page confidence="0.998787">
104
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.714675">
<title confidence="0.9971925">A UNIFICATION-BASED PARSER FOR RELATIONAL GRAMMAR</title>
<author confidence="1">David E Johnson</author>
<affiliation confidence="0.999879">IBM Research Division</affiliation>
<address confidence="0.9933005">P.O. Box 218 Yorktown Heights, NY 10598</address>
<email confidence="0.88358">djohns@watson.ibm.corn</email>
<author confidence="0.991354">Adam Meyers</author>
<affiliation confidence="0.9851965">Linguistics Department New York University</affiliation>
<address confidence="0.996117">New York, NY 10003</address>
<email confidence="0.998375">meyers@acf2.nyu.edu</email>
<author confidence="0.896226">Lawrence S Moss</author>
<affiliation confidence="0.9992715">Mathematics Department Indiana University</affiliation>
<address confidence="0.999934">Bloomington, IN 47401</address>
<email confidence="0.999822">lmoss@indiana.edu</email>
<abstract confidence="0.997058">We present an implemented unification-based parser for relational grammars developed within feature grammar (SFG) framework, which generalizes Kasper-Rounds logic to handle relational grammar analyses. We first introduce the key aspects of SFG and a lexicalized, graph-based variant of the framework suitable for implementing relational grammars. We then describe a head-driven chart parser for lexicalized SFG. The basic parsing operation is essentially ordinary feature-structure unification augmented an operation of unification build the stratified features characteristic of SFG.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Bob Carpenter</author>
</authors>
<title>The Logic of Typed Feature Structures. Cambridge UP,</title>
<date>1992</date>
<location>Cambridge,</location>
<contexts>
<context position="1304" citStr="[1]" startWordPosition="180" endWordPosition="180">onal grammars. We then describe a head-driven chart parser for lexicalized SFG. The basic parsing operation is essentially ordinary feature-structure unification augmented with an operation of label unification to build the stratified features characteristic of SFG. INTRODUCTION Although the impact of relational grammar (RG) on theoretical linguistics has been substantial, it has never previously been put in a form suitable for computational use. RG&apos;s multiple syntactic strata would seem to preclude its use in the kind of monotonic, unification-based parsing system many now consider standard ([1], [11]). However, recent work by Johnson and Moss [2] on a Kasper-Rounds (KR) style logic-based formalism [5] for RG, called Stratified Feature Grammar (SFG), has demonstrated that even RG&apos;s multiple strata are amenable to a feature-structure treatment. Based on this work, we have developed a unification-based, chart parser for a lexical version of SFG suitable for building computational relational grammars. A lexicalized SFG is simply a collection of stratified feature graphs (Sgraphs), each of which is anchored to a lexical item, analogous to lexicalized TAGs [10]. The basic parsing operatio</context>
<context position="3026" citStr="[1]" startWordPosition="457" endWordPosition="457">n worse, these &amp;quot;carry over&amp;quot; equations vary from case to case. SFG avoids this problem. STRATIFIED FEATURE GRAMMAR SFG&apos;s key innovation is the generalization of the concept feature to a sequence of so-called relational signs (R-signs). The interpretation of a stratified feature is that each R-sign in a sequence denotes a primitive relation in different strata. 1 For instance, in Joe gave Mary tea there are, at the clause level, four sister arcs (arcs with the same source node), as shown in Figure 1: one arc labeled [H] with target gave, indicating gave is the head of the clause; one with label [1] and target Joe, indicating Joe is both the predicateargument, and surface subject, of the clause; one with label [3,2] and target Mary, indicating that &apos;We use the following R-signs: 1 (subject), 2 (direct object), 3 (indirect object), 8 (chOmeur), Cat (Category), C (comp), F (flag), H (head), LOC (locative), M (marked), as well as the special Null R-signs 0 and/, explained below. 9 7 [Cat] S [1] Joe [H] gave [3,2] Mary [2,8] tea Figure 1: S-graph for Joe gave Mary tea. Mary is the predicate-argument indirect object, but the surface direct object, of the clause; and one with label [2,8] and t</context>
<context position="6381" citStr="[3, 2, 1, 0]" startWordPosition="1038" endWordPosition="1041">ids the &amp;quot;carry over&amp;quot; problem. S-graphs also include a strict partial order on arcs to represent linear precedence (cf. [3], [9]). The SFG description language includes a class of linear precedence statements, e.g., (1] -&lt; (H] means that in a constituent &amp;quot;the final subject precedes the head&amp;quot;. Given a set RS of R-signs, a (stratified) feature (or label) is a sequence of R-signs which may be closed on the left or right or both. Closed sides are indicated with square brackets and open sides with parentheses. For example, [2, 1) denotes a label that is closed on the left and open on the right, and [3, 2, 1, 0] denotes a label that is closed on both sides. Labels of the form [- • -I are called (totally) closed; of the form (• • .) (totally) open; and the others partially closed (open) or closed (open) on the right (left), as appropriate. Let Br denote the set of features over RS*. Br is partially ordered by the smallest relation E permitting extension along open sides. For example, (3) g (3,2) c [3, 2, 1) E [3, 2, 1, 0]. Each feature 1 subsuming (E) a feature f provides a partial description of f. The left-closed bracket [ allows reference to the &amp;quot;deepest&amp;quot; (initial) R-sign of a left-closed feature; </context>
<context position="7711" citStr="[2,1,0]" startWordPosition="1278" endWordPosition="1278">maximal (completely defined) and with respect to label unification, defined below, act like ordinary (atomic) features. Formal definitions of S-graph and other definitions implicit in our work are provided in [2]. 3 We ignore negative constraints here. 98 AN EXAMPLE Figure 2 depicts the essential aspects of the Sgraph for John seemed ill. Focus on the features [0,1] and [2,1,0], both of which have the NP John as target (indicated by the i&apos;s). The R-sign 0 is a member of Null, a distinguished set of R-signs, members of which can only occur next to brackets [ or ]. The prefix [2,1) of the label [2,1,0] is the SFG representation of RG&apos;s unaccusative analysis of adjectives. The suffix (1,0] of [2,1,0]; the prefix [0,1) of the label [0,1] in the matrix clause; and the structure-sharing collectively represent the raising of the embedded subject (cf. Figure 3). Given an S-graph G, Null R-signs permit the definitions of the predicate-argument graph, and the surface graph, of G. The predicateargument graph corresponds to all arcs whose labels do not begin with a Null R-sign; the relevant R-signs are the first ones. The surface graph corresponds to all arcs whose labels do not end with a Null R-sig</context>
<context position="9685" citStr="[0, 1]" startWordPosition="1600" endWordPosition="1601">raphs reflecting all consistent combinations of rule graphs and then associate each word with the collection of derived graphs it anchors. However, we actually only construct all the derived graphs not involving extractions. Since extractions can affect almost any arc, compiling them into lexicalized S-graphs would be impractical. Instead, extractions are handled by a novel mechanism involving multi-rooted graphs (cf. Concluding Remarks). We assume that all lexically governed rules such as Passive, Dative Advancement and Raising are compiled into the lexical entries governing them. [Cat] VP - [0, 1] i John _ [H] seemed [Cat] AP [C] [2, 1, 0] i [H] _ ill Figure 3: Raising Rule Graph Figure 4: Surface Graph for John seemed ill [Cat] VP [H] seemed [Cat] AP a [C] [2) John [H] in - Figure 5: Predicate-Argument Graph for John seemed ill Figure 2: S-graph for John seemed ill [0,1) A I [C] A [Cat] VP - (1] i John ....._ [H] seemed [C] [[Cat] AP 1 [H] in - - - 99 Thus, given has four entries (Ditransitive, Ditransitive + Dative, Passive, Dative + Passive). This aspect of our framework is reminiscent of LFG [4] and HPSG [7], except that in SFG, relational structure is transparently recorded in the</context>
<context position="10936" citStr="[1, 8, 0]" startWordPosition="1837" endWordPosition="1839"> neither on LFGstyle annotated CFG rules and equation solving nor on HPSG-style SUBCAT lists. We illustrate below the process of constructing a lexical entry for given from rule graphs (ignoring morphology). The rule graphs used are for Ditransitive, Dative and (Agentless) Passive constructions. Combined, they yield a ditransitivedative-passive S-graph for the use of given occurring in Joe was given tea (cf. Figure 6). [Cat] S [0, 1] i Joe [H] was [Cat] VP [H] given [3, 2, 1, 0] [2,8] - [1, 8, 0] _ [C] N tea Figure 6: S-graph for Joe was given tea. (DI U DAT) UPAS: _ [H] given [3, 2, 1) [2,8) [1, 8, 0] The idea behind label unification is that two compatible labels combine to yield a label with maximal nonempty overlap. Left (right) closed labels unify with left (right) open labels to yield left (right) closed labels. There are ten types of label unification, determined by the four types of bracket pairs: totally closed (open), closed only on the left (right). However, in parsing (as opposed to building a lexicalized grammar), we stipulate that successful label unification must result in a totally closed label. Additionally, we assume that all labels in well-formed lexicalized graphs (the i</context>
<context position="12788" citStr="[1]" startWordPosition="2163" endWordPosition="2163">nd 4 are typically used in parsing bounded control constructions (e.g., &amp;quot;equi&amp;quot; and &amp;quot;raising&amp;quot;) and extractions by means of &amp;quot;splicing&amp;quot; Null R-signs onto the open ends of labels and closing off the labels in the process. We note in passing that cases involving totally open labels may not result in unique unifications, e.g., (1,2) U (2, 1) can be either (2,1,2) or (1,2,1). In practice, such aberrant cases seem not to arise. Label unification thus plays a central role in building a lexicalized grammar and in parsing. THE PARSING ALGORITHM S-unification is like normal feature structure unification ([1], [11]), except that in certain cases two arcs with distinct labels 1 and l&apos; are replaced by a single arc whose label is obtained by unifying 1 and 1&apos;. S-unification is implemented via the procedures Unify-Nodes, Unify-Arcs, and Unify-Sets-ofArcs: 1. Unify-Nodes(n,n1 consists of the steps: a. Unify label(n) and label(n&apos;), where node labels unify under identity b. Unify-Sets-of-Arcs(Out-Arcs(n), OutArcs(0) 2. Unify-Arcs(A,A1 consists of the steps: a. Unify label(A) and label(A&apos;) b. Unify-Nodes(target(A),target(A1) 3. Unify-Sets-of-Arcs(Seti, Set2), where Seti = , Ak} and Set2 {Am, , An}, return</context>
<context position="18169" citStr="[ni, 1,2]" startWordPosition="3151" endWordPosition="3152">hs G., associated with w. After initialization, the example chart consists of states 1:1, 2:1, 3:1. Then the parser traverses the chart from left to right starting with state-set 1 (step B of the algorithm), using left and right completions, according to whether left or right precedence conditions are used. Each completion looks in a state-set to the left of Sc for a state meeting a set of conditions. In the example, for c = 1, step B of the algorithm does not find any states in any state-set preceding S1 to test, so the parser advances c to 2. A left completion succeeds with Q, = state 2:1 = [ni, 1,2] and Q3 = state 1:1 = [ni, 0, 1]. State 2:2 = [74, 0, 2] is added to state-set 52, where n&apos;s = Unify-at-end-of-Path(ni, ni, [0, 1)). Label [0, 1) is closed off to yield [0, 1] in the output graph, since no further R-signs may be added to the label once the arc bearing the label is complete. The precedence constraints are interpreted as strict partial orders on the sets of outgoing SSR arcs of each node (in contrast to the totally ordered lexicalized TAGs). Arc [0, 1) satisfies leftprecedence because: (i) [0, 1) is an incomplete terminal arc, where a terminal arc is an SSR arc, the target of wh</context>
<context position="19570" citStr="[2,1,0]" startWordPosition="3436" endWordPosition="3436">surface arcs which must occur between [0 1) and [H]. (We say can in (iii) because the parser accomodates variable word order.) The parser precedes to state-set S3. A right completion succeeds with Q = state 2:2 = 0, 2] and c2; = state 3:1 = [77.; , 2, 3]. State 3:2 = [7-4&apos;, 0, 3] is added to state set 53, n&apos;i = Unify-at102 1:1 I 2:1 I RP=2 3:1 I RP=3 VP IH1 c] AP&apos; I 11. seemed AP (1,0 seemed NP • LP=0 RP=1 LP=1 LP=2 N I i. [0,1) NP ill John NP ill John 2:2 I RP=2 3:2 I RP=3 VP • lc.] [H] 1. [CI AP* seemed AP MI&apos; (1,01 ill John seemed ill [0,1) LPO LP=0 HP* VP • (HJ. [0,1) [ 31. John • Lseemed [2,1,0] NP. [H] i. John John seemed Figure 7: Chart for John seemed ill. end-of-Path(nii, n, [C]). State 3:2 is a successful parse because n:&apos; is complete and spans the entire input string. To sum up: a completion finds a state Qi = [7-4, L„ Ri] and a state Qi = [ni , Li , Ri] in adjacent state-sets (Li = Rj or Ri = Li) such that ni is incomplete and nj is complete. Each successful completion completes an arc A E SSR-OutArcs(ni) by unifying nj with the target of A. Left completion operates on a state Qi = [ni, Li, c] in the current state-set S, looking for a state Qi = [ni, L3, Ly] in state-set SL, t</context>
</contexts>
<marker>[1]</marker>
<rawString>Bob Carpenter. The Logic of Typed Feature Structures. Cambridge UP, Cambridge, 1992.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David E Johnson</author>
<author>Lawrence S Moss</author>
</authors>
<title>Some formal properties of stratified feature grammars.</title>
<date>1993</date>
<booktitle>Annals of Mathematics and Artificial Intelligence,</booktitle>
<note>To appear in</note>
<contexts>
<context position="1357" citStr="[2]" startWordPosition="190" endWordPosition="190">arser for lexicalized SFG. The basic parsing operation is essentially ordinary feature-structure unification augmented with an operation of label unification to build the stratified features characteristic of SFG. INTRODUCTION Although the impact of relational grammar (RG) on theoretical linguistics has been substantial, it has never previously been put in a form suitable for computational use. RG&apos;s multiple syntactic strata would seem to preclude its use in the kind of monotonic, unification-based parsing system many now consider standard ([1], [11]). However, recent work by Johnson and Moss [2] on a Kasper-Rounds (KR) style logic-based formalism [5] for RG, called Stratified Feature Grammar (SFG), has demonstrated that even RG&apos;s multiple strata are amenable to a feature-structure treatment. Based on this work, we have developed a unification-based, chart parser for a lexical version of SFG suitable for building computational relational grammars. A lexicalized SFG is simply a collection of stratified feature graphs (Sgraphs), each of which is anchored to a lexical item, analogous to lexicalized TAGs [10]. The basic parsing operation of the system is S-graph unification (S-unification</context>
<context position="3145" citStr="[3,2]" startWordPosition="477" endWordPosition="477">&apos;s key innovation is the generalization of the concept feature to a sequence of so-called relational signs (R-signs). The interpretation of a stratified feature is that each R-sign in a sequence denotes a primitive relation in different strata. 1 For instance, in Joe gave Mary tea there are, at the clause level, four sister arcs (arcs with the same source node), as shown in Figure 1: one arc labeled [H] with target gave, indicating gave is the head of the clause; one with label [1] and target Joe, indicating Joe is both the predicateargument, and surface subject, of the clause; one with label [3,2] and target Mary, indicating that &apos;We use the following R-signs: 1 (subject), 2 (direct object), 3 (indirect object), 8 (chOmeur), Cat (Category), C (comp), F (flag), H (head), LOC (locative), M (marked), as well as the special Null R-signs 0 and/, explained below. 9 7 [Cat] S [1] Joe [H] gave [3,2] Mary [2,8] tea Figure 1: S-graph for Joe gave Mary tea. Mary is the predicate-argument indirect object, but the surface direct object, of the clause; and one with label [2,8] and target tea, indicating tea is the predicate-argument direct object, but surface chameur, of the clause. Such a structure</context>
<context position="6381" citStr="[3, 2, 1, 0]" startWordPosition="1038" endWordPosition="1041">ids the &amp;quot;carry over&amp;quot; problem. S-graphs also include a strict partial order on arcs to represent linear precedence (cf. [3], [9]). The SFG description language includes a class of linear precedence statements, e.g., (1] -&lt; (H] means that in a constituent &amp;quot;the final subject precedes the head&amp;quot;. Given a set RS of R-signs, a (stratified) feature (or label) is a sequence of R-signs which may be closed on the left or right or both. Closed sides are indicated with square brackets and open sides with parentheses. For example, [2, 1) denotes a label that is closed on the left and open on the right, and [3, 2, 1, 0] denotes a label that is closed on both sides. Labels of the form [- • -I are called (totally) closed; of the form (• • .) (totally) open; and the others partially closed (open) or closed (open) on the right (left), as appropriate. Let Br denote the set of features over RS*. Br is partially ordered by the smallest relation E permitting extension along open sides. For example, (3) g (3,2) c [3, 2, 1) E [3, 2, 1, 0]. Each feature 1 subsuming (E) a feature f provides a partial description of f. The left-closed bracket [ allows reference to the &amp;quot;deepest&amp;quot; (initial) R-sign of a left-closed feature; </context>
<context position="7711" citStr="[2,1,0]" startWordPosition="1278" endWordPosition="1278">maximal (completely defined) and with respect to label unification, defined below, act like ordinary (atomic) features. Formal definitions of S-graph and other definitions implicit in our work are provided in [2]. 3 We ignore negative constraints here. 98 AN EXAMPLE Figure 2 depicts the essential aspects of the Sgraph for John seemed ill. Focus on the features [0,1] and [2,1,0], both of which have the NP John as target (indicated by the i&apos;s). The R-sign 0 is a member of Null, a distinguished set of R-signs, members of which can only occur next to brackets [ or ]. The prefix [2,1) of the label [2,1,0] is the SFG representation of RG&apos;s unaccusative analysis of adjectives. The suffix (1,0] of [2,1,0]; the prefix [0,1) of the label [0,1] in the matrix clause; and the structure-sharing collectively represent the raising of the embedded subject (cf. Figure 3). Given an S-graph G, Null R-signs permit the definitions of the predicate-argument graph, and the surface graph, of G. The predicateargument graph corresponds to all arcs whose labels do not begin with a Null R-sign; the relevant R-signs are the first ones. The surface graph corresponds to all arcs whose labels do not end with a Null R-sig</context>
<context position="9728" citStr="[2, 1, 0]" startWordPosition="1610" endWordPosition="1612">ions of rule graphs and then associate each word with the collection of derived graphs it anchors. However, we actually only construct all the derived graphs not involving extractions. Since extractions can affect almost any arc, compiling them into lexicalized S-graphs would be impractical. Instead, extractions are handled by a novel mechanism involving multi-rooted graphs (cf. Concluding Remarks). We assume that all lexically governed rules such as Passive, Dative Advancement and Raising are compiled into the lexical entries governing them. [Cat] VP - [0, 1] i John _ [H] seemed [Cat] AP [C] [2, 1, 0] i [H] _ ill Figure 3: Raising Rule Graph Figure 4: Surface Graph for John seemed ill [Cat] VP [H] seemed [Cat] AP a [C] [2) John [H] in - Figure 5: Predicate-Argument Graph for John seemed ill Figure 2: S-graph for John seemed ill [0,1) A I [C] A [Cat] VP - (1] i John ....._ [H] seemed [C] [[Cat] AP 1 [H] in - - - 99 Thus, given has four entries (Ditransitive, Ditransitive + Dative, Passive, Dative + Passive). This aspect of our framework is reminiscent of LFG [4] and HPSG [7], except that in SFG, relational structure is transparently recorded in the stratified features. Moreover, SFG relies </context>
<context position="12025" citStr="[2,1,0]" startWordPosition="2035" endWordPosition="2035">ust result in a totally closed label. Additionally, we assume that all labels in well-formed lexicalized graphs (the input graphs to the parsing algorithm) are at least partially closed. This leaves only four cases: - Case 1. [a] U [a] = [a] Case 2. [a) U [a[3] = [a[3] _ Case 3. (a] U [pa] = [8a] (2, 1) Case 4. [af3) U (f3-y] = [0-y] [1,8,0] Note: a, 0,-y E &apos;R.S* and )3 is the longest com.. _ mon, nonempty string. DItransitive: given DATive: DI U DAT: [H] given [3,2) [2,8) [1) _ PASsive: 100 The following list provides examples of each. 1. [1,0] U [1,0] [1,0] 2. [1) U [1,0] = [1,0] 3. (1,0] U [2,1,0] = [2,1,0] 4. [2,1) U (1,0] = [2,1,0] Case 1 is the same as ordinary label unification under identity. Besides their roles in unifying rule-graphs, Cases 2, 3 and 4 are typically used in parsing bounded control constructions (e.g., &amp;quot;equi&amp;quot; and &amp;quot;raising&amp;quot;) and extractions by means of &amp;quot;splicing&amp;quot; Null R-signs onto the open ends of labels and closing off the labels in the process. We note in passing that cases involving totally open labels may not result in unique unifications, e.g., (1,2) U (2, 1) can be either (2,1,2) or (1,2,1). In practice, such aberrant cases seem not to arise. Label unificatio</context>
<context position="18169" citStr="[ni, 1,2]" startWordPosition="3151" endWordPosition="3152">hs G., associated with w. After initialization, the example chart consists of states 1:1, 2:1, 3:1. Then the parser traverses the chart from left to right starting with state-set 1 (step B of the algorithm), using left and right completions, according to whether left or right precedence conditions are used. Each completion looks in a state-set to the left of Sc for a state meeting a set of conditions. In the example, for c = 1, step B of the algorithm does not find any states in any state-set preceding S1 to test, so the parser advances c to 2. A left completion succeeds with Q, = state 2:1 = [ni, 1,2] and Q3 = state 1:1 = [ni, 0, 1]. State 2:2 = [74, 0, 2] is added to state-set 52, where n&apos;s = Unify-at-end-of-Path(ni, ni, [0, 1)). Label [0, 1) is closed off to yield [0, 1] in the output graph, since no further R-signs may be added to the label once the arc bearing the label is complete. The precedence constraints are interpreted as strict partial orders on the sets of outgoing SSR arcs of each node (in contrast to the totally ordered lexicalized TAGs). Arc [0, 1) satisfies leftprecedence because: (i) [0, 1) is an incomplete terminal arc, where a terminal arc is an SSR arc, the target of wh</context>
<context position="19570" citStr="[2,1,0]" startWordPosition="3436" endWordPosition="3436">surface arcs which must occur between [0 1) and [H]. (We say can in (iii) because the parser accomodates variable word order.) The parser precedes to state-set S3. A right completion succeeds with Q = state 2:2 = 0, 2] and c2; = state 3:1 = [77.; , 2, 3]. State 3:2 = [7-4&apos;, 0, 3] is added to state set 53, n&apos;i = Unify-at102 1:1 I 2:1 I RP=2 3:1 I RP=3 VP IH1 c] AP&apos; I 11. seemed AP (1,0 seemed NP • LP=0 RP=1 LP=1 LP=2 N I i. [0,1) NP ill John NP ill John 2:2 I RP=2 3:2 I RP=3 VP • lc.] [H] 1. [CI AP* seemed AP MI&apos; (1,01 ill John seemed ill [0,1) LPO LP=0 HP* VP • (HJ. [0,1) [ 31. John • Lseemed [2,1,0] NP. [H] i. John John seemed Figure 7: Chart for John seemed ill. end-of-Path(nii, n, [C]). State 3:2 is a successful parse because n:&apos; is complete and spans the entire input string. To sum up: a completion finds a state Qi = [7-4, L„ Ri] and a state Qi = [ni , Li , Ri] in adjacent state-sets (Li = Rj or Ri = Li) such that ni is incomplete and nj is complete. Each successful completion completes an arc A E SSR-OutArcs(ni) by unifying nj with the target of A. Left completion operates on a state Qi = [ni, Li, c] in the current state-set S, looking for a state Qi = [ni, L3, Ly] in state-set SL, t</context>
</contexts>
<marker>[2]</marker>
<rawString>David E. Johnson and Lawrence S. Moss. Some formal properties of stratified feature grammars. To appear in Annals of Mathematics and Artificial Intelligence, 1993.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David E Johnson</author>
<author>Paul M Postal</author>
</authors>
<title>Arc Pair Grammar.</title>
<date>1980</date>
<publisher>Princeton University Press,</publisher>
<contexts>
<context position="3145" citStr="[3,2]" startWordPosition="477" endWordPosition="477">&apos;s key innovation is the generalization of the concept feature to a sequence of so-called relational signs (R-signs). The interpretation of a stratified feature is that each R-sign in a sequence denotes a primitive relation in different strata. 1 For instance, in Joe gave Mary tea there are, at the clause level, four sister arcs (arcs with the same source node), as shown in Figure 1: one arc labeled [H] with target gave, indicating gave is the head of the clause; one with label [1] and target Joe, indicating Joe is both the predicateargument, and surface subject, of the clause; one with label [3,2] and target Mary, indicating that &apos;We use the following R-signs: 1 (subject), 2 (direct object), 3 (indirect object), 8 (chOmeur), Cat (Category), C (comp), F (flag), H (head), LOC (locative), M (marked), as well as the special Null R-signs 0 and/, explained below. 9 7 [Cat] S [1] Joe [H] gave [3,2] Mary [2,8] tea Figure 1: S-graph for Joe gave Mary tea. Mary is the predicate-argument indirect object, but the surface direct object, of the clause; and one with label [2,8] and target tea, indicating tea is the predicate-argument direct object, but surface chameur, of the clause. Such a structure</context>
<context position="5891" citStr="[3]" startWordPosition="949" endWordPosition="949">s of the respective formulas. We compile the various rules and their combinations into Rule Graphs and associate sets of these with appropriate lexical anchors, resulting in a lexicalized grammar. 3 S-graphs are formally feature structures: given a collection of sister arcs, the stratified labels are required to be functional. However, as shown in the example, the individual R-signs are not. Moreover, the lengths of the labels can vary, and this crucial property is how SFG avoids the &amp;quot;carry over&amp;quot; problem. S-graphs also include a strict partial order on arcs to represent linear precedence (cf. [3], [9]). The SFG description language includes a class of linear precedence statements, e.g., (1] -&lt; (H] means that in a constituent &amp;quot;the final subject precedes the head&amp;quot;. Given a set RS of R-signs, a (stratified) feature (or label) is a sequence of R-signs which may be closed on the left or right or both. Closed sides are indicated with square brackets and open sides with parentheses. For example, [2, 1) denotes a label that is closed on the left and open on the right, and [3, 2, 1, 0] denotes a label that is closed on both sides. Labels of the form [- • -I are called (totally) closed; of the </context>
<context position="10810" citStr="[3, 2, 1, 0]" startWordPosition="1805" endWordPosition="1808">and HPSG [7], except that in SFG, relational structure is transparently recorded in the stratified features. Moreover, SFG relies neither on LFGstyle annotated CFG rules and equation solving nor on HPSG-style SUBCAT lists. We illustrate below the process of constructing a lexical entry for given from rule graphs (ignoring morphology). The rule graphs used are for Ditransitive, Dative and (Agentless) Passive constructions. Combined, they yield a ditransitivedative-passive S-graph for the use of given occurring in Joe was given tea (cf. Figure 6). [Cat] S [0, 1] i Joe [H] was [Cat] VP [H] given [3, 2, 1, 0] [2,8] - [1, 8, 0] _ [C] N tea Figure 6: S-graph for Joe was given tea. (DI U DAT) UPAS: _ [H] given [3, 2, 1) [2,8) [1, 8, 0] The idea behind label unification is that two compatible labels combine to yield a label with maximal nonempty overlap. Left (right) closed labels unify with left (right) open labels to yield left (right) closed labels. There are ten types of label unification, determined by the four types of bracket pairs: totally closed (open), closed only on the left (right). However, in parsing (as opposed to building a lexicalized grammar), we stipulate that successful label unifi</context>
</contexts>
<marker>[3]</marker>
<rawString>David E. Johnson and Paul M. Postal. Arc Pair Grammar. Princeton University Press, 1980.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ronald Kaplan</author>
<author>Joan Bresnan</author>
</authors>
<title>Lexicalfunctional grammar, a formal system for grammatical representation.</title>
<date>1982</date>
<booktitle>The Mental Representation of Grammatical Relations.</booktitle>
<editor>In J. Bresnan, editor,</editor>
<publisher>MIT Press,</publisher>
<contexts>
<context position="10197" citStr="[4]" startWordPosition="1705" endWordPosition="1705">ncement and Raising are compiled into the lexical entries governing them. [Cat] VP - [0, 1] i John _ [H] seemed [Cat] AP [C] [2, 1, 0] i [H] _ ill Figure 3: Raising Rule Graph Figure 4: Surface Graph for John seemed ill [Cat] VP [H] seemed [Cat] AP a [C] [2) John [H] in - Figure 5: Predicate-Argument Graph for John seemed ill Figure 2: S-graph for John seemed ill [0,1) A I [C] A [Cat] VP - (1] i John ....._ [H] seemed [C] [[Cat] AP 1 [H] in - - - 99 Thus, given has four entries (Ditransitive, Ditransitive + Dative, Passive, Dative + Passive). This aspect of our framework is reminiscent of LFG [4] and HPSG [7], except that in SFG, relational structure is transparently recorded in the stratified features. Moreover, SFG relies neither on LFGstyle annotated CFG rules and equation solving nor on HPSG-style SUBCAT lists. We illustrate below the process of constructing a lexical entry for given from rule graphs (ignoring morphology). The rule graphs used are for Ditransitive, Dative and (Agentless) Passive constructions. Combined, they yield a ditransitivedative-passive S-graph for the use of given occurring in Joe was given tea (cf. Figure 6). [Cat] S [0, 1] i Joe [H] was [Cat] VP [H] given</context>
</contexts>
<marker>[4]</marker>
<rawString>Ronald Kaplan and Joan Bresnan. Lexicalfunctional grammar, a formal system for grammatical representation. In J. Bresnan, editor, The Mental Representation of Grammatical Relations. MIT Press, 1982.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert Kasper</author>
<author>William C Rounds</author>
</authors>
<title>The logic of unification in grammar. Linguistics and Philosophy,</title>
<date>1990</date>
<contexts>
<context position="1413" citStr="[5]" startWordPosition="198" endWordPosition="198">s essentially ordinary feature-structure unification augmented with an operation of label unification to build the stratified features characteristic of SFG. INTRODUCTION Although the impact of relational grammar (RG) on theoretical linguistics has been substantial, it has never previously been put in a form suitable for computational use. RG&apos;s multiple syntactic strata would seem to preclude its use in the kind of monotonic, unification-based parsing system many now consider standard ([1], [11]). However, recent work by Johnson and Moss [2] on a Kasper-Rounds (KR) style logic-based formalism [5] for RG, called Stratified Feature Grammar (SFG), has demonstrated that even RG&apos;s multiple strata are amenable to a feature-structure treatment. Based on this work, we have developed a unification-based, chart parser for a lexical version of SFG suitable for building computational relational grammars. A lexicalized SFG is simply a collection of stratified feature graphs (Sgraphs), each of which is anchored to a lexical item, analogous to lexicalized TAGs [10]. The basic parsing operation of the system is S-graph unification (S-unification): This is essentially ordinary feature-structure unific</context>
</contexts>
<marker>[5]</marker>
<rawString>Robert Kasper and William C. Rounds. The logic of unification in grammar. Linguistics and Philosophy, 13:35-58, 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alberto Lavelli</author>
<author>Giorgio Satta</author>
</authors>
<title>Bidirectional parsing of lexicalized tree adjoining grammars.</title>
<date>1991</date>
<booktitle>In Proceedings of the 5th Conference of the European Chapter of the Association of Computational Linguistics,</booktitle>
<contexts>
<context position="15762" citStr="[6]" startWordPosition="2674" endWordPosition="2674">rcs which must follow F are incomplete. b. A can precede F. c. All surface arcs which must both precede F and follow A are complete. B. Right-Precedence(A, ni) is true if: a. All surface arcs which must precede F are complete. b. A can follow F. c. All surface arcs which must both follow F and precede A are complete. 101 2. Complete : A node is complete if it is either a lexical anchor or else has (obligatory) outgoing SSR arcs, all of which are complete. An arc is complete if its target is complete. The algorithm is head-driven [8] and was inspired by parsing algorithms for lexicalized TAGs ([6], [101). Simplified Parsing Algorithm: Input: A string of words w1, . • • , wk. Output: A chart containing all possible parses. Method: A. Initialization: 1. Create a list of k state-sets , Sk, each empty. 2. For c = 1, . . . , k, for each Graph(ni) of wc, add [ni, c — 1, c] to Sc. B. Completions: For c = 1, k, do repeatedly until no more states can be added to Sc: 1. Leftward Completion: For all Q, = [rti, c] E Se, Qi = [nil L31 Li] E Sr„, such that Complete(nj) and A E SSR-Out-Arcs(ni), such that Left-Precedence(A,N) IF Unify-at-end- of-Path(n,, n3, A) n:, THEN Add [n&apos;.„ Li, c] to Sc 2. Righ</context>
</contexts>
<marker>[6]</marker>
<rawString>Alberto Lavelli and Giorgio Satta. Bidirectional parsing of lexicalized tree adjoining grammars. In Proceedings of the 5th Conference of the European Chapter of the Association of Computational Linguistics, 1991.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Carl Pollard</author>
<author>Ivan Sag</author>
</authors>
<title>Information-based Syntax and Semantics. CSLI Lecture Notes.</title>
<date>1987</date>
<publisher>University of Chicago Press,</publisher>
<location>Chicago,</location>
<contexts>
<context position="10210" citStr="[7]" startWordPosition="1708" endWordPosition="1708">aising are compiled into the lexical entries governing them. [Cat] VP - [0, 1] i John _ [H] seemed [Cat] AP [C] [2, 1, 0] i [H] _ ill Figure 3: Raising Rule Graph Figure 4: Surface Graph for John seemed ill [Cat] VP [H] seemed [Cat] AP a [C] [2) John [H] in - Figure 5: Predicate-Argument Graph for John seemed ill Figure 2: S-graph for John seemed ill [0,1) A I [C] A [Cat] VP - (1] i John ....._ [H] seemed [C] [[Cat] AP 1 [H] in - - - 99 Thus, given has four entries (Ditransitive, Ditransitive + Dative, Passive, Dative + Passive). This aspect of our framework is reminiscent of LFG [4] and HPSG [7], except that in SFG, relational structure is transparently recorded in the stratified features. Moreover, SFG relies neither on LFGstyle annotated CFG rules and equation solving nor on HPSG-style SUBCAT lists. We illustrate below the process of constructing a lexical entry for given from rule graphs (ignoring morphology). The rule graphs used are for Ditransitive, Dative and (Agentless) Passive constructions. Combined, they yield a ditransitivedative-passive S-graph for the use of given occurring in Joe was given tea (cf. Figure 6). [Cat] S [0, 1] i Joe [H] was [Cat] VP [H] given [3, 2, 1, 0]</context>
</contexts>
<marker>[7]</marker>
<rawString>Carl Pollard and Ivan Sag. Information-based Syntax and Semantics. CSLI Lecture Notes. University of Chicago Press, Chicago, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Derek Proudian</author>
<author>Carl Pollard</author>
</authors>
<title>Parsing head-driven phrase structure grammar.</title>
<date>1985</date>
<booktitle>In Proceedings of the 23rd Annual Meeting of the ACL,</booktitle>
<contexts>
<context position="3456" citStr="[2,8]" startWordPosition="531" endWordPosition="531">l, four sister arcs (arcs with the same source node), as shown in Figure 1: one arc labeled [H] with target gave, indicating gave is the head of the clause; one with label [1] and target Joe, indicating Joe is both the predicateargument, and surface subject, of the clause; one with label [3,2] and target Mary, indicating that &apos;We use the following R-signs: 1 (subject), 2 (direct object), 3 (indirect object), 8 (chOmeur), Cat (Category), C (comp), F (flag), H (head), LOC (locative), M (marked), as well as the special Null R-signs 0 and/, explained below. 9 7 [Cat] S [1] Joe [H] gave [3,2] Mary [2,8] tea Figure 1: S-graph for Joe gave Mary tea. Mary is the predicate-argument indirect object, but the surface direct object, of the clause; and one with label [2,8] and target tea, indicating tea is the predicate-argument direct object, but surface chameur, of the clause. Such a structure is called a stratified feature graph (S-graph). This situation could be described in SFG logic with the following formula (the significance of the different label delimiters (,), [, ] is explained below): R1 := [H] : gave A [1) : Joe A [3, 2) : Mary A [2, 8) : tea . In RG, the clause-level syntactic informati</context>
<context position="10816" citStr="[2,8]" startWordPosition="1809" endWordPosition="1809"> except that in SFG, relational structure is transparently recorded in the stratified features. Moreover, SFG relies neither on LFGstyle annotated CFG rules and equation solving nor on HPSG-style SUBCAT lists. We illustrate below the process of constructing a lexical entry for given from rule graphs (ignoring morphology). The rule graphs used are for Ditransitive, Dative and (Agentless) Passive constructions. Combined, they yield a ditransitivedative-passive S-graph for the use of given occurring in Joe was given tea (cf. Figure 6). [Cat] S [0, 1] i Joe [H] was [Cat] VP [H] given [3, 2, 1, 0] [2,8] - [1, 8, 0] _ [C] N tea Figure 6: S-graph for Joe was given tea. (DI U DAT) UPAS: _ [H] given [3, 2, 1) [2,8) [1, 8, 0] The idea behind label unification is that two compatible labels combine to yield a label with maximal nonempty overlap. Left (right) closed labels unify with left (right) open labels to yield left (right) closed labels. There are ten types of label unification, determined by the four types of bracket pairs: totally closed (open), closed only on the left (right). However, in parsing (as opposed to building a lexicalized grammar), we stipulate that successful label unification</context>
<context position="15697" citStr="[8]" startWordPosition="2663" endWordPosition="2663">rc. Then: A. Left-Precedence(A, ni) is true iff: a. All surface arcs which must follow F are incomplete. b. A can precede F. c. All surface arcs which must both precede F and follow A are complete. B. Right-Precedence(A, ni) is true if: a. All surface arcs which must precede F are complete. b. A can follow F. c. All surface arcs which must both follow F and precede A are complete. 101 2. Complete : A node is complete if it is either a lexical anchor or else has (obligatory) outgoing SSR arcs, all of which are complete. An arc is complete if its target is complete. The algorithm is head-driven [8] and was inspired by parsing algorithms for lexicalized TAGs ([6], [101). Simplified Parsing Algorithm: Input: A string of words w1, . • • , wk. Output: A chart containing all possible parses. Method: A. Initialization: 1. Create a list of k state-sets , Sk, each empty. 2. For c = 1, . . . , k, for each Graph(ni) of wc, add [ni, c — 1, c] to Sc. B. Completions: For c = 1, k, do repeatedly until no more states can be added to Sc: 1. Leftward Completion: For all Q, = [rti, c] E Se, Qi = [nil L31 Li] E Sr„, such that Complete(nj) and A E SSR-Out-Arcs(ni), such that Left-Precedence(A,N) IF Unify-a</context>
</contexts>
<marker>[8]</marker>
<rawString>Derek Proudian and Carl Pollard. Parsing head-driven phrase structure grammar. In Proceedings of the 23rd Annual Meeting of the ACL, 1985.</rawString>
</citation>
<citation valid="true">
<authors>
<author>William C Rounds</author>
<author>Alexis ManasterRamer</author>
</authors>
<title>A logical version of functional grammar.</title>
<date>1987</date>
<booktitle>In Proceedings of The 25th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<contexts>
<context position="2166" citStr="[9]" startWordPosition="310" endWordPosition="310"> on this work, we have developed a unification-based, chart parser for a lexical version of SFG suitable for building computational relational grammars. A lexicalized SFG is simply a collection of stratified feature graphs (Sgraphs), each of which is anchored to a lexical item, analogous to lexicalized TAGs [10]. The basic parsing operation of the system is S-graph unification (S-unification): This is essentially ordinary feature-structure unification augmented with an operation of label unification to build the stratified features characteristic of SFG. RELATED WORK Rounds and Manaster-Ramer [9] suggested encoding multiple strata in terms of a &amp;quot;level&amp;quot; attribute, using path equations to state correspondences across strata. Unfortunately, &amp;quot;unchanged&amp;quot; relations in a stratum must be explicitly &amp;quot;carried over&amp;quot; via path equations to the next stratum. Even worse, these &amp;quot;carry over&amp;quot; equations vary from case to case. SFG avoids this problem. STRATIFIED FEATURE GRAMMAR SFG&apos;s key innovation is the generalization of the concept feature to a sequence of so-called relational signs (R-signs). The interpretation of a stratified feature is that each R-sign in a sequence denotes a primitive relation in</context>
<context position="5896" citStr="[9]" startWordPosition="950" endWordPosition="950">the respective formulas. We compile the various rules and their combinations into Rule Graphs and associate sets of these with appropriate lexical anchors, resulting in a lexicalized grammar. 3 S-graphs are formally feature structures: given a collection of sister arcs, the stratified labels are required to be functional. However, as shown in the example, the individual R-signs are not. Moreover, the lengths of the labels can vary, and this crucial property is how SFG avoids the &amp;quot;carry over&amp;quot; problem. S-graphs also include a strict partial order on arcs to represent linear precedence (cf. [3], [9]). The SFG description language includes a class of linear precedence statements, e.g., (1] -&lt; (H] means that in a constituent &amp;quot;the final subject precedes the head&amp;quot;. Given a set RS of R-signs, a (stratified) feature (or label) is a sequence of R-signs which may be closed on the left or right or both. Closed sides are indicated with square brackets and open sides with parentheses. For example, [2, 1) denotes a label that is closed on the left and open on the right, and [3, 2, 1, 0] denotes a label that is closed on both sides. Labels of the form [- • -I are called (totally) closed; of the form </context>
</contexts>
<marker>[9]</marker>
<rawString>William C. Rounds and Alexis ManasterRamer. A logical version of functional grammar. In Proceedings of The 25th Annual Meeting of the Association for Computational Linguistics, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yves Schabes</author>
</authors>
<title>Mathematical and Computational Properties of Lexicalized Grammars.</title>
<date>1990</date>
<tech>PhD thesis,</tech>
<institution>University of Pennsylvania,</institution>
<contexts>
<context position="1876" citStr="[10]" startWordPosition="271" endWordPosition="271"> many now consider standard ([1], [11]). However, recent work by Johnson and Moss [2] on a Kasper-Rounds (KR) style logic-based formalism [5] for RG, called Stratified Feature Grammar (SFG), has demonstrated that even RG&apos;s multiple strata are amenable to a feature-structure treatment. Based on this work, we have developed a unification-based, chart parser for a lexical version of SFG suitable for building computational relational grammars. A lexicalized SFG is simply a collection of stratified feature graphs (Sgraphs), each of which is anchored to a lexical item, analogous to lexicalized TAGs [10]. The basic parsing operation of the system is S-graph unification (S-unification): This is essentially ordinary feature-structure unification augmented with an operation of label unification to build the stratified features characteristic of SFG. RELATED WORK Rounds and Manaster-Ramer [9] suggested encoding multiple strata in terms of a &amp;quot;level&amp;quot; attribute, using path equations to state correspondences across strata. Unfortunately, &amp;quot;unchanged&amp;quot; relations in a stratum must be explicitly &amp;quot;carried over&amp;quot; via path equations to the next stratum. Even worse, these &amp;quot;carry over&amp;quot; equations vary from case </context>
</contexts>
<marker>[10]</marker>
<rawString>Yves Schabes. Mathematical and Computational Properties of Lexicalized Grammars. PhD thesis, University of Pennsylvania, 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart Shieber</author>
</authors>
<title>Constraint-Based Grammar Formalisms.</title>
<date>1992</date>
<publisher>MIT Press,</publisher>
<contexts>
<context position="1310" citStr="[11]" startWordPosition="181" endWordPosition="181">grammars. We then describe a head-driven chart parser for lexicalized SFG. The basic parsing operation is essentially ordinary feature-structure unification augmented with an operation of label unification to build the stratified features characteristic of SFG. INTRODUCTION Although the impact of relational grammar (RG) on theoretical linguistics has been substantial, it has never previously been put in a form suitable for computational use. RG&apos;s multiple syntactic strata would seem to preclude its use in the kind of monotonic, unification-based parsing system many now consider standard ([1], [11]). However, recent work by Johnson and Moss [2] on a Kasper-Rounds (KR) style logic-based formalism [5] for RG, called Stratified Feature Grammar (SFG), has demonstrated that even RG&apos;s multiple strata are amenable to a feature-structure treatment. Based on this work, we have developed a unification-based, chart parser for a lexical version of SFG suitable for building computational relational grammars. A lexicalized SFG is simply a collection of stratified feature graphs (Sgraphs), each of which is anchored to a lexical item, analogous to lexicalized TAGs [10]. The basic parsing operation of t</context>
<context position="8979" citStr="[11]" startWordPosition="1494" endWordPosition="1494">arc labeled [0,1] is not a predicate-argument arc, indicating that John bears no predicate-argument relation to the top clause. And the arc labeled [2,1,0] is not a surface arc, indicating that John bears no surface relation to the embedded phrase headed by ill. The surface graph is shown in Figure 4 and the predicate-argument graph in Figure 5. Notice that the surface graph is a tree. The treehood of surface graphs is part of the definition of S-graph and provides the foundation for our parsing algorithm; it is the SFG analog to the &amp;quot;context-free backbone&amp;quot; typical of unificationbased systems [11]. LEXICALIZED SFG Given a finite collection of rule graphs, we could construct the finite set of S-graphs reflecting all consistent combinations of rule graphs and then associate each word with the collection of derived graphs it anchors. However, we actually only construct all the derived graphs not involving extractions. Since extractions can affect almost any arc, compiling them into lexicalized S-graphs would be impractical. Instead, extractions are handled by a novel mechanism involving multi-rooted graphs (cf. Concluding Remarks). We assume that all lexically governed rules such as Passi</context>
<context position="12794" citStr="[11]" startWordPosition="2164" endWordPosition="2164">are typically used in parsing bounded control constructions (e.g., &amp;quot;equi&amp;quot; and &amp;quot;raising&amp;quot;) and extractions by means of &amp;quot;splicing&amp;quot; Null R-signs onto the open ends of labels and closing off the labels in the process. We note in passing that cases involving totally open labels may not result in unique unifications, e.g., (1,2) U (2, 1) can be either (2,1,2) or (1,2,1). In practice, such aberrant cases seem not to arise. Label unification thus plays a central role in building a lexicalized grammar and in parsing. THE PARSING ALGORITHM S-unification is like normal feature structure unification ([1], [11]), except that in certain cases two arcs with distinct labels 1 and l&apos; are replaced by a single arc whose label is obtained by unifying 1 and 1&apos;. S-unification is implemented via the procedures Unify-Nodes, Unify-Arcs, and Unify-Sets-ofArcs: 1. Unify-Nodes(n,n1 consists of the steps: a. Unify label(n) and label(n&apos;), where node labels unify under identity b. Unify-Sets-of-Arcs(Out-Arcs(n), OutArcs(0) 2. Unify-Arcs(A,A1 consists of the steps: a. Unify label(A) and label(A&apos;) b. Unify-Nodes(target(A),target(A1) 3. Unify-Sets-of-Arcs(Seti, Set2), where Seti = , Ak} and Set2 {Am, , An}, returns a se</context>
</contexts>
<marker>[11]</marker>
<rawString>Stuart Shieber. Constraint-Based Grammar Formalisms. MIT Press, 1992.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>