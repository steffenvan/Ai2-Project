<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000020">
<title confidence="0.984189">
Control Strategies for Parsing with Freer Word-Order Languages
</title>
<author confidence="0.997275">
Gerald Penn
</author>
<affiliation confidence="0.92626">
Dept. of Computer Science
University of Toronto
Toronto M5S 3G4, Canada
</affiliation>
<author confidence="0.985476">
Stefan Banjevic
</author>
<affiliation confidence="0.926394">
Dept. of Mathematics
University of Toronto
Toronto M5S 2E4, Canada
</affiliation>
<author confidence="0.983807">
Michael Demko
</author>
<affiliation confidence="0.999161">
Dept. of Computer Science
University of Toronto
</affiliation>
<address confidence="0.600353">
Toronto M5S 3G4, Canada
</address>
<email confidence="0.999055">
{gpenn,banjevic,mpademko}@cs.toronto.edu
</email>
<sectionHeader confidence="0.997391" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.99987625">
We provide two different methods for
bounding search when parsing with freer
word-order languages. Both of these can
be thought of as exploiting alternative
sources of constraints not commonly used
in CFGs, in order to make up for the lack
of more rigid word-order and the standard
algorithms that use the assumption of rigid
word-order implicitly. This work is pre-
liminary in that it has not yet been evalu-
ated on a large-scale grammar/corpus for a
freer word-order language.
</bodyText>
<sectionHeader confidence="0.999517" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.9999917">
This paper describes two contributions to the
area of parsing over freer word-order (FWO) lan-
guages, i.e., languages that do not readily admit a
semantically transparent context-free analysis, be-
cause of a looser connection between grammati-
cal function assignment and linear constituent or-
der than one finds in English. This is a partic-
ularly ripe area for constraint-based methods be-
cause such a large number of linguistic partial
knowledge sources must be brought to bear on
FWO parsing in order to restrict its search space to
a size comparable to that of standard CFG-based
parsing.
The first addresses the indexation of tabled sub-
strings in generalized chart parsers for FWO lan-
guages. While chart parsing can famously be cast
as deduction (Pereira and Warren, 1983), what
chart parsing really is is an algebraic closure over
the rules of a phrase structure grammar, which is
most naturally expressed inside a constraint solver
such as CHR (Morawietz, 2000). Ideally, we
would like to use standard chart parsers for FWO
languages, but because of the constituent ordering
constraints that are implicit in the right-hand-sides
(RHSs) of CFG rules, this is not possible without
effectively converting a FWO grammar into a CFG
by expanding its rule system exponentially into all
possible RHS orders (Barton et al., 1987). FWO
grammar rules generally cannot be used as they
stand in a chart parser because tabled substrings
record a non-terminal category C derived over a
contiguous subspan of the input string from word
i to word j. FWO languages have many phrasal
categories that are not contiguous substrings.
Johnson (1985), Reape (1991) and others have
suggested using bit vectors to index chart edges
as an alternative to substring spans in the case of
parsing over FWO languages, but that is really
only half of the story. We still need a control strat-
egy to tell us where we should be searching for
some constituent at any point in a derivation. This
paper provides such a control strategy, using this
data structure, for doing search more effectively
with a FWO grammar.
The second contribution addresses another
source of constraints on the search space: the
length of the input. While this number is not a
constant across parses, it is constant within a sin-
gle parse, and there are functions that can be pre-
computed for a fixed grammar which relate tight
upper and lower bounds on the length of the in-
put to both the height of a parse tree and other
variables (defined below) whose values bound the
recursion of the fixed phrase structure rule sys-
tem. Iteratively computing and caching the val-
ues of these functions as needed allows us to in-
vert them efficiently, and bound the depth of the
search. This can be thought of as a partial substi-
tute for the resource-bounded control that bottom-
up parsing generally provides, Goal-directedness
</bodyText>
<page confidence="0.965984">
9
</page>
<note confidence="0.587961">
Proceedings of the 3rd Workshop on Constraints and Language Processing (CSLP-06), pages 9–16,
Sydney, July 2006. c�2006 Association for Computational Linguistics
</note>
<bodyText confidence="0.999788142857143">
is maintained, because — with the use of con-
straint programming – it can still be used inside
a top-down strategy. In principle, this could be
worthwhile to compute for some CFGs as well, al-
though the much larger search space covered by a
naive bottom-up parser in the case of FWO gram-
mars (all possible subsequences, rather than all
possible contiguous subsequences), makes it con-
siderably more valuable in the present setting.
In the worst case, a binary-branching immediate
dominance grammar (i.e., no linear precedence)
could specify that every word belongs to the same
category, W, and that phrases can be formed from
every pair of words or phrases. A complete pars-
ing chart in this case would have exponentially
many edges, so nothing in this paper (or in the
aforementioned work on bit vectors) actually im-
proves the asymptotic complexity of the recogni-
tion task. Natural languages do not behave like
this, however. In practice, one can expect more
polymorphy in the part-of-speech/category sys-
tem, more restrictions in the allowable combina-
tions of words and phrases (specified in the imme-
diate dominance components of a phrase structure
rule system), and more restrictions in the allow-
able orders and discontinuities with which those
argument categories can occur (specified in the
linear precedence components of a phrase struc-
ture rule system).
These restrictions engender a system of con-
straints that, when considered as a whole, admit
certain very useful, language-dependent strategies
for resolving the (respectively, don’t-care) nonde-
terministic choice points that a (resp., all-paths)
parser must face, specifically: (1) which lexical
categories to use (or, resp., in which order), given
the input words, (2) which phrase structure rules
to apply (resp., in which order), and (3) given a
particular choice of phrase structure rule, in which
order to search for the argument categories on its
right-hand side (this one is don’t-care nondeter-
ministic even if the parser is looking for only the
best/first parse). These heuristics are generally ob-
tained either through the use of a parameter esti-
mation method over a large amount of annotated
data, or, in the case of a manually constructed
grammar, simply through some implicit conven-
tion, such as the textual order in which the lexicon,
rule system, or RHS categories are stated.1
</bodyText>
<footnote confidence="0.9358925">
1In the case of the lexicon and rule system, there is a very
long-standing tradition in logic programming of using this
</footnote>
<bodyText confidence="0.999975">
This paper does not address how to find these
heuristics. We assume that they exist, and instead
address the problem of adapting a chart parser
to their efficient use. To ignore this would in-
volve conducting an enormous number of deriva-
tions, only to look in the chart at the end and
discover that we have already derived the current
bit-vector/category pair. In the case of standard
CFG-based parsing, one generally avoids this by
tabling so-called active edges, which record the
subspaces on which a search has already been ini-
tiated. This works well because the only existen-
tially quantified variables in the tabled entry are
the interior nodes in the span which demarcate
where one right-hand-side category ends and an-
other adjacent one begins. To indicate that one is
attempting to complete the rule, S –� NP V P,
for example, one must only table the search from
i to j for some k, such that NP is derivable from
i to k and V P is derivable from k to j. Our first
contribution can be thought of as a generalization
of these active edges to the case of bit vectors.
</bodyText>
<sectionHeader confidence="0.90919" genericHeader="method">
2 FWO Parsing as Search within a
</sectionHeader>
<subsectionHeader confidence="0.773119">
Powerset Lattice
</subsectionHeader>
<bodyText confidence="0.999968333333334">
A standard chart-parser views constituents as ex-
tending over spans, contiguous intervals of a lin-
ear string. In FWO parsing, constituents partition
the input into not necessarily contiguous subse-
quences, which can be thought of as bit vectors
whose AND is 0 and whose OR is 2&apos; – 1, given an
initial n-length input string. For readability, and
to avoid making an arbitrary choice as to whether
the leftmost word should correspond to the most
significant or least significant bit, we will refer
to these constituents as subsets of f ... n} rather
than as n-length bit vectors. For simplicity and
because of our heightened awareness of the im-
portance of goal-directedness to FWO parsing (see
the discussion in the previous section), we will
only outline the strictly top-down variant of our
strategy, although natural analogues do exist for
the other orientations.
</bodyText>
<subsectionHeader confidence="0.978403">
2.1 State
</subsectionHeader>
<bodyText confidence="0.995922833333333">
State is: (N, CanBV, ReqBV).
The returned result is: UsedBV or failure.
convention. To our knowledge, the first to apply it to the order
of RHS categories, which only makes sense once one drops
the implicit linear ordering implied by the RHSs of context-
free grammar rules, was Daniels and Meurers (2002).
</bodyText>
<page confidence="0.992666">
10
</page>
<bodyText confidence="0.999910764705882">
Following Penn and Haji-Abdolhosseini
(2003), we can characterize a search state under
these assumptions using one non-terminal, N, and
two subsets/bit vectors, the CanBV and ReqBV.2
CanBV is the set of all words that can be used
to build an N, and ReqBV is the set of all words
that must be used while building the N. CanBV
always contains ReqBV, and what it additionally
contains are optional words that may or may not
be used. If search from this state is successful,
i.e., N is found using ReqBV and nothing that
is not in CanBV, then it returns a UsedBV, the
subset of words that were actually used. We will
assume here that our FWO grammars are not so
free that one word can be used in the derivation of
two or more sibling constituents, although there is
clearly a generalization to this case.
</bodyText>
<subsectionHeader confidence="0.991817">
2.2 Process
</subsectionHeader>
<bodyText confidence="0.993662">
Search(hN, C, Ri) can then be defined in the
constraint solver as follows:
</bodyText>
<subsectionHeader confidence="0.645581">
2.2.1 Initialization
</subsectionHeader>
<bodyText confidence="0.985799666666667">
A top-down parse of an n-length string be-
gins with the state consisting of the distinguished
category, S, of the grammar, and CanBV =
</bodyText>
<equation confidence="0.761612">
ReqBV = f1 ... ng.
</equation>
<subsectionHeader confidence="0.855393">
2.2.2 Active Edge Subsumption
</subsectionHeader>
<bodyText confidence="0.999967666666667">
The first step is to check the current state against
states that have already been considered. For ex-
pository reasons, this will be presented below. Let
us assume for now that this step always fails to
produce a matching edge. We must then predict
using the rules of the FWO grammar.
</bodyText>
<subsubsectionHeader confidence="0.864689">
2.2.3 Initial Prediction
</subsubsectionHeader>
<listItem confidence="0.944852">
hN, C, Ri =) hN1, C, Oi, where:
1. N0 ! N1 ... Nk,
2. k &gt; 1, and
3. N t N0#.
</listItem>
<bodyText confidence="0.953374230769231">
As outlined in Penn and Haji-Abdolhosseini
(2003), the predictive step from a state consisting
of hN, C, Ri using an immediate dominance rule,
N0 ! N1 ... Nk, with k &gt; 1 and no linear prece-
dence constraints transits to a state hN1, C, Oi pro-
vided that N is compatible with N0. In the case
of a classical set of atomic non-terminals, com-
patibility should be interpreted as equality. In the
2Actually, Penn and Haji-Abdolhosseini (2003) use
CanBV and OptBV, which can be defined as CanBV n
ReqBV.
case of Prolog terms, as in definite clause gram-
mars, or typed feature structures, as in head-driven
phrase structure grammar, compatibility can be in-
terpreted as either unifiability or the asymmetric
subsumption of N by N0. Without loss of gener-
ality, we will assume unifiability here.
This initial predictive step says that there are,
in general, no restrictions on which word must be
consumed (ReqBV = O). Depending on the lan-
guage chosen for expressing linear precedence re-
strictions, this set may be non-empty, and in fact,
the definition of state used here may need to be
generalized to something more complicated than
a single set to express the required consumption
constraints.
</bodyText>
<subsubsectionHeader confidence="0.665816">
2.2.4 Subsequent Prediction
</subsubsectionHeader>
<listItem confidence="0.9507575">
hN, C, Ri =) hNj+1, Cj, Oi, where:
1. N0 ! N1 ... Nk,
2. N t N0#,
3. hN1, C, Oi succeeded with U1,
...
hNj, Cj_1, Oi succeeded with Uj,
4. k &gt; 1 and 1 &lt; j &lt;k-1, and
5. Cj = C \ U1 \ ... \ Uj.
</listItem>
<bodyText confidence="0.94256875">
Regardless of these generalizations, however,
each subsequent predictive step, having recog-
nized N1 ... Nj, for 1 &lt; j &lt; k — 1, computes the
next CanBV Cj by removing the consumed words
Uj from the previous CanBV Cj_1, and then tran-
sits to state hNj+1, Cj, Oi. Removing the Used-
BVs is the result of our assumption that no word
can be used by two or more sibling constituents.
</bodyText>
<listItem confidence="0.884292">
2.2.5 Completion
hN, C, Ri =) hNk, Ck_1, Rk_1i, where:
1. N0 ! N1 ... Nk,
2. N t N0#,
3. hN1, C, Oi succeeded with U1,
...
hNk_1, Ck_2, Oi succeeded with Uk-1,
4. Ck_1 = C \ U1 \ ... \ Uk_1, and
5. Rk_1 = R \ U1 \ ... \ Uk_1.
</listItem>
<bodyText confidence="0.947380111111111">
The completion step then involves recognizing
the last RHS category (although this is no longer
rightmost in terms of linear precedence). Here,
the major difference from subsequent prediction is
that there is now a potentially non-empty ReqBV.
Only with the last RHS category are we actually
in a position to enforce R from the source state.
If hNk, Ck_1, Rk_1i succeeds with Uk, then
hN, C, Ri succeeds with U1 [ ... [ Uk.
</bodyText>
<page confidence="0.995261">
11
</page>
<subsectionHeader confidence="0.989999">
2.3 Active Edge Subsumption Revisited
</subsectionHeader>
<bodyText confidence="0.99954822">
So far, this is very similar to the strategy out-
lined in Penn and Haji-Abdolhosseini (2003). If
we were to add active edges in a manner simi-
lar to standard chart parsing, we would tabulate
states like (Na, Ca, Ra) and then compare them
in step 2.2.2 to current states (N, C, R) by deter-
mining whether (classically) N = Na, C = Ca,
and R = Ra. This might catch some redundant
search, but just as we can do better in the case of
non-atomic categories by checking for subsump-
tion (Na C N) or unifiability (N u Na, ), we can
do better on C and R as well because these are sets
that come with a natural notion of containment.
Figure 1 shows an example of how this contain-
ment can be used. Rather than comparing edges
annotated with linear subspans, as in the case of
CFG chart parsing, here we are comparing edges
annotated with sublattices of the powerset lattice
on n elements, each of which has a top element (its
CanBV) and a bottom element (its ReqBV). Ev-
erything in between this top and bottom is a sub-
set of words that has been (or will be) tried if that
combination has been tabled as an active edge.
Figure 1 assumes that n = 6, and that we have
tabled an active edge (dashed lines) with Ca =
{1, 2, 4, 5, 6}, and Ra = {1, 2}. Now suppose
later that we decide to search for the same cate-
gory in C = {1, 2, 3, 4, 5, 6}, R = {1, 2} (dotted
lines). Here, C =� Ca, so an equality-based com-
parison would fail, but a better strategy would be
to reallocate the one extra bit in C (3) to R, and
then search C&apos; = {1, 2, 3, 4, 5, 6}, R&apos; = {1, 2, 3}
(solid lines). As shown in Figure 1, this solid re-
gion fills in all and only the region left unsearched
by the active edge.
This is actually just one of five possible cases
that can arise during the comparison. The com-
plete algorithm is given in Figure 2. This algo-
rithm works as a filter, which either blocks the
current state from further exploration, allows it to
be further explored, or breaks it into several other
states that can be concurrently explored. Step 1(a)
deals with category unifiability. If the current cat-
egory, N, is unifiable with the tabled active cat-
egory, Na, then 1(a) breaks N into more specific
pieces that are either incompatible with Na or sub-
sumed by Na. By the time we get to 1(b), we know
we are dealing with a piece that is subsumed by
Na. O stands for “optional,” CanBV bits that are
not required.
</bodyText>
<listItem confidence="0.978740857142858">
Check((N, C, R)):
• For each active edge, a, with (Na, Ca, Ra),
1. If N u Na, , then:
(a) For each minimal category N&apos; such
that N C N&apos; and N&apos; u Nat, concur-
rently:
– Let N := N&apos;, and continue [to
next active edge].
(b) Let N := N u Na, O := C n R and
Oa:=CanRa.
(c) If Ca n Oa n C =� 0, then continue
[to next active edge].
(d) If C nO nCa =� 0, then continue [to
next active edge].
(e) If (Z :=)O n Ca =� 0, then:
i. Let O := O n Z,
ii. Concurrently:
A. continue [to next active
edge], and
B. (1) Let C := C n Z,
(2) goto (1) [to reconsider
this active edge].
(f) If (Z :=)Ca n Oa n O =� 0, then:
i. Let O := O n Z, C := C n Z,
ii. continue [to next active edge].
(g) Fail — this state is subsumed by an
active edge.
2. else continue [to next active edge].
</listItem>
<figureCaption confidence="0.993457">
Figure 2: Active edge checking algorithm.
</figureCaption>
<bodyText confidence="0.999752928571429">
Only one of 1(g) or the bodies of 1(c), 1(d), 1(e)
or 1(f) is ever executed in a single pass through the
loop. These are the five cases that can arise dur-
ing subset/bit vector comparison, and they must
be tried in the order given. Viewing the current
state’s CanBV and ReqBV as a modification of the
active edge’s, the first four cases correspond to:
the removal of required words (1(c)), the addition
of required words (1(d)), the addition of optional
(non-required) words (1(e)), and the reallocation
of required words to optional words (1(f)). Unless
one of these four cases has happened, the current
sublattice has already been searched in its entirety
(1(g)).
</bodyText>
<subsectionHeader confidence="0.978148">
2.4 Linear Precedence Constraints
</subsectionHeader>
<bodyText confidence="0.9999605">
The elaboration above has assumed the absence
of any linear precedence constraints. This is the
</bodyText>
<page confidence="0.980215">
12
</page>
<figure confidence="0.8875768">
f1,2,3,4,5,6g
f1,2,3,4,5g f1,2,3,5,6g f1,2,3,4,6g f1,2,4,5,6g
f1,2,3,4g f1,2,3,5g f1,2,3,6g f1,2,4,5g f1,2,4,6g f1,2,5,6g
f1,2,3g f1,2,4g f1,2,5g f1,2,6g
f1,2g
</figure>
<figureCaption confidence="0.999947">
Figure 1: A powerset lattice representation of active edge checking with CanBV and ReqBV.
</figureCaption>
<bodyText confidence="0.9998625">
worst case, from a complexity perspective. The
propagation rules of section 2.2 can remain un-
changed in a concurrent constraint-based frame-
work in which other linear precedence constraints
observe the resulting algebraic closure and fail
when violated, but it is possible to integrate these
into the propagators for efficiency. In either case,
the active edge subsumption procedure remains
unchanged.
For lack of space, we do not consider the char-
acterization of linear precedence constraints in
terms of CanBV and ReqBV further here.
</bodyText>
<sectionHeader confidence="0.900038" genericHeader="method">
3 Category Graphs and Iteratively
Computed Yields
</sectionHeader>
<bodyText confidence="0.996464285714286">
Whereas in the last section we trivialized linear
precedence, the constraints of this section sim-
ply do not use them. Given a FWO grammar, G,
with immediate dominance rules, R, over a set of
non-terminals, N, we define the category graph
of G to be the smallest directed bipartite graph,
C(G) = (V, E), such that:
</bodyText>
<listItem confidence="0.994909333333333">
• V = N U R U {Lex, Empty},
• (X, r) E E if non-terminal X appears on the
RHS of rule r,
• (r, X) E E if the LHS non-terminal of r is
X,
• (Lex, r) E E if there is a terminal on the
RHS of rule r, and
• (Empty, r) E E if r is an empty production
rule.
</listItem>
<bodyText confidence="0.99962025">
We will call the vertices of C(G) either category
nodes or rule nodes. Lex and Empty are consid-
ered category nodes. The category graph of the
grammar in Figure 3, for example, is shown in
</bodyText>
<figure confidence="0.7579406">
S VP NP VP1 V NP
NP1 N’ S VP2 V
NP2 N’ N {boy, girl}
N’1 N Det Det {a, the, this}
N’2 N V {sees, calls}
</figure>
<figureCaption confidence="0.999786">
Figure 3: A sample CFG-like grammar.
</figureCaption>
<bodyText confidence="0.973094823529412">
Figure 4. By convention, we draw category nodes
with circles, and rule nodes with boxes, and we la-
bel rule nodes by the LHS categories of the rules
they correspond to plus an index. For brevity, we
will assume a normal form for our grammars here,
in which the RHS of every rule is either a string of
non-terminals or a single terminal.
Category graphs are a minor variation of the
“grammar graphs” of Moencke and Wilhelm
(1982), but we will use them for a very differ-
ent purpose. For brevity, we will consider only
atomic non-terminals in the remainder of this sec-
tion. Category graphs can be constructed for par-
tially ordered sets of non-terminals, but in this
case, they can only be used to approximate the val-
ues of the functions that they exactly compute in
the atomic case.
</bodyText>
<page confidence="0.995345">
13
</page>
<figure confidence="0.994555533333333">
N
Lex Empty
Det
V
NP1
N’2
N Det V
NP VP
N’
NP2
N’1
S
S
VP1
VP2
</figure>
<bodyText confidence="0.995068333333333">
the fixed grammar G. Likewise, let Xmin(h) be
the minimum yield that such an instance must pro-
duce. Also, as an abuse of functional notation, let:
</bodyText>
<equation confidence="0.933888666666667">
Xmax(&lt; h) = max0&lt;j&lt;h Xmax(�)
Xmin(&lt; h) = min0&lt;j&lt;h Xmin(�)
Now, using these, we can come back and define
Xmax(h) and Xmin(h):
Lexmax(h) =
h = 0
Lexmin(h) =� 1
undefined otherwise
Emptymax(h) =
0 h = 0
Empty min (h) = undefined otherwise
and for all other category nodes, X:
Xmax(1) =
{ 0 X EER
1 X t E R
undefined otherwise
and for h &gt; 1:
Xmin(1) =
max i( max Xmax (h — 1)
X-+X1 ::: XkER 1&lt;i&lt;k
Xmax j(&lt; h — 1))
</equation>
<figureCaption confidence="0.9999975">
Figure 4: The category graph for the grammar in
Figure 3.
</figureCaption>
<equation confidence="0.996980333333333">
Xmax(h) =
k
+ =� �4i
</equation>
<bodyText confidence="0.9997315">
Restricting search to unexplored sublattices
helps us with recursion in a grammar in that it
stops redundant search, but in some cases, recur-
sion can be additionally bounded (above and be-
low) not because it is redundant but because it can-
not possibly yield a string as short or long as the
current input string. Inputs are unbounded in size
across parses, but within a single parse, the input
is fixed to a constant size. Category graphs can be
used to calculate bounds as a function of this size.
We will refer below to the length of an input string
below a particular non-terminal in a parse tree as
the yield of that non-terminal instance. The height
of a non-terminal instance in a parse tree is 1 if it
is pre-terminal, and 1 plus the maximum height of
any of its daughter non-terminals otherwise. Non-
terminal categories can have a range of possible
yields and heights.
</bodyText>
<subsectionHeader confidence="0.999683">
3.1 Parse Tree Height
</subsectionHeader>
<bodyText confidence="0.999771333333333">
Given a non-terminal, X, let Xmax(h) be the
maximum yield that a non-terminal instance of X
at height h in any parse tree can produce, given
</bodyText>
<equation confidence="0.9706017">
i min (min Xmin (h — 1)
X-+X1:::XkER 1&lt;i&lt;k
Xmin
j (&lt; h — 1)).
For example, in Figure 3, there is only one rule
with S as a LHS category, so:
Smax(h) = max NPmax(h — 1) + VPmax(� h � 1)
NPmax(� h � 1) + VPmax(h � 1)
Smin(h) = min NPmin(h —1) + VPmin(&lt; h —1)
NPmin(&lt; h — 1) + VPmin(h — 1).
</equation>
<bodyText confidence="0.9988235">
These functions compute yields as a function
of height. We know the yield, however, and
want bounds on height. Given a grammar in
which the non-pre-terminal rules have a constant
branching factor, we also know that Xmax(h) and
Xmin(h), are monotonically non-decreasing in h,
where they are defined. This means that we can it-
eratively compute Xmax(h), for all non-terminals
X, and all values h out to the first h&apos; that pro-
duces a value strictly greater than the current yield
(the length of the given input). Similarly, we can
compute Xmin(h), for all non-terminals X, and
</bodyText>
<equation confidence="0.989974333333333">
Xmin (h) =
k
+ =� �4i
</equation>
<page confidence="0.988276">
14
</page>
<bodyText confidence="0.999975236842105">
all values h out to the first h&amp;quot; that is equal to or
greater than the current yield. The height of the
resulting parse tree, h, can then be bounded as
h&apos; — 1 &lt; h &lt; h&amp;quot;. These iterative computations
can be cached and reused across different inputs.
In general, in the absence of a constant branching
factor, we still have a finite maximum branching
factor, from which an upper bound on any poten-
tial decrease in Xmax(h) and Xmzn(h) can be de-
termined.
This provides an interval constraint. Because
there may be heights for which Xmax(h) and
Xmzn(h) is not defined, one could, with small
enough intervals, additionally define a finite do-
main constraint that excludes these.
These recursive definitions are well-founded
when there is at least one finite string derivable
by every non-terminal in the grammar. The Xmzn
functions converge in the presence of unit produc-
tion cycles in C(G); the Xmax functions can also
converge in this case. Convergence restricts our
ability to constrain search with yields.
A proper empirical test of the efficacy of these
constraints requires large-scale phrase structure
grammars with weakened word-order constraints,
which are very difficult to come by. On the other
hand, our preliminary experiments with simple
top-down parsing on the Penn Treebank II sug-
gest that even in the case of classical context-free
grammars, yield constraints can improve the effi-
ciency of parsing. The latency of constraint en-
forcement has proven to be a real issue in this
case (weaker bounds that are faster to enforce
can produce better results), but the fact that yield
constraints produce any benefit whatsoever with
CFGs is very promising, since the search space is
so much smaller than in the FWO case, and edge
indexing is so much easier.
</bodyText>
<subsectionHeader confidence="0.998602">
3.2 Cycle Variables
</subsectionHeader>
<bodyText confidence="0.999552735849057">
The heights of non-terminals from whose category
nodes the cycles of C(G) are not path-accessible
can easily be bounded. Using the above height-
dependent yield equations, the heights of the other
non-terminals can also be bounded, because any
input string fixes the yield to a finite value, and
thus the height to a finite range (in the absence
of converging Xmzn sequences). But we can do
better. We can condition these bounds not only
upon height but upon the individual rules used. We
could even make them depend upon sequences of
rules, or on vertical chains of non-terminals within
trees. If C(G) contains cycles, however, there
are infinitely many such chains (although finitely
many of any given length), but trips around cycles
themselves can also be counted.
Let us formally specify that a cycle refers to
a unique path from some category node to itself,
such that every node along the path except the last
is unique. Note that because C(G) is bipartite,
paths alternate between category nodes and rule
nodes.
Now we can enumerate the distinct cycles of
any category graph. In Figure 4, there are two,
both passing through NP and S, with one pass-
ing through VP in addition. Note that cycles,
even though they are unique, may share nodes as
these two do. For each cycle, we will arbitrarily
choose an index node for it, and call the unique
edge along the cycle leading into that node its in-
dex link. It will be convenient to choose the distin-
guished non-terminal, S, as the index node when
it appears in a cycle, and in other cases, to choose
a node with a minimal path-distance to S in the
category graph.
For each cycle, we will also assign it a unique
cycle variable (written n, m etc.). The domain of
this variable is the natural numbers and it counts
the number of times in a parse that we traverse
this cycle as we search top-down for a tree. When
an index link is traversed, the corresponding cycle
variable must be incremented.
For each category node X in C(G), we can de-
fine the maximum and minimum yield as before,
but now instead of height being the only indepen-
dent parameter, we also make these functions de-
pend on the cycle variables of all of the cycles
that pass through X. If X has no cycles passing
through it, then its only parameter is still h. We
can also easily extend the definition of these func-
tions to rule nodes.
Rather than provide the general definitions here,
we simply give some of the equations for Figure 4,
</bodyText>
<page confidence="0.992416">
15
</page>
<bodyText confidence="0.932835">
for shortage of space:
</bodyText>
<equation confidence="0.999221866666667">
Smax(h; n; m) = Smax(h; n; m)
Smax(h; n; m) = Smax(h; n; m)
Smax(h; n; m) =
{ NPmax(h — 1; i; k)
+VPmax(&lt; h — 1; j; �l)
NPmax(&lt; h — 1;�i; k)
+VPmax(h — 1; j; �l)
NPmax (h; n m)
NPmax (h; n; m) = max1NPmax
2 (h; n; m)
NPmax 1(h; n; 1i2) =
{ N’max(h — 1)
+Smax(&lt; h — 1; n — 1; m — 1)
N’max(&lt; h — 1)
NPmax 1(h; n; 1i2) =
</equation>
<bodyText confidence="0.999934235294118">
straints or finite domain constraints.
In the case of grammars over atomic categories,
using a single cycle variable for every distinct cy-
cle is generally not an option. The grammar in-
duced from the local trees of the 35-sentence sec-
tion wsj 0105 of the Penn Treebank II, for ex-
ample, has 49 non-terminals and 258 rules, with
153,026 cycles. Grouping together cycles that dif-
fer only in their rule nodes, we are left with 204
groupings, and in fact, they pass through only
12 category nodes. Yet the category node with
the largest number of incident cycles (NP) would
still require 163 cycle (grouping) variables — too
many to iteratively compute these functions effi-
ciently. Naturally, it would be possible to con-
flate more cycles to obtain cruder but more effi-
cient bounds.
</bodyText>
<equation confidence="0.995016909090909">
max
i + j = n,
k + l = m
max
+Smax(h — 1; n — 1; m — 1)
max
+Smax (h — 1; n — 1; m)
N ax (h n, m) _ N,max (h — 1) n = m = 0
Pz
undefined o:w:
VPmax 1(h; n; m) =
</equation>
<bodyText confidence="0.999993055555556">
We think of functions in which overscores are
written over some parameters as entirely differ-
ent functions that have witnessed partial traver-
sals through the cycles corresponding to the over-
scored parameters, beginning at the respective in-
dex nodes of those cycles.
Cycle variables are a local measure of non-
terminal instances in that they do not depend on
the absolute height of the tree — only on a fixed
range of nodes above and below them in the tree.
These makes them more suitable for the itera-
tive computation of yields that we are interested
in. Because Xmax and Xmin are now multi-
variate functions in general, we must tabulate an
entire table out to some bound in each dimension,
from which we obtain an entire frontier of accept-
able values for the height and each cycle variable.
Again, these can be posed either as interval con-
</bodyText>
<sectionHeader confidence="0.999679" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.996433705882353">
G. E. Barton, R. C. Berwick, and E. S. Ristad. 1987.
Computational Complexity and Natural Language.
MIT Press.
M. Daniels and W. D. Meurers. 2002. Improving
the efficiency of parsing with discontinuous con-
stituents. In 7th International Workshop on Natural
Language Understanding and Logic Programming
(NLULP).
M. Johnson. 1985. Parsing with discontinuous con-
stituents. In Proceedings of the 23rd Annual Meet-
ing of the Association for Computational Linguis-
tics, pages 127–132.
U. Moencke and R. Wilhelm. 1982. Iterative algo-
rithms on grammar graphs. In H. J. Schneider and
H. Goettler, editors, Proceedings of the 8th Confer-
ence on Graphtheoretic Concepts in Computer Sci-
ence (WG 82), pages 177–194. Carl Hanser Verlag.
F. Morawietz. 2000. Chart parsing and constraint
programming. In Proceedings of the 18th Inter-
national Conference on Computational Linguistics
(COLING-00), volume 1, pages 551–557.
G. Penn and M. Haji-Abdolhosseini. 2003. Topologi-
cal parsing. In Proceedings of the 10th Conference
ofthe European Chapter of the Associationfor Com-
putational Linguistics (EACL-03), pages 283–290.
F. C. N. Pereira and D. H. D. Warren. 1983. Parsing
as deduction. In Proceedings of 21st Annual Meet-
ing of the Association for Computational Linguistics
(ACL), pages 137–144.
M. Reape. 1991. Parsing bounded discontinuous con-
stituents: Generalisations of some common algo-
rithms. In M. Reape, editor, Word Order in Ger-
manic and Parsing, pages 41–70. Centre for Cogni-
tive Science, University of Edinburgh.
</reference>
<equation confidence="0.990817071428571">
{ Vmax(h — 1)
+NPmax(&lt; h — 1; n; m — 1)
Vmax(&lt; h — 1)
max
+NPmax(h — 1; n; m — 1)
{ N’max(h — 1)
+Smax(&lt; h — 1; n — 1; m)
N’max(&lt; h — 1)
{ N’max(h — 1)
+Smax(&lt; h — 1;n; m — 1)
N’max(&lt; h — 1)
NPmax 1(h; n; m) =
max
+Smax(h — 1; n; m — 1)
</equation>
<page confidence="0.991751">
16
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.626191">
<title confidence="0.999835">Control Strategies for Parsing with Freer Word-Order Languages</title>
<author confidence="0.996102">Gerald</author>
<affiliation confidence="0.999912">Dept. of Computer University of</affiliation>
<address confidence="0.986808">Toronto M5S 3G4, Canada</address>
<author confidence="0.939253">Stefan</author>
<affiliation confidence="0.9994045">Dept. of University of</affiliation>
<address confidence="0.95837">Toronto M5S 2E4, Canada</address>
<author confidence="0.717437">Michael</author>
<affiliation confidence="0.9998415">Dept. of Computer University of</affiliation>
<address confidence="0.979912">Toronto M5S 3G4, Canada</address>
<abstract confidence="0.999144461538462">We provide two different methods for bounding search when parsing with freer word-order languages. Both of these can be thought of as exploiting alternative sources of constraints not commonly used in CFGs, in order to make up for the lack of more rigid word-order and the standard algorithms that use the assumption of rigid word-order implicitly. This work is preliminary in that it has not yet been evaluated on a large-scale grammar/corpus for a freer word-order language.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>G E Barton</author>
<author>R C Berwick</author>
<author>E S Ristad</author>
</authors>
<date>1987</date>
<booktitle>Computational Complexity and Natural Language.</booktitle>
<publisher>MIT Press.</publisher>
<contexts>
<context position="2179" citStr="Barton et al., 1987" startWordPosition="338" endWordPosition="341">t parsing can famously be cast as deduction (Pereira and Warren, 1983), what chart parsing really is is an algebraic closure over the rules of a phrase structure grammar, which is most naturally expressed inside a constraint solver such as CHR (Morawietz, 2000). Ideally, we would like to use standard chart parsers for FWO languages, but because of the constituent ordering constraints that are implicit in the right-hand-sides (RHSs) of CFG rules, this is not possible without effectively converting a FWO grammar into a CFG by expanding its rule system exponentially into all possible RHS orders (Barton et al., 1987). FWO grammar rules generally cannot be used as they stand in a chart parser because tabled substrings record a non-terminal category C derived over a contiguous subspan of the input string from word i to word j. FWO languages have many phrasal categories that are not contiguous substrings. Johnson (1985), Reape (1991) and others have suggested using bit vectors to index chart edges as an alternative to substring spans in the case of parsing over FWO languages, but that is really only half of the story. We still need a control strategy to tell us where we should be searching for some constitue</context>
</contexts>
<marker>Barton, Berwick, Ristad, 1987</marker>
<rawString>G. E. Barton, R. C. Berwick, and E. S. Ristad. 1987. Computational Complexity and Natural Language. MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Daniels</author>
<author>W D Meurers</author>
</authors>
<title>Improving the efficiency of parsing with discontinuous constituents.</title>
<date>2002</date>
<booktitle>In 7th International Workshop on Natural Language Understanding and Logic Programming (NLULP).</booktitle>
<contexts>
<context position="8633" citStr="Daniels and Meurers (2002)" startWordPosition="1421" endWordPosition="1424"> as n-length bit vectors. For simplicity and because of our heightened awareness of the importance of goal-directedness to FWO parsing (see the discussion in the previous section), we will only outline the strictly top-down variant of our strategy, although natural analogues do exist for the other orientations. 2.1 State State is: (N, CanBV, ReqBV). The returned result is: UsedBV or failure. convention. To our knowledge, the first to apply it to the order of RHS categories, which only makes sense once one drops the implicit linear ordering implied by the RHSs of contextfree grammar rules, was Daniels and Meurers (2002). 10 Following Penn and Haji-Abdolhosseini (2003), we can characterize a search state under these assumptions using one non-terminal, N, and two subsets/bit vectors, the CanBV and ReqBV.2 CanBV is the set of all words that can be used to build an N, and ReqBV is the set of all words that must be used while building the N. CanBV always contains ReqBV, and what it additionally contains are optional words that may or may not be used. If search from this state is successful, i.e., N is found using ReqBV and nothing that is not in CanBV, then it returns a UsedBV, the subset of words that were actua</context>
</contexts>
<marker>Daniels, Meurers, 2002</marker>
<rawString>M. Daniels and W. D. Meurers. 2002. Improving the efficiency of parsing with discontinuous constituents. In 7th International Workshop on Natural Language Understanding and Logic Programming (NLULP).</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Johnson</author>
</authors>
<title>Parsing with discontinuous constituents.</title>
<date>1985</date>
<booktitle>In Proceedings of the 23rd Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>127--132</pages>
<contexts>
<context position="2485" citStr="Johnson (1985)" startWordPosition="390" endWordPosition="391">ers for FWO languages, but because of the constituent ordering constraints that are implicit in the right-hand-sides (RHSs) of CFG rules, this is not possible without effectively converting a FWO grammar into a CFG by expanding its rule system exponentially into all possible RHS orders (Barton et al., 1987). FWO grammar rules generally cannot be used as they stand in a chart parser because tabled substrings record a non-terminal category C derived over a contiguous subspan of the input string from word i to word j. FWO languages have many phrasal categories that are not contiguous substrings. Johnson (1985), Reape (1991) and others have suggested using bit vectors to index chart edges as an alternative to substring spans in the case of parsing over FWO languages, but that is really only half of the story. We still need a control strategy to tell us where we should be searching for some constituent at any point in a derivation. This paper provides such a control strategy, using this data structure, for doing search more effectively with a FWO grammar. The second contribution addresses another source of constraints on the search space: the length of the input. While this number is not a constant a</context>
</contexts>
<marker>Johnson, 1985</marker>
<rawString>M. Johnson. 1985. Parsing with discontinuous constituents. In Proceedings of the 23rd Annual Meeting of the Association for Computational Linguistics, pages 127–132.</rawString>
</citation>
<citation valid="true">
<authors>
<author>U Moencke</author>
<author>R Wilhelm</author>
</authors>
<title>Iterative algorithms on grammar graphs.</title>
<date>1982</date>
<booktitle>Proceedings of the 8th Conference on Graphtheoretic Concepts in Computer Science (WG 82),</booktitle>
<pages>177--194</pages>
<editor>In H. J. Schneider and H. Goettler, editors,</editor>
<publisher>Carl Hanser Verlag.</publisher>
<contexts>
<context position="18714" citStr="Moencke and Wilhelm (1982)" startWordPosition="3327" endWordPosition="3330">raph of the grammar in Figure 3, for example, is shown in S VP NP VP1 V NP NP1 N’ S VP2 V NP2 N’ N {boy, girl} N’1 N Det Det {a, the, this} N’2 N V {sees, calls} Figure 3: A sample CFG-like grammar. Figure 4. By convention, we draw category nodes with circles, and rule nodes with boxes, and we label rule nodes by the LHS categories of the rules they correspond to plus an index. For brevity, we will assume a normal form for our grammars here, in which the RHS of every rule is either a string of non-terminals or a single terminal. Category graphs are a minor variation of the “grammar graphs” of Moencke and Wilhelm (1982), but we will use them for a very different purpose. For brevity, we will consider only atomic non-terminals in the remainder of this section. Category graphs can be constructed for partially ordered sets of non-terminals, but in this case, they can only be used to approximate the values of the functions that they exactly compute in the atomic case. 13 N Lex Empty Det V NP1 N’2 N Det V NP VP N’ NP2 N’1 S S VP1 VP2 the fixed grammar G. Likewise, let Xmin(h) be the minimum yield that such an instance must produce. Also, as an abuse of functional notation, let: Xmax(&lt; h) = max0&lt;j&lt;h Xmax(�) Xmin(&lt;</context>
</contexts>
<marker>Moencke, Wilhelm, 1982</marker>
<rawString>U. Moencke and R. Wilhelm. 1982. Iterative algorithms on grammar graphs. In H. J. Schneider and H. Goettler, editors, Proceedings of the 8th Conference on Graphtheoretic Concepts in Computer Science (WG 82), pages 177–194. Carl Hanser Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Morawietz</author>
</authors>
<title>Chart parsing and constraint programming.</title>
<date>2000</date>
<booktitle>In Proceedings of the 18th International Conference on Computational Linguistics (COLING-00),</booktitle>
<volume>1</volume>
<pages>551--557</pages>
<contexts>
<context position="1820" citStr="Morawietz, 2000" startWordPosition="283" endWordPosition="284">e area for constraint-based methods because such a large number of linguistic partial knowledge sources must be brought to bear on FWO parsing in order to restrict its search space to a size comparable to that of standard CFG-based parsing. The first addresses the indexation of tabled substrings in generalized chart parsers for FWO languages. While chart parsing can famously be cast as deduction (Pereira and Warren, 1983), what chart parsing really is is an algebraic closure over the rules of a phrase structure grammar, which is most naturally expressed inside a constraint solver such as CHR (Morawietz, 2000). Ideally, we would like to use standard chart parsers for FWO languages, but because of the constituent ordering constraints that are implicit in the right-hand-sides (RHSs) of CFG rules, this is not possible without effectively converting a FWO grammar into a CFG by expanding its rule system exponentially into all possible RHS orders (Barton et al., 1987). FWO grammar rules generally cannot be used as they stand in a chart parser because tabled substrings record a non-terminal category C derived over a contiguous subspan of the input string from word i to word j. FWO languages have many phra</context>
</contexts>
<marker>Morawietz, 2000</marker>
<rawString>F. Morawietz. 2000. Chart parsing and constraint programming. In Proceedings of the 18th International Conference on Computational Linguistics (COLING-00), volume 1, pages 551–557.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Penn</author>
<author>M Haji-Abdolhosseini</author>
</authors>
<title>Topological parsing.</title>
<date>2003</date>
<booktitle>In Proceedings of the 10th Conference ofthe European Chapter of the Associationfor Computational Linguistics (EACL-03),</booktitle>
<pages>283--290</pages>
<contexts>
<context position="8682" citStr="Penn and Haji-Abdolhosseini (2003)" startWordPosition="1427" endWordPosition="1430">and because of our heightened awareness of the importance of goal-directedness to FWO parsing (see the discussion in the previous section), we will only outline the strictly top-down variant of our strategy, although natural analogues do exist for the other orientations. 2.1 State State is: (N, CanBV, ReqBV). The returned result is: UsedBV or failure. convention. To our knowledge, the first to apply it to the order of RHS categories, which only makes sense once one drops the implicit linear ordering implied by the RHSs of contextfree grammar rules, was Daniels and Meurers (2002). 10 Following Penn and Haji-Abdolhosseini (2003), we can characterize a search state under these assumptions using one non-terminal, N, and two subsets/bit vectors, the CanBV and ReqBV.2 CanBV is the set of all words that can be used to build an N, and ReqBV is the set of all words that must be used while building the N. CanBV always contains ReqBV, and what it additionally contains are optional words that may or may not be used. If search from this state is successful, i.e., N is found using ReqBV and nothing that is not in CanBV, then it returns a UsedBV, the subset of words that were actually used. We will assume here that our FWO gramma</context>
<context position="10165" citStr="Penn and Haji-Abdolhosseini (2003)" startWordPosition="1701" endWordPosition="1704"> Initialization A top-down parse of an n-length string begins with the state consisting of the distinguished category, S, of the grammar, and CanBV = ReqBV = f1 ... ng. 2.2.2 Active Edge Subsumption The first step is to check the current state against states that have already been considered. For expository reasons, this will be presented below. Let us assume for now that this step always fails to produce a matching edge. We must then predict using the rules of the FWO grammar. 2.2.3 Initial Prediction hN, C, Ri =) hN1, C, Oi, where: 1. N0 ! N1 ... Nk, 2. k &gt; 1, and 3. N t N0#. As outlined in Penn and Haji-Abdolhosseini (2003), the predictive step from a state consisting of hN, C, Ri using an immediate dominance rule, N0 ! N1 ... Nk, with k &gt; 1 and no linear precedence constraints transits to a state hN1, C, Oi provided that N is compatible with N0. In the case of a classical set of atomic non-terminals, compatibility should be interpreted as equality. In the 2Actually, Penn and Haji-Abdolhosseini (2003) use CanBV and OptBV, which can be defined as CanBV n ReqBV. case of Prolog terms, as in definite clause grammars, or typed feature structures, as in head-driven phrase structure grammar, compatibility can be interp</context>
<context position="12675" citStr="Penn and Haji-Abdolhosseini (2003)" startWordPosition="2171" endWordPosition="2174"> with Uk-1, 4. Ck_1 = C \ U1 \ ... \ Uk_1, and 5. Rk_1 = R \ U1 \ ... \ Uk_1. The completion step then involves recognizing the last RHS category (although this is no longer rightmost in terms of linear precedence). Here, the major difference from subsequent prediction is that there is now a potentially non-empty ReqBV. Only with the last RHS category are we actually in a position to enforce R from the source state. If hNk, Ck_1, Rk_1i succeeds with Uk, then hN, C, Ri succeeds with U1 [ ... [ Uk. 11 2.3 Active Edge Subsumption Revisited So far, this is very similar to the strategy outlined in Penn and Haji-Abdolhosseini (2003). If we were to add active edges in a manner similar to standard chart parsing, we would tabulate states like (Na, Ca, Ra) and then compare them in step 2.2.2 to current states (N, C, R) by determining whether (classically) N = Na, C = Ca, and R = Ra. This might catch some redundant search, but just as we can do better in the case of non-atomic categories by checking for subsumption (Na C N) or unifiability (N u Na, ), we can do better on C and R as well because these are sets that come with a natural notion of containment. Figure 1 shows an example of how this containment can be used. Rather </context>
</contexts>
<marker>Penn, Haji-Abdolhosseini, 2003</marker>
<rawString>G. Penn and M. Haji-Abdolhosseini. 2003. Topological parsing. In Proceedings of the 10th Conference ofthe European Chapter of the Associationfor Computational Linguistics (EACL-03), pages 283–290.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F C N Pereira</author>
<author>D H D Warren</author>
</authors>
<title>Parsing as deduction.</title>
<date>1983</date>
<booktitle>In Proceedings of 21st Annual Meeting of the Association for Computational Linguistics (ACL),</booktitle>
<pages>137--144</pages>
<contexts>
<context position="1629" citStr="Pereira and Warren, 1983" startWordPosition="250" endWordPosition="253">emantically transparent context-free analysis, because of a looser connection between grammatical function assignment and linear constituent order than one finds in English. This is a particularly ripe area for constraint-based methods because such a large number of linguistic partial knowledge sources must be brought to bear on FWO parsing in order to restrict its search space to a size comparable to that of standard CFG-based parsing. The first addresses the indexation of tabled substrings in generalized chart parsers for FWO languages. While chart parsing can famously be cast as deduction (Pereira and Warren, 1983), what chart parsing really is is an algebraic closure over the rules of a phrase structure grammar, which is most naturally expressed inside a constraint solver such as CHR (Morawietz, 2000). Ideally, we would like to use standard chart parsers for FWO languages, but because of the constituent ordering constraints that are implicit in the right-hand-sides (RHSs) of CFG rules, this is not possible without effectively converting a FWO grammar into a CFG by expanding its rule system exponentially into all possible RHS orders (Barton et al., 1987). FWO grammar rules generally cannot be used as th</context>
</contexts>
<marker>Pereira, Warren, 1983</marker>
<rawString>F. C. N. Pereira and D. H. D. Warren. 1983. Parsing as deduction. In Proceedings of 21st Annual Meeting of the Association for Computational Linguistics (ACL), pages 137–144.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Reape</author>
</authors>
<title>Parsing bounded discontinuous constituents: Generalisations of some common algorithms.</title>
<date>1991</date>
<booktitle>Word Order in Germanic and Parsing,</booktitle>
<pages>41--70</pages>
<editor>In M. Reape, editor,</editor>
<institution>Centre for Cognitive Science, University of Edinburgh.</institution>
<contexts>
<context position="2499" citStr="Reape (1991)" startWordPosition="392" endWordPosition="393">uages, but because of the constituent ordering constraints that are implicit in the right-hand-sides (RHSs) of CFG rules, this is not possible without effectively converting a FWO grammar into a CFG by expanding its rule system exponentially into all possible RHS orders (Barton et al., 1987). FWO grammar rules generally cannot be used as they stand in a chart parser because tabled substrings record a non-terminal category C derived over a contiguous subspan of the input string from word i to word j. FWO languages have many phrasal categories that are not contiguous substrings. Johnson (1985), Reape (1991) and others have suggested using bit vectors to index chart edges as an alternative to substring spans in the case of parsing over FWO languages, but that is really only half of the story. We still need a control strategy to tell us where we should be searching for some constituent at any point in a derivation. This paper provides such a control strategy, using this data structure, for doing search more effectively with a FWO grammar. The second contribution addresses another source of constraints on the search space: the length of the input. While this number is not a constant across parses, </context>
</contexts>
<marker>Reape, 1991</marker>
<rawString>M. Reape. 1991. Parsing bounded discontinuous constituents: Generalisations of some common algorithms. In M. Reape, editor, Word Order in Germanic and Parsing, pages 41–70. Centre for Cognitive Science, University of Edinburgh.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>