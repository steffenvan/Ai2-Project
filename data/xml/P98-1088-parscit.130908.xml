<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.001125">
<title confidence="0.947994">
Memoisation for Glue Language Deduction and Categorial Parsing
</title>
<author confidence="0.998514">
Mark Hepple
</author>
<affiliation confidence="0.997667">
Department of Computer Science
University of Sheffield
</affiliation>
<address confidence="0.911832">
Regent Court, 211 Portobello Street
Sheffield Si 4DP, UK
</address>
<email confidence="0.903015">
heppleOdcs.shef.ac.uk
</email>
<sectionHeader confidence="0.972261" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999982428571428">
The multiplicative fragment of linear logic has
found a number of applications in computa-
tional linguistics: in the &amp;quot;glue language&amp;quot; ap-
proach to LFG semantics, and in the formu-
lation and parsing of various categorial gram-
mars. These applications call for efficient de-
duction methods. Although a number of de-
duction methods for multiplicative linear logic
are known, none of them are tabular meth-
ods, which bring a substantial efficiency gain
by avoiding redundant computation (c.f. chart
methods in CFG parsing): this paper presents
such a method, and discusses its use in relation
to the above applications.
</bodyText>
<sectionHeader confidence="0.996303" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999985035714286">
The multiplicative fragment of linear logic,
which includes just the linear implication (0—)
and multiplicative (0) operators, has found a
number of applications within linguistics and
computational linguistics. Firstly, it can be
used in combination with some system of la-
belling (after the &apos;labelled deduction&apos; method-
ology of (Gabbay, 1996)) as a general method
for formulating various categorial grammar sys-
tems. Linear deduction methods provide a com-
mon basis for parsing categorial systems formu-
lated in this way. Secondly, the multiplicative
fragment forms the core of the system used in
work by Dalrymple and colleagues for handling
the semantics of LFG derivations, providing a
&apos;glue language&apos; for assembling the meanings of
sentences from those of words and phrases.
Although there are a number of deduction
methods for multiplicative linear logic, there is a
notable absence of tabular methods, which, like
chart parsing for CFGs, avoid redundant com-
putation. Hepple (1996) presents a compilation
method which allows for tabular deduction for
implicational linear logic (i.e. the fragment with
only 0—). This paper develops that method to
cover the fragment that includes the multiplic-
ative. The use of this method for the applica-
tions mentioned above is discussed.
</bodyText>
<sectionHeader confidence="0.936627" genericHeader="introduction">
2 Multiplicative Linear Logic
</sectionHeader>
<bodyText confidence="0.997528285714286">
Linear logic is a &apos;resource-sensitive&apos; logic: in any
deduction, each assumption (&apos;resource&apos;) is used
precisely once. The formulae of the multiplicat-
ive fragment of (intuitionistic) linear logic are
defined by .7&amp;quot; ::------ A IFo—F I .F 0 ,T (A a
nonempty set of atomic types). The following
rules provide a natural deduction formulation:
</bodyText>
<figure confidence="0.9265565">
Ao—B:a B:b
o—E
A: (ab)
Ao—B: Av.a
[B: x],[C : BOC: b
A : a A:a B:b
OE
A : ET, (b, a) AOB: (a b)
</figure>
<bodyText confidence="0.9967577">
The elimination (E) and introduction (I) rules
for o— correspond to steps of functional ap-
plication and abstraction, respectively, as the
term labelling reveals. The o—I rule dis-
charges precisely one assumption (B) within
the proof to which it applies. The 01 rule
pairs together the premise terms, whereas 0E
has a substitution like meaning.&apos; Proofs
that Wo— (Xo—Z), Xo—Y, Yo—Z = W and that
Xo—Yo—Z, YOZ = X follow:
</bodyText>
<equation confidence="0.973814571428571">
Wo—(X0—Z) : w Xo—Y : x Yo—Z : y [Z :
Y: (yz)
X: (x(yz))
Xo—Z:Az.x(yx)
W: w(Az.x(yz))
&apos;The meaning is more obvious in the notation of
(Benton et al., 1992): (let b be x0y in a).
[B : v]
A : a
538
Xo—Yo—Z : x [Z:z] [Y:y] YOZ:w
Xo—Y : (xz)
X : (xzy)
X: (w, (xzy))
</equation>
<bodyText confidence="0.999727111111111">
The differential status of the assumptions and
goal of a deduction (i.e. between r and A in
F = A) is addressed in terms of polarity: as-
sumptions are deemed to have positive polar-
ity, and goals negative polarity. Each Sub-
formula also has a polarity, which is determ-
ined by the polarity of the immediately con-
taining (sub)formula, according to the following
schemata (where 25 is the opposite polarity to p):
</bodyText>
<equation confidence="0.924582">
(i) ( XP Y P )P (ii) ( XP YP )P
</equation>
<bodyText confidence="0.999943636363636">
For example, the leftmost assumption of the
first proof above has the polarity pattern
( W+ o— (X— 0-- Z+ )— ). The proofs illustrate
the phenomenon of &apos;hypothetical reasoning&apos;,
where additional assumptions (called &apos;hypothet-
icals&apos;) are used, which are later discharged. The
need for hypothetical reasoning in a proof is
driven by the types of the assumptions and goal:
the hypotheticals correspond to positive polar-
ity subformulae of the assumptions/goal that
occur in the following subformula contexts:
</bodyText>
<equation confidence="0.9841885">
i) (X— o— Y+)— (giving hypothetical Y)
ii) (X+ Y+ )+ (giving hypo&apos;s X and Y)
</equation>
<bodyText confidence="0.996529153846154">
The subformula (Xo— Z) of Wo—(Xo—Z) in the
proof above is an instance of context (i), so a
hypothetical Z results. Subformulae that are in-
stances of patterns (i,ii) may nest within other
such instances (e.g. in ((A0B)0C)o—D, both
((AOB)0C) and (AB) are instances of (ii)).
In such cases, we can focus on the maximal pat-
tern instances (i.e. not contained within any
other), and then examine the hypotheticals pro-
duced for whether they in turn license hypothet-
ical reasoning. This approach makes explicit
the patterns of dependency amongst hypothet-
ical elements.
</bodyText>
<sectionHeader confidence="0.8758445" genericHeader="method">
3 First-order Compilation for
Implicational Linear Logic
</sectionHeader>
<bodyText confidence="0.999979071428571">
Hepple (1996) shows how deductions in implic-
ational linear logic can be recast as deductions
involving only first-order formulae, using only
a single inference rule (a variant of o—E). The
method involves compiling the original formulae
to indexed first-order formulae, where a higher-
order2 initial formula yields multiple compiled
formulae, e.g. (omitting indices) Xo— (Yo—Z)
would yield Xo—Y and Z, i.e. with the sub-
formula Z, relevant to hypothetical reasoning,
being excised to be treated as a separate as-
sumption, leaving a first-order residue.3 Index-
ing is used to ensure general linear use of re-
sources, but also notably to ensure proper use
of excised subformulae, i.e. so that Z, in our ex-
ample, must be used in deriving the argument
of Xo—Y, or otherwise invalid deductions would
result). Simplifying X0— (Yo— Z) to Xo—Y re-
moves the need for an o—I inference, but the
effect of such a step is not lost, since it is com-
piled into the semantics of the formula.
The approach is best explained by example.
In proving X0—(Yo—Z), Yo—W, Wo—Z = X,
the premise formulae compile to the indexed for-
mulae (1-4) shown in the proof below. Each
of these formulae (1-4) is associated with a
set containing a single index, which serves as
a unique identifier for that assumption.
</bodyText>
<listItem confidence="0.995178428571428">
1. : X0—(Y:{j}) : Au.x(Az.u)
2. {j}:Z:z
2. {k} : Yo—(W: 0) : Au.yu
4. {/} : Wo—(Z: 0) : Au.wu
5. {j, /} :W :wz [2+4]
6. {j, k, l} :Y : y(wz) [3+5]
7. {i, j, k, : X : x (Az .y(wz)) [1+6]
</listItem>
<bodyText confidence="0.999646857142857">
The formulae (5-7) arise under combination, al-
lowed by the single rule below. The index sets
of these formulae identify precisely the assump-
tions from which they are derived, with appro-
priate indexation being ensured by the condi-
tion 7r = q5ki-J7k of the rule (where-W- stands for
disjoint union, which enforces linear usage).
</bodyText>
<listItem confidence="0.448814333333333">
: Ao—(B:a): Av.a B: b ir=hb
C
ir : A :a[blv]
</listItem>
<bodyText confidence="0.9878977">
2The key division here is between higher-order formu-
lae, which are are functors that seek at least one argu-
ment that bears a a functional type (e.g. Wo—(Xo—Z)),
and first-order formulae, which seek no such argument.
3This &apos;excision&apos; step has parallels to the &apos;emit&apos; step
used in the chart-parsing approaches for the associative
Lambek calculus of (Honig, 1994) and (Hepple, 1992),
although the latters differs in that there is no removal
of the relevant subformula, i.e. the &apos;emitting formula&apos; is
not simplified, remaining higher-order.
</bodyText>
<page confidence="0.990756">
539
</page>
<bodyText confidence="0.999951166666667">
Assumptions (1) and (4) both come from
Xo—(Yo—Z): note how (1)&apos;s argument is marked
with (4)&apos;s index (j). The condition a C tp of the
rule ensures that (4) must contribute to the de-
rivation of (1)&apos;s argument. Finally, observe that
the rule&apos;s semantics involves not simple applic-
ation, but rather by direct substitution for the
variable of a lambda expression, employing a
special variant of substitution, notated _[_//.._],
which specifically does not act to avoid acci-
dental binding. Hence, in the final inference of
the proof, the variable z falls within the scope of
an abstraction over z, becoming bound. The ab-
straction over z corresponds to an o—I step that
is compiled into the semantics, so that an expli-
cit inference is no longer required. See (Hepple,
1996) for more details, including a precise state-
ment of the compilation procedure.
</bodyText>
<sectionHeader confidence="0.91543" genericHeader="method">
4 First-order Compilation for
Multiplicative Linear Logic
</sectionHeader>
<bodyText confidence="0.99977405">
In extending the above approach to the multi-
plicative, we will address the OI and OE rules
as separate problems. The need for an OI use
within a proof is driven by the type of either
some assumption or the proof&apos;s overall goal,
e.g. to build the argument of an assumption
such as Ao—(BOC). For this specific example,
we might try to avoid the need for an expli-
cit 01 use by transforming the assumption to
the form Ao—Bo—C (note that the two formu-
lae are interderivable). This line of explora-
tion, however, leads to incompleteness, since the
manoeuvre results in proof structures that lack
a node corresponding to the result of the OI in-
ference (which is present in the natural deduc-
tion proof), and this node may be needed as the
locus of some other inference.4 This problem
can be overcome by the use of goal atoms, which
are unique pseudo-type atoms, that are intro-
duced into types by compilation (in the par-
lance of lisp, they are tensymmed&apos; atoms). An
assumption Ao—(BOC) would compile to Ac—g
plus go-Bo-c, where g is the unique goal atom
(gl, perhaps). A proof using these types does
contain a node corresponding to (what would
be) the result of the 0 inference in the natural
4Specifically, the node must be present to allow
for steps corresponding to OE inferences. The ex-
pert reader should be able to convince themselves
of this fact by considering an example such as
Xo—((YOU)o—(ZOU)), Yo—Z X.
deduction proof, namely that bearing type g,
the result of combining go-Bo-c with its ar-
guments.
This method can be used in combination with
the existing compilation approach. For ex-
ample, an initial assumption Ao—((BOC)o—D)
would yield a hypothetical D, leaving the
residue A0—(BOC), which would become Ao—g
plus go—Bo—C, as just discussed. This method
of uniquely-generated &apos;goal atoms&apos; can also be
used in dealing with deductions having complex
types for their intended overall result (which
may license hypotheticals, by virtue of real-
ising the polarity contexts discussed in section
2). Thus, we can replace an initial deduction
F = A with go-A, r = g, making the goal A
part of the left hand side. The new premise
go-A can be compiled just like any other. Since
the new goal formula g is atomic, it requires no
compilation. For example, a goal type Xo—Y
would become an extra premise go-(xo-y),
which would compile to formulae go-x plus Y.
Turning next to OE, the rule involves hypo-
thetical reasoning, so compilation of a maximal
positive polarity subformula BOC will add hy-
potheticals B,C. No further compilation of BOC
itself is then required: whatever is needed for
hypothetical reasoning with respect to the in-
ternal structure of its subformulae will arise
elsewhere by compilation of the hypotheticals
B,C. Assume that these latter hypotheticals
have identifying indices i, j and semantic vari-
ables x,y respectively. A rule for OE might
combine BOC (with term t, say) with any other
formula A (with term s, say) provided that the
latter has a disjoint index set that includes i, j,
to give a result that is also of type A, that is as-
signed semantics E2,y(t,$). To be able to con-
struct this semantics, the rule would need to
be able to access the identities of the variables
x, y. The need to explicitly annotate this iden-
tity information might be avoided by &apos;raising&apos;
the semantics of the multiplicative formula at
compilation time to be a function over the other
term, e.g. t might be raised to Au.E2,y (t, u). A
usable inference rule might then take the follow-
ing form (where the identifying indices of the
hypotheticals have been marked on the product
type):
</bodyText>
<equation confidence="0.864006333333333">
(0, A, s) (7,b, (B C) : {i, j}, Au.t) j,j E
it =
(7, A, t[s/u])
</equation>
<page confidence="0.924773">
540
</page>
<bodyText confidence="0.996935395833333">
Note that we can safely restrict the rule to re-
quire that the type A of the minor premise
is atomic. This is possible since firstly, the
first-order compilation context ensures that the
arguments required by a functor to yield an
atomic result are always present (with respect to
completing a valid deduction), and secondly, the
alternatives of combining a functor with a mul-
tiplicative under the rule either before or after
supplying its arguments are equivalent.5
In fact, we do not need the rule above, as
we can instead achieve the same effects us-
ing only the single (0--) inference rule that we
already have, by allowing a very restricted use
of type polymorphism. Thus, since the above
rule&apos;s conclusion and minor premise are the
same atomic type, we can in the compilation
simply replace a formula X0Y, with an implic-
ation Ao—(A: {i, j}), where A is a variable over
atomic types (and i, j the identifying indices
of the two hypotheticals generated by compil-
ation). The semantics provided for this functor
is of the &apos;raised&apos; kind discussed above. However,
this approach to handling 0E inferences within
the compiled system has an undesirable charac-
teristic (which would also arise using the infer-
ence rule discussed above), which is that it will
allow multiple derivations that assign equival-
ent proof terms for a given type combination.
This is due to non-determinism for the stage
at which a type such as Ao— (A: { j}) particip-
ates in the proof. A proof might contain sev-
eral nodes bearing atomic types which contain
the required hypotheticals, and Ao — (A: j})
might combine in at any of these nodes, giving
equivalent results.6
The above ideas for handling the multiplicat-
ive are combined with the methods developed
&apos;This follows from the proof term equivalence
(ga)) = (EL(f,g) a) where x, y E freevars(g).
The move of requiring the minor premise to be atomic
effects a partial normalisation which involves not only
the relative ordering of OE and o—E steps, but also that
between interdependent OE steps (as might arise for an
assumption such as ((A0B)0C)). It is straightforward
to demonstrate that the restriction results in no loss of
readings. See (Benton et ai., 1992) regarding term as-
signment and proof normalisation for linear logic.
</bodyText>
<footnote confidence="0.6878265">
6It is anticipated that this problem can be solved by
using normalisation results as a basis for discarding par-
tial analyses during processing, but further work is re-
quired in developing this idea.
</footnote>
<bodyText confidence="0.999973">
for the implicational fragment to give the com-
pilation procedure (7), stated in Figure 1. This
takes a sequent r A as input (case 7-1), where
A is a type and each assumption in I&apos; takes
the form Type:Sem (Sem minimally just some
unique variable), and it returns a structure
(g, 0, A), where g is a goal atom, (/) the set of
all identifying indices, and A a set of indexed
first order formulae (with associated semantics).
Let A* denote the result of closing A under the
single inference rule. The sequent is proven if
(0, g, t) E 6,* for some term t, which is a com-
plete proof term for the implicit deduction. The
statement of the compilation procedure here is
somewhat different to that given in (Hepple,
1996), which is based on polar translation func-
tions. In the version here, the formula related
cases address only positive formulae.7
As an example, consider the deduction
Xo—Y, YOZ X0Z. Compilation returns the
goal atom gO, the full index set {g, h, j, k , 1} ,
plus the formulae show in (1-6) below.
</bodyText>
<figureCaption confidence="0.998081615384615">
({g}, g0 o—(gl: {h}), At.t)
({h} , gl o— (X: 0)0— (Z: 0), AvAw.(w 0 v))
(fib Xo—(Y: 0), Ax .(ax))
({j}, /1), Au.Er,z(b, u))
({k},Y, y)
({/}, Z, z)
({i , k} ,X, (ay)) [3+5]
({h, l}, gl o—(X: 0), Aw.(w z)) [2+6]
({h, i , k,1}, ((ay) z)) [7+8]
({h, j, k, /},g1,E(b, ((ay) 0 z))) [4+9]
({g, h,i, j, k, I} , gO, E?,z(b, ((ay) 0 z))) [1+11]
(fg, h, i, k, 11, gO, ((ay) 0 z)) [1+9]
({g, h,i, j, k,1} , gO, Erz (b, ((ay) 0 z))) [4+12]
</figureCaption>
<bodyText confidence="0.999137142857143">
The formulae (7-13) arise under combination.
Formulae (11) and (13) correspond to success-
ful overall analyses (i.e. have type gO, and are
labelled with the full index set). The proof il-
lustrates the possibility of multiple derivations
7Note that the complexity of the compilation is linear
in the &apos;size&apos; of the initial deduction, as measured by a
count of type atoms. For applications where the formulae
that may participate are preset (e.g. they are drawn
from lexicon), formulae can be precompiled, although the
results of precompilation would need to be parametised
with respect to the variables/indices appearing, with a
sufficient supply &apos;fresh&apos; symbols being generated at time
of lexical access, to ensure uniqueness.
</bodyText>
<page confidence="0.997554">
541
</page>
<figureCaption confidence="0.999976">
Figure 1: The Compilation Procedure
</figureCaption>
<bodyText confidence="0.961253666666667">
r(Xi: xi, , xn Xo) = (g, •A)
where io, • • • in fresh indices; g a fresh goal atom; 0 = indices(A)
AY•Y)) U T((ii, Xi, x1)) U • • • U T((in, Xn, xn))
</bodyText>
<equation confidence="0.959929666666667">
r(((/), X , s)) = (0, X, s) where X atomic
((0, X o-Y, s)) = r((0, Xo-(Y: 0), s)) where Y has no (inclusion) index set
7-((0, Xic)-(Y: s)) = (0, X20- (Y: Ax.t) U
</equation>
<bodyText confidence="0.9623337">
where Y is atomic; x a fresh variable; 71(0, (sx))) = (07 X2, t) WF
xo--((70--z): 0), s)) = ((0, X 0- (Y : 7), Ay.s(Az.y))) Ur((i, Z, z))
where i a fresh index; y, z fresh variables; 7r=iU//)
7((cp, Xo-((Y 0 Z): 0), s)) = WI), X c- (g: 7), s)) U go-Yo-Z, AzAy.(Y 0 z)))
where i a fresh index; g a fresh goal atom; y, z fresh variables; it =i1.4
7((0, X 0 Y, s)) = (4), Ao- - (A: {i, j}), At.(EL(s, t))) U r((i, X, x)) U T((j, Y, y))
where i, j fresh indices; x, y, t fresh variables; A a fresh variable over atomic types
assigning equivalent readings, i.e. (11) and (13)
have identical proof terms, that arise by non-
determinism for involvement of formula (4).
</bodyText>
<sectionHeader confidence="0.957985" genericHeader="method">
5 Computing Exclusion Constraints
</sectionHeader>
<bodyText confidence="0.999978181818182">
The use of inclusion constraints (i.e. require-
ments that some formula must be used in de-
riving a given functor&apos;s argument) within the
approach allows us to ensure that hypotheticals
are appropriately used in any overall deduction
and hence that deductions are valid. However,
the approach allows that deduction can generate
some intermediate results that cannot be part of
an overall deduction. For example, compiling a
formula Xo-(Yo-(Zo-W))0-(Vo-W) gives the
first-order residue Xo-Yo-V, plus hypothetic-
als Zo-W and W. A partial deduction in which
the hypothetical Zo-W is used in deriving the
argument V of Xo-Yo-V cannot be extended
to a successfull overall deduction, since its use
again for the functor&apos;s second argument Y (as
an inclusion constraint will require) would viol-
ate linear usage. For the same reason, a direct
combination of the hypotheticals Zo-W and W
is likewise a deductive dead end.
This problem can be addressed via exclusion
constraints, i.e. annotations to forbid stated
formulae having been used in deriving a given
funtor&apos;s argument, as proposed in (Hepple,
1998). Thus, a functor might have the form
Xo-(Y:{i}:{j}) to indicate that i must appear
in its argument&apos;s index set, and that j must not.
Such exclusions can be straightforwardly com-
puted over the set of compiled formulae that de-
rive from each initial assumption, using simple
(set-theoretic) patterns of reasoning. For ex-
ample, for the case above, since W must be
used in deriving the argument V of the main
residue formula, it can be excluded from the ar-
gument Y of that formula (which follows from
the disjointness condition on the single inference
rule). Given that the argument Y must include
Zo-W, but excludes W, we can infer that W
cannot contribute to the argument of Zo-W,
giving an exclusion constraint that (amongst
other things) blocks the direct combination of
Zo-W and W. See (Hepple, 1998) for more de-
tails (although a slightly different version of the
first-order formalism is used there).
</bodyText>
<sectionHeader confidence="0.991372" genericHeader="method">
6 Tabular Deduction
</sectionHeader>
<bodyText confidence="0.999978444444445">
A simple algorithm for use with the above ap-
proach, which avoids much redundant compu-
tation, is as follows. Given a possible theorem
to prove, the results of compilation (i.e. in-
dexed types plus semantics) are gathered on an
agenda. Then, a loop is followed in which an
item is taken from the agenda and added to the
database (which is initially empty), and then
the next triple is taken from the agenda and
</bodyText>
<page confidence="0.992799">
542
</page>
<bodyText confidence="0.999983810810811">
so on until the agenda is empty. Whenever an
entry is added to the database, a check is made
to see if it can combine with any that are already
there, in which case new agenda items are gen-
erated. When the agenda is empty, a check is
made for any successful overall analyses. Since
the result of a combination always bears an in-
dex set larger than either parent, and since the
maximal index set is fixed at compilation time,
the above process must terminate.
However, there is clearly more redundancy
to be eliminated here. Where two items dif-
fer only in their semantics, their subsequent
involvement in any further deductions will be
precisely parallel, and so they can be collapsed
together. For this purpose, the semantic com-
ponent of database entries is replaced with a
unique identifer, which serves as a &apos;hook&apos; for
semantic alternatives. Agenda items, on the
other hand, instead record the way that the
agenda item was produced, which is either &apos;pre-
supplied&apos; (by compilation) or `by combination&apos;,
in which case the entries combined are recorded
by their identifiers. When an agenda item is
added to the database, a check is made for an
entry with the same indexed type. If there is
none, a new entry is created and a check made
for possible combinations (giving rise to new
agenda items). However, if an appropriate ex-
isting entry is found, a record is made for that
entry of an additional way to produce it, but
no check made for possible combinations. If at
the end there is a successful overall analsysis,
its unique identifier, plus the records of what
combined to produce what, can be used to enu-
merate directly the proof terms for successful
analyses.
</bodyText>
<sectionHeader confidence="0.97903" genericHeader="method">
7 Application #1: Categorial
</sectionHeader>
<subsectionHeader confidence="0.834727">
Parsing
</subsectionHeader>
<bodyText confidence="0.9995202">
The associative Lambek calculus (Lambek,
1958) is perhaps the most familiar representat-
ive of the class of categorial formalisms that fall
within the &apos;type-logical&apos; tradition. Recent work
has seen proposals for a range of such systems,
differing in their resource sensitivity (and hence,
implicitly, their underlying notion of &apos;linguistic
structure&apos;), in some cases combining differing
resource sensitivities in one system.8 Many of
8See, for example, the formalisms developed in
(Moortgat et al., 1994), (Morrill, 1994), (Hepple, 1995).
these proposals employ a &apos;labelled deductive
system&apos; methodology (Gabbay, 1996), whereby
types in proofs are associated with labels which
record proof information for use in ensuring cor-
rect inferencing. A natural &apos;base logic&apos; on which
to construct such systems is the multiplicat-
ive fragment of linear logic, since (i) it stands
above the various categorial systems in the hier-
archy of substructural logics, and (ii) its oper-
ators correspond to precisely those appearing in
any standard categorial logic. The key require-
ment for parsing categorial systems formulated
in this way is some theorem proving method
that is sufficient for the fragment of linear logic
employed (although some additional work will
be required for managing labels), and a num-
ber of different approaches have been used, e.g.
proof nets (Moortgat, 1992), and SLD resolu-
tion (Morrill, 1995). Hepple (1996) introduces
first-order compilation for implicational linear
logic, and shows how that method can be used
with labelling as a basis parsing implicational
categorial systems. No further complications
arise for combining the extended compilation
approach described in this paper with labelling
systems as a basis for efficient, non-redundant
parsing of categorial formalisms in the core mul-
tiplicative fragment. See (Hepple, 1996) for a
worked example.
</bodyText>
<sectionHeader confidence="0.9967275" genericHeader="method">
8 Application #2: Glue Language
Deduction
</sectionHeader>
<bodyText confidence="0.999692">
In a line of research beginning with Dalrymple
et al. (1993), a fragment of linear logic is used as
a &apos;glue language&apos; for assembling sentence mean-
ings for LFG analyses in a &apos;deductive&apos; fashion
(enabling, for example, an direct treatment of
quantifier scoping, without need of additional
mechanisms). Some sample expressions:
</bodyText>
<sectionHeader confidence="0.687667" genericHeader="conclusions">
hates:
</sectionHeader>
<construct confidence="0.585650333333333">
VX, (s -s-&gt;t hates(X,Y))c--((f &apos;-eX) 0 (9 eY))
everyone: VH, S.(H every(per son, S))
0—(Y x .(H S(x))0—(9 e x))
</construct>
<bodyText confidence="0.9993855">
The operator serves to pair together a &apos;role&apos;
with a meaning expression (whose semantic
type is shown by a subscript), where a &apos;role&apos;
is essentially a node in a LFG f-structure. For
our purposes roles can be treated as if they were
just atomic symbols. For theorem proving pur-
poses, the universal quantifiers above can be de-
leted: the uppercase variables can be treated
</bodyText>
<page confidence="0.995008">
543
</page>
<bodyText confidence="0.999989042553192">
as Prolog-like variables, which become instanti-
ated under matching during proof construction;
the lowercase variables can be replaced by arbit-
rary constants. Such deletion leaves a residue
that can be treated as just expressions of mul-
tiplicative linear logic, with role/meaning pairs
serving as `basic formulae&apos;.9
An observation contrasting the categorial and
glue language approaches is that in the cat-
egorial case, all that is required of a deduction
is the proof term it returns, which (for &apos;lin-
guistic derivations&apos;) provides a `semantic recipe&apos;
for combining the lexical meanings of initial for-
mulae directly. However, for the glue language
case, given the way that meanings are folded
into the logical expressions, the lexical terms
themselves must participate in a proof for the
semantics of a LFG derivation to be produced.
Here is one way that the first-order compila-
tion approach might be used for glue language
deduction (other ways are possible). Firstly,
we can take each (quantifier-free) glue term, re-
place each role/meaning pair with just the role
component, and associate the resulting formula
with a unique semantic variable. The set of for-
mulae so produced can then undergo the first-
order compilation procedure. Crucially for com-
pilation, although some of the role expressions
in the formulae may be (Prolog-like&apos;) variables,
they correspond to atomic formulae (so there is
no `hidden structure&apos; that compilation cannot
address). A complication here is that occur-
rences of a single role variable may end up in
different first-order formulae. In any overall de-
duction, the binding of these multiple variable
instances must be consistent, but we cannot rely
on a global binding context, since alternative
proofs will typically induce distinct (but intern-
ally consistent) bindings. Hence, bindings must
be handled locally (i.e. relative to each database
formula) and combinations will involve merging
of local binding contexts. Each proof term that
tabular deduction returns corresponds to a nat-
ural deduction proof over the precompilation
formulae. If we mechanically mirror this pat-
tern of proof over the original glue terms (with
meanings, but quantifier-free), a role/meaning
</bodyText>
<footnote confidence="0.6180625">
9See (Fry, 1997), who uses a proof net method for glue
language deduction, for relevant discussion. This paper
also provides examples of glue language uses that require
a full deductive system for the multiplicative fragment.
</footnote>
<bodyText confidence="0.9957395">
pair that provides a reading of the original LFG
derivation will result.
</bodyText>
<sectionHeader confidence="0.990221" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999862818181818">
Nick Benton, Gavin Bierman, Valeria de Paiva
&amp; Martin Hyland. 1992. `Term Assignment
for Intuitionistic Linear Logic.&apos; Tech. Report
262, Cambridge University Computer Lab.
Mary Dalrymple, John Lamping &amp; Vijay
Saraswat. 1993. `LFG semantics via con-
straints.&apos; Proc. EACL-6, Utrecht.
John Fry 1997. `Negative Polarity Licensing
at the Syntax-Semantics Interface.&apos; Proc.
ACL/EACL-97 Joint Conference, Madrid.
Dov M. Gabbay. 1996. Labelled deductive sys-
tems. Volume 1. Oxford University Press.
Mark Hepple. 1992. `Chart Parsing Lambek
Grammars: Modal Extensions and Incre-
mentality&apos;, Proc. COLING-92.
Mark Hepple. 1995. `Mixing Modes of Lin-
guistic Description in Categorial Grammar.&apos;
Proc. EACL-7, Dublin.
Mark Hepple. 1996. `A Compilation-Chart
Method for Linear Categorial Deduction.&apos;
Proc. COLING-96, Copenhagen.
Mark Hepple. 1998. `Linear Deduction via
First-order Compilation.&apos; Proc. First Work-
shop on Tabulation in Parsing and Deduc-
tion.
Esther K8nig. 1994. `A Hypothetical Reasoning
Algorithm for Linguistic Analysis.&apos; Journal
of Logic and Computation, Vol. 4, No 1.
Joachim Lambek. 1958. `The mathematics of
sentence structure.&apos; American Mathematical
Monthly, 65, pp154-170.
Michael Moortgat. 1992. `Labelled deduct-
ive systems for categorial theorem proving.&apos;
Proc. of Eighth Amsterdam Colloquium, ILLI,
University of Amsterdam.
Michael Moortgat 8z Richard T. Oehrle. 1994.
`Adjacency, dependency and order.&apos; Proc. of
Ninth Amsterdam Colloquium.
Glyn Morrill. 1994. Type Logical Grammar:
Categorial Logic of Signs. Kluwer Academic
Publishers, Dordrecht.
Glyn Morrill. 1995. `Higher-order Linear Lo-
gic Programming of Categorial Deduction.&apos;
Proc. of EACL-7, Dublin.
</reference>
<page confidence="0.99827">
544
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.935462">
<title confidence="0.99996">Memoisation for Glue Language Deduction and Categorial Parsing</title>
<author confidence="0.999968">Mark Hepple</author>
<affiliation confidence="0.999881">Department of Computer Science University of Sheffield</affiliation>
<address confidence="0.9749465">Regent Court, 211 Portobello Street Sheffield Si 4DP, UK</address>
<email confidence="0.997088">heppleOdcs.shef.ac.uk</email>
<abstract confidence="0.999167066666667">The multiplicative fragment of linear logic has found a number of applications in computational linguistics: in the &amp;quot;glue language&amp;quot; approach to LFG semantics, and in the formulation and parsing of various categorial grammars. These applications call for efficient deduction methods. Although a number of deduction methods for multiplicative linear logic are known, none of them are tabular methods, which bring a substantial efficiency gain by avoiding redundant computation (c.f. chart methods in CFG parsing): this paper presents such a method, and discusses its use in relation to the above applications.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Nick Benton</author>
<author>Gavin Bierman</author>
<author>Valeria de Paiva</author>
<author>Martin Hyland</author>
</authors>
<title>Term Assignment for Intuitionistic Linear Logic.&apos;</title>
<date>1992</date>
<tech>Tech. Report 262,</tech>
<institution>Cambridge University Computer Lab.</institution>
<marker>Benton, Bierman, de Paiva, Hyland, 1992</marker>
<rawString>Nick Benton, Gavin Bierman, Valeria de Paiva &amp; Martin Hyland. 1992. `Term Assignment for Intuitionistic Linear Logic.&apos; Tech. Report 262, Cambridge University Computer Lab.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mary Dalrymple</author>
<author>John Lamping</author>
<author>Vijay Saraswat</author>
</authors>
<title>LFG semantics via constraints.&apos;</title>
<date>1993</date>
<booktitle>Proc. EACL-6,</booktitle>
<location>Utrecht.</location>
<contexts>
<context position="23572" citStr="Dalrymple et al. (1993)" startWordPosition="4024" endWordPosition="4027">ts (Moortgat, 1992), and SLD resolution (Morrill, 1995). Hepple (1996) introduces first-order compilation for implicational linear logic, and shows how that method can be used with labelling as a basis parsing implicational categorial systems. No further complications arise for combining the extended compilation approach described in this paper with labelling systems as a basis for efficient, non-redundant parsing of categorial formalisms in the core multiplicative fragment. See (Hepple, 1996) for a worked example. 8 Application #2: Glue Language Deduction In a line of research beginning with Dalrymple et al. (1993), a fragment of linear logic is used as a &apos;glue language&apos; for assembling sentence meanings for LFG analyses in a &apos;deductive&apos; fashion (enabling, for example, an direct treatment of quantifier scoping, without need of additional mechanisms). Some sample expressions: hates: VX, (s -s-&gt;t hates(X,Y))c--((f &apos;-eX) 0 (9 eY)) everyone: VH, S.(H every(per son, S)) 0—(Y x .(H S(x))0—(9 e x)) The operator serves to pair together a &apos;role&apos; with a meaning expression (whose semantic type is shown by a subscript), where a &apos;role&apos; is essentially a node in a LFG f-structure. For our purposes roles can be treated </context>
</contexts>
<marker>Dalrymple, Lamping, Saraswat, 1993</marker>
<rawString>Mary Dalrymple, John Lamping &amp; Vijay Saraswat. 1993. `LFG semantics via constraints.&apos; Proc. EACL-6, Utrecht.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John Fry</author>
</authors>
<title>Negative Polarity Licensing at the Syntax-Semantics Interface.&apos;</title>
<date>1997</date>
<booktitle>Proc. ACL/EACL-97 Joint Conference,</booktitle>
<location>Madrid.</location>
<marker>Fry, 1997</marker>
<rawString>John Fry 1997. `Negative Polarity Licensing at the Syntax-Semantics Interface.&apos; Proc. ACL/EACL-97 Joint Conference, Madrid.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dov M Gabbay</author>
</authors>
<title>Labelled deductive systems. Volume 1.</title>
<date>1996</date>
<publisher>Oxford University Press.</publisher>
<contexts>
<context position="1183" citStr="Gabbay, 1996" startWordPosition="175" endWordPosition="176">c are known, none of them are tabular methods, which bring a substantial efficiency gain by avoiding redundant computation (c.f. chart methods in CFG parsing): this paper presents such a method, and discusses its use in relation to the above applications. 1 Introduction The multiplicative fragment of linear logic, which includes just the linear implication (0—) and multiplicative (0) operators, has found a number of applications within linguistics and computational linguistics. Firstly, it can be used in combination with some system of labelling (after the &apos;labelled deduction&apos; methodology of (Gabbay, 1996)) as a general method for formulating various categorial grammar systems. Linear deduction methods provide a common basis for parsing categorial systems formulated in this way. Secondly, the multiplicative fragment forms the core of the system used in work by Dalrymple and colleagues for handling the semantics of LFG derivations, providing a &apos;glue language&apos; for assembling the meanings of sentences from those of words and phrases. Although there are a number of deduction methods for multiplicative linear logic, there is a notable absence of tabular methods, which, like chart parsing for CFGs, a</context>
<context position="22220" citStr="Gabbay, 1996" startWordPosition="3817" endWordPosition="3818">associative Lambek calculus (Lambek, 1958) is perhaps the most familiar representative of the class of categorial formalisms that fall within the &apos;type-logical&apos; tradition. Recent work has seen proposals for a range of such systems, differing in their resource sensitivity (and hence, implicitly, their underlying notion of &apos;linguistic structure&apos;), in some cases combining differing resource sensitivities in one system.8 Many of 8See, for example, the formalisms developed in (Moortgat et al., 1994), (Morrill, 1994), (Hepple, 1995). these proposals employ a &apos;labelled deductive system&apos; methodology (Gabbay, 1996), whereby types in proofs are associated with labels which record proof information for use in ensuring correct inferencing. A natural &apos;base logic&apos; on which to construct such systems is the multiplicative fragment of linear logic, since (i) it stands above the various categorial systems in the hierarchy of substructural logics, and (ii) its operators correspond to precisely those appearing in any standard categorial logic. The key requirement for parsing categorial systems formulated in this way is some theorem proving method that is sufficient for the fragment of linear logic employed (althou</context>
</contexts>
<marker>Gabbay, 1996</marker>
<rawString>Dov M. Gabbay. 1996. Labelled deductive systems. Volume 1. Oxford University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Hepple</author>
</authors>
<title>Chart Parsing Lambek Grammars: Modal Extensions and Incrementality&apos;,</title>
<date>1992</date>
<booktitle>Proc. COLING-92.</booktitle>
<contexts>
<context position="7107" citStr="Hepple, 1992" startWordPosition="1197" endWordPosition="1198">mptions from which they are derived, with appropriate indexation being ensured by the condition 7r = q5ki-J7k of the rule (where-W- stands for disjoint union, which enforces linear usage). : Ao—(B:a): Av.a B: b ir=hb C ir : A :a[blv] 2The key division here is between higher-order formulae, which are are functors that seek at least one argument that bears a a functional type (e.g. Wo—(Xo—Z)), and first-order formulae, which seek no such argument. 3This &apos;excision&apos; step has parallels to the &apos;emit&apos; step used in the chart-parsing approaches for the associative Lambek calculus of (Honig, 1994) and (Hepple, 1992), although the latters differs in that there is no removal of the relevant subformula, i.e. the &apos;emitting formula&apos; is not simplified, remaining higher-order. 539 Assumptions (1) and (4) both come from Xo—(Yo—Z): note how (1)&apos;s argument is marked with (4)&apos;s index (j). The condition a C tp of the rule ensures that (4) must contribute to the derivation of (1)&apos;s argument. Finally, observe that the rule&apos;s semantics involves not simple application, but rather by direct substitution for the variable of a lambda expression, employing a special variant of substitution, notated _[_//.._], which specific</context>
</contexts>
<marker>Hepple, 1992</marker>
<rawString>Mark Hepple. 1992. `Chart Parsing Lambek Grammars: Modal Extensions and Incrementality&apos;, Proc. COLING-92.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Hepple</author>
</authors>
<title>Mixing Modes of Linguistic Description in Categorial Grammar.&apos;</title>
<date>1995</date>
<booktitle>Proc. EACL-7,</booktitle>
<location>Dublin.</location>
<contexts>
<context position="22139" citStr="Hepple, 1995" startWordPosition="3807" endWordPosition="3808">he proof terms for successful analyses. 7 Application #1: Categorial Parsing The associative Lambek calculus (Lambek, 1958) is perhaps the most familiar representative of the class of categorial formalisms that fall within the &apos;type-logical&apos; tradition. Recent work has seen proposals for a range of such systems, differing in their resource sensitivity (and hence, implicitly, their underlying notion of &apos;linguistic structure&apos;), in some cases combining differing resource sensitivities in one system.8 Many of 8See, for example, the formalisms developed in (Moortgat et al., 1994), (Morrill, 1994), (Hepple, 1995). these proposals employ a &apos;labelled deductive system&apos; methodology (Gabbay, 1996), whereby types in proofs are associated with labels which record proof information for use in ensuring correct inferencing. A natural &apos;base logic&apos; on which to construct such systems is the multiplicative fragment of linear logic, since (i) it stands above the various categorial systems in the hierarchy of substructural logics, and (ii) its operators correspond to precisely those appearing in any standard categorial logic. The key requirement for parsing categorial systems formulated in this way is some theorem pr</context>
</contexts>
<marker>Hepple, 1995</marker>
<rawString>Mark Hepple. 1995. `Mixing Modes of Linguistic Description in Categorial Grammar.&apos; Proc. EACL-7, Dublin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Hepple</author>
</authors>
<title>A Compilation-Chart Method for Linear Categorial Deduction.&apos;</title>
<date>1996</date>
<booktitle>Proc. COLING-96,</booktitle>
<location>Copenhagen.</location>
<contexts>
<context position="1824" citStr="Hepple (1996)" startWordPosition="275" endWordPosition="276">rmulating various categorial grammar systems. Linear deduction methods provide a common basis for parsing categorial systems formulated in this way. Secondly, the multiplicative fragment forms the core of the system used in work by Dalrymple and colleagues for handling the semantics of LFG derivations, providing a &apos;glue language&apos; for assembling the meanings of sentences from those of words and phrases. Although there are a number of deduction methods for multiplicative linear logic, there is a notable absence of tabular methods, which, like chart parsing for CFGs, avoid redundant computation. Hepple (1996) presents a compilation method which allows for tabular deduction for implicational linear logic (i.e. the fragment with only 0—). This paper develops that method to cover the fragment that includes the multiplicative. The use of this method for the applications mentioned above is discussed. 2 Multiplicative Linear Logic Linear logic is a &apos;resource-sensitive&apos; logic: in any deduction, each assumption (&apos;resource&apos;) is used precisely once. The formulae of the multiplicative fragment of (intuitionistic) linear logic are defined by .7&amp;quot; ::------ A IFo—F I .F 0 ,T (A a nonempty set of atomic types). T</context>
<context position="4910" citStr="Hepple (1996)" startWordPosition="811" endWordPosition="812">— Z) of Wo—(Xo—Z) in the proof above is an instance of context (i), so a hypothetical Z results. Subformulae that are instances of patterns (i,ii) may nest within other such instances (e.g. in ((A0B)0C)o—D, both ((AOB)0C) and (AB) are instances of (ii)). In such cases, we can focus on the maximal pattern instances (i.e. not contained within any other), and then examine the hypotheticals produced for whether they in turn license hypothetical reasoning. This approach makes explicit the patterns of dependency amongst hypothetical elements. 3 First-order Compilation for Implicational Linear Logic Hepple (1996) shows how deductions in implicational linear logic can be recast as deductions involving only first-order formulae, using only a single inference rule (a variant of o—E). The method involves compiling the original formulae to indexed first-order formulae, where a higherorder2 initial formula yields multiple compiled formulae, e.g. (omitting indices) Xo— (Yo—Z) would yield Xo—Y and Z, i.e. with the subformula Z, relevant to hypothetical reasoning, being excised to be treated as a separate assumption, leaving a first-order residue.3 Indexing is used to ensure general linear use of resources, bu</context>
<context position="8036" citStr="Hepple, 1996" startWordPosition="1351" endWordPosition="1352">) must contribute to the derivation of (1)&apos;s argument. Finally, observe that the rule&apos;s semantics involves not simple application, but rather by direct substitution for the variable of a lambda expression, employing a special variant of substitution, notated _[_//.._], which specifically does not act to avoid accidental binding. Hence, in the final inference of the proof, the variable z falls within the scope of an abstraction over z, becoming bound. The abstraction over z corresponds to an o—I step that is compiled into the semantics, so that an explicit inference is no longer required. See (Hepple, 1996) for more details, including a precise statement of the compilation procedure. 4 First-order Compilation for Multiplicative Linear Logic In extending the above approach to the multiplicative, we will address the OI and OE rules as separate problems. The need for an OI use within a proof is driven by the type of either some assumption or the proof&apos;s overall goal, e.g. to build the argument of an assumption such as Ao—(BOC). For this specific example, we might try to avoid the need for an explicit 01 use by transforming the assumption to the form Ao—Bo—C (note that the two formulae are interderi</context>
<context position="14981" citStr="Hepple, 1996" startWordPosition="2555" endWordPosition="2556">es a sequent r A as input (case 7-1), where A is a type and each assumption in I&apos; takes the form Type:Sem (Sem minimally just some unique variable), and it returns a structure (g, 0, A), where g is a goal atom, (/) the set of all identifying indices, and A a set of indexed first order formulae (with associated semantics). Let A* denote the result of closing A under the single inference rule. The sequent is proven if (0, g, t) E 6,* for some term t, which is a complete proof term for the implicit deduction. The statement of the compilation procedure here is somewhat different to that given in (Hepple, 1996), which is based on polar translation functions. In the version here, the formula related cases address only positive formulae.7 As an example, consider the deduction Xo—Y, YOZ X0Z. Compilation returns the goal atom gO, the full index set {g, h, j, k , 1} , plus the formulae show in (1-6) below. ({g}, g0 o—(gl: {h}), At.t) ({h} , gl o— (X: 0)0— (Z: 0), AvAw.(w 0 v)) (fib Xo—(Y: 0), Ax .(ax)) ({j}, /1), Au.Er,z(b, u)) ({k},Y, y) ({/}, Z, z) ({i , k} ,X, (ay)) [3+5] ({h, l}, gl o—(X: 0), Aw.(w z)) [2+6] ({h, i , k,1}, ((ay) z)) [7+8] ({h, j, k, /},g1,E(b, ((ay) 0 z))) [4+9] ({g, h,i, j, k, I} , </context>
<context position="23019" citStr="Hepple (1996)" startWordPosition="3945" endWordPosition="3946">the multiplicative fragment of linear logic, since (i) it stands above the various categorial systems in the hierarchy of substructural logics, and (ii) its operators correspond to precisely those appearing in any standard categorial logic. The key requirement for parsing categorial systems formulated in this way is some theorem proving method that is sufficient for the fragment of linear logic employed (although some additional work will be required for managing labels), and a number of different approaches have been used, e.g. proof nets (Moortgat, 1992), and SLD resolution (Morrill, 1995). Hepple (1996) introduces first-order compilation for implicational linear logic, and shows how that method can be used with labelling as a basis parsing implicational categorial systems. No further complications arise for combining the extended compilation approach described in this paper with labelling systems as a basis for efficient, non-redundant parsing of categorial formalisms in the core multiplicative fragment. See (Hepple, 1996) for a worked example. 8 Application #2: Glue Language Deduction In a line of research beginning with Dalrymple et al. (1993), a fragment of linear logic is used as a &apos;glue</context>
</contexts>
<marker>Hepple, 1996</marker>
<rawString>Mark Hepple. 1996. `A Compilation-Chart Method for Linear Categorial Deduction.&apos; Proc. COLING-96, Copenhagen.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Hepple</author>
</authors>
<title>Linear Deduction via First-order Compilation.&apos;</title>
<date>1998</date>
<booktitle>Proc. First Workshop on Tabulation in Parsing and Deduction.</booktitle>
<contexts>
<context position="18567" citStr="Hepple, 1998" startWordPosition="3202" endWordPosition="3203">e Xo-Yo-V, plus hypotheticals Zo-W and W. A partial deduction in which the hypothetical Zo-W is used in deriving the argument V of Xo-Yo-V cannot be extended to a successfull overall deduction, since its use again for the functor&apos;s second argument Y (as an inclusion constraint will require) would violate linear usage. For the same reason, a direct combination of the hypotheticals Zo-W and W is likewise a deductive dead end. This problem can be addressed via exclusion constraints, i.e. annotations to forbid stated formulae having been used in deriving a given funtor&apos;s argument, as proposed in (Hepple, 1998). Thus, a functor might have the form Xo-(Y:{i}:{j}) to indicate that i must appear in its argument&apos;s index set, and that j must not. Such exclusions can be straightforwardly computed over the set of compiled formulae that derive from each initial assumption, using simple (set-theoretic) patterns of reasoning. For example, for the case above, since W must be used in deriving the argument V of the main residue formula, it can be excluded from the argument Y of that formula (which follows from the disjointness condition on the single inference rule). Given that the argument Y must include Zo-W, </context>
</contexts>
<marker>Hepple, 1998</marker>
<rawString>Mark Hepple. 1998. `Linear Deduction via First-order Compilation.&apos; Proc. First Workshop on Tabulation in Parsing and Deduction.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Esther K8nig</author>
</authors>
<title>A Hypothetical Reasoning Algorithm for Linguistic Analysis.&apos;</title>
<date>1994</date>
<journal>Journal of Logic and Computation,</journal>
<volume>4</volume>
<marker>K8nig, 1994</marker>
<rawString>Esther K8nig. 1994. `A Hypothetical Reasoning Algorithm for Linguistic Analysis.&apos; Journal of Logic and Computation, Vol. 4, No 1.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joachim Lambek</author>
</authors>
<title>The mathematics of sentence structure.&apos;</title>
<date>1958</date>
<journal>American Mathematical Monthly,</journal>
<volume>65</volume>
<pages>154--170</pages>
<contexts>
<context position="21649" citStr="Lambek, 1958" startWordPosition="3736" endWordPosition="3737"> for an entry with the same indexed type. If there is none, a new entry is created and a check made for possible combinations (giving rise to new agenda items). However, if an appropriate existing entry is found, a record is made for that entry of an additional way to produce it, but no check made for possible combinations. If at the end there is a successful overall analsysis, its unique identifier, plus the records of what combined to produce what, can be used to enumerate directly the proof terms for successful analyses. 7 Application #1: Categorial Parsing The associative Lambek calculus (Lambek, 1958) is perhaps the most familiar representative of the class of categorial formalisms that fall within the &apos;type-logical&apos; tradition. Recent work has seen proposals for a range of such systems, differing in their resource sensitivity (and hence, implicitly, their underlying notion of &apos;linguistic structure&apos;), in some cases combining differing resource sensitivities in one system.8 Many of 8See, for example, the formalisms developed in (Moortgat et al., 1994), (Morrill, 1994), (Hepple, 1995). these proposals employ a &apos;labelled deductive system&apos; methodology (Gabbay, 1996), whereby types in proofs are</context>
</contexts>
<marker>Lambek, 1958</marker>
<rawString>Joachim Lambek. 1958. `The mathematics of sentence structure.&apos; American Mathematical Monthly, 65, pp154-170.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Moortgat</author>
</authors>
<title>Labelled deductive systems for categorial theorem proving.&apos;</title>
<date>1992</date>
<booktitle>Proc. of Eighth Amsterdam Colloquium, ILLI,</booktitle>
<institution>University of Amsterdam.</institution>
<contexts>
<context position="22968" citStr="Moortgat, 1992" startWordPosition="3937" endWordPosition="3938">l &apos;base logic&apos; on which to construct such systems is the multiplicative fragment of linear logic, since (i) it stands above the various categorial systems in the hierarchy of substructural logics, and (ii) its operators correspond to precisely those appearing in any standard categorial logic. The key requirement for parsing categorial systems formulated in this way is some theorem proving method that is sufficient for the fragment of linear logic employed (although some additional work will be required for managing labels), and a number of different approaches have been used, e.g. proof nets (Moortgat, 1992), and SLD resolution (Morrill, 1995). Hepple (1996) introduces first-order compilation for implicational linear logic, and shows how that method can be used with labelling as a basis parsing implicational categorial systems. No further complications arise for combining the extended compilation approach described in this paper with labelling systems as a basis for efficient, non-redundant parsing of categorial formalisms in the core multiplicative fragment. See (Hepple, 1996) for a worked example. 8 Application #2: Glue Language Deduction In a line of research beginning with Dalrymple et al. (1</context>
</contexts>
<marker>Moortgat, 1992</marker>
<rawString>Michael Moortgat. 1992. `Labelled deductive systems for categorial theorem proving.&apos; Proc. of Eighth Amsterdam Colloquium, ILLI, University of Amsterdam.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Moortgat 8z Richard T Oehrle</author>
</authors>
<title>Adjacency, dependency and order.&apos;</title>
<date>1994</date>
<booktitle>Proc. of Ninth</booktitle>
<location>Amsterdam Colloquium.</location>
<marker>Oehrle, 1994</marker>
<rawString>Michael Moortgat 8z Richard T. Oehrle. 1994. `Adjacency, dependency and order.&apos; Proc. of Ninth Amsterdam Colloquium.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Glyn Morrill</author>
</authors>
<title>Type Logical Grammar: Categorial Logic of Signs.</title>
<date>1994</date>
<publisher>Kluwer Academic Publishers,</publisher>
<location>Dordrecht.</location>
<contexts>
<context position="22123" citStr="Morrill, 1994" startWordPosition="3805" endWordPosition="3806">merate directly the proof terms for successful analyses. 7 Application #1: Categorial Parsing The associative Lambek calculus (Lambek, 1958) is perhaps the most familiar representative of the class of categorial formalisms that fall within the &apos;type-logical&apos; tradition. Recent work has seen proposals for a range of such systems, differing in their resource sensitivity (and hence, implicitly, their underlying notion of &apos;linguistic structure&apos;), in some cases combining differing resource sensitivities in one system.8 Many of 8See, for example, the formalisms developed in (Moortgat et al., 1994), (Morrill, 1994), (Hepple, 1995). these proposals employ a &apos;labelled deductive system&apos; methodology (Gabbay, 1996), whereby types in proofs are associated with labels which record proof information for use in ensuring correct inferencing. A natural &apos;base logic&apos; on which to construct such systems is the multiplicative fragment of linear logic, since (i) it stands above the various categorial systems in the hierarchy of substructural logics, and (ii) its operators correspond to precisely those appearing in any standard categorial logic. The key requirement for parsing categorial systems formulated in this way is</context>
</contexts>
<marker>Morrill, 1994</marker>
<rawString>Glyn Morrill. 1994. Type Logical Grammar: Categorial Logic of Signs. Kluwer Academic Publishers, Dordrecht.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Glyn Morrill</author>
</authors>
<title>Higher-order Linear Logic Programming of Categorial Deduction.&apos;</title>
<date>1995</date>
<booktitle>Proc. of EACL-7,</booktitle>
<location>Dublin.</location>
<contexts>
<context position="23004" citStr="Morrill, 1995" startWordPosition="3943" endWordPosition="3944">such systems is the multiplicative fragment of linear logic, since (i) it stands above the various categorial systems in the hierarchy of substructural logics, and (ii) its operators correspond to precisely those appearing in any standard categorial logic. The key requirement for parsing categorial systems formulated in this way is some theorem proving method that is sufficient for the fragment of linear logic employed (although some additional work will be required for managing labels), and a number of different approaches have been used, e.g. proof nets (Moortgat, 1992), and SLD resolution (Morrill, 1995). Hepple (1996) introduces first-order compilation for implicational linear logic, and shows how that method can be used with labelling as a basis parsing implicational categorial systems. No further complications arise for combining the extended compilation approach described in this paper with labelling systems as a basis for efficient, non-redundant parsing of categorial formalisms in the core multiplicative fragment. See (Hepple, 1996) for a worked example. 8 Application #2: Glue Language Deduction In a line of research beginning with Dalrymple et al. (1993), a fragment of linear logic is </context>
</contexts>
<marker>Morrill, 1995</marker>
<rawString>Glyn Morrill. 1995. `Higher-order Linear Logic Programming of Categorial Deduction.&apos; Proc. of EACL-7, Dublin.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>