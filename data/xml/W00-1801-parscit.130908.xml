<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000001">
<note confidence="0.455805">
Finite-State Non-Con.caten.ative Morphotactics
Kenneth R. Beesley and Lauri Karttunen
</note>
<keyword confidence="0.357469">
beesleyOxrce.xerox.com, karttunenOxrce.xerox.com
</keyword>
<sectionHeader confidence="0.960987" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9998394375">
Finite-state morphology in the general tradition
of the Two-Level and Xerox implementations
has proved very successful in the production
of robust morphological analyzer-generators, in-
cluding many large-scale commercial systems.
However, it has long been recognized that
these implementations have serious limitations
in handling non-concatenative phenomena. We
describe a new technique for constructing finite-
state transducers that involves reapplying the
regular-expression compiler to its own output.
Implemented in an algorithm called compile-
replace, this technique has proved useful for
handling non-concatenative phenomena; and we
demonstrate it on Malay full-stem reduplication
and Arabic stem interdigitation.
</bodyText>
<sectionHeader confidence="0.995591" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999801894736842">
Most natural languages construct words by con-
catenating morphemes together in strict orders.
Such &amp;quot;concatenative morphotactics&amp;quot; can be im-
pressively productive, especially in agglutina-
tive languages like Aymara (Figure 11) or Turk-
ish, and in agglutinative/polysynthetic lan-
guages like Inuktitut (Figure 2)(Mallon, 1999,
2). In such languages a single word may con-
tain as many morphemes as an average-length
English sentence.
Finite-state morphology in the tradition of
the Two-Level (Koskenniemi, 1983) and Xerox
implementations (Karttunen, 1991; Karttunen,
1994; Beesley and Karttunen, 2000) has been
very successful in implementing large-scale,
robust and efficient morphological analyzer-
generators for concatenative languages, includ-
ing the commercially important European lan-
guages and non-Indo-European examples like
</bodyText>
<footnote confidence="0.754262">
1I wish to thank Stuart Newton for this example.
</footnote>
<bodyText confidence="0.999448888888889">
Finnish, Turkish and Hungarian. However,
Koskenniemi himself understood that his initial
implementation had significant limitations in
handling non-concatenative morphotactic pro-
cesses:
&amp;quot;Only restricted infixation and redu-
plication can be handled adequately
with the present system. Some exten-
sions or revisions will be necessary for
an adequate description of languages
possessing extensive infixation or redu-
plication&amp;quot; (Koskenniemi, 1983, 27).
This limitation has of course not escaped the no-
tice of various reviewers, e.g. Sproat(1992). We
shall argue that the morphotactic limitations of
the traditional implementations are the direct
result of relying solely on the concatenation op-
eration in morphotactic description.
We describe a technique, within the Xerox
implementation of finite-state morphology, that
corrects the limitations at the source, going be-
yond concatenation to allow the full range of
finite-state operations to be used in morphotac-
tic description. Regular-expression descriptions
are compiled into finite-state automata or trans-
ducers (collectively called networks) as usual,
and then the compiler is re-applied to its own
output, producing a modified but still finite-
state network. This technique, implemented
in an algorithm called COMPILE-REPLACE, has
already proved useful for handling Malay full-
stem reduplication and Arabic stem interdigi-
tation, which will be described below. Before
illustrating these applications, we will first out-
line our general approach to finite-state mor-
phology.
</bodyText>
<page confidence="0.943614">
1
</page>
<note confidence="0.9751545">
Lexical: uta+ma+na-ka+p+xa+samacha-i+wa
Surface: uta ma n ka p xa samach i wa
</note>
<equation confidence="0.771210111111111">
uta = house (root)
+ma = 2nd person possessive
+na =in
-ka = (locative, verbalizer)
+p = plural
+xa = perfect aspect
+samacha = &amp;quot;apparently&amp;quot;
= 3rd person
+wa = topic marker
</equation>
<figureCaption confidence="0.993674">
Figure 1: Aymara: utarnankapxasarnachiwa = &amp;quot;it appears that they are in your house&amp;quot;
</figureCaption>
<bodyText confidence="0.82112495">
Lexical: Paris+mut+nngau+juma+niraq+lauq+sima+nngit+junga
Surface: Pari mu nngau juma nira lauq sima nngit tunga
Paris
+mut
+nngau
+juma
+niraq
+lauq
+sima
+nngit
+junga
= (root = Paris)
= terminalis case ending
= go (verbalizer)
= want
= declare (that)
= past
= (added to -lauq- indicates &amp;quot;distant past&amp;quot;)
= negative
= 1st person sing. present indic (nonspecific)
</bodyText>
<figureCaption confidence="0.8555">
Figure 2: Inuktitut: Parirnunngaujurnaniralauqsirnanngittunga = &amp;quot;I never said I wanted to go to
Paris&amp;quot;
</figureCaption>
<sectionHeader confidence="0.963942" genericHeader="introduction">
2 Finite-State Morphology
</sectionHeader>
<subsectionHeader confidence="0.975441">
2.1 Analysis and Generation
</subsectionHeader>
<bodyText confidence="0.999987684210527">
In the most theory- and implementation-neutral
form, morphological analysis and generation of
written words can be modeled as a relation
between the words themselves and analyses of
those words. Computationally, as shown in Fig-
ure 3, a black-box module maps from words to
analyses to effect Analysis, and from analyses
to words to effect Generation.
The basic claim or hope of the finite-state ap-
proach to natural-language morphology is that
relations like that represented in Figure 3 are in
fact regular relations, i.e. relations between two
regular languages. The surface language con-
sists of strings (= words = sequences of sym-
bols) written according to some defined orthog-
raphy. In a commercial application for a natural
language, the surface language to be modeled
is usually a given, e.g. the set of valid French
words as written according to standard French
</bodyText>
<sectionHeader confidence="0.7462775" genericHeader="method">
ANALYSES
ANALYZER/
GENERATOR
WORDS
</sectionHeader>
<figureCaption confidence="0.867091">
Figure 3: Morphological Analysis/Generation
as a Relation between Analyses and Words
</figureCaption>
<bodyText confidence="0.999899625">
orthography. The lexical language again con-
sists of strings, but strings designed according
to the needs and taste of the linguist, represent-
ing analyses of the surface words. It is some-
times convenient to design these lexical strings
to show all the constituent morphemes in their
morphophonemic form, separated and identified
as in Figures 1 and 2. In other applications,
</bodyText>
<page confidence="0.997125">
2
</page>
<figure confidence="0.992955">
Analysis Strings
Regular
Expression
Compiler
Word Strings
</figure>
<figureCaption confidence="0.977398">
Figure 4: Compilation of a Regular Expression into an FST that Maps between Two Regular
Languages
</figureCaption>
<bodyText confidence="0.960884673913044">
it may be useful to design the lexical strings
to contain the traditional dictionary citation
form, together with linguist-selected &amp;quot;tag&amp;quot; sym-
bols like +Noun, +Verb, +SG, +PL, that convey
category, person, number, tense, mood, case,
etc. Thus the lexical string representing paie,
the first-person singular, present indicative form
of the French verb payer (&amp;quot;to pay&amp;quot;), might be
spelled payer+IndP+SG+Pl+Verb. The tag sym-
bols are stored and manipulated just like al-
phabetic symbols, but they have multicharacter
print names.
If the relation is finite-state, then it can be
defined using the metalanguage of regular ex-
pressions; and, with a suitable compiler, the
regular expression source code can be compiled
into a finite-state transducer (FsT), as shown in
Figure 4, that implements the relation compu-
tationally. Following convention, we will often
refer to the upper projection of the FST, repre-
senting analyses, as the LEXICAL language, a set
of lexical strings; and we will refer to the lower
projection as the SURFACE language, consisting
of surface strings. There are compelling advan-
tages to computing with such finite-state ma-
chines, including mathematical elegance, flexi-
bility, and for most natural-language applica-
tions, high efficiency and data-compaction.
One computes with FsTs by applying them,
in either direction, to an input string. When
one such FST that was written for French is ap-
plied in an upward direction to the surface word
inaisons (&amp;quot;houses&amp;quot;), it returns the related string
maison+Fem+PL+Noun, consisting of the citation
form and tag symbols chosen by a linguist to
convey that the surface form is a feminine noun
in the plural form. A single surface string can
be related to multiple lexical strings, e.g. ap-
plying this FST in an upward direction to sur-
face string suis produces the four related lexical
strings shown in Figure 5. Such ambiguity of
surface strings is very common.
etre+IndP+SG+Pl+Verb
suivre+IndP+SG+P2+Verb
suivre+IndP+SG+Pl+Verb
suivre+Imp+SG+P2+Verb
</bodyText>
<figureCaption confidence="0.988703">
Figure 5: Multiple Analyses for suis
</figureCaption>
<bodyText confidence="0.9998285">
Conversely, the very same FST can be applied
in a downward direction to a lexical string like
etre+IndP+SG+Pl+Verb to return the related
surface string suis; such transducers are inher-
ently bidirectional. Ambiguity in the downward
direction is also possible, as in the relation of
the lexical string payer+IndP+SG+Pl+Verb (&amp;quot;I
pay&amp;quot;) to the surface strings paie and pa ye, which
are in fact valid alternate spellings in standard
French orthography.
</bodyText>
<subsectionHeader confidence="0.99717">
2.2 Morphotactics and Alternations
</subsectionHeader>
<bodyText confidence="0.992759">
There are two challenges in modeling natural
language morphology:
</bodyText>
<listItem confidence="0.9995245">
• Morphotactics
• Phonological/Orthographical Alternations
</listItem>
<bodyText confidence="0.977136">
Finite-state morphology models both using
regular expressions. The source descriptions
may also be written in higher-level notations
(e.g. lexc (Karttunen, 1993), twolc (Kart-
tunen and Beesley, 1992) and Replace Rules
(Karttunen, 1995; Karttunen, 1996; Kempe and
Karttunen, 1996)) that are simply helpful short-
hands for regular expressions and that compile,
using their dedicated compilers, into finite-state
</bodyText>
<page confidence="0.988354">
3
</page>
<figure confidence="0.999806777777778">
Lexicon
Regular Expression
Lexicon FST
.o.
Rule FST
Lexical Transducer
(a single FST)
Rule
Regular Expression
i
b
0
4
0 +Comp
+Adj
b
r
i
4
e
0
4
Compiler
*:a
a
0:a
*:0
a:0
*:0
0:^[a * 0:^]
a *
a
Lexical: b a g i +Noun +Plural
Surface: -[ {bagi} - 2 -]
Lexical: p e 1 abuhan +Noun +Plural
Surface: -[{pelabuhan} - 2 -1
</figure>
<figureCaption confidence="0.997871">
Figure 11: Two Paths in the Initial Malay Transducer Defined via Concatenation
</figureCaption>
<bodyText confidence="0.9999253">
In this simple example, the upper language of
the original network in Figure 8 is identical to
the regular expression that is compiled and re-
placed. In the linguistic applications presented
in the next sections, the two sides of a regular-
expression path contain different strings. The
upper side contains morphological information;
the regular-expression operators appear only on
the lower side and are not present in the final
result.
</bodyText>
<subsectionHeader confidence="0.990697">
3.1 Reduplication
</subsectionHeader>
<bodyText confidence="0.991795260273973">
Traditional Two-Level implementations are al-
ready capable of describing some limited
reduplication and infixation as in Tagalog
(Antworth, 1990, 156-162). The more chal-
lenging phenomenon is variable-length redupli-
cation, as found in Malay and the closely related
Indonesian language.
An example of variable-length full-stem redu-
plication occurs with the Malay stem bagi,
which means &amp;quot;bag&amp;quot; or &amp;quot;suitcase&amp;quot;; this form is
in fact number-neutral and can translate as the
plural. Its overt plural is phonologically bag-
ibagi,3 formed by repeating the stem twice in a
row. Although this pluralization process may
appear concatenative, it does not involve con-
catenating a predictable pluralizing morpheme,
but rather copying the preceding stem, what-
ever it may be and however long it may be.
Thus the overt plural of pelabuhan (&amp;quot;port&amp;quot;), it-
self a derived form, is phonologically pelabuhan-
pelabuhan.
Productive reduplication cannot be described
by finite-state or even context-free formalisms.
It is well known that the copy language, {ww
1 w c L}, where each word contains two copies
of the same string, is a context-sensitive lan-
guage. However, if the &amp;quot;base&amp;quot; language L is
finite, we can construct a finite-state network
that encodes L and the reduplications of all the
3In the standard orthography, such reduplicated
words are written with a hyphen, e.g. bag-bag, that
we will ignore for this example.
strings in L. On the assumption that there are
only a finite number of words subject to redu-
plication (no free compounding), it is possible
to construct a lexical transducer for languages
such as Malay. We will show a simple and el-
egant way to do this with strictly finite-state
operations.
To understand the general solution to full-
stem reduplication using the compile-replace al-
gorithm requires a bit of background. In the
regular expression calculus there are several op-
erators that involve concatenation. For exam-
ple, if A is a regular expression denoting a lan-
guage or a relation, A* denotes zero or more and
A+ denotes one or more concatenations of A with
itself. There are also operators that express a
fixed number of concatenations. In the Xerox
calculus, expressions of the form An, where n is
an integer, denote n concatenations of A. {abc}
denotes the concatenation of symbols a, b, and
c. We also employ - [and -] as delimiter sym-
bols around regular-expression substrings.
The reduplication of any string w can then
be notated as {w}-2, and we start by defining
a network where the lower-side strings are built
by simple concatenation of a prefix - C, a root
enclosed in braces, and an overt-plural suffix -2
followed by the closing -1. Figure 11 shows the
paths for two Malay plurals in the initial net-
work.
The compile-replace algorithm, applied to the
lower-side of this network, recognizes each in-
dividual delimited regular-expression substring
like - Hbagi}-2-1, compiles it, and replaces it
with the result of the compilation, here bagi-
bagi. The same process applies to the entire
lower-side language, resulting in a network that
relates pairs of strings such as the ones in Fig-
ure 12. This provides the desired solution, still
finite-state, for analyzing and generating full-
stem reduplication in Malay.4
</bodyText>
<footnote confidence="0.988881">
4It is well-known (McCarthy and Prince, 1995) that
reduplication can be a more complex phenomenon than
</footnote>
<page confidence="0.987327">
6
</page>
<figure confidence="0.7462305">
Lexical:bagi +Noun +Plural
Surface:bagibagi
Lexical:pelabuhan +Noun +Plural
Surface:pelabuhanpelabuhan
</figure>
<figureCaption confidence="0.997881">
Figure 12: The Malay FST After the Application of Compile-Replace to the Lower-Side Language
</figureCaption>
<bodyText confidence="0.816292">
The special delimiters - [ and -] can be
used to surround arty appropriate regular-
expression substring, using arty necessary
regular-expression operators, and compile-
replace may be applied to the lower-side and/or
upper-side of the network as desired. There
is nothing to stop the linguist from inserting
delimiters multiple times, including via compo-
sition, and reapplying compile-replace multiple
times (see the Appendix). The technique im-
plemented in compile-replace is a general way
of allowing the regular-expression compiler to
reapply to and modify its own output.
</bodyText>
<subsectionHeader confidence="0.9961345">
3.2 Semitic Stem Interdigitation
3.2.1 Review of Earlier Work
</subsectionHeader>
<bodyText confidence="0.991527956521739">
Much of the work in non-concatenative finite-
state morphotactics has been dedicated to han-
dling Semitic stem interdigitation. An example
of interdigitation occurs with the Arabic stem
katab, which means &amp;quot;wrote&amp;quot;. According to an
influential autosegmental analysis (McCarthy,
1981), this stem consists of an all-consonant
root ktb whose general meaning has to do with
writing, an abstract consonant-vowel template
CVCVC, and a voweling or vocalization that he
symbolized simply as a, signifying perfect as-
pect and active voice. The root consonants are
associated with the C slots of the template and
the vowel or vowels with the V slots, producing
a complete stem katab. If the root and the vo-
calization are thought of as morphemes, neither
morpheme occurs continuously in the stem. The
same root ktb can combine with the template
CVCVC and a different vocalization ui, signifying
perfect aspect and passive voice, producing the
stem kutib, which means &amp;quot;was written&amp;quot;. Simi-
larly, the root ktb can combine with template
it is in Malay. In some languages only a part of the stem
is reduplicated and there may be systematic differences
between the reduplicate and the base form. We believe
that our approach to reduplication can account for these
complex phenomena as well but we cannot discuss the
issue here due to lack of space.
CVVCVC and ui to produce kuutib, the root drs
can combine with CVCVC and ui to form duris,
and so forth.
Kay (1987) reformalized the autosegmental
tiers of McCarthy (1981) as projections of a
multi-level transducer and wrote a small Prolog-
based prototype that handled the interdigita-
tion of roots, CV-templates and vocalizations
into abstract Arabic stems; this general ap-
proach, with multi-tape transducers, has been
explored and extended by Kiraz in several pa-
pers (1994a; 1996; 1994b; 2000) with respect to
Syriac and Arabic. The implementation is de-
scribed in Kiraz and Grimley-Evans (1999).
In work more directly related to the current
solution, it was Kataja and Koskenniemi (1988)
who first demonstrated that Semitic (Akkadian)
roots and patterns5 could be formalized as reg-
ular languages, and that the non-concatenative
interdigitation of stems could be elegantly for-
malized as the intersection of those regular lan-
guages. Thus Akkadian words were formalized
as consisting of morphemes, some of which were
combined together by intersection and others of
which were combined via concatenation.
This was the key insight: morphotactic de-
scription could employ various finite-state op-
erations, not just concatenation; and languages
that required only concatenation were just spe-
cial cases. By extension, the widely noticed lim-
itations of early finite-state implementations in
dealing with non-concatenative morphotactics
could be traced to their dependence on the con-
catenation operation in morphotactic descrip-
tions.
This insight of Kataja and Koskenniemi was
applied by Beesley in a large-scale morphologi-
cal analyzer for Arabic, first using an implemen-
tation that simulated the intersection of stems
in code at runtime (Beesley, 1989; Beesley et
al., 1989; Beesley, 1990; Beesley, 1991), and ran
</bodyText>
<footnote confidence="0.9923945">
5These patterns combine what McCarthy (1981)
would call templates and vocalizations.
</footnote>
<page confidence="0.999057">
7
</page>
<bodyText confidence="0.999958851851852">
rather slowly; and later, using Xerox finite-state
technology (Beesley, 1996; Beesley, 1998a), a
new implementation that intersected the stems
at compile time and performed well at runtime.
The 1996 algorithm that intersected roots and
patterns into stems, and substituted the original
roots and patterns on just the lower side with
the intersected stem, was admittedly rather ad
hoc and computationally intensive, taking over
two hours to handle about 90,000 stems on a
SUN Ultra workstation. The compile-replace
algorithm is a vast improvement in both gener-
ality and efficiency, producing the same result
in a few minutes.
Following the lines of Kataja and Kosken-
niemi (1988), we could define intermediate net-
works with regular-expression substrings that
indicate the intersection of suitably encoded
roots, templates, and vocalizations (for a for-
mal description of what such regular-expression
substrings would look like, see Beesley (1998c;
1998b)). However, the general-purpose inter-
section algorithm would be expensive in arty
non-trivial application, and the interdigitation
of stems represents a special case of intersection
that we achieve in practice by a much more ef-
ficient finite-state algorithm called MERGE.
</bodyText>
<subsectionHeader confidence="0.44589">
3.2.2 Merge
</subsectionHeader>
<bodyText confidence="0.999707742857143">
The merge algorithm is a pattern-filling oper-
ation that combines two regular languages, a
template and a filler, into a single one. The
strings of the filler language consist of ordinary
symbols such as d, r, s, u, i. The template
expressions may contain special class symbols
such as C (= consonant) or V (= vowel) that
represent a predefined set of ordinary symbols.
The objective of the merge operation is to align
the template strings with the filler strings and
to instantiate the class symbols of the template
as the matching filler symbols.
Like intersection, the merge algorithm oper-
ates by following two paths, one in the template
network, the other in the filler network, and it
constructs the corresponding single path in the
result network. Every state in the result corre-
sponds to two original states, one in template,
the other in the filler. If the original states are
both final, the resulting state is also final; oth-
erwise it is non-final. In other words, in order to
construct a successful path, the algorithm must
reach a final state in both of the original net-
works. If the new path terminates in a non-final
state, it represents a failure and will eventually
be pruned out.
The operation starts in the initial state of the
original networks. At each point, the algorithm
tries to find all the successful matches between
the template arcs and filler arcs. A match is
successful if the filler arc symbol is included in
the class designated by the template arc sym-
bol. The main difference between merge and
classical intersection is in Conditions 1 and 2
below:
</bodyText>
<listItem confidence="0.846579272727273">
1. If a successful match is found, a new arc is
added to the current result state. The arc
is labeled with the filler arc symbol; its des-
tination is the result state that corresponds
to the two original destinations.
2. If no successful match is found for a given
template arc, the arc is copied into the cur-
rent result state. Its destination is the re-
sult state that corresponds to the destina-
tion of the template arc and the current
filler state.
</listItem>
<bodyText confidence="0.917148636363636">
In effect, Condition 2 preserves any template
arc that does not find a match. In that case,
the path in the template network advances to
a new state while the path in the filler network
stays at the current state.
We use the networks in Figure 13 to illustrate
the effect of the merge algorithm. Figure 13
shows a linear template network and two filler
networks, one of which is cyclic.
o c -o -o v -o -.o C
o±-o s -o CO o
</bodyText>
<figureCaption confidence="0.820684">
Figure 13: A Template Network and Two Filler
Networks
</figureCaption>
<bodyText confidence="0.9991998">
It is easy to see that the merge of the drs
network with the template network yields the
result shown in Figure 14. The three symbols
of the filler string are instantiated in the three
consonant slots in the CVVCVC template.
</bodyText>
<figure confidence="0.517052">
0 d oVipi or....0_,..7 0 s
</figure>
<figureCaption confidence="0.992393">
Figure 14: Intermediate Result.
</figureCaption>
<page confidence="0.878038">
8
</page>
<figure confidence="0.9899495">
Lexical: k t b =Root CVCVC =Template a + =Voc
Surface: -[ktb .m&gt;.CVCVC .&lt;m. a+ -]
Lexical: k t b =Root CVCVC =Template u * i =Voc
Surface: -[ktb .m&gt;.CVCVC .&lt;m. u*i -]
Lexical: d r s =Root CVVCVC =Template u * i =Voc
Surface: -[drs .m&gt;.CVVCVC .&lt;m. u* i -]
</figure>
<figureCaption confidence="0.912779">
Figure 16: Initial paths
</figureCaption>
<figure confidence="0.95718">
d
u 1 r s
</figure>
<figureCaption confidence="0.782701">
Figure 15: Final Result
Figure 15 presents the final result in which
the second filler network in Figure 13 is merged
with the intermediate result shown in Figure 14.
</figureCaption>
<bodyText confidence="0.999930975">
In this case, the filler language contains an in-
finite set of strings, but only one successful path
can be constructed. Because the filler string
ends with a single i, the first two V symbols
can be instantiated only as u. Note that ordi-
nary symbols in the partially filled template are
treated like the class symbols that do not find a
match. That is, they are copied into the result
in their current position without consuming a
filler symbol.
To introduce the merge operation into the
Xerox regular expression calculus we need to
choose an operator symbol. Because merge, like
subtraction, is a non-commutative operation,
we also must distinguish between the template
and the filler. For example, we could choose .m.
as the operator and decide by convention which
of the two operands plays which role in expres-
sions such as [A .m. B]. What we actually have
done, perhaps without a sufficiently good moti-
vation, is to introduce two variants of the merge
operator, .&lt;m. and .m&gt;., that differ only with
respect to whether the template is to the left
( . &lt;m.) or to the right ( .m&gt; .) of the the filler.
The expression [A .&lt;m. B] represents the same
merge operation as [B .m&gt;. A]. In both cases,
A denotes the template, B denotes the filler, and
the result is the same. With these new opera-
tors, the network in Figure 15 can be compiled
from an expression such as
drs.m&gt;.CVVCVC.&lt;m.u*i
As we have defined them, .&lt;m. and .m&gt;. are
weakly binding left-associative operators. In
this example, the first merge instantiates the
filler consonants, the second operation fills the
vowel slots. However, the order in which the
merge operations are performed is irrelevant in
this case because the two filler languages do not
provide competing instantiations for the same
class symbols.
</bodyText>
<subsectionHeader confidence="0.8838875">
3.2.3 Merging Roots and Vocalizations
with Templates
</subsectionHeader>
<bodyText confidence="0.999406935483871">
Following the tradition, we can represent the
lexical forms of Arabic stems as consisting of
three components, a consonantal root, a CV tem-
plate and a vocalization, possibly preceded and
followed by additional affixes. In contrast to
McCarthy, Kay, and Kiraz, we combine the
three components into a single projection. In a
sense, McCarthy&apos;s three tiers are conflated into
a single one with three distinct parts. In our
opinion, there is no substantive difference from
a computational point of view.
For example, the initial lexical representation
of the surface forms katab, kutib, and duuris,
may be represented as a concatenation of the
three components shown in Figure 16. We use
the symbols =Root, =Template, and =Voc to
designate the three components of the lexical
form. The corresponding initial surface form is
a regular-expression substring, containing two
merge operators, that will be compiled and re-
placed by the interdigitated surface form.
The application of the compile-replace opera-
tion to the lower side of the initial lexicon yields
a transducer that maps the Arabic interdigi-
tated forms directly into their corresponding tri-
partite analyses and vice versa, as illustrated in
Figure 17.
Alternation rules are subsequently composed
on the lower side of the result to map the in-
terdigitated, but still morphophonemic, strings
into real surface strings.
</bodyText>
<page confidence="0.977428">
9
</page>
<figure confidence="0.9909445">
Lexical: k t b
Surface:
Lexical: k t b
Surface:
Lexical: d r s
Surface:
=Root CVCVC =Template a + =Voc
katab
=Root CVCVC =Template u * i =Voc
kutib
=Root CVVCVC =Template u * i =Voc
duuris
</figure>
<figureCaption confidence="0.999334">
Figure 17: After Applying Compile-Replace to the Lower Side
</figureCaption>
<bodyText confidence="0.9973058">
Although many Arabic templates are widely
considered to be pure CV-patterns, it has
been argued that certain templates also contain
&amp;quot;hard-wired&amp;quot; specific vowels and consonants.&apos;
For example, the so-called &amp;quot;FormVIII&amp;quot; template
is considered, by some linguists, to contain an
embedded t: CtVCVC.
The presence of ordinary symbols in the tem-
plate does not pose arty problem for the anal-
ysis adopted here. As we already mentioned
in discussing the intermediate representation in
Figure 14, the merge operation treats ordinary
symbols in a partially filled template in the
same manner as it treats unmatched class sym-
bols. The merge of a root such as ktb with the
presumed FormVIII template and the a+ vocal-
ism,
ktb.m&gt;.CtVCVC.&lt;m.a+
produces the desired result, ktatab, without
arty additional mechanism.
</bodyText>
<sectionHeader confidence="0.701552" genericHeader="method">
4 Status of the Implementations
</sectionHeader>
<subsectionHeader confidence="0.911759">
4.1 Malay Morphological
Analyzer/Generator
</subsectionHeader>
<bodyText confidence="0.9999365">
Malay and Indonesian are closely-related lan-
guages characterized by rich derivation and
little or nothing that could be called inflec-
tion. The Malay morphological analyzer pro-
totype, written using lexc, Replace Rules, and
compile-replace, implements approximately 50
different derivational processes, including pre-
fixation, suffixation, prefix-suffix pairs (circum-
fixation), reduplication, some infixation, and
combinations of these processes. Each root is
marked manually in the source dictionary to in-
dicate the idiosyncratic subset of derivational
processes that it undergoes.
The small prototype dictionary, stored in
an XML format, contains approximately 1000
roots, with about 1500 derivational subentries
(i.e. an average of 1.5 derivational processes
per root). At compile time, the XML dictio-
nary is parsed and &amp;quot;downtranslated&amp;quot; into the
source format required for the lexc compiler.
The XML dictionary could be expanded by arty
competent Malay lexicographer.
</bodyText>
<subsectionHeader confidence="0.8310805">
4.2 Arabic Morphological
Analyzer/Generator
</subsectionHeader>
<bodyText confidence="0.999894375">
The current Arabic system has been described
in some detail in previous publications (Beesley,
1996; Beesley, 1998a; Beesley, 1998b) and is
available for testing on the Internet.7 The modi-
fication of the system to use the compile-replace
algorithm has not changed the size or the behav-
ior of the system in arty way, but it has reduced
the compilation time from hours to minutes.
</bodyText>
<sectionHeader confidence="0.997303" genericHeader="evaluation">
5 Conclusion
</sectionHeader>
<bodyText confidence="0.999970777777778">
The well-founded criticism of traditional imple-
mentations of finite-state morphology, that they
are limited to handling concatenative morpho-
tactics, is a direct result of their dependence
on the concatenation operation in morphotactic
description. The technique described here, im-
plemented in the compile-replace algorithm, al-
lows the regular-expression compiler to reapply
to and modify its own output, effectively freeing
morphotactic description to use arty finite-state
operation. Significant experiments with Malay
and a much larger application in Arabic have
shown the value of this technique in handling
two classic examples of non-concatenative mor-
photactics: full-stem reduplication and Semitic
stem interdigitation. Work remains to be done
in applying the technique to other known vari-
eties of non-concatenative morphotactics.
</bodyText>
<footnote confidence="0.9649515">
6See Beesley (1998c) for a discussion of this contro-
versial issue. 7 http://www.xrce.xerox.com/research/mlit/arabic/
</footnote>
<page confidence="0.997946">
10
</page>
<bodyText confidence="0.998928428571428">
The compile-replace algorithm and the merge
operator introduced in this paper are general
techniques not limited to handling the specific
morphotactic problems we have discussed. We
expect that they will have many other useful
applications. One illustration is given in the
Appendix.
</bodyText>
<sectionHeader confidence="0.978979" genericHeader="conclusions">
6 Appendix: Palindrome Extraction
</sectionHeader>
<bodyText confidence="0.9998338125">
To demonstrate the power of the compile-
replace method, let us show how it cart be ap-
plied to solve another &amp;quot;hard&amp;quot; problem: identi-
fying and extracting all the palindromes from a
lexicon. Like reduplication, palindrome identifi-
cation appears at first to require more powerful
tools than a finite-state calculus. But this task
cart be accomplished, in fact quite efficiently, by
using the compile-replace technique.
Let us assume that L is a simple network con-
structed from art English wordlist. We start by
extracting from L all the words with a property
that is necessary but not sufficient for being a
palindrome, namely, the words whose inverse is
also art English word. This step cart be accom-
plished by redefining L as &amp; L .r] where &amp;
represents intersection and .r is the reverse op-
erator. The resulting network contains palin-
dromes such as madam as well non-palindromes
such as dog and god.
The remaining task is to eliminate all the
words like dog that are not identical to their
own inverse. This cart be done in three
steps. We first apply the technique used for
Malay reduplication. That is, we redefine L
as &amp;quot;- C&amp;quot; &amp;quot; C&amp;quot; L XX &amp;quot;1&amp;quot; 11-11 2 &apos;1&amp;quot;, and apply
the compile-replace operation. At this point
the lower-side of L contains strings such as
dogXXdogXX and madamXXmadamXX where XX is
a specially introduced symbol to mark the mid-
dle (and the end) of each string.
The next, and somewhat delicate, step is to
replace the XX markers by the desired opera-
tors, intersection and reverse, and to wrap the
special regular expression delimiters - and -1
around the whole lexicon. This cart be done by
composing L with one or several replace trans-
ducers to yield a network consisting of expres-
sions such as -Edo g&amp; Ed o g] .r -1 and
-Emadam&amp; [madam].r
In the third and final step, the application
of compile-replace eliminates words like dog
because the intersection of dog with the in-
verted form god is empty. Only the palin-
dromes survive the operation. The extrac-
tion of all the palindromes from the 25K Unix
/usr/dict/words file by this method takes a cou-
ple of seconds.
</bodyText>
<sectionHeader confidence="0.993952" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.994263186046512">
Evart L. Antworth. 1990. PC-KIMMO: a two-
level processor for morphological analysis.
Number 16 in Occasional publications in aca-
demic computing. Summer Institute of Lin-
guistics, Dallas.
Kenneth R. Beesley and Lauri Karttunen.
2000. Finite-State Morphology: Xerox Tools
and Techniques. Cambridge University Press.
Forthcoming.
Kenneth R. Beesley, Tim Buckwalter, and Stu-
art N. Newton. 1989. Two-level finite-state
analysis of Arabic morphology. In Proceed-
ings of the Seminar on Bilingual Computing
in Arabic and English, Cambridge, England,
September 6-7. No pagination.
Kenneth R. Beesley. 1989. Computer analysis
of Arabic morphology: A two-level approach
with detours. In Third Annual Symposium on
Arabic Linguistics, Salt Lake City, March 3-
4. University of Utah. Published as Beesley,
1991.
Kenneth R. Beesley. 1990. Finite-state de-
scription of Arabic morphology. In Proceed-
ings of the Second Cambridge Conference on
Bilingual Computing in Arabic and English,
September 5-7. No pagination.
Kenneth R. Beesley. 1991. Computer analy-
sis of Arabic morphology: A two-level ap-
proach with detours. In Bernard Comrie and
Mushira Eid, editors, Perspectives on Arabic
Linguistics III: Papers from the Third An-
nual Symposium on Arabic Linguistics, pages
155-172. John Benjamins, Amsterdam. Read
originally at the Third Annual Symposium ort
Arabic Linguistics, University of Utah, Salt
Lake City, Utah, 3-4 March 1989.
Kenneth R. Beesley. 1996. Arabic finite-state
morphological analysis and generation. In
COLING&apos;96, volume 1, pages 89-94, Copen-
hagen, August 5-9. Center for Sprogteknologi.
The 16th International Conference ort Com-
putational Linguistics.
Kenneth R. Beesley. 1998a. Arabic morphologi-
</reference>
<page confidence="0.989893">
11
</page>
<reference confidence="0.999706485148515">
cal analysis on the Internet. In ICEMC0-98,
Cambridge, April 17-18. Centre for Middle
Eastern Studies. Proceedings of the 6th Inter-
national Conference and Exhibition on Multi-
lingual Computing. Paper number 3.1.1; no
pagination.
Kenneth R. Beesley. 1998b. Arabic morphology
using only finite-state operations. In Michael
Rosner, editor, Computational Approaches to
Semitic Languages: Proceedings of the Work-
shop, pages 50-57, Montreal, Quebec, Au-
gust 16. Universite de Montreal.
Kenneth R. Beesley. 1998c. Arabic stem mor-
photactics via finite-state intersection. Paper
presented at the 12th Symposium on Ara-
bic Linguistics, Arabic Linguistic Society, 6-7
March, 1998, Champaign, IL.
Lauri Karttunen and Kenneth R. Beesley. 1992.
Two-level rule compiler. Technical Report
ISTL-92-2, Xerox Palo Alto Research Center,
Palo Alto, CA, October.
Lauri Karttunen, Ronald M. Kaplan, and Annie
Zaenen. 1992. Two-level morphology with
composition. In COLING&apos;92, pages 141-148,
Nantes, France, August 23-28.
Lauri Karttunen. 1991. Finite-state con-
straints. In Proceedings of the Interna-
tional Conference on Current Issues in Com-
putational Linguistics, Penang, Malaysia,
June 10-14. Universiti Sains Malaysia.
Lauri Karttunen. 1993. Finite-state lexicon
compiler. Technical Report ISTL-NLTT-
1993-04-02, Xerox Palo Alto Research Center,
Palo Alto, CA, April.
Lauri Karttunen. 1994. Constructing lexical
transducers. In COLING&apos;94, Kyoto, Japan.
Lauri Karttunen. 1995. The replace oper-
ator. In ACL&apos;95, Cambridge, MA. cmp-
lg/9504032.
Lauri Karttunen. 1996. Directed replace-
ment. In ACL&apos;96, Santa Cruz, CA. cmp-
lg/9606029.
Laura Kataja and Kimmo Koskenniemi. 1988.
Finite-state description of Semitic morphol-
ogy: A case study of Ancient Akkadian. In
COLING&apos;88, pages 313-315.
Martin Kay. 1987. Nonconcatenative finite-
state morphology. In Proceedings of the Third
Conference of the European Chapter of the
Association for Computational Linguistics,
pages 2-10.
Andre Kempe and Lauri Karttunen. 1996. Par-
allel replacement in finite-state calculus. In
COLING&apos;96, Copenhagen, August 5-9. cmp-
lg/9607007.
George Anton Kiraz and Edmund Grimley-
Evans. 1999. Multi-tape automata for speech
and language systems: A Prolog implemen-
tation. In Jean-Marc Champarnaud, De-
nis Maurel, and Djellout Ziadi, editors, Au-
tomata Implementation, volume 1660 of Lec-
ture Notes in Computer Science. Springer
Verlag, Berlin, Germany.
George Anton Kiraz. 1994a. Multi-tape two-
level morphology: a case study in Semitic
non-linear morphology. In COLING &apos;9, vol-
ume 1, pages 180-186.
George Anton Kiraz. 1994b. Multi-tape two-
level morphology: a case study in Semitic
non-linear morphology. In Proceedings of the
15th International Conference on Computa-
tional Linguistics, Kyoto, Japan.
George Anton Kiraz. 1996. Semhe: A gener-
alised two-level system. In Proceedings of the
34th Annual Meeting of the Association of
Computational Linguistics, Santa Cruz, CA.
George Anton Kiraz. 2000. Multi-tiered non-
linear morphology: A case study on Semitic.
Computational Linguistics, 26(1).
Kimmo Koskenniemi. 1983. Two-level mor-
phology: A general computational model for
word-form recognition and production. Pub-
lication 11, University of Helsinki, Depart-
ment of General Linguistics, Helsinki.
Alon Lavie, Alon Itai, Uzzi Ornan, and Mori Ri-
mon. 1988. On the applicability of two level
morphology to the inflection of Hebrew verbs.
In Proceedings of ALLC HI, pages 246-260.
Mick Mallon. 1999. Inuktitut linguistics
for technocrats. Technical report, Ittuku-
luuk Language Programs, Icialuit, Nunavut,
Canada.
John J. McCarthy and Alan Prince. 1995.
Faithfulness and reduplicative identity. Oc-
casional papers in Linguistics 18, University
of Massachusetts, Amherst, MA. ROA-60.
John J. McCarthy. 1981. A prosodic theory of
nonconcatenative morphology. Linguistic In-
quiry, 12(3):373-418.
Richard Sproat. 1992. Morphology and Compu-
tation. MIT Press, Cambridge, MA.
</reference>
<page confidence="0.998461">
12
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.975385">
<title confidence="0.999393">Finite-State Non-Con.caten.ative Morphotactics</title>
<author confidence="0.998879">Kenneth R Beesley</author>
<author confidence="0.998879">Lauri</author>
<email confidence="0.999522">beesleyOxrce.xerox.com,karttunenOxrce.xerox.com</email>
<abstract confidence="0.998655294117647">Finite-state morphology in the general tradition of the Two-Level and Xerox implementations has proved very successful in the production of robust morphological analyzer-generators, including many large-scale commercial systems. However, it has long been recognized that these implementations have serious limitations in handling non-concatenative phenomena. We describe a new technique for constructing finitestate transducers that involves reapplying the regular-expression compiler to its own output. Implemented in an algorithm called compilereplace, this technique has proved useful for handling non-concatenative phenomena; and we demonstrate it on Malay full-stem reduplication and Arabic stem interdigitation.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Evart L Antworth</author>
</authors>
<title>PC-KIMMO: a twolevel processor for morphological analysis.</title>
<date>1990</date>
<journal>Number</journal>
<booktitle>in Occasional publications in academic computing. Summer Institute of Linguistics,</booktitle>
<volume>16</volume>
<location>Dallas.</location>
<contexts>
<context position="9688" citStr="Antworth, 1990" startWordPosition="1437" endWordPosition="1438">ia Concatenation In this simple example, the upper language of the original network in Figure 8 is identical to the regular expression that is compiled and replaced. In the linguistic applications presented in the next sections, the two sides of a regularexpression path contain different strings. The upper side contains morphological information; the regular-expression operators appear only on the lower side and are not present in the final result. 3.1 Reduplication Traditional Two-Level implementations are already capable of describing some limited reduplication and infixation as in Tagalog (Antworth, 1990, 156-162). The more challenging phenomenon is variable-length reduplication, as found in Malay and the closely related Indonesian language. An example of variable-length full-stem reduplication occurs with the Malay stem bagi, which means &amp;quot;bag&amp;quot; or &amp;quot;suitcase&amp;quot;; this form is in fact number-neutral and can translate as the plural. Its overt plural is phonologically bagibagi,3 formed by repeating the stem twice in a row. Although this pluralization process may appear concatenative, it does not involve concatenating a predictable pluralizing morpheme, but rather copying the preceding stem, whatever</context>
</contexts>
<marker>Antworth, 1990</marker>
<rawString>Evart L. Antworth. 1990. PC-KIMMO: a twolevel processor for morphological analysis. Number 16 in Occasional publications in academic computing. Summer Institute of Linguistics, Dallas.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth R Beesley</author>
<author>Lauri Karttunen</author>
</authors>
<title>Finite-State Morphology: Xerox Tools and Techniques.</title>
<date>2000</date>
<publisher>Cambridge University Press. Forthcoming.</publisher>
<contexts>
<context position="1468" citStr="Beesley and Karttunen, 2000" startWordPosition="185" endWordPosition="188">stem interdigitation. 1 Introduction Most natural languages construct words by concatenating morphemes together in strict orders. Such &amp;quot;concatenative morphotactics&amp;quot; can be impressively productive, especially in agglutinative languages like Aymara (Figure 11) or Turkish, and in agglutinative/polysynthetic languages like Inuktitut (Figure 2)(Mallon, 1999, 2). In such languages a single word may contain as many morphemes as an average-length English sentence. Finite-state morphology in the tradition of the Two-Level (Koskenniemi, 1983) and Xerox implementations (Karttunen, 1991; Karttunen, 1994; Beesley and Karttunen, 2000) has been very successful in implementing large-scale, robust and efficient morphological analyzergenerators for concatenative languages, including the commercially important European languages and non-Indo-European examples like 1I wish to thank Stuart Newton for this example. Finnish, Turkish and Hungarian. However, Koskenniemi himself understood that his initial implementation had significant limitations in handling non-concatenative morphotactic processes: &amp;quot;Only restricted infixation and reduplication can be handled adequately with the present system. Some extensions or revisions will be n</context>
</contexts>
<marker>Beesley, Karttunen, 2000</marker>
<rawString>Kenneth R. Beesley and Lauri Karttunen. 2000. Finite-State Morphology: Xerox Tools and Techniques. Cambridge University Press. Forthcoming.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth R Beesley</author>
<author>Tim Buckwalter</author>
<author>Stuart N Newton</author>
</authors>
<title>Two-level finite-state analysis of Arabic morphology.</title>
<date>1989</date>
<booktitle>In Proceedings of the Seminar on Bilingual Computing in Arabic and English,</booktitle>
<location>Cambridge, England,</location>
<note>No pagination.</note>
<contexts>
<context position="16784" citStr="Beesley et al., 1989" startWordPosition="2558" endWordPosition="2561">scription could employ various finite-state operations, not just concatenation; and languages that required only concatenation were just special cases. By extension, the widely noticed limitations of early finite-state implementations in dealing with non-concatenative morphotactics could be traced to their dependence on the concatenation operation in morphotactic descriptions. This insight of Kataja and Koskenniemi was applied by Beesley in a large-scale morphological analyzer for Arabic, first using an implementation that simulated the intersection of stems in code at runtime (Beesley, 1989; Beesley et al., 1989; Beesley, 1990; Beesley, 1991), and ran 5These patterns combine what McCarthy (1981) would call templates and vocalizations. 7 rather slowly; and later, using Xerox finite-state technology (Beesley, 1996; Beesley, 1998a), a new implementation that intersected the stems at compile time and performed well at runtime. The 1996 algorithm that intersected roots and patterns into stems, and substituted the original roots and patterns on just the lower side with the intersected stem, was admittedly rather ad hoc and computationally intensive, taking over two hours to handle about 90,000 stems on a S</context>
</contexts>
<marker>Beesley, Buckwalter, Newton, 1989</marker>
<rawString>Kenneth R. Beesley, Tim Buckwalter, and Stuart N. Newton. 1989. Two-level finite-state analysis of Arabic morphology. In Proceedings of the Seminar on Bilingual Computing in Arabic and English, Cambridge, England, September 6-7. No pagination.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth R Beesley</author>
</authors>
<title>Computer analysis of Arabic morphology: A two-level approach with detours.</title>
<date>1989</date>
<booktitle>In Third Annual Symposium on Arabic Linguistics,</booktitle>
<institution>University of Utah.</institution>
<location>Salt Lake City,</location>
<note>Published as Beesley,</note>
<contexts>
<context position="16762" citStr="Beesley, 1989" startWordPosition="2556" endWordPosition="2557">morphotactic description could employ various finite-state operations, not just concatenation; and languages that required only concatenation were just special cases. By extension, the widely noticed limitations of early finite-state implementations in dealing with non-concatenative morphotactics could be traced to their dependence on the concatenation operation in morphotactic descriptions. This insight of Kataja and Koskenniemi was applied by Beesley in a large-scale morphological analyzer for Arabic, first using an implementation that simulated the intersection of stems in code at runtime (Beesley, 1989; Beesley et al., 1989; Beesley, 1990; Beesley, 1991), and ran 5These patterns combine what McCarthy (1981) would call templates and vocalizations. 7 rather slowly; and later, using Xerox finite-state technology (Beesley, 1996; Beesley, 1998a), a new implementation that intersected the stems at compile time and performed well at runtime. The 1996 algorithm that intersected roots and patterns into stems, and substituted the original roots and patterns on just the lower side with the intersected stem, was admittedly rather ad hoc and computationally intensive, taking over two hours to handle abo</context>
</contexts>
<marker>Beesley, 1989</marker>
<rawString>Kenneth R. Beesley. 1989. Computer analysis of Arabic morphology: A two-level approach with detours. In Third Annual Symposium on Arabic Linguistics, Salt Lake City, March 3-4. University of Utah. Published as Beesley, 1991.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth R Beesley</author>
</authors>
<title>Finite-state description of Arabic morphology.</title>
<date>1990</date>
<booktitle>In Proceedings of the Second Cambridge Conference on Bilingual Computing in Arabic and English,</booktitle>
<note>No pagination.</note>
<contexts>
<context position="16799" citStr="Beesley, 1990" startWordPosition="2562" endWordPosition="2563"> various finite-state operations, not just concatenation; and languages that required only concatenation were just special cases. By extension, the widely noticed limitations of early finite-state implementations in dealing with non-concatenative morphotactics could be traced to their dependence on the concatenation operation in morphotactic descriptions. This insight of Kataja and Koskenniemi was applied by Beesley in a large-scale morphological analyzer for Arabic, first using an implementation that simulated the intersection of stems in code at runtime (Beesley, 1989; Beesley et al., 1989; Beesley, 1990; Beesley, 1991), and ran 5These patterns combine what McCarthy (1981) would call templates and vocalizations. 7 rather slowly; and later, using Xerox finite-state technology (Beesley, 1996; Beesley, 1998a), a new implementation that intersected the stems at compile time and performed well at runtime. The 1996 algorithm that intersected roots and patterns into stems, and substituted the original roots and patterns on just the lower side with the intersected stem, was admittedly rather ad hoc and computationally intensive, taking over two hours to handle about 90,000 stems on a SUN Ultra workst</context>
</contexts>
<marker>Beesley, 1990</marker>
<rawString>Kenneth R. Beesley. 1990. Finite-state description of Arabic morphology. In Proceedings of the Second Cambridge Conference on Bilingual Computing in Arabic and English, September 5-7. No pagination.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Kenneth R Beesley</author>
</authors>
<title>Computer analysis of Arabic morphology: A two-level approach with detours.</title>
<date>1991</date>
<booktitle>Perspectives on Arabic Linguistics III: Papers from the Third Annual Symposium on Arabic Linguistics,</booktitle>
<pages>155--172</pages>
<editor>In Bernard Comrie and Mushira Eid, editors,</editor>
<publisher>John Benjamins,</publisher>
<institution>University of Utah,</institution>
<location>Amsterdam.</location>
<contexts>
<context position="16815" citStr="Beesley, 1991" startWordPosition="2564" endWordPosition="2565">-state operations, not just concatenation; and languages that required only concatenation were just special cases. By extension, the widely noticed limitations of early finite-state implementations in dealing with non-concatenative morphotactics could be traced to their dependence on the concatenation operation in morphotactic descriptions. This insight of Kataja and Koskenniemi was applied by Beesley in a large-scale morphological analyzer for Arabic, first using an implementation that simulated the intersection of stems in code at runtime (Beesley, 1989; Beesley et al., 1989; Beesley, 1990; Beesley, 1991), and ran 5These patterns combine what McCarthy (1981) would call templates and vocalizations. 7 rather slowly; and later, using Xerox finite-state technology (Beesley, 1996; Beesley, 1998a), a new implementation that intersected the stems at compile time and performed well at runtime. The 1996 algorithm that intersected roots and patterns into stems, and substituted the original roots and patterns on just the lower side with the intersected stem, was admittedly rather ad hoc and computationally intensive, taking over two hours to handle about 90,000 stems on a SUN Ultra workstation. The compi</context>
</contexts>
<marker>Beesley, 1991</marker>
<rawString>Kenneth R. Beesley. 1991. Computer analysis of Arabic morphology: A two-level approach with detours. In Bernard Comrie and Mushira Eid, editors, Perspectives on Arabic Linguistics III: Papers from the Third Annual Symposium on Arabic Linguistics, pages 155-172. John Benjamins, Amsterdam. Read originally at the Third Annual Symposium ort Arabic Linguistics, University of Utah, Salt Lake City, Utah, 3-4 March 1989.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth R Beesley</author>
</authors>
<title>Arabic finite-state morphological analysis and generation.</title>
<date>1996</date>
<booktitle>In COLING&apos;96,</booktitle>
<volume>1</volume>
<pages>89--94</pages>
<location>Copenhagen,</location>
<contexts>
<context position="16988" citStr="Beesley, 1996" startWordPosition="2588" endWordPosition="2589">e-state implementations in dealing with non-concatenative morphotactics could be traced to their dependence on the concatenation operation in morphotactic descriptions. This insight of Kataja and Koskenniemi was applied by Beesley in a large-scale morphological analyzer for Arabic, first using an implementation that simulated the intersection of stems in code at runtime (Beesley, 1989; Beesley et al., 1989; Beesley, 1990; Beesley, 1991), and ran 5These patterns combine what McCarthy (1981) would call templates and vocalizations. 7 rather slowly; and later, using Xerox finite-state technology (Beesley, 1996; Beesley, 1998a), a new implementation that intersected the stems at compile time and performed well at runtime. The 1996 algorithm that intersected roots and patterns into stems, and substituted the original roots and patterns on just the lower side with the intersected stem, was admittedly rather ad hoc and computationally intensive, taking over two hours to handle about 90,000 stems on a SUN Ultra workstation. The compile-replace algorithm is a vast improvement in both generality and efficiency, producing the same result in a few minutes. Following the lines of Kataja and Koskenniemi (1988</context>
<context position="26827" citStr="Beesley, 1996" startWordPosition="4215" endWordPosition="4216">to indicate the idiosyncratic subset of derivational processes that it undergoes. The small prototype dictionary, stored in an XML format, contains approximately 1000 roots, with about 1500 derivational subentries (i.e. an average of 1.5 derivational processes per root). At compile time, the XML dictionary is parsed and &amp;quot;downtranslated&amp;quot; into the source format required for the lexc compiler. The XML dictionary could be expanded by arty competent Malay lexicographer. 4.2 Arabic Morphological Analyzer/Generator The current Arabic system has been described in some detail in previous publications (Beesley, 1996; Beesley, 1998a; Beesley, 1998b) and is available for testing on the Internet.7 The modification of the system to use the compile-replace algorithm has not changed the size or the behavior of the system in arty way, but it has reduced the compilation time from hours to minutes. 5 Conclusion The well-founded criticism of traditional implementations of finite-state morphology, that they are limited to handling concatenative morphotactics, is a direct result of their dependence on the concatenation operation in morphotactic description. The technique described here, implemented in the compile-re</context>
</contexts>
<marker>Beesley, 1996</marker>
<rawString>Kenneth R. Beesley. 1996. Arabic finite-state morphological analysis and generation. In COLING&apos;96, volume 1, pages 89-94, Copenhagen, August 5-9. Center for Sprogteknologi. The 16th International Conference ort Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth R Beesley</author>
</authors>
<title>Arabic morphological analysis on the Internet. In ICEMC0-98,</title>
<date>1998</date>
<booktitle>Proceedings of the 6th International Conference and Exhibition on Multilingual Computing. Paper</booktitle>
<location>Cambridge,</location>
<contexts>
<context position="17003" citStr="Beesley, 1998" startWordPosition="2590" endWordPosition="2591">ntations in dealing with non-concatenative morphotactics could be traced to their dependence on the concatenation operation in morphotactic descriptions. This insight of Kataja and Koskenniemi was applied by Beesley in a large-scale morphological analyzer for Arabic, first using an implementation that simulated the intersection of stems in code at runtime (Beesley, 1989; Beesley et al., 1989; Beesley, 1990; Beesley, 1991), and ran 5These patterns combine what McCarthy (1981) would call templates and vocalizations. 7 rather slowly; and later, using Xerox finite-state technology (Beesley, 1996; Beesley, 1998a), a new implementation that intersected the stems at compile time and performed well at runtime. The 1996 algorithm that intersected roots and patterns into stems, and substituted the original roots and patterns on just the lower side with the intersected stem, was admittedly rather ad hoc and computationally intensive, taking over two hours to handle about 90,000 stems on a SUN Ultra workstation. The compile-replace algorithm is a vast improvement in both generality and efficiency, producing the same result in a few minutes. Following the lines of Kataja and Koskenniemi (1988), we could def</context>
<context position="26842" citStr="Beesley, 1998" startWordPosition="4217" endWordPosition="4218"> idiosyncratic subset of derivational processes that it undergoes. The small prototype dictionary, stored in an XML format, contains approximately 1000 roots, with about 1500 derivational subentries (i.e. an average of 1.5 derivational processes per root). At compile time, the XML dictionary is parsed and &amp;quot;downtranslated&amp;quot; into the source format required for the lexc compiler. The XML dictionary could be expanded by arty competent Malay lexicographer. 4.2 Arabic Morphological Analyzer/Generator The current Arabic system has been described in some detail in previous publications (Beesley, 1996; Beesley, 1998a; Beesley, 1998b) and is available for testing on the Internet.7 The modification of the system to use the compile-replace algorithm has not changed the size or the behavior of the system in arty way, but it has reduced the compilation time from hours to minutes. 5 Conclusion The well-founded criticism of traditional implementations of finite-state morphology, that they are limited to handling concatenative morphotactics, is a direct result of their dependence on the concatenation operation in morphotactic description. The technique described here, implemented in the compile-replace algorithm</context>
</contexts>
<marker>Beesley, 1998</marker>
<rawString>Kenneth R. Beesley. 1998a. Arabic morphological analysis on the Internet. In ICEMC0-98, Cambridge, April 17-18. Centre for Middle Eastern Studies. Proceedings of the 6th International Conference and Exhibition on Multilingual Computing. Paper number 3.1.1; no pagination.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth R Beesley</author>
</authors>
<title>Arabic morphology using only finite-state operations.</title>
<date>1998</date>
<booktitle>Computational Approaches to Semitic Languages: Proceedings of the Workshop,</booktitle>
<pages>50--57</pages>
<editor>In Michael Rosner, editor,</editor>
<location>Montreal, Quebec,</location>
<contexts>
<context position="17003" citStr="Beesley, 1998" startWordPosition="2590" endWordPosition="2591">ntations in dealing with non-concatenative morphotactics could be traced to their dependence on the concatenation operation in morphotactic descriptions. This insight of Kataja and Koskenniemi was applied by Beesley in a large-scale morphological analyzer for Arabic, first using an implementation that simulated the intersection of stems in code at runtime (Beesley, 1989; Beesley et al., 1989; Beesley, 1990; Beesley, 1991), and ran 5These patterns combine what McCarthy (1981) would call templates and vocalizations. 7 rather slowly; and later, using Xerox finite-state technology (Beesley, 1996; Beesley, 1998a), a new implementation that intersected the stems at compile time and performed well at runtime. The 1996 algorithm that intersected roots and patterns into stems, and substituted the original roots and patterns on just the lower side with the intersected stem, was admittedly rather ad hoc and computationally intensive, taking over two hours to handle about 90,000 stems on a SUN Ultra workstation. The compile-replace algorithm is a vast improvement in both generality and efficiency, producing the same result in a few minutes. Following the lines of Kataja and Koskenniemi (1988), we could def</context>
<context position="26842" citStr="Beesley, 1998" startWordPosition="4217" endWordPosition="4218"> idiosyncratic subset of derivational processes that it undergoes. The small prototype dictionary, stored in an XML format, contains approximately 1000 roots, with about 1500 derivational subentries (i.e. an average of 1.5 derivational processes per root). At compile time, the XML dictionary is parsed and &amp;quot;downtranslated&amp;quot; into the source format required for the lexc compiler. The XML dictionary could be expanded by arty competent Malay lexicographer. 4.2 Arabic Morphological Analyzer/Generator The current Arabic system has been described in some detail in previous publications (Beesley, 1996; Beesley, 1998a; Beesley, 1998b) and is available for testing on the Internet.7 The modification of the system to use the compile-replace algorithm has not changed the size or the behavior of the system in arty way, but it has reduced the compilation time from hours to minutes. 5 Conclusion The well-founded criticism of traditional implementations of finite-state morphology, that they are limited to handling concatenative morphotactics, is a direct result of their dependence on the concatenation operation in morphotactic description. The technique described here, implemented in the compile-replace algorithm</context>
</contexts>
<marker>Beesley, 1998</marker>
<rawString>Kenneth R. Beesley. 1998b. Arabic morphology using only finite-state operations. In Michael Rosner, editor, Computational Approaches to Semitic Languages: Proceedings of the Workshop, pages 50-57, Montreal, Quebec, August 16. Universite de Montreal.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth R Beesley</author>
</authors>
<title>Arabic stem morphotactics via finite-state intersection. Paper presented at the 12th</title>
<date>1998</date>
<booktitle>Symposium on Arabic Linguistics, Arabic Linguistic Society,</booktitle>
<pages>6--7</pages>
<location>Champaign, IL.</location>
<contexts>
<context position="17003" citStr="Beesley, 1998" startWordPosition="2590" endWordPosition="2591">ntations in dealing with non-concatenative morphotactics could be traced to their dependence on the concatenation operation in morphotactic descriptions. This insight of Kataja and Koskenniemi was applied by Beesley in a large-scale morphological analyzer for Arabic, first using an implementation that simulated the intersection of stems in code at runtime (Beesley, 1989; Beesley et al., 1989; Beesley, 1990; Beesley, 1991), and ran 5These patterns combine what McCarthy (1981) would call templates and vocalizations. 7 rather slowly; and later, using Xerox finite-state technology (Beesley, 1996; Beesley, 1998a), a new implementation that intersected the stems at compile time and performed well at runtime. The 1996 algorithm that intersected roots and patterns into stems, and substituted the original roots and patterns on just the lower side with the intersected stem, was admittedly rather ad hoc and computationally intensive, taking over two hours to handle about 90,000 stems on a SUN Ultra workstation. The compile-replace algorithm is a vast improvement in both generality and efficiency, producing the same result in a few minutes. Following the lines of Kataja and Koskenniemi (1988), we could def</context>
<context position="26842" citStr="Beesley, 1998" startWordPosition="4217" endWordPosition="4218"> idiosyncratic subset of derivational processes that it undergoes. The small prototype dictionary, stored in an XML format, contains approximately 1000 roots, with about 1500 derivational subentries (i.e. an average of 1.5 derivational processes per root). At compile time, the XML dictionary is parsed and &amp;quot;downtranslated&amp;quot; into the source format required for the lexc compiler. The XML dictionary could be expanded by arty competent Malay lexicographer. 4.2 Arabic Morphological Analyzer/Generator The current Arabic system has been described in some detail in previous publications (Beesley, 1996; Beesley, 1998a; Beesley, 1998b) and is available for testing on the Internet.7 The modification of the system to use the compile-replace algorithm has not changed the size or the behavior of the system in arty way, but it has reduced the compilation time from hours to minutes. 5 Conclusion The well-founded criticism of traditional implementations of finite-state morphology, that they are limited to handling concatenative morphotactics, is a direct result of their dependence on the concatenation operation in morphotactic description. The technique described here, implemented in the compile-replace algorithm</context>
</contexts>
<marker>Beesley, 1998</marker>
<rawString>Kenneth R. Beesley. 1998c. Arabic stem morphotactics via finite-state intersection. Paper presented at the 12th Symposium on Arabic Linguistics, Arabic Linguistic Society, 6-7 March, 1998, Champaign, IL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
<author>Kenneth R Beesley</author>
</authors>
<title>Two-level rule compiler.</title>
<date>1992</date>
<tech>Technical Report ISTL-92-2,</tech>
<institution>Xerox Palo Alto Research Center,</institution>
<location>Palo Alto, CA,</location>
<contexts>
<context position="8482" citStr="Karttunen and Beesley, 1992" startWordPosition="1234" endWordPosition="1238">e inherently bidirectional. Ambiguity in the downward direction is also possible, as in the relation of the lexical string payer+IndP+SG+Pl+Verb (&amp;quot;I pay&amp;quot;) to the surface strings paie and pa ye, which are in fact valid alternate spellings in standard French orthography. 2.2 Morphotactics and Alternations There are two challenges in modeling natural language morphology: • Morphotactics • Phonological/Orthographical Alternations Finite-state morphology models both using regular expressions. The source descriptions may also be written in higher-level notations (e.g. lexc (Karttunen, 1993), twolc (Karttunen and Beesley, 1992) and Replace Rules (Karttunen, 1995; Karttunen, 1996; Kempe and Karttunen, 1996)) that are simply helpful shorthands for regular expressions and that compile, using their dedicated compilers, into finite-state 3 Lexicon Regular Expression Lexicon FST .o. Rule FST Lexical Transducer (a single FST) Rule Regular Expression i b 0 4 0 +Comp +Adj b r i 4 e 0 4 Compiler *:a a 0:a *:0 a:0 *:0 0:^[a * 0:^] a * a Lexical: b a g i +Noun +Plural Surface: -[ {bagi} - 2 -] Lexical: p e 1 abuhan +Noun +Plural Surface: -[{pelabuhan} - 2 -1 Figure 11: Two Paths in the Initial Malay Transducer Defined via Conca</context>
</contexts>
<marker>Karttunen, Beesley, 1992</marker>
<rawString>Lauri Karttunen and Kenneth R. Beesley. 1992. Two-level rule compiler. Technical Report ISTL-92-2, Xerox Palo Alto Research Center, Palo Alto, CA, October.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
<author>Ronald M Kaplan</author>
<author>Annie Zaenen</author>
</authors>
<title>Two-level morphology with composition.</title>
<date>1992</date>
<booktitle>In COLING&apos;92,</booktitle>
<pages>141--148</pages>
<location>Nantes, France,</location>
<marker>Karttunen, Kaplan, Zaenen, 1992</marker>
<rawString>Lauri Karttunen, Ronald M. Kaplan, and Annie Zaenen. 1992. Two-level morphology with composition. In COLING&apos;92, pages 141-148, Nantes, France, August 23-28.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
</authors>
<title>Finite-state constraints.</title>
<date>1991</date>
<booktitle>In Proceedings of the International Conference on Current Issues in Computational Linguistics, Penang,</booktitle>
<institution>Universiti Sains Malaysia.</institution>
<location>Malaysia,</location>
<contexts>
<context position="1421" citStr="Karttunen, 1991" startWordPosition="181" endWordPosition="182">ull-stem reduplication and Arabic stem interdigitation. 1 Introduction Most natural languages construct words by concatenating morphemes together in strict orders. Such &amp;quot;concatenative morphotactics&amp;quot; can be impressively productive, especially in agglutinative languages like Aymara (Figure 11) or Turkish, and in agglutinative/polysynthetic languages like Inuktitut (Figure 2)(Mallon, 1999, 2). In such languages a single word may contain as many morphemes as an average-length English sentence. Finite-state morphology in the tradition of the Two-Level (Koskenniemi, 1983) and Xerox implementations (Karttunen, 1991; Karttunen, 1994; Beesley and Karttunen, 2000) has been very successful in implementing large-scale, robust and efficient morphological analyzergenerators for concatenative languages, including the commercially important European languages and non-Indo-European examples like 1I wish to thank Stuart Newton for this example. Finnish, Turkish and Hungarian. However, Koskenniemi himself understood that his initial implementation had significant limitations in handling non-concatenative morphotactic processes: &amp;quot;Only restricted infixation and reduplication can be handled adequately with the present</context>
</contexts>
<marker>Karttunen, 1991</marker>
<rawString>Lauri Karttunen. 1991. Finite-state constraints. In Proceedings of the International Conference on Current Issues in Computational Linguistics, Penang, Malaysia, June 10-14. Universiti Sains Malaysia.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
</authors>
<title>Finite-state lexicon compiler.</title>
<date>1993</date>
<tech>Technical Report ISTL-NLTT1993-04-02,</tech>
<institution>Xerox Palo Alto Research Center,</institution>
<location>Palo Alto, CA,</location>
<contexts>
<context position="8445" citStr="Karttunen, 1993" startWordPosition="1231" endWordPosition="1232">suis; such transducers are inherently bidirectional. Ambiguity in the downward direction is also possible, as in the relation of the lexical string payer+IndP+SG+Pl+Verb (&amp;quot;I pay&amp;quot;) to the surface strings paie and pa ye, which are in fact valid alternate spellings in standard French orthography. 2.2 Morphotactics and Alternations There are two challenges in modeling natural language morphology: • Morphotactics • Phonological/Orthographical Alternations Finite-state morphology models both using regular expressions. The source descriptions may also be written in higher-level notations (e.g. lexc (Karttunen, 1993), twolc (Karttunen and Beesley, 1992) and Replace Rules (Karttunen, 1995; Karttunen, 1996; Kempe and Karttunen, 1996)) that are simply helpful shorthands for regular expressions and that compile, using their dedicated compilers, into finite-state 3 Lexicon Regular Expression Lexicon FST .o. Rule FST Lexical Transducer (a single FST) Rule Regular Expression i b 0 4 0 +Comp +Adj b r i 4 e 0 4 Compiler *:a a 0:a *:0 a:0 *:0 0:^[a * 0:^] a * a Lexical: b a g i +Noun +Plural Surface: -[ {bagi} - 2 -] Lexical: p e 1 abuhan +Noun +Plural Surface: -[{pelabuhan} - 2 -1 Figure 11: Two Paths in the Initi</context>
</contexts>
<marker>Karttunen, 1993</marker>
<rawString>Lauri Karttunen. 1993. Finite-state lexicon compiler. Technical Report ISTL-NLTT1993-04-02, Xerox Palo Alto Research Center, Palo Alto, CA, April.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
</authors>
<title>Constructing lexical transducers.</title>
<date>1994</date>
<booktitle>In COLING&apos;94, Kyoto,</booktitle>
<contexts>
<context position="1438" citStr="Karttunen, 1994" startWordPosition="183" endWordPosition="184">ation and Arabic stem interdigitation. 1 Introduction Most natural languages construct words by concatenating morphemes together in strict orders. Such &amp;quot;concatenative morphotactics&amp;quot; can be impressively productive, especially in agglutinative languages like Aymara (Figure 11) or Turkish, and in agglutinative/polysynthetic languages like Inuktitut (Figure 2)(Mallon, 1999, 2). In such languages a single word may contain as many morphemes as an average-length English sentence. Finite-state morphology in the tradition of the Two-Level (Koskenniemi, 1983) and Xerox implementations (Karttunen, 1991; Karttunen, 1994; Beesley and Karttunen, 2000) has been very successful in implementing large-scale, robust and efficient morphological analyzergenerators for concatenative languages, including the commercially important European languages and non-Indo-European examples like 1I wish to thank Stuart Newton for this example. Finnish, Turkish and Hungarian. However, Koskenniemi himself understood that his initial implementation had significant limitations in handling non-concatenative morphotactic processes: &amp;quot;Only restricted infixation and reduplication can be handled adequately with the present system. Some ext</context>
</contexts>
<marker>Karttunen, 1994</marker>
<rawString>Lauri Karttunen. 1994. Constructing lexical transducers. In COLING&apos;94, Kyoto, Japan.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
</authors>
<title>The replace operator.</title>
<date>1995</date>
<booktitle>In ACL&apos;95,</booktitle>
<location>Cambridge, MA.</location>
<contexts>
<context position="8517" citStr="Karttunen, 1995" startWordPosition="1242" endWordPosition="1243">nward direction is also possible, as in the relation of the lexical string payer+IndP+SG+Pl+Verb (&amp;quot;I pay&amp;quot;) to the surface strings paie and pa ye, which are in fact valid alternate spellings in standard French orthography. 2.2 Morphotactics and Alternations There are two challenges in modeling natural language morphology: • Morphotactics • Phonological/Orthographical Alternations Finite-state morphology models both using regular expressions. The source descriptions may also be written in higher-level notations (e.g. lexc (Karttunen, 1993), twolc (Karttunen and Beesley, 1992) and Replace Rules (Karttunen, 1995; Karttunen, 1996; Kempe and Karttunen, 1996)) that are simply helpful shorthands for regular expressions and that compile, using their dedicated compilers, into finite-state 3 Lexicon Regular Expression Lexicon FST .o. Rule FST Lexical Transducer (a single FST) Rule Regular Expression i b 0 4 0 +Comp +Adj b r i 4 e 0 4 Compiler *:a a 0:a *:0 a:0 *:0 0:^[a * 0:^] a * a Lexical: b a g i +Noun +Plural Surface: -[ {bagi} - 2 -] Lexical: p e 1 abuhan +Noun +Plural Surface: -[{pelabuhan} - 2 -1 Figure 11: Two Paths in the Initial Malay Transducer Defined via Concatenation In this simple example, th</context>
</contexts>
<marker>Karttunen, 1995</marker>
<rawString>Lauri Karttunen. 1995. The replace operator. In ACL&apos;95, Cambridge, MA. cmplg/9504032.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
</authors>
<title>Directed replacement.</title>
<date>1996</date>
<booktitle>In ACL&apos;96,</booktitle>
<location>Santa Cruz, CA.</location>
<contexts>
<context position="8534" citStr="Karttunen, 1996" startWordPosition="1244" endWordPosition="1245">s also possible, as in the relation of the lexical string payer+IndP+SG+Pl+Verb (&amp;quot;I pay&amp;quot;) to the surface strings paie and pa ye, which are in fact valid alternate spellings in standard French orthography. 2.2 Morphotactics and Alternations There are two challenges in modeling natural language morphology: • Morphotactics • Phonological/Orthographical Alternations Finite-state morphology models both using regular expressions. The source descriptions may also be written in higher-level notations (e.g. lexc (Karttunen, 1993), twolc (Karttunen and Beesley, 1992) and Replace Rules (Karttunen, 1995; Karttunen, 1996; Kempe and Karttunen, 1996)) that are simply helpful shorthands for regular expressions and that compile, using their dedicated compilers, into finite-state 3 Lexicon Regular Expression Lexicon FST .o. Rule FST Lexical Transducer (a single FST) Rule Regular Expression i b 0 4 0 +Comp +Adj b r i 4 e 0 4 Compiler *:a a 0:a *:0 a:0 *:0 0:^[a * 0:^] a * a Lexical: b a g i +Noun +Plural Surface: -[ {bagi} - 2 -] Lexical: p e 1 abuhan +Noun +Plural Surface: -[{pelabuhan} - 2 -1 Figure 11: Two Paths in the Initial Malay Transducer Defined via Concatenation In this simple example, the upper language </context>
</contexts>
<marker>Karttunen, 1996</marker>
<rawString>Lauri Karttunen. 1996. Directed replacement. In ACL&apos;96, Santa Cruz, CA. cmplg/9606029.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Laura Kataja</author>
<author>Kimmo Koskenniemi</author>
</authors>
<title>Finite-state description of Semitic morphology: A case study of Ancient Akkadian. In</title>
<date>1988</date>
<booktitle>COLING&apos;88,</booktitle>
<pages>313--315</pages>
<contexts>
<context position="15709" citStr="Kataja and Koskenniemi (1988)" startWordPosition="2399" endWordPosition="2402">with CVCVC and ui to form duris, and so forth. Kay (1987) reformalized the autosegmental tiers of McCarthy (1981) as projections of a multi-level transducer and wrote a small Prologbased prototype that handled the interdigitation of roots, CV-templates and vocalizations into abstract Arabic stems; this general approach, with multi-tape transducers, has been explored and extended by Kiraz in several papers (1994a; 1996; 1994b; 2000) with respect to Syriac and Arabic. The implementation is described in Kiraz and Grimley-Evans (1999). In work more directly related to the current solution, it was Kataja and Koskenniemi (1988) who first demonstrated that Semitic (Akkadian) roots and patterns5 could be formalized as regular languages, and that the non-concatenative interdigitation of stems could be elegantly formalized as the intersection of those regular languages. Thus Akkadian words were formalized as consisting of morphemes, some of which were combined together by intersection and others of which were combined via concatenation. This was the key insight: morphotactic description could employ various finite-state operations, not just concatenation; and languages that required only concatenation were just special </context>
<context position="17589" citStr="Kataja and Koskenniemi (1988)" startWordPosition="2680" endWordPosition="2684">te technology (Beesley, 1996; Beesley, 1998a), a new implementation that intersected the stems at compile time and performed well at runtime. The 1996 algorithm that intersected roots and patterns into stems, and substituted the original roots and patterns on just the lower side with the intersected stem, was admittedly rather ad hoc and computationally intensive, taking over two hours to handle about 90,000 stems on a SUN Ultra workstation. The compile-replace algorithm is a vast improvement in both generality and efficiency, producing the same result in a few minutes. Following the lines of Kataja and Koskenniemi (1988), we could define intermediate networks with regular-expression substrings that indicate the intersection of suitably encoded roots, templates, and vocalizations (for a formal description of what such regular-expression substrings would look like, see Beesley (1998c; 1998b)). However, the general-purpose intersection algorithm would be expensive in arty non-trivial application, and the interdigitation of stems represents a special case of intersection that we achieve in practice by a much more efficient finite-state algorithm called MERGE. 3.2.2 Merge The merge algorithm is a pattern-filling o</context>
</contexts>
<marker>Kataja, Koskenniemi, 1988</marker>
<rawString>Laura Kataja and Kimmo Koskenniemi. 1988. Finite-state description of Semitic morphology: A case study of Ancient Akkadian. In COLING&apos;88, pages 313-315.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Martin Kay</author>
</authors>
<title>Nonconcatenative finitestate morphology.</title>
<date>1987</date>
<booktitle>In Proceedings of the Third Conference of the European Chapter of the Association for Computational Linguistics,</booktitle>
<pages>2--10</pages>
<contexts>
<context position="15137" citStr="Kay (1987)" startWordPosition="2314" endWordPosition="2315">CVC and a different vocalization ui, signifying perfect aspect and passive voice, producing the stem kutib, which means &amp;quot;was written&amp;quot;. Similarly, the root ktb can combine with template it is in Malay. In some languages only a part of the stem is reduplicated and there may be systematic differences between the reduplicate and the base form. We believe that our approach to reduplication can account for these complex phenomena as well but we cannot discuss the issue here due to lack of space. CVVCVC and ui to produce kuutib, the root drs can combine with CVCVC and ui to form duris, and so forth. Kay (1987) reformalized the autosegmental tiers of McCarthy (1981) as projections of a multi-level transducer and wrote a small Prologbased prototype that handled the interdigitation of roots, CV-templates and vocalizations into abstract Arabic stems; this general approach, with multi-tape transducers, has been explored and extended by Kiraz in several papers (1994a; 1996; 1994b; 2000) with respect to Syriac and Arabic. The implementation is described in Kiraz and Grimley-Evans (1999). In work more directly related to the current solution, it was Kataja and Koskenniemi (1988) who first demonstrated that</context>
</contexts>
<marker>Kay, 1987</marker>
<rawString>Martin Kay. 1987. Nonconcatenative finitestate morphology. In Proceedings of the Third Conference of the European Chapter of the Association for Computational Linguistics, pages 2-10.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andre Kempe</author>
<author>Lauri Karttunen</author>
</authors>
<title>Parallel replacement in finite-state calculus.</title>
<date>1996</date>
<booktitle>In COLING&apos;96,</booktitle>
<location>Copenhagen,</location>
<contexts>
<context position="8562" citStr="Kempe and Karttunen, 1996" startWordPosition="1246" endWordPosition="1249">as in the relation of the lexical string payer+IndP+SG+Pl+Verb (&amp;quot;I pay&amp;quot;) to the surface strings paie and pa ye, which are in fact valid alternate spellings in standard French orthography. 2.2 Morphotactics and Alternations There are two challenges in modeling natural language morphology: • Morphotactics • Phonological/Orthographical Alternations Finite-state morphology models both using regular expressions. The source descriptions may also be written in higher-level notations (e.g. lexc (Karttunen, 1993), twolc (Karttunen and Beesley, 1992) and Replace Rules (Karttunen, 1995; Karttunen, 1996; Kempe and Karttunen, 1996)) that are simply helpful shorthands for regular expressions and that compile, using their dedicated compilers, into finite-state 3 Lexicon Regular Expression Lexicon FST .o. Rule FST Lexical Transducer (a single FST) Rule Regular Expression i b 0 4 0 +Comp +Adj b r i 4 e 0 4 Compiler *:a a 0:a *:0 a:0 *:0 0:^[a * 0:^] a * a Lexical: b a g i +Noun +Plural Surface: -[ {bagi} - 2 -] Lexical: p e 1 abuhan +Noun +Plural Surface: -[{pelabuhan} - 2 -1 Figure 11: Two Paths in the Initial Malay Transducer Defined via Concatenation In this simple example, the upper language of the original network in F</context>
</contexts>
<marker>Kempe, Karttunen, 1996</marker>
<rawString>Andre Kempe and Lauri Karttunen. 1996. Parallel replacement in finite-state calculus. In COLING&apos;96, Copenhagen, August 5-9. cmplg/9607007.</rawString>
</citation>
<citation valid="true">
<authors>
<author>George Anton Kiraz</author>
<author>Edmund GrimleyEvans</author>
</authors>
<title>Multi-tape automata for speech and language systems: A Prolog implementation.</title>
<date>1999</date>
<booktitle>In Jean-Marc Champarnaud, Denis Maurel, and Djellout Ziadi, editors, Automata Implementation,</booktitle>
<volume>1660</volume>
<publisher>Springer Verlag,</publisher>
<location>Berlin, Germany.</location>
<marker>Kiraz, GrimleyEvans, 1999</marker>
<rawString>George Anton Kiraz and Edmund GrimleyEvans. 1999. Multi-tape automata for speech and language systems: A Prolog implementation. In Jean-Marc Champarnaud, Denis Maurel, and Djellout Ziadi, editors, Automata Implementation, volume 1660 of Lecture Notes in Computer Science. Springer Verlag, Berlin, Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>George Anton Kiraz</author>
</authors>
<title>Multi-tape twolevel morphology: a case study in Semitic non-linear morphology.</title>
<date>1994</date>
<booktitle>In COLING &apos;9,</booktitle>
<volume>1</volume>
<pages>180--186</pages>
<marker>Kiraz, 1994</marker>
<rawString>George Anton Kiraz. 1994a. Multi-tape twolevel morphology: a case study in Semitic non-linear morphology. In COLING &apos;9, volume 1, pages 180-186.</rawString>
</citation>
<citation valid="true">
<authors>
<author>George Anton Kiraz</author>
</authors>
<title>Multi-tape twolevel morphology: a case study in Semitic non-linear morphology.</title>
<date>1994</date>
<booktitle>In Proceedings of the 15th International Conference on Computational Linguistics, Kyoto,</booktitle>
<marker>Kiraz, 1994</marker>
<rawString>George Anton Kiraz. 1994b. Multi-tape twolevel morphology: a case study in Semitic non-linear morphology. In Proceedings of the 15th International Conference on Computational Linguistics, Kyoto, Japan.</rawString>
</citation>
<citation valid="true">
<authors>
<author>George Anton Kiraz</author>
</authors>
<title>Semhe: A generalised two-level system.</title>
<date>1996</date>
<booktitle>In Proceedings of the 34th Annual Meeting of the Association of Computational Linguistics,</booktitle>
<location>Santa Cruz, CA.</location>
<marker>Kiraz, 1996</marker>
<rawString>George Anton Kiraz. 1996. Semhe: A generalised two-level system. In Proceedings of the 34th Annual Meeting of the Association of Computational Linguistics, Santa Cruz, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>George Anton Kiraz</author>
</authors>
<title>Multi-tiered nonlinear morphology: A case study on Semitic.</title>
<date>2000</date>
<journal>Computational Linguistics,</journal>
<volume>26</volume>
<issue>1</issue>
<marker>Kiraz, 2000</marker>
<rawString>George Anton Kiraz. 2000. Multi-tiered nonlinear morphology: A case study on Semitic. Computational Linguistics, 26(1).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kimmo Koskenniemi</author>
</authors>
<title>Two-level morphology: A general computational model for word-form recognition and production.</title>
<date>1983</date>
<journal>Publication</journal>
<volume>11</volume>
<institution>University of Helsinki, Department of General Linguistics,</institution>
<location>Helsinki.</location>
<contexts>
<context position="1378" citStr="Koskenniemi, 1983" startWordPosition="176" endWordPosition="177">ve phenomena; and we demonstrate it on Malay full-stem reduplication and Arabic stem interdigitation. 1 Introduction Most natural languages construct words by concatenating morphemes together in strict orders. Such &amp;quot;concatenative morphotactics&amp;quot; can be impressively productive, especially in agglutinative languages like Aymara (Figure 11) or Turkish, and in agglutinative/polysynthetic languages like Inuktitut (Figure 2)(Mallon, 1999, 2). In such languages a single word may contain as many morphemes as an average-length English sentence. Finite-state morphology in the tradition of the Two-Level (Koskenniemi, 1983) and Xerox implementations (Karttunen, 1991; Karttunen, 1994; Beesley and Karttunen, 2000) has been very successful in implementing large-scale, robust and efficient morphological analyzergenerators for concatenative languages, including the commercially important European languages and non-Indo-European examples like 1I wish to thank Stuart Newton for this example. Finnish, Turkish and Hungarian. However, Koskenniemi himself understood that his initial implementation had significant limitations in handling non-concatenative morphotactic processes: &amp;quot;Only restricted infixation and reduplication</context>
</contexts>
<marker>Koskenniemi, 1983</marker>
<rawString>Kimmo Koskenniemi. 1983. Two-level morphology: A general computational model for word-form recognition and production. Publication 11, University of Helsinki, Department of General Linguistics, Helsinki.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alon Lavie</author>
<author>Alon Itai</author>
<author>Uzzi Ornan</author>
<author>Mori Rimon</author>
</authors>
<title>On the applicability of two level morphology to the inflection of Hebrew verbs.</title>
<date>1988</date>
<booktitle>In Proceedings of ALLC HI,</booktitle>
<pages>246--260</pages>
<marker>Lavie, Itai, Ornan, Rimon, 1988</marker>
<rawString>Alon Lavie, Alon Itai, Uzzi Ornan, and Mori Rimon. 1988. On the applicability of two level morphology to the inflection of Hebrew verbs. In Proceedings of ALLC HI, pages 246-260.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mick Mallon</author>
</authors>
<title>Inuktitut linguistics for technocrats.</title>
<date>1999</date>
<tech>Technical report, Ittukuluuk Language Programs,</tech>
<location>Icialuit, Nunavut, Canada.</location>
<contexts>
<context position="1194" citStr="Mallon, 1999" startWordPosition="148" endWordPosition="149">ves reapplying the regular-expression compiler to its own output. Implemented in an algorithm called compilereplace, this technique has proved useful for handling non-concatenative phenomena; and we demonstrate it on Malay full-stem reduplication and Arabic stem interdigitation. 1 Introduction Most natural languages construct words by concatenating morphemes together in strict orders. Such &amp;quot;concatenative morphotactics&amp;quot; can be impressively productive, especially in agglutinative languages like Aymara (Figure 11) or Turkish, and in agglutinative/polysynthetic languages like Inuktitut (Figure 2)(Mallon, 1999, 2). In such languages a single word may contain as many morphemes as an average-length English sentence. Finite-state morphology in the tradition of the Two-Level (Koskenniemi, 1983) and Xerox implementations (Karttunen, 1991; Karttunen, 1994; Beesley and Karttunen, 2000) has been very successful in implementing large-scale, robust and efficient morphological analyzergenerators for concatenative languages, including the commercially important European languages and non-Indo-European examples like 1I wish to thank Stuart Newton for this example. Finnish, Turkish and Hungarian. However, Kosken</context>
</contexts>
<marker>Mallon, 1999</marker>
<rawString>Mick Mallon. 1999. Inuktitut linguistics for technocrats. Technical report, Ittukuluuk Language Programs, Icialuit, Nunavut, Canada.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John J McCarthy</author>
<author>Alan Prince</author>
</authors>
<title>Faithfulness and reduplicative identity. Occasional papers in Linguistics 18,</title>
<date>1995</date>
<institution>University of Massachusetts,</institution>
<location>Amherst, MA. ROA-60.</location>
<contexts>
<context position="12807" citStr="McCarthy and Prince, 1995" startWordPosition="1947" endWordPosition="1950">ng -1. Figure 11 shows the paths for two Malay plurals in the initial network. The compile-replace algorithm, applied to the lower-side of this network, recognizes each individual delimited regular-expression substring like - Hbagi}-2-1, compiles it, and replaces it with the result of the compilation, here bagibagi. The same process applies to the entire lower-side language, resulting in a network that relates pairs of strings such as the ones in Figure 12. This provides the desired solution, still finite-state, for analyzing and generating fullstem reduplication in Malay.4 4It is well-known (McCarthy and Prince, 1995) that reduplication can be a more complex phenomenon than 6 Lexical:bagi +Noun +Plural Surface:bagibagi Lexical:pelabuhan +Noun +Plural Surface:pelabuhanpelabuhan Figure 12: The Malay FST After the Application of Compile-Replace to the Lower-Side Language The special delimiters - [ and -] can be used to surround arty appropriate regularexpression substring, using arty necessary regular-expression operators, and compilereplace may be applied to the lower-side and/or upper-side of the network as desired. There is nothing to stop the linguist from inserting delimiters multiple times, including vi</context>
</contexts>
<marker>McCarthy, Prince, 1995</marker>
<rawString>John J. McCarthy and Alan Prince. 1995. Faithfulness and reduplicative identity. Occasional papers in Linguistics 18, University of Massachusetts, Amherst, MA. ROA-60.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John J McCarthy</author>
</authors>
<title>A prosodic theory of nonconcatenative morphology.</title>
<date>1981</date>
<journal>Linguistic Inquiry,</journal>
<pages>12--3</pages>
<contexts>
<context position="13975" citStr="McCarthy, 1981" startWordPosition="2114" endWordPosition="2115">serting delimiters multiple times, including via composition, and reapplying compile-replace multiple times (see the Appendix). The technique implemented in compile-replace is a general way of allowing the regular-expression compiler to reapply to and modify its own output. 3.2 Semitic Stem Interdigitation 3.2.1 Review of Earlier Work Much of the work in non-concatenative finitestate morphotactics has been dedicated to handling Semitic stem interdigitation. An example of interdigitation occurs with the Arabic stem katab, which means &amp;quot;wrote&amp;quot;. According to an influential autosegmental analysis (McCarthy, 1981), this stem consists of an all-consonant root ktb whose general meaning has to do with writing, an abstract consonant-vowel template CVCVC, and a voweling or vocalization that he symbolized simply as a, signifying perfect aspect and active voice. The root consonants are associated with the C slots of the template and the vowel or vowels with the V slots, producing a complete stem katab. If the root and the vocalization are thought of as morphemes, neither morpheme occurs continuously in the stem. The same root ktb can combine with the template CVCVC and a different vocalization ui, signifying </context>
<context position="15193" citStr="McCarthy (1981)" startWordPosition="2321" endWordPosition="2322">fect aspect and passive voice, producing the stem kutib, which means &amp;quot;was written&amp;quot;. Similarly, the root ktb can combine with template it is in Malay. In some languages only a part of the stem is reduplicated and there may be systematic differences between the reduplicate and the base form. We believe that our approach to reduplication can account for these complex phenomena as well but we cannot discuss the issue here due to lack of space. CVVCVC and ui to produce kuutib, the root drs can combine with CVCVC and ui to form duris, and so forth. Kay (1987) reformalized the autosegmental tiers of McCarthy (1981) as projections of a multi-level transducer and wrote a small Prologbased prototype that handled the interdigitation of roots, CV-templates and vocalizations into abstract Arabic stems; this general approach, with multi-tape transducers, has been explored and extended by Kiraz in several papers (1994a; 1996; 1994b; 2000) with respect to Syriac and Arabic. The implementation is described in Kiraz and Grimley-Evans (1999). In work more directly related to the current solution, it was Kataja and Koskenniemi (1988) who first demonstrated that Semitic (Akkadian) roots and patterns5 could be formali</context>
<context position="16869" citStr="McCarthy (1981)" startWordPosition="2572" endWordPosition="2573">ges that required only concatenation were just special cases. By extension, the widely noticed limitations of early finite-state implementations in dealing with non-concatenative morphotactics could be traced to their dependence on the concatenation operation in morphotactic descriptions. This insight of Kataja and Koskenniemi was applied by Beesley in a large-scale morphological analyzer for Arabic, first using an implementation that simulated the intersection of stems in code at runtime (Beesley, 1989; Beesley et al., 1989; Beesley, 1990; Beesley, 1991), and ran 5These patterns combine what McCarthy (1981) would call templates and vocalizations. 7 rather slowly; and later, using Xerox finite-state technology (Beesley, 1996; Beesley, 1998a), a new implementation that intersected the stems at compile time and performed well at runtime. The 1996 algorithm that intersected roots and patterns into stems, and substituted the original roots and patterns on just the lower side with the intersected stem, was admittedly rather ad hoc and computationally intensive, taking over two hours to handle about 90,000 stems on a SUN Ultra workstation. The compile-replace algorithm is a vast improvement in both gen</context>
</contexts>
<marker>McCarthy, 1981</marker>
<rawString>John J. McCarthy. 1981. A prosodic theory of nonconcatenative morphology. Linguistic Inquiry, 12(3):373-418.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Richard Sproat</author>
</authors>
<title>Morphology and Computation.</title>
<date>1992</date>
<publisher>MIT Press,</publisher>
<location>Cambridge, MA.</location>
<marker>Sproat, 1992</marker>
<rawString>Richard Sproat. 1992. Morphology and Computation. MIT Press, Cambridge, MA.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>