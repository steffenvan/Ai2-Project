<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.037731">
<title confidence="0.983445">
OSU-GP: Attribute Selection using Genetic Programming
</title>
<author confidence="0.997648">
Josh King
</author>
<affiliation confidence="0.99526">
Department of Computer Science and Engineering
The Ohio State University
</affiliation>
<address confidence="0.766013">
Columbus, OH 43210, USA
</address>
<email confidence="0.999106">
kingjo@cse.ohio-state.edu
</email>
<sectionHeader confidence="0.993909" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.99618175">
This system’s approach to the attribute selec-
tion task was to use a genetic programming
algorithm to search for a solution to the task.
The evolved programs for the furniture and
people domain exhibit quite naive behavior,
and the DICE and MASI scores on the train-
ing sets reflect the poor humanlikeness of the
programs.
</bodyText>
<figure confidence="0.995058444444445">
valueIn {variables}
target sequence
distractors canUseLoc
eqA ifte
set empty for
set add and, or, not
set remove {attributeERC}
add {attributeListERC}
remove
</figure>
<tableCaption confidence="0.99379">
Table 1: Functions supplied to the GP algorithm
</tableCaption>
<sectionHeader confidence="0.970497" genericHeader="keywords">
1 Genetic Programming
</sectionHeader>
<bodyText confidence="0.999838222222223">
Genetic programming is a form of evolutionary
computing in which a meta program evolves another
program to solve a problem. Creating by hand a
program which solves the problem may be possi-
ble, but if the problem has many parameters which
contribute to a solution’s quality, the program de-
signer may miss some subtle interplay in favor of an
expected solution. Genetic programming evolves a
pool of programs to optimize a user supplied fitness
function which gives some indication of how well a
program performs on the problem.
This report in no way attempt to fully ex-
plain genetic programming. See, e.g., (Koza,
1992) for a better understanding of genetic
programming. The evolutionary computation
toolkit ECJ available from http://www.cs.
gmu.edu/˜eclab/projects/ecj/ was used
for the genetic programming algorithm.
</bodyText>
<sectionHeader confidence="0.988647" genericHeader="introduction">
2 Functions
</sectionHeader>
<bodyText confidence="0.999965714285714">
The genetic programming algoritm had at its dis-
posal the functions listed in Table 1. The func-
tion eqA tests whether two attribute values are
equal. The functions add and remove operate on
attribute lists, whereas the similarly named set add
and set remove operate on entity sets. The function
ifte is an if-then-else construct, and the function for
is a foreach operator on sets of entities or lists of at-
tributes and requires both a variable to change the
value of (the iterating variable) and the set or list to
operate over. The functions surrounded by braces
represent various things: for {variables}, various
variables of the different types were globally acces-
sible. {attributeERC} and {attributeListERC} rep-
resent random variables that take on attributes from
the trial set and lists of those attributes. A mutation
of an ERC (ephemeral random constant) simply sets
it to a different random value from the random con-
stant’s domain.
The functions supplied to the genetic program-
ming method were more than expressive enough to
formulate, e.g., Dale and Reiter’s Incremental Algo-
rithm (Dale and Reiter, 1995), a well known stan-
dard algorithm for doing this task. During the run of
the genetic programming algorithm, every function
shown in Table 1 was explored in the search, even
though many of them are not used in the solutions
found.
</bodyText>
<page confidence="0.993463">
225
</page>
<table confidence="0.8729742">
diceDist locationUse
masiDist inappropriate
noHit length
bloat empty
similar excessive
</table>
<tableCaption confidence="0.998327">
Table 2: The costs GP should minimize
</tableCaption>
<sectionHeader confidence="0.985062" genericHeader="method">
3 Fitness Function
</sectionHeader>
<bodyText confidence="0.999925034482758">
The genetic programming algorithm must be sup-
plied with a fitness function which judges how well
a program performs on the problem. For this task
of attribute selection, there are multiple dimensions
to optimize in. For simplicity, a linear combination
of the various dimensions was used for the fitness
function. The dimensions to optimize on were rep-
resented as costs or penalties that the genetic pro-
gramming algorithm sought to minimize. The vari-
ous costs are listed in Table 2. The costs were de-
vised with an eye towards optimizing quantities that
existing algorithms for this task also attempt to opti-
mize.
DICE and MASI scores on the training data were
converted to costs by subtracting from one. The
noHit cost is for not forming a distinguishing col-
lection of attributes and was given a high weight.
The bloat penalty penalizes long programs (to make
interpreting the result easier).
The fitness function is a weighted sum of these
costs. A fitness of zero would mean that each di-
mension is optimized fully. This is not possible, as
some of the costs conflict with each other: for ex-
ample, length and empty. The weights for the fitness
function were hand tuned, which is counter to the
desire to use genetic programming rather than hand
tune an algorithm. The use of evolutionary comput-
ing to tune these weights may produce better results,
but was not tried here.
</bodyText>
<sectionHeader confidence="0.970231" genericHeader="method">
4 Resulting System
</sectionHeader>
<bodyText confidence="0.981595142857143">
The program which evolved for the training trials of
the furniture domain is shown here:
(ifte canUseLoc
(var aList set al0
(add [ orientation size ]
colour))
(var aList set al0
</bodyText>
<table confidence="0.9724802">
(add (add [ orientation size ]
DICE MASI
Furniture 0.61 0.30
People 0.35 0.10
Average 0.49 0.21
</table>
<tableCaption confidence="0.6886555">
Table 3: DICE and MASI scores on training set
colour) type)))
</tableCaption>
<bodyText confidence="0.8867635">
The program found for the people domain is
shown here:
</bodyText>
<figure confidence="0.411647142857143">
(ifte canUseLoc
(var aList set al0 (add
(add [ hairColour hasGlasses ]
hasBeard) hasSuit))
(var aList set al0
(add [ hairColour hasGlasses ]
hasBeard)))
</figure>
<bodyText confidence="0.999886315789474">
Both of these programs seem quite unintelligent
in their behavior. They only ever set the attribute
list to one of two lists, depending only on whether
the location condition is flagged or not, and don’t
even make use of the location information. Further
tweaking of the fitness function or using different
schemes for evolution may improve the performance
of an evolved solution.
The performance metrics of DICE score and
MASI score on the training set are shown in Table 3.
The accuracy of the realization1 of the attributes is
both zero. The scores reflect the obvious point that
the evolved programs have plenty of room for im-
provement. A fitness function which is less reliant
on the user to specify weightings for optimization
may be necessary, or an evaluation which tests the
program’s ability to generalize may catalyze pro-
gram evolution into less naive directions than those
programs shown here.
</bodyText>
<sectionHeader confidence="0.999253" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.995875">
Robert Dale and Ehud Reiter. 1995. Computational
interpretations of the gricean maxims in the gener-
ation of referring expressions. Cognitive Science,
19(2):233–263.
John R. Koza. 1992. Genetic Programming: on the Pro-
gramming of Computers by Means of Natural Selec-
tion. The MIT Press.
</reference>
<footnote confidence="0.975671333333333">
1The realizer was the simple template-based realizer written
by Irene Langkilde-Geary, Brighton University for the ASGRE
2007 challenge.
</footnote>
<page confidence="0.995518">
226
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.386755">
<title confidence="0.99983">OSU-GP: Attribute Selection using Genetic Programming</title>
<author confidence="0.995143">Josh</author>
<affiliation confidence="0.9831875">Department of Computer Science and The Ohio State</affiliation>
<address confidence="0.9974">Columbus, OH 43210,</address>
<email confidence="0.99987">kingjo@cse.ohio-state.edu</email>
<abstract confidence="0.998291896551725">This system’s approach to the attribute selection task was to use a genetic programming algorithm to search for a solution to the task. The evolved programs for the furniture and people domain exhibit quite naive behavior, and the DICE and MASI scores on the training sets reflect the poor humanlikeness of the programs. target sequence distractors canUseLoc eqA ifte set empty for set add and, or, not remove remove Table 1: Functions supplied to the GP algorithm 1 Genetic Programming Genetic programming is a form of evolutionary computing in which a meta program evolves another program to solve a problem. Creating by hand a program which solves the problem may be possible, but if the problem has many parameters which contribute to a solution’s quality, the program designer may miss some subtle interplay in favor of an expected solution. Genetic programming evolves a pool of programs to optimize a user supplied fitness function which gives some indication of how well a program performs on the problem. This report in no way attempt to fully exgenetic programming. See, (Koza, 1992) for a better understanding of genetic programming. The evolutionary ECJ available from used for the genetic programming algorithm. 2 Functions The genetic programming algoritm had at its disposal the functions listed in Table 1. The funceqA tests whether two attribute equal. The functions add and remove operate on attribute lists, whereas the similarly named set add and set remove operate on entity sets. The function ifte is an if-then-else construct, and the function for is a foreach operator on sets of entities or lists of attributes and requires both a variable to change the value of (the iterating variable) and the set or list to operate over. The functions surrounded by braces various things: for various variables of the different types were globally accesrepresent random variables that take on attributes from the trial set and lists of those attributes. A mutation of an ERC (ephemeral random constant) simply sets it to a different random value from the random constant’s domain. The functions supplied to the genetic programming method were more than expressive enough to Dale and Reiter’s Incremental Algorithm (Dale and Reiter, 1995), a well known standard algorithm for doing this task. During the run of the genetic programming algorithm, every function shown in Table 1 was explored in the search, even though many of them are not used in the solutions found. 225 diceDist locationUse masiDist inappropriate noHit length bloat empty similar excessive Table 2: The costs GP should minimize 3 Fitness Function The genetic programming algorithm must be supplied with a fitness function which judges how well a program performs on the problem. For this task of attribute selection, there are multiple dimensions to optimize in. For simplicity, a linear combination of the various dimensions was used for the fitness function. The dimensions to optimize on were represented as costs or penalties that the genetic programming algorithm sought to minimize. The various costs are listed in Table 2. The costs were devised with an eye towards optimizing quantities that existing algorithms for this task also attempt to optimize. DICE and MASI scores on the training data were converted to costs by subtracting from one. The noHit cost is for not forming a distinguishing collection of attributes and was given a high weight. The bloat penalty penalizes long programs (to make interpreting the result easier). The fitness function is a weighted sum of these costs. A fitness of zero would mean that each dimension is optimized fully. This is not possible, as some of the costs conflict with each other: for example, length and empty. The weights for the fitness function were hand tuned, which is counter to the desire to use genetic programming rather than hand tune an algorithm. The use of evolutionary computing to tune these weights may produce better results, but was not tried here. 4 Resulting System The program which evolved for the training trials of the furniture domain is shown here: (ifte canUseLoc (var aList set al0 (add [ orientation size ] colour)) (var aList set al0 (add (add [ orientation size ] DICE MASI Furniture 0.61 0.30 People 0.35 0.10 Average 0.49 0.21 Table 3: DICE and MASI scores on training set colour) type))) The program found for the people domain is shown here: (ifte canUseLoc (var aList set al0 (add (add [ hairColour hasGlasses ] hasBeard) hasSuit)) (var aList set al0 (add [ hairColour hasGlasses ] hasBeard))) Both of these programs seem quite unintelligent in their behavior. They only ever set the attribute list to one of two lists, depending only on whether the location condition is flagged or not, and don’t even make use of the location information. Further tweaking of the fitness function or using different schemes for evolution may improve the performance of an evolved solution. The performance metrics of DICE score and MASI score on the training set are shown in Table 3. accuracy of the of the attributes is both zero. The scores reflect the obvious point that the evolved programs have plenty of room for improvement. A fitness function which is less reliant on the user to specify weightings for optimization may be necessary, or an evaluation which tests the program’s ability to generalize may catalyze program evolution into less naive directions than those programs shown here.</abstract>
<title confidence="0.666018">References</title>
<author confidence="0.672926">Computational</author>
<abstract confidence="0.983115888888889">interpretations of the gricean maxims in the generof referring expressions. 19(2):233–263. R. Koza. 1992. Programming: on the Programming of Computers by Means of Natural Selec- The MIT Press. realizer was the simple template-based realizer written by Irene Langkilde-Geary, Brighton University for the ASGRE 2007 challenge.</abstract>
<intro confidence="0.747234">226</intro>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Robert Dale</author>
<author>Ehud Reiter</author>
</authors>
<title>Computational interpretations of the gricean maxims in the generation of referring expressions.</title>
<date>1995</date>
<journal>Cognitive Science,</journal>
<volume>19</volume>
<issue>2</issue>
<contexts>
<context position="2688" citStr="Dale and Reiter, 1995" startWordPosition="419" endWordPosition="422"> and the set or list to operate over. The functions surrounded by braces represent various things: for {variables}, various variables of the different types were globally accessible. {attributeERC} and {attributeListERC} represent random variables that take on attributes from the trial set and lists of those attributes. A mutation of an ERC (ephemeral random constant) simply sets it to a different random value from the random constant’s domain. The functions supplied to the genetic programming method were more than expressive enough to formulate, e.g., Dale and Reiter’s Incremental Algorithm (Dale and Reiter, 1995), a well known standard algorithm for doing this task. During the run of the genetic programming algorithm, every function shown in Table 1 was explored in the search, even though many of them are not used in the solutions found. 225 diceDist locationUse masiDist inappropriate noHit length bloat empty similar excessive Table 2: The costs GP should minimize 3 Fitness Function The genetic programming algorithm must be supplied with a fitness function which judges how well a program performs on the problem. For this task of attribute selection, there are multiple dimensions to optimize in. For si</context>
</contexts>
<marker>Dale, Reiter, 1995</marker>
<rawString>Robert Dale and Ehud Reiter. 1995. Computational interpretations of the gricean maxims in the generation of referring expressions. Cognitive Science, 19(2):233–263.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John R Koza</author>
</authors>
<title>Genetic Programming: on the Programming of Computers by Means of Natural Selection.</title>
<date>1992</date>
<publisher>The MIT Press.</publisher>
<contexts>
<context position="1363" citStr="Koza, 1992" startWordPosition="214" endWordPosition="215"> programming is a form of evolutionary computing in which a meta program evolves another program to solve a problem. Creating by hand a program which solves the problem may be possible, but if the problem has many parameters which contribute to a solution’s quality, the program designer may miss some subtle interplay in favor of an expected solution. Genetic programming evolves a pool of programs to optimize a user supplied fitness function which gives some indication of how well a program performs on the problem. This report in no way attempt to fully explain genetic programming. See, e.g., (Koza, 1992) for a better understanding of genetic programming. The evolutionary computation toolkit ECJ available from http://www.cs. gmu.edu/˜eclab/projects/ecj/ was used for the genetic programming algorithm. 2 Functions The genetic programming algoritm had at its disposal the functions listed in Table 1. The function eqA tests whether two attribute values are equal. The functions add and remove operate on attribute lists, whereas the similarly named set add and set remove operate on entity sets. The function ifte is an if-then-else construct, and the function for is a foreach operator on sets of entit</context>
</contexts>
<marker>Koza, 1992</marker>
<rawString>John R. Koza. 1992. Genetic Programming: on the Programming of Computers by Means of Natural Selection. The MIT Press.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>