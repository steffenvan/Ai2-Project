<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000004">
<title confidence="0.995144">
An Efficient Compiler for Weighted Rewrite Rules
</title>
<author confidence="0.966723">
Mehryar Mohri Richard Sproat
</author>
<affiliation confidence="0.887263">
AT&amp;T Research Bell Laboratories
</affiliation>
<address confidence="0.9780775">
600 Mountain Avenue 700 Mountain Avenue
Murray Hill, 07974 NJ Murray Hill, 07974 NJ
</address>
<email confidence="0.999205">
mohri@research.att.com rwsObell—labs.com
</email>
<sectionHeader confidence="0.997378" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9997425625">
Context-dependent rewrite rules are used
in many areas of natural language and
speech processing. Work in computa-
tional phonology has demonstrated that,
given certain conditions, such rewrite
rules can be represented as finite-state
transducers (FSTs). We describe a new
algorithm for compiling rewrite rules into
FSTs. We show the algorithm to be sim-
pler and more efficient than existing al-
gorithms. Further, many of our appli-
cations demand the ability to compile
weighted rules into weighted FSTs, trans-
ducers generalized by providing transi-
tions with weights. We have extended
the algorithm to allow for this.
</bodyText>
<sectionHeader confidence="0.98629" genericHeader="keywords">
1. Motivation
</sectionHeader>
<bodyText confidence="0.994597333333334">
Rewrite rules are used in many areas of natural
language and speech processing, including syntax,
morphology, and phonology&apos;. In interesting ap-
plications, the number of rules can be very large.
It is then crucial to give a representation of these
rules that leads to efficient programs.
Finite-state transducers provide just such a
compact representation (Mohri, 1994). They are
used in various areas of natural language and
speech processing because their increased compu-
tational power enables one to build very large ma-
chines to model interestingly complex linguistic
phenomena. They also allow algebraic operations
such as union, composition, and projection which
are very useful in practice (Berstel, 1979; Eilen-
berg, 1974 1976). And, as originally shown by
Johnson (1972), rewrite rules can be modeled as
&apos;Parallel rewrite rules also have interesting applica-
tions in biology. In addition to their formal language
theory interest, systems such as those of Aristid Lin-
denmayer provide rich mathematical models for bio-
logical development (Rozenberg and Salomaa, 1980).
finite-state transducers, under the condition that
no rule be allowed to apply any more than a finite
number of times to its own output.
Kaplan and Kay (1994), or equivalently Kart-
tunen (1995), provide an algorithm for compiling
rewrite rules into finite-state transducers, under
the condition that they do not rewrite their non-
contextual part2. We here present a new algorithm
for compiling such rewrite rules which is both sim-
pler to understand and implement, and computa-
tionally more efficient. Clarity is important since,
as pointed out by Kaplan and Kay (1994), the rep-
resentation of rewrite rules by finite-state trans-
ducers involves many subtleties. Time and space
efficiency of the compilation are also crucial. Us-
ing naive algorithms can be very time consuming
and lead to very large machines (Liberman, 1994).
In some applications such as those related
to speech processing, one needs to use weighted
rewrite rules, namely rewrite rules to which
weights are associated. These weights are then
used at the final stage of applications to output the
most probable analysis. Weighted rewrite rules
can be compiled into weighted finite-state trans-
ducers, namely transducers generalized by pro-
viding transitions with a weighted output, under
the same context condition. These transducers
are very useful in speech processing (Pereira et
al., 1994). We briefly describe how we have aug-
mented our algorithm to handle the compilation
of weighted rules into weighted finite-state trans-
ducers.
In order to set the stage for our own contribu-
tion, we start by reviewing salient aspects of the
Kaplan and Kay algorithm.
</bodyText>
<footnote confidence="0.6135788">
&apos;The general question of the decidability of the
halting problem even for one-rule semi-Thue systems
is still open. Robert McNaughton (1994) has recently
made a positive conjecture about the class of the rules
without self overlap.
</footnote>
<page confidence="0.982458">
231
</page>
<equation confidence="0.839284363636364">
Prologue o
Id(Obligatory(0, &lt;i , &gt;))
Id(Rightcontest(p,&lt;,&gt;))
Replace
Id(Leftcontext(A,&lt;,&gt;))
Prologue-1
Id(E*;‹ 0 &lt;i 0&gt;&lt; &gt; E&apos;&gt;&lt; o) °
= id((E;0 &gt; p&gt;0E;0— &gt; E&apos;;0 n E;(3 &gt; P&gt;oE;o— &gt; E&apos;;0)‹) o
= [Id(E*&lt;,&gt;, 0)Opt(Id(&lt;0)0&lt;c&gt;c x
id((E&apos;6A&lt;0 E&apos;10 &lt; &lt; E*&lt;0 n E*&lt;0A&lt;0 —E &lt; &lt; Es0)&gt;) 0
(1)
</equation>
<figureCaption confidence="0.999513">
Figure 1: Compilation of obligatory left-to-right rules, using the KK algorithm.
</figureCaption>
<sectionHeader confidence="0.948242" genericHeader="introduction">
2. The KK Algorithm
</sectionHeader>
<bodyText confidence="0.992795">
The rewrite rules we consider here have the fol-
lowing general form:
</bodyText>
<equation confidence="0.90054">
—) (2)
</equation>
<bodyText confidence="0.972205506024096">
Such rules can be interpreted in the following way:
0 is to be replaced by whenever it is preceded
by A and followed by p. Thus, A and p represent
the left and right contexts of application of the
rules. In general, 0, 0, A and p are all regular
expressions over the alphabet of the rules. Several
types of rules can be considered depending on their
being obligatory or optional, and on their direction
of application, from left to right, right to left or
simultaneous application.
Consider an obligatory rewrite rule of the form
i/A p, which we will assume applies left to
right across the input string. Compilation of this
rule in the algorithm of Kaplan and Kay (1994)
(KK for short) involves composing together six
transducers, see Figure 1.
We use the notations of KK. In particular, E
denotes the alphabet, &lt; denotes the set of context
labeled brackets {&lt;a, &lt;i, &lt;c}, &gt; the set {&gt;a, &gt;i,
&gt;c}, and 0 an additional character representing
deleted material. Subscript symbols of an expres-
sion are symbols which are allowed to freely ap-
pear anywhere in the strings represented by that
expression. Given a regular expression r, Id(r) is
the identity transducer obtained from an automa-
ton A representing r by adding output labels to A
identical to its input labels.
The first transducer, Prologue, freely intro-
duces labeled brackets from the set {&lt; a ,
&gt;a, &gt;i , &gt;,} which are used by left and
right context transducers. The last transducer,
Prologue-1, erases all such brackets.
In such a short space, we can of course not
hope to do justice to the KK algorithm, and the
reader who is not familiar with it is urged to con-
sult their paper. However, one point that we do
need to stress is the following: while the con-
struction of Prologue, Prologue-1 and Replace
is fairly direct, construction of the other transduc-
ers is more complex, with each being derived via
the application of several levels of regular oper-
ations from the original expressions in the rules.
This clearly appears from the explicit expressions
we have indicated for the transducers. The con-
struction of the three other transducers involves
many operations including: two intersections of
automata, two distinct subtractions, and nine
complementations. Each subtraction involves an
intersection and a complementation algorithm3.
So, in the whole, four intersections and eleven
complementations need to be performed.
Intersection and complementation are classi-
cal automata algorithms (Aho et al., 1974; Aho
et al., 1986). The complexity of intersection is
quadratic. But the classical complementation al-
gorithm requires the input automaton to be de-
terministic. Thus, each of these 11 operations re-
quires first the determinization of the input. Such
operations can be very costly in the case of the
automata involved in the KK algorithm4.
In the following section we briefly describe a
new algorithm for compiling rewrite rules. For rea-
sons of space, we concentrate here on the com-
pilation of left-to-right obligatory rewrite rules.
However, our methods extend straightforwardly to
other modes of application (optional, right-to-left,
simultaneous, batch), or kinds of rules (two-level
rules) discussed by Kaplan and Kay (1994).
3A subtraction can of course also be performed di-
rectly by combining the two steps of intersection and
complementation, but the corresponding algorithm
has exactly the same cost as the total cost of the two
operations performed consecutively.
40ne could hope to find a more efficient way of de-
termining the complement of an automaton that would
not require determinization. However, this problem
is PSPACE-complete. Indeed, the regular expression
non-universality problem is a subproblem of comple-
mentation known to be PSPACE-complete (Garey and
Johnson, 1979, page 174), (Stockmeyer and Meyer,
1973). This problem also known as the emptiness
of complement problem has been extensively studied
(Aho et al., 1974, page 410-419).
</bodyText>
<page confidence="0.985872">
232
</page>
<sectionHeader confidence="0.93096" genericHeader="method">
3. New Algorithm
</sectionHeader>
<subsectionHeader confidence="0.967069">
3.1. Overview
</subsectionHeader>
<bodyText confidence="0.990296">
,In contrast to the KK algorithm which introduces
brackets everywhere only to restrict their occur-
rence subsequently, our algorithm introduces con-
text symbols just when and where they are needed.
Furthermore, the number of intermediate trans-
ducers necessary in the construction of the rules
is smaller than in the KK algorithm, and each of
the transducers can be constructed more directly
and efficiently from the primitive expressions of
the rule, 0, &apos;kb, A, p.
A transducer corresponding to the left-to-
right obligatory rule 0 0/A p can be ob-
tained by composition of five transducers:
</bodyText>
<listItem confidence="0.986297615384615">
r of o replace o o 12 (3)
1. The transducer r introduces in a string a
marker &gt; before every instance of p. For rea-
sons that will become clear we will notate this
as E*p E* &gt; p.
2. The transducer f introduces markers &lt;1 and
&lt;2 before each instance of 0 that is followed
by &gt;: (E U {&gt;})* &gt;--* U {&gt;})*{&lt;1&gt; &lt;2
}0 &gt;. In other words, this transducer Marks
just those 0 that occur before p.
3. The replacement transducer replace replaces
0 with tp in the context &lt;1 &gt;, simultane-
ously deleting &gt; in all positions (Figure 2).
</listItem>
<bodyText confidence="0.822300142857143">
Since &gt;, &lt;1, and &lt;2 need to be ignored when
determining an occurrence of 0, there are
loops over the transitions &gt;: c, &lt;1: c, &lt;2:
at all states of 0, or equivalently of the states
of the cross product transducer 0 x 0.
4. The transducer 11 admits only those strings
in which occurrences of &lt;1 are preceded
by A and deletes &lt;1 at such occurrences:
E*A E*A.
5. The transducer 12 admits only those strings
in which occurrences of &lt;2 are not preceded
by .\ and deletes &lt;2 at such occurrences:
E*A &lt;2--+ E*A.
Clearly the composition of these transducers leads
to the desired result. The construction of the
transducer replace is straightforward. In the fol-
lowing, we show that the construction of the other
four transducers is also very simple, and that it
only requires the determinization of 3 automata
and additional work linear (time and space) in the
size of the determinized automata.
</bodyText>
<subsectionHeader confidence="0.818493">
3.2. Markers
Markers of TYPE I
</subsectionHeader>
<bodyText confidence="0.999379">
Let us start by considering the problem of con-
structing what we shall call a TYPE 1 transducer,
</bodyText>
<figureCaption confidence="0.971479">
Figure 2: Replacement transducer replace in the
obligatory left-to-right case.
</figureCaption>
<bodyText confidence="0.974845428571429">
which inserts a marker after all prefixes of a string
that match a particular regular expression. Given
a regular expression (3 defined on the alphabet E,
one can construct, using classical algorithms (Aho
et al., 1986), a deterministic automaton a repre-
senting E*fl. As with the KK algorithm, one can
obtain from a a transducer x = Id(a) simply by
assigning to each transition the same output label
as the input label. We can easily transform x into
a new transducer r such that it inserts an arbi-
trary marker # after each occurrence of a pattern
described by #. To do so, we make final the non-
final states of x and for any final state q of x we
create a new state q&apos;, a copy of q. Thus, q&apos; has
the same transitions as q, and q&apos; is a final state.
We then make q non-final, remove the transitions
leaving q and add a transition from q to q&apos; with
input label the empty word c, and output #. Fig-
ures 3 and 4 illustrate the transformation of x into
T.
a:a c:c
</bodyText>
<figureCaption confidence="0.99685">
Figure 3: Final state q of x with entering and
leaving transitions.
Figure 4: States and transitions of r obtained by
modifications of those of x.
</figureCaption>
<page confidence="0.987101">
233
</page>
<bodyText confidence="0.978144837837838">
Proposition 1 Let a be a deterministic automa-
ton representing E.,3, then the transducer 7 ob-
taMed as described above is a transducer post-
marking occurrences of /3 in a string of E* by #.
Proof. The proof is based on the observa-
tion that a deterministic automaton representing
E*P is necessarily complete&apos;. Notice that non-
deterministic automata representing E*13 are not
necessarily complete. Let q be a state of a and let
u E E* be a string reaching q6. Let v be a string
described by the regular expression P. Then, for
any a E E, uav is in E*P. Hence, uav is accepted
by the automaton a, and, since a is deterministic,
there exists a transition labeled with a leaving q.
Thus, one can read any string u E E* using the
automaton a. Since by definition of a, the state
reached when reading a prefix u&apos; of u is final if
U&apos; E E*P, by construction, the transducer 7 in-
serts the symbol # after the prefix u&apos; if tz&apos; ends
with a pattern of /3. This ends the proof of the
proposition. 0
Markers of TYPE 2
In some cases, one wishes to check that any
occurrence of # in a string s is preceded (or fol-
lowed) by an occurrence of a pattern of P. We
shall say that the corresponding transducers are
of TYPE 2. They play the role of a filter. Here
again, they can be defined from a deterministic au-
tomaton representing E*T3. Figure 5 illustrates the
modifications to make from the automaton of fig-
ure 3. The symbols # should only appear at final
states and must be erased. The loop # : c added
at final states of Id(a) is enough for that purpose.
All states of the transducer are then made final
since any string conforming to this restriction is
acceptable: cf. the transducer /1 for A above.
#:£
</bodyText>
<figureCaption confidence="0.991153">
Figure 5: Filter transducer, TYPE 2.
</figureCaption>
<footnote confidence="0.956877833333333">
5An automaton A is complete if at any state q and
for any element a of the alphabet E there exists at least
one transition leaving q labeled with a. In the case of
deterministic automata, the transition is unique.
6We assume all states of a accessible. This is true
if a is obtained by determinization.
</footnote>
<note confidence="0.264879">
Markers of TYPE 3
</note>
<bodyText confidence="0.9273625">
In other cases, one wishes to check the reverse
constraint, that is that occurrences of # in the
string s are not preceded (or followed) by any oc-
currence of a pattern of p. The transformation
then simply consists of adding a loop at each non-
final state of Id(a), and of making all states final.
Thus, a state such as that of figure 6 is trans-
a:a c:c
</bodyText>
<figureCaption confidence="0.996563">
Figure 6: Non-final state q of a.
</figureCaption>
<bodyText confidence="0.9203435">
formed into that of figure 5. We shall say that the
corresponding transducer is of TYPE 3: cf. the
transducer /2 for A.
The construction of these transducers (TYPE
1-3) can be generalized in various ways. In par-
ticular:
</bodyText>
<listItem confidence="0.914325222222222">
• One can add several alternative markers
{#1, • • , #k} after each occurrence of a pat-
tern of P in a string. The result is then an
automaton with transitions labeled with, for
instance, #1, • • • , #k after each pattern of /3:
cf. transducer f for 0 above.
• Instead of inserting a symbol, one can delete
a symbol which would be necessarily present
after each occurrence of a pattern of [3.
</listItem>
<bodyText confidence="0.999380714285714">
For any regular expression a, de-
fine M arker(a ,type, deletions, insertions) as the
transducer of type type constructed as previously
described from a deterministic automaton repre-
senting a, insertions and deletions being, respec-
tively, the set of insertions and deletions the trans-
ducer makes.
</bodyText>
<construct confidence="0.9362602">
Proposition 2 For any regular expression
a, Marker(a,type,deletions,insertions) can be
constructed from a deterministic automaton rep-
resenting a in linear time and space with respect
to the size of this automaton.
</construct>
<bodyText confidence="0.9829685">
Proof. We proved in the previous proposition that
the modifications do indeed lead to the desired
transducer for TYPE 1. The proof for other cases
is similar. That the construction is linear in space
is clear since at most one additional transition and
state is created for final or non-final states7. The
overall time complexity of the construction is lin-
ear, since the construction of Id(a) is linear in the
/For TYPE 2 and TYPE 3, no state is added but only
a transition per final or non-final state.
</bodyText>
<page confidence="0.959196">
234
</page>
<equation confidence="0.98315825">
r = [reverse(Marker(E*reverse(p),1,{&gt;},0))] (4)
f= [reverse(Marker((EU {&gt;})*reverse(ck&gt; &gt;),1,{&lt;1,&lt;2},0))] (5)
11 = [Marker(E* A,2,0,{&lt;1.})}&lt;2&lt;2 (6)
12 = [Marker(E* A, 3,0, {&lt;2})] (7)
</equation>
<figureCaption confidence="0.999153">
Figure 7: Expressions of the r, f, 11, and /2 using Marker.
</figureCaption>
<bodyText confidence="0.996230142857143">
number of transitions of a and that other modifi-
cations consisting of adding new states and transi-
tions and making states final or not are also linear.
0
We just showed that M arker(a,type,de-
letions, insertions) can be constructed in a very
efficient way. Figure 7 gives the expressions of the
four transducers r, f, ii, and /2 using Marker.
Thus, these transducers can be constructed
very efficiently from deterministic automata repre-
senting&apos; E*reverse(p), (EU {&gt;})* reverse(0&gt; &gt;),
and E*A. The construction of r and f requires
two reverse operations. This is because these two
transducers insert material before p or cb.
</bodyText>
<sectionHeader confidence="0.97538" genericHeader="method">
4. Extension to Weighted Rules
</sectionHeader>
<bodyText confidence="0.994894117647059">
In many applications, in particular in areas re-
lated to speech, one wishes not only to give all
possible analyses of some input, but also to give
some measure of how likely each of the analyses is.
One can then generalize replacements by consid-
ering extended regular expressions, namely, using
the terminology of formal language theory, ratio-
nal power series (Berstel and Reutenauer, 1988;
Salomaa and Soittola, 1978).
The rational power series we consider here are
functions mapping E* to R4. U {00} which can be
described by regular expressions over the alphabet
(74 U loop x E. S = (4a)(2b)*(3b) is an example
of rational power series. It defines a function in
the following way: it associates a non-null num-
ber only with the strings recognized by the regu-
lar expression ab* b. This number is obtained by
adding the coefficients involved in the recognition
of the string. The value associated with abbb, for
instance, is (S, abbb) = 4 + 2 + 2 + 3 = 11.
In general, such extended regular expressions
can be redundant. Some strings can be matched
8As in the KK algorithm we denote by 0&gt; the set
of the strings described by containing possibly oc-
currences of &gt; at any position. In the same way, sub-
scripts such as &gt;:&gt; for a transducer r indicate that
loops by &gt;:&gt; are added at all states of r. We de-
note by reverse(a) the regular expression describing
exactly the reverse strings of a if a is a regular expres-
sion, or the reverse transducer of a if a is a transducer.
in different ways with distinct coefficients. The
value associated with those strings is then the min-
imum of all possible results. S&apos; = (2a)(3b)(4b) +
(5a)(3b*) matches abb with the different weights
2 + 3 + 4 = 9 and 5 + 3 + 3 = 11. The mini-
mum of the two is the value associated with abb:
(S&apos;, abb) = 9. Non-negative numbers in the defi-
nition of these power series are often interpreted
as the negative logarithm of probabilities. This
explains our choice of the operations: addition of
the weights along the string recognition and min,
since we are only interested in that result which
has the highest probability9.
Rewrite rules can be generalized by letting ik
be a rational power series. The result of the ap-
plication of a generalized rule to a string is then
a set of weighted strings which can be represented
by a weighted automaton. Consider for instance
the following rule, which states that an abstract
nasal, denoted N, is rewritten as in in the context
of a following labial:
</bodyText>
<equation confidence="0.856064">
N in/ [-I-labial] (8)
</equation>
<bodyText confidence="0.999936222222222">
Now suppose that this is only probabilistically
true, and that while ninety percent of the time
N does indeed become in in this environment,
about ten percent of the time in real speech it be-
comes n. Converting from probabilities to weights,
one would say that N becomes in with weight
= — log(0.9), and n with weight /6&apos; = — log(0.1),
in the stated environment. One could represent
this by the following rule:
</bodyText>
<equation confidence="0.67506">
N am A- fin/ [+labial] (9)
</equation>
<bodyText confidence="0.999596181818182">
We define Weighted finite-state transducers as
transducers such that in addition to input and out-
put labels, each transition is labeled with a weight.
The result of the application of a weighted
transducer to a string, or more generally to an
automaton is a weighted automaton. The corre-
sponding operation is similar to the unweighted
case. However, the weight of the transducer
and those of the string or automaton need to
be combined too, here added, during composition
(Pereira et al., 1994).
</bodyText>
<footnote confidence="0.9147095">
9Using the terminology of the theory of languages,
the functions we consider here are power series de-
fined on the tropical semiring (R-FUlool, min, +, oo, 0)
(Kuich and Salomaa, 1986).
</footnote>
<page confidence="0.995971">
235
</page>
<figure confidence="0.876926">
N:N/O
</figure>
<figureCaption confidence="0.999831">
Figure 8: Transducer representing the rule 9.
</figureCaption>
<bodyText confidence="0.9996165">
We have generalized the composition opera-
tion to the weighted case by introducing this com-
bination of weights. The algorithm we described
in the previous sections can then also be used to
compile weighted rewrite rules.
As an example, the obligatory rule 9 can be
represented by the weighted transducer of Fig-
ure 8 1°. The following theorem extends to the
weighted case the assertion proved by Kaplan and
Kay (1994).
</bodyText>
<construct confidence="0.532019">
Theorem 1 A weighted rewrite rule of the type
defined above that does not rewrite its non-
contextual part can be represented by a weighted
finite-state transducer.
</construct>
<bodyText confidence="0.9994773">
Proof. The construction we described in the pre-
vious section also provides a constructive proof
of this theorem in the unweighted case. In case
is a power series, one simply needs to use in
that construction a weighted finite-state trans-
ducer representing O. By definition of composition
of weighted transducers, or multiplication of power
series, the weights are then used in a way consis-
tent with the definition of the weighted context-
dependent rules. 0
</bodyText>
<sectionHeader confidence="0.993567" genericHeader="evaluation">
5. Experiments
</sectionHeader>
<bodyText confidence="0.99998575">
In order to compare the performance of the al-
gorithm presented here with KK, we timed both
algorithms on the compilation of individual rules
taken from the following set (k E [0, 10]):
</bodyText>
<equation confidence="0.958204">
a —&gt; Ck (10)
(11)
</equation>
<bodyText confidence="0.991289135593221">
10We here use the symbol to denote all letters
different from b, m, n, p, and N.
In other words we tested twenty two rules where
the left context or the right context is varied in
length from zero to ten occurrences of c. For our
experiments, we used the alphabet of a realistic
application, the text analyzer for the Bell Labora-
tories German text-to-speech system consisting of
194 labels. All tests were run on a Silicon Graph-
ics IRIS Indigo 4000, 100 MhZ IP20 Processor,
128 Mbytes RAM, running IRIX 5.2. Figure 9
shows the relative performance of the two algo-
rithms for the left context: apparently the per-
formance of both algorithms is roughly linear in
the length of the left context, but KK has a worse
constant, due to the larger number of operations
involved. Figure 10 shows the equivalent data for
the right context. At first glance the data looks
similar to that for the left context, until one no-
tices that in Figure 10 we have plotted the time on
a log scale: the KK algorithm is hyperexponential.
What is the reason for this performance degra-
dation in the right context? The culprits turn
out to be the two intersectands in the expression
of Rightcontext(p,&lt;,&gt;) in Figure 1. Consider
for example the righthand intersectand, namely
o&gt; p&gt;0E*&gt;0— &gt; E, which is the complement
of E;0 &gt; p&gt;0E;0— &gt; E. As previously in-
dicated, the complementation algorithm, requires
determinization, and the determinization of au-
tomata representing expressions of the form E* a,
where a is a regular expression, is often very ex-
pensive, specially when the expression a is already
complex, as in this case.
Figure 11 plots the behavior of determiniza-
tion on the expression E&apos;;0 &gt; p&gt;oE*&gt;0— &gt; E*&gt;o
for each of the rules in the set a —&gt; b Ck ,
(k E [0,10]). On the horizontal axis is the num-
ber of arcs of the non-deterministic input machine,
and on the vertical axis the log of the number of
arcs of the deterministic machine, i.e. the ma-
chine result of the determinization algorithm with-
out using any minimization. The perfect linearity
indicates an exponential time and space behav-
ior, and this in turn explains the observed differ-
ence in performance. In contrast, the construction
of the right context machine in our algorithm in-
volves only the single determinization of the au-
tomaton representing E* p, and thus is much less
expensive. The comparison just discussed involves
a rather artificial ruleset, but the differences in
performance that we have highlighted show up in
real applications. Consider two sets of pronun-
ciation rules from the Bell Laboratories German
text-to-speech system: the size of the alphabet for
this ruleset is 194, as noted above. The first rule-
set, consisting of pronunciation rules for the ortho-
graphic vowel &lt;O&gt; contains twelve rules, and the
second ruleset, which deals with the orthographic
</bodyText>
<page confidence="0.978166">
236
</page>
<figure confidence="0.9745898">
• KM( elgorithm
O New algorithm
I I I
O 2 4 0
L•nptli of UM Carg4/2
</figure>
<figureCaption confidence="0.943973666666667">
Figure 9: Compilation times for rules of the form
a —+ b/ ck (k E [0,10]).
Figure 10: Compilation times for rules of the form
</figureCaption>
<figure confidence="0.994666571428571">
a b I Ck (k E [0,10]).
8-
q
• KEA sigorithm
o New 4190400&amp;quot;
2 4 10
1.40011101A101t Context
</figure>
<bodyText confidence="0.998594285714286">
vowel &lt;a&gt; contains twenty five rules. In the ac-
tual application of the rule compiler to these rules,
one compiles the individual rules in each ruleset
one by one, and composes them together in the
order written, compacts them after each composi-
tion, and derives a single transducer for each set.
When done off-line, these operations of compo-
</bodyText>
<tableCaption confidence="0.999915">
Table 1: Comparison in a real example.
</tableCaption>
<table confidence="0.839521">
Rules KK
time space time space
(s) states arcs (s) states arcs
&lt;O&gt; 62 412 50,475 47 394 47,491
&lt;a&gt; 284 1,939 215,721 240 1,927 213,408
</table>
<bodyText confidence="0.99956125">
sition and compaction dominate the time corre-
sponding to the construction of the transducer for
each individual rule. The difference between the
two algorithms appears still clearly for these two
sets of rules. Table 1 shows for each algorithm
the times in seconds for the overall construction,
and the number of states and arcs of the output
transducers.
</bodyText>
<sectionHeader confidence="0.998458" genericHeader="conclusions">
6. Conclusion
</sectionHeader>
<bodyText confidence="0.999971052631579">
We briefly described a new algorithm for compiling
context-dependent rewrite rules into finite-state
transducers. Several additional methods can be
used to make this algorithm even more efficient.
The automata determinizations needed for
this algorithm are of a specific type. They repre-
sent expressions of the type E*0 where 0 is a reg-
ular expression. Given a deterministic automaton
representing 0, such determinizations can be per-
formed in a more efficient way using failure func-
tions (Mohri, 1995). Moreover, the corresponding
determinization is independent of E which can be
very large in some applications. It only depends
on the alphabet of the automaton representing 0.
One can devise an on-the-fly implementation
of the composition algorithm leading to the final
transducer representing a rule. Only the neces-
sary part of the intermediate transducers is then
expanded for a given input (Pereira et al., 1994).
The resulting transducer representing a rule
is often subsequentiable or p-subsequentiable. It
can then be determinized and minimized (Mohri,
1994). This both makes the use of the transducer
time efficient and reduces its size.
We also indicated an extension of the theory
of rule-compilation to the case of weighted rules,
which compile into weighted finite-state transduc-
ers. Many algorithms used in the finite-state the-
ory and in their applications to natural language
processing can be extended in the same way.
To date the main serious application of this
compiler has been to developing text-analyzers
for text-to-speech systems at Bell Laboratories
(Sproat, 1996): partial to more-or-less complete
analyzers have been built for Spanish, Italian,
French, Romanian, German, Russian, Mandarin
and Japanese. However, we hope to also be able to
use the compiler in serious applications in speech
</bodyText>
<figure confidence="0.7091638">
II
New
237
BOO 810 820 830
• arca in Pbar S
</figure>
<figureCaption confidence="0.999126">
Figure 11: Number of arcs in the_ non-
</figureCaption>
<bodyText confidence="0.9989232">
deterministic automaton r representing PS =
E&gt;o &gt; P&gt;0E;0— &gt; E*;0 versus the log of the num-
ber of arcs in the automaton obtained by deter-
minization of T.
recognition in the future.
</bodyText>
<sectionHeader confidence="0.998406" genericHeader="acknowledgments">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.9999146">
We wish to thank several colleagues of AT&amp;T/Bell
Labs, in particular Fernando Pereira and Michael
Riley for stimulating discussions about this work
and Bernd Möbius for providing the German pro-
nunciation rules cited herein.
</bodyText>
<sectionHeader confidence="0.99947" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999755929577465">
Alfred V. Aho, John E. Hoperoft, and Jeffrey D.
Ullman. 1974. The design and analysis of
computer algorithms. Addison Wesley: Read-
ing, MA.
Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman.
1986. Compilers, Principles, Techniques and
Tools. Addison Wesley: Reading, MA.
Jean Berstel and Christophe Reutenauer.
1988. Rational Series and Their Languages.
Springer-Verlag: Berlin-New York.
Jean Berstel. 1979. Transductions and Context-
Free Languages. Teubner Studienbucher:
Stuttgart.
Samuel Eilenberg. 1974-1976. Automata, Lan-
guages and Machines, volume A-B. Academic
Press.
Michael R. Garey and David S. Johnson. 1979.
Computers and Intractability. Freeman and
Company, New York.
C. Douglas Johnson. 1972. Formal Aspects of
Phonological Description. Mouton, Mouton,
The Hague.
Ronald M. Kaplan and Martin Kay. 1994. Regu-
lar models of phonological rule systems. Com-
putational Linguistics, 20(3).
Lauri Karttunen. 1995. The replace operator. In
33rd Meeting of the Association for Compu-
tational Linguistics (ACL 95), Proceedings of
the Conference, MIT, Cambridge, Massachus-
setts. ACL.
Wener Kuich and Arto Salomaa. 1986. Semir-
ings, Automata, Languages. Springer-Verlag:
Berlin-New York.
Mark Liberman. 1994. Commentary on kaplan
and kay. Computational Linguistics, 20(3).
Robert McNaughton. 1994. The uniform halt-
ing problem for one-rule semi-thue systems.
Technical Report 94-18, Department of Com-
puter Science, Rensselaer Polytechnic Insti-
tute, Troy, New York.
Mehryar Mohri. 1994. Compact representations
by finite-state transducers. In 32nd Meeting of
the Association for Computational Linguistics
(ACL 9.4), Proceedings of the Conference, Las
Cruces, New Mexico. ACL.
Mehryar Mohri. 1995. Matching patterns of an
automaton. Lecture Notes in Computer Sci-
ence, 937.
Fernando C. N. Pereira, Michael Riley, and
Richard Sproat. 1994. Weighted rational
transductions and their application to human
language processing. In ARPA Workshop on
Human Language Technology. Advanced Re-
search Projects Agency.
Grzegorz Rozenberg and Arto Salomaa. 1980.
The Mathematical Theory of L Systems. Aca-
demic Press, New York.
Arto Salomaa and Matti Soittola. 1978.
Automata-Theoretic Aspects of Formal Power
Series. Springer-Verlag: Berlin-New York.
Richard Sproat. 1996. Multilingual text analy-
sis for text-to-speech synthesis. In Proceed-
ings of the ECAI-96 Workshop on Extended
Finite State Models of Language, Budapest,
Hungary. European Conference on Artificial
Intelligence.
L. J. Stockmeyer and A. R. Meyer. 1973. Word
problems requiring exponential time. In Pro-
ceedings of the 5th Annual ACM Sympo-
sium on Theory of Computing. Association for
Computing Machinery, New York, 1-9.
</reference>
<page confidence="0.997052">
238
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.000011">
<title confidence="0.99993">An Efficient Compiler for Weighted Rewrite Rules</title>
<author confidence="0.999159">Mehryar Mohri Richard Sproat</author>
<affiliation confidence="0.999988">AT&amp;T Research Bell Laboratories</affiliation>
<address confidence="0.9978125">600 Mountain Avenue 700 Mountain Avenue Murray Hill, 07974 NJ Murray Hill, 07974 NJ</address>
<email confidence="0.996768">mohri@research.att.comrwsObell—labs.com</email>
<abstract confidence="0.973303273015874">Context-dependent rewrite rules are used in many areas of natural language and speech processing. Work in computational phonology has demonstrated that, given certain conditions, such rewrite rules can be represented as finite-state transducers (FSTs). We describe a new algorithm for compiling rewrite rules into FSTs. We show the algorithm to be simpler and more efficient than existing algorithms. Further, many of our applications demand the ability to compile into transducers generalized by providing transitions with weights. We have extended the algorithm to allow for this. 1. Motivation Rewrite rules are used in many areas of natural language and speech processing, including syntax, morphology, and phonology&apos;. In interesting applications, the number of rules can be very large. It is then crucial to give a representation of these rules that leads to efficient programs. Finite-state transducers provide just such a compact representation (Mohri, 1994). They are used in various areas of natural language and speech processing because their increased computational power enables one to build very large machines to model interestingly complex linguistic phenomena. They also allow algebraic operations such as union, composition, and projection which are very useful in practice (Berstel, 1979; Eilenberg, 1974 1976). And, as originally shown by Johnson (1972), rewrite rules can be modeled as &apos;Parallel rewrite rules also have interesting applications in biology. In addition to their formal language theory interest, systems such as those of Aristid Lindenmayer provide rich mathematical models for biological development (Rozenberg and Salomaa, 1980). finite-state transducers, under the condition that no rule be allowed to apply any more than a finite number of times to its own output. Kaplan and Kay (1994), or equivalently Karttunen (1995), provide an algorithm for compiling rewrite rules into finite-state transducers, under the condition that they do not rewrite their non- We here present a new algorithm for compiling such rewrite rules which is both simpler to understand and implement, and computationally more efficient. Clarity is important since, as pointed out by Kaplan and Kay (1994), the representation of rewrite rules by finite-state transmany subtleties. Time and efficiency of the compilation are also crucial. Using naive algorithms can be very time consuming and lead to very large machines (Liberman, 1994). In some applications such as those related speech processing, one needs to use rewrite rules, namely rewrite rules to which weights are associated. These weights are then used at the final stage of applications to output the most probable analysis. Weighted rewrite rules be compiled into transducers, namely transducers generalized by providing transitions with a weighted output, under the same context condition. These transducers are very useful in speech processing (Pereira et al., 1994). We briefly describe how we have augmented our algorithm to handle the compilation of weighted rules into weighted finite-state transducers. In order to set the stage for our own contribution, we start by reviewing salient aspects of the Kaplan and Kay algorithm. &apos;The general question of the decidability of the halting problem even for one-rule semi-Thue systems is still open. Robert McNaughton (1994) has recently made a positive conjecture about the class of the rules overlap. 231 Prologue o Id(Obligatory(0, &lt;i , &gt;)) Id(Rightcontest(p,&lt;,&gt;)) Replace Id(Leftcontext(A,&lt;,&gt;)) 0&lt;i 0&gt;&lt; &gt; E&apos;&gt;&lt; o) ° &gt; n E;(3 &gt; o x &lt; &lt; n &lt; &lt; 0 (1) Figure 1: Compilation of obligatory left-to-right rules, using the KK algorithm. 2. The KK Algorithm The rewrite rules we consider here have the following general form: —) (2) Such rules can be interpreted in the following way: 0 is to be replaced by whenever it is preceded A and followed by A and the left and right contexts of application of the In general, A and all regular expressions over the alphabet of the rules. Several types of rules can be considered depending on their being obligatory or optional, and on their direction of application, from left to right, right to left or simultaneous application. Consider an obligatory rewrite rule of the form we will assume applies left to right across the input string. Compilation of this rule in the algorithm of Kaplan and Kay (1994) (KK for short) involves composing together six transducers, see Figure 1. We use the notations of KK. In particular, E denotes the alphabet, &lt; denotes the set of context brackets &lt;i, &lt;c}, &gt; set &gt;i, &gt;c}, and 0 an additional character representing deleted material. Subscript symbols of an expression are symbols which are allowed to freely appear anywhere in the strings represented by that Given a regular expression r, the identity transducer obtained from an automaton A representing r by adding output labels to A identical to its input labels. first transducer, introduces labeled brackets from the set {&lt; a , &gt;a, &gt;i , &gt;,} which are used by left and right context transducers. The last transducer, all such brackets. In such a short space, we can of course not hope to do justice to the KK algorithm, and the reader who is not familiar with it is urged to consult their paper. However, one point that we do need to stress is the following: while the conof and is fairly direct, construction of the other transducers is more complex, with each being derived via the application of several levels of regular operations from the original expressions in the rules. This clearly appears from the explicit expressions we have indicated for the transducers. The construction of the three other transducers involves many operations including: two intersections of automata, two distinct subtractions, and nine complementations. Each subtraction involves an and a complementation So, in the whole, four intersections and eleven complementations need to be performed. Intersection and complementation are classical automata algorithms (Aho et al., 1974; Aho et al., 1986). The complexity of intersection is quadratic. But the classical complementation algorithm requires the input automaton to be deterministic. Thus, each of these 11 operations requires first the determinization of the input. Such operations can be very costly in the case of the involved in the KK In the following section we briefly describe a new algorithm for compiling rewrite rules. For reasons of space, we concentrate here on the compilation of left-to-right obligatory rewrite rules. However, our methods extend straightforwardly to other modes of application (optional, right-to-left, simultaneous, batch), or kinds of rules (two-level rules) discussed by Kaplan and Kay (1994). subtraction can of course also be performed dicombining the two steps of intersection and complementation, but the corresponding algorithm has exactly the same cost as the total cost of the two operations performed consecutively. could hope to find a more efficient way of determining the complement of an automaton that would not require determinization. However, this problem PSPACE-complete. Indeed, the regular non-universality problem is a subproblem of complementation known to be PSPACE-complete (Garey and Johnson, 1979, page 174), (Stockmeyer and Meyer, This problem also known as emptiness complement problem been extensively studied et al., page 410-419). 232 3. New Algorithm 3.1. Overview ,In contrast to the KK algorithm which introduces brackets everywhere only to restrict their occurrence subsequently, our algorithm introduces context symbols just when and where they are needed. Furthermore, the number of intermediate transducers necessary in the construction of the rules is smaller than in the KK algorithm, and each of the transducers can be constructed more directly and efficiently from the primitive expressions of rule, &apos;kb, transducer corresponding to the left-toobligatory rule be tained by composition of five transducers: of o replace o o 12 1. The transducer r introduces in a string a &gt; before every instance of reasons that will become clear we will notate this E*p E* &gt; The transducer markers &lt;1 and each instance of is followed &gt;: (E U {&gt;})* &gt;--* U &lt;2 &gt;. other words, this transducer Marks those occur before The replacement transducer the context &lt;1 &gt;, simultaneously deleting &gt; in all positions (Figure 2). &gt;, &lt;1, and to be ignored when an occurrence of are loops over the transitions &gt;: c, &lt;1: c, &lt;2: all states of equivalently of the states the cross product transducer 0. 4. The transducer 11 admits only those strings in which occurrences of &lt;1 are preceded by A and deletes &lt;1 at such occurrences: E*A E*A. 5. The transducer 12 admits only those strings which occurrences of not preceded .\ and deletes such occurrences: E*A &lt;2--+ E*A. Clearly the composition of these transducers leads to the desired result. The construction of the straightforward. In the following, we show that the construction of the other four transducers is also very simple, and that it only requires the determinization of 3 automata and additional work linear (time and space) in the size of the determinized automata. 3.2. Markers of Let us start by considering the problem of conwhat we shall call a transducer, 2: Replacement transducer the obligatory left-to-right case. which inserts a marker after all prefixes of a string that match a particular regular expression. Given regular expression on the alphabet E, one can construct, using classical algorithms (Aho et al., 1986), a deterministic automaton a representing E*fl. As with the KK algorithm, one can from a a transducer x = by assigning to each transition the same output label as the input label. We can easily transform x into a new transducer r such that it inserts an arbitrary marker # after each occurrence of a pattern by do so, we make final the nonstates of x and for any final state x we a new state copy of same transitions as a final state. then make remove the transitions add a transition from label the empty word output #. Figures 3 and 4 illustrate the transformation of x into T. a:a c:c 3: Final state x with entering and leaving transitions. Figure 4: States and transitions of r obtained by modifications of those of x. 233 1 a be a deterministic automarepresenting the transducer obtaMed as described above is a transducer postoccurrences of /3 in a string of #. Proof. The proof is based on the observation that a deterministic automaton representing E*P is necessarily complete&apos;. Notice that nonautomata representing are not complete. Let a state of a and let E E* be a string reaching Let v be a string described by the regular expression P. Then, for any a E E, uav is in E*P. Hence, uav is accepted by the automaton a, and, since a is deterministic, exists a transition labeled with a leaving Thus, one can read any string u E E* using the automaton a. Since by definition of a, the state reached when reading a prefix u&apos; of u is final if E E*P, by construction, the transducer inserts the symbol # after the prefix u&apos; if tz&apos; ends with a pattern of /3. This ends the proof of the proposition. 0 of In some cases, one wishes to check that any of # in a string preceded (or followed) by an occurrence of a pattern of P. We shall say that the corresponding transducers are They play the role of a filter. Here again, they can be defined from a deterministic automaton representing E*T3. Figure 5 illustrates the modifications to make from the automaton of figure 3. The symbols # should only appear at final and must be erased. The loop # : final states of enough for that purpose. All states of the transducer are then made final since any string conforming to this restriction is cf. the transducer for A above. 5: Filter transducer, automaton A is complete if at any state for any element a of the alphabet E there exists at least transition leaving with a. In the case of deterministic automata, the transition is unique. assume all states of a accessible. This is true if a is obtained by determinization. of In other cases, one wishes to check the reverse constraint, that is that occurrences of # in the not preceded (or followed) by any ocof a pattern of transformation then simply consists of adding a loop at each nonstate of of making all states final. a state such as that of figure transa:a c:c state a. formed into that of figure 5. We shall say that the transducer is of cf. the for A. construction of these transducers 1-3) can be generalized in various ways. In particular: • One can add several alternative markers • • , each occurrence of a patof a string. The result is then an automaton with transitions labeled with, for transducer • Instead of inserting a symbol, one can delete a symbol which would be necessarily present each occurrence of a pattern of For any regular expression a, dearker(a ,type, deletions, insertions) the transducer of type type constructed as previously described from a deterministic automaton repreinsertions respectively, the set of insertions and deletions the transducer makes. 2 any regular expression a, Marker(a,type,deletions,insertions) can be constructed from a deterministic automaton representing a in linear time and space with respect to the size of this automaton. Proof. We proved in the previous proposition that the modifications do indeed lead to the desired for 1. proof for other cases is similar. That the construction is linear in space is clear since at most one additional transition and is created for final or non-final The overall time complexity of the construction is linsince the construction of linear in the and no state is added but only a transition per final or non-final state. 234 r = [reverse(Marker(E*reverse(p),1,{&gt;},0))] (4) 11 = (6) 12 = A, 7: Expressions of the r, /2 using number of transitions of a and that other modifications consisting of adding new states and transitions and making states final or not are also linear. 0 just showed that arker(a,type,deinsertions) be constructed in a very efficient way. Figure 7 gives the expressions of the transducers f, and using Thus, these transducers can be constructed very efficiently from deterministic automata repre- (EU {&gt;})* &gt;), E*A. The construction of r and two reverse operations. This is because these two insert material p 4. Extension to Weighted Rules In many applications, in particular in areas related to speech, one wishes not only to give all possible analyses of some input, but also to give some measure of how likely each of the analyses is. One can then generalize replacements by considexpressions, namely, using terminology of formal language theory, ratiopower series and Reutenauer, 1988; Salomaa and Soittola, 1978). The rational power series we consider here are mapping E* to U {00} which can be described by regular expressions over the alphabet U loop x E. = is an example of rational power series. It defines a function in the following way: it associates a non-null number only with the strings recognized by the reguexpression b. number is obtained by adding the coefficients involved in the recognition the string. The value associated with is abbb) = + 2 + 2 + 3 = 11. In general, such extended regular expressions can be redundant. Some strings can be matched in the KK algorithm we denote by 0&gt; the set of the strings described by containing possibly occurrences of &gt; at any position. In the same way, subscripts such as &gt;:&gt; for a transducer r indicate that loops by &gt;:&gt; are added at all states of r. We deby regular expression describing exactly the reverse strings of a if a is a regular expression, or the reverse transducer of a if a is a transducer. in different ways with distinct coefficients. The value associated with those strings is then the minof all possible results. = + matches the different weights 2 + 3 + 4 = 9 and 5 + 3 + 3 = 11. The miniof the two is the value associated with abb) = Non-negative numbers in the definition of these power series are often interpreted as the negative logarithm of probabilities. This explains our choice of the operations: addition of weights along the string recognition and since we are only interested in that result which the highest rules can be generalized by letting be a rational power series. The result of the application of a generalized rule to a string is then set of strings can be represented a automaton. for instance the following rule, which states that an abstract denoted rewritten as in in the context of a following labial: in/ [-I-labial] suppose that this is only true, and that while ninety percent of the time indeed become in in this environment, about ten percent of the time in real speech it becomes n. Converting from probabilities to weights, would say that in with weight — log(0.9), and n with weight = — log(0.1), in the stated environment. One could represent this by the following rule: am Afin/ [+labial] define finite-state transducers transducers such that in addition to input and output labels, each transition is labeled with a weight. The result of the application of a weighted transducer to a string, or more generally to an automaton is a weighted automaton. The corresponding operation is similar to the unweighted case. However, the weight of the transducer and those of the string or automaton need to be combined too, here added, during composition (Pereira et al., 1994). the terminology of the theory of languages, the functions we consider here are power series deon the semiring (R-FUlool, +, oo, 0) (Kuich and Salomaa, 1986). 235 N:N/O Figure 8: Transducer representing the rule 9. We have generalized the composition operation to the weighted case by introducing this combination of weights. The algorithm we described in the previous sections can then also be used to compile weighted rewrite rules. As an example, the obligatory rule 9 can be represented by the weighted transducer of Fig- 8 The following theorem extends to the weighted case the assertion proved by Kaplan and Kay (1994). 1 weighted rewrite rule of the type defined above that does not rewrite its noncontextual part can be represented by a weighted finite-state transducer. Proof. The construction we described in the previous section also provides a constructive proof of this theorem in the unweighted case. In case is a power series, one simply needs to use in that construction a weighted finite-state transducer representing O. By definition of composition of weighted transducers, or multiplication of power series, the weights are then used in a way consistent with the definition of the weighted contextdependent rules. 0 In order to compare the performance of the algorithm presented here with KK, we timed both algorithms on the compilation of individual rules from the following set [0, —&gt; (10) (11) here use the symbol to denote all letters from n, p, and In other words we tested twenty two rules where the left context or the right context is varied in from zero to ten occurrences of our experiments, we used the alphabet of a realistic application, the text analyzer for the Bell Laboratories German text-to-speech system consisting of 194 labels. All tests were run on a Silicon Graphics IRIS Indigo 4000, 100 MhZ IP20 Processor, Mbytes RAM, running Figure 9 shows the relative performance of the two algorithms for the left context: apparently the perof both algorithms is in the length of the left context, but KK has a worse constant, due to the larger number of operations involved. Figure 10 shows the equivalent data for the right context. At first glance the data looks similar to that for the left context, until one notices that in Figure 10 we have plotted the time on a log scale: the KK algorithm is hyperexponential. What is the reason for this performance degradation in the right context? The culprits turn out to be the two intersectands in the expression Figure 1. Consider forexample the righthandintersectand, namely &gt; E, which is the complement &gt; &gt; E. As previously indicated, the complementation algorithm, requires determinization, and the determinization of automata representing expressions of the form E* a, where a is a regular expression, is often very expensive, specially when the expression a is already complex, as in this case. 11 plots the behaviorof determinizaon the expression &gt; &gt; each of the rules in the set a —&gt; Ck , [0,10]). the horizontal axis is the number of arcs of the non-deterministic input machine, and on the vertical axis the log of the number of arcs of the deterministic machine, i.e. the machine result of the determinization algorithm without using any minimization. The perfect linearity indicates an exponential time and space behavior, and this in turn explains the observed difference in performance. In contrast, the construction of the right context machine in our algorithm involves only the single determinization of the aurepresenting p, thus is much less expensive. The comparison just discussed involves a rather artificial ruleset, but the differences in performance that we have highlighted show up in applications. Consider two pronunciation rules from the Bell Laboratories German text-to-speech system: the size of the alphabet for this ruleset is 194, as noted above. The first ruleset, consisting of pronunciation rules for the orthovowel twelve rules, and the second ruleset, which deals with the orthographic 236 • KM( elgorithm O New algorithm I I I 2 4 L•nptli of UM Carg4/2 Figure 9: Compilation times for rules of the form —+ ck (k [0,10]). Figure 10: Compilation times for rules of the form I (k [0,10]). q • KEA sigorithm New 4 1.40011101A101t Context vowel &lt;a&gt; contains twenty five rules. In the actual application of the rule compiler to these rules, one compiles the individual rules in each ruleset one by one, and composes them together in the order written, compacts them after each composition, and derives a single transducer for each set. done off-line, these operations of compo- Table 1: Comparison in a real example. time space time space (s) states arcs (s) states arcs &lt;O&gt; 62 412 50,475 47 394 47,491 &lt;a&gt; 284 1,939 215,721 240 1,927 213,408 sition and compaction dominate the time corresponding to the construction of the transducer for each individual rule. The difference between the two algorithms appears still clearly for these two sets of rules. Table 1 shows for each algorithm the times in seconds for the overall construction, and the number of states and arcs of the output transducers. 6. Conclusion We briefly described a new algorithm for compiling context-dependent rewrite rules into finite-state transducers. Several additional methods can be used to make this algorithm even more efficient. The automata determinizations needed for this algorithm are of a specific type. They represent expressions of the type E*0 where 0 is a regular expression. Given a deterministic automaton representing 0, such determinizations can be perin a more efficient way using func- 1995). Moreover, the corresponding determinization is independent of E which can be very large in some applications. It only depends on the alphabet of the automaton representing 0. can devise an of the composition algorithm leading to the final transducer representing a rule. Only the necessary part of the intermediate transducers is then expanded for a given input (Pereira et al., 1994). The resulting transducer representing a rule is often subsequentiable or p-subsequentiable. It can then be determinized and minimized (Mohri, 1994). This both makes the use of the transducer time efficient and reduces its size. We also indicated an extension of the theory of rule-compilation to the case of weighted rules, which compile into weighted finite-state transducers. Many algorithms used in the finite-state theory and in their applications to natural language processing can be extended in the same way. To date the main serious application of this compiler has been to developing text-analyzers for text-to-speech systems at Bell Laboratories (Sproat, 1996): partial to more-or-less complete analyzers have been built for Spanish, Italian, French, Romanian, German, Russian, Mandarin and Japanese. However, we hope to also be able to use the compiler in serious applications in speech II New 237 BOO 810 820 830 • arca in Pbar S 11: Number of arcs in the_ nonautomaton = &gt; &gt; versus the log of the number of arcs in the automaton obtained by deterof recognition in the future. Acknowledgements We wish to thank several colleagues of AT&amp;T/Bell Labs, in particular Fernando Pereira and Michael Riley for stimulating discussions about this work and Bernd Möbius for providing the German pronunciation rules cited herein.</abstract>
<note confidence="0.703122193548387">References Alfred V. Aho, John E. Hoperoft, and Jeffrey D. 1974. design and analysis of algorithms. Wesley: Reading, MA. Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. Principles, Techniques and Wesley: Reading, MA. Jean Berstel and Christophe Reutenauer. Series and Their Languages. Springer-Verlag: Berlin-New York. Berstel. 1979. and Context- Languages. Studienbucher: Stuttgart. Eilenberg. 1974-1976. Lanand Machines, A-B. Academic Press. Michael R. Garey and David S. Johnson. 1979. and Intractability. and Company, New York. Douglas Johnson. 1972. Aspects of Description. Mouton, The Hague. Ronald M. Kaplan and Martin Kay. 1994. Regumodels of phonological rule systems. Com- Linguistics, Lauri Karttunen. 1995. The replace operator. In of the Association for Computational Linguistics (ACL 95), Proceedings of the Conference, MIT, Cambridge, Massachus- Wener Kuich and Arto Salomaa. 1986. Semir-</note>
<address confidence="0.525534">Automata, Languages. Berlin-New York.</address>
<author confidence="0.97328">Commentary on kaplan kay Linguistics</author>
<author confidence="0.97328">Robert McNaughton</author>
<abstract confidence="0.891922">ing problem for one-rule semi-thue systems.</abstract>
<note confidence="0.937794777777778">Technical Report 94-18, Department of Computer Science, Rensselaer Polytechnic Institute, Troy, New York. Mehryar Mohri. 1994. Compact representations finite-state transducers. In 32nd of the Association for Computational Linguistics (ACL 9.4), Proceedings of the Conference, Las New Mexico. Mehryar Mohri. 1995. Matching patterns of an</note>
<title confidence="0.898276">Notes in Computer Sci-</title>
<author confidence="0.90967">Weighted rational</author>
<abstract confidence="0.405679">transductions and their application to human processing. In Workshop on Language Technology. Research Projects Agency.</abstract>
<note confidence="0.871169055555555">Grzegorz Rozenberg and Arto Salomaa. 1980. Mathematical Theory of L Systems. Academic Press, New York. Arto Salomaa and Matti Soittola. 1978. Aspects of Formal Berlin-New York. Richard Sproat. 1996. Multilingual text analyfor text-to-speech synthesis. In Proceedings of the ECAI-96 Workshop on Extended State Models of Language, Hungary. European Conference on Artificial Intelligence. L. J. Stockmeyer and A. R. Meyer. 1973. Word requiring exponential time. In Proof the Annual ACM Sympoon Theory of Computing. for Computing Machinery, New York, 1-9. 238</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Alfred V Aho</author>
<author>John E Hoperoft</author>
<author>Jeffrey D Ullman</author>
</authors>
<title>The design and analysis of computer algorithms.</title>
<date>1974</date>
<publisher>Addison Wesley:</publisher>
<location>Reading, MA.</location>
<contexts>
<context position="6711" citStr="Aho et al., 1974" startWordPosition="1073" endWordPosition="1076">rived via the application of several levels of regular operations from the original expressions in the rules. This clearly appears from the explicit expressions we have indicated for the transducers. The construction of the three other transducers involves many operations including: two intersections of automata, two distinct subtractions, and nine complementations. Each subtraction involves an intersection and a complementation algorithm3. So, in the whole, four intersections and eleven complementations need to be performed. Intersection and complementation are classical automata algorithms (Aho et al., 1974; Aho et al., 1986). The complexity of intersection is quadratic. But the classical complementation algorithm requires the input automaton to be deterministic. Thus, each of these 11 operations requires first the determinization of the input. Such operations can be very costly in the case of the automata involved in the KK algorithm4. In the following section we briefly describe a new algorithm for compiling rewrite rules. For reasons of space, we concentrate here on the compilation of left-to-right obligatory rewrite rules. However, our methods extend straightforwardly to other modes of appli</context>
<context position="8149" citStr="Aho et al., 1974" startWordPosition="1294" endWordPosition="1297">ion and complementation, but the corresponding algorithm has exactly the same cost as the total cost of the two operations performed consecutively. 40ne could hope to find a more efficient way of determining the complement of an automaton that would not require determinization. However, this problem is PSPACE-complete. Indeed, the regular expression non-universality problem is a subproblem of complementation known to be PSPACE-complete (Garey and Johnson, 1979, page 174), (Stockmeyer and Meyer, 1973). This problem also known as the emptiness of complement problem has been extensively studied (Aho et al., 1974, page 410-419). 232 3. New Algorithm 3.1. Overview ,In contrast to the KK algorithm which introduces brackets everywhere only to restrict their occurrence subsequently, our algorithm introduces context symbols just when and where they are needed. Furthermore, the number of intermediate transducers necessary in the construction of the rules is smaller than in the KK algorithm, and each of the transducers can be constructed more directly and efficiently from the primitive expressions of the rule, 0, &apos;kb, A, p. A transducer corresponding to the left-toright obligatory rule 0 0/A p can be obtaine</context>
</contexts>
<marker>Aho, Hoperoft, Ullman, 1974</marker>
<rawString>Alfred V. Aho, John E. Hoperoft, and Jeffrey D. Ullman. 1974. The design and analysis of computer algorithms. Addison Wesley: Reading, MA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alfred V Aho</author>
<author>Ravi Sethi</author>
<author>Jeffrey D Ullman</author>
</authors>
<date>1986</date>
<booktitle>Compilers, Principles, Techniques and Tools.</booktitle>
<publisher>Addison Wesley:</publisher>
<location>Reading, MA.</location>
<contexts>
<context position="6730" citStr="Aho et al., 1986" startWordPosition="1077" endWordPosition="1080">ication of several levels of regular operations from the original expressions in the rules. This clearly appears from the explicit expressions we have indicated for the transducers. The construction of the three other transducers involves many operations including: two intersections of automata, two distinct subtractions, and nine complementations. Each subtraction involves an intersection and a complementation algorithm3. So, in the whole, four intersections and eleven complementations need to be performed. Intersection and complementation are classical automata algorithms (Aho et al., 1974; Aho et al., 1986). The complexity of intersection is quadratic. But the classical complementation algorithm requires the input automaton to be deterministic. Thus, each of these 11 operations requires first the determinization of the input. Such operations can be very costly in the case of the automata involved in the KK algorithm4. In the following section we briefly describe a new algorithm for compiling rewrite rules. For reasons of space, we concentrate here on the compilation of left-to-right obligatory rewrite rules. However, our methods extend straightforwardly to other modes of application (optional, r</context>
<context position="10616" citStr="Aho et al., 1986" startWordPosition="1728" endWordPosition="1731">e other four transducers is also very simple, and that it only requires the determinization of 3 automata and additional work linear (time and space) in the size of the determinized automata. 3.2. Markers Markers of TYPE I Let us start by considering the problem of constructing what we shall call a TYPE 1 transducer, Figure 2: Replacement transducer replace in the obligatory left-to-right case. which inserts a marker after all prefixes of a string that match a particular regular expression. Given a regular expression (3 defined on the alphabet E, one can construct, using classical algorithms (Aho et al., 1986), a deterministic automaton a representing E*fl. As with the KK algorithm, one can obtain from a a transducer x = Id(a) simply by assigning to each transition the same output label as the input label. We can easily transform x into a new transducer r such that it inserts an arbitrary marker # after each occurrence of a pattern described by #. To do so, we make final the nonfinal states of x and for any final state q of x we create a new state q&apos;, a copy of q. Thus, q&apos; has the same transitions as q, and q&apos; is a final state. We then make q non-final, remove the transitions leaving q and add a tr</context>
</contexts>
<marker>Aho, Sethi, Ullman, 1986</marker>
<rawString>Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. 1986. Compilers, Principles, Techniques and Tools. Addison Wesley: Reading, MA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jean Berstel</author>
<author>Christophe Reutenauer</author>
</authors>
<title>Rational Series and Their Languages. Springer-Verlag:</title>
<date>1988</date>
<location>Berlin-New York.</location>
<contexts>
<context position="16846" citStr="Berstel and Reutenauer, 1988" startWordPosition="2854" endWordPosition="2857">nistic automata representing&apos; E*reverse(p), (EU {&gt;})* reverse(0&gt; &gt;), and E*A. The construction of r and f requires two reverse operations. This is because these two transducers insert material before p or cb. 4. Extension to Weighted Rules In many applications, in particular in areas related to speech, one wishes not only to give all possible analyses of some input, but also to give some measure of how likely each of the analyses is. One can then generalize replacements by considering extended regular expressions, namely, using the terminology of formal language theory, rational power series (Berstel and Reutenauer, 1988; Salomaa and Soittola, 1978). The rational power series we consider here are functions mapping E* to R4. U {00} which can be described by regular expressions over the alphabet (74 U loop x E. S = (4a)(2b)*(3b) is an example of rational power series. It defines a function in the following way: it associates a non-null number only with the strings recognized by the regular expression ab* b. This number is obtained by adding the coefficients involved in the recognition of the string. The value associated with abbb, for instance, is (S, abbb) = 4 + 2 + 2 + 3 = 11. In general, such extended regula</context>
</contexts>
<marker>Berstel, Reutenauer, 1988</marker>
<rawString>Jean Berstel and Christophe Reutenauer. 1988. Rational Series and Their Languages. Springer-Verlag: Berlin-New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jean Berstel</author>
</authors>
<title>Transductions and ContextFree Languages. Teubner Studienbucher:</title>
<date>1979</date>
<location>Stuttgart.</location>
<contexts>
<context position="1580" citStr="Berstel, 1979" startWordPosition="234" endWordPosition="235">, morphology, and phonology&apos;. In interesting applications, the number of rules can be very large. It is then crucial to give a representation of these rules that leads to efficient programs. Finite-state transducers provide just such a compact representation (Mohri, 1994). They are used in various areas of natural language and speech processing because their increased computational power enables one to build very large machines to model interestingly complex linguistic phenomena. They also allow algebraic operations such as union, composition, and projection which are very useful in practice (Berstel, 1979; Eilenberg, 1974 1976). And, as originally shown by Johnson (1972), rewrite rules can be modeled as &apos;Parallel rewrite rules also have interesting applications in biology. In addition to their formal language theory interest, systems such as those of Aristid Lindenmayer provide rich mathematical models for biological development (Rozenberg and Salomaa, 1980). finite-state transducers, under the condition that no rule be allowed to apply any more than a finite number of times to its own output. Kaplan and Kay (1994), or equivalently Karttunen (1995), provide an algorithm for compiling rewrite r</context>
</contexts>
<marker>Berstel, 1979</marker>
<rawString>Jean Berstel. 1979. Transductions and ContextFree Languages. Teubner Studienbucher: Stuttgart.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Samuel Eilenberg</author>
</authors>
<date>1974</date>
<journal>Automata, Languages and Machines,</journal>
<volume>volume</volume>
<publisher>A-B. Academic Press.</publisher>
<contexts>
<context position="1597" citStr="Eilenberg, 1974" startWordPosition="236" endWordPosition="238">nd phonology&apos;. In interesting applications, the number of rules can be very large. It is then crucial to give a representation of these rules that leads to efficient programs. Finite-state transducers provide just such a compact representation (Mohri, 1994). They are used in various areas of natural language and speech processing because their increased computational power enables one to build very large machines to model interestingly complex linguistic phenomena. They also allow algebraic operations such as union, composition, and projection which are very useful in practice (Berstel, 1979; Eilenberg, 1974 1976). And, as originally shown by Johnson (1972), rewrite rules can be modeled as &apos;Parallel rewrite rules also have interesting applications in biology. In addition to their formal language theory interest, systems such as those of Aristid Lindenmayer provide rich mathematical models for biological development (Rozenberg and Salomaa, 1980). finite-state transducers, under the condition that no rule be allowed to apply any more than a finite number of times to its own output. Kaplan and Kay (1994), or equivalently Karttunen (1995), provide an algorithm for compiling rewrite rules into finite-</context>
</contexts>
<marker>Eilenberg, 1974</marker>
<rawString>Samuel Eilenberg. 1974-1976. Automata, Languages and Machines, volume A-B. Academic Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael R Garey</author>
<author>David S Johnson</author>
</authors>
<title>Computers and Intractability. Freeman and Company,</title>
<date>1979</date>
<location>New York.</location>
<contexts>
<context position="7997" citStr="Garey and Johnson, 1979" startWordPosition="1270" endWordPosition="1273"> of rules (two-level rules) discussed by Kaplan and Kay (1994). 3A subtraction can of course also be performed directly by combining the two steps of intersection and complementation, but the corresponding algorithm has exactly the same cost as the total cost of the two operations performed consecutively. 40ne could hope to find a more efficient way of determining the complement of an automaton that would not require determinization. However, this problem is PSPACE-complete. Indeed, the regular expression non-universality problem is a subproblem of complementation known to be PSPACE-complete (Garey and Johnson, 1979, page 174), (Stockmeyer and Meyer, 1973). This problem also known as the emptiness of complement problem has been extensively studied (Aho et al., 1974, page 410-419). 232 3. New Algorithm 3.1. Overview ,In contrast to the KK algorithm which introduces brackets everywhere only to restrict their occurrence subsequently, our algorithm introduces context symbols just when and where they are needed. Furthermore, the number of intermediate transducers necessary in the construction of the rules is smaller than in the KK algorithm, and each of the transducers can be constructed more directly and eff</context>
</contexts>
<marker>Garey, Johnson, 1979</marker>
<rawString>Michael R. Garey and David S. Johnson. 1979. Computers and Intractability. Freeman and Company, New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Douglas Johnson</author>
</authors>
<title>Formal Aspects of Phonological Description.</title>
<date>1972</date>
<location>Mouton, Mouton, The Hague.</location>
<contexts>
<context position="1647" citStr="Johnson (1972)" startWordPosition="245" endWordPosition="246">ber of rules can be very large. It is then crucial to give a representation of these rules that leads to efficient programs. Finite-state transducers provide just such a compact representation (Mohri, 1994). They are used in various areas of natural language and speech processing because their increased computational power enables one to build very large machines to model interestingly complex linguistic phenomena. They also allow algebraic operations such as union, composition, and projection which are very useful in practice (Berstel, 1979; Eilenberg, 1974 1976). And, as originally shown by Johnson (1972), rewrite rules can be modeled as &apos;Parallel rewrite rules also have interesting applications in biology. In addition to their formal language theory interest, systems such as those of Aristid Lindenmayer provide rich mathematical models for biological development (Rozenberg and Salomaa, 1980). finite-state transducers, under the condition that no rule be allowed to apply any more than a finite number of times to its own output. Kaplan and Kay (1994), or equivalently Karttunen (1995), provide an algorithm for compiling rewrite rules into finite-state transducers, under the condition that they d</context>
</contexts>
<marker>Johnson, 1972</marker>
<rawString>C. Douglas Johnson. 1972. Formal Aspects of Phonological Description. Mouton, Mouton, The Hague.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ronald M Kaplan</author>
<author>Martin Kay</author>
</authors>
<title>Regular models of phonological rule systems.</title>
<date>1994</date>
<journal>Computational Linguistics,</journal>
<volume>20</volume>
<issue>3</issue>
<contexts>
<context position="2100" citStr="Kaplan and Kay (1994)" startWordPosition="315" endWordPosition="318">perations such as union, composition, and projection which are very useful in practice (Berstel, 1979; Eilenberg, 1974 1976). And, as originally shown by Johnson (1972), rewrite rules can be modeled as &apos;Parallel rewrite rules also have interesting applications in biology. In addition to their formal language theory interest, systems such as those of Aristid Lindenmayer provide rich mathematical models for biological development (Rozenberg and Salomaa, 1980). finite-state transducers, under the condition that no rule be allowed to apply any more than a finite number of times to its own output. Kaplan and Kay (1994), or equivalently Karttunen (1995), provide an algorithm for compiling rewrite rules into finite-state transducers, under the condition that they do not rewrite their noncontextual part2. We here present a new algorithm for compiling such rewrite rules which is both simpler to understand and implement, and computationally more efficient. Clarity is important since, as pointed out by Kaplan and Kay (1994), the representation of rewrite rules by finite-state transducers involves many subtleties. Time and space efficiency of the compilation are also crucial. Using naive algorithms can be very tim</context>
<context position="4917" citStr="Kaplan and Kay (1994)" startWordPosition="780" endWordPosition="783">: 0 is to be replaced by whenever it is preceded by A and followed by p. Thus, A and p represent the left and right contexts of application of the rules. In general, 0, 0, A and p are all regular expressions over the alphabet of the rules. Several types of rules can be considered depending on their being obligatory or optional, and on their direction of application, from left to right, right to left or simultaneous application. Consider an obligatory rewrite rule of the form i/A p, which we will assume applies left to right across the input string. Compilation of this rule in the algorithm of Kaplan and Kay (1994) (KK for short) involves composing together six transducers, see Figure 1. We use the notations of KK. In particular, E denotes the alphabet, &lt; denotes the set of context labeled brackets {&lt;a, &lt;i, &lt;c}, &gt; the set {&gt;a, &gt;i, &gt;c}, and 0 an additional character representing deleted material. Subscript symbols of an expression are symbols which are allowed to freely appear anywhere in the strings represented by that expression. Given a regular expression r, Id(r) is the identity transducer obtained from an automaton A representing r by adding output labels to A identical to its input labels. The firs</context>
<context position="7436" citStr="Kaplan and Kay (1994)" startWordPosition="1185" endWordPosition="1188">rithm requires the input automaton to be deterministic. Thus, each of these 11 operations requires first the determinization of the input. Such operations can be very costly in the case of the automata involved in the KK algorithm4. In the following section we briefly describe a new algorithm for compiling rewrite rules. For reasons of space, we concentrate here on the compilation of left-to-right obligatory rewrite rules. However, our methods extend straightforwardly to other modes of application (optional, right-to-left, simultaneous, batch), or kinds of rules (two-level rules) discussed by Kaplan and Kay (1994). 3A subtraction can of course also be performed directly by combining the two steps of intersection and complementation, but the corresponding algorithm has exactly the same cost as the total cost of the two operations performed consecutively. 40ne could hope to find a more efficient way of determining the complement of an automaton that would not require determinization. However, this problem is PSPACE-complete. Indeed, the regular expression non-universality problem is a subproblem of complementation known to be PSPACE-complete (Garey and Johnson, 1979, page 174), (Stockmeyer and Meyer, 197</context>
<context position="20527" citStr="Kaplan and Kay (1994)" startWordPosition="3511" endWordPosition="3514">y of languages, the functions we consider here are power series defined on the tropical semiring (R-FUlool, min, +, oo, 0) (Kuich and Salomaa, 1986). 235 N:N/O Figure 8: Transducer representing the rule 9. We have generalized the composition operation to the weighted case by introducing this combination of weights. The algorithm we described in the previous sections can then also be used to compile weighted rewrite rules. As an example, the obligatory rule 9 can be represented by the weighted transducer of Figure 8 1°. The following theorem extends to the weighted case the assertion proved by Kaplan and Kay (1994). Theorem 1 A weighted rewrite rule of the type defined above that does not rewrite its noncontextual part can be represented by a weighted finite-state transducer. Proof. The construction we described in the previous section also provides a constructive proof of this theorem in the unweighted case. In case is a power series, one simply needs to use in that construction a weighted finite-state transducer representing O. By definition of composition of weighted transducers, or multiplication of power series, the weights are then used in a way consistent with the definition of the weighted conte</context>
</contexts>
<marker>Kaplan, Kay, 1994</marker>
<rawString>Ronald M. Kaplan and Martin Kay. 1994. Regular models of phonological rule systems. Computational Linguistics, 20(3).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
</authors>
<title>The replace operator.</title>
<date>1995</date>
<booktitle>In 33rd Meeting of the Association for Computational Linguistics (ACL 95), Proceedings of the Conference, MIT,</booktitle>
<publisher>ACL.</publisher>
<location>Cambridge, Massachussetts.</location>
<contexts>
<context position="2134" citStr="Karttunen (1995)" startWordPosition="321" endWordPosition="323">nd projection which are very useful in practice (Berstel, 1979; Eilenberg, 1974 1976). And, as originally shown by Johnson (1972), rewrite rules can be modeled as &apos;Parallel rewrite rules also have interesting applications in biology. In addition to their formal language theory interest, systems such as those of Aristid Lindenmayer provide rich mathematical models for biological development (Rozenberg and Salomaa, 1980). finite-state transducers, under the condition that no rule be allowed to apply any more than a finite number of times to its own output. Kaplan and Kay (1994), or equivalently Karttunen (1995), provide an algorithm for compiling rewrite rules into finite-state transducers, under the condition that they do not rewrite their noncontextual part2. We here present a new algorithm for compiling such rewrite rules which is both simpler to understand and implement, and computationally more efficient. Clarity is important since, as pointed out by Kaplan and Kay (1994), the representation of rewrite rules by finite-state transducers involves many subtleties. Time and space efficiency of the compilation are also crucial. Using naive algorithms can be very time consuming and lead to very large</context>
</contexts>
<marker>Karttunen, 1995</marker>
<rawString>Lauri Karttunen. 1995. The replace operator. In 33rd Meeting of the Association for Computational Linguistics (ACL 95), Proceedings of the Conference, MIT, Cambridge, Massachussetts. ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Wener Kuich</author>
<author>Arto Salomaa</author>
</authors>
<date>1986</date>
<location>Semirings, Automata, Languages. Springer-Verlag: Berlin-New York.</location>
<contexts>
<context position="20054" citStr="Kuich and Salomaa, 1986" startWordPosition="3431" endWordPosition="3434">ers such that in addition to input and output labels, each transition is labeled with a weight. The result of the application of a weighted transducer to a string, or more generally to an automaton is a weighted automaton. The corresponding operation is similar to the unweighted case. However, the weight of the transducer and those of the string or automaton need to be combined too, here added, during composition (Pereira et al., 1994). 9Using the terminology of the theory of languages, the functions we consider here are power series defined on the tropical semiring (R-FUlool, min, +, oo, 0) (Kuich and Salomaa, 1986). 235 N:N/O Figure 8: Transducer representing the rule 9. We have generalized the composition operation to the weighted case by introducing this combination of weights. The algorithm we described in the previous sections can then also be used to compile weighted rewrite rules. As an example, the obligatory rule 9 can be represented by the weighted transducer of Figure 8 1°. The following theorem extends to the weighted case the assertion proved by Kaplan and Kay (1994). Theorem 1 A weighted rewrite rule of the type defined above that does not rewrite its noncontextual part can be represented b</context>
</contexts>
<marker>Kuich, Salomaa, 1986</marker>
<rawString>Wener Kuich and Arto Salomaa. 1986. Semirings, Automata, Languages. Springer-Verlag: Berlin-New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Liberman</author>
</authors>
<title>Commentary on kaplan and kay.</title>
<date>1994</date>
<journal>Computational Linguistics,</journal>
<volume>20</volume>
<issue>3</issue>
<contexts>
<context position="2760" citStr="Liberman, 1994" startWordPosition="421" endWordPosition="422">n algorithm for compiling rewrite rules into finite-state transducers, under the condition that they do not rewrite their noncontextual part2. We here present a new algorithm for compiling such rewrite rules which is both simpler to understand and implement, and computationally more efficient. Clarity is important since, as pointed out by Kaplan and Kay (1994), the representation of rewrite rules by finite-state transducers involves many subtleties. Time and space efficiency of the compilation are also crucial. Using naive algorithms can be very time consuming and lead to very large machines (Liberman, 1994). In some applications such as those related to speech processing, one needs to use weighted rewrite rules, namely rewrite rules to which weights are associated. These weights are then used at the final stage of applications to output the most probable analysis. Weighted rewrite rules can be compiled into weighted finite-state transducers, namely transducers generalized by providing transitions with a weighted output, under the same context condition. These transducers are very useful in speech processing (Pereira et al., 1994). We briefly describe how we have augmented our algorithm to handle</context>
</contexts>
<marker>Liberman, 1994</marker>
<rawString>Mark Liberman. 1994. Commentary on kaplan and kay. Computational Linguistics, 20(3).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert McNaughton</author>
</authors>
<title>The uniform halting problem for one-rule semi-thue systems.</title>
<date>1994</date>
<tech>Technical Report 94-18,</tech>
<institution>Department of Computer Science, Rensselaer Polytechnic Institute,</institution>
<location>Troy, New York.</location>
<contexts>
<context position="3698" citStr="McNaughton (1994)" startWordPosition="568" endWordPosition="569">e-state transducers, namely transducers generalized by providing transitions with a weighted output, under the same context condition. These transducers are very useful in speech processing (Pereira et al., 1994). We briefly describe how we have augmented our algorithm to handle the compilation of weighted rules into weighted finite-state transducers. In order to set the stage for our own contribution, we start by reviewing salient aspects of the Kaplan and Kay algorithm. &apos;The general question of the decidability of the halting problem even for one-rule semi-Thue systems is still open. Robert McNaughton (1994) has recently made a positive conjecture about the class of the rules without self overlap. 231 Prologue o Id(Obligatory(0, &lt;i , &gt;)) Id(Rightcontest(p,&lt;,&gt;)) Replace Id(Leftcontext(A,&lt;,&gt;)) Prologue-1 Id(E*;‹ 0 &lt;i 0&gt;&lt; &gt; E&apos;&gt;&lt; o) ° = id((E;0 &gt; p&gt;0E;0— &gt; E&apos;;0 n E;(3 &gt; P&gt;oE;o— &gt; E&apos;;0)‹) o = [Id(E*&lt;,&gt;, 0)Opt(Id(&lt;0)0&lt;c&gt;c x id((E&apos;6A&lt;0 E&apos;10 &lt; &lt; E*&lt;0 n E*&lt;0A&lt;0 —E &lt; &lt; Es0)&gt;) 0 (1) Figure 1: Compilation of obligatory left-to-right rules, using the KK algorithm. 2. The KK Algorithm The rewrite rules we consider here have the following general form: —) (2) Such rules can be interpreted in the following way: </context>
</contexts>
<marker>McNaughton, 1994</marker>
<rawString>Robert McNaughton. 1994. The uniform halting problem for one-rule semi-thue systems. Technical Report 94-18, Department of Computer Science, Rensselaer Polytechnic Institute, Troy, New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mehryar Mohri</author>
</authors>
<title>Compact representations by finite-state transducers.</title>
<date>1994</date>
<booktitle>In 32nd Meeting of the Association for Computational Linguistics (ACL 9.4), Proceedings of the Conference,</booktitle>
<publisher>ACL.</publisher>
<location>Las Cruces, New Mexico.</location>
<contexts>
<context position="1239" citStr="Mohri, 1994" startWordPosition="183" endWordPosition="184">sting algorithms. Further, many of our applications demand the ability to compile weighted rules into weighted FSTs, transducers generalized by providing transitions with weights. We have extended the algorithm to allow for this. 1. Motivation Rewrite rules are used in many areas of natural language and speech processing, including syntax, morphology, and phonology&apos;. In interesting applications, the number of rules can be very large. It is then crucial to give a representation of these rules that leads to efficient programs. Finite-state transducers provide just such a compact representation (Mohri, 1994). They are used in various areas of natural language and speech processing because their increased computational power enables one to build very large machines to model interestingly complex linguistic phenomena. They also allow algebraic operations such as union, composition, and projection which are very useful in practice (Berstel, 1979; Eilenberg, 1974 1976). And, as originally shown by Johnson (1972), rewrite rules can be modeled as &apos;Parallel rewrite rules also have interesting applications in biology. In addition to their formal language theory interest, systems such as those of Aristid </context>
<context position="26420" citStr="Mohri, 1994" startWordPosition="4516" endWordPosition="4517">cient way using failure functions (Mohri, 1995). Moreover, the corresponding determinization is independent of E which can be very large in some applications. It only depends on the alphabet of the automaton representing 0. One can devise an on-the-fly implementation of the composition algorithm leading to the final transducer representing a rule. Only the necessary part of the intermediate transducers is then expanded for a given input (Pereira et al., 1994). The resulting transducer representing a rule is often subsequentiable or p-subsequentiable. It can then be determinized and minimized (Mohri, 1994). This both makes the use of the transducer time efficient and reduces its size. We also indicated an extension of the theory of rule-compilation to the case of weighted rules, which compile into weighted finite-state transducers. Many algorithms used in the finite-state theory and in their applications to natural language processing can be extended in the same way. To date the main serious application of this compiler has been to developing text-analyzers for text-to-speech systems at Bell Laboratories (Sproat, 1996): partial to more-or-less complete analyzers have been built for Spanish, Ita</context>
</contexts>
<marker>Mohri, 1994</marker>
<rawString>Mehryar Mohri. 1994. Compact representations by finite-state transducers. In 32nd Meeting of the Association for Computational Linguistics (ACL 9.4), Proceedings of the Conference, Las Cruces, New Mexico. ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mehryar Mohri</author>
</authors>
<title>Matching patterns of an automaton.</title>
<date>1995</date>
<journal>Lecture Notes in Computer Science,</journal>
<pages>937</pages>
<contexts>
<context position="25855" citStr="Mohri, 1995" startWordPosition="4431" endWordPosition="4432">conds for the overall construction, and the number of states and arcs of the output transducers. 6. Conclusion We briefly described a new algorithm for compiling context-dependent rewrite rules into finite-state transducers. Several additional methods can be used to make this algorithm even more efficient. The automata determinizations needed for this algorithm are of a specific type. They represent expressions of the type E*0 where 0 is a regular expression. Given a deterministic automaton representing 0, such determinizations can be performed in a more efficient way using failure functions (Mohri, 1995). Moreover, the corresponding determinization is independent of E which can be very large in some applications. It only depends on the alphabet of the automaton representing 0. One can devise an on-the-fly implementation of the composition algorithm leading to the final transducer representing a rule. Only the necessary part of the intermediate transducers is then expanded for a given input (Pereira et al., 1994). The resulting transducer representing a rule is often subsequentiable or p-subsequentiable. It can then be determinized and minimized (Mohri, 1994). This both makes the use of the tr</context>
</contexts>
<marker>Mohri, 1995</marker>
<rawString>Mehryar Mohri. 1995. Matching patterns of an automaton. Lecture Notes in Computer Science, 937.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fernando C N Pereira</author>
<author>Michael Riley</author>
<author>Richard Sproat</author>
</authors>
<title>Weighted rational transductions and their application to human language processing.</title>
<date>1994</date>
<booktitle>In ARPA Workshop on Human Language Technology. Advanced Research Projects Agency.</booktitle>
<contexts>
<context position="3293" citStr="Pereira et al., 1994" startWordPosition="500" endWordPosition="503">e algorithms can be very time consuming and lead to very large machines (Liberman, 1994). In some applications such as those related to speech processing, one needs to use weighted rewrite rules, namely rewrite rules to which weights are associated. These weights are then used at the final stage of applications to output the most probable analysis. Weighted rewrite rules can be compiled into weighted finite-state transducers, namely transducers generalized by providing transitions with a weighted output, under the same context condition. These transducers are very useful in speech processing (Pereira et al., 1994). We briefly describe how we have augmented our algorithm to handle the compilation of weighted rules into weighted finite-state transducers. In order to set the stage for our own contribution, we start by reviewing salient aspects of the Kaplan and Kay algorithm. &apos;The general question of the decidability of the halting problem even for one-rule semi-Thue systems is still open. Robert McNaughton (1994) has recently made a positive conjecture about the class of the rules without self overlap. 231 Prologue o Id(Obligatory(0, &lt;i , &gt;)) Id(Rightcontest(p,&lt;,&gt;)) Replace Id(Leftcontext(A,&lt;,&gt;)) Prologu</context>
<context position="19869" citStr="Pereira et al., 1994" startWordPosition="3400" endWordPosition="3403">weight /6&apos; = — log(0.1), in the stated environment. One could represent this by the following rule: N am A- fin/ [+labial] (9) We define Weighted finite-state transducers as transducers such that in addition to input and output labels, each transition is labeled with a weight. The result of the application of a weighted transducer to a string, or more generally to an automaton is a weighted automaton. The corresponding operation is similar to the unweighted case. However, the weight of the transducer and those of the string or automaton need to be combined too, here added, during composition (Pereira et al., 1994). 9Using the terminology of the theory of languages, the functions we consider here are power series defined on the tropical semiring (R-FUlool, min, +, oo, 0) (Kuich and Salomaa, 1986). 235 N:N/O Figure 8: Transducer representing the rule 9. We have generalized the composition operation to the weighted case by introducing this combination of weights. The algorithm we described in the previous sections can then also be used to compile weighted rewrite rules. As an example, the obligatory rule 9 can be represented by the weighted transducer of Figure 8 1°. The following theorem extends to the w</context>
<context position="26271" citStr="Pereira et al., 1994" startWordPosition="4494" endWordPosition="4497">essions of the type E*0 where 0 is a regular expression. Given a deterministic automaton representing 0, such determinizations can be performed in a more efficient way using failure functions (Mohri, 1995). Moreover, the corresponding determinization is independent of E which can be very large in some applications. It only depends on the alphabet of the automaton representing 0. One can devise an on-the-fly implementation of the composition algorithm leading to the final transducer representing a rule. Only the necessary part of the intermediate transducers is then expanded for a given input (Pereira et al., 1994). The resulting transducer representing a rule is often subsequentiable or p-subsequentiable. It can then be determinized and minimized (Mohri, 1994). This both makes the use of the transducer time efficient and reduces its size. We also indicated an extension of the theory of rule-compilation to the case of weighted rules, which compile into weighted finite-state transducers. Many algorithms used in the finite-state theory and in their applications to natural language processing can be extended in the same way. To date the main serious application of this compiler has been to developing text-</context>
</contexts>
<marker>Pereira, Riley, Sproat, 1994</marker>
<rawString>Fernando C. N. Pereira, Michael Riley, and Richard Sproat. 1994. Weighted rational transductions and their application to human language processing. In ARPA Workshop on Human Language Technology. Advanced Research Projects Agency.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Grzegorz Rozenberg</author>
<author>Arto Salomaa</author>
</authors>
<title>The Mathematical Theory of L Systems.</title>
<date>1980</date>
<publisher>Academic Press,</publisher>
<location>New York.</location>
<contexts>
<context position="1940" citStr="Rozenberg and Salomaa, 1980" startWordPosition="287" endWordPosition="290">g because their increased computational power enables one to build very large machines to model interestingly complex linguistic phenomena. They also allow algebraic operations such as union, composition, and projection which are very useful in practice (Berstel, 1979; Eilenberg, 1974 1976). And, as originally shown by Johnson (1972), rewrite rules can be modeled as &apos;Parallel rewrite rules also have interesting applications in biology. In addition to their formal language theory interest, systems such as those of Aristid Lindenmayer provide rich mathematical models for biological development (Rozenberg and Salomaa, 1980). finite-state transducers, under the condition that no rule be allowed to apply any more than a finite number of times to its own output. Kaplan and Kay (1994), or equivalently Karttunen (1995), provide an algorithm for compiling rewrite rules into finite-state transducers, under the condition that they do not rewrite their noncontextual part2. We here present a new algorithm for compiling such rewrite rules which is both simpler to understand and implement, and computationally more efficient. Clarity is important since, as pointed out by Kaplan and Kay (1994), the representation of rewrite r</context>
</contexts>
<marker>Rozenberg, Salomaa, 1980</marker>
<rawString>Grzegorz Rozenberg and Arto Salomaa. 1980. The Mathematical Theory of L Systems. Academic Press, New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Arto Salomaa</author>
<author>Matti Soittola</author>
</authors>
<title>Automata-Theoretic Aspects of Formal Power Series. Springer-Verlag:</title>
<date>1978</date>
<location>Berlin-New York.</location>
<contexts>
<context position="16875" citStr="Salomaa and Soittola, 1978" startWordPosition="2858" endWordPosition="2861">E*reverse(p), (EU {&gt;})* reverse(0&gt; &gt;), and E*A. The construction of r and f requires two reverse operations. This is because these two transducers insert material before p or cb. 4. Extension to Weighted Rules In many applications, in particular in areas related to speech, one wishes not only to give all possible analyses of some input, but also to give some measure of how likely each of the analyses is. One can then generalize replacements by considering extended regular expressions, namely, using the terminology of formal language theory, rational power series (Berstel and Reutenauer, 1988; Salomaa and Soittola, 1978). The rational power series we consider here are functions mapping E* to R4. U {00} which can be described by regular expressions over the alphabet (74 U loop x E. S = (4a)(2b)*(3b) is an example of rational power series. It defines a function in the following way: it associates a non-null number only with the strings recognized by the regular expression ab* b. This number is obtained by adding the coefficients involved in the recognition of the string. The value associated with abbb, for instance, is (S, abbb) = 4 + 2 + 2 + 3 = 11. In general, such extended regular expressions can be redundan</context>
</contexts>
<marker>Salomaa, Soittola, 1978</marker>
<rawString>Arto Salomaa and Matti Soittola. 1978. Automata-Theoretic Aspects of Formal Power Series. Springer-Verlag: Berlin-New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Richard Sproat</author>
</authors>
<title>Multilingual text analysis for text-to-speech synthesis.</title>
<date>1996</date>
<booktitle>In Proceedings of the ECAI-96 Workshop on Extended Finite State Models of Language, Budapest, Hungary. European Conference on Artificial Intelligence.</booktitle>
<contexts>
<context position="26943" citStr="Sproat, 1996" startWordPosition="4598" endWordPosition="4599">sequentiable or p-subsequentiable. It can then be determinized and minimized (Mohri, 1994). This both makes the use of the transducer time efficient and reduces its size. We also indicated an extension of the theory of rule-compilation to the case of weighted rules, which compile into weighted finite-state transducers. Many algorithms used in the finite-state theory and in their applications to natural language processing can be extended in the same way. To date the main serious application of this compiler has been to developing text-analyzers for text-to-speech systems at Bell Laboratories (Sproat, 1996): partial to more-or-less complete analyzers have been built for Spanish, Italian, French, Romanian, German, Russian, Mandarin and Japanese. However, we hope to also be able to use the compiler in serious applications in speech II New 237 BOO 810 820 830 • arca in Pbar S Figure 11: Number of arcs in the_ nondeterministic automaton r representing PS = E&gt;o &gt; P&gt;0E;0— &gt; E*;0 versus the log of the number of arcs in the automaton obtained by determinization of T. recognition in the future. Acknowledgements We wish to thank several colleagues of AT&amp;T/Bell Labs, in particular Fernando Pereira and Mich</context>
</contexts>
<marker>Sproat, 1996</marker>
<rawString>Richard Sproat. 1996. Multilingual text analysis for text-to-speech synthesis. In Proceedings of the ECAI-96 Workshop on Extended Finite State Models of Language, Budapest, Hungary. European Conference on Artificial Intelligence.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L J Stockmeyer</author>
<author>A R Meyer</author>
</authors>
<title>Word problems requiring exponential time.</title>
<date>1973</date>
<booktitle>In Proceedings of the 5th Annual ACM Symposium on Theory of Computing. Association for Computing Machinery,</booktitle>
<pages>1--9</pages>
<location>New York,</location>
<contexts>
<context position="8038" citStr="Stockmeyer and Meyer, 1973" startWordPosition="1276" endWordPosition="1279"> by Kaplan and Kay (1994). 3A subtraction can of course also be performed directly by combining the two steps of intersection and complementation, but the corresponding algorithm has exactly the same cost as the total cost of the two operations performed consecutively. 40ne could hope to find a more efficient way of determining the complement of an automaton that would not require determinization. However, this problem is PSPACE-complete. Indeed, the regular expression non-universality problem is a subproblem of complementation known to be PSPACE-complete (Garey and Johnson, 1979, page 174), (Stockmeyer and Meyer, 1973). This problem also known as the emptiness of complement problem has been extensively studied (Aho et al., 1974, page 410-419). 232 3. New Algorithm 3.1. Overview ,In contrast to the KK algorithm which introduces brackets everywhere only to restrict their occurrence subsequently, our algorithm introduces context symbols just when and where they are needed. Furthermore, the number of intermediate transducers necessary in the construction of the rules is smaller than in the KK algorithm, and each of the transducers can be constructed more directly and efficiently from the primitive expressions o</context>
</contexts>
<marker>Stockmeyer, Meyer, 1973</marker>
<rawString>L. J. Stockmeyer and A. R. Meyer. 1973. Word problems requiring exponential time. In Proceedings of the 5th Annual ACM Symposium on Theory of Computing. Association for Computing Machinery, New York, 1-9.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>