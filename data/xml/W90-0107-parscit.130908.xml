<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000014">
<title confidence="0.989899">
Using Bidirectional Semantic Rules for Generation
</title>
<author confidence="0.992444">
Jim Barnett and Inderjeet Mani
</author>
<affiliation confidence="0.84425375">
Microelectronics and Computer Technology Corporation (MCC)
3500 West Balcones Center Drive
Austin, Texas 78759
U.S.A.
</affiliation>
<sectionHeader confidence="0.98879" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9999832">
This paper describes the use of a system of semantic
rules to generate noun compounds, vague or polyse-
mous words, and cases of metonymy. The rules are bi-
directional and are used by the understanding system
to interpret the same constructions.
</bodyText>
<sectionHeader confidence="0.987026" genericHeader="introduction">
Introduction
</sectionHeader>
<bodyText confidence="0.995977682926829">
In generation systems that are paired with understand-
ing systems, bidirectionality is desirable for reasons
that are both theoretical (a single model of linguis-
tic behaviour) and practical (shorter development time,
greater consistency, etc.)&apos;. Recently, [Shieber et al. 89]
and [Calder at al. 89] have presented generation algo-
rithms that share both semantics and syntax with the
understanding system. This paper presents an exten-
sion of these algorithms to deal with phenomena that
have often been lumped together under &apos;pragmatics&apos;,
namely noun compounding, metonymy (the use of a
word to refer to a related concept), and vague or poly-
semous words like &amp;quot;have.&amp;quot;
The difficulty with these constructions is that they
are productive, and cannot be handled easily by simply
listing meanings in a lexicon. Taking noun compound-
ing as an example, we have &amp;quot;corn oil&amp;quot; and &amp;quot;olive oil&amp;quot;
referring to oil made from corn or olives. We could add
a lexical sense for &amp;quot;corn&amp;quot; meaning &amp;quot;made from corn,&amp;quot;
but then we face an explosion in the size of the lexi-
con, and an inability to understand or generate novel
compounds: if we acquire &amp;quot;safflower&amp;quot; as the name of a
plant, we would like the system to be able to handle
&amp;quot;safflower oil&amp;quot; immediately, but this won&apos;t be possible
if we need a separate lexical sense to handle compound-
ing. The system will be more robust (and the lexicon
more compact) if we can derive the desired sense of
&amp;quot;safflower&amp;quot; from the basic noun sense when we need it.
We have therefore developed a system of bidirectional
semantic rides to handle these phenomena at the ap-
propriate level of generality.
&apos;For more detailed arguments along these lines, see
[Appelt 87], [Shieber 88], [Jacobs 88a].
We have implemented these rules in Common Lisp as
part of the KBNL system [Barnett et al. 90] at MCC,
but nothing depends on the idiosyncracies of our for-
malisms or implementation, so the technique is com-
patible with a wide variety of theories of the kinds
of relations that are likely to occur in these construc-
tions, as in, e.g., [Finin 80] for noun compounds and
[Nunberg 78] for oblique reference.
</bodyText>
<subsectionHeader confidence="0.927865">
The Framework
</subsectionHeader>
<bodyText confidence="0.999985851851852">
The algorithms for recognition and generation use
an agenda-based blackboard for communication and
control [Cohen et al. 89]. Our syntax component
uses an extension of Categorial Unification Grammar
[Wittenburg 86] as the phrase-structure component of
an LFG-style functional representation (f-structure),
and the semantic component maps from this represen-
tation to sets of assertions in the interface language of
the CYC knowledge base [Lenat et al. 90].
Semantic rules map partial semantic interpretations
onto other partial interpretations. They consist of a
left-hand side and a right-hand side, each consisting of
one or more templates, plus a mechanism for mapping
an instantiation of either set of templates onto an in-
stantiation of the other set. The intuitive semantics of
these rules is that any interpretation that matches the
left-hand side licenses a second interpretation match-
ing the right-hand side. For example, we can use the
name of an author to refer to his works (&amp;quot;I read Shake-
speare&amp;quot;), and the corresponding semantic rule states
that the existence of an NP denoting an artist licences
the use of the same NP to refer to his works. The gen-
eration system applies the rules in a backward-chaining
direction, while the understanding system runs them
forward. A later section contains a fuller discussion of
the implementation of the rules, while the next sections
discuss their use at runtime.
</bodyText>
<sectionHeader confidence="0.697934" genericHeader="method">
Generation
</sectionHeader>
<bodyText confidence="0.998679">
The generator is divided into strategic and tactical com-
ponents. The former takes a frame as input and cre-
ates a description of it based on a set of discriminative
</bodyText>
<page confidence="0.99877">
47
</page>
<bodyText confidence="0.998818215686274">
properties which are recorded in the KB and indicate
which aspects of a frame are likely to be salient. If
a comparison class is available, the resulting descrip-
tion uniquely identifies the frame with respect to that
class, otherwise it contains default &apos;interesting&apos; proper-
ties. Once it has generated this set of assertions, the
strategic component calls the tactical component with
a goal Semantics : Syntax, where Semantics consists of
the assertions plus the distinguished variable that the
utterance is &apos;about&apos;, and Syntax is an f-structure (which
may specify no more than the category.)
Given this input, the tactical component uses a vari-
ant of the semantic-head driven algorithms described
by [Calder at al. 89] and [Shieber et al. 89] to generate
a phrase whose syntax and semantics match the goal.
Before examining this algorithm, we note that in cat-
egorial grammars, most of the syntactic information is
contained in the lexical definitions of words. For ex-
ample, the lexical entry for a transitive verb like &amp;quot;read&amp;quot;
specifies that it takes an object NP to its right and then
a subject NP to its left. Any such constituent that takes
at least one argument is called a functor, while a con-
stituent with no arguments is called atomic. Functors
and their arguments are combined by a small number
of binary rules, and there is also a set of unary rules,
which can change the category of a constituent (forming
passive verbs out of actives, for example.)
Next we define two relationships between con-
stituents and goals: first, a constituent matches a goal if
its semantics subsumes the goal&apos;s semantics and its syn-
tactic category is the same as the goal&apos;s, with possible
extra arguments. Thus the transitive verb &amp;quot;eat&amp;quot;, with
category SWP/NP, is a syntactic match for the goal
category S because it will be an S once it gets its ar-
guments. Second, a constituent satisfies a goal if it has
identical semantics and its f-structure is a supergraph
of the goal&apos;s f-structure.
Given this syntactic framework, the algorithm works
by peeling off lexical functors and recursing on their ar-
guments until it bottoms out in an atomic constituent.
Given a goal, the first step consists of lexical look-up
to find an item that matches the goal. Once this item,
called the semantic head, is found, the algorithm pro-
ceeds both top-down and bottom up. If the semantic
head is a functor, it proceeds top-down trying to solve
the sub-goal for its argument. Once this sub-goal is
satisfied, the algorithm works bottom-up by applying
unary grammar rules to to the argument constituent
alone, or binary rules to combine it with the functor.
When a complete constituent is found which satisfies
the goal, we are done.
</bodyText>
<sectionHeader confidence="0.576866" genericHeader="method">
Extension: Goal Revision
</sectionHeader>
<bodyText confidence="0.9997275">
The algorithm described above assumes a fixed set of
choices in the lexicon. It can generate metonymic ex-
pressions and noun compounds, but only at the cost
of massive lexical ambiguity. We therefore extend it by
considering the possibility of goal revision as an alterna-
tive to the lexical look-up step&apos;. By running a semantic
rule backward, we can map the current goal onto one
or more new goals to which the algorithm recursively
applies. Satisfying the new goals will generate an ex-
pression with the desired meaning and thus indirectly
satisfy the original goal.
Revision using noun compounding rules leads to a
binary decomposition of the original goal, as shown in
Figure 2, while metonymy rules result in a unary de-
composition, as shown in Figure 3. From this perspec-
tive, we note that the lexical look-up of a functor can
be viewed as a kind of guided binary decomposition
(Figure 1), splitting the original goal into two sub-goals
with the knowledge that one of them will be satisfied
immediately.
</bodyText>
<figure confidence="0.663078454545455">
GOAL
(X HRSCOLOR Y)
(X ISA BOOK)
(Y EQUALS RED)
(X HASCRERTOR 2)
(2 EQUALS rim)
FUNCIOR ARC
(X HRSCOLOR Y) (X ISR BOOK)
(Y EQUALS RED) (X HASCREATOR 2)
(2 EQUALS MAO)
( Lex -&gt; RED)
</figure>
<figureCaption confidence="0.999634">
Figure 1: Lexical Lookup as Decomposition
</figureCaption>
<bodyText confidence="0.99997775">
Our extension to the algorithms of [Calder at al. 89]
and [Shieber et al. 89] thus amounts to the decision to
allow top-down decomposition to be guided by rules
as well as lexical items. As we would expect, this is
the mirror image of the situation during understanding,
where semantic rules are used as an extension to the
lexicon in the process of merging translations bottom-
up. The extended algorithm is shown in the Appendix.
</bodyText>
<subsectionHeader confidence="0.958785">
Controlling Rule Application
</subsectionHeader>
<bodyText confidence="0.943685142857143">
The strategic component can control the choice among
alternatives through its specification of the goal&apos;s syn-
tax. For example, the strategic component can force
the use of a compound by providing an appropriately
detailed f-structure (i.e., one that specifies the presence
of a modifier of category N.) If it does so, no matter
whether we are in best-first or all-paths mode, only the
compounding alternative will succeed and satisfy the
syntactic goal. On the other hand, if the syntactic goal
is underspecified, the output (in best-first mode) will
2The notion of goal revision in generation dates back to
[Appelt 83] where various conditions could lead to replan-
ning of the input; for recent work incorporating goal revision
see [Vaughan et al. 86].
</bodyText>
<page confidence="0.996171">
48
</page>
<bodyText confidence="0.99996275">
depend on the tactical component&apos;s heuristic ordering.
In this case, given the default ordering which prefers
lexical look-up to noun compounding to metonymy, the
tactical component will use a noun compound when
lexical look-up fails (i.e., there is no corresponding ad-
jective or preposition). Another result of this default
ordering is that metonymy will never fire in the ab-
sence of a syntactic specification since there is always
another way (unless the lexicon is incomplete) of say-
ing the same thing using words that are in the lexicon.
However, the literal alternative is usually more verbose
than the metonymous expression, so the strategic com-
ponent can force the use of metonymy by specifying a
limit on the number of words the tactical component
is allowed to use. Given a limit of 3 words, descriptive
phrases like &amp;quot;a book by Joyce&amp;quot; will fail, and only the
metonymous expression &amp;quot;Joyce&amp;quot; will succeed.
In best-first mode, substantial improvements in effi-
ciency are possible by re-ordering the alternatives based
on the syntactic properties of the goal. For example, it
makes sense to try metonymy first if the desired length
is significantly less than the number of assertions in the
goal&apos;s semantics, since each lexical item normally covers
only a few assertions.
</bodyText>
<subsectionHeader confidence="0.877">
Generating Noun Compounds
</subsectionHeader>
<bodyText confidence="0.993542416666667">
Suppose we have a Software-Machine rule, stating
that if &amp;quot;y&amp;quot; denotes any kind of Software and &amp;quot;x&amp;quot; a
computer, &amp;quot;a y x&amp;quot; means a Computer x that CanRun-
Language y. Now consider a goal with semantics (W
ISA Computer)(Z Equals Lisp)(W CanRunLanguage
Z), distinguished variable W, and syntax NP. There is
no lexical item covering all these assertions, or any lex-
ical functor covering part of them (i.e., &amp;quot;Lisp&amp;quot; is not
in the lexicon as an adjective.) Thus, even in best-first
mode, we will end up applying the Software-Machine
rule to this goal, resulting in the decomposition shown
in Figure 2.
</bodyText>
<sectionHeader confidence="0.6098814" genericHeader="method">
COAL
MP
(I( CANRUALANGURGE Z)
(14 ISA COMPUTER)
( Z EQUALS LISP)
</sectionHeader>
<bodyText confidence="0.986199458333334">
isfy the other. Combining the sub-goal solutions yields
&amp;quot;Lisp machine&amp;quot; as a solution to the original goal.
Multiple compounds are handled by repeated invo-
cations of the rules. Suppose we have a Mechanism-
Maintenance rule, stating that if &amp;quot;x&amp;quot; denotes a Ma-
chine and &amp;quot;y&amp;quot; denotes any kind of MaintenanceOpera-
lion, &amp;quot;x y&amp;quot; denotes a Maintenance Operation y with y
Maintains x. Given input semantics (Y ISA Repair-
Operation)(Y Maintains X)(X ISA Computer&amp;quot; Can-
RunLanguage Z)(Z Equals Lisp), with distinguished ref-
erent Y, the maintenance rule will eventually fire, gen-
erating patterns for a head (Y ISA RepairOperation)
and a modifier (X ISA Computer&amp;quot; CanRunLanguage
Z)(Z Equals Lisp). The head&apos;s goal will be satisfied by
the entry for &amp;quot;repair&amp;quot;, but processing of the modifier
will invoke the Software-Machine rule, just as in the
example above. The output will be &amp;quot;Lisp machine re-
pair&amp;quot;, with the left-branching structure [[Lisp machine]
repair].
For an example of a right-branching compound, sup-
pose we have a Product-Manufacturer rule stating
that if &amp;quot;x&amp;quot; is the name of a Product and &amp;quot;y&amp;quot; is the
name of a Company, then &amp;quot;a y x&amp;quot; is a Product x that is
ManufacturedBy company y. Given the input (X ISA
</bodyText>
<subsubsectionHeader confidence="0.570143">
Computer)(X ManufacturedBy Y)(X CanRunLanguage
Z)(Y Equals Symbolics)(Z Equals Lisp), the product
</subsubsectionHeader>
<bodyText confidence="0.966864">
rule will fire, producing a modifier sub-goal for (Y
Equals Symbolics) and a head sub-goal for (X ISA Com-
puter)(X CanRunLanguage Z)(Z Equals Lisp). This
time the Software-Machine rule will be invoked on
the head sub-goal, while lexical item &amp;quot;Symbolics&amp;quot; will
satisfy the modifier sub-goal, and the output will be
[Symbolics [Lisp machine]].
</bodyText>
<table confidence="0.617174307692308">
Generating Metonymic References
GOAL
MR
(X ISA BOOK)
(A HASCREATOP Y)
(V EQUALS JRMESJOYCE)
SUBGOAL
NP
(R EQUALS JAMESJOYCE)
LEFT -SUBGOAL
(1 EQUALS LISP)
RIGHT -SUBGOAL
(14 ISA COMPUTER)
</table>
<figureCaption confidence="0.999846">
Figure 3: Decomposition for Metonymy
Figure 2: Decomposition for a Noun Compound
</figureCaption>
<bodyText confidence="0.998205142857143">
Recursing on the sub-goals, the lexical item &amp;quot;Lisp&amp;quot;
will satisfy the left sub-goal, and &amp;quot;machine&amp;quot; will sat-
Suppose we have an Artist rule licensing the use of
an artist&apos;s name to refer to his works, and are try-
ing to generate an NP with semantics (X ISA Book&amp;quot;
Has Creator JamesJoyce). If we are in all-paths mode,
or if the strategic component has requested a succinct
</bodyText>
<page confidence="0.99736">
49
</page>
<bodyText confidence="0.999195571428572">
solution, the Artist rule will fire, yielding the decom-
position shown in Figure 3.
In this case, the new goal is immediately satisfied by
the lexical entry for &amp;quot;Joyce&amp;quot;, but in principle the solu-
tion to the metonymous sub-goal could involve peeling
off various modifiers, yielding, for example, &amp;quot;an excruc-
tiatingly boring Walter Scott.&amp;quot;
</bodyText>
<subsectionHeader confidence="0.926819">
Semantic Rules during Understanding
</subsectionHeader>
<bodyText confidence="0.998960035714286">
The use of semantic rules during understanding is
straightforward. Noun compounding rules are invoked
in the appropriate syntactic context, and they merge
the interpretations of the two nouns into a single mean-
ing. Metonymy rules are invoked when the knowledge
base rejects the literal meaning as inconsistent. Given
input &amp;quot;Bill reads Shakespeare&amp;quot;, the KB will not per-
mit Bill to read the person Shakespeare, and the first
try at semantic interpretation fails. We then invoke all
available metonymy rules (on both &amp;quot;reads&amp;quot; and &amp;quot;Shake-
speare&amp;quot;), and the Artist rule mentioned above suc-
ceeds, leading to the desired interpretation.
A hierarchy of rules is established by assigning each
rule a level of effort, so that it is invoked only when the
appropriate level is reached. Processing stops at the
lowest level at which it can find an interpretation that
the KB accepts. At each level, we consider all combi-
nations of rules and lexical items from that level with
items from previous levels, so it is possible for, e.g., a
level 2 metonymy rule to feed a level 1 noun compound-
ing rule, as in the example below, but only if there is no
consistent interpretation at level 1 alone. The follow-
ing trace shows the level 2 Artist metonymy rule given
above interleaving with the level 1 WorkPerformed
compounding rule (which states that if &amp;quot;x&amp;quot; denotes an
instance of Work0fArt and &amp;quot;y&amp;quot; denotes an instance
of Performance, then &amp;quot;an x y&amp;quot; denotes a performance
whose WorkPerformed is x.
</bodyText>
<table confidence="0.994519588235294">
Parse &amp;quot;a Bach recital&amp;quot;
...Level 1
...Trying WorkPerformed CPD Rule
...Failing
;; since JSBach is not a Work0fArt
...Level 2
...Trying Artist Metonymy Rule on
(X Equals JSBach)
...Success
;; now &amp;quot;Bach&amp;quot; -&gt;
(X ISA Work0fArt)(X HasCreator JSBach)
...Level 1
...Trying WorkPerformed CPD Rule
...Success
;; interpretation is now -&gt;
(X ISA Work0fArt)(X HasCreator JSBach)
(Y ISA Performance)(Y WorkPerformed X)
</table>
<subsectionHeader confidence="0.719632">
Semantic Rule Implementation
</subsectionHeader>
<bodyText confidence="0.999876929824562">
Semantic rules, as we noted earlier, map partial seman-
tic interpretations (sets of assertions) onto other partial
interpretations&apos;. The left and right hand sides of the
rules are therefore specified as templates, i.e., as sets
of assertions with variables in predicate and term po-
sitions. For both forward and backward chaining, rule
application proceeds in three steps: unification with the
rule&apos;s input templates, computation of the output bind-
ings from the input bindings, and instantiation of the
output template. The only difference between forward
and backward chaining applications is which sides of
the rule serve as the input and output. Rule applica-
tion can fail at either of the first two steps if the input
fails to match the specifications.
The only point worth mentioning about the unifi-
cation and instantiation operations is that they allow
sub-classes in the input to match super-classes in the
rule pattern. Thus in the MechanismMaintenance
example above, the classes Computer and RepairOper-
ation in the input match Machine and MaintenanceOp-
eration in the rule.
The complexity lies in the second step, where we must
map a set of bindings for either side of the rule onto a
set of bindings for the other side. Crucially, the values
of bindings are either variables, or, most important,
objects in the KB (classes or relations), and the second
stage of rule application consists of 1) checking that the
KB objects meet certain conditions, and 2) using the
KB objects to compute the value of the new bindings.
For example, when we apply the Artist metonymy rule
to an expression in the forward direction, we must 1)
check that it denotes a person, and 2) find the kinds
of works of art that the person creates - poems, music,
etc., since these are the types of objects that the name
can be used to refer to.
To perform these operations, we create two kinds of
expressions which can be evaluated in a binding en-
vironment: 1) Filter expressions, which have a single
parameter, and return T or Nil depending on whether
the binding of that parameter satisfies the expression
2) Bind expressions, which have two parameters, and
return a set of bindings for the first parameter, based
on evaluating the rest of the expression in the envi-
ronment. Thus evaluating (Filter (X ISA Dog)) in an
environment will return T if X is bound to an instance
of Dog, and evaluating (Bind Z (X CreatorOf)) will re-
turn a set of extended bindings, each with Z bound to
one of the things that X is the CreatorOf To apply a
rule in either direction, we start with the bindings from
the input unification (if it succeeded) and evaluate the
Filter and Bind expressions in order, eliminating any
environment in which a Filter expression returns Nil.
The rule succeeds if it outputs one or more extended
environments, which are then used to instantiate the
output templates.
A rule&apos;s Filter and Bind statements compute a rela-
tion between input and output bindings. To reverse the
</bodyText>
<footnote confidence="0.99508">
3The rules also allow for optional specification of syntac-
tic categories and surface string.
</footnote>
<page confidence="0.997928">
50
</page>
<bodyText confidence="0.998797869565217">
rule, we need to compute the inverse of the relation.&apos;
To do this we reverse the order of the statements and re-
place each Bind statement (which computes a relation
between variable bindings) with its inverse. Here we
rely on the fact that the CYC KB automatically main-
tains inverses for all relations defined in it (for KBs
without this feature, we would have to define inverses
for all relations used in rules). If CreatorOf is the in-
verse of HasCreator, then the inverse of (Bind Z (X
CreatorOf)) is simply (Bind X (Z HasCreator)).
A few more details are necessary to complete the im-
plementation. First, we define the relation Instances,
which maps from classes to their elements, as the in-
verse of ISA. Next we define a concatenation operator
+ on relations, so that (Z (Instances + HasCreator)) re-
turns all the creators of instances of the class Z.&apos; Next,
we stipulate that if the variable X is already bound,
(Bind X (Z HasCreator)) acts as a Filter, returning T
if X is among the values for (Z HasCreator.) Finally,
for reasons of efficiency, we cache separate patterns for
backward and forward application, instead of reversing
the expressions at run time. The generation and under-
standing patterns for the Artist rule are given below:
</bodyText>
<figure confidence="0.84519325">
Input Pattern (W ISA Z)(new-var HasCreator X)
Bind Y (Z Instances + If
Filter (Y ISA Person)
OutputPattern (X Equals Y)
Input Pattern (X Equals Y)
Filter (Y ISA Person)
Bind Z (Y CreatorOf + ISA)
Output Pattern(W ISA Z)(new-var HasCreator Y)
</figure>
<bodyText confidence="0.9995541">
Running the rule backward on (Q ISA Book)(Q
HasCreator JamesJoyce), initial unification binds Q to
W, Z to Book and Y to JamesJoyce. The Bind ex-
pression serves as a filter in this case, checking that Y
is in fact the CreatorOf some instance of Z, the Filter
expression checks that Y is a Person, and the output
is (X Equals JamesJoyce), which will match the lexi-
cal semantics for &amp;quot;Joyce&amp;quot; permitting us to use that NP
to refer to the book. Running the rule forward on (X
Equals JamesJoyce), Yis bound to JamesJoyce, the Fil-
ter expression again checks that Y is a Person, and the
Bind expression binds Z to all the classes of objects Y is
the Creator0f(in this case, the class Book). The output
is an expression denoting any Book which HasCreator
JamesJoyce, thus letting us understand &amp;quot;Joyce&amp;quot; as re-
ferring to a Book.
The rule format is similar for noun compounds, ex-
cept that there are two input patterns (in the forward
direction) and a single output pattern. During under-
standing, the two patterns are unified with the inter-
</bodyText>
<footnote confidence="0.5793655">
4MathematicaLly, a relation is a set of ordered pairs, and
its inverse is the set of inverted pairs. Any relation is there-
fore guaranteed to have a unique inverse.
5The inverse of (rl r2) is ((inverse r2) + (inverse rl)).
</footnote>
<bodyText confidence="0.999933166666667">
pretations of the head and modifier nouns, the Filters
and Binds work as before, and the output pattern is the
interpretation of the compound. Backward application
is as before, except that the output is a pair of instan-
tiated patterns which the generation routine then uses
as new goals.
</bodyText>
<subsectionHeader confidence="0.908377">
Related Work
</subsectionHeader>
<bodyText confidence="0.99921005">
A variety of systems have used rules of the kind
we are considering, either explicitly or implicitly,
for use in understanding compounds, vague expres-
sions, and metonymy, for example, [Dahl et al. 87],
[Hobbs et al. 88], [Grosz et al. 85], [Stallard 87], but
no mention is made of reversing these rules for gen-
eration.
A number of systems generate compounds, but
most apparently do so using either phrasal lexi-
cons (e.g., [Hovy 88], [Jacobs 88b], [Wilensky 88]), or
multiple lexical senses (e.g., [Pustejovsky et al. 87],
[Nirenburg et al. 88]), rather than rules of the sort we
propose. Other generation systems apparently con-
struct noun compounds via specialized (uni-directional)
strategies specified in the interface to the tactical com-
ponent [McDonald et al. 881, or a combination of these
techniques [McKeown 82]. We have been unable to find
discussions of generation of metonymy, though at least
some cases of it could obviously be handled via lexical
ambiguity.
</bodyText>
<sectionHeader confidence="0.991184" genericHeader="method">
Discussion
</sectionHeader>
<bodyText confidence="0.999963192307692">
The use of semantic rules seems to us to handle most of
the technical problems in providing an economical, bi-
directional treatment of a variety of non-literal and/or
vague constructions. At the heart of any reversible sys-
tem is the notion of being able to run mappings for-
wards or backwards, so that, for example, the under-
standing and generation lexicons are inverses of each
other. These rules are a natural extension of this mech-
anism to more complex constructions. Furthermore,
these rules can handle a wide variety of phenomena. In
addition to the examples discussed above, we have used
semantic rules for the lexical semantics of vague words
like &amp;quot;have&amp;quot; and &amp;quot;of&amp;quot;, which are like noun compounding
and metonymy in that the only alternative to massive
lexical ambiguity is to compute the nature of the rela-
tion based on the interpretation of the arguments. This
use of semantic rules for lexical semantics amounts to
permitting a lexical item to further decompose its sub-
goal, instead of satisfying it immediately in the man-
ner of Figure 1. Finally, these rules do not commit us
to any particular analysis of the constructions in ques-
tion (except insofar as they assume separate levels of
syntactic and semantic representation.) To take noun
compounding as an example, we can implement a wide
variety of theories of the kinds of relations compounds
express and of the hierarchies among them.
</bodyText>
<page confidence="0.996568">
51
</page>
<bodyText confidence="0.999957391304348">
The main open issue is the development of strategies
for the use of these expressions. The problem is most
acute in the case of metonymy. At present, the strate-
gic component can force the use of metonymous expres-
sions by requiring brevity. However, use of metonymy
is not just a matter of succinctness since it also tends
to indicate informality and familiarity. In more ex-
treme uses, it may have a poetic or humorous force.
To use metonymy, compounds, or other vague expres-
sions successfully, we need a theory of how they effect
the discourse, as well as a strategic component which
is sophisticated enough to exploit the theory. As a first
step in this direction, we are implementing a discourse
module which will allow us to address some of these
issues. For example, metonymous expressions are safer
when used to refer to classes of objects that have al-
ready been described than when used to introduce new
ones. If &amp;quot;an Orvis fishing rod&amp;quot; has already been men-
tioned, then &amp;quot;an Orvis&amp;quot; is likely to make sense, even to
people who wouldn&apos;t have understood it the first time
around. However, such individual heuristics will be of
limited usefulness until they are integrated into a com-
prehensive model of communication.
</bodyText>
<sectionHeader confidence="0.998385" genericHeader="method">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.999857">
We are grateful to Elaine Rich for comments on an ear-
lier draft of this paper.
</bodyText>
<sectionHeader confidence="0.99192" genericHeader="method">
Appendix: Generation Algorithm
</sectionHeader>
<bodyText confidence="0.999965037037037">
The psuedocode for the generation algorithm is shown
below, identifying the point of departure from the
[Calder at al. 89] algorithm. The lexical lookup-step of
line 1 is replaced with the more general top-down step
of line la, by calling the new function generate-tp-dn.
The rest of the (pseudo)code remains unchanged.
Here are the language constructs used in the pseu-
docode. We denote local variable assignment as X
Y, with scope extending to the immediate containing
construct. Destructuring by pattern matching is al-
lowed, e.g. &lt; X1 X2 X3 &gt;:= Y simultaneously binds
Xl, X2 and X3 to the corresponding components in Y.
AND and OR have exactly the behavior of Common
Lisp AND and OR.
For the sake of conciseness,the function choose is used
as a shorthand for control strategies: in all-paths mode,
it finds all solutions; in best-first mode it imposes a
heuristic ordering on the choices and finds a single so-
lution, finding any subsequent solutions on backtrack-
ing. The function choose-tp-dn-operation heuristically
picks the best operation based on the goal. The func-
tions match and satisfy are as defined earlier. The
functions apply-unary-bup-rule and apply-binary-bup-
rule constitute the rule application interface to gram-
mar rules; similarly, the functions apply-unary-tp-dn-
rule and apply-binary-tp-dn-rule constitute the rule ap-
plication interface for the semantic rules.
</bodyText>
<sectionHeader confidence="0.736173125" genericHeader="method">
FUNCTION generate(Goal):
1 AND(;;OLD: Subgoal := lex-decomp(Goal)
;; NEW:
la Subgoal := choose(generate-tp-dn(Goal))
;; AS BEFORE:
2 choose(generate-bup(Subgoal, Goal))).
FUNCTION generate-tp-dn(Goal);
operation :=
</sectionHeader>
<bodyText confidence="0.893251472222222">
choose(choose-tp-dn-operation(Goal))
CASE operation
:lex
lex-decomp(Goal)
:unary-decomp
;; e.g. METONYMY RULES:
choose(apply-unary-tp-dn-rule(Goal))
:binary-decomp
;; e.g. COMPOUNDING/VAGUE WORD RULES:
AND(&lt;left-subgoal, right-subgoal&gt; :=
choose(apply-binary-tp-dn-rule
(Goal)),
choose(generate(left-subgoal)),
choose(generate(right-subgoal)),
choose(apply-binary-bup-rule
(left-subgoal, right-subgoal))).
FUNCTION generate-bup(Subgoal, Goal);
OR(satisfies(Subgoal, Goal),
AND(Arg :=
choose(extract-arg(Subgoal)),
Goall :=
choose(apply-binary-bup-rule
(Subgoal, Arg)),
choose(generate(Arg)),
choose(generate-bup
(Goall, Goal))),
AND(Goall :=
choose(apply-unary-bup-rule
(Subgoal)),
choose(generate-bup
(Goall, Goal)))).
FUNCTION lex-decomp(Goal):
AND(Subgoal :=
choose(lexical-lookup(Goal)),
matches(Subgoal, Goal),
Subgoal).
</bodyText>
<sectionHeader confidence="0.927351" genericHeader="references">
References
</sectionHeader>
<bodyText confidence="0.981841888888889">
[Appelt 83] D. E. Appelt, &amp;quot;Telegram: A Grammar For-
malism For Language Planning&amp;quot;, Proceedings of
the ACL, M.I.T., 15-17 June, 1983.
[Appelt 87] D. E. Appelt, &amp;quot;Bidirectional Grammars
and the Design of Natural Language Generation
Systems&amp;quot;, TINLAP-3 Position Papers, New Mex-
ico State University, 7-9 January, 1987.
[Barnett et at. 90] J. Barnett, K. Knight, I. Mani, and
E. Rich, &amp;quot;Knowledge and Natural Language Pro-
</bodyText>
<page confidence="0.996532">
52
</page>
<reference confidence="0.998131845238095">
cessing&amp;quot;, to appear in Communications of the
ACM, August, 1990.
[Calder at al. 89] J. Calder, M. Reape, and H. Zeevat,
&amp;quot;An Algorithm for Generation in Unification Cat-
egorial Grammar&amp;quot;, Proceedings of the 4th Confer-
ence of the European Chapter of the ACL, pp. 233-
240, Manchester, 10-12 April, 1989.
[Cohen et al. 89] R. M. Cohen, T. P. McCandless, and
E. Rich, &amp;quot;A Problem Solving Approach to Human-
Computer Interface Management&amp;quot;, MCC Tech
Report ACT-HI-306-89, Fall 1989.
[Dahl et al. 87] D. Dahl, M. Palmer, and R. Passon-
neau, &amp;quot;Nominalizations in Pundit&amp;quot;, Proceedings of
the ACL, Stanford, 6-9 July, 1987.
[Finin 80] T. Finin, &amp;quot;The Semantic Interpretation
of Compound Nominals&amp;quot;, University of Illinois,
Ph.D. Dissertation, 1980.
[Grosz et al. 85] B. Grosz, D. Appelt, P. Martin, and
F. C. N. Pereira, &amp;quot;Team: An Experiment in the
Design of Transportable Natural-Language Inter-
faces&amp;quot;, Artificial Intelligence.
[Hobbs et al. 88] J. R. Hobbs, M. Stickel, P. Martin,
and D. Edwards, &amp;quot;Interpretation as Abduction&amp;quot;,
Proceedings of the ACL, Buffalo, 7-10 June, 1988.
[Hovy 88] E. II. Hovy, &amp;quot;Generating Language with a
Phrasal Lexicon&amp;quot;, in D. D. McDonald and L.
Bolc, eds., Natural Language Generation Systems,
Springer-Verlag, 1988.
[Jacobs 88a] P. S. Jacobs, &amp;quot;Achieving Bidirectional-
ity&amp;quot;, Proceedings of the 1th International Confer-
ence on Computational Linguistics, Budapest, 22-
27 August, 1988, pp. 267-269.
[Jacobs 88b] P. S. Jacobs, &amp;quot;PHRED: A Generator for
Natural Language Interfaces&amp;quot;, in D. D. McDonald
and L. Bolc, eds., Natural Language Generation
Systems, Springer-Verlag, 1988.
[Lenat et al. 90] D. Lenat and R. Guha, &amp;quot;Building
Large Knowledge Based Systems, Representations
and Inference in the CYC Project&amp;quot;, Addison Wes-
ley, 1990.
[McDonald et al. 88] D. D. McDonald and M. W.
Meteer, &amp;quot;From Water to Wine: Generating Natu-
ral Language Text from Today&apos;s Application Pro-
grams&amp;quot;, Second Conference on Applied Natural
Language Processing, Austin, 9-12 February, 1988.
[McKeown 82] K. R. McKeown, &amp;quot;Generating Natural
Language Text in Response to Questions About
Database Structure&amp;quot;, University of Pennsylvania,
Ph.D. Dissertation, 1982.
[Nirenburg et al. 88] S. Nirenburg, R. McCardell, E.
Nyberg, P. Werner, S. Huffman, E. Kenschaft and
I. Nirenburg, &amp;quot;DIOGENES-88&amp;quot;, CMU Tech Re-
port CMU-CMT-88-107, June 1988.
[Nunberg 78] G. Nunberg, &amp;quot;The Pragmatics of Refer-
ence&amp;quot;, City College of New York, Ph.D. Disserta-
tion, 1978.
[Pustejovsky et al. 87] J. Pustejovsky and S. Niren-
burg, &amp;quot;Lexical Selection in the Process of Lan-
guage Generation&amp;quot;, Proceedings of the ACL, Stan-
ford, 6-9 July, 1987.
[Shieber 88] S. M. Shieber, &amp;quot;A Uniform Architecture
for Parsing and Generation&amp;quot;, Proceedings of the
12th International Conference on Computational
Linguistics, Budapest, 22-27 August, 1988, pp.
614-619.
[Shieber et al. 89] S. M. Shieber, G. van Noord, R. C.
Moore, and F. C. N. Pereira, &amp;quot;A Semantic-Head-
Driven Generation Algorithm for Unification-
Based Formalisms&amp;quot;, Proceedings of the ACL, Van-
couver, 26-29 June, 1989.
[Stallard 87] D. Stallard, &amp;quot;The Logical Analysis of Lex-
ical Ambiguity&amp;quot;, Proceedings of the ACL, Stan-
ford, 6-9 July, 1987.
[Vaughan et al. 86] M. M. Vaughan and D. D. McDon-
ald, &amp;quot;A Model of Revision in Natural Language
Generation&amp;quot;, Proceedings of the ACL, New York,
10-13 June, 1986.
[Wilensky 88] R. Wilensky, D. N. Chin, M. Luria, J.
Martin, J. Mayfield, and D. Wu, &amp;quot;The Berkeley
UNIX Consultant Project&amp;quot;, Computational Lin-
guistics, Vol. 14, No. 4, December 1988.
[Wittenburg 86] K. Wittenburg, &amp;quot;A Parser for Portable
NL Interfaces Using Graph-Unification-Based
Grammars&amp;quot;, Proceedings of AAAI 86, 1986.
</reference>
<page confidence="0.999296">
53
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.944167">
<title confidence="0.999993">Using Bidirectional Semantic Rules for Generation</title>
<author confidence="0.983982">Barnett</author>
<affiliation confidence="0.991352">Microelectronics and Computer Technology Corporation</affiliation>
<address confidence="0.991190333333333">3500 West Balcones Center Drive Austin, Texas U.S.A.</address>
<abstract confidence="0.997541833333333">This paper describes the use of a system of semantic rules to generate noun compounds, vague or polysemous words, and cases of metonymy. The rules are bidirectional and are used by the understanding system to interpret the same constructions.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<title>cessing&amp;quot;, to appear in</title>
<date>1990</date>
<journal>Communications of the ACM,</journal>
<marker>1990</marker>
<rawString> cessing&amp;quot;, to appear in Communications of the ACM, August, 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Calder</author>
<author>M Reape</author>
<author>H Zeevat</author>
</authors>
<title>An Algorithm for Generation in Unification Categorial Grammar&amp;quot;,</title>
<date>1989</date>
<booktitle>Proceedings of the 4th Conference of the European Chapter of the ACL,</booktitle>
<pages>233--240</pages>
<location>Manchester,</location>
<marker>[Calder at al. 89]</marker>
<rawString>J. Calder, M. Reape, and H. Zeevat, &amp;quot;An Algorithm for Generation in Unification Categorial Grammar&amp;quot;, Proceedings of the 4th Conference of the European Chapter of the ACL, pp. 233-240, Manchester, 10-12 April, 1989.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R M Cohen</author>
<author>T P McCandless</author>
<author>E Rich</author>
</authors>
<title>A Problem Solving Approach to HumanComputer Interface Management&amp;quot;,</title>
<date>1989</date>
<tech>MCC Tech Report ACT-HI-306-89,</tech>
<location>Fall</location>
<marker>[Cohen et al. 89]</marker>
<rawString>R. M. Cohen, T. P. McCandless, and E. Rich, &amp;quot;A Problem Solving Approach to HumanComputer Interface Management&amp;quot;, MCC Tech Report ACT-HI-306-89, Fall 1989.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Dahl</author>
<author>M Palmer</author>
<author>R Passonneau</author>
</authors>
<title>Nominalizations in Pundit&amp;quot;,</title>
<date>1987</date>
<booktitle>Proceedings of the ACL, Stanford,</booktitle>
<pages>6--9</pages>
<marker>[Dahl et al. 87]</marker>
<rawString>D. Dahl, M. Palmer, and R. Passonneau, &amp;quot;Nominalizations in Pundit&amp;quot;, Proceedings of the ACL, Stanford, 6-9 July, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Finin</author>
</authors>
<title>The Semantic Interpretation of Compound Nominals&amp;quot;,</title>
<date>1980</date>
<institution>University of Illinois, Ph.D. Dissertation,</institution>
<marker>[Finin 80]</marker>
<rawString>T. Finin, &amp;quot;The Semantic Interpretation of Compound Nominals&amp;quot;, University of Illinois, Ph.D. Dissertation, 1980.</rawString>
</citation>
<citation valid="false">
<authors>
<author>B Grosz</author>
<author>D Appelt</author>
<author>P Martin</author>
<author>F C N Pereira</author>
</authors>
<title>Team: An Experiment in the Design of Transportable Natural-Language Interfaces&amp;quot;,</title>
<journal>Artificial Intelligence.</journal>
<marker>[Grosz et al. 85]</marker>
<rawString>B. Grosz, D. Appelt, P. Martin, and F. C. N. Pereira, &amp;quot;Team: An Experiment in the Design of Transportable Natural-Language Interfaces&amp;quot;, Artificial Intelligence.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J R Hobbs</author>
<author>M Stickel</author>
<author>P Martin</author>
<author>D Edwards</author>
</authors>
<title>Interpretation as Abduction&amp;quot;,</title>
<date>1988</date>
<booktitle>Proceedings of the ACL,</booktitle>
<location>Buffalo,</location>
<marker>[Hobbs et al. 88]</marker>
<rawString>J. R. Hobbs, M. Stickel, P. Martin, and D. Edwards, &amp;quot;Interpretation as Abduction&amp;quot;, Proceedings of the ACL, Buffalo, 7-10 June, 1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hovy</author>
</authors>
<title>Generating Language with a Phrasal Lexicon&amp;quot;,</title>
<date>1988</date>
<booktitle>Natural Language Generation Systems,</booktitle>
<editor>in D. D. McDonald and L. Bolc, eds.,</editor>
<publisher>Springer-Verlag,</publisher>
<marker>[Hovy 88]</marker>
<rawString>E. II. Hovy, &amp;quot;Generating Language with a Phrasal Lexicon&amp;quot;, in D. D. McDonald and L. Bolc, eds., Natural Language Generation Systems, Springer-Verlag, 1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P S Jacobs</author>
</authors>
<title>Achieving Bidirectionality&amp;quot;,</title>
<date>1988</date>
<booktitle>Proceedings of the 1th International Conference on Computational Linguistics, Budapest,</booktitle>
<pages>22--27</pages>
<marker>[Jacobs 88a]</marker>
<rawString>P. S. Jacobs, &amp;quot;Achieving Bidirectionality&amp;quot;, Proceedings of the 1th International Conference on Computational Linguistics, Budapest, 22-27 August, 1988, pp. 267-269.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P S Jacobs</author>
</authors>
<title>PHRED: A Generator for Natural Language Interfaces&amp;quot;,</title>
<date>1988</date>
<booktitle>Natural Language Generation Systems,</booktitle>
<editor>in D. D. McDonald and L. Bolc, eds.,</editor>
<publisher>Springer-Verlag,</publisher>
<marker>[Jacobs 88b]</marker>
<rawString>P. S. Jacobs, &amp;quot;PHRED: A Generator for Natural Language Interfaces&amp;quot;, in D. D. McDonald and L. Bolc, eds., Natural Language Generation Systems, Springer-Verlag, 1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Lenat</author>
<author>R Guha</author>
</authors>
<title>Building Large Knowledge Based Systems, Representations and Inference in the CYC Project&amp;quot;,</title>
<date>1990</date>
<publisher>Addison Wesley,</publisher>
<marker>[Lenat et al. 90]</marker>
<rawString>D. Lenat and R. Guha, &amp;quot;Building Large Knowledge Based Systems, Representations and Inference in the CYC Project&amp;quot;, Addison Wesley, 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D D McDonald</author>
<author>M W Meteer</author>
</authors>
<title>From Water to Wine: Generating Natural Language Text from Today&apos;s Application Programs&amp;quot;,</title>
<date>1988</date>
<booktitle>Second Conference on Applied Natural Language Processing,</booktitle>
<location>Austin,</location>
<marker>[McDonald et al. 88]</marker>
<rawString>D. D. McDonald and M. W. Meteer, &amp;quot;From Water to Wine: Generating Natural Language Text from Today&apos;s Application Programs&amp;quot;, Second Conference on Applied Natural Language Processing, Austin, 9-12 February, 1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K R McKeown</author>
</authors>
<title>Generating Natural Language Text in Response to Questions About Database Structure&amp;quot;,</title>
<date>1982</date>
<institution>University of Pennsylvania, Ph.D. Dissertation,</institution>
<marker>[McKeown 82]</marker>
<rawString>K. R. McKeown, &amp;quot;Generating Natural Language Text in Response to Questions About Database Structure&amp;quot;, University of Pennsylvania, Ph.D. Dissertation, 1982.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Nirenburg</author>
<author>R McCardell</author>
<author>E Nyberg</author>
<author>P Werner</author>
<author>S Huffman</author>
<author>E Kenschaft</author>
<author>I Nirenburg</author>
</authors>
<date>1988</date>
<tech>DIOGENES-88&amp;quot;, CMU Tech Report CMU-CMT-88-107,</tech>
<marker>[Nirenburg et al. 88]</marker>
<rawString>S. Nirenburg, R. McCardell, E. Nyberg, P. Werner, S. Huffman, E. Kenschaft and I. Nirenburg, &amp;quot;DIOGENES-88&amp;quot;, CMU Tech Report CMU-CMT-88-107, June 1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Nunberg</author>
</authors>
<title>The Pragmatics of Reference&amp;quot;, City College of</title>
<date>1978</date>
<location>New York, Ph.D. Dissertation,</location>
<marker>[Nunberg 78]</marker>
<rawString>G. Nunberg, &amp;quot;The Pragmatics of Reference&amp;quot;, City College of New York, Ph.D. Dissertation, 1978.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Pustejovsky</author>
<author>S Nirenburg</author>
</authors>
<title>Lexical Selection in the Process of Language Generation&amp;quot;,</title>
<date>1987</date>
<booktitle>Proceedings of the ACL, Stanford,</booktitle>
<pages>6--9</pages>
<marker>[Pustejovsky et al. 87]</marker>
<rawString>J. Pustejovsky and S. Nirenburg, &amp;quot;Lexical Selection in the Process of Language Generation&amp;quot;, Proceedings of the ACL, Stanford, 6-9 July, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S M Shieber</author>
</authors>
<title>A Uniform Architecture for Parsing and Generation&amp;quot;,</title>
<date>1988</date>
<booktitle>Proceedings of the 12th International Conference on Computational Linguistics,</booktitle>
<pages>614--619</pages>
<location>Budapest,</location>
<marker>[Shieber 88]</marker>
<rawString>S. M. Shieber, &amp;quot;A Uniform Architecture for Parsing and Generation&amp;quot;, Proceedings of the 12th International Conference on Computational Linguistics, Budapest, 22-27 August, 1988, pp. 614-619.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S M Shieber</author>
<author>G van Noord</author>
<author>R C Moore</author>
<author>F C N Pereira</author>
</authors>
<title>A Semantic-HeadDriven Generation Algorithm for UnificationBased Formalisms&amp;quot;,</title>
<date>1989</date>
<booktitle>Proceedings of the ACL,</booktitle>
<location>Vancouver,</location>
<marker>[Shieber et al. 89]</marker>
<rawString>S. M. Shieber, G. van Noord, R. C. Moore, and F. C. N. Pereira, &amp;quot;A Semantic-HeadDriven Generation Algorithm for UnificationBased Formalisms&amp;quot;, Proceedings of the ACL, Vancouver, 26-29 June, 1989.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Stallard</author>
</authors>
<title>The Logical Analysis of Lexical Ambiguity&amp;quot;,</title>
<date>1987</date>
<booktitle>Proceedings of the ACL, Stanford,</booktitle>
<pages>6--9</pages>
<marker>[Stallard 87]</marker>
<rawString>D. Stallard, &amp;quot;The Logical Analysis of Lexical Ambiguity&amp;quot;, Proceedings of the ACL, Stanford, 6-9 July, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M M Vaughan</author>
<author>D D McDonald</author>
</authors>
<title>A Model of Revision in Natural Language Generation&amp;quot;,</title>
<date>1986</date>
<booktitle>Proceedings of the ACL,</booktitle>
<pages>10--13</pages>
<location>New York,</location>
<marker>[Vaughan et al. 86]</marker>
<rawString>M. M. Vaughan and D. D. McDonald, &amp;quot;A Model of Revision in Natural Language Generation&amp;quot;, Proceedings of the ACL, New York, 10-13 June, 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Wilensky</author>
<author>D N Chin</author>
<author>M Luria</author>
<author>J Martin</author>
<author>J Mayfield</author>
<author>D Wu</author>
</authors>
<title>The Berkeley UNIX Consultant Project&amp;quot;,</title>
<date>1988</date>
<journal>Computational Linguistics,</journal>
<volume>14</volume>
<marker>[Wilensky 88]</marker>
<rawString>R. Wilensky, D. N. Chin, M. Luria, J. Martin, J. Mayfield, and D. Wu, &amp;quot;The Berkeley UNIX Consultant Project&amp;quot;, Computational Linguistics, Vol. 14, No. 4, December 1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Wittenburg</author>
</authors>
<title>A Parser for Portable NL Interfaces Using Graph-Unification-Based Grammars&amp;quot;,</title>
<date>1986</date>
<booktitle>Proceedings of AAAI 86,</booktitle>
<marker>[Wittenburg 86]</marker>
<rawString>K. Wittenburg, &amp;quot;A Parser for Portable NL Interfaces Using Graph-Unification-Based Grammars&amp;quot;, Proceedings of AAAI 86, 1986.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>