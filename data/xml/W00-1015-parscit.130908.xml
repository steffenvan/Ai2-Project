<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.985315">
Flexible Speech Act Based Dialogue Management
</title>
<author confidence="0.995687">
Eli Hagen and Fred Popowich
</author>
<affiliation confidence="0.972896">
School of Computing Science
Simon Fraser University
</affiliation>
<address confidence="0.849626">
Canada V5A 1S6
</address>
<email confidence="0.99482">
fhagen,popowichl@cs.sfu.ca
</email>
<sectionHeader confidence="0.969377" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999947">
We present an application independent dialogue
engine that reasons on application dependent
knowledge sources to calculate predictions about
how a dialogue might continue. Predictions are
language independent and are translated into lan-
guage dependent structures for recognition and
synthesis. Further, we discuss how the predic-
tions account for different kinds of dialogue, e.g.,
question-answer or mixed initiative.
</bodyText>
<sectionHeader confidence="0.999649" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999964580645161">
The computerized spoken information systems (or
Spoken Dialogue System—SDS) that we will con-
sider in this paper are systems where a computer
acts as the operator of some service and inter-
acts with a user in natural language, e.g., switch
board, directory assistance, or ticket service. Be-
fore an SDS can provide its information, it needs
to acquire data from the user, e.g., customer name
and number, birth date, service location, or ser-
vice date. We call these parameter values. In an
SDS they are acquired orally and speech recogni-
tion is used to decode the speech signal into words.
A dialogue manager facilitates the negotiation
of parameter values between a user and an SDS.
We emphasize keeping our dialogue manager ap-
plication and language independent, thus we fac-
tored out the independent information into two
components. A dialogue engine calculates pre-
dictions for how to continue a dialogue from de-
pendent knowledge sources (e.g., dialogue gram-
mar and history, application description). A prag-
matic interpreter maps syntactic/semantic inter-
pretation results onto predictions.
Our predictions are called dialogue primitives;
GEN-primitives predict system utterances and
REC-primitives predict user utterances. They are
language independent and on both the recogni-
tion and the generation side, other modules trans-
late them into language dependent structures. In
this paper, we will discuss the kinds of primi-
tives our dialogue manager calculates and how
</bodyText>
<figureCaption confidence="0.985014">
Figure 1: System architecture of our SDS. The
arcs indicate information flow.
</figureCaption>
<bodyText confidence="0.9746375">
they account for different kinds of dialogue, e.g.,
question-answer or mixed initiative.
</bodyText>
<sectionHeader confidence="0.995357" genericHeader="introduction">
2 Background
</sectionHeader>
<bodyText confidence="0.999969125">
First, we discuss our system architecture and data
flow between modules. Second, we present the ap-
plication description of a movie service, which we
will use for the examples in later sections. Third,
we present some of our current primitives, and fi-
nally, we describe the dialogue engine and how it
uses the application description and other sources
to calculate dialogue primitives.
</bodyText>
<subsectionHeader confidence="0.98724">
2.1 System Architecture
</subsectionHeader>
<bodyText confidence="0.999898363636364">
Our system architecture is presented in Figure 1.
The dialogue manager takes an application de-
scription (Section 2.2) and a set of dialogue strate-
gies (Sections 3 and 4) as input—both provided by
the service designer. The application description
describes the parameters needed by the service
and is necessarily application dependent. The di-
alogue strategies contain directions for how the di-
alogue shall proceed in certain situations. For ex-
ample, whether to ask for confirmation or spelling
of a badly recognized parameter value or whether
</bodyText>
<figure confidence="0.99843544">
REG-primitives
REC-
SIDE speech
recognizer
syntac./sem.
interpreter
telephone/
microphone
speech
output
REC-
primitives
GEN-
primitiv
response
generator
pragm.
dialogue
engine
application
description
+ dialogue
strategies
GEN-
SIDE
</figure>
<page confidence="0.994539">
131
</page>
<bodyText confidence="0.999078947368421">
to generate system or user directed dialogue.
The output of our dialogue manager is a bag
of abstract, language independent primitives. On
the generation side they encode the next sys-
tem utterance and a response generator trans-
lates the GEN-primitives into text, which is then
synthesized. On the recognition side, the REC-
primitives represent the dialogue manager&apos;s pre-
dictions about the next user utterance. REC-
primitives are translated into (recognition) con-
texts and grammars for speech recognition and
they may activate sub-components of a synsem
grammar. After speech recognition has taken
place, the dialogue engine must be told which pre-
dictions came true, thus the pragmatic interpreter
maps the output of synsem interpreter onto a sub-
bag of REC-primitives, which is then returned to
the dialogue engine for further processing (Sec-
tion 2.4).
</bodyText>
<subsectionHeader confidence="0.992441">
2.2 Application Description
</subsectionHeader>
<bodyText confidence="0.993045382352941">
The application description (AD) specifies the
tasks that a service can solve and the parame-
ter values needed to solve them. The AD for a
movie service is presented in Figure 2. Our repre-
sentation is an extended version of and-or trees1
and in Figure 2, the U-shaped symbols represent
and-relations, while the V-shaped symbols repre-
sent or-relations. Thus, this movie service can
perform three tasks: selling tickets or providing
movie or theatre information. If the user wants
to buy tickets, the system needs to acquire six pa-
rameter values, e.g., the show time, the date, and
the name of the film. Date and show time can
be acquired in several ways. For example, a date
can be a simple date (e.g., &amp;quot;November 17th&amp;quot;) or
a combination of day of the week and week (e.g.,
&amp;quot;Wednesday this week.&amp;quot;).
The nodes keep state information. Open nodes
have not yet been negotiated, topic nodes are be-
ing negotiated, and closed nodes have been negoti-
ated. The currently active task has status active.
Parameters can be retrieved through the func-
tions activeTask(AD), openParams(AD), closed-
Params(AD), and topicParams(AD). Status(p)
returns the status of parameter p. tasks (AD) and
params(AD) return the task arid parameter nodes.
Similar hierarchical domain descriptions have
been suggested in (Young et al., 1990) for a naval
domain and in (Carninero-Gil et al., 1996) for an
e-mail assistance domain. A tree-like organiza-
tion of the domain is sufficent for the information
retrieval domains, which we are currently consid-
ering. We expect, however, that in future work we
&apos;Extensions include has-a relations.
</bodyText>
<figureCaption confidence="0.983078666666667">
Figure 2: A description of a movie service. No-
tation: U and V represent and/or-relations. Sub-
scripts t and,, denote tasks and parameters.
</figureCaption>
<bodyText confidence="0.996330875">
will need to switch to a semantic network struc-
ture or since our future research includes auto-
matic generation of system utterances from our
dialogue primitives, we hope to be able to uti-
lize the ontology and domain organization work,
which has proven so useful for text generation
(Bateman et al., 1994; Bateman et al., 1995), for
both dialogue management and text generation.
</bodyText>
<subsectionHeader confidence="0.997196">
2.3 Dialogue Primitives
</subsectionHeader>
<bodyText confidence="0.9996159375">
Following the procedure outlined in Section 2.4,
the dialogue manager calculates a bag of primi-
tives for each turn and speaker. Our current col-
lection is motivated through our experience with
several domains, e.g., movie service, horoscope
service, and directory assistance. The collection
is not exhaustive and we will add primitives as
wider dialogue coverage is required.
Notation: A primitive is written prim-
Name(p=v,n), where primName is its name; p E
params(AD) u {aTask}; aTask is a special param-
eter whose values E tasks(AD); v is the value of p;
and n is an integer denoting the number of times
a primitive has been uttered. If v is uninstanti-
ated, it is left out for readability. Unless otherwise
stated, p E paran-cs(AD).
</bodyText>
<subsectionHeader confidence="0.797308">
2.3.1 GEN-Primitives
Our current GEN-primitives:
</subsectionHeader>
<bodyText confidence="0.98062725">
salutation(p=v): system opens or closes the inter-
action. p E {hello, goodbye}, v E {morning, day,
evening}.
requestValue(p): system requests a value for the
paxamter p. p E params(AD) U {aTask}.
requestValue(p=v): system asks whether the value
v of parameter p is correct. If this form is used, the
system has a list of alternative values for p, and
</bodyText>
<figure confidence="0.992758636363636">
movie service
movieInfot buyTicketst theatreInfoi
film,,
no0f- city,,\
named- Tickets
ip
Time, time date
theatre,,
week-
week
Dayp
</figure>
<page confidence="0.992793">
132
</page>
<bodyText confidence="0.984723704081633">
v is not a recognition result (e.g., Frankfurt am
Main or Frankfurt an der Oder where Frankfurt
is the recognition result.)
requestValue(aTask=v), v E tasks (AD) U {repeat-
PreServiceTask, useService, repeatService}: system
requests a value for aTask. If v E {repeatPre-
ServiceTask, useService, repeatService}, the system
requests whether the user wants the pre-service
task repeated, the service started (first task after
pre-service task), or a new task started.
requestConfirm(p=v): system asks whether the
value v of parameter p is correct. v is a recog-
nition result. p E params(AD) U {aTask}. Am-
biguous results not resulting from speech recog-
nition, e.g., Frankfurt am Main vs. Frankfurt an
der Oder, would yield multiple requestValue(p=v)
primitives.
requestValueABC(p): system requests the spelling
of the value of parameter p.
requestParam(p=v): system asks whether the
value v is a value for parameter p.
evaluate(p=v) : system acknowledges value v of
parameter p.
promise(p=v): system promises to attempt to
answer the user&apos;s request. p E params(AD) U
{aTask}. v E {pleaseWait}. Only used after nav-
igate, requestParam() or requestAlternative() if
the user has to wait long for a reply.
inform(aTask=v): system informs about the ac-
quired database results. v E activeTask(AD) U
{tooMany, zero}. If v activerask(AD), there
are several answers, if v = tooMany/zero, there
are either too many answers to be enumerated or
zero answers.
inform(aTask=n): system presents the n&apos;th answer
to the query t. n &gt; 0
informAlternative(p): system informs that there
are several possible values for p. p E params(AD)
U {aTask}. v E {tooMany, null}. If v = tooMany,
there are too many alternatives to be enumerated.
v = null, means that v is uninstantiated, not that
there are zero alternatives.
informAlternative(p=v): system informs that a
possible value of p is v. p E params(AD) U
{aTask}.
informNegative(p): system informs that the user
misrecognized something. p E params(AD) U
{aTask}.
informPositive(p): system informs that the user
recognized something correctly. p E params(AD)
U {aTask}.
withdraw(p): system withdraws from dialogue for
reason p E {error} before it has started negotia-
tions.
withdrawOffer(aTask=v): system withdraws an of-
fer for reason v E {error}.
withdrawPromise(aTask=v): system withdraws a
promise for reason v E {error}.
In Section 3, we present several sample instan-
tiations of the primitives.
2.3.2 REC-Primitives
Our current REC-primitives:
reques-tParam(p): user requests which parameter
the system requested. p E params(AD) U {nu*.
requestAlternatives(p): user requests possible val-
ues for parameter p.
requestConfirm(aTask=n): user asks system to
confirm an answer that it has given, e.g., &amp;quot;Was
the first answer $30?&amp;quot; 0 &lt; n &lt; no of query results.
informValue(p=v): user provides value v for pa-
rameter p. p was requested.2
informExtraValue(p=v): user provides value v for
parameter p. p was not requested in the preceeding
system utterance.
informValueABC(p=v): user spells the value v of
parameter p. The spelling is expanded by synsem
and expansions are presented to the dialogue man-
ager.2
informPositive(p=v): user confirms that the value
of parameter p is v. p E params(AD) u {aTask}.
informNegative(p=v): user disconfirms that the
value of parameter p is V. p E params(AD) U
{aTask}.
correctValue(p=v): user corrects a misrecognized
value. Often used together with inform Negative.
For example, &amp;quot;Hamburg, not Homburg.&amp;quot;2
informGarbage(p): user says something but recog-
nizer and/or synsem could not make sense out of
It.
changeValue(p=v): user changes the value of pa-
rameter p to v instead of v&apos;.2
repeatValue(p=v): user repeats the value v of pa-
rameter p.2
correctParam(p=v): user corrects that v is the
value of p, not p&apos;.
disambiguate(p=v): user chooses v as the value of
p when presented with a choice between several
values for p. p E params(AD) U {aTask}.
</bodyText>
<footnote confidence="0.926547">
2The pragmatic interpreter instantiates v.
</footnote>
<page confidence="0.997899">
133
</page>
<bodyText confidence="0.995200757575758">
rejectValue(p=v): the user has been given a se-
ries of alternatives and chooses p=.v&apos;. Primitive is
combined with disambiguate(p=v&apos;).
navigate(aTask=v): user navigates in the query re-
sults. v E {forward, backward, repeat, n} where 0 &lt;
n &lt; no of query results.2
rejectRequest(p=v): user ignores or does not hear
the system request. v E {null, didNotHear}.
rejectOffer(aTask=v): user ignores or does not
hear the system offer. v E tasks(AD)U {null, did-
NotHear}.
evaluate(t=v): user evaluates an answer she has
received. v E {positive, neutral, negative, cancel).
cancel is used to end the current dialogue after at
least one answer has been given and start a new
one without calling again.
promise(p): user promises to find a value for p.
withdrawAccept(aTask=v): user withdraws from
the conversation for reason v E {cancel, hangup}.
With cancel, the user ends the current dialogue
before an answer has been given and starts a new
task without calling again.2
withdrawPromise(p=v): user withdraws a promise
to provide a value for reason v E {cancel,
hangup}.2
withdrawRequest(p=v): user withdraws a request.
p E params(AD) U {forward, backward, repeat, and
n}.2
null(): returned to the dialogue manager if the
user does not say anything and is not expected to
say anything, e.g., after a greeting or promise.
In Section 3, we present several sample instan-
tiations of the primitives.
</bodyText>
<subsectionHeader confidence="0.997968">
2.4 Dialogue Engine
</subsectionHeader>
<bodyText confidence="0.998416236842105">
The dialogue engine (Hagen, 1999) consists of a
reasoning engine and several knowledge sources:
An AD defines an application&apos;s data-needs, a di-
alogue grammar defines how a dialogue may pro-
ceed at the level of speech acts, and a dialogue
history is a dynamically growing parse tree of an
on-going dialogue with respect to the dialogue
grammar. Other knowledge sources may be re-
quired, for instance, recognition confidence or dis-
ambiguation of city names.
The dialogue engine calculates the next turn by
consulting and combining information from the
knowledge sources. It consults with the dialogue
history and the dialogue grammar in order to cal-
culate which speech acts may continue a dialogue.
Speech acts have no propositional content, thus
in the context of the current dialogue history and
the state of the application description, they are
translated into dialogue primitives, which have
content, for example, the name of a parameter
and a potential value for this parameter. Here we
will walk through an example of how some prim-
itives are calculated in a simple question-answer
dialogue.
Example: For our example we will use the AD
in Figure 2. Assume that the task has already
been negotiated and set to theatre information
(i.e., activeTask(AD) = theatrel nfo), i.e., the sys-
tem needs to acquire the name of the theatre and
the name of the city. All other nodes in the AD
are closed since they are not relevant to this task.
The speech act grammar used in our system
is presented in Appendix A but we will use a
trivial grammar for the example. It can account
for simple question-answer dialogues where a
request from the system (sys) is followed by an
inform from the user (usr). The system can
respond to the inform with a sub-dialogue:3
</bodyText>
<equation confidence="0.901554555555556">
Dialogue(sys)—*(request(sys) + Inform(usr))*
I nform ( us r)-4 nform (usr) + [Dialogue(sys)]
The dialogue history reflects all previous ne-
gotiations (here: task theatrelnfo).
Dialogue(sys)
request(sys) Inform(usr)
req uestVa I ue(task)
intorm(usr)
nformVa I ue(task=theatrel nfo)
</equation>
<bodyText confidence="0.9972106">
The next turn can be rooted in either the
Inform(usr) after the inform(usr) or in the Dia-
logue(sys) after Inform(usr).
With all the above knowledge sources in place,
the calculation of the next dialogue turn can start:
</bodyText>
<listItem confidence="0.800731125">
1. The last speech act in the dialogue history
gives us a starting point in the grammar, thus
moving forward from inform(usr), the next atomic
speech act is request(sys)—either as a flat struc-
ture (i.e., request(sys) off Dialogue(sys)) or in a
sub-dialogue (i.e., Dialogue(sys)+request(sys) off
I nform ( usr))
2. Knowing that the system can request some-
</listItem>
<bodyText confidence="0.9835031">
thing, the dialogue engine consults with the AD
for what the system can ask about. The flat
strucutre (request(sys)) represents negotiation of
the task but since we assume that negotiation of
the task is complete (i.e., Status(theatreInfo) = ac-
tive), this speech act is not interpreted into a prim-
&apos;The star (*) means that a dialogue may contain
several request(sys) + Inform(usr) sequences. Lower-
case speech acts are atomic, while others axe complex.
The dialogue in square brackets (0) is optional.
</bodyText>
<page confidence="0.993566">
134
</page>
<bodyText confidence="0.999414428571429">
itive. Next we consider the sub-dialogue struc-
ture. Both children of theatrelnfo are open (i.e.,
they have not been negotiatied yet) thus the sys-
tem randomly chooses to pursue city whose state
is changed to topic. The speech act and the pa-
rameter are combined into the primitive request-
Value(city)—request a value for the parameter city
(e.g., &amp;quot;In which city is the theatre?&amp;quot;). We chose
to use the sub-dialogue structure instead of the
flat strucutre to represent negotiation of parame-
ter values since they are subordinate to the task
in the sense that the task dictates which parame-
ter values are needed. This is also the case for the
real gammas. (Appendix A).
</bodyText>
<listItem confidence="0.758317">
3. The primitive requestValue(city) is added to
the dialogue history:
</listItem>
<equation confidence="0.995569">
Dialogue(sys)
request(sys) Inform ( usr)
req uestVa I ue(task)
intorm(usr) Dialogue(sys)
informValue(task=theatreInfo)
req uest(sys)
requestValue(city)
</equation>
<bodyText confidence="0.910045416666667">
4. Starting from request(sys), the grammar
states that inform(usr) (i.e., Inform(usr) + in-
form(usr)) is the next speech act in the dialogue.
requestValue(city) was the last primitive spoken.
Reasoning that a user-inform in response to a sys-
tem requestValue should involve the same parame-
ter as the system&apos;s requestValue, the information is
combined to form the primitive informValue(city),
i.e., the user should respond to the system request
with a value for the parameter city. Let&apos;s assume
that the user replied &amp;quot;Hong Kong&amp;quot;, thus the dia-
logue history is expanded:
</bodyText>
<equation confidence="0.492028111111111">
Dialogue(sys)
request(sys) I nform ( us r)
req uestVa I ue (task).-
intorm(usr) Dialogue(sys)
nform Va I u e (ta sk=t h eat re I nfo)
req u est (sys) I nform (usr)
requestValue(city)
inform (usr)
informValue(city=Hong Kong)
</equation>
<listItem confidence="0.945436545454545">
5. Starting from inform(usr), the grammar re-
turns request(sys) and Dia logue(sys)+request(sys).
Since a recogniton result is available from the pre-
vious turn, the engine checks its recogntion con-
fidence. If it is high, it would consider the nego-
tiation of city finished, change its state to closed,
and discard Dialogue(sys)+request(sys) since there
is nothing to be requested about a closed param-
eter. It would translate request(sys) into request-
Value(theatre) since theatre is the only remaining
open parameter.
</listItem>
<bodyText confidence="0.999733692307692">
If confidence is low, the dialogue engine
may decide to ask the user to confirm
the recognized value. In which case, Dia-
logue(sys)+request(sys) would be interpreted into
requestConfirm(city=Hong Kong). Whether re-
quest(sys) would be interpreted or not depends
on the dialogue strategies chosen by the service
designer (see Sections 3 and 4).
If confidence is extremely low, the dialogue en-
gine may decide to repeat the question. In which
case, request(sys) would be interpreted into re-
questValue(city, 2), while the sub-dialogue struc-
ture would be discarded.
</bodyText>
<listItem confidence="0.994941">
6. Any interpretation of the flat strucutre would
result in the following addition to the last Dia-
logue(sys) in the dialogue history.
</listItem>
<equation confidence="0.9505294">
Dialogue(sys)
request(sys) I nform (usr) request(sys)
requestValue(city)
inform(usr)
nform Va I u e (city= Hong Kong)
</equation>
<bodyText confidence="0.9999672">
Our example shows how a speech act can result
in several primitives depending on the context and
thus how the dialogue manager dynamically reacts
to external events. Although this brief description
may not show it, our dialogue manager can handle
mixed initiative dialogue (Hagen, 1999). In (Ha-
gen, 1999), we also present our theory of taking,
keeping, and relinquishing the initiative.
Heisterkasnp and McGlashan (1996) presented
an approach that uses a similar division of func-
tionality as we do: task (=application), contex-
tual (=synsem + pragmatic), and pragmatic in-
terpretation (=dialogue engine). They also use
abstract parameterized units similar to ours, but
they do not use a speech act grammar to cal-
culate the units. Rather, they map contex-
tual functions onto dialogue goals, e.g., the func-
tion new_for_system(goalcity:munich) introduces
the dialogue goal confirm(goalcity:munich). In
terms of our primitievs this could be expressed as
requestConfirm() follows informValue(). We choose
not to start our modelling at this level since we
want to be able to vary what follows informValue(),
e.g., requestConfirm(), requestValueABCO, or eval-
uate°.
</bodyText>
<sectionHeader confidence="0.947209" genericHeader="method">
3 Primitives in Use
</sectionHeader>
<bodyText confidence="0.99984925">
Conceptually, GEN-primitives are calculated first
and then a bag of possible responses (REC-
primitives). One dialogue primitive corresponds
to one information unit or communicative goal,
</bodyText>
<page confidence="0.986448">
135
</page>
<table confidence="0.977772461538461">
GEN-Primitive REC-Primitives
informValue(film)
rejectRequest(film)
withdrawAccept(aTask=hangup)
withdrawAccept(aTask=cancel)
informPositive(theatre=Ridge)
informNegative(theatre=Ridge)
rejectRequest(theatre=Ridge)
withdrawAccept(aTask=hangup)
withdrawAccept(aTask=cancel)
requestValue(film)
requestConfirm
(theatre=Ridge)
</table>
<tableCaption confidence="0.932857">
Table 1: REC-primitives calculated in response
to two GEN-primitives in Dialogue 1.
</tableCaption>
<bodyText confidence="0.993790888888889">
e.g., in an information retrieval setting: provid-
ing or requesting one piece of information. Prim-
itives can be used individually or combined to ac-
count for more complex dialogue. Whether and
how they are combined depends on the dialogue
strategies specified by the service designer. In this
and the following section, we will examine several
such strategies and show how the primitives are
combined to achieve them.
</bodyText>
<subsectionHeader confidence="0.939821">
3.1 Question-Answer Dialogue
</subsectionHeader>
<bodyText confidence="0.860143">
In the simplest case, the service designer wants a
strickt question-answer dialogue:4
</bodyText>
<table confidence="0.89339">
Dialogue 1: Question-Answer
Sys: &amp;quot;Which film do you want to see?&amp;quot;
requestValue(film)
Usr: &amp;quot;The Matrix. At the Ridge.&amp;quot;
Int: informValue(film=Matrix)
Sys: &amp;quot;Which theatre?&amp;quot;
req uestVa I ue(theatre)
Usr: &amp;quot;Ridge. RIDG E.&amp;quot;
Int: i nfor mVa I ue(theatre=Ridge)
Sys: &amp;quot;Did you say The Ridge?&amp;quot;
requestConfi rm (theatre= Ridge)
Usr: &amp;quot;Yes. RID G E.&amp;quot;
Int: informPositive(theatre=Ridge)
</table>
<bodyText confidence="0.999927466666667">
For this type of dialogue, only the FtEC-
primitives representing direct answers, rejects,
and withdraws are calculated. In Table 1, we
present those calculated in response to the
first and the third system turn. We see that,
after requestValue(film), only informValue(film)
is calculated and the pragmatic interpreter has
no chance to detect &amp;quot;At the Ridge&amp;quot; (even if
synsem parsed it correctly) since there is no in-
formExtraValue(theatre) available to map it onto.
Similarly, after requestConfi rm (theatre= Ridge)
only inform Positive(t heat re= Ridge) and in-
form N egative(t heave= Ridge) are available and
&amp;quot;R. I D G E&amp;quot; cannot be detected since there is no
informValueABC(city) primitive present.
</bodyText>
<tableCaption confidence="0.4271465">
4In the sample dialogues, &apos;Sys&apos; means system turn,
&apos;Use means user turn, and &apos;Int&apos; means primitives rec-
ognized and sent back to the dialogue engine from the
pragmatic interpreter.
</tableCaption>
<figure confidence="0.988180285714286">
GEN-Primitive REC-Primitives
informValue(film)
rejectRequest(film)
informExtraValueValue(time)
informExtraValue(theatre)
informExtraValue(city)
informExtraValue(noOfTickets)
informExtraValue(date)
withdrawAccept(aTask=v)&amp;quot;
informPositive(theatre=Ridge)
informNegative(theatre=Ridge)
rejectRequest(theatre=Ridge)
informExtraValue(time)
informExtraValue(city)
informExtraValue(noOfTickets)
informExtraValue(date)
withdrawAccept(aTask=v)a
requestValue(film)
request onfirm
(theatre=Ridge)
E {cancel, hangup}
</figure>
<tableCaption confidence="0.8541855">
Table 2: REC-primitives calculated in response
to two GEN-primitives in Dialogue 2.
</tableCaption>
<subsectionHeader confidence="0.998864">
3.2 Over-Answering
</subsectionHeader>
<bodyText confidence="0.9985328">
In our experience, users frequently provide more
information than explicitly asked for, thus a more
flexible dialogue strategy would be to allow over-
answering and Dialogue 1 could have developed as
follows:
</bodyText>
<equation confidence="0.409269363636364">
Dialogue 2: Over-Answering
Sys: &amp;quot;Which film do you want to see?&amp;quot;
requestValue(film)
Usr: &amp;quot;Matrix. At the Ridge. RIDG E.&amp;quot;
Int: informValue(film=Matrix)
+ inform ExtraVa I ue(theatre=The Ridge)
Sys: &amp;quot;Did you say The Ridge?&amp;quot;
req uestConfi rm (theatre= Ridge)
Usr: &amp;quot;Yes, and I want the late show.&amp;quot;
Int: informPositive(theatre=Ridge)
+ informExtraValue(time=9PM)
</equation>
<bodyText confidence="0.9995274">
In Table 2, we present the REC-primitives cal-
culated in response to the same system turns as
in Dialogue 1. In Dialogue 2, only over-answering
of requestValue() primitives were allowed, thus
&amp;quot;R I D G E&amp;quot; could still not be accounted for.
</bodyText>
<subsectionHeader confidence="0.998704">
3.3 Complex Mixed Initiative
</subsectionHeader>
<bodyText confidence="0.999724">
Here we consider the most complex dialogue strat-
egy that we can currently offer: The system is able
to account for complex mixed initiative dialogue
(at least from a dialogue point of view), i.e., the
user can requst clarifications, over-answer, change
values, repeat values, correct values, spell values,
and reject requests as she pleases.
</bodyText>
<table confidence="0.753231714285714">
Dialogue 3: Complex Mixed Initiative
Sys: &amp;quot;Which film do you want to see?&amp;quot;
req uestVa I ue(fi I m)
Usr: &amp;quot;Sorry, did you ask for the time?&amp;quot;
Int: requestParam(time)
Sys: &amp;quot;No. Which film do you want to see?&amp;quot;
i nform N egative(ti me) + req uestVa I ue(fi I m , 2)
</table>
<page confidence="0.887572">
136
</page>
<table confidence="0.937999214285714">
Dialogue 3 cont&apos;d.
Usr: &amp;quot;Matrix. At the Ridge.&amp;quot;
Int: informValue(film=Matrix)
+ informExtraValue(theatre=The Ridge)
Sys: &amp;quot;Did you say The Ridge?&amp;quot;
requestConfirm(theatre=Ridge, 1)
Usr: &amp;quot;Sorry, I didn&apos;t hear that.&amp;quot;
Int: rejectRequest(theatre=didNotHear)
Sys: &amp;quot;Did you say The Ridge?&amp;quot;
requestConfirm(theatre=Ridge, 2)
Usr: &amp;quot;Yes, The Ridge. RIDG E.&amp;quot;
Int: informPositive(theatre=Ridge)
+ repeatValue(theatre=Ridge)
+ informValueABC(theatre=Ridge)
Sys: &amp;quot;Ok. What time?&amp;quot;
evaluate(theatre=Ridge)
+ requestValue(time)
Usr: &amp;quot;I don&apos;t know. What are the alternatives?&amp;quot;
Int: requestAlternatives(time)
Sys: &amp;quot;18:30 or 21:00.&amp;quot;
informAlternative(time=18:30)
+ informAlternative(time=21:00)
Usr: &amp;quot;Ok, two tickets for the late show tomorrow.&amp;quot;
Int: evaluate(time=neutral)
+ informExtraValue(noOfTickets=2)
+ informValue(time=21:00)
+ informExtraValue(date=July 4)
Sys: &amp;quot;Did you say two tickets?&amp;quot;
</table>
<equation confidence="0.58071825">
requestConfirm(noOfTickets=2)
Usr: &amp;quot;Yes, but I change to the early show.&amp;quot;
Int: informPositive(noOfTickets=2)
+ changeValue(time=18:30)
</equation>
<bodyText confidence="0.947559">
In Table 3, we present the REC-primitives cal-
culated in response to two system utterances.
</bodyText>
<subsectionHeader confidence="0.871925">
3.4 Multi-Functional Turns
</subsectionHeader>
<bodyText confidence="0.964392857142857">
It has been argued that speech act grammars can-
not be used to describe dialogue since utterances
can be multi-functional or encode more than one
speech act; Speech act grammars can typically be
in only one state at a time, thus they cannot cap-
ture this phenomenon (Levinson, 1981). In an
information retrieval setting such situations oc-
cur, for example, when users disregard the system
utterance and provide unrelated information or
when a recogniton mistake occured and the sytem
asks for confirmation. Instead of answering yes or
no, users frequently answer with the correct value,
which implicitly disconfirms the previous value:
Dialogue 4: Multi-Functional Utterances
</bodyText>
<table confidence="0.9558087">
Sys: &amp;quot;How many tickets?&amp;quot;
requestValue(noOfTickets)
Usr: &amp;quot;I want tickets for July 4.&amp;quot;
Int: rejectRequest(noOfTickets)
+ informExtraValue(date=July 3)
Sys: &amp;quot;Did you say July 3?&amp;quot;
requestConfirm(date=July 3)
Usr: &amp;quot;Tomorrow!&amp;quot;
Int: informNegative(date=July 3)
+ correctValue(date=July 4)
</table>
<bodyText confidence="0.853905222222222">
In the first utterance, the user both ignores the
system utterance and provides some information.
In the second one, she negated and correctd the
system suggestion with a single word.
GEN-Primitive REC- rimitives
requestValue film InformValue film
informValueABC(film)
requestAlternatives(film)
promise(film)
rejectRequest(film=v)&apos;
informGarbage(film)
requestParam(p)b
informExtraValue(p)b
informValueABC(p)b
repeatValue(p)`
changeValue(p)`
withdrawAccept(aTask=v)d
requestConfirm inform Positive theatre= Ridge
</bodyText>
<equation confidence="0.724721533333333">
(theatre=Ridge) repeatValue(theatre=Ridge)
informNegative(theatre=Ridge)
correctValue(theatre)
informValueABC(theatre)
rejectRequest(theatre=v)a
informGarbage(theatre)
informExtraValue(p)b
informValueABC(p)b
repeatValue(p)c
changeValue(p)c
withdrawAccept(aTask=v)d
&amp;quot;Vv E {null, didNotHear}
VpE openParams(AD)
`VpE dosedParams(AD)
dVv E {cancel, hangup}
</equation>
<tableCaption confidence="0.7646205">
Table 3: REC-primitives calculated in response
to two GEN-primitives in Dialogue 3.
</tableCaption>
<bodyText confidence="0.998856">
Since we are not using the speech act grammar
directly and instead interpret the speech acts into
a bag of primitives, we can assign as many prim-
itives to an utterance as necessary and are not
bound by the states dictated by a grammar. This
aspect of our approach becomes even more inter-
esting when the system combines several primi-
tives in its utterance (Section 4).
</bodyText>
<sectionHeader confidence="0.98466" genericHeader="method">
4 Dialogue Strategies
</sectionHeader>
<bodyText confidence="0.999957533333333">
Although, the procedure outlined in Section 2.4,
only shows how to calculate one primitive per sys-
tem turn, the approach is, of course, not limited
to this. The service designer can decide to em-
ploy mixed initiative dialogue strategies for the
system utterances as well, for example, requesting
or confirming several values at once or implicitly
confirming values. The dialogue strategies for sys-
tem utterances include choosing nodes in the ap-
plication description, dealing with speech recogni-
tion results, or dealing with ambiguous data from
other knowledge sources. Here we present a few
examples of how the dialogue manager would com-
bine hypotheses (for more information see (Hagen,
2001)).
</bodyText>
<page confidence="0.993827">
137
</page>
<subsectionHeader confidence="0.999158">
4.1 Confirmation Strategies
</subsectionHeader>
<bodyText confidence="0.99101625">
We illustrate implicit and multiple confirmation,
i.e., the system realizes requestValue and request-
Confirm or multiple requestConfirm primitives in
one utterance:
</bodyText>
<table confidence="0.996272590909091">
Dialogue 5: Confirmation Strategies
Sys: &amp;quot;Which showing of The Matrix do you want?&amp;quot;
requestValue(time)
+ requestConfi rm (fi I m= M atr ix)
Usr: &amp;quot;(No.) Buena Vista!&amp;quot;
Int: informNegative(film=The Matrix)
+ correctValue(film=Buena Vista)
+ rejectRequest(time)
Sys: &amp;quot;Which showing of Buena Vista do you want?&amp;quot;
requestConfirm(film=Buena Vista)
+ requestValue(time)
Usr: &amp;quot;The late show. Tomorrow.&amp;quot;
Int: informPositive(film=Buena Vista)
+ i nformVa I ue(time=21:00)
+ informExtraValue(date=8 October)
Sys: &amp;quot;Did you say 21:00 today?&amp;quot;
requestConfirm (ti me=21:00)
requestConfirm(date=October 7)
Usr: &amp;quot;No. Tomorrow.&amp;quot;
Int: i nform Positive (ti m e=21:00)
+ informNegative(date= October 7)
+ correctValue(date=October 8)
</table>
<bodyText confidence="0.99994304">
For the first two utterances, the system has a
recognition result for the parameter film with a
low recognition score. Consequently, it calculates
requestConfirm(film=.Matrix/Buena Vista). Addi-
tionally, there are still open parameter nodes in
the AD, thus the dialogue engine picks one (ei-
ther at random or if the service designer has
ordered them, the next one) and calculates a
requestValue primitive, here requestValue(time).
If the service designer allows implicit confirma-
tion, the two primitives are combined and ut-
tered together in one turn. If the service de-
signer does not allow implicit confirmation, the
dialogue engine continues the dialogue with the
topic that has alread been introduced, i.e., re-
questConfirm(film=Matrix/Buena Vista).5
For its last utterance, the system has two recog-
nition results with a low recognition score, thus
for each one of them it calculates a requestConfirm
primitive. If the service designer, allows multiple
confirmations, they are combined and realized as
one utterance. If not, the dialogue engine chooses
requestConfirm(time=21:00), since this topic was
introduces first. If topics are introduced in the
same utterance, it pickes one at random.
</bodyText>
<subsectionHeader confidence="0.999317">
4.2 AD Based Strategies
</subsectionHeader>
<bodyText confidence="0.999548914285714">
When requesting parameter values from the user,
the system consults the application description for
&apos;This is a conceptual account. In the implemen-
tation, the requestValue primitive would not be cal-
cualted at all, if the service designer does not allow
implicit confirmation.
open nodes. If there are several open nodes, the
dialogue manager can decide to keep the initiative
and produce several primitives, which can be com-
bined into one turn. If the nodes are joined with
an or-relation, the text generator would trans-
late the primitives into an utterance offering al-
ternative ways of entering the same information.
For example, &amp;quot;Please tell me the show time or
early or late show.&amp;quot; (requestValue(time) + re-
questValue(namedTime)). If the nodes are joined
with an and- or a has-a relation, the text gen-
erator would translate the primitives into an ut-
terances requesting several different pieces of in-
formation. For example, &amp;quot;What is the name of
the city and the theatre?&amp;quot; (requestValue(city) +
req uestVa I ue(theatre)).
As seen in the application descriptions there
may be several ways of acquiring a particular value
e.g., date and time in Figure 2. If a parameter
value is recognized with a low score, the service
designer can decide whether the system shall con-
tinue processing the original parameter or whether
it shall switch to one of the alternative ones. Thus
after a bad recognition of date, the system can
switch strategy and request weekDay and week in-
stead.
Which strategies to follow is decided by the ser-
vice designer through a set of switches in the dia-
logue strategies specification file (Figure 1).
</bodyText>
<sectionHeader confidence="0.991734" genericHeader="method">
5 Pragmatic Interpreter
</sectionHeader>
<bodyText confidence="0.999967375">
After synsem interpretation, the user utterance
must be mapped onto dialogue primitives. A bag
of REC-primitives is calculated for each user ut-
terance and the pragmatic interpreter must assure
that the utterance is mapped onto primitives in
this bag. There is always a mapping. The reject
and withdraw primitives are always part of the bag
thus in the worst case, the user utterance would
be mapped onto one of these.
Since primitives in their =instantiated form are
application independent, we can develop generic
rules for this mapping. In other words, the rules
define how the dialogue strategies presented in
Section 3 are mapped onto primitives and how we
account for several primitives per utterance.
A rule has the form: GEN-Primitives A user ut-
terance REC-primitives. In Table 4, we present
two rules for implicit confirmation. The first one
corresponds to the first sys/usr pair in Dialogue 5.
The user responds with a new value vs (Buena
Vista) for pa (film) in requestConfirm(p2=v2)
and thereby disconfirms vs (Matrix) and re-
jects the request for a value for p1 (time) in
requestValue(pi). The second rule corresponds to
</bodyText>
<page confidence="0.998886">
138
</page>
<tableCaption confidence="0.953895">
Table 4: Mapping of user input onto REC-
primitives. p=v means that the user provided
value v for param p.
</tableCaption>
<bodyText confidence="0.99994912">
the second sys/usr pair in Dialogue 5. The user
provides value vi (the late show) for pi (time)
in requestValue(pi) and thus confirms v2 (Buena
Vista) in requestConfirm ( p2=v2). For instanti-
ation of the primitives, see Dialogue 5. Here,
we only presented two examples. Similar rules
were developed for all our primitives and dialogue
strategies (see (Hagen, 2001)).
One reviewer asked whether we can modify the
approach such that expectations can be overrid-
den if there is sufficently good information from
the synsem module. The short answer is that we
could (re-)calculate the primitives pretending that
the service designer allowed mixed initiative re-
gardless of the dialogue strategies actually chosen.
We, however, think it is important to give her the
right to decide. For example, if she has decided
that over-answering is allowed, informExtraValue()
primitives for all parameters whose status is still
open would be calculated and thus there is noth-
ing to override. If, however, the service designer
has decided that over-answering is not allowed, we
assume that she had good reasons for doing that
and the dialogue manager will not try to overrule
this decision.
</bodyText>
<sectionHeader confidence="0.999384" genericHeader="conclusions">
6 Conclusion
</sectionHeader>
<bodyText confidence="0.99996622">
We have presented some results from our research
on spoken dialogue management. We concen-
trated on how to dynamically calculate a collec-
tion of predictions for how to continue a dialogue
(dialogue primitives), how to account for differ-
ent dialogue strategies and utterances with sev-
eral communicative goals through combinations of
primitives, and how to map the user utterances
onto primitives. The approach has been imple-
mented and tested in several prototype systems,
e.g., horoscope, movie, and telephone rate service
(Feldes et al., 1998).
Dialogue grammars have previously been used
to manage dialogue (Bunt, 1989; Bilange, 1991;
Raum and Hinkehnan, 1992; Jonsson, 1993; Mast
et al., 1994; Novick and Sutton, 1994; Chino and
Tsuboi, 1996), but we are not aware of an ap-
proach where speech acts are translated into a
collection of primitives with propositional content.
Previous grammar approaches use the speech acts
directly or assume a one-to-one correspondence
between utterance and speech act.
Through the natural division of the knowledge
into type and content, we have achieved a flex-
ible dialogue manager that adapts to users&apos; be-
haviour. We can take advantage of the predictive
capabilites of speech act grammars and still be
able to account for multi-functional utterances.
We have also demonstrated that our approach
is flexible: 1. the dialogue engine, the pragmatic
interpreter, the primitives and the algorithm for
mapping user utterances onto predictions are ap-
plication and language independent, which makes
it easy to reuse our dialogue manager in new ap-
plications. and 2. the dialogue manager can easily
account for several types of dialogue, e.g., strict
question-answer or mixed initiative. We give the
service designer the freedom to decide which kind
of dialogue she wants—on a high level—and the
dialogue manager combines the basic primitives
accordingly.
Future work includes empirical testing to ver-
ify whether we are calculating appropriate predic-
tions. Also, several aspects of our dialogue gram-
mar have not yet been translated into primitives,
for example, the frequent use of assert in natu-
ral dialogue. As a wider dialogue coverage is re-
quired, we will add primitives accordingly. We are
also working on using the primities as input to a
multi-lingual automatic text generation system.
</bodyText>
<sectionHeader confidence="0.997364" genericHeader="acknowledgments">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.999722">
The author thanks the three anonymous reviewers
for their helpful comments on the first draft of
this paper. Financial support from the Norwegian
Research Council, project number 116578/410 is
greatly appreciated.
</bodyText>
<sectionHeader confidence="0.99681" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.9145594">
J.A. Bateman, B. Magnini, and F. Rinaldi. 1994.
The generalized {Italian, German, English} up-
per model. In Proc. of the ECAI94 Workshop:
Comparison of Implemented Ontologies, Ams-
terdam, The Netherlands.
</reference>
<figure confidence="0.999685257142857">
GEN-Primitives
requestValue(pi)
V1 &lt;j &lt; maxi
req u est Co nf. (pi =vi )
V1 &lt; j &lt; maxi
requestValue(pi)
V1 &lt; i &lt; maxi
requestConf.(pi=vi)
V1 &lt; j &lt; maxi
REC-Primitives
informNeg.(pi=vi
Vj 1 &lt; j &lt; k
correctVal.(pi=vi)
Vj 1 &lt; i &lt; k
informPos.(pi=v5)
Vj k &lt; j &lt; maxi
rejectRequest(pi)
V1 &lt; i &lt; maxi
informVal.(pi=vi
Vi 1 &lt; j &lt; k
informPos,(pi=vi)
V1 &lt; j &lt; maxi
rejectRequest(pi)
Vi k &lt; i&lt; maxi
(no)
pi =vi,
vi vi,
Vj
1 &lt; j&lt;
k &lt; maxi
pi=vi,
Vi
1 &lt; i &lt;
k &lt; maxi
Input
</figure>
<page confidence="0.977649">
139
</page>
<reference confidence="0.999885388888889">
J.A. Bateman, B. Magnini, and G. Fabris.
1995. The generalized upper model knowledge
base: Organization and use. In Proc. of the
Conf. on Knowledge Representation and Shar-
ing, Twente, The Netherlands.
E. Bilange. 1991. A task independent oral dia-
logue model. In Proc. of the Euro. Conf. of the
ACL, pages 83-87.
H.C. Bunt. 1989. Information dialogues as com-
municative action in relation to partner model-
ing and information processing. In M.M. Tay-
lor, F. Neel, and D.G. Bouwhuis, editors, The
Structure of Multimodal Dialogue, pages 47-73.
North-Holland, Amsterdam.
J. Caminero-Gil, J. Alvarez-Cercadillo, C. Crespo-
Casas, and D. Tapias-Merino. 1996. Data-
driven discourse modeling for semantic in-
terpretation. In Proc. of 1996 Intl. Conf.
on Acoustics, Speech, and Signal Processing
(ICASSP&apos;96), pages 401-404.
T. Chino and H. Tsuboi. 1996. A new discourse
model for spontaneous spoken dialogue. In
1021-1024, editor, Proc. of the 1996 Intl. Conf.
on Spoken Language Processing (ICSLP&apos;96).
S. Feldes, G. Fries, E. Hagen, and A. Wirth. 1998.
A novel service creation environment for speech
enabled database access. In Proc. 4th IEEE
Workshop on Interactive Voice Technology for
Telecommunications Applications (IVTTA&apos;98),
29-30 Sept. 1998, Torino, Italy.
E. Hagen. 1999. An approach to mixed ini-
tiative spoken information retrieval dialogue.
User Modeling and User-Adapted Interaction,
9(1/2):167-213.
E. Hagen. 2001. Mixed Initiative Spoken Dialogue
Management in Information Systems. Ph.D.
thesis, School of Computing Science, Simon
Fraser University, Burnaby, BC, Canada. Jan.
2001 expected.
P. Heisterkamp and S. McGlashan. 1996. Units
of dialogue management. In Proc. of the 1996
Intl. Conf. on Spoken Language Processing (IC-
SLP&apos;96).
A. Hasson. 1993. A dialogue manager using
initiative-response units and distributed con-
trol. In Proc. of 6th Euro. Conf. of the ACL,
pages 233-238.
S.C. Levinson. 1981. Some pre-observations on
the modelling of dialogue. Discourse Processes,
4:93-116.
M. Mast, F. Kummert, U. Ehrlich, G.A. Fink,
T. Kuhn, H. Niemann, and G. Sagerer. 1994.
Prosody takes over: Towards a prosodically
guided dialog system. Speech Communication,
15(1-2):155-167.
D.G. Novick and S. Sutton. 1994. An empirical
model of acknowledgement for spoken-language
systems. In Proc. of the 32nd Annual Meeting
of the ACL, pages 96-101.
S. Sitter and A. Stein. 1992. Modelling the il-
locutionary aspects of information-seeking di-
alogues. Information Processing and Manage-
ment, 8(2):165-180.
D. Traum and E. Hinkelman. 1992. Conversation
acts in task-oriented spoken dialogue. Compu-
tational Intelligence, 8(3):575-599.
S. Young, A. Hauptmann, W. Ward, E. Smith,
and P. Werner. 1990. High-level knowledge
sources in usable speech recognition systems.
In A. Waibel and K. Lee, editors, Readings
in Speech Recognition, pages 538-549. Morgan
Kaufman, San Mateo, CA.
</reference>
<subsectionHeader confidence="0.350467">
A. The Complete Dialogue Grammar
</subsectionHeader>
<bodyText confidence="0.990343545454545">
The complete grammar is a slightly modified
version of the grammar presented in (Sitter and
Stein, 1992). Notation: Complex dialogue
moves begin with an upper case (e.g., Request);
atomic dialogue acts are all lower case (e.g., re-
quest). S and K mean seeker and knower. Square
brackets ([]) mean optional. X+ means one or
more instances of X. All moves except Inform and
Assert are representated by the abstraction Move.
Subscript, means that move and act must be of
the same type, e.g., Request and request.
</bodyText>
<reference confidence="0.991335272727273">
Dialogue(S)-+(Cycle(S))+
Cycle(S) Request(S), Promise(K), Inform(K),
Evaluate(S).
Cycle(S) Request(S), [Promise(K)],
WithdrawRequest(S).
Cycle(S) Request(S), Promise(K),
WithdrawPromise(K).
Cycle(S) -4 Request(S), RejectRequest(K).
Cycle(S) -4 Offer(K), Accept(S), Inform (K), Eva luate(S).
Cycle(S) -&gt; Offer(K), [Accept(S)I, WithdrawOfFer(K).
Cycle(S) -4 OfFer(K), Accept(S), WithdrawAccept(S).
Cycle(S) -4 Offer(K), RejectOfFer(S).
Cycle(S)-4 Withdraw(usr).
Cycle(S) Withdraw(system).
Inform(K) inform(K), [Dia logue(S)].
Assert(S/K) assert(S/K), [Dialogue(K/S)].
Movei(S/K).
Movei(S/K).4 acti(S/K), [Dialogue(K/S)].
Movei(S/K) act; (S/K), [Assert(S/K)].
Movei(S/K) Dialogue(K/S).
Movei(S/K) -&gt; Assert(S/K), (acti(S/K)].
Movei(S/K) Assert(S/K), [Dialogue(K/S)].
</reference>
<page confidence="0.997524">
140
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.468955">
<title confidence="0.9995">Flexible Speech Act Based Dialogue Management</title>
<author confidence="0.975487">Hagen</author>
<affiliation confidence="0.962564">School of Computing</affiliation>
<address confidence="0.682639">Simon Fraser Canada V5A</address>
<email confidence="0.993833">fhagen,popowichl@cs.sfu.ca</email>
<abstract confidence="0.9914722">We present an application independent dialogue engine that reasons on application dependent knowledge sources to calculate predictions about how a dialogue might continue. Predictions are language independent and are translated into language dependent structures for recognition and synthesis. Further, we discuss how the predicaccount for different kinds of dialogue, question-answer or mixed initiative.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>J A Bateman</author>
<author>B Magnini</author>
<author>F Rinaldi</author>
</authors>
<title>The generalized {Italian, German, English} upper model.</title>
<date>1994</date>
<booktitle>In Proc. of the ECAI94 Workshop: Comparison of Implemented Ontologies,</booktitle>
<location>Amsterdam, The Netherlands.</location>
<contexts>
<context position="6349" citStr="Bateman et al., 1994" startWordPosition="981" endWordPosition="984">the domain is sufficent for the information retrieval domains, which we are currently considering. We expect, however, that in future work we &apos;Extensions include has-a relations. Figure 2: A description of a movie service. Notation: U and V represent and/or-relations. Subscripts t and,, denote tasks and parameters. will need to switch to a semantic network structure or since our future research includes automatic generation of system utterances from our dialogue primitives, we hope to be able to utilize the ontology and domain organization work, which has proven so useful for text generation (Bateman et al., 1994; Bateman et al., 1995), for both dialogue management and text generation. 2.3 Dialogue Primitives Following the procedure outlined in Section 2.4, the dialogue manager calculates a bag of primitives for each turn and speaker. Our current collection is motivated through our experience with several domains, e.g., movie service, horoscope service, and directory assistance. The collection is not exhaustive and we will add primitives as wider dialogue coverage is required. Notation: A primitive is written primName(p=v,n), where primName is its name; p E params(AD) u {aTask}; aTask is a special par</context>
</contexts>
<marker>Bateman, Magnini, Rinaldi, 1994</marker>
<rawString>J.A. Bateman, B. Magnini, and F. Rinaldi. 1994. The generalized {Italian, German, English} upper model. In Proc. of the ECAI94 Workshop: Comparison of Implemented Ontologies, Amsterdam, The Netherlands.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J A Bateman</author>
<author>B Magnini</author>
<author>G Fabris</author>
</authors>
<title>The generalized upper model knowledge base: Organization and use.</title>
<date>1995</date>
<booktitle>In Proc. of the Conf. on Knowledge Representation and Sharing,</booktitle>
<location>Twente, The Netherlands.</location>
<contexts>
<context position="6372" citStr="Bateman et al., 1995" startWordPosition="985" endWordPosition="988">t for the information retrieval domains, which we are currently considering. We expect, however, that in future work we &apos;Extensions include has-a relations. Figure 2: A description of a movie service. Notation: U and V represent and/or-relations. Subscripts t and,, denote tasks and parameters. will need to switch to a semantic network structure or since our future research includes automatic generation of system utterances from our dialogue primitives, we hope to be able to utilize the ontology and domain organization work, which has proven so useful for text generation (Bateman et al., 1994; Bateman et al., 1995), for both dialogue management and text generation. 2.3 Dialogue Primitives Following the procedure outlined in Section 2.4, the dialogue manager calculates a bag of primitives for each turn and speaker. Our current collection is motivated through our experience with several domains, e.g., movie service, horoscope service, and directory assistance. The collection is not exhaustive and we will add primitives as wider dialogue coverage is required. Notation: A primitive is written primName(p=v,n), where primName is its name; p E params(AD) u {aTask}; aTask is a special parameter whose values E t</context>
</contexts>
<marker>Bateman, Magnini, Fabris, 1995</marker>
<rawString>J.A. Bateman, B. Magnini, and G. Fabris. 1995. The generalized upper model knowledge base: Organization and use. In Proc. of the Conf. on Knowledge Representation and Sharing, Twente, The Netherlands.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Bilange</author>
</authors>
<title>A task independent oral dialogue model.</title>
<date>1991</date>
<booktitle>In Proc. of the Euro. Conf. of the ACL,</booktitle>
<pages>83--87</pages>
<contexts>
<context position="35689" citStr="Bilange, 1991" startWordPosition="5385" endWordPosition="5386">me results from our research on spoken dialogue management. We concentrated on how to dynamically calculate a collection of predictions for how to continue a dialogue (dialogue primitives), how to account for different dialogue strategies and utterances with several communicative goals through combinations of primitives, and how to map the user utterances onto primitives. The approach has been implemented and tested in several prototype systems, e.g., horoscope, movie, and telephone rate service (Feldes et al., 1998). Dialogue grammars have previously been used to manage dialogue (Bunt, 1989; Bilange, 1991; Raum and Hinkehnan, 1992; Jonsson, 1993; Mast et al., 1994; Novick and Sutton, 1994; Chino and Tsuboi, 1996), but we are not aware of an approach where speech acts are translated into a collection of primitives with propositional content. Previous grammar approaches use the speech acts directly or assume a one-to-one correspondence between utterance and speech act. Through the natural division of the knowledge into type and content, we have achieved a flexible dialogue manager that adapts to users&apos; behaviour. We can take advantage of the predictive capabilites of speech act grammars and stil</context>
</contexts>
<marker>Bilange, 1991</marker>
<rawString>E. Bilange. 1991. A task independent oral dialogue model. In Proc. of the Euro. Conf. of the ACL, pages 83-87.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H C Bunt</author>
</authors>
<title>Information dialogues as communicative action in relation to partner modeling and information processing.</title>
<date>1989</date>
<booktitle>The Structure of Multimodal Dialogue,</booktitle>
<pages>47--73</pages>
<editor>In M.M. Taylor, F. Neel, and D.G. Bouwhuis, editors,</editor>
<publisher>North-Holland,</publisher>
<location>Amsterdam.</location>
<contexts>
<context position="35674" citStr="Bunt, 1989" startWordPosition="5383" endWordPosition="5384">presented some results from our research on spoken dialogue management. We concentrated on how to dynamically calculate a collection of predictions for how to continue a dialogue (dialogue primitives), how to account for different dialogue strategies and utterances with several communicative goals through combinations of primitives, and how to map the user utterances onto primitives. The approach has been implemented and tested in several prototype systems, e.g., horoscope, movie, and telephone rate service (Feldes et al., 1998). Dialogue grammars have previously been used to manage dialogue (Bunt, 1989; Bilange, 1991; Raum and Hinkehnan, 1992; Jonsson, 1993; Mast et al., 1994; Novick and Sutton, 1994; Chino and Tsuboi, 1996), but we are not aware of an approach where speech acts are translated into a collection of primitives with propositional content. Previous grammar approaches use the speech acts directly or assume a one-to-one correspondence between utterance and speech act. Through the natural division of the knowledge into type and content, we have achieved a flexible dialogue manager that adapts to users&apos; behaviour. We can take advantage of the predictive capabilites of speech act gr</context>
</contexts>
<marker>Bunt, 1989</marker>
<rawString>H.C. Bunt. 1989. Information dialogues as communicative action in relation to partner modeling and information processing. In M.M. Taylor, F. Neel, and D.G. Bouwhuis, editors, The Structure of Multimodal Dialogue, pages 47-73. North-Holland, Amsterdam.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Caminero-Gil</author>
<author>J Alvarez-Cercadillo</author>
<author>C CrespoCasas</author>
<author>D Tapias-Merino</author>
</authors>
<title>Datadriven discourse modeling for semantic interpretation.</title>
<date>1996</date>
<booktitle>In Proc. of 1996 Intl. Conf. on Acoustics, Speech, and Signal Processing (ICASSP&apos;96),</booktitle>
<pages>401--404</pages>
<marker>Caminero-Gil, Alvarez-Cercadillo, CrespoCasas, Tapias-Merino, 1996</marker>
<rawString>J. Caminero-Gil, J. Alvarez-Cercadillo, C. CrespoCasas, and D. Tapias-Merino. 1996. Datadriven discourse modeling for semantic interpretation. In Proc. of 1996 Intl. Conf. on Acoustics, Speech, and Signal Processing (ICASSP&apos;96), pages 401-404.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Chino</author>
<author>H Tsuboi</author>
</authors>
<title>A new discourse model for spontaneous spoken dialogue.</title>
<date>1996</date>
<booktitle>In 1021-1024, editor, Proc. of the 1996 Intl. Conf. on Spoken Language Processing (ICSLP&apos;96).</booktitle>
<contexts>
<context position="35799" citStr="Chino and Tsuboi, 1996" startWordPosition="5401" endWordPosition="5404">lculate a collection of predictions for how to continue a dialogue (dialogue primitives), how to account for different dialogue strategies and utterances with several communicative goals through combinations of primitives, and how to map the user utterances onto primitives. The approach has been implemented and tested in several prototype systems, e.g., horoscope, movie, and telephone rate service (Feldes et al., 1998). Dialogue grammars have previously been used to manage dialogue (Bunt, 1989; Bilange, 1991; Raum and Hinkehnan, 1992; Jonsson, 1993; Mast et al., 1994; Novick and Sutton, 1994; Chino and Tsuboi, 1996), but we are not aware of an approach where speech acts are translated into a collection of primitives with propositional content. Previous grammar approaches use the speech acts directly or assume a one-to-one correspondence between utterance and speech act. Through the natural division of the knowledge into type and content, we have achieved a flexible dialogue manager that adapts to users&apos; behaviour. We can take advantage of the predictive capabilites of speech act grammars and still be able to account for multi-functional utterances. We have also demonstrated that our approach is flexible:</context>
</contexts>
<marker>Chino, Tsuboi, 1996</marker>
<rawString>T. Chino and H. Tsuboi. 1996. A new discourse model for spontaneous spoken dialogue. In 1021-1024, editor, Proc. of the 1996 Intl. Conf. on Spoken Language Processing (ICSLP&apos;96).</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Feldes</author>
<author>G Fries</author>
<author>E Hagen</author>
<author>A Wirth</author>
</authors>
<title>A novel service creation environment for speech enabled database access.</title>
<date>1998</date>
<booktitle>In Proc. 4th IEEE Workshop on Interactive Voice Technology for Telecommunications Applications (IVTTA&apos;98),</booktitle>
<pages>29--30</pages>
<location>Torino, Italy.</location>
<contexts>
<context position="35598" citStr="Feldes et al., 1998" startWordPosition="5370" endWordPosition="5373">and the dialogue manager will not try to overrule this decision. 6 Conclusion We have presented some results from our research on spoken dialogue management. We concentrated on how to dynamically calculate a collection of predictions for how to continue a dialogue (dialogue primitives), how to account for different dialogue strategies and utterances with several communicative goals through combinations of primitives, and how to map the user utterances onto primitives. The approach has been implemented and tested in several prototype systems, e.g., horoscope, movie, and telephone rate service (Feldes et al., 1998). Dialogue grammars have previously been used to manage dialogue (Bunt, 1989; Bilange, 1991; Raum and Hinkehnan, 1992; Jonsson, 1993; Mast et al., 1994; Novick and Sutton, 1994; Chino and Tsuboi, 1996), but we are not aware of an approach where speech acts are translated into a collection of primitives with propositional content. Previous grammar approaches use the speech acts directly or assume a one-to-one correspondence between utterance and speech act. Through the natural division of the knowledge into type and content, we have achieved a flexible dialogue manager that adapts to users&apos; beh</context>
</contexts>
<marker>Feldes, Fries, Hagen, Wirth, 1998</marker>
<rawString>S. Feldes, G. Fries, E. Hagen, and A. Wirth. 1998. A novel service creation environment for speech enabled database access. In Proc. 4th IEEE Workshop on Interactive Voice Technology for Telecommunications Applications (IVTTA&apos;98), 29-30 Sept. 1998, Torino, Italy.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Hagen</author>
</authors>
<title>An approach to mixed initiative spoken information retrieval dialogue. User Modeling and User-Adapted Interaction,</title>
<date>1999</date>
<pages>9--1</pages>
<contexts>
<context position="13083" citStr="Hagen, 1999" startWordPosition="2039" endWordPosition="2040"> hangup}. With cancel, the user ends the current dialogue before an answer has been given and starts a new task without calling again.2 withdrawPromise(p=v): user withdraws a promise to provide a value for reason v E {cancel, hangup}.2 withdrawRequest(p=v): user withdraws a request. p E params(AD) U {forward, backward, repeat, and n}.2 null(): returned to the dialogue manager if the user does not say anything and is not expected to say anything, e.g., after a greeting or promise. In Section 3, we present several sample instantiations of the primitives. 2.4 Dialogue Engine The dialogue engine (Hagen, 1999) consists of a reasoning engine and several knowledge sources: An AD defines an application&apos;s data-needs, a dialogue grammar defines how a dialogue may proceed at the level of speech acts, and a dialogue history is a dynamically growing parse tree of an on-going dialogue with respect to the dialogue grammar. Other knowledge sources may be required, for instance, recognition confidence or disambiguation of city names. The dialogue engine calculates the next turn by consulting and combining information from the knowledge sources. It consults with the dialogue history and the dialogue grammar in </context>
<context position="19440" citStr="Hagen, 1999" startWordPosition="3053" endWordPosition="3054">questValue(city, 2), while the sub-dialogue structure would be discarded. 6. Any interpretation of the flat strucutre would result in the following addition to the last Dialogue(sys) in the dialogue history. Dialogue(sys) request(sys) I nform (usr) request(sys) requestValue(city) inform(usr) nform Va I u e (city= Hong Kong) Our example shows how a speech act can result in several primitives depending on the context and thus how the dialogue manager dynamically reacts to external events. Although this brief description may not show it, our dialogue manager can handle mixed initiative dialogue (Hagen, 1999). In (Hagen, 1999), we also present our theory of taking, keeping, and relinquishing the initiative. Heisterkasnp and McGlashan (1996) presented an approach that uses a similar division of functionality as we do: task (=application), contextual (=synsem + pragmatic), and pragmatic interpretation (=dialogue engine). They also use abstract parameterized units similar to ours, but they do not use a speech act grammar to calculate the units. Rather, they map contextual functions onto dialogue goals, e.g., the function new_for_system(goalcity:munich) introduces the dialogue goal confirm(goalcity:mu</context>
</contexts>
<marker>Hagen, 1999</marker>
<rawString>E. Hagen. 1999. An approach to mixed initiative spoken information retrieval dialogue. User Modeling and User-Adapted Interaction, 9(1/2):167-213.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Hagen</author>
</authors>
<title>Mixed Initiative Spoken Dialogue Management in Information Systems.</title>
<date>2001</date>
<tech>Ph.D. thesis,</tech>
<institution>School of Computing Science, Simon Fraser University,</institution>
<location>Burnaby, BC, Canada.</location>
<note>expected.</note>
<contexts>
<context position="28863" citStr="Hagen, 2001" startWordPosition="4320" endWordPosition="4321">e primitive per system turn, the approach is, of course, not limited to this. The service designer can decide to employ mixed initiative dialogue strategies for the system utterances as well, for example, requesting or confirming several values at once or implicitly confirming values. The dialogue strategies for system utterances include choosing nodes in the application description, dealing with speech recognition results, or dealing with ambiguous data from other knowledge sources. Here we present a few examples of how the dialogue manager would combine hypotheses (for more information see (Hagen, 2001)). 137 4.1 Confirmation Strategies We illustrate implicit and multiple confirmation, i.e., the system realizes requestValue and requestConfirm or multiple requestConfirm primitives in one utterance: Dialogue 5: Confirmation Strategies Sys: &amp;quot;Which showing of The Matrix do you want?&amp;quot; requestValue(time) + requestConfi rm (fi I m= M atr ix) Usr: &amp;quot;(No.) Buena Vista!&amp;quot; Int: informNegative(film=The Matrix) + correctValue(film=Buena Vista) + rejectRequest(time) Sys: &amp;quot;Which showing of Buena Vista do you want?&amp;quot; requestConfirm(film=Buena Vista) + requestValue(time) Usr: &amp;quot;The late show. Tomorrow.&amp;quot; Int: inf</context>
<context position="34234" citStr="Hagen, 2001" startWordPosition="5157" endWordPosition="5158"> and thereby disconfirms vs (Matrix) and rejects the request for a value for p1 (time) in requestValue(pi). The second rule corresponds to 138 Table 4: Mapping of user input onto RECprimitives. p=v means that the user provided value v for param p. the second sys/usr pair in Dialogue 5. The user provides value vi (the late show) for pi (time) in requestValue(pi) and thus confirms v2 (Buena Vista) in requestConfirm ( p2=v2). For instantiation of the primitives, see Dialogue 5. Here, we only presented two examples. Similar rules were developed for all our primitives and dialogue strategies (see (Hagen, 2001)). One reviewer asked whether we can modify the approach such that expectations can be overridden if there is sufficently good information from the synsem module. The short answer is that we could (re-)calculate the primitives pretending that the service designer allowed mixed initiative regardless of the dialogue strategies actually chosen. We, however, think it is important to give her the right to decide. For example, if she has decided that over-answering is allowed, informExtraValue() primitives for all parameters whose status is still open would be calculated and thus there is nothing to</context>
</contexts>
<marker>Hagen, 2001</marker>
<rawString>E. Hagen. 2001. Mixed Initiative Spoken Dialogue Management in Information Systems. Ph.D. thesis, School of Computing Science, Simon Fraser University, Burnaby, BC, Canada. Jan. 2001 expected.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Heisterkamp</author>
<author>S McGlashan</author>
</authors>
<title>Units of dialogue management.</title>
<date>1996</date>
<booktitle>In Proc. of the 1996 Intl. Conf. on Spoken Language Processing (ICSLP&apos;96).</booktitle>
<marker>Heisterkamp, McGlashan, 1996</marker>
<rawString>P. Heisterkamp and S. McGlashan. 1996. Units of dialogue management. In Proc. of the 1996 Intl. Conf. on Spoken Language Processing (ICSLP&apos;96).</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Hasson</author>
</authors>
<title>A dialogue manager using initiative-response units and distributed control.</title>
<date>1993</date>
<booktitle>In Proc. of 6th Euro. Conf. of the ACL,</booktitle>
<pages>233--238</pages>
<marker>Hasson, 1993</marker>
<rawString>A. Hasson. 1993. A dialogue manager using initiative-response units and distributed control. In Proc. of 6th Euro. Conf. of the ACL, pages 233-238.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S C Levinson</author>
</authors>
<title>Some pre-observations on the modelling of dialogue.</title>
<date>1981</date>
<booktitle>Discourse Processes,</booktitle>
<pages>4--93</pages>
<contexts>
<context position="26158" citStr="Levinson, 1981" startWordPosition="3964" endWordPosition="3965">Value(time=21:00) + informExtraValue(date=July 4) Sys: &amp;quot;Did you say two tickets?&amp;quot; requestConfirm(noOfTickets=2) Usr: &amp;quot;Yes, but I change to the early show.&amp;quot; Int: informPositive(noOfTickets=2) + changeValue(time=18:30) In Table 3, we present the REC-primitives calculated in response to two system utterances. 3.4 Multi-Functional Turns It has been argued that speech act grammars cannot be used to describe dialogue since utterances can be multi-functional or encode more than one speech act; Speech act grammars can typically be in only one state at a time, thus they cannot capture this phenomenon (Levinson, 1981). In an information retrieval setting such situations occur, for example, when users disregard the system utterance and provide unrelated information or when a recogniton mistake occured and the sytem asks for confirmation. Instead of answering yes or no, users frequently answer with the correct value, which implicitly disconfirms the previous value: Dialogue 4: Multi-Functional Utterances Sys: &amp;quot;How many tickets?&amp;quot; requestValue(noOfTickets) Usr: &amp;quot;I want tickets for July 4.&amp;quot; Int: rejectRequest(noOfTickets) + informExtraValue(date=July 3) Sys: &amp;quot;Did you say July 3?&amp;quot; requestConfirm(date=July 3) Usr</context>
</contexts>
<marker>Levinson, 1981</marker>
<rawString>S.C. Levinson. 1981. Some pre-observations on the modelling of dialogue. Discourse Processes, 4:93-116.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Mast</author>
<author>F Kummert</author>
<author>U Ehrlich</author>
<author>G A Fink</author>
<author>T Kuhn</author>
<author>H Niemann</author>
<author>G Sagerer</author>
</authors>
<title>Prosody takes over: Towards a prosodically guided dialog system.</title>
<date>1994</date>
<journal>Speech Communication,</journal>
<pages>15--1</pages>
<contexts>
<context position="35749" citStr="Mast et al., 1994" startWordPosition="5393" endWordPosition="5396">nt. We concentrated on how to dynamically calculate a collection of predictions for how to continue a dialogue (dialogue primitives), how to account for different dialogue strategies and utterances with several communicative goals through combinations of primitives, and how to map the user utterances onto primitives. The approach has been implemented and tested in several prototype systems, e.g., horoscope, movie, and telephone rate service (Feldes et al., 1998). Dialogue grammars have previously been used to manage dialogue (Bunt, 1989; Bilange, 1991; Raum and Hinkehnan, 1992; Jonsson, 1993; Mast et al., 1994; Novick and Sutton, 1994; Chino and Tsuboi, 1996), but we are not aware of an approach where speech acts are translated into a collection of primitives with propositional content. Previous grammar approaches use the speech acts directly or assume a one-to-one correspondence between utterance and speech act. Through the natural division of the knowledge into type and content, we have achieved a flexible dialogue manager that adapts to users&apos; behaviour. We can take advantage of the predictive capabilites of speech act grammars and still be able to account for multi-functional utterances. We hav</context>
</contexts>
<marker>Mast, Kummert, Ehrlich, Fink, Kuhn, Niemann, Sagerer, 1994</marker>
<rawString>M. Mast, F. Kummert, U. Ehrlich, G.A. Fink, T. Kuhn, H. Niemann, and G. Sagerer. 1994. Prosody takes over: Towards a prosodically guided dialog system. Speech Communication, 15(1-2):155-167.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D G Novick</author>
<author>S Sutton</author>
</authors>
<title>An empirical model of acknowledgement for spoken-language systems.</title>
<date>1994</date>
<booktitle>In Proc. of the 32nd Annual Meeting of the ACL,</booktitle>
<pages>96--101</pages>
<contexts>
<context position="35774" citStr="Novick and Sutton, 1994" startWordPosition="5397" endWordPosition="5400"> on how to dynamically calculate a collection of predictions for how to continue a dialogue (dialogue primitives), how to account for different dialogue strategies and utterances with several communicative goals through combinations of primitives, and how to map the user utterances onto primitives. The approach has been implemented and tested in several prototype systems, e.g., horoscope, movie, and telephone rate service (Feldes et al., 1998). Dialogue grammars have previously been used to manage dialogue (Bunt, 1989; Bilange, 1991; Raum and Hinkehnan, 1992; Jonsson, 1993; Mast et al., 1994; Novick and Sutton, 1994; Chino and Tsuboi, 1996), but we are not aware of an approach where speech acts are translated into a collection of primitives with propositional content. Previous grammar approaches use the speech acts directly or assume a one-to-one correspondence between utterance and speech act. Through the natural division of the knowledge into type and content, we have achieved a flexible dialogue manager that adapts to users&apos; behaviour. We can take advantage of the predictive capabilites of speech act grammars and still be able to account for multi-functional utterances. We have also demonstrated that </context>
</contexts>
<marker>Novick, Sutton, 1994</marker>
<rawString>D.G. Novick and S. Sutton. 1994. An empirical model of acknowledgement for spoken-language systems. In Proc. of the 32nd Annual Meeting of the ACL, pages 96-101.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Sitter</author>
<author>A Stein</author>
</authors>
<title>Modelling the illocutionary aspects of information-seeking dialogues.</title>
<date>1992</date>
<booktitle>Information Processing and Management,</booktitle>
<pages>8--2</pages>
<marker>Sitter, Stein, 1992</marker>
<rawString>S. Sitter and A. Stein. 1992. Modelling the illocutionary aspects of information-seeking dialogues. Information Processing and Management, 8(2):165-180.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Traum</author>
<author>E Hinkelman</author>
</authors>
<title>Conversation acts in task-oriented spoken dialogue.</title>
<date>1992</date>
<journal>Computational Intelligence,</journal>
<pages>8--3</pages>
<marker>Traum, Hinkelman, 1992</marker>
<rawString>D. Traum and E. Hinkelman. 1992. Conversation acts in task-oriented spoken dialogue. Computational Intelligence, 8(3):575-599.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Young</author>
<author>A Hauptmann</author>
<author>W Ward</author>
<author>E Smith</author>
<author>P Werner</author>
</authors>
<title>High-level knowledge sources in usable speech recognition systems.</title>
<date>1990</date>
<booktitle>Readings in Speech Recognition,</booktitle>
<pages>538--549</pages>
<editor>In A. Waibel and K. Lee, editors,</editor>
<publisher>Morgan</publisher>
<location>Kaufman, San Mateo, CA.</location>
<contexts>
<context position="5612" citStr="Young et al., 1990" startWordPosition="859" endWordPosition="862">imple date (e.g., &amp;quot;November 17th&amp;quot;) or a combination of day of the week and week (e.g., &amp;quot;Wednesday this week.&amp;quot;). The nodes keep state information. Open nodes have not yet been negotiated, topic nodes are being negotiated, and closed nodes have been negotiated. The currently active task has status active. Parameters can be retrieved through the functions activeTask(AD), openParams(AD), closedParams(AD), and topicParams(AD). Status(p) returns the status of parameter p. tasks (AD) and params(AD) return the task arid parameter nodes. Similar hierarchical domain descriptions have been suggested in (Young et al., 1990) for a naval domain and in (Carninero-Gil et al., 1996) for an e-mail assistance domain. A tree-like organization of the domain is sufficent for the information retrieval domains, which we are currently considering. We expect, however, that in future work we &apos;Extensions include has-a relations. Figure 2: A description of a movie service. Notation: U and V represent and/or-relations. Subscripts t and,, denote tasks and parameters. will need to switch to a semantic network structure or since our future research includes automatic generation of system utterances from our dialogue primitives, we h</context>
</contexts>
<marker>Young, Hauptmann, Ward, Smith, Werner, 1990</marker>
<rawString>S. Young, A. Hauptmann, W. Ward, E. Smith, and P. Werner. 1990. High-level knowledge sources in usable speech recognition systems. In A. Waibel and K. Lee, editors, Readings in Speech Recognition, pages 538-549. Morgan Kaufman, San Mateo, CA.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Cycle Request</author>
</authors>
<location>Promise(K), Inform(K), Evaluate(S).</location>
<marker>Request, </marker>
<rawString>Cycle(S) Request(S), Promise(K), Inform(K), Evaluate(S).</rawString>
</citation>
<citation valid="false">
<authors>
<author>Cycle Request</author>
</authors>
<location>Promise(K)], WithdrawRequest(S).</location>
<marker>Request, </marker>
<rawString>Cycle(S) Request(S), [Promise(K)], WithdrawRequest(S).</rawString>
</citation>
<citation valid="false">
<authors>
<author>Cycle Request</author>
</authors>
<location>Promise(K), WithdrawPromise(K).</location>
<marker>Request, </marker>
<rawString>Cycle(S) Request(S), Promise(K), WithdrawPromise(K).</rawString>
</citation>
<citation valid="false">
<journal>Offer(K), Accept(S), Inform (K), Eva luate(S). Cycle(S) -&gt; Offer(K), [Accept(S)I, WithdrawOfFer(K). Cycle(S) -4 OfFer(K), Accept(S), WithdrawAccept(S). Cycle(S)</journal>
<tech>Cycle(S) -4 Request(S), RejectRequest(K). Cycle(S) -4</tech>
<volume>4</volume>
<location>Offer(K), RejectOfFer(S).</location>
<marker></marker>
<rawString>Cycle(S) -4 Request(S), RejectRequest(K). Cycle(S) -4 Offer(K), Accept(S), Inform (K), Eva luate(S). Cycle(S) -&gt; Offer(K), [Accept(S)I, WithdrawOfFer(K). Cycle(S) -4 OfFer(K), Accept(S), WithdrawAccept(S). Cycle(S) -4 Offer(K), RejectOfFer(S).</rawString>
</citation>
<citation valid="false">
<authors>
<author>Cycle-4 Withdraw</author>
</authors>
<title>Cycle(S) Withdraw(system). Inform(K) inform(K), [Dia logue(S)].</title>
<journal>Assert(S/K) assert(S/K), [Dialogue(K/S)]. Movei(S/K).</journal>
<marker>Withdraw, </marker>
<rawString>Cycle(S)-4 Withdraw(usr). Cycle(S) Withdraw(system). Inform(K) inform(K), [Dia logue(S)]. Assert(S/K) assert(S/K), [Dialogue(K/S)]. Movei(S/K).</rawString>
</citation>
<citation valid="false">
<authors>
<author>Movei 4 acti</author>
</authors>
<journal>Movei(S/K) act; (S/K), [Assert(S/K)]. Movei(S/K) Dialogue(K/S).</journal>
<marker>acti, </marker>
<rawString>Movei(S/K).4 acti(S/K), [Dialogue(K/S)]. Movei(S/K) act; (S/K), [Assert(S/K)]. Movei(S/K) Dialogue(K/S).</rawString>
</citation>
<citation valid="false">
<journal>Movei(S/K) Assert(S/K), [Dialogue(K/S)].</journal>
<marker></marker>
<rawString>Movei(S/K) -&gt; Assert(S/K), (acti(S/K)]. Movei(S/K) Assert(S/K), [Dialogue(K/S)].</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>