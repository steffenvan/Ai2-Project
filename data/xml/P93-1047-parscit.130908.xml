<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.064452">
<sectionHeader confidence="0.721208" genericHeader="abstract">
EXTENDING KIMMO&apos;S TWO-LEVEL MODEL OF
MORPHOLOGY *
</sectionHeader>
<author confidence="0.874692">
Ano op Sarkar
</author>
<affiliation confidence="0.999132">
Centre for Development of Advanced Computing
Pune University Campus, Pune 411007, India
</affiliation>
<email confidence="0.471338">
anoopaparcom.ernet.in
</email>
<sectionHeader confidence="0.992924" genericHeader="keywords">
Abstract
</sectionHeader>
<bodyText confidence="0.999995888888889">
This paper describes the problems faced while us-
ing Kimmo&apos;s two-level model to describe certain
Indian languages such as Tamil and Hindi. The
two-level model is shown to be descriptively inad-
equate to address these problems. A simple ex-
tension to the basic two-level model is introduced
which allows conflicting phonological rules to co-
exist. The computational complexity of the exten-
sion is the same as Kimmo&apos;s two-level model.
</bodyText>
<sectionHeader confidence="0.998799" genericHeader="introduction">
INTRODUCTION
</sectionHeader>
<bodyText confidence="0.999846142857143">
Kimmo Koskenniemi&apos;s two-level model (Kosken-
niemi, 1983, Koskenniemi, 1984) uses finite-state
transducers to implement phonological rules. This
paper presents the experience of attempting a two-
level phonology for certain Indian languages; the
problems faced in this attempt and their resolu-
tion. The languages we consider are Tamil and
Hindi. For the languages considered we want to
show that practical descriptions of their morphol-
ogy can be achieved by a simple generalization of
the two-level model. Although the basic two-level
model has been generalized in this paper, the ex-
tensions do not affect the complexity or the basic
tenets of the two-level model.
</bodyText>
<sectionHeader confidence="0.9998595" genericHeader="method">
SOME PROBLEMS FOR THE
TWO-LEVEL MODEL
</sectionHeader>
<bodyText confidence="0.996779947368421">
The two-level model is descriptively adequate for
most morphological processes occuring in Indian
languages. However, there are some cases where
the basic two-level fails to give an adequate de-
scription. One problem is caused by the large
number of words imported from Sanskrit in lan-
guages such as Hindi, Tamil and Tibetan. The
other problem occurs in Tamil where phonology
disambiguates between different senses of a mor-
pheme. The cases where these occur is common
*I would like to thank P. Ramanujan and R. Doctor
for their help, and Dr. Darbari for his support.
and productive. They cannot be considered as ex-
ceptional.
For example, in Tamil the verb tulai (to be
similar) is derived from the Sanskrit base word
tula (similarity). The past participle of tulai
exhibits the following property. (LR, and SR refer to
the lexical and surface environments respectively).
</bodyText>
<listItem confidence="0.986513333333333">
(1) LR: tulai+Ota
SR: tolaiOtta
(adj. who resembles [something])
</listItem>
<bodyText confidence="0.998331375">
In this example, the consonant insertion at the
morpheme boundary is consistent with Tamil
phonology, but the realization of u as o in the en-
vironment of tu follows a morphology that origi-
nates in Sanskrit and which causes inconsistency
when used as a general rule in Tamil. The follow-
ing example illustrates how regular Tamil phonol-
ogy works.
</bodyText>
<listItem confidence="0.994311">
(2) LR: kudi+Ota
SR: kudiOtta
(adj. drunk)
(3) LR: tolai+Ota
SR: tolaiOtta
(adj. who has lost [something])
</listItem>
<bodyText confidence="0.99991075">
From examples (1) through (3) we see that the
same environment gives differing surface realiza-
tions. Phonological rules formulated within the
two-level model to describe this data have to be
mutually exclusive. As all phonological rules are
applied simultaneously, the two-level model can
describe the above data only with the use of arbi-
trary diacritics in the lexical representation. The
same problem occurs in Hindi. In Table 1 (6) and
(7) follow regular Hindi phonology, while (4) and
(5) which have descended from Sanskrit display
the use of Sanskrit phonology. All these exam-
ples show that any model of this phonological be-
haviour will have to allow access for a certain class
of words to the phonology of another language
whose rules might conflict with its own.
</bodyText>
<page confidence="0.997899">
304
</page>
<table confidence="0.983417">
Nom. Sing. Ob. Sing. Nom. Pin. Ob. Pin.
pita pita pita pitao
data data data datao
phita phite phite phito
ladka ladke ladke ladko
</table>
<tableCaption confidence="0.999771">
Table 1: Behaviour of certain Hindi words that use Sanskrit phonology
</tableCaption>
<bodyText confidence="0.999757111111111">
There is one other problem that comes up
in Tamil where the phonology disambiguates be-
tween two senses of a stem. For instance, for the
word padi which means either, 1. to read, or 2.
to settle; differing phonological rules apply to the
two senses of the word. If, as in (8) gemination is
applied the continuous participial of padi means
reading, whereas, if nasalized, in (9), it means set-
tling (e.g. of dust).
</bodyText>
<listItem confidence="0.999620166666667">
(8) LR: padi+Otu+Okondu
SR: padiOttuOkkondu
(reading)
(9) LR: padi+Otu+kondu
SR: padiOntuOkondu
(settling)
</listItem>
<bodyText confidence="0.999989470588236">
The two-level model could be conceivably be used
to handle the cases given above by positing ar-
bitrary lexical environments for classes of words
that do not follow the regular phonology of the
language, e.g. in (1) we could have the lexical rep-
resentation as tUlai with rules transforming it to
the surface form. To handle (8) and (9) we could
have lexical forms padiI and padiY tagged with
the appropriate sense and with duplicated phono-
logical rules. But introducing artificial lexical rep-
resentations has the disadvantage that two-level
rules that assume the same lexical environment
across classes of words have to be duplicated, lead-
ing to an inefficient set of rules. A more adequate
method, which increases notational felicity with-
out affecting the computational complexity of the
two-level model is described in the next section.
</bodyText>
<sectionHeader confidence="0.999667" genericHeader="method">
EXTENDING THE TWO-LEVEL
MODEL
</sectionHeader>
<bodyText confidence="0.967473">
The extended two-level model presented allows
each lexical entity to choose a set of phonologi-
cal rules that can be applied for its recognition
and generation.
Consider the two level rules&apos; that apply to ex-
ample (1). Rule 1 transforms u to o in the proper
&apos;The notations used are: * indicates zero or more
instances of an element, parentheses are optional ele-
ments, stands for negation and curly braces indicate
sets of elements that match respectively. 0 stands for
environment while Rule 2 geminates t.3
</bodyText>
<equation confidence="0.957929166666667">
Ria: u: o CV* + : 0 t:t
Rib: 0:t {B,NAS}C +:0 t:t
where, C - consonants
V - vowels
B - voiced stops
NAS - nasals
</equation>
<bodyText confidence="0.9993903">
We cannot allow the rule R1 to apply to (2)
and so we need some method to restrict its ap-
plication to a certain set (in this case all words
like (1) borrowed from Sanskrit). To overcome
this, each lexical entry is associated with a subset
of two-level rules chosen from the complete set of
possible rules. Each morpheme applies its respec-
tive subset in word recognition and generation.
Consider a fictional example—(11) below—to
illustrate how the extended model works.
</bodyText>
<equation confidence="0.977423333333333">
1 2 3
(11) LR: haX + mel + lek
SR: horn 0 mel 0 Oek
Rlla: a:o C X: (+:0)
Rub: X:{m,0} a:_(+:0) {m, m}
Rik: 1:0 1:1 (+:0)
</equation>
<bodyText confidence="0.923717842105263">
Rlla transforms a to o in the proper environ-
ment, Rub geminates m and Rile degeminates
1.3 Assume rule Rlla that is applied to a in mor-
pheme 1—haX—cannot be used in a general way
without conflicts with the complete set of two-level
rules applicable. To avoid conflict we assign a sub-
set of two-level rules, say Pi, to morpheme 1 which
it applies between its morpheme boundaries. Mor-
phemes 2 and 3 both apply rule subset P2 between
their respective boundaries. For instance, Pi here
will be the rule set {RUA, Rilb, Rile} and P2
will be {R11b, R11c}. Note that we have to sup-
the null character in both the lexical and surface rep-
resentations.
2The description presented here is simplified some-
what as the purpose of presenting it is illustrative
rather than exhaustive.
&apos;In rule R11b a: means lexical a can be realized as
any surface character.
</bodyText>
<page confidence="0.998236">
305
</page>
<bodyText confidence="0.999911411764706">
ply each morpheme enough rules within its sub-
set to allow for the left-context and right-context
of the rules that realize other surrounding mor-
phemes. All the rules are still applied in parallel.
At any time in the recognition or generation pro-
cess there is still only one complete set of two-level
rules being used. Any rule (finite state transducer)
that fails and which does not belong to the sub-
set claimed by a morpheme being realized is set
back to the start state. This mechanism allows
mutually conflicting phonological rules to co-exist
in the two-level rulebase and allow them to apply
in their appropriate environments.
For instance, if we have a lexical entry laX
in addition to the morphemes introduced in (11),
then we can have realizations such as (12) by
adding R12 to the above rules.
</bodyText>
<listItem confidence="0.718145666666667">
(12) LR: laX+mel+lek
SR: limOme100ek
R12: a:i C X: (+:0)
</listItem>
<bodyText confidence="0.998962638888889">
Thus laX uses a rule subset P3 which consists
of rules {R12, Rub, R11c}. Notice R12 and R1 la
are potentially in conflict with each other.
In the method detailed above we ignore cer-
tain rule failures by resetting it to its start state.
Can this be justified within the two-level model?
Each rule has a lexical to surface realization which
it applies when it finds that the left context and
the right context specified in the rule is satisfied.
In the extended model, if a rule fails and it does
not belong to the rule set associated with the cur-
rent morpheme, then by resetting it to its start
state we are assuming that the rule&apos;s left context
has not yet begun. The left context of the rule can
begin with the next character in the same mor-
pheme. This property means that we can have
conflicting rules that apply within the same word.
In practice it is better to use an equivalent
method where a set of two-level rules that cannot
apply between its boundaries is stored with a mor-
pheme. If one or more of these rules fail and they
belong to the set associated with that morpheme
then the rule is simply reset to the start state else
we try another path towards the analysis of the
word.
The model presented handles both additive
and mutually exclusive rules, whereas in a system
in which a few morphs specify additional rules and
inherit the rest, mutually exclusive rules have to
be handled with the additional complexity of the
defeasible inheritance of two-level rules.
It is easy to see that the extensions do not in-
crease the computational complexity of the basic
two-level model. We have one additional lexical
tag per morpheme and one check for set member-
ship at every failure of a rule.
</bodyText>
<sectionHeader confidence="0.984944" genericHeader="conclusions">
CONCLUSION
</sectionHeader>
<bodyText confidence="0.99999">
We have shown that some examples from lan-
guages such as Tamil and Hindi cannot be effec-
tively described under Kimmo&apos;s two-level model.
An extension to the basic two-level model is dis-
cussed which allows morphemes to associate with
them rule subsets which correspond to a certain
phonology which gives the morpheme a valid de-
scription. The extension to Kimmo&apos;s two-level
model gives us the following advantages:
</bodyText>
<listItem confidence="0.998915833333333">
• rules that conflict in surface realization can be
used,
• it gives more descriptive power,
• the number of rules are reduced,
• no increase in computational complexity over
• Kimmo&apos;s two-level model.
</listItem>
<bodyText confidence="0.999685833333333">
We have implemented the extended two-level
model using the standard method of represent-
ing phonological rules by deterministic finite state
automata (Antworth, 1990, Karttunen, 1983) and
using PATRICIA (Knuth, 1973) for the storage of
lexical entries.
</bodyText>
<sectionHeader confidence="0.998484" genericHeader="references">
REFERENCES
</sectionHeader>
<reference confidence="0.992712157894737">
Antworth, Evan L., 1990. PC-KIMMO: a two-
level processor for morphological analysis. Oc-
casional Publications in Academic Computing
No. 16. Dallas, TX: Summer Institute of Lin-
guistics.
Karttunen, Lauri, 1983. KIMMO: a general mor-
phological processor. Texas Linguistic Forum
22:163-186.
Knuth, Donald E., 1973. The An of Computer
Programming. Vol. 3/Sorting and Searching.
Addison Wesley, Reading, MA.
Koskenniemi, Kimmo, 1983. A Two Level model
for Morphological Analysis. In Proc. 8th Int?
Joint Conf. of Al (IJCAP83), Karlsruhe.
Koskenniemi, Kimmo, 1984. A General Com-
putational Model for Word-Form Recognition
and Production. In Proc. 10th Intl Conf on
Comp. Ling. (COLINGM, PP. 178-181, Stan-
ford University.
</reference>
<page confidence="0.99921">
306
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.809578">
<title confidence="0.99054">EXTENDING KIMMO&apos;S TWO-LEVEL MODEL OF MORPHOLOGY *</title>
<author confidence="0.987062">Ano op Sarkar</author>
<affiliation confidence="0.99755">Centre for Development of Advanced Computing</affiliation>
<address confidence="0.87783">Pune University Campus, Pune 411007, India</address>
<email confidence="0.967444">anoopaparcom.ernet.in</email>
<abstract confidence="0.9978353">This paper describes the problems faced while using Kimmo&apos;s two-level model to describe certain Indian languages such as Tamil and Hindi. The two-level model is shown to be descriptively inadequate to address these problems. A simple extension to the basic two-level model is introduced which allows conflicting phonological rules to coexist. The computational complexity of the extension is the same as Kimmo&apos;s two-level model.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Evan L Antworth</author>
</authors>
<title>PC-KIMMO: a twolevel processor for morphological analysis.</title>
<date>1990</date>
<booktitle>Occasional Publications in Academic Computing No. 16.</booktitle>
<institution>Summer Institute of Linguistics.</institution>
<location>Dallas, TX:</location>
<marker>Antworth, 1990</marker>
<rawString>Antworth, Evan L., 1990. PC-KIMMO: a twolevel processor for morphological analysis. Occasional Publications in Academic Computing No. 16. Dallas, TX: Summer Institute of Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
</authors>
<title>KIMMO: a general morphological processor. Texas Linguistic Forum</title>
<date>1983</date>
<pages>22--163</pages>
<marker>Karttunen, 1983</marker>
<rawString>Karttunen, Lauri, 1983. KIMMO: a general morphological processor. Texas Linguistic Forum 22:163-186.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Donald E Knuth</author>
</authors>
<title>The An of Computer Programming. Vol. 3/Sorting and Searching.</title>
<date>1973</date>
<publisher>Addison Wesley,</publisher>
<location>Reading, MA.</location>
<marker>Knuth, 1973</marker>
<rawString>Knuth, Donald E., 1973. The An of Computer Programming. Vol. 3/Sorting and Searching. Addison Wesley, Reading, MA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kimmo Koskenniemi</author>
</authors>
<title>A Two Level model for Morphological Analysis. In</title>
<date>1983</date>
<booktitle>Proc. 8th Int? Joint Conf. of Al (IJCAP83),</booktitle>
<location>Karlsruhe.</location>
<contexts>
<context position="679" citStr="Koskenniemi, 1983" startWordPosition="98" endWordPosition="100">r Centre for Development of Advanced Computing Pune University Campus, Pune 411007, India anoopaparcom.ernet.in Abstract This paper describes the problems faced while using Kimmo&apos;s two-level model to describe certain Indian languages such as Tamil and Hindi. The two-level model is shown to be descriptively inadequate to address these problems. A simple extension to the basic two-level model is introduced which allows conflicting phonological rules to coexist. The computational complexity of the extension is the same as Kimmo&apos;s two-level model. INTRODUCTION Kimmo Koskenniemi&apos;s two-level model (Koskenniemi, 1983, Koskenniemi, 1984) uses finite-state transducers to implement phonological rules. This paper presents the experience of attempting a twolevel phonology for certain Indian languages; the problems faced in this attempt and their resolution. The languages we consider are Tamil and Hindi. For the languages considered we want to show that practical descriptions of their morphology can be achieved by a simple generalization of the two-level model. Although the basic two-level model has been generalized in this paper, the extensions do not affect the complexity or the basic tenets of the two-level </context>
</contexts>
<marker>Koskenniemi, 1983</marker>
<rawString>Koskenniemi, Kimmo, 1983. A Two Level model for Morphological Analysis. In Proc. 8th Int? Joint Conf. of Al (IJCAP83), Karlsruhe.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kimmo Koskenniemi</author>
</authors>
<title>A General Computational Model for Word-Form Recognition and Production.</title>
<date>1984</date>
<booktitle>In Proc. 10th Intl Conf on Comp. Ling. (COLINGM, PP.</booktitle>
<pages>178--181</pages>
<institution>Stanford University.</institution>
<contexts>
<context position="699" citStr="Koskenniemi, 1984" startWordPosition="101" endWordPosition="102">pment of Advanced Computing Pune University Campus, Pune 411007, India anoopaparcom.ernet.in Abstract This paper describes the problems faced while using Kimmo&apos;s two-level model to describe certain Indian languages such as Tamil and Hindi. The two-level model is shown to be descriptively inadequate to address these problems. A simple extension to the basic two-level model is introduced which allows conflicting phonological rules to coexist. The computational complexity of the extension is the same as Kimmo&apos;s two-level model. INTRODUCTION Kimmo Koskenniemi&apos;s two-level model (Koskenniemi, 1983, Koskenniemi, 1984) uses finite-state transducers to implement phonological rules. This paper presents the experience of attempting a twolevel phonology for certain Indian languages; the problems faced in this attempt and their resolution. The languages we consider are Tamil and Hindi. For the languages considered we want to show that practical descriptions of their morphology can be achieved by a simple generalization of the two-level model. Although the basic two-level model has been generalized in this paper, the extensions do not affect the complexity or the basic tenets of the two-level model. SOME PROBLEMS</context>
</contexts>
<marker>Koskenniemi, 1984</marker>
<rawString>Koskenniemi, Kimmo, 1984. A General Computational Model for Word-Form Recognition and Production. In Proc. 10th Intl Conf on Comp. Ling. (COLINGM, PP. 178-181, Stanford University.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>