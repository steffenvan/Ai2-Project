<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.998941">
Transforming Controlled Natural Language Biomedical Queries
into Answer Set Programs
</title>
<author confidence="0.986626">
Esra Erdem and Reyyan Yeniterzi
</author>
<affiliation confidence="0.864849666666667">
Faculty of Engineering and Natural Sciences
Sabancı University
Orhanlı, Tuzla 34956 Istanbul, Turkey
</affiliation>
<sectionHeader confidence="0.982969" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999334944444444">
We introduce a controlled natural language for
biomedical queries, called BIOQUERYCNL,
and present an algorithm to convert a biomed-
ical query in this language into a program
in answer set programming (ASP)—a for-
mal framework to automate reasoning about
knowledge. BIOQUERYCNL allows users to
express complex queries (possibly containing
nested relative clauses and cardinality con-
straints) over biomedical ontologies; and such
a transformation of BIOQUERYCNL queries
into ASP programs is useful for automat-
ing reasoning about biomedical ontologies by
means of ASP solvers. We precisely describe
the grammar of BIOQUERYCNL, implement
our transformation algorithm, and illustrate its
applicability to biomedical queries by some
examples.
</bodyText>
<sectionHeader confidence="0.999134" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.9999265625">
The rapid increase in the popularity and usage of
Web leads researchers to store data and make it pub-
licly available in many ways. In particular, to facili-
tate access to its desired parts, it is stored in a struc-
tured form, like ontologies. These ontologies can
be queried with an SQL-like formal query language.
However, since these ontologies have been devel-
oped for and widely used by people that lacks the
necessary knowledge in a formal query language,
a simpler and more commonly known language is
needed to represent queries. A natural language is
the perfect answer, but ambiguities in its grammar
and vocabulary make it difficult to automate reason-
ing about queries in natural language. Therefore, to
represent queries, we consider a middle ground be-
tween these two options: a Controlled Natural Lan-
guage (CNL).
A CNL is a subset of a natural language, with a re-
stricted grammar and vocabulary, that overcomes the
ambiguity of natural languages. Since we consider
queries in a specific domain, namely biomedicine,
and over specific sources of information, namely
biomedical ontologies, a CNL designed and devel-
oped for reasoning about biomedical ontologies is
sufficient to represent biomedical queries. Essen-
tially, a CNL is a formal language but with a look
of a natural language. Therefore, compared to a
natural language, a CNL can be easily converted to
some other formalisms. This allows us to use au-
tomated reasoners, specifically developed for such
formalisms, to find answers to queries expressed in
a CNL.
One such formalism is Answer Set Programming
(ASP) (Baral, 2003). ASP is a new knowledge rep-
resentation and reasoning paradigm which supports
representation of defaults, constraints, preferences,
aggregates, etc., and provides technologies that al-
low us to automate reasoning with incomplete in-
formation, and to integrate other technologies, like
description logics reasoners and Semantic Web tech-
nologies. For instance, in (Bodenreider et al., 2008),
the authors illustrate the applicability and effective-
ness of using ASP to represent a rule layer that inte-
grates relevant parts of some biomedical ontologies
in RDF(S)/OWL, and to compute answers to some
complex biomedical queries over these ontologies.
Although CNLs are appropriate for expressing
biomedical queries, and methods and technologies
</bodyText>
<page confidence="0.96847">
117
</page>
<note confidence="0.9401775">
Proceedings of the Workshop on BioNLP, pages 117–124,
Boulder, Colorado, June 2009. c�2009 Association for Computational Linguistics
</note>
<figureCaption confidence="0.999929">
Figure 1: Architecture of the Overall System
</figureCaption>
<bodyText confidence="0.999871301587301">
of ASP are appropriate for automated reasoning
about biomedical ontologies, there is no algorithm
to convert a CNL biomedical query into a program.
In (Bodenreider et al., 2008), biomedical queries are
represented as programs in ASP; however, these pro-
grams are constructed manually. However, manually
constructing ASP programs to represent biomedi-
cal queries is not only time consuming but also
requires expertise in ASP. This prevents automat-
ing the whole process of computing an answer to a
query, once it is given in a CNL.
In this paper, we design and develop a CNL
(called BIOQUERYCNL) for expressing biomedical
queries over some ontologies, and introduce an al-
gorithm to convert a biomedical query expressed in
this CNL into a program in ASP. The idea is to au-
tomatically compute an answer to the query using
methods of (Bodenreider et al., 2008), once the user
types the query. This idea is illustrated in Figure 1.
Similar approaches of using a CNL for querying
ontologies have been investigated in various stud-
ies. For instance, (Bernstein et al., 2005) consid-
ers queries in the controlled natural language, At-
tempto Controlled English (ACE) (Attempto, 2008),
and transforms them into queries in PQL (Klein and
Bernstein, 2004) to be evaluated by a query engine.
(Bernstein et al., 2006) presents a system that guides
the user to write a query in ACE, and translates the
query into SPARQL to be evaluated by the reasoner
of JENA (Jena, 2008). On the other hand, (Kauf-
mann et al., 2006) transforms a given natural lan-
guage query to a SPARQL query (using the Stan-
ford Parser and WORDNET) to be evaluated by a
reasoner like that of JENA. Our work is different
from these studies in two ways: we consider queries
over biomedical ontologies (thus different forms of
queries, and vocabulary), and we transform a query
into an ASP program to automate reasoning over a
rule layer presented in ASP.
Transformations of natural language sentences
into ASP has been studied in (Baral et al., 2008) and
(Baral et al., 2007). In (Baral et al., 2008), the au-
thors introduce methods to transform some simple
forms of sentences into ASP using Lambda Calcu-
lus. In (Baral et al., 2007), the authors use C&amp;C
tools (CC, 2009) to parse the some forms of natu-
ral language input, and perform a semantic analysis
over the parser output using BOXER (Boxer, 2009),
to do reasoning in ASP. Our work is different in that
we consider a CNL to express queries, and intro-
duce a different method for converting CNL to a pro-
gram in ASP, via Discourse Representation Struc-
tures (DRS) (Kamp, 1981).
In the rest of the paper, first we briefly discuss
ASP with some examples (Section 2). Then we de-
fine the grammatical structure of BIOQUERYCNL
and give some examples (Section 3). Next, we
introduce our algorithm for transforming a BIO-
QUERYCNL query into an ASP program and ex-
plain it by an example (Section 4). We conclude
with a discussion of challenges related to the im-
plementation of our algorithm (Section 5) and other
related problems that we are working on (Section 6).
</bodyText>
<sectionHeader confidence="0.935284" genericHeader="method">
2 Answer Set Programming
</sectionHeader>
<bodyText confidence="0.999653642857143">
Answer Set Programming (ASP) (Lifschitz, 1999;
Marek and Truszczy´nski, 1999; Niemel¨a, 1999;
Baral, 2003) is a new knowledge representation
and reasoning paradigm which supports representa-
tion of defaults, constraints, preferences, aggregates,
etc., and provides technologies that allow us to auto-
mate reasoning with incomplete information, and to
integrate other technologies, like description logics
reasoners and Semantic Web technologies.
In ASP, knowledge is represented as a “program”
(a finite set of “rules”) whose meaning is captured
by its models (called “answer sets” (Gelfond and
Lifschitz, 1988)). Answer sets for a program can
be computed by “answer set solvers” such as DLV
</bodyText>
<page confidence="0.94243">
118
</page>
<bodyText confidence="0.851665166666667">
(DLV, 2009). Consider for instance the program:
gene_gene(“ADRB1”,“CHRM5”).
gene_gene(“CHRM1”,“CHRM5”).
(Q3) What are the genes that are related to the
disease Asthma and are targeted by the drug
Epinephrine?
</bodyText>
<equation confidence="0.999373333333333">
chain(X,Y) :- gene_gene(X,Y).
chain(X,Y) :- gene_gene(Y,X).
chain(X,Y) :- gene_gene(X,Z), chain(Z,Y).
</equation>
<bodyText confidence="0.999965875">
The first rule expresses that the gene ADRB1 inter-
acts with the gene CHRM5. The second rule ex-
presses that the gene CHRM1 interacts with the gene
CHRM5. The third, the fourth, and the fifth rules
express a chain of such interactions. In a rule con-
taining :-, the left-hand-side of :- is called the head
of the rule, the right-hand-side is called the body of
the rule. Such a rule p :- q, r. is read as “p if q
and r”. Here the head atom is p, and the body atoms
are q and r. The answer set for this program de-
scribes that there is a chain of interactions between
CHRM1 and CHRM5, ADRB1 and CHRM5, and
ADRB1 and CHRM1.
As mentioned above, the language of ASP is ex-
pressive enough to represent defaults, constraints,
preferences, aggregates, etc.. For instance, the rule
</bodyText>
<equation confidence="0.935867333333333">
treats_2diseases(R) :-
#count{D:treats(R,D)}&gt;=2, drug(R).
describes drugs R that treat at least 2 diseases.
</equation>
<sectionHeader confidence="0.990091" genericHeader="method">
3 A Controlled Natural Language for
</sectionHeader>
<subsectionHeader confidence="0.509626">
Biomedical Queries
</subsectionHeader>
<bodyText confidence="0.998704785714286">
We introduce a controlled natural language, called
BIOQUERYCNL, to express biomedical queries,
whose grammar is shown in Table 1. This gram-
mar should be considered in connection with the
given biomedical ontologies. The italic words in the
grammar, for instance, represent the information ex-
tracted from the related ontologies. We call these
italic words ontology functions; the detailed descrip-
tion of these functions are given in Table 2.
With BIOQUERYCNL, the users can ask simple
queries, queries with nested relative clauses (with
any number of conjunctions and disjunctions), and
queries with cardinalities. Some sample queries are
given below.
</bodyText>
<listItem confidence="0.938324">
(Q1) Which symptoms are alleviated by the drug
Epinephrine?
(Q2) What are the side-effects of the drugs that treat
the disease Asthma?
(Q4) What are the symptoms of the diseases that are
related to the gene ADRB1 or that are treated
by the drug Epinephrine?
(Q5) Which genes are targeted by at least 2 drugs
and are related to at most 3 diseases?
</listItem>
<bodyText confidence="0.9818975">
BIOQUERYCNL is a subset of Attempto Con-
trolled English (ACE) (Attempto, 2008), which can
represent a wide range of queries (Fuchs et al.,
2008), specialized for biomedical ontologies.
</bodyText>
<sectionHeader confidence="0.975713" genericHeader="method">
4 Converting Controlled Natural
</sectionHeader>
<subsectionHeader confidence="0.539311">
Language Queries to Programs
</subsectionHeader>
<bodyText confidence="0.843997222222222">
We have implemented an algorithm, QUERY, pre-
sented in Algorithm 1, that obtains an ASP rule
Head ← Body from a query Q expressed in BIO-
QUERYCNL, via transforming Q into a DRS. We
will explain the main steps of the QUERY algorithm
by an example, considering query (Q4).
Algorithm 1 QUERY(Q)
Input: A query Q
Output: An ASP rule Head ← Body
</bodyText>
<listItem confidence="0.9914052">
1: D := Find the DRS of Q
2: Head := HEAD(D)
3: Body&apos; := BODY(D)
4: Body := POSTPROCESSING(Body&apos;)
5: return Head ← Body
</listItem>
<subsectionHeader confidence="0.990217">
4.1 Transforming a CNL Query into DRS
</subsectionHeader>
<bodyText confidence="0.998805272727273">
Attempto Controlled English (ACE) text can be
converted into Discourse Representation Structures
(DRS) (Kamp, 1981) — a variant of the first-order
logic that is used for the dynamic interpretation of
natural language and systematic translation of natu-
ral language into logical form — without any am-
biguity, using tools like Attempto Parsing Engine
(APE). APE converts ACE text to DRS by an ap-
proach similar to (Blackburn and Bos, 2005), as ex-
plained in (Fuchs et al., 2008). For instance, APE
transforms query (Q4) into the following DRS:
</bodyText>
<page confidence="0.999172">
119
</page>
<tableCaption confidence="0.999879">
Table 1: The Grammar of BIOQUERYCNL
</tableCaption>
<table confidence="0.997260571428571">
QUERY YESNOQUERY  |WHQUERY QUESTIONMARK
YESNOQUERY DODOESQUERY  |ISAREQUERY
WHQUERY WHATQUERY  |WHICHQUERY
DODOESQUERY [ Do  |Does ] Type() Instance(T) PREDICATERELATION
ISAREQUERY [ Is  |Are ] Type() Instance(T) Verb(T)
WHATQUERY What BE Type() that PREDICATERELATION
WHATQUERY What BE OFRELATION that PREDICATERELATION
WHATQUERY What BE OFRELATIONINSTANCE that PREDICATERELATION
WHICHQUERY Which Type() PREDICATERELATION
OFRELATION Noun(T) of Type()
OFRELATIONINSTANCE Noun(T) of Type() Instance(T)
PREDICATERELATION ACTIVERELATION (CONNECTOR (that)? PREDICATERELATION)*
PREDICATERELATION PASSIVERELATION (CONNECTOR (that)? PREDICATERELATION)*
ACTIVERELATION V erb(T, T0) Type() Instance(T0)
ACTIVERELATION V erb(T, T0) GENERALISEDQUANTOR PositiveNumber Type()
PASSIVERELATION BE V erb(T0, T) by Type() Instance(T0)
PASSIVERELATION BE V erb(T0, T) by GENERALISEDQUANTOR PositiveNumber Type()
BE is  |are
CONNECTOR and  |or
GENERALISEDQUANTOR at least  |at most  |more than  |less than  |exactly
QUESTIONMARK ?
</table>
<tableCaption confidence="0.998662">
Table 2: The Ontology Functions
</tableCaption>
<bodyText confidence="0.8573866">
Type() returns the type information the ontologies keep, ex. gene, disease, drug
Instance(T) returns instances of the type T, ex. Asthma for type disease
Verb(T) returns the verbs related to the type T, ex. approve for type drug
Verb(T, T0) returns the verbs where type T is the subject and type T0 is the object, ex. drug treat disease
Noun(T) returns the nouns that are related to the type T, ex. symptom for type disease
</bodyText>
<figure confidence="0.969114428571429">
[A,B,C,D]
query(A,what)-1
predicate(B,be,A,C)-1
relation(C,of,D)-1
object(C,symptoms,countable,na,eq,1)-1
[E,F,G]
modifier_pp(F,to,E)-1
property(G,related,pos)-1
predicate(F,be,D,G)-1
object(E,gene_ADRB1,countable,na,eq,1)-1
v
[H,I]
predicate(I,treated,H,D)-1
object(H,drug_Epinephrine,
</figure>
<page confidence="0.728657">
countable,na,eq,1)-1
object(D,diseases,countable,na,geq,2)-1
</page>
<bodyText confidence="0.9999134">
Note that the DRS consists of two kinds of expres-
sions. The lines with a list of uppercase letters, like
[E,F,G], describe the domain of the DRS; each up-
percase letter is a referent. The rest of the DRS de-
scribe the conditions about the domain.
The DRS above contains some predefined pred-
icates, such as object, property, predicate,
query, etc.. All the nouns, adjectives, verbs, mod-
ifiers, etc. are represented with one of them. For
instance,
</bodyText>
<listItem confidence="0.999567333333333">
• object describes objects and the relevant
forms of nouns denoting them (like “diseases”)
• predicate describes relations that are pro-
</listItem>
<page confidence="0.979896">
120
</page>
<bodyText confidence="0.9743845">
duced by different forms of verbs (like
“treated”),
</bodyText>
<listItem confidence="0.980827">
• relation describes relations that are produced
by of-constructions (like “symptoms of dis-
ease”),
• query describes the form of the query and the
objects that the query is referring to.
</listItem>
<bodyText confidence="0.9974175">
Ontologies represent relations between concepts.
A rule layer over ontologies introduce further con-
cepts integrating them. ASP takes into account
relevant concepts and relations to answer a given
query about these ontologies. In the biomedical
queries we consider, the concepts and instances are
represented with object and the relations between
these concepts are represented with predicate and
relation. The query is also important in terms of
the type of information the user asks for.
</bodyText>
<subsectionHeader confidence="0.998038">
4.2 Constructing the Head and the Body Atoms
</subsectionHeader>
<bodyText confidence="0.999988105263158">
Once the corresponding DRS is obtained from a
given BIOQUERYCNL query, the head and the body
atoms are constructed by analyzing the conditions in
the DRS, as described in Algorithms 2 and 3.
The HEAD algorithm is about the query pred-
icate, which refers to objects or relations that
are asked for in the given query. By following
the referents, starting from the one mentioned
in query, the algorithm finds out the type of
the information that is asked for in the given
query. Consider, for instance, query (Q4). The
referent mentioned in query(A,what) is A.
It is mentioned in predicate(B,be,A,C)-1,
and here it denotes an object with referent
C. Now let’s find where C is mentioned: in
object(C,symptoms,countable,na,eq,1)-1 to
denote symptoms. Therefore, the query asks for
symptoms. Based on this information, Algorithm 2
returns the head of the ASP rules as follows:
</bodyText>
<equation confidence="0.519232">
what_be_symptoms(SYM1)
</equation>
<bodyText confidence="0.99994325">
The BODY algorithm analyzes the predicate and
the relation predicates. These two predicates de-
scribe relations between objects described by the
object predicates. The algorithm starts from the
predicate and the relation predicates, and then,
by following the referents, it returns the body atoms
of the ASP rule. For instance, Algorithm 3 returns
the following body atoms for query (Q4):
</bodyText>
<equation confidence="0.990643333333333">
symptoms_of_diseases(symptom_SYM1,
disease_DIS1)
diseases_be_related_to_gene(disease_DIS1,
gene_“ADRB1”)
drug_treated_diseases(drug_“Epinephrine”,
disease_DIS1)
</equation>
<bodyText confidence="0.982533">
These body atoms are given to POSTPROCESSING
step, to produce bodies of the ASP rules.
</bodyText>
<subsectionHeader confidence="0.999734">
4.3 Constructing the ASP Rules
</subsectionHeader>
<bodyText confidence="0.9987492">
POSTPROCESSING is the last step of the QUERY
algorithm. At this step, first the number of rules
is determined, and then the body atoms are placed
in the bodies of these rules. In ASP, a conjunc-
tive query can be represented by a rule. However,
disjunctive queries are represented by several rules
with same head but different bodies. For instance,
query (Q4) is a disjunctive query (a disjunction of
two queries), so there will be two rules representing
this query:
</bodyText>
<equation confidence="0.9499893">
what_be_symptoms(SYM1) :-
symptoms_of_diseases(symptom_SYM1,
disease_DIS1),
diseases_be_related_to_gene(disease_DIS1,
gene_“ADRB1”).
what_be_symptoms(SYM1) :-
drug_treated_diseases(drug_“Epinephrine”,
disease_DIS1),
symptoms_of_diseases(symptom_SYM1,
disease_DIS1).
</equation>
<bodyText confidence="0.999841588235294">
Next, the predicate names in the bodies of these
rules are matched with the names of the already de-
fined predicates in ontologies or in the rule layer
over these ontologies. After matching the predicate
names, the parameters of the predicates may have to
be reordered.
The matching of the predicates very much de-
pends on the user interface (UI). If UI enforces users
to use a specific grammar and lexicon while form-
ing the query, then the matching can be done with
an easy table look-up method. If the UI allows more
flexibility of constructing a query, then the match-
ing algorithm should use some basic Natural Lan-
guage Processing methods and similarity metrics to
find the most probable matching.
After matching the predicates, the ordering of the
parameters can be done easily. The BODY algorithm
</bodyText>
<page confidence="0.989414">
121
</page>
<bodyText confidence="0.299394333333333">
Algorithm 2 HEAD(D)
Input: A DRS
Output: Head of an ASP rule
</bodyText>
<listItem confidence="0.994799666666667">
1: query(Ref, QuestionWord) // e.g., query(A, which) for “Which drug ...”
2: if Ref is an object then
3: Object := REFERSTO(Ref) // e.g., A refers to a “drug” DRG1
4: Head := CONCAT(QuestionWord, Object, Ref) // e.g., which drug(DRG1)
5: else if Ref is a subject of a predicate then // query(A, what) for “What are the genes ...”
6: Object := REFERSTO(Ref) // e.g., A refers to “genes” GENE1
7: Head := CONCAT(QuestionWord, Predicate, Object, Ref) // e.g., what be genes(GENE1)
8: end if
9: return Head
</listItem>
<bodyText confidence="0.999537875">
returns the body predicates with the parameters. In
these parameters, the type and the instance names
are kept together. Thus, ordering of those parame-
ters are done just by using the type information. Af-
ter the ordering is done, the type information part is
removed from the parameters.
For instance, after matching the predicates, we get
the following ASP rule for query (Q4).
</bodyText>
<equation confidence="0.865131833333333">
what_be_symptoms(SYM1) :-
disease_symptom(DIS1,SYM1),
disease_gene(DIS1,“ADRB1”).
what_be_symptoms(SYM1) :-
treats_disease(“Epinephrine”,DIS1),
disease_symptom(DIS1,SYM1).
</equation>
<bodyText confidence="0.985367263157895">
With an ASP rule layer over ontologies, and
this ASP program, an ASP solver, like DLVHEX
(DLVHEX, 2009), returns an answer to query (Q4) .
For instance, consider the ASP rule layer, and
the gene, disease, drug ontologies of (Bodenreider
et al., 2008). The ontologies of (Bodenreider et
al., 2008) are obtained from the ontologies PHAR-
MGKB (PharmGKB, 2008), UNIPROT (UniProt,
2008), GENE ONTOLOGY (GO) (GeneOntology,
2008), GENENETWORK database (GeneNetwork,
2008), DRUGBANK (DrugBank, 2008), and the
Medical Symptoms and Signs of Disease web page
(MedicalSymptomsSignsDisease, 2008). With this
rule layer and the ontologies, and the ASP program
above, the following is a part of the answer DLVHEX
finds to the query above:
noisy breathing faster breathing
shortness of breath coughing
chest tightness wheezing
</bodyText>
<subsectionHeader confidence="0.998572">
4.4 Another Example
</subsectionHeader>
<bodyText confidence="0.9995885">
The algorithm discussed above returns the following
ASP program for query (Q5):
</bodyText>
<equation confidence="0.906348">
which_genes(GN1) :-
2&lt;=#count{DRG1:drug_gene(DRG1,GN1)},
#count{DIS1:disease_gene(DIS1,GN1)}&lt;=3.
</equation>
<bodyText confidence="0.999578166666667">
Since query (Q5) contains cardinality constraints,
the ASP program uses the aggregate #count.
More examples of biomedical queries, and
the ASP programs generated by our program
can be seen athttp://people.sabanciuniv.edu/
esraerdem/bioquery-asp/bionlp09/.
</bodyText>
<sectionHeader confidence="0.993182" genericHeader="method">
5 Implementational Issues
</sectionHeader>
<bodyText confidence="0.999984052631579">
We have implemented the algorithms explained
above in PERL. We have used Attempto Parsing
Engine APE to convert a given BIOQUERYCNL
query into a DRS. Since BIOQUERYCNL is about
biomedical ontologies, we provided APE some in-
formation about biomedical concepts, such as gene,
drug, and words that represent relations between
these concepts such as treat, target etc..
However, providing such information is not suf-
ficient to convert all BIOQUERYCNL biomedical
queries into programs, mainly due to specific in-
stances of these concepts (consider, for instance,
various drug names that appear in ontologies). One
way to deal with this problem is to extract from the
ontologies all instances of each concept and provide
them to APE as an additional lexicon. This may not
be the perfect solution since this process has to be
repeated when an instance is added to the ontology.
An alternative way can be enforcing the user to enter
</bodyText>
<page confidence="0.986844">
122
</page>
<reference confidence="0.214948791666667">
Algorithm 3 BODY(D)
Input: A DRS
Output: Body of an ASP rule
1: Body := empty string
2: for each predicate P do
3: // P can be of the form predicate(Ref, Verb, SubRef), like predicate(H, targeted, A)
4: Subject := REFERSTO(SubRef) // e.g., A refers to “genes” GENE1
5: if P has a verb phrase modifier then
6: (Modifier, Object) := REFERSTO(Ref) // e.g., H refers to ( “by”, “drug” DRG1 )
7: end if
8: if P has an object then // P can be of the form predicate(Ref, Verb, SubRef, ObjRef)
9: Object := REFERSTO(ObjRef)
10: end if
11: Body := CONCAT(Body, Subject, Verb, Modifier, Object)
12: // e.g., genes targeted by drugs(GENE1, DRG1)
13: end for
14: for each relation R do
15: // R can be of the form relation(Ref1, of, Ref2), like relation(C, of, D)
16: Object1 := REFERSTO(Ref1) // e.g., C refers to “symptoms” SYM1
17: Object2 := REFERSTO(Ref2) // e.g., D refers to “diseases” DIS1
18: Body := CONCAT(Body, Object1, ”‘of”’, Object2)
19: // e.g., symptoms of diseases(SYM1, DIS1)
20: end for
21: return Body
</reference>
<bodyText confidence="0.998757857142857">
the concept name just before the instance (like “the
drug Epinephrine”) in the query. This is how we deal
with instance names, in the current version of our
implementations. However, such BIOQUERYCNL
queries are not in the language of APE; so, with
some preprocessing, we rewrite these queries in the
correct syntax for APE.
</bodyText>
<sectionHeader confidence="0.999247" genericHeader="conclusions">
6 Conclusion
</sectionHeader>
<bodyText confidence="0.999976565217391">
We have designed and developed a Controlled Nat-
ural Language (CNL), called BIOQUERYCNL, to
represent biomedical queries over some ontologies,
and provided a precise description of its grammati-
cal structure.
We have introduced an algorithm to convert
queries in BIOQUERYCNL to a program in Answer
Set Programming (ASP). The idea is to compute an-
swers to these queries automatically, by means of
automated reasoners in ASP, over biomedical on-
tologies in RDF(S)/OWL and a rule layer in ASP
integrating these ontologies. Our algorithm can
handle various forms of simple/complex disjunc-
tive/conjunctive queries that may contain (nested)
relative clauses and cardinality constraints.
We have implemented this algorithm in PERL,
and tried it with the ASP rule layer, and the ontolo-
gies of (Bodenreider et al., 2008).
One essential part of the overall system is an in-
telligent user interface that allows a user to enter
biomedical queries in BIOQUERYCNL. Design and
implementation of such a user-interface is a part of
our ongoing work.
</bodyText>
<sectionHeader confidence="0.99749" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.99811175">
Thanks to Tobias Kuhn for his help with ACE. This
work is supported by the Scientific and Technolog-
ical Research Council of Turkey (TUBITAK) grant
108E229.
</bodyText>
<sectionHeader confidence="0.994605" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.859385">
Attempto. 2008. http://attempto.ifi.uzh.
ch/site/.
</reference>
<page confidence="0.994808">
123
</page>
<reference confidence="0.9991439625">
Chitta Baral, Juraj Dzifcak, and Luis Tari. 2007. To-
wards overcoming the knowledge acquisition bottle-
neck in answer set prolog applications: Embracing
natural language inputs. In Proc. of ICLP, pages 1–
21.
Chitta Baral, Juraj Dzifcak, and Tran Cao Son. 2008.
Using answer set programming and lambda calculus
to characterize natural language sentences with nor-
matives and exceptions. In Proc. of AAAI, pages 818–
823.
Chitta Baral. 2003. Knowledge Representation, Rea-
soning and Declarative Problem Solving. Cambridge
University Press.
Abraham Bernstein, Esther Kaufmann, Anne G¨ohring,
and Christoph Kiefer. 2005. Querying ontologies: A
controlled english interface for end-users. In Proc. of
ISWC, pages 112–126.
Abraham Bernstein, Esther Kaufmann, Christian Kaiser,
and Christoph Kiefer. 2006. Ginseng: A guided in-
put natural language search engine for querying on-
tologies. In Jena User Conference.
Patrick Blackburn and Johan Bos. 2005. Representation
and Inference for Natural Language. A First Course in
Computational Semantics. CSLI.
Olivier Bodenreider, Zeynep Hande C¸oban, Mahir Can
Do˘ganay, Esra Erdem, and Hilal Kos¸ucu. 2008. A
preliminary report on answering complex queries re-
lated to drug discovery using answer set programming.
In Proc. of ALPSWS.
Boxer. 2009. http://svn.ask.it.usyd.edu.
au/trac/candc/wiki/boxer.
CC. 2009. http://svn.ask.it.usyd.edu.au/
trac/candc/wiki.
DLV. 2009. http://www.dbai.tuwien.ac.at/
proj/dlv.
DLVHEX. 2009. http://con.fusion.at/
dlvhex/.
DrugBank. 2008. http://redpoll.pharmacy.
ualberta.ca/drugbank/.
Norbert E. Fuchs, Kaarel Kaljurand, and Tobias Kuhn.
2008. Discourse representation structures for ace 6.0.
Technical Report IFI-2008.02, Department of Infor-
matics, University of Zurich.
Michael Gelfond and Vladimir Lifschitz. 1988. The
stable model semantics for logic programming. In
Robert Kowalski and Kenneth Bowen, editors, Logic
Programming: Proceedings of the Fifth International
Conference and Symposium.
GeneNetwork. 2008. http://humgen.med.uu.
nl/˜lude/genenetwork.
GeneOntology. 2008. http://www.
geneontology.org.
Jena. 2008. http://jena.sourceforge.net/.
Hans Kamp. 1981. A theory of truth and semantic rep-
resentation. In J. A. G. Groenendijk, T. M. V. Janssen,
and M. B. J. Stokhof, editors, Formal Methods in the
Study of Language, volume 1, pages 277–322.
Esther Kaufmann, Abraham Bernstein, and Renato Zum-
stein. 2006. Querix: A natural language interface
to query ontologies based on clarification dialogs. In
Proc. of ISWC.
Mark Klein and Abraham Bernstein. 2004. Toward high-
precision service retrieval. IEEE Internet Computing,
8(1):30–36.
Vladimir Lifschitz. 1999. Action languages, answer sets
and planning. In The Logic Programming Paradigm:
a 25-Year Perspective. Springer.
Victor Marek and Mirosław Truszczy´nski. 1999. Sta-
ble models and an alternative logic programming
paradigm. In The Logic Programming Paradigm: a
25-Year Perspective. Springer.
MedicalSymptomsSignsDisease. 2008. http:
//www.medicinenet.com/symptoms_and_
signs/article.htm.
Ilkka Niemel¨a. 1999. Logic programs with stable model
semantics as a constraint programming paradigm. An-
nals of Mathematics and Artificial Intelligence, 25.
PharmGKB. 2008. http://www.pharmgkb.org.
UniProt. 2008. http://www.ebi.uniprot.org/
index.shtml.
</reference>
<page confidence="0.998144">
124
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.264729">
<title confidence="0.7538892">Transforming Controlled Natural Language Biomedical into Answer Set Programs Erdem Faculty of Engineering and Natural Sabancı</title>
<address confidence="0.928579">Orhanlı, Tuzla 34956 Istanbul, Turkey</address>
<abstract confidence="0.997110947368421">We introduce a controlled natural language for queries, called and present an algorithm to convert a biomedical query in this language into a program in answer set programming (ASP)—a formal framework to automate reasoning about allows users to express complex queries (possibly containing nested relative clauses and cardinality constraints) over biomedical ontologies; and such transformation of queries into ASP programs is useful for automating reasoning about biomedical ontologies by means of ASP solvers. We precisely describe grammar of implement our transformation algorithm, and illustrate its applicability to biomedical queries by some examples.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<title>Algorithm 3 BODY(D) Input: A DRS Output: Body of an ASP rule 1: Body := empty string 2: for each predicate P do 3: // P can be of the form predicate(Ref, Verb, SubRef), like predicate(H, targeted, A) 4: Subject := REFERSTO(SubRef) // e.g., A refers to “genes” GENE1 5: if P has a verb phrase modifier then 6: (Modifier, Object) := REFERSTO(Ref) // e.g., H refers to ( “by”, “drug” DRG1 ) 7: end if 8: if P has an object then // P can be of the form predicate(Ref, Verb, SubRef, ObjRef) 9: Object := REFERSTO(ObjRef) 10: end if 11:</title>
<date>2008</date>
<journal>Body := CONCAT(Body, Subject, Verb, Modifier, Object)</journal>
<booktitle>Ref2), like relation(C, of, D) 16: Object1 := REFERSTO(Ref1) // e.g., C refers to “symptoms” SYM1 17: Object2 := REFERSTO(Ref2) // e.g., D refers to “diseases” DIS1 18: Body := CONCAT(Body, Object1, ”‘of”’, Object2)</booktitle>
<volume>12</volume>
<note>http://attempto.ifi.uzh. ch/site/.</note>
<marker>2008</marker>
<rawString>Algorithm 3 BODY(D) Input: A DRS Output: Body of an ASP rule 1: Body := empty string 2: for each predicate P do 3: // P can be of the form predicate(Ref, Verb, SubRef), like predicate(H, targeted, A) 4: Subject := REFERSTO(SubRef) // e.g., A refers to “genes” GENE1 5: if P has a verb phrase modifier then 6: (Modifier, Object) := REFERSTO(Ref) // e.g., H refers to ( “by”, “drug” DRG1 ) 7: end if 8: if P has an object then // P can be of the form predicate(Ref, Verb, SubRef, ObjRef) 9: Object := REFERSTO(ObjRef) 10: end if 11: Body := CONCAT(Body, Subject, Verb, Modifier, Object) 12: // e.g., genes targeted by drugs(GENE1, DRG1) 13: end for 14: for each relation R do 15: // R can be of the form relation(Ref1, of, Ref2), like relation(C, of, D) 16: Object1 := REFERSTO(Ref1) // e.g., C refers to “symptoms” SYM1 17: Object2 := REFERSTO(Ref2) // e.g., D refers to “diseases” DIS1 18: Body := CONCAT(Body, Object1, ”‘of”’, Object2) 19: // e.g., symptoms of diseases(SYM1, DIS1) 20: end for 21: return Body Attempto. 2008. http://attempto.ifi.uzh. ch/site/.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Chitta Baral</author>
<author>Juraj Dzifcak</author>
<author>Luis Tari</author>
</authors>
<title>Towards overcoming the knowledge acquisition bottleneck in answer set prolog applications: Embracing natural language inputs.</title>
<date>2007</date>
<booktitle>In Proc. of ICLP,</booktitle>
<pages>1--21</pages>
<contexts>
<context position="5506" citStr="Baral et al., 2007" startWordPosition="862" endWordPosition="865"> be evaluated by the reasoner of JENA (Jena, 2008). On the other hand, (Kaufmann et al., 2006) transforms a given natural language query to a SPARQL query (using the Stanford Parser and WORDNET) to be evaluated by a reasoner like that of JENA. Our work is different from these studies in two ways: we consider queries over biomedical ontologies (thus different forms of queries, and vocabulary), and we transform a query into an ASP program to automate reasoning over a rule layer presented in ASP. Transformations of natural language sentences into ASP has been studied in (Baral et al., 2008) and (Baral et al., 2007). In (Baral et al., 2008), the authors introduce methods to transform some simple forms of sentences into ASP using Lambda Calculus. In (Baral et al., 2007), the authors use C&amp;C tools (CC, 2009) to parse the some forms of natural language input, and perform a semantic analysis over the parser output using BOXER (Boxer, 2009), to do reasoning in ASP. Our work is different in that we consider a CNL to express queries, and introduce a different method for converting CNL to a program in ASP, via Discourse Representation Structures (DRS) (Kamp, 1981). In the rest of the paper, first we briefly disc</context>
</contexts>
<marker>Baral, Dzifcak, Tari, 2007</marker>
<rawString>Chitta Baral, Juraj Dzifcak, and Luis Tari. 2007. Towards overcoming the knowledge acquisition bottleneck in answer set prolog applications: Embracing natural language inputs. In Proc. of ICLP, pages 1– 21.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Chitta Baral</author>
<author>Juraj Dzifcak</author>
<author>Tran Cao Son</author>
</authors>
<title>Using answer set programming and lambda calculus to characterize natural language sentences with normatives and exceptions.</title>
<date>2008</date>
<booktitle>In Proc. of AAAI,</booktitle>
<pages>818--823</pages>
<contexts>
<context position="5481" citStr="Baral et al., 2008" startWordPosition="857" endWordPosition="860"> the query into SPARQL to be evaluated by the reasoner of JENA (Jena, 2008). On the other hand, (Kaufmann et al., 2006) transforms a given natural language query to a SPARQL query (using the Stanford Parser and WORDNET) to be evaluated by a reasoner like that of JENA. Our work is different from these studies in two ways: we consider queries over biomedical ontologies (thus different forms of queries, and vocabulary), and we transform a query into an ASP program to automate reasoning over a rule layer presented in ASP. Transformations of natural language sentences into ASP has been studied in (Baral et al., 2008) and (Baral et al., 2007). In (Baral et al., 2008), the authors introduce methods to transform some simple forms of sentences into ASP using Lambda Calculus. In (Baral et al., 2007), the authors use C&amp;C tools (CC, 2009) to parse the some forms of natural language input, and perform a semantic analysis over the parser output using BOXER (Boxer, 2009), to do reasoning in ASP. Our work is different in that we consider a CNL to express queries, and introduce a different method for converting CNL to a program in ASP, via Discourse Representation Structures (DRS) (Kamp, 1981). In the rest of the pap</context>
</contexts>
<marker>Baral, Dzifcak, Son, 2008</marker>
<rawString>Chitta Baral, Juraj Dzifcak, and Tran Cao Son. 2008. Using answer set programming and lambda calculus to characterize natural language sentences with normatives and exceptions. In Proc. of AAAI, pages 818– 823.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Chitta Baral</author>
</authors>
<title>Knowledge Representation, Reasoning and Declarative Problem Solving.</title>
<date>2003</date>
<publisher>Cambridge University Press.</publisher>
<contexts>
<context position="2567" citStr="Baral, 2003" startWordPosition="393" endWordPosition="394">ies in a specific domain, namely biomedicine, and over specific sources of information, namely biomedical ontologies, a CNL designed and developed for reasoning about biomedical ontologies is sufficient to represent biomedical queries. Essentially, a CNL is a formal language but with a look of a natural language. Therefore, compared to a natural language, a CNL can be easily converted to some other formalisms. This allows us to use automated reasoners, specifically developed for such formalisms, to find answers to queries expressed in a CNL. One such formalism is Answer Set Programming (ASP) (Baral, 2003). ASP is a new knowledge representation and reasoning paradigm which supports representation of defaults, constraints, preferences, aggregates, etc., and provides technologies that allow us to automate reasoning with incomplete information, and to integrate other technologies, like description logics reasoners and Semantic Web technologies. For instance, in (Bodenreider et al., 2008), the authors illustrate the applicability and effectiveness of using ASP to represent a rule layer that integrates relevant parts of some biomedical ontologies in RDF(S)/OWL, and to compute answers to some complex</context>
<context position="6667" citStr="Baral, 2003" startWordPosition="1064" endWordPosition="1065">1). In the rest of the paper, first we briefly discuss ASP with some examples (Section 2). Then we define the grammatical structure of BIOQUERYCNL and give some examples (Section 3). Next, we introduce our algorithm for transforming a BIOQUERYCNL query into an ASP program and explain it by an example (Section 4). We conclude with a discussion of challenges related to the implementation of our algorithm (Section 5) and other related problems that we are working on (Section 6). 2 Answer Set Programming Answer Set Programming (ASP) (Lifschitz, 1999; Marek and Truszczy´nski, 1999; Niemel¨a, 1999; Baral, 2003) is a new knowledge representation and reasoning paradigm which supports representation of defaults, constraints, preferences, aggregates, etc., and provides technologies that allow us to automate reasoning with incomplete information, and to integrate other technologies, like description logics reasoners and Semantic Web technologies. In ASP, knowledge is represented as a “program” (a finite set of “rules”) whose meaning is captured by its models (called “answer sets” (Gelfond and Lifschitz, 1988)). Answer sets for a program can be computed by “answer set solvers” such as DLV 118 (DLV, 2009).</context>
</contexts>
<marker>Baral, 2003</marker>
<rawString>Chitta Baral. 2003. Knowledge Representation, Reasoning and Declarative Problem Solving. Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Abraham Bernstein</author>
<author>Esther Kaufmann</author>
<author>Anne G¨ohring</author>
<author>Christoph Kiefer</author>
</authors>
<title>Querying ontologies: A controlled english interface for end-users.</title>
<date>2005</date>
<booktitle>In Proc. of ISWC,</booktitle>
<pages>112--126</pages>
<marker>Bernstein, Kaufmann, G¨ohring, Kiefer, 2005</marker>
<rawString>Abraham Bernstein, Esther Kaufmann, Anne G¨ohring, and Christoph Kiefer. 2005. Querying ontologies: A controlled english interface for end-users. In Proc. of ISWC, pages 112–126.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Abraham Bernstein</author>
<author>Esther Kaufmann</author>
<author>Christian Kaiser</author>
<author>Christoph Kiefer</author>
</authors>
<title>Ginseng: A guided input natural language search engine for querying ontologies.</title>
<date>2006</date>
<booktitle>In Jena User Conference.</booktitle>
<contexts>
<context position="4783" citStr="Bernstein et al., 2006" startWordPosition="734" endWordPosition="737"> to convert a biomedical query expressed in this CNL into a program in ASP. The idea is to automatically compute an answer to the query using methods of (Bodenreider et al., 2008), once the user types the query. This idea is illustrated in Figure 1. Similar approaches of using a CNL for querying ontologies have been investigated in various studies. For instance, (Bernstein et al., 2005) considers queries in the controlled natural language, Attempto Controlled English (ACE) (Attempto, 2008), and transforms them into queries in PQL (Klein and Bernstein, 2004) to be evaluated by a query engine. (Bernstein et al., 2006) presents a system that guides the user to write a query in ACE, and translates the query into SPARQL to be evaluated by the reasoner of JENA (Jena, 2008). On the other hand, (Kaufmann et al., 2006) transforms a given natural language query to a SPARQL query (using the Stanford Parser and WORDNET) to be evaluated by a reasoner like that of JENA. Our work is different from these studies in two ways: we consider queries over biomedical ontologies (thus different forms of queries, and vocabulary), and we transform a query into an ASP program to automate reasoning over a rule layer presented in AS</context>
</contexts>
<marker>Bernstein, Kaufmann, Kaiser, Kiefer, 2006</marker>
<rawString>Abraham Bernstein, Esther Kaufmann, Christian Kaiser, and Christoph Kiefer. 2006. Ginseng: A guided input natural language search engine for querying ontologies. In Jena User Conference.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Patrick Blackburn</author>
<author>Johan Bos</author>
</authors>
<title>Representation and Inference for Natural Language. A First Course in Computational Semantics.</title>
<date>2005</date>
<publisher>CSLI.</publisher>
<contexts>
<context position="10673" citStr="Blackburn and Bos, 2005" startWordPosition="1715" endWordPosition="1718">utput: An ASP rule Head ← Body 1: D := Find the DRS of Q 2: Head := HEAD(D) 3: Body&apos; := BODY(D) 4: Body := POSTPROCESSING(Body&apos;) 5: return Head ← Body 4.1 Transforming a CNL Query into DRS Attempto Controlled English (ACE) text can be converted into Discourse Representation Structures (DRS) (Kamp, 1981) — a variant of the first-order logic that is used for the dynamic interpretation of natural language and systematic translation of natural language into logical form — without any ambiguity, using tools like Attempto Parsing Engine (APE). APE converts ACE text to DRS by an approach similar to (Blackburn and Bos, 2005), as explained in (Fuchs et al., 2008). For instance, APE transforms query (Q4) into the following DRS: 119 Table 1: The Grammar of BIOQUERYCNL QUERY YESNOQUERY |WHQUERY QUESTIONMARK YESNOQUERY DODOESQUERY |ISAREQUERY WHQUERY WHATQUERY |WHICHQUERY DODOESQUERY [ Do |Does ] Type() Instance(T) PREDICATERELATION ISAREQUERY [ Is |Are ] Type() Instance(T) Verb(T) WHATQUERY What BE Type() that PREDICATERELATION WHATQUERY What BE OFRELATION that PREDICATERELATION WHATQUERY What BE OFRELATIONINSTANCE that PREDICATERELATION WHICHQUERY Which Type() PREDICATERELATION OFRELATION Noun(T) of Type() OFRELATIO</context>
</contexts>
<marker>Blackburn, Bos, 2005</marker>
<rawString>Patrick Blackburn and Johan Bos. 2005. Representation and Inference for Natural Language. A First Course in Computational Semantics. CSLI.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Olivier Bodenreider</author>
</authors>
<title>Zeynep Hande C¸oban, Mahir Can Do˘ganay, Esra Erdem, and Hilal Kos¸ucu.</title>
<date>2008</date>
<booktitle>In Proc. of ALPSWS.</booktitle>
<marker>Bodenreider, 2008</marker>
<rawString>Olivier Bodenreider, Zeynep Hande C¸oban, Mahir Can Do˘ganay, Esra Erdem, and Hilal Kos¸ucu. 2008. A preliminary report on answering complex queries related to drug discovery using answer set programming. In Proc. of ALPSWS.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Boxer</author>
</authors>
<date>2009</date>
<note>http://svn.ask.it.usyd.edu. au/trac/candc/wiki/boxer.</note>
<contexts>
<context position="5832" citStr="Boxer, 2009" startWordPosition="922" endWordPosition="923"> ontologies (thus different forms of queries, and vocabulary), and we transform a query into an ASP program to automate reasoning over a rule layer presented in ASP. Transformations of natural language sentences into ASP has been studied in (Baral et al., 2008) and (Baral et al., 2007). In (Baral et al., 2008), the authors introduce methods to transform some simple forms of sentences into ASP using Lambda Calculus. In (Baral et al., 2007), the authors use C&amp;C tools (CC, 2009) to parse the some forms of natural language input, and perform a semantic analysis over the parser output using BOXER (Boxer, 2009), to do reasoning in ASP. Our work is different in that we consider a CNL to express queries, and introduce a different method for converting CNL to a program in ASP, via Discourse Representation Structures (DRS) (Kamp, 1981). In the rest of the paper, first we briefly discuss ASP with some examples (Section 2). Then we define the grammatical structure of BIOQUERYCNL and give some examples (Section 3). Next, we introduce our algorithm for transforming a BIOQUERYCNL query into an ASP program and explain it by an example (Section 4). We conclude with a discussion of challenges related to the imp</context>
</contexts>
<marker>Boxer, 2009</marker>
<rawString>Boxer. 2009. http://svn.ask.it.usyd.edu. au/trac/candc/wiki/boxer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>CC</author>
</authors>
<date>2009</date>
<note>http://svn.ask.it.usyd.edu.au/ trac/candc/wiki.</note>
<contexts>
<context position="5700" citStr="CC, 2009" startWordPosition="899" endWordPosition="900">luated by a reasoner like that of JENA. Our work is different from these studies in two ways: we consider queries over biomedical ontologies (thus different forms of queries, and vocabulary), and we transform a query into an ASP program to automate reasoning over a rule layer presented in ASP. Transformations of natural language sentences into ASP has been studied in (Baral et al., 2008) and (Baral et al., 2007). In (Baral et al., 2008), the authors introduce methods to transform some simple forms of sentences into ASP using Lambda Calculus. In (Baral et al., 2007), the authors use C&amp;C tools (CC, 2009) to parse the some forms of natural language input, and perform a semantic analysis over the parser output using BOXER (Boxer, 2009), to do reasoning in ASP. Our work is different in that we consider a CNL to express queries, and introduce a different method for converting CNL to a program in ASP, via Discourse Representation Structures (DRS) (Kamp, 1981). In the rest of the paper, first we briefly discuss ASP with some examples (Section 2). Then we define the grammatical structure of BIOQUERYCNL and give some examples (Section 3). Next, we introduce our algorithm for transforming a BIOQUERYCN</context>
</contexts>
<marker>CC, 2009</marker>
<rawString>CC. 2009. http://svn.ask.it.usyd.edu.au/ trac/candc/wiki.</rawString>
</citation>
<citation valid="true">
<authors>
<author>DLV</author>
</authors>
<date>2009</date>
<note>http://www.dbai.tuwien.ac.at/ proj/dlv.</note>
<contexts>
<context position="7266" citStr="DLV, 2009" startWordPosition="1153" endWordPosition="1154">aral, 2003) is a new knowledge representation and reasoning paradigm which supports representation of defaults, constraints, preferences, aggregates, etc., and provides technologies that allow us to automate reasoning with incomplete information, and to integrate other technologies, like description logics reasoners and Semantic Web technologies. In ASP, knowledge is represented as a “program” (a finite set of “rules”) whose meaning is captured by its models (called “answer sets” (Gelfond and Lifschitz, 1988)). Answer sets for a program can be computed by “answer set solvers” such as DLV 118 (DLV, 2009). Consider for instance the program: gene_gene(“ADRB1”,“CHRM5”). gene_gene(“CHRM1”,“CHRM5”). (Q3) What are the genes that are related to the disease Asthma and are targeted by the drug Epinephrine? chain(X,Y) :- gene_gene(X,Y). chain(X,Y) :- gene_gene(Y,X). chain(X,Y) :- gene_gene(X,Z), chain(Z,Y). The first rule expresses that the gene ADRB1 interacts with the gene CHRM5. The second rule expresses that the gene CHRM1 interacts with the gene CHRM5. The third, the fourth, and the fifth rules express a chain of such interactions. In a rule containing :-, the left-hand-side of :- is called the he</context>
</contexts>
<marker>DLV, 2009</marker>
<rawString>DLV. 2009. http://www.dbai.tuwien.ac.at/ proj/dlv.</rawString>
</citation>
<citation valid="true">
<authors>
<author>DLVHEX</author>
</authors>
<date>2009</date>
<note>http://con.fusion.at/ dlvhex/.</note>
<contexts>
<context position="18291" citStr="DLVHEX, 2009" startWordPosition="2823" endWordPosition="2824">ameters. In these parameters, the type and the instance names are kept together. Thus, ordering of those parameters are done just by using the type information. After the ordering is done, the type information part is removed from the parameters. For instance, after matching the predicates, we get the following ASP rule for query (Q4). what_be_symptoms(SYM1) :- disease_symptom(DIS1,SYM1), disease_gene(DIS1,“ADRB1”). what_be_symptoms(SYM1) :- treats_disease(“Epinephrine”,DIS1), disease_symptom(DIS1,SYM1). With an ASP rule layer over ontologies, and this ASP program, an ASP solver, like DLVHEX (DLVHEX, 2009), returns an answer to query (Q4) . For instance, consider the ASP rule layer, and the gene, disease, drug ontologies of (Bodenreider et al., 2008). The ontologies of (Bodenreider et al., 2008) are obtained from the ontologies PHARMGKB (PharmGKB, 2008), UNIPROT (UniProt, 2008), GENE ONTOLOGY (GO) (GeneOntology, 2008), GENENETWORK database (GeneNetwork, 2008), DRUGBANK (DrugBank, 2008), and the Medical Symptoms and Signs of Disease web page (MedicalSymptomsSignsDisease, 2008). With this rule layer and the ontologies, and the ASP program above, the following is a part of the answer DLVHEX finds </context>
</contexts>
<marker>DLVHEX, 2009</marker>
<rawString>DLVHEX. 2009. http://con.fusion.at/ dlvhex/.</rawString>
</citation>
<citation valid="true">
<authors>
<author>DrugBank</author>
</authors>
<date>2008</date>
<note>http://redpoll.pharmacy. ualberta.ca/drugbank/.</note>
<contexts>
<context position="18678" citStr="DrugBank, 2008" startWordPosition="2879" endWordPosition="2880">SYM1), disease_gene(DIS1,“ADRB1”). what_be_symptoms(SYM1) :- treats_disease(“Epinephrine”,DIS1), disease_symptom(DIS1,SYM1). With an ASP rule layer over ontologies, and this ASP program, an ASP solver, like DLVHEX (DLVHEX, 2009), returns an answer to query (Q4) . For instance, consider the ASP rule layer, and the gene, disease, drug ontologies of (Bodenreider et al., 2008). The ontologies of (Bodenreider et al., 2008) are obtained from the ontologies PHARMGKB (PharmGKB, 2008), UNIPROT (UniProt, 2008), GENE ONTOLOGY (GO) (GeneOntology, 2008), GENENETWORK database (GeneNetwork, 2008), DRUGBANK (DrugBank, 2008), and the Medical Symptoms and Signs of Disease web page (MedicalSymptomsSignsDisease, 2008). With this rule layer and the ontologies, and the ASP program above, the following is a part of the answer DLVHEX finds to the query above: noisy breathing faster breathing shortness of breath coughing chest tightness wheezing 4.4 Another Example The algorithm discussed above returns the following ASP program for query (Q5): which_genes(GN1) :- 2&lt;=#count{DRG1:drug_gene(DRG1,GN1)}, #count{DIS1:disease_gene(DIS1,GN1)}&lt;=3. Since query (Q5) contains cardinality constraints, the ASP program uses the aggrega</context>
</contexts>
<marker>DrugBank, 2008</marker>
<rawString>DrugBank. 2008. http://redpoll.pharmacy. ualberta.ca/drugbank/.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Norbert E Fuchs</author>
<author>Kaarel Kaljurand</author>
<author>Tobias Kuhn</author>
</authors>
<title>Discourse representation structures for ace 6.0.</title>
<date>2008</date>
<tech>Technical Report IFI-2008.02,</tech>
<institution>Department of Informatics, University of Zurich.</institution>
<contexts>
<context position="9639" citStr="Fuchs et al., 2008" startWordPosition="1538" endWordPosition="1541">clauses (with any number of conjunctions and disjunctions), and queries with cardinalities. Some sample queries are given below. (Q1) Which symptoms are alleviated by the drug Epinephrine? (Q2) What are the side-effects of the drugs that treat the disease Asthma? (Q4) What are the symptoms of the diseases that are related to the gene ADRB1 or that are treated by the drug Epinephrine? (Q5) Which genes are targeted by at least 2 drugs and are related to at most 3 diseases? BIOQUERYCNL is a subset of Attempto Controlled English (ACE) (Attempto, 2008), which can represent a wide range of queries (Fuchs et al., 2008), specialized for biomedical ontologies. 4 Converting Controlled Natural Language Queries to Programs We have implemented an algorithm, QUERY, presented in Algorithm 1, that obtains an ASP rule Head ← Body from a query Q expressed in BIOQUERYCNL, via transforming Q into a DRS. We will explain the main steps of the QUERY algorithm by an example, considering query (Q4). Algorithm 1 QUERY(Q) Input: A query Q Output: An ASP rule Head ← Body 1: D := Find the DRS of Q 2: Head := HEAD(D) 3: Body&apos; := BODY(D) 4: Body := POSTPROCESSING(Body&apos;) 5: return Head ← Body 4.1 Transforming a CNL Query into DRS A</context>
</contexts>
<marker>Fuchs, Kaljurand, Kuhn, 2008</marker>
<rawString>Norbert E. Fuchs, Kaarel Kaljurand, and Tobias Kuhn. 2008. Discourse representation structures for ace 6.0. Technical Report IFI-2008.02, Department of Informatics, University of Zurich.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Gelfond</author>
<author>Vladimir Lifschitz</author>
</authors>
<title>The stable model semantics for logic programming.</title>
<date>1988</date>
<booktitle>Logic Programming: Proceedings of the Fifth International Conference and Symposium.</booktitle>
<editor>In Robert Kowalski and Kenneth Bowen, editors,</editor>
<contexts>
<context position="7170" citStr="Gelfond and Lifschitz, 1988" startWordPosition="1133" endWordPosition="1136">er Set Programming Answer Set Programming (ASP) (Lifschitz, 1999; Marek and Truszczy´nski, 1999; Niemel¨a, 1999; Baral, 2003) is a new knowledge representation and reasoning paradigm which supports representation of defaults, constraints, preferences, aggregates, etc., and provides technologies that allow us to automate reasoning with incomplete information, and to integrate other technologies, like description logics reasoners and Semantic Web technologies. In ASP, knowledge is represented as a “program” (a finite set of “rules”) whose meaning is captured by its models (called “answer sets” (Gelfond and Lifschitz, 1988)). Answer sets for a program can be computed by “answer set solvers” such as DLV 118 (DLV, 2009). Consider for instance the program: gene_gene(“ADRB1”,“CHRM5”). gene_gene(“CHRM1”,“CHRM5”). (Q3) What are the genes that are related to the disease Asthma and are targeted by the drug Epinephrine? chain(X,Y) :- gene_gene(X,Y). chain(X,Y) :- gene_gene(Y,X). chain(X,Y) :- gene_gene(X,Z), chain(Z,Y). The first rule expresses that the gene ADRB1 interacts with the gene CHRM5. The second rule expresses that the gene CHRM1 interacts with the gene CHRM5. The third, the fourth, and the fifth rules express </context>
</contexts>
<marker>Gelfond, Lifschitz, 1988</marker>
<rawString>Michael Gelfond and Vladimir Lifschitz. 1988. The stable model semantics for logic programming. In Robert Kowalski and Kenneth Bowen, editors, Logic Programming: Proceedings of the Fifth International Conference and Symposium.</rawString>
</citation>
<citation valid="true">
<authors>
<author>GeneNetwork</author>
</authors>
<date>2008</date>
<note>http://humgen.med.uu. nl/˜lude/genenetwork.</note>
<contexts>
<context position="18651" citStr="GeneNetwork, 2008" startWordPosition="2876" endWordPosition="2877">SYM1) :- disease_symptom(DIS1,SYM1), disease_gene(DIS1,“ADRB1”). what_be_symptoms(SYM1) :- treats_disease(“Epinephrine”,DIS1), disease_symptom(DIS1,SYM1). With an ASP rule layer over ontologies, and this ASP program, an ASP solver, like DLVHEX (DLVHEX, 2009), returns an answer to query (Q4) . For instance, consider the ASP rule layer, and the gene, disease, drug ontologies of (Bodenreider et al., 2008). The ontologies of (Bodenreider et al., 2008) are obtained from the ontologies PHARMGKB (PharmGKB, 2008), UNIPROT (UniProt, 2008), GENE ONTOLOGY (GO) (GeneOntology, 2008), GENENETWORK database (GeneNetwork, 2008), DRUGBANK (DrugBank, 2008), and the Medical Symptoms and Signs of Disease web page (MedicalSymptomsSignsDisease, 2008). With this rule layer and the ontologies, and the ASP program above, the following is a part of the answer DLVHEX finds to the query above: noisy breathing faster breathing shortness of breath coughing chest tightness wheezing 4.4 Another Example The algorithm discussed above returns the following ASP program for query (Q5): which_genes(GN1) :- 2&lt;=#count{DRG1:drug_gene(DRG1,GN1)}, #count{DIS1:disease_gene(DIS1,GN1)}&lt;=3. Since query (Q5) contains cardinality constraints, the A</context>
</contexts>
<marker>GeneNetwork, 2008</marker>
<rawString>GeneNetwork. 2008. http://humgen.med.uu. nl/˜lude/genenetwork.</rawString>
</citation>
<citation valid="true">
<authors>
<author>GeneOntology</author>
</authors>
<date>2008</date>
<note>http://www. geneontology.org.</note>
<contexts>
<context position="18609" citStr="GeneOntology, 2008" startWordPosition="2872" endWordPosition="2873"> ASP rule for query (Q4). what_be_symptoms(SYM1) :- disease_symptom(DIS1,SYM1), disease_gene(DIS1,“ADRB1”). what_be_symptoms(SYM1) :- treats_disease(“Epinephrine”,DIS1), disease_symptom(DIS1,SYM1). With an ASP rule layer over ontologies, and this ASP program, an ASP solver, like DLVHEX (DLVHEX, 2009), returns an answer to query (Q4) . For instance, consider the ASP rule layer, and the gene, disease, drug ontologies of (Bodenreider et al., 2008). The ontologies of (Bodenreider et al., 2008) are obtained from the ontologies PHARMGKB (PharmGKB, 2008), UNIPROT (UniProt, 2008), GENE ONTOLOGY (GO) (GeneOntology, 2008), GENENETWORK database (GeneNetwork, 2008), DRUGBANK (DrugBank, 2008), and the Medical Symptoms and Signs of Disease web page (MedicalSymptomsSignsDisease, 2008). With this rule layer and the ontologies, and the ASP program above, the following is a part of the answer DLVHEX finds to the query above: noisy breathing faster breathing shortness of breath coughing chest tightness wheezing 4.4 Another Example The algorithm discussed above returns the following ASP program for query (Q5): which_genes(GN1) :- 2&lt;=#count{DRG1:drug_gene(DRG1,GN1)}, #count{DIS1:disease_gene(DIS1,GN1)}&lt;=3. Since query (Q</context>
</contexts>
<marker>GeneOntology, 2008</marker>
<rawString>GeneOntology. 2008. http://www. geneontology.org.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jena</author>
</authors>
<date>2008</date>
<note>http://jena.sourceforge.net/.</note>
<contexts>
<context position="4937" citStr="Jena, 2008" startWordPosition="765" endWordPosition="766">et al., 2008), once the user types the query. This idea is illustrated in Figure 1. Similar approaches of using a CNL for querying ontologies have been investigated in various studies. For instance, (Bernstein et al., 2005) considers queries in the controlled natural language, Attempto Controlled English (ACE) (Attempto, 2008), and transforms them into queries in PQL (Klein and Bernstein, 2004) to be evaluated by a query engine. (Bernstein et al., 2006) presents a system that guides the user to write a query in ACE, and translates the query into SPARQL to be evaluated by the reasoner of JENA (Jena, 2008). On the other hand, (Kaufmann et al., 2006) transforms a given natural language query to a SPARQL query (using the Stanford Parser and WORDNET) to be evaluated by a reasoner like that of JENA. Our work is different from these studies in two ways: we consider queries over biomedical ontologies (thus different forms of queries, and vocabulary), and we transform a query into an ASP program to automate reasoning over a rule layer presented in ASP. Transformations of natural language sentences into ASP has been studied in (Baral et al., 2008) and (Baral et al., 2007). In (Baral et al., 2008), the </context>
</contexts>
<marker>Jena, 2008</marker>
<rawString>Jena. 2008. http://jena.sourceforge.net/.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hans Kamp</author>
</authors>
<title>A theory of truth and semantic representation.</title>
<date>1981</date>
<booktitle>Formal Methods in the Study of Language,</booktitle>
<volume>1</volume>
<pages>277--322</pages>
<editor>In J. A. G. Groenendijk, T. M. V. Janssen, and M. B. J. Stokhof, editors,</editor>
<contexts>
<context position="6057" citStr="Kamp, 1981" startWordPosition="963" endWordPosition="964">een studied in (Baral et al., 2008) and (Baral et al., 2007). In (Baral et al., 2008), the authors introduce methods to transform some simple forms of sentences into ASP using Lambda Calculus. In (Baral et al., 2007), the authors use C&amp;C tools (CC, 2009) to parse the some forms of natural language input, and perform a semantic analysis over the parser output using BOXER (Boxer, 2009), to do reasoning in ASP. Our work is different in that we consider a CNL to express queries, and introduce a different method for converting CNL to a program in ASP, via Discourse Representation Structures (DRS) (Kamp, 1981). In the rest of the paper, first we briefly discuss ASP with some examples (Section 2). Then we define the grammatical structure of BIOQUERYCNL and give some examples (Section 3). Next, we introduce our algorithm for transforming a BIOQUERYCNL query into an ASP program and explain it by an example (Section 4). We conclude with a discussion of challenges related to the implementation of our algorithm (Section 5) and other related problems that we are working on (Section 6). 2 Answer Set Programming Answer Set Programming (ASP) (Lifschitz, 1999; Marek and Truszczy´nski, 1999; Niemel¨a, 1999; Ba</context>
<context position="10353" citStr="Kamp, 1981" startWordPosition="1662" endWordPosition="1663">e have implemented an algorithm, QUERY, presented in Algorithm 1, that obtains an ASP rule Head ← Body from a query Q expressed in BIOQUERYCNL, via transforming Q into a DRS. We will explain the main steps of the QUERY algorithm by an example, considering query (Q4). Algorithm 1 QUERY(Q) Input: A query Q Output: An ASP rule Head ← Body 1: D := Find the DRS of Q 2: Head := HEAD(D) 3: Body&apos; := BODY(D) 4: Body := POSTPROCESSING(Body&apos;) 5: return Head ← Body 4.1 Transforming a CNL Query into DRS Attempto Controlled English (ACE) text can be converted into Discourse Representation Structures (DRS) (Kamp, 1981) — a variant of the first-order logic that is used for the dynamic interpretation of natural language and systematic translation of natural language into logical form — without any ambiguity, using tools like Attempto Parsing Engine (APE). APE converts ACE text to DRS by an approach similar to (Blackburn and Bos, 2005), as explained in (Fuchs et al., 2008). For instance, APE transforms query (Q4) into the following DRS: 119 Table 1: The Grammar of BIOQUERYCNL QUERY YESNOQUERY |WHQUERY QUESTIONMARK YESNOQUERY DODOESQUERY |ISAREQUERY WHQUERY WHATQUERY |WHICHQUERY DODOESQUERY [ Do |Does ] Type() </context>
</contexts>
<marker>Kamp, 1981</marker>
<rawString>Hans Kamp. 1981. A theory of truth and semantic representation. In J. A. G. Groenendijk, T. M. V. Janssen, and M. B. J. Stokhof, editors, Formal Methods in the Study of Language, volume 1, pages 277–322.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Esther Kaufmann</author>
<author>Abraham Bernstein</author>
<author>Renato Zumstein</author>
</authors>
<title>Querix: A natural language interface to query ontologies based on clarification dialogs.</title>
<date>2006</date>
<booktitle>In Proc. of ISWC.</booktitle>
<contexts>
<context position="4981" citStr="Kaufmann et al., 2006" startWordPosition="771" endWordPosition="775">s the query. This idea is illustrated in Figure 1. Similar approaches of using a CNL for querying ontologies have been investigated in various studies. For instance, (Bernstein et al., 2005) considers queries in the controlled natural language, Attempto Controlled English (ACE) (Attempto, 2008), and transforms them into queries in PQL (Klein and Bernstein, 2004) to be evaluated by a query engine. (Bernstein et al., 2006) presents a system that guides the user to write a query in ACE, and translates the query into SPARQL to be evaluated by the reasoner of JENA (Jena, 2008). On the other hand, (Kaufmann et al., 2006) transforms a given natural language query to a SPARQL query (using the Stanford Parser and WORDNET) to be evaluated by a reasoner like that of JENA. Our work is different from these studies in two ways: we consider queries over biomedical ontologies (thus different forms of queries, and vocabulary), and we transform a query into an ASP program to automate reasoning over a rule layer presented in ASP. Transformations of natural language sentences into ASP has been studied in (Baral et al., 2008) and (Baral et al., 2007). In (Baral et al., 2008), the authors introduce methods to transform some </context>
</contexts>
<marker>Kaufmann, Bernstein, Zumstein, 2006</marker>
<rawString>Esther Kaufmann, Abraham Bernstein, and Renato Zumstein. 2006. Querix: A natural language interface to query ontologies based on clarification dialogs. In Proc. of ISWC.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Klein</author>
<author>Abraham Bernstein</author>
</authors>
<title>Toward highprecision service retrieval.</title>
<date>2004</date>
<journal>IEEE Internet Computing,</journal>
<volume>8</volume>
<issue>1</issue>
<contexts>
<context position="4723" citStr="Klein and Bernstein, 2004" startWordPosition="723" endWordPosition="726">edical queries over some ontologies, and introduce an algorithm to convert a biomedical query expressed in this CNL into a program in ASP. The idea is to automatically compute an answer to the query using methods of (Bodenreider et al., 2008), once the user types the query. This idea is illustrated in Figure 1. Similar approaches of using a CNL for querying ontologies have been investigated in various studies. For instance, (Bernstein et al., 2005) considers queries in the controlled natural language, Attempto Controlled English (ACE) (Attempto, 2008), and transforms them into queries in PQL (Klein and Bernstein, 2004) to be evaluated by a query engine. (Bernstein et al., 2006) presents a system that guides the user to write a query in ACE, and translates the query into SPARQL to be evaluated by the reasoner of JENA (Jena, 2008). On the other hand, (Kaufmann et al., 2006) transforms a given natural language query to a SPARQL query (using the Stanford Parser and WORDNET) to be evaluated by a reasoner like that of JENA. Our work is different from these studies in two ways: we consider queries over biomedical ontologies (thus different forms of queries, and vocabulary), and we transform a query into an ASP pro</context>
</contexts>
<marker>Klein, Bernstein, 2004</marker>
<rawString>Mark Klein and Abraham Bernstein. 2004. Toward highprecision service retrieval. IEEE Internet Computing, 8(1):30–36.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Vladimir Lifschitz</author>
</authors>
<title>Action languages, answer sets and planning. In The Logic Programming Paradigm: a 25-Year Perspective.</title>
<date>1999</date>
<publisher>Springer.</publisher>
<contexts>
<context position="6606" citStr="Lifschitz, 1999" startWordPosition="1056" endWordPosition="1057">in ASP, via Discourse Representation Structures (DRS) (Kamp, 1981). In the rest of the paper, first we briefly discuss ASP with some examples (Section 2). Then we define the grammatical structure of BIOQUERYCNL and give some examples (Section 3). Next, we introduce our algorithm for transforming a BIOQUERYCNL query into an ASP program and explain it by an example (Section 4). We conclude with a discussion of challenges related to the implementation of our algorithm (Section 5) and other related problems that we are working on (Section 6). 2 Answer Set Programming Answer Set Programming (ASP) (Lifschitz, 1999; Marek and Truszczy´nski, 1999; Niemel¨a, 1999; Baral, 2003) is a new knowledge representation and reasoning paradigm which supports representation of defaults, constraints, preferences, aggregates, etc., and provides technologies that allow us to automate reasoning with incomplete information, and to integrate other technologies, like description logics reasoners and Semantic Web technologies. In ASP, knowledge is represented as a “program” (a finite set of “rules”) whose meaning is captured by its models (called “answer sets” (Gelfond and Lifschitz, 1988)). Answer sets for a program can be </context>
</contexts>
<marker>Lifschitz, 1999</marker>
<rawString>Vladimir Lifschitz. 1999. Action languages, answer sets and planning. In The Logic Programming Paradigm: a 25-Year Perspective. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Victor Marek</author>
<author>Mirosław Truszczy´nski</author>
</authors>
<title>Stable models and an alternative logic programming paradigm. In The Logic Programming Paradigm: a 25-Year Perspective.</title>
<date>1999</date>
<publisher>Springer.</publisher>
<marker>Marek, Truszczy´nski, 1999</marker>
<rawString>Victor Marek and Mirosław Truszczy´nski. 1999. Stable models and an alternative logic programming paradigm. In The Logic Programming Paradigm: a 25-Year Perspective. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>MedicalSymptomsSignsDisease</author>
</authors>
<date>2008</date>
<note>http: //www.medicinenet.com/symptoms_and_ signs/article.htm.</note>
<contexts>
<context position="18770" citStr="MedicalSymptomsSignsDisease, 2008" startWordPosition="2891" endWordPosition="2892">se(“Epinephrine”,DIS1), disease_symptom(DIS1,SYM1). With an ASP rule layer over ontologies, and this ASP program, an ASP solver, like DLVHEX (DLVHEX, 2009), returns an answer to query (Q4) . For instance, consider the ASP rule layer, and the gene, disease, drug ontologies of (Bodenreider et al., 2008). The ontologies of (Bodenreider et al., 2008) are obtained from the ontologies PHARMGKB (PharmGKB, 2008), UNIPROT (UniProt, 2008), GENE ONTOLOGY (GO) (GeneOntology, 2008), GENENETWORK database (GeneNetwork, 2008), DRUGBANK (DrugBank, 2008), and the Medical Symptoms and Signs of Disease web page (MedicalSymptomsSignsDisease, 2008). With this rule layer and the ontologies, and the ASP program above, the following is a part of the answer DLVHEX finds to the query above: noisy breathing faster breathing shortness of breath coughing chest tightness wheezing 4.4 Another Example The algorithm discussed above returns the following ASP program for query (Q5): which_genes(GN1) :- 2&lt;=#count{DRG1:drug_gene(DRG1,GN1)}, #count{DIS1:disease_gene(DIS1,GN1)}&lt;=3. Since query (Q5) contains cardinality constraints, the ASP program uses the aggregate #count. More examples of biomedical queries, and the ASP programs generated by our progra</context>
</contexts>
<marker>MedicalSymptomsSignsDisease, 2008</marker>
<rawString>MedicalSymptomsSignsDisease. 2008. http: //www.medicinenet.com/symptoms_and_ signs/article.htm.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ilkka Niemel¨a</author>
</authors>
<title>Logic programs with stable model semantics as a constraint programming paradigm.</title>
<date>1999</date>
<journal>Annals of Mathematics and Artificial Intelligence,</journal>
<volume>25</volume>
<pages>PharmGKB.</pages>
<note>http://www.pharmgkb.org. UniProt.</note>
<marker>Niemel¨a, 1999</marker>
<rawString>Ilkka Niemel¨a. 1999. Logic programs with stable model semantics as a constraint programming paradigm. Annals of Mathematics and Artificial Intelligence, 25. PharmGKB. 2008. http://www.pharmgkb.org. UniProt. 2008. http://www.ebi.uniprot.org/ index.shtml.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>