<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000062">
<title confidence="0.9290715">
The Karamel System and Semitic Languages: Structured Multi-Tiered
Morphology
</title>
<author confidence="0.825761">
Franc¸ois Barth´elemy
</author>
<affiliation confidence="0.4645295">
CNAM-Cedric, Paris, France
INRIA-Alpage, Rocquencourt, France
</affiliation>
<email confidence="0.990881">
francois.barthelemy@cnam.fr
</email>
<sectionHeader confidence="0.997337" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999823615384616">
Karamel is a system for finite-state mor-
phology which is multi-tape and uses a
typed Cartesian product to relate tapes in
a structured way. It implements stati-
cally compiled feature structures. Its lan-
guage allows the use of regular expres-
sions and Generalized Restriction rules to
define multi-tape transducers. Both simul-
taneous and successive application of local
constraints are possible. This system is in-
teresting for describing rich and structured
morphologies such as the morphology of
Semitic languages.
</bodyText>
<sectionHeader confidence="0.999393" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999907464285714">
Karamel is a system for defining and executing
multi-tape finite-state transducers where relation-
ships between tapes are expressed using a tree
structure. This structure is obtained through em-
bedded units, which are used to analyze a tuple of
strings recognized by the transducer. For instance,
the units considered in an example may be affix,
form and sentence.
The system includes a language and an Inte-
grated Development Environment. The language
uses extended regular expressions, computations
and contextual rules. The environment provides a
graphical interface to write and execute finite-state
descriptions.
Karamel has many applications. For Natural
Language Processing, it may be used for morpho-
logical analysis, transliteration, parsing, etc. This
paper is dedicated to the application of Karamel to
the morphological analysis of Semitic languages,
for which both multiple tapes and complex struc-
tures are useful.
Some descriptions of the morphology of
Semitic Languages use several tiers. For instance,
(McCarthy, 1981) uses four tiers, one for prefixes,
one for the root, one for the template (consonant-
vowel pattern) and the last one for the vocaliza-
tion.
Such a multi-tiered description may be im-
plemented using a cascade of 2-tape machines
(Beesley, 1998) or using a multi-tape transducer
where each tier is described by a tape and the sur-
face form by an additional tape. This is the ap-
proach of G. A. Kiraz for the Syriac language (Ki-
raz, 2000). Karamel is designed for the later solu-
tion.
The multi-tape feature is also interesting for de-
scribing related dialects, whenever a great part of
the analysis may be shared. A separate tape is ded-
icated to the surface form in each dialect.
The Semitic Morphology is strongly structured
by the roots. The basis of an analysis is the identi-
fication of the root. Furthermore, several layers of
affixes may be distinguished around the core con-
taining the roots: paradigmatic prefixes; affixes
encoding the person, gender and number; clitics
such as pronouns. This structure is conveniently
defined using Karamel’s units.
In the following section of the paper, we present
Karamel’s language, its theoretical background
and its syntax. Section 3 describe the other as-
pects of the Karamel System: its development en-
vironment, its current state and future evolutions.
Then comes an example of Semitic morphology
written in Karamel, the description of Akkadian
verbal flexion. The last section compares Karamel
to some other systems.
</bodyText>
<sectionHeader confidence="0.948108" genericHeader="method">
2 The Karamel language
</sectionHeader>
<bodyText confidence="0.999910428571429">
The language is based on a subclass of ratio-
nal n-ary relations called multi-grain relations
which is closed under intersection and difference
(Barth´elemy, 2007b). They are defined using ra-
tional expressions extended with a typed Cartesian
product. This operator implements the notion of
unit used to give a tree-structure to tuples of the
</bodyText>
<note confidence="0.95198">
Proceedings of the EACL 2009 Workshop on Computational Approaches to Semitic Languages, pages 10–18,
Athens, Greece, 31 March, 2009. c�2009 Association for Computational Linguistics
</note>
<page confidence="0.997997">
10
</page>
<bodyText confidence="0.988791428571429">
relations. A unit is an inner-node of the structure.
A project is a set of finite-state machine defined
over the same universe: the same alphabet, the
same tape set, the same units. A project begins
with declarations defining this universe. It contin-
ues with an ordered sequence of machine defini-
tions.
The declaration section contains several clauses
including classes, tapes and unit definitions. A
class of symbols is a finite set of symbols. Here
are some examples of class definitions:
class short_v is a, e, i, u;
class long_v is aa, ee, ii, uu;
class vow is a, e, i, u, long_v;
A symbol may belong to several classes. In the
definition of a class, another class name may ap-
pear and is just an abbreviation for all its members.
The class names are also used in regular expres-
sions to denote the disjunction of their members.
The symbols written using several letters and/or
digits, when there is a risk of confusion with a
string of symbols, must be written enclosed by &lt;
and &gt;. For instance, the long a is written aa in the
class definition (long_v) but in a regular expres-
sion, it must be written &lt;aa&gt; because aa denotes
a string of two short vowels. The bracketing with
&lt; and &gt; is also used for special characters such as
the space &lt; &gt;, punctuation marks (e.g. &lt;,&gt;) and
the empty string &lt;&gt;.
A tape is declared with its name and the alpha-
bet of the symbols which may appear on it.
tape dig: &lt;digit&gt;,
fr, en: &lt;letter&gt;|&lt; &gt;|&lt;-&gt;;
The alphabet is defined using a regular expression
made with symbols, classes and length-preserving
operators such as the disjunction and the differ-
ence.
A Karamel unit is a typed Cartesian product.
The type consists in i) a number of components
and ii) the tapes contained by each component. In
the declaration, there is also a default value for
each component.
</bodyText>
<equation confidence="0.7649814">
unit seg is {d: dig = &lt;digit&gt;*;
f: fr = &lt;letter&gt;*;
e: en = &lt;letter&gt;*}
unit num is
{c: dig, fr, en={seg}+}
</equation>
<bodyText confidence="0.974727161290322">
The unit seg (for segment) contains three compo-
nents, each using a single tape. The unit num (for
number) has one component which contains three
tapes (dig, fr and en).
The default value is a non-empty sequence
of units of type seg. Cartesian products are
written in regular expressions as tuples with
the type name followed by the components:
{seg: 2(0?),vingt,twenty}. Compo-
nent names may be used instead of their posi-
tion {seg:e=twenty,f=vingt,d=2(0?)}.
When a component is omitted, the default value
is implied. The notation {seg} (cf. the default
value of the component c in num) is a unit seg
with default values in all the components. Units
may be embedded:
{num:{seg:2,vingt,twenty}
{seg:2,-deux,-two}}
This example is a structured representation of the
triplet (22,vingt-deux,twenty-two).
In Karamel, there are three ways of defining a
finite-state transducer: by a regular expression, by
a computation or by a contextual rule. Regular
expressions use symbols, classes of symbols, ra-
tional operations and standard extensions (for in-
stance, optionality written ?). Furthermore, inter-
section, difference and negation are also available
although these operations are usually not defined
on transducers.
Regular expressions are defined using the
regexp construction:
</bodyText>
<equation confidence="0.7314425">
regexp zero is
{seg: 0,z´ero,(zero|naught)};
{seg: &lt;digit&gt;*-0};
end
</equation>
<bodyText confidence="0.999918882352941">
A regexp contains a non empty sequence of regular
expressions ended with a semicolon. It denotes the
disjunction of these expressions.
The second way of defining a machine is by ap-
plying operators to already defined machines. All
the operators used in regular expressions may ap-
pear in such a computation, but there are some
other operators as well. The first one is the projec-
tion which removes one or several tapes from its
operand. The second one is the external product
which combines a n-ary relation with a language
on a given tape. It is used to apply a transducer
to a given input which is not split in units yet. All
possible partitioning of the input in units is first
computed, and then it is intersected with one tape
of the transducer. The reverse operation is the ex-
ternal projection which extracts a language from a
</bodyText>
<page confidence="0.998558">
11
</page>
<bodyText confidence="0.972762863636364">
relation on a given tape by first applying the sim-
ple projection and then removing unit boundaries.
These two operations are used to transduce a given
possibly non-deterministic input into an output.
let segments=
union(star(non_zero),zero);
The let is followed by an expression in prefixed
notation with the operators written with letters.
The literals are the names of previously defined
machine. In our example, the expression uses the
machines zero defined by the previous regexp
and non_zero (not given here).
The last way for defining a machine consists in
the Generalized Restriction Rules defined in (Yli-
Jyr¨a and Koskenniemi, 2004). Roughly speak-
ing, these rules are a modernized version of clas-
sical Two-Level Rules such as Context Restriction
and Surface Coercion rules (Koskenniemi, 1983).
They also are comparable to the rewrite rules of
Xerox Finite-State Tools (Beesley and Karttunen,
2003), the difference being that rewrite rules are
applied in cascades whereas GR rules may be si-
multaneous.
Contextual rules are defined using three regular
expressions:
gr_rule rzero is
{num}
constraint
{num:seg={seg}*{seg:#0}{seg}*}
=&gt; {num:seg={seg:#0,z´ero}}
end
The first expression defines a universe. All the ex-
pressions in the universe which match the pattern
on the left of the arrow must also match the pat-
tern on the right. The sharp symbol is an auxiliary
symbol used to make sure that the 0 on both sides
is the same occurrence of this symbol. It identi-
fies the center of the contextual rule. For more de-
tails about the semantics of Generalized Restric-
tion rules, see (Yli-Jyr¨a and Koskenniemi, 2004).
Karamel implements non-recursive feature
structures. Feature values are ordinary symbols
and feature structures are typed. The types must
be declared in the declaration section of the de-
scription. Feature Structures may appear any-
where in regular expressions. They are usually put
on one or several specific tapes. They are stati-
cally compiled. Feature Structures are to be used
with caution, because they allow the expression of
long-distance dependencies which are costly and
may lead to a combinatorial explosion. The fea-
ture structure compilation techniques come from
(Barth´elemy, 2007a).
A type is defined as follows:
fstruct Name is
[gen=gender,num=1|2|3]
where gender is a class and 1, 2, 3 are sym-
bols. Each feature is defined with its name and
its domain of values, which is a finite set of sym-
bols defined by a regular expression. A fea-
ture structure of this type is written as follows:
[Name:gen=masc,num=2]. As usual, it is
possible to specify only part of the features and
their order is not important. The type name at
the beginning is mandatory. Feature structures are
compiled using auxiliary symbols which are not
known by the user. The type name denotes a class
of symbols containing all the symbols which may
be used to compile a structure of this type, includ-
ing auxiliary symbols.
Regular expressions and contextual rules may
use variables which take their values in finite set
of symbols. An expression with such a variable
stands for the disjunction of all the possible val-
uation of the variables. Variables are especially
useful to express feature structure unification.
The language offers macros called abbrevia-
tions. An abbreviation is a notation for an already
declared unit where part of the components is de-
fined in the declaration and another part is defined
in the call. Here is an example.
abbrev teen is {d: dig = &lt;digit&gt;;
f: fr =&lt;letter&gt;*;
e: en = &lt;letter&gt;*}
for {seg: 1 @d, @f,@e teen}
In an expression, {teen: 6, seize,six}
is expanded in {seg: 16,seize,sixteen}
before the compilation.
</bodyText>
<sectionHeader confidence="0.975733" genericHeader="method">
3 The Karamel System
</sectionHeader>
<bodyText confidence="0.999742">
The core of the system consists in a compiler writ-
ten in Python which compiles Karamel descrip-
tions into finite-state automata which are inter-
preted as transducers by the system. The com-
piler uses the FSM and Lextools toolkits by AT&amp;T
Research. A Karamel regular expression is first
compiled in the Lextools format, then the Lextools
compiler is called to compile it in FSM binary for-
mat. Some Karamel operations over transducers
</bodyText>
<page confidence="0.993074">
12
</page>
<bodyText confidence="0.999959633333333">
such as the intersection, the union, the concatena-
tion are directly implemented by the correspond-
ing FSM operation on automata. Some other op-
erations such as the two projections and the ex-
ternal product are performed by a script calling a
sequence of FSM computations.
The development environment uses a Graph-
ical User Interface written in HTML, CSS and
Javascript. There are three main subparts: project
management (creation, deletion, import, export,
duplication); project development: creation, dele-
tion, renaming, reordering, checking, compilation
of a machine; machine execution, with optional in-
troduction of run-time input, filtering of the result,
projection on one or several tapes.
A dependency graph is maintained in order to
ensure that a change in one machine is taken into
account in all the machines which depend on it.
For instance if there is the following definition:
let m3=union(m1,m2);, any change in m1
implies a recompilation of m3. This recompila-
tion is not necessarily immediate. A status is asso-
ciated to each machine. The change in m1 results
in a change in the statuses of m1 and m3.
At the moment, the execution of a machine is
possible only through the GUI, using a browser.
The development of a C++ or Python function to
interpret the FSM machine with the Karamel se-
mantics is not a difficult task, but it is still to be
done. Another weakness of the current version
of the system is the type-checking which is not
fully implemented. The type system is simple and
the language is strongly typed, so every type error
should be found at compile time. It is not the case
yet.
Karamel will be distributed to a few kind beta-
testers in a near future. We plan to add some test
facilities to the environment. At medium term, a
migration from FSM to openFST (Allauzen et al.,
2007) and a distribution under the LGPL license
are envisaged.
So far, Karamel has been used for morphology.
A morphological analyzer for the Akkadian verb is
presented in the next section. It is a medium size
grammar. Another project describes the French
morphology. It is the translation in Karamel of
a grammar developed for the MMORPH system
(Petitpierre and Russel, 1995). The grammar has
a large coverage. It has been tested with a toy
lexicon only. The other domain of application ex-
plored so far is the transliteration domain. There
is a multilingual description of numbers that re-
lates the notation with digits to a written form in
several languages (French, English, Finnish). A
tape is devoted to each language, a tape to the dig-
its and several tapes for feature structures, some
of which are language specific. Another project
transliterates Egyptian hieroglyphs into the Latin
alphabet, using an intermediate representation on
a third tape.
</bodyText>
<sectionHeader confidence="0.927955" genericHeader="method">
4 An example: the Akkadian verb
</sectionHeader>
<bodyText confidence="0.998970789473684">
In this section, we present an application of
Karamel to Semitic morphology, namely a de-
scription of Akkadian verbal forms.
Akkadian is the language of the ancient
Mesopotamia. It was written in cuneiform, from
around 2500 B.C. up to the first century B.C. It
is the main representative of the eastern branch of
Semitic languages. It is divided in seven main di-
alects with many local variations. Its verbal mor-
phology is a typical semitic one, with a great num-
ber of triliteral roots, some stems with usual flex-
ion (prefixation, reduplication, infixation, vocal-
ization). There are two infixes, t and tn. Their
presence is almost orthogonal with the presence of
a stem prefix and the reduplication of the second
radical.
The description of the morphology in Karamel
is based on a two-level structure. The first level
separates verbal forms in three layers:
</bodyText>
<listItem confidence="0.995972555555556">
• a core, which contains the root, its vocaliza-
tion, and also the prefixes which depend on
the stem and/or aspect, infixes and gemina-
tion.
• personal affixes (prefixes and suffixes), which
encode the person, the number, the gender
and the case (when relevant).
• the clitics: enclitic pronoun and proclitic par-
ticles.
</listItem>
<bodyText confidence="0.999224">
In the following, these units will be called big
grains.
The second level is used for the core only, which
is divided in smaller parts using the two following
criteria: firstly, a unit must be significant in the
analysis; secondly, it is determined by a set of fea-
tures in such a way that no smaller part is uniquely
determined by a subset of these features and no
greater part is determined by the same set of fea-
tures. Such a component is invariable for a given
</bodyText>
<page confidence="0.997953">
13
</page>
<bodyText confidence="0.990321541666667">
value of its features, except some surface transfor-
mations.
Following the proposition of (Malbran-Labat,
2001), three kinds of vowels are distinguished.
The first kind of vowel depends on the stem and
the aspect. They are called aspectual vowels. The
second kind, called lexical vowel depends on the
stem, the aspect and a lexical category attached
to the root. The third kind of vowels, the sup-
port vowels are not related to morphological fea-
tures. They are necessary to pronounce and/or
write1 the form. The first two kinds of vow-
els are systematically preserved in weak forms
whereas support vowels disappear in weak con-
sonant neighborhood. Support vowel are member
of the small grain containing the preceding conso-
nant whereas lexical and aspectual vowels consti-
tute small grains.
The different subparts of the core and their fea-
tures are given in figure 1. They will be called
small grains.
The figure 2 gives some extracts of the project.
It begins with the declaration section. There is a
class of all letters, subclasses of consonants, weak
consonants, strong consonants, vowels, long vow-
els, short vowels. There is also a class for each
feature domain. Several types of feature structures
are defined: one for each kind of big grain (core,
personal affix, pronoun, enclitic particle); a unique
type for all the kinds of small grains.
The description has five tapes. The first tape
contains the feature structures associated with big
grains, the second tape contains the feature struc-
tures covering small grains. The third tape con-
tains a canonical form of each grain. It corre-
spond to the lexical form of traditional Two-Level
grammars. The last two tapes contain the surface
forms respectively in the Babylonian and the As-
syrian dialects, which are slightly different, mostly
in their vocalization.
Here is an example of structured analysis of the
form iptaras¯u.
pers core pers
pref suff
rad stem rad lex rad
1 infix 2 vowel 3
i p ta r a s u¯
The tape scheme does not correspond to a multi-
</bodyText>
<footnote confidence="0.939588">
1The cuneiform writing is syllabic. It is impossible to
write a consonant without a vowel immediately before or af-
ter it.
</footnote>
<bodyText confidence="0.999863254901961">
tiered analysis. There are several reasons for this.
The first one comes from the Akkadian language.
The stems and aspects are not described by pat-
terns but divided in smaller analysis units, in par-
ticular stem analysis uses the two orthogonal di-
mensions called here stem1 and stem2: the first
one notes stem gemination and prefixation and the
later, infixation. A stem is a pair (stem1,stem2).
The vocalization does not require patterns of two
vowels separated by the middle radical, but in
most cases a pattern of only one vowel.
Another reason comes from the Karamel lan-
guage: the information usually encoded in tiers
appears in the unit types. For instance the infor-
mation about the root tier appears in small grains
of type radical. Similarly, the vocalization appears
in the small grains of types aspect vowel and lex-
ical vowel. The rich tree structure is sufficient to
express clearly the analysis.
The morphotactics of the language is described
as the sum of local constraints. It involves only
the first three tapes. The elementary units, namely
small grains and all the big grains but the core,
are described separately. For instance, the ma-
chine aspect_infix (cf. figure 2) distin-
guishes two cases: if the feature aspect has
perfect as value, then there is a small grain of
type ifx_parf containing the infix ta; if the
feature aspect has another value, then there is
no grain of type ifx_parf in the core. The two
cases are given using two different regular expres-
sions. For more complex small grains, more cases
are to be described, up to 13 for the lexical vowels
which have different colors and length depending
on 4 features.
Two finite-state machines describe the order of
respectively small and big grains. The one for
small grains called core_morphotactics is
sketched in the figure.
The lexicon is given using a macro called
lexent. A lexent (for lexical entry) tuple
looks like a usual lexicon entry, with only lexi-
cal information, although it is a regular expression
denoting a complete core, with its prefix, infixes,
vowels, etc. The lexicon finite state machine
may be directly intersected with the sg_order
machine previously defined and all the other con-
straints in order to obtain a machine describing all
the possible cores build on the roots given in the
lexicon.
The computation of the two surface forms for
</bodyText>
<page confidence="0.997863">
14
</page>
<table confidence="0.997888555555556">
subpart stem1 stem2 aspect class root example
aspect prefix X X X X muparrisu
stem prefix X X ˇsuprusu
radical X iprus
core infix iptaras
stem1 gemination uparras
aspect gemination X X X iparras
aspect vowel X X X uparris
lexical vowel X X X X iprus
</table>
<figureCaption confidence="0.999186">
Figure 1: Subparts and features
</figureCaption>
<bodyText confidence="0.999845913043478">
the two dialects is performed by a set of con-
straints written using regular expressions and con-
textual rules. They relate the lexical form and one
or both surface forms. The features are used in
some of them.
Rules are used for phenomena which may occur
several times in a given form. For instance, the
deletion of support vowels before another vowel
may appear in several places: before lexical and
aspectual vowels, but also when a weak consonant
disappears or changes to a vowel.
In many cases however, surface transformation
occur only in one given place of a form and the use
of a rule is not necessary. The tree structure helps
in characterizing this place. The example given
in the figure is the coloration of the first vowel in
some stems (II and III).
The grammar presently covers strong forms, 1-
weak verbs and part of 2-weak and 3-weak verbs.
Verbs with two or three weak consonants2 and
quadriliteral roots are not covered at all. The de-
scription uses 27 regexp clauses, 22 let and 6
rules.
</bodyText>
<subsectionHeader confidence="0.999882">
4.1 Comparisons with other systems
</subsectionHeader>
<bodyText confidence="0.999984769230769">
There are many systems for writing finite-state
machines. In this section we compare Karamel
with some of them which are specialized in mor-
phological descriptions.
The most popular system is probably the Xerox
Finite State Tool (Beesley and Karttunen, 2003).
It has been used, among others, for the descrip-
tion of Arabic morphology (Beesley, 1998). The
interdigitation is handled using a compile-replace
process using the replace operator (Karttunen and
Beesley, 2000) (Karttunen, 1995).
The computational model is a sequential one,
where two-tape transducers are merged using the
</bodyText>
<footnote confidence="0.972582">
2There is a Akkadian verb with 3 weak consonants as root.
</footnote>
<bodyText confidence="0.995167461538462">
composition operation. The descriptions are ori-
ented, with an input and an output, but the trans-
duction has not to be deterministic and the ma-
chines are invertible. The strings are not struc-
tured, but some structure may be marked using
auxiliary symbols inserted when necessary by the
user.
In order to fulfill the constraints that there are
only two tapes, grammars often put heterogeneous
data on a tape. For instance, the features and the
lexical representations are put together on the in-
put tape. Intermediate forms in the cascade often
contain a mix of lexical and surface representa-
tions.
There are no feature structures in XFST, but fea-
tures written as ordinary symbols. The scope and
the unifications are written by the user.
Karamel is more declarative than XFST. Infor-
mation of different natures are put on different
tapes. Abstract feature structures are available.
Their compilation and the unifications are auto-
mated. On the other hand, XFST is more efficient.
The structure information is put only where neces-
sary.
XFST is distributed under a commercial license.
The system MAGEAD is another system of
finite-state morphology developed for Arabic di-
alects (Habash and Rambow, 2006). It follows the
multi-tape approach proposed by George Anton
Kiraz for the Syriac language (Kiraz, 2000). It has
a rule-based language following the principles of
(Grimley-Evans et al., 1996) in which a notion of
partition splits forms in a sequence of units com-
parable to Karamel’s units. But in this approach,
there is only one kind of unit which relates all the
tapes. Like Karamel, MAGEAD is a layer above
Lextools and FSM. The system is not distributed
and its description in published papers is not very
detailed.
</bodyText>
<page confidence="0.982167">
15
</page>
<sectionHeader confidence="0.401852" genericHeader="evaluation">
Declarations
</sectionHeader>
<bodyText confidence="0.73119972">
class vowel is a, e, i, u, aa, ee, ii, uu;
class cons is b, d, g, h, ...
class num is sing, dual, plur;
class aspect is present, preterit, perfect, ...
...
fstruct fspers is [asp=aspect,pers=pers,num=num,gen=gen]
fstruct fscore is [stem1=stem1,stem2=stem2,asp=aspect,lex=lex]
...
tape lex: letter, bab: letter, assy: letter, sg: fssg,
bg : fspers|fscore|fsclit;
unit sgrain is {sg: sg = [fssg]; lex: lex = &lt;letter&gt;*,
bab: bab =&lt;letter&gt;*, assy: assy = &lt;letter&gt;*}
unit core is {bg: bg = [fscore];
smallg: sg, lex, bab, assy = {sgrain}* }
...
abbrev sgi is {r1: bg = [fscore]; r2: sg = [fssg];
r3: lex = &lt;letter&gt;*}
for {core: @r1, {sgrain}* {sgrain: @r2, @r3} {sgrain}* }
abbrev lexent is {cfs: bg = [fscore]; fst: lex = &lt;cons&gt;;
snd: lex = &lt;cons&gt;; thd: lex = &lt;cons&gt;}
for {core: @cfs, {sgrain: [fssg:typ=typ-rad]}*
{sgrain: [fssg:typ=rad], @fst} {sgrain: [fssg:typ=typ-rad]}*
{sgrain: [fssg:typ=rad], @snd} {sgrain: [fssg:typ=typ-rad]}*
{sgrain: [fssg:typ=rad], @thd} }
Small grains morphotactics
</bodyText>
<equation confidence="0.6552345">
regexp aspect_infix is
{sgi: [fscore:asp=perfect],[fssg:typ=ifx_parf], ta};
{core: [fscore:asp=aspect-perfect],
{sgrain: [fssg:typ=typ-ifx_parf]}* };
end
...
regexp small_grain_order is
{core: smallg=
{sgrain: [fssg:typ=asp_pref]}? {sgrain: [fssg:typ=rad]}
{sgrain: [fssg:typ=ifx_parf]}? {sgrain: [fssg:typ=ifx_parf]}?
</equation>
<bodyText confidence="0.73283775">
...
let core_morphotactics=intersect(aspect_infix,stem_gemination,
...,small_grain_order);
regexp lexicon is
{lexent: [fscore:lex=a_u,stem1=I|II|IV],p,r,s};
{lexent: [fscore:lex=a,stem1=I|III],s.,b,t};
...
let actual_cores=intersect(core_morphotactics,lexicon);
</bodyText>
<figureCaption confidence="0.98367">
Figure 2: extracts from the Akkadian project
</figureCaption>
<page confidence="0.781319">
16
</page>
<figure confidence="0.992373388888889">
Surface transformations
gr_rule delete_support_vowels is
{core}
constraint
{core: smallg= {sgrain}*
#{sgrain: lex=&lt;letter&gt;+&lt;vowel&gt;,bab=&lt;letter&gt;&lt;cons&gt;}
{sgrain}* }
=&gt;
{core: smallg= {sgrain}* #{sgrain}
{sgrain: bab=&lt;&gt;}? {sgrain: lex=&lt;vowel&gt;} {sgrain}*}
end
regexp color_u is
{core: [fscore:stem1=II|III],
{sgrain:lex=&lt;cons&gt;?&lt;vowel&gt;,bab=&lt;cons&gt;?u}{sgrain}*};
{core: [fscore:stem1=I|IV],
{sgrain:lex=&lt;cons&gt;?&lt;vowel&gt;,bab=&lt;cons&gt;?(&lt;vowel&gt;-u)}
{sgrain}*};
end
</figure>
<figureCaption confidence="0.999897">
Figure 3: extracts from the Akkadian project
</figureCaption>
<bodyText confidence="0.99994484375">
The main difference is that MAGEAD has only
one level of structure using only one type of Carte-
sian Products. Another difference is that the two
systems use different kinds of contextual rules.
The rules differ both by their syntax and their se-
mantics. Furthermore, contextual rules are the
main syntactic construction in MAGEAD whereas
Karamel uses also regular expressions.
MMORPH is another system of partition-based
morphology based on the work by Pulman and
Hepple (Pulman and Hepple, 1993). There are two
parts in a description: first, the morphotactics is
described using a Unification Grammar where the
terminals are lexical affixes and the non-terminals
are feature structures; transformation rules relate
the lexical and surface levels. The features are flat.
Feature structures are evaluated dynamically by a
unification machine.
Karamel statically compiles Feature Structures
and their unification into finite-state transducers.
This is efficient and part of the structures are
shared. On the other hand, the grammar of fea-
ture structures must be regular and there is a risk
of combinatorial explosion. MMORPH uses two
kinds of units: one relates affixes to Feature Struc-
tures, the other relates small parts of lexical and
surface forms (typically, substrings of length 0
to 2). Karamel uses a richer and more flexible
structuration. Furthermore, the number of tapes is
fixed in MMORPH and user defined in Karamel.
MMORPH is distributed under the GPL license. It
is not maintained any more.
</bodyText>
<sectionHeader confidence="0.999656" genericHeader="conclusions">
5 Conclusion
</sectionHeader>
<bodyText confidence="0.999989">
In this paper, we have emphasized the application
of Karamel to morphological descriptions. The
multiplicity of tapes is useful at all the levels of
the analysis. The abstract representation typically
uses feature structures. Several tapes are to be
used if different kinds of feature structures have
different spans with respect to the surface form. At
the intermediate level, several tapes may be used
by a multi-tiered analysis. It is not the case in our
example, but Karamel is compatible with an ap-
proach where each tier is put on a different tape
(Kiraz, 2000). The surface level may also use sev-
eral tapes. In our example, two tapes are used for
two different dialects. It is also possible to use sev-
eral tapes for several writings of the surface forms,
for instance, a standard written form, a phonetic
representation using the International Phonetic Al-
phabet (IPA) and a transcription in Latin alphabet.
The other main feature of Karamel is to use em-
bedded units to relate the different tapes. This is
useful to define the scope of feature structure and
to distinguish several parts in the forms.
</bodyText>
<page confidence="0.998693">
17
</page>
<sectionHeader confidence="0.998343" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999484419354839">
Cyril Allauzen, Michael Riley, Johan Schalkwyk, Wo-
jciech Skut, and Mehryar Mohri. 2007. Openfst:
A general and efficient weighted finite-state trans-
ducer library. In Implementation and Application
of Automata, 12th International Conference, CIAA,
volume 4783 of LNC, pages 11–23, Prague, Czech
Republic.
Franc¸ois Barth´elemy. 2007a. Finite-state compilation
of feature structures for two-level morphology. In
International Workshop on Finite State Methods in
Natural Language Processing (FSMNLP), Potsdam,
Germany.
Franc¸ois Barth´elemy. 2007b. Multi-grain relations. In
Implementation and Application of Automata, 12th
International Conference (CIAA), pages 243–252,
Prague, Czech Republic.
Kenneth R. Beesley and Lauri Karttunen. 2003. Finite
State Morphology. CSLI Publications.
Kenneth R. Beesley. 1998. Arabic morphology using
only finite-state operations.
Edmund Grimley-Evans, George Kiraz, and Stephen
Pulman. 1996. Compiling a partition-based two-
level formalism. In COLING, pages 454–459,
Copenhagen, Denmark.
Nizar Habash and Owen Rambow. 2006. Magead: a
morphological analyzer and generator for the Ara-
bic dialects. In ACL: Proceedings of the 21st Inter-
national Conference on Computational Linguistics
and the 44th annual meeting of the Association for
Computational Linguistics, pages 681–688.
Lauri Karttunen and Kenneth R. Beesley. 2000.
Finite-state non-concatenative morphotactics. In
Fifth Workshop of the ACL Special Interest Group
in Computational Phonology, pages 1–12, Luxem-
bourg (Luxembourg).
Lauri Karttunen. 1995. The replace operator. In ACL-
95, pages 16–23, Boston, Massachusetts. Associa-
tion for Computational Linguistics.
George Anton Kiraz. 2000. Multitiered nonlinear
morphology using multitape finite automata: a case
study on Syriac and Arabic. Comput. Linguist.,
26(1):77–105.
Kimmo Koskenniemi. 1983. Two-level model for
morphological analysis. In IJCAI-83, pages 683–
685, Karlsruhe, Germany.
Florence Malbran-Labat. 2001. Manuel de langue
akkadienne. Publications de l’institut Orientaliste
de Louvain (50), Peeters.
John J. McCarthy. 1981. A prosodic theory of noncon-
catenative morphology. Linguistic Inquiry, 12:373–
418.
D. Petitpierre and G. Russel. 1995. Mmorph: the mul-
tex morphology program. Technical report, ISSCO
technical report, Geneva, Switzerland.
S. Pulman and M. Hepple. 1993. A feature-based for-
malism for two-level phonology. Computer Speech
and Language, 7.
Anssi Mikael Yli-Jyr¨a and Kimmo Koskenniemi.
2004. Compiling contextual restrictions on strings
into finite-state automata. In Proceedings of the
Eindhoven FASTAR Days 2004 (September 3–4),
Eindhoven, The Netherlands, December.
</reference>
<page confidence="0.999292">
18
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.171970">
<title confidence="0.979944">The Karamel System and Semitic Languages: Structured Multi-Tiered</title>
<author confidence="0.615842">Morphology</author>
<affiliation confidence="0.279345">CNAM-Cedric, Paris,</affiliation>
<address confidence="0.515055">INRIA-Alpage, Rocquencourt,</address>
<email confidence="0.996935">francois.barthelemy@cnam.fr</email>
<abstract confidence="0.994025">Karamel is a system for finite-state morphology which is multi-tape and uses a typed Cartesian product to relate tapes in a structured way. It implements statically compiled feature structures. Its language allows the use of regular expressions and Generalized Restriction rules to define multi-tape transducers. Both simultaneous and successive application of local constraints are possible. This system is interesting for describing rich and structured morphologies such as the morphology of Semitic languages.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Cyril Allauzen</author>
<author>Michael Riley</author>
<author>Johan Schalkwyk</author>
<author>Wojciech Skut</author>
<author>Mehryar Mohri</author>
</authors>
<title>Openfst: A general and efficient weighted finite-state transducer library.</title>
<date>2007</date>
<booktitle>In Implementation and Application of Automata, 12th International Conference, CIAA,</booktitle>
<volume>4783</volume>
<pages>11--23</pages>
<location>Prague, Czech Republic.</location>
<contexts>
<context position="13737" citStr="Allauzen et al., 2007" startWordPosition="2232" endWordPosition="2235">e GUI, using a browser. The development of a C++ or Python function to interpret the FSM machine with the Karamel semantics is not a difficult task, but it is still to be done. Another weakness of the current version of the system is the type-checking which is not fully implemented. The type system is simple and the language is strongly typed, so every type error should be found at compile time. It is not the case yet. Karamel will be distributed to a few kind betatesters in a near future. We plan to add some test facilities to the environment. At medium term, a migration from FSM to openFST (Allauzen et al., 2007) and a distribution under the LGPL license are envisaged. So far, Karamel has been used for morphology. A morphological analyzer for the Akkadian verb is presented in the next section. It is a medium size grammar. Another project describes the French morphology. It is the translation in Karamel of a grammar developed for the MMORPH system (Petitpierre and Russel, 1995). The grammar has a large coverage. It has been tested with a toy lexicon only. The other domain of application explored so far is the transliteration domain. There is a multilingual description of numbers that relates the notati</context>
</contexts>
<marker>Allauzen, Riley, Schalkwyk, Skut, Mohri, 2007</marker>
<rawString>Cyril Allauzen, Michael Riley, Johan Schalkwyk, Wojciech Skut, and Mehryar Mohri. 2007. Openfst: A general and efficient weighted finite-state transducer library. In Implementation and Application of Automata, 12th International Conference, CIAA, volume 4783 of LNC, pages 11–23, Prague, Czech Republic.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Franc¸ois Barth´elemy</author>
</authors>
<title>Finite-state compilation of feature structures for two-level morphology.</title>
<date>2007</date>
<booktitle>In International Workshop on Finite State Methods in Natural Language Processing (FSMNLP),</booktitle>
<location>Potsdam, Germany.</location>
<marker>Barth´elemy, 2007</marker>
<rawString>Franc¸ois Barth´elemy. 2007a. Finite-state compilation of feature structures for two-level morphology. In International Workshop on Finite State Methods in Natural Language Processing (FSMNLP), Potsdam, Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Franc¸ois Barth´elemy</author>
</authors>
<title>Multi-grain relations.</title>
<date>2007</date>
<booktitle>In Implementation and Application of Automata, 12th International Conference (CIAA),</booktitle>
<pages>243--252</pages>
<location>Prague, Czech Republic.</location>
<marker>Barth´elemy, 2007</marker>
<rawString>Franc¸ois Barth´elemy. 2007b. Multi-grain relations. In Implementation and Application of Automata, 12th International Conference (CIAA), pages 243–252, Prague, Czech Republic.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth R Beesley</author>
<author>Lauri Karttunen</author>
</authors>
<title>Finite State Morphology.</title>
<date>2003</date>
<publisher>CSLI Publications.</publisher>
<contexts>
<context position="8743" citStr="Beesley and Karttunen, 2003" startWordPosition="1399" endWordPosition="1402">n in prefixed notation with the operators written with letters. The literals are the names of previously defined machine. In our example, the expression uses the machines zero defined by the previous regexp and non_zero (not given here). The last way for defining a machine consists in the Generalized Restriction Rules defined in (YliJyr¨a and Koskenniemi, 2004). Roughly speaking, these rules are a modernized version of classical Two-Level Rules such as Context Restriction and Surface Coercion rules (Koskenniemi, 1983). They also are comparable to the rewrite rules of Xerox Finite-State Tools (Beesley and Karttunen, 2003), the difference being that rewrite rules are applied in cascades whereas GR rules may be simultaneous. Contextual rules are defined using three regular expressions: gr_rule rzero is {num} constraint {num:seg={seg}*{seg:#0}{seg}*} =&gt; {num:seg={seg:#0,z´ero}} end The first expression defines a universe. All the expressions in the universe which match the pattern on the left of the arrow must also match the pattern on the right. The sharp symbol is an auxiliary symbol used to make sure that the 0 on both sides is the same occurrence of this symbol. It identifies the center of the contextual rule</context>
<context position="22401" citStr="Beesley and Karttunen, 2003" startWordPosition="3705" endWordPosition="3708">example given in the figure is the coloration of the first vowel in some stems (II and III). The grammar presently covers strong forms, 1- weak verbs and part of 2-weak and 3-weak verbs. Verbs with two or three weak consonants2 and quadriliteral roots are not covered at all. The description uses 27 regexp clauses, 22 let and 6 rules. 4.1 Comparisons with other systems There are many systems for writing finite-state machines. In this section we compare Karamel with some of them which are specialized in morphological descriptions. The most popular system is probably the Xerox Finite State Tool (Beesley and Karttunen, 2003). It has been used, among others, for the description of Arabic morphology (Beesley, 1998). The interdigitation is handled using a compile-replace process using the replace operator (Karttunen and Beesley, 2000) (Karttunen, 1995). The computational model is a sequential one, where two-tape transducers are merged using the 2There is a Akkadian verb with 3 weak consonants as root. composition operation. The descriptions are oriented, with an input and an output, but the transduction has not to be deterministic and the machines are invertible. The strings are not structured, but some structure ma</context>
</contexts>
<marker>Beesley, Karttunen, 2003</marker>
<rawString>Kenneth R. Beesley and Lauri Karttunen. 2003. Finite State Morphology. CSLI Publications.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth R Beesley</author>
</authors>
<title>Arabic morphology using only finite-state operations.</title>
<date>1998</date>
<contexts>
<context position="1996" citStr="Beesley, 1998" startWordPosition="289" endWordPosition="290">l Language Processing, it may be used for morphological analysis, transliteration, parsing, etc. This paper is dedicated to the application of Karamel to the morphological analysis of Semitic languages, for which both multiple tapes and complex structures are useful. Some descriptions of the morphology of Semitic Languages use several tiers. For instance, (McCarthy, 1981) uses four tiers, one for prefixes, one for the root, one for the template (consonantvowel pattern) and the last one for the vocalization. Such a multi-tiered description may be implemented using a cascade of 2-tape machines (Beesley, 1998) or using a multi-tape transducer where each tier is described by a tape and the surface form by an additional tape. This is the approach of G. A. Kiraz for the Syriac language (Kiraz, 2000). Karamel is designed for the later solution. The multi-tape feature is also interesting for describing related dialects, whenever a great part of the analysis may be shared. A separate tape is dedicated to the surface form in each dialect. The Semitic Morphology is strongly structured by the roots. The basis of an analysis is the identification of the root. Furthermore, several layers of affixes may be dis</context>
<context position="22491" citStr="Beesley, 1998" startWordPosition="3722" endWordPosition="3723"> presently covers strong forms, 1- weak verbs and part of 2-weak and 3-weak verbs. Verbs with two or three weak consonants2 and quadriliteral roots are not covered at all. The description uses 27 regexp clauses, 22 let and 6 rules. 4.1 Comparisons with other systems There are many systems for writing finite-state machines. In this section we compare Karamel with some of them which are specialized in morphological descriptions. The most popular system is probably the Xerox Finite State Tool (Beesley and Karttunen, 2003). It has been used, among others, for the description of Arabic morphology (Beesley, 1998). The interdigitation is handled using a compile-replace process using the replace operator (Karttunen and Beesley, 2000) (Karttunen, 1995). The computational model is a sequential one, where two-tape transducers are merged using the 2There is a Akkadian verb with 3 weak consonants as root. composition operation. The descriptions are oriented, with an input and an output, but the transduction has not to be deterministic and the machines are invertible. The strings are not structured, but some structure may be marked using auxiliary symbols inserted when necessary by the user. In order to fulfi</context>
</contexts>
<marker>Beesley, 1998</marker>
<rawString>Kenneth R. Beesley. 1998. Arabic morphology using only finite-state operations.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Edmund Grimley-Evans</author>
<author>George Kiraz</author>
<author>Stephen Pulman</author>
</authors>
<title>Compiling a partition-based twolevel formalism.</title>
<date>1996</date>
<booktitle>In COLING,</booktitle>
<pages>454--459</pages>
<location>Copenhagen, Denmark.</location>
<contexts>
<context position="24171" citStr="Grimley-Evans et al., 1996" startWordPosition="3987" endWordPosition="3990">e than XFST. Information of different natures are put on different tapes. Abstract feature structures are available. Their compilation and the unifications are automated. On the other hand, XFST is more efficient. The structure information is put only where necessary. XFST is distributed under a commercial license. The system MAGEAD is another system of finite-state morphology developed for Arabic dialects (Habash and Rambow, 2006). It follows the multi-tape approach proposed by George Anton Kiraz for the Syriac language (Kiraz, 2000). It has a rule-based language following the principles of (Grimley-Evans et al., 1996) in which a notion of partition splits forms in a sequence of units comparable to Karamel’s units. But in this approach, there is only one kind of unit which relates all the tapes. Like Karamel, MAGEAD is a layer above Lextools and FSM. The system is not distributed and its description in published papers is not very detailed. 15 Declarations class vowel is a, e, i, u, aa, ee, ii, uu; class cons is b, d, g, h, ... class num is sing, dual, plur; class aspect is present, preterit, perfect, ... ... fstruct fspers is [asp=aspect,pers=pers,num=num,gen=gen] fstruct fscore is [stem1=stem1,stem2=stem2</context>
</contexts>
<marker>Grimley-Evans, Kiraz, Pulman, 1996</marker>
<rawString>Edmund Grimley-Evans, George Kiraz, and Stephen Pulman. 1996. Compiling a partition-based twolevel formalism. In COLING, pages 454–459, Copenhagen, Denmark.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Nizar Habash</author>
<author>Owen Rambow</author>
</authors>
<title>Magead: a morphological analyzer and generator for the Arabic dialects.</title>
<date>2006</date>
<booktitle>In ACL: Proceedings of the 21st International Conference on Computational Linguistics and the 44th annual meeting of the Association for Computational Linguistics,</booktitle>
<pages>681--688</pages>
<contexts>
<context position="23979" citStr="Habash and Rambow, 2006" startWordPosition="3958" endWordPosition="3961">urface representations. There are no feature structures in XFST, but features written as ordinary symbols. The scope and the unifications are written by the user. Karamel is more declarative than XFST. Information of different natures are put on different tapes. Abstract feature structures are available. Their compilation and the unifications are automated. On the other hand, XFST is more efficient. The structure information is put only where necessary. XFST is distributed under a commercial license. The system MAGEAD is another system of finite-state morphology developed for Arabic dialects (Habash and Rambow, 2006). It follows the multi-tape approach proposed by George Anton Kiraz for the Syriac language (Kiraz, 2000). It has a rule-based language following the principles of (Grimley-Evans et al., 1996) in which a notion of partition splits forms in a sequence of units comparable to Karamel’s units. But in this approach, there is only one kind of unit which relates all the tapes. Like Karamel, MAGEAD is a layer above Lextools and FSM. The system is not distributed and its description in published papers is not very detailed. 15 Declarations class vowel is a, e, i, u, aa, ee, ii, uu; class cons is b, d, </context>
</contexts>
<marker>Habash, Rambow, 2006</marker>
<rawString>Nizar Habash and Owen Rambow. 2006. Magead: a morphological analyzer and generator for the Arabic dialects. In ACL: Proceedings of the 21st International Conference on Computational Linguistics and the 44th annual meeting of the Association for Computational Linguistics, pages 681–688.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
<author>Kenneth R Beesley</author>
</authors>
<title>Finite-state non-concatenative morphotactics.</title>
<date>2000</date>
<booktitle>In Fifth Workshop of the ACL Special Interest Group in Computational Phonology,</booktitle>
<pages>1--12</pages>
<contexts>
<context position="22612" citStr="Karttunen and Beesley, 2000" startWordPosition="3736" endWordPosition="3739">weak consonants2 and quadriliteral roots are not covered at all. The description uses 27 regexp clauses, 22 let and 6 rules. 4.1 Comparisons with other systems There are many systems for writing finite-state machines. In this section we compare Karamel with some of them which are specialized in morphological descriptions. The most popular system is probably the Xerox Finite State Tool (Beesley and Karttunen, 2003). It has been used, among others, for the description of Arabic morphology (Beesley, 1998). The interdigitation is handled using a compile-replace process using the replace operator (Karttunen and Beesley, 2000) (Karttunen, 1995). The computational model is a sequential one, where two-tape transducers are merged using the 2There is a Akkadian verb with 3 weak consonants as root. composition operation. The descriptions are oriented, with an input and an output, but the transduction has not to be deterministic and the machines are invertible. The strings are not structured, but some structure may be marked using auxiliary symbols inserted when necessary by the user. In order to fulfill the constraints that there are only two tapes, grammars often put heterogeneous data on a tape. For instance, the feat</context>
</contexts>
<marker>Karttunen, Beesley, 2000</marker>
<rawString>Lauri Karttunen and Kenneth R. Beesley. 2000. Finite-state non-concatenative morphotactics. In Fifth Workshop of the ACL Special Interest Group in Computational Phonology, pages 1–12, Luxembourg (Luxembourg).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
</authors>
<title>The replace operator.</title>
<date>1995</date>
<booktitle>In ACL95,</booktitle>
<pages>16--23</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<location>Boston, Massachusetts.</location>
<contexts>
<context position="22630" citStr="Karttunen, 1995" startWordPosition="3740" endWordPosition="3741">eral roots are not covered at all. The description uses 27 regexp clauses, 22 let and 6 rules. 4.1 Comparisons with other systems There are many systems for writing finite-state machines. In this section we compare Karamel with some of them which are specialized in morphological descriptions. The most popular system is probably the Xerox Finite State Tool (Beesley and Karttunen, 2003). It has been used, among others, for the description of Arabic morphology (Beesley, 1998). The interdigitation is handled using a compile-replace process using the replace operator (Karttunen and Beesley, 2000) (Karttunen, 1995). The computational model is a sequential one, where two-tape transducers are merged using the 2There is a Akkadian verb with 3 weak consonants as root. composition operation. The descriptions are oriented, with an input and an output, but the transduction has not to be deterministic and the machines are invertible. The strings are not structured, but some structure may be marked using auxiliary symbols inserted when necessary by the user. In order to fulfill the constraints that there are only two tapes, grammars often put heterogeneous data on a tape. For instance, the features and the lexic</context>
</contexts>
<marker>Karttunen, 1995</marker>
<rawString>Lauri Karttunen. 1995. The replace operator. In ACL95, pages 16–23, Boston, Massachusetts. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>George Anton Kiraz</author>
</authors>
<title>Multitiered nonlinear morphology using multitape finite automata: a case study on Syriac and Arabic.</title>
<date>2000</date>
<journal>Comput. Linguist.,</journal>
<volume>26</volume>
<issue>1</issue>
<contexts>
<context position="2186" citStr="Kiraz, 2000" startWordPosition="326" endWordPosition="328">languages, for which both multiple tapes and complex structures are useful. Some descriptions of the morphology of Semitic Languages use several tiers. For instance, (McCarthy, 1981) uses four tiers, one for prefixes, one for the root, one for the template (consonantvowel pattern) and the last one for the vocalization. Such a multi-tiered description may be implemented using a cascade of 2-tape machines (Beesley, 1998) or using a multi-tape transducer where each tier is described by a tape and the surface form by an additional tape. This is the approach of G. A. Kiraz for the Syriac language (Kiraz, 2000). Karamel is designed for the later solution. The multi-tape feature is also interesting for describing related dialects, whenever a great part of the analysis may be shared. A separate tape is dedicated to the surface form in each dialect. The Semitic Morphology is strongly structured by the roots. The basis of an analysis is the identification of the root. Furthermore, several layers of affixes may be distinguished around the core containing the roots: paradigmatic prefixes; affixes encoding the person, gender and number; clitics such as pronouns. This structure is conveniently defined using</context>
<context position="24084" citStr="Kiraz, 2000" startWordPosition="3976" endWordPosition="3977">and the unifications are written by the user. Karamel is more declarative than XFST. Information of different natures are put on different tapes. Abstract feature structures are available. Their compilation and the unifications are automated. On the other hand, XFST is more efficient. The structure information is put only where necessary. XFST is distributed under a commercial license. The system MAGEAD is another system of finite-state morphology developed for Arabic dialects (Habash and Rambow, 2006). It follows the multi-tape approach proposed by George Anton Kiraz for the Syriac language (Kiraz, 2000). It has a rule-based language following the principles of (Grimley-Evans et al., 1996) in which a notion of partition splits forms in a sequence of units comparable to Karamel’s units. But in this approach, there is only one kind of unit which relates all the tapes. Like Karamel, MAGEAD is a layer above Lextools and FSM. The system is not distributed and its description in published papers is not very detailed. 15 Declarations class vowel is a, e, i, u, aa, ee, ii, uu; class cons is b, d, g, h, ... class num is sing, dual, plur; class aspect is present, preterit, perfect, ... ... fstruct fspe</context>
</contexts>
<marker>Kiraz, 2000</marker>
<rawString>George Anton Kiraz. 2000. Multitiered nonlinear morphology using multitape finite automata: a case study on Syriac and Arabic. Comput. Linguist., 26(1):77–105.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kimmo Koskenniemi</author>
</authors>
<title>Two-level model for morphological analysis.</title>
<date>1983</date>
<booktitle>In IJCAI-83,</booktitle>
<pages>683--685</pages>
<location>Karlsruhe, Germany.</location>
<contexts>
<context position="8638" citStr="Koskenniemi, 1983" startWordPosition="1385" endWordPosition="1386">t into an output. let segments= union(star(non_zero),zero); The let is followed by an expression in prefixed notation with the operators written with letters. The literals are the names of previously defined machine. In our example, the expression uses the machines zero defined by the previous regexp and non_zero (not given here). The last way for defining a machine consists in the Generalized Restriction Rules defined in (YliJyr¨a and Koskenniemi, 2004). Roughly speaking, these rules are a modernized version of classical Two-Level Rules such as Context Restriction and Surface Coercion rules (Koskenniemi, 1983). They also are comparable to the rewrite rules of Xerox Finite-State Tools (Beesley and Karttunen, 2003), the difference being that rewrite rules are applied in cascades whereas GR rules may be simultaneous. Contextual rules are defined using three regular expressions: gr_rule rzero is {num} constraint {num:seg={seg}*{seg:#0}{seg}*} =&gt; {num:seg={seg:#0,z´ero}} end The first expression defines a universe. All the expressions in the universe which match the pattern on the left of the arrow must also match the pattern on the right. The sharp symbol is an auxiliary symbol used to make sure that t</context>
</contexts>
<marker>Koskenniemi, 1983</marker>
<rawString>Kimmo Koskenniemi. 1983. Two-level model for morphological analysis. In IJCAI-83, pages 683– 685, Karlsruhe, Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Florence Malbran-Labat</author>
</authors>
<title>Manuel de langue akkadienne.</title>
<date>2001</date>
<booktitle>Publications de l’institut Orientaliste de Louvain (50),</booktitle>
<location>Peeters.</location>
<contexts>
<context position="16469" citStr="Malbran-Labat, 2001" startWordPosition="2693" endWordPosition="2694"> enclitic pronoun and proclitic particles. In the following, these units will be called big grains. The second level is used for the core only, which is divided in smaller parts using the two following criteria: firstly, a unit must be significant in the analysis; secondly, it is determined by a set of features in such a way that no smaller part is uniquely determined by a subset of these features and no greater part is determined by the same set of features. Such a component is invariable for a given 13 value of its features, except some surface transformations. Following the proposition of (Malbran-Labat, 2001), three kinds of vowels are distinguished. The first kind of vowel depends on the stem and the aspect. They are called aspectual vowels. The second kind, called lexical vowel depends on the stem, the aspect and a lexical category attached to the root. The third kind of vowels, the support vowels are not related to morphological features. They are necessary to pronounce and/or write1 the form. The first two kinds of vowels are systematically preserved in weak forms whereas support vowels disappear in weak consonant neighborhood. Support vowel are member of the small grain containing the precedi</context>
</contexts>
<marker>Malbran-Labat, 2001</marker>
<rawString>Florence Malbran-Labat. 2001. Manuel de langue akkadienne. Publications de l’institut Orientaliste de Louvain (50), Peeters.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John J McCarthy</author>
</authors>
<title>A prosodic theory of nonconcatenative morphology. Linguistic Inquiry,</title>
<date>1981</date>
<pages>12--373</pages>
<contexts>
<context position="1756" citStr="McCarthy, 1981" startWordPosition="248" endWordPosition="249">elopment Environment. The language uses extended regular expressions, computations and contextual rules. The environment provides a graphical interface to write and execute finite-state descriptions. Karamel has many applications. For Natural Language Processing, it may be used for morphological analysis, transliteration, parsing, etc. This paper is dedicated to the application of Karamel to the morphological analysis of Semitic languages, for which both multiple tapes and complex structures are useful. Some descriptions of the morphology of Semitic Languages use several tiers. For instance, (McCarthy, 1981) uses four tiers, one for prefixes, one for the root, one for the template (consonantvowel pattern) and the last one for the vocalization. Such a multi-tiered description may be implemented using a cascade of 2-tape machines (Beesley, 1998) or using a multi-tape transducer where each tier is described by a tape and the surface form by an additional tape. This is the approach of G. A. Kiraz for the Syriac language (Kiraz, 2000). Karamel is designed for the later solution. The multi-tape feature is also interesting for describing related dialects, whenever a great part of the analysis may be sha</context>
</contexts>
<marker>McCarthy, 1981</marker>
<rawString>John J. McCarthy. 1981. A prosodic theory of nonconcatenative morphology. Linguistic Inquiry, 12:373– 418.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Petitpierre</author>
<author>G Russel</author>
</authors>
<title>Mmorph: the multex morphology program.</title>
<date>1995</date>
<tech>Technical report, ISSCO technical report,</tech>
<location>Geneva, Switzerland.</location>
<contexts>
<context position="14108" citStr="Petitpierre and Russel, 1995" startWordPosition="2292" endWordPosition="2295">r should be found at compile time. It is not the case yet. Karamel will be distributed to a few kind betatesters in a near future. We plan to add some test facilities to the environment. At medium term, a migration from FSM to openFST (Allauzen et al., 2007) and a distribution under the LGPL license are envisaged. So far, Karamel has been used for morphology. A morphological analyzer for the Akkadian verb is presented in the next section. It is a medium size grammar. Another project describes the French morphology. It is the translation in Karamel of a grammar developed for the MMORPH system (Petitpierre and Russel, 1995). The grammar has a large coverage. It has been tested with a toy lexicon only. The other domain of application explored so far is the transliteration domain. There is a multilingual description of numbers that relates the notation with digits to a written form in several languages (French, English, Finnish). A tape is devoted to each language, a tape to the digits and several tapes for feature structures, some of which are language specific. Another project transliterates Egyptian hieroglyphs into the Latin alphabet, using an intermediate representation on a third tape. 4 An example: the Akka</context>
</contexts>
<marker>Petitpierre, Russel, 1995</marker>
<rawString>D. Petitpierre and G. Russel. 1995. Mmorph: the multex morphology program. Technical report, ISSCO technical report, Geneva, Switzerland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Pulman</author>
<author>M Hepple</author>
</authors>
<title>A feature-based formalism for two-level phonology.</title>
<date>1993</date>
<journal>Computer Speech and Language,</journal>
<volume>7</volume>
<contexts>
<context position="27129" citStr="Pulman and Hepple, 1993" startWordPosition="4371" endWordPosition="4374">ore:stem1=I|IV], {sgrain:lex=&lt;cons&gt;?&lt;vowel&gt;,bab=&lt;cons&gt;?(&lt;vowel&gt;-u)} {sgrain}*}; end Figure 3: extracts from the Akkadian project The main difference is that MAGEAD has only one level of structure using only one type of Cartesian Products. Another difference is that the two systems use different kinds of contextual rules. The rules differ both by their syntax and their semantics. Furthermore, contextual rules are the main syntactic construction in MAGEAD whereas Karamel uses also regular expressions. MMORPH is another system of partition-based morphology based on the work by Pulman and Hepple (Pulman and Hepple, 1993). There are two parts in a description: first, the morphotactics is described using a Unification Grammar where the terminals are lexical affixes and the non-terminals are feature structures; transformation rules relate the lexical and surface levels. The features are flat. Feature structures are evaluated dynamically by a unification machine. Karamel statically compiles Feature Structures and their unification into finite-state transducers. This is efficient and part of the structures are shared. On the other hand, the grammar of feature structures must be regular and there is a risk of combi</context>
</contexts>
<marker>Pulman, Hepple, 1993</marker>
<rawString>S. Pulman and M. Hepple. 1993. A feature-based formalism for two-level phonology. Computer Speech and Language, 7.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Anssi Mikael Yli-Jyr¨a</author>
<author>Kimmo Koskenniemi</author>
</authors>
<title>Compiling contextual restrictions on strings into finite-state automata.</title>
<date>2004</date>
<booktitle>In Proceedings of the Eindhoven FASTAR Days</booktitle>
<location>Eindhoven, The Netherlands,</location>
<marker>Yli-Jyr¨a, Koskenniemi, 2004</marker>
<rawString>Anssi Mikael Yli-Jyr¨a and Kimmo Koskenniemi. 2004. Compiling contextual restrictions on strings into finite-state automata. In Proceedings of the Eindhoven FASTAR Days 2004 (September 3–4), Eindhoven, The Netherlands, December.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>