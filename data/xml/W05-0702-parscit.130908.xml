<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000046">
<title confidence="0.995166">
A finite-state morphological grammar of Hebrew
</title>
<author confidence="0.993323">
Shlomo Yona
</author>
<affiliation confidence="0.997877">
Department of Computer Science
University of Haifa
</affiliation>
<address confidence="0.622934">
31905 Haifa, Israel
</address>
<email confidence="0.996232">
shlomo@cs.haifa.ac.il
</email>
<author confidence="0.988647">
Shuly Wintner
</author>
<affiliation confidence="0.9978715">
Department of Computer Science
University of Haifa
</affiliation>
<address confidence="0.623942">
31905 Haifa, Israel
</address>
<email confidence="0.997842">
shuly@cs.haifa.ac.il
</email>
<sectionHeader confidence="0.993875" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999924333333334">
Morphological analysis is a crucial com-
ponent of several natural language pro-
cessing tasks, especially for languages
with a highly productive morphology,
where stipulating a full lexicon of sur-
face forms is not feasible. We describe
HAMSAH (HAifa Morphological System
for Analyzing Hebrew), a morphological
processor for Modern Hebrew, based on
finite-state linguistically motivated rules
and a broad coverage lexicon. The set
of rules comprehensively covers the mor-
phological, morpho-phonological and or-
thographic phenomena that are observable
in contemporary Hebrew texts. Reliance
on finite-state technology facilitates the
construction of a highly efficient, com-
pletely bidirectional system for analysis
and generation. HAMSAH is currently
the broadest-coverage and most accurate
freely-available system for Hebrew.
</bodyText>
<sectionHeader confidence="0.875904" genericHeader="method">
1 Hebrew morphology: the challenge
</sectionHeader>
<bodyText confidence="0.999815">
Hebrew, like other Semitic languages, has a rich
and complex morphology. The major word forma-
tion machinery is root-and-pattern, where roots are
sequences of three (typically) or more consonants,
called radicals, and patterns are sequences of vow-
els and, sometimes, also consonants, with “slots”
into which the root’s consonants are being inserted
(interdigitation). Inflectional morphology is highly
productive and consists mostly of suffixes, but some-
times of prefixes or circumfixes.
</bodyText>
<page confidence="0.957209">
9
</page>
<bodyText confidence="0.9998942">
As an example of root-and-pattern morphology,
consider the Hebrew1 roots g.d.l and r.e.m and the
patterns hCCCh and CiCwC, where the ‘C’s indi-
cate the slots. When the roots combine with these
patterns the resulting lexemes are hgdlh, gidwl,
hremh, riewm, respectively. After the root com-
bines with the pattern, some morpho-phonological
alternations take place, which may be non-trivial:
for example, the htCCCwt pattern triggers assimi-
lation when the first consonant of the root is t or
d: thus, d.r.e+htCCCwt yields hdrewt. The same
pattern triggers metathesis when the first radical is s
or e: s.d.r+htCCCwt yields hstdrwt rather than the
expected htsdrwt. Frequently, root consonants such
as w or i are altogether missing from the resulting
form. Other weak paradigms include roots whose
first radical is n and roots whose second and third
radicals are identical. Thus, the roots q.w.m, g.n.n,
n.p.l and i.c.g, when combining with the hCCCh
pattern, yield the seemingly similar lexemes hqmh,
hgnh, hplh and hcgh, respectively.
The combination of a root with a pattern produces
a base (or a lexeme), which can then be inflected in
various forms. Nouns, adjectives and numerals in-
flect for number (singular, plural and, in rare cases,
also dual) and gender (masculine or feminine). In
addition, all these three types of nominals have two
phonologically distinct forms, known as the abso-
lute and construct states. Unfortunately, in the stan-
dard orthography approximately half of the nomi-
</bodyText>
<figure confidence="0.173254">
1To facilitate readability we sometimes use a transliteration
of Hebrew using ASCII characters:
a b g d h w z x v i k
N M ] 7 17 1 T n t0 &apos; �
</figure>
<footnote confidence="0.432578">
l m n s y p c q r e t
�7 0 ] o r E) Y 7 -1 PTI r
</footnote>
<note confidence="0.9912885">
Proceedings of the ACL Workshop on Computational Approaches to Semitic Languages, pages 9–16,
Ann Arbor, June 2005. c�2005 Association for Computational Linguistics
</note>
<bodyText confidence="0.999251597560976">
nals appear to have identical forms in both states,
a fact which substantially increases the ambigu-
ity. In addition, nominals take pronominal suffixes
which are interpreted as possessives. These inflect
for number, gender and person: spr+h—*sprh “her
book”, spr+km—*sprkm “your book”, etc. As ex-
pected, these processes involve certain morphologi-
cal alternations, as in mlkh+h—*mlkth “her queen”,
mlkh+km—*mlktkm “your queen”. Verbs inflect for
number, gender and person (first, second and third)
and also for a combination of tense and aspect,
which is traditionally analyzed as having the values
past, present, future, imperative and infinite. Verbs
can also take pronominal suffixes, which in this case
are interpreted as direct objects, but such construc-
tions are rare in contemporary Hebrew of the regis-
ters we are interested in.
These matters are complicated further due to two
sources: first, the standard Hebrew orthography
leaves most of the vowels unspecified. It does not
explicate [a] and [e], does not distinguish between
[o] and [u] and leaves many of the [i] vowels un-
specified. Furthermore, the single letter ❹ w is used
both for the vowels [o] and [u] and for the con-
sonant [v], whereas ❽ i is similarly used both for
the vowel [i] and for the consonant [y]. On top of
that, the script dictates that many particles, includ-
ing four of the most frequent prepositions (b “in”,
k “as”, l “to” and m “from”), the definite article
h “the”, the coordinating conjunction w “and” and
some subordinating conjunctions (such as e “that”
and ke “when”), all attach to the words which imme-
diately follow them. Thus, a form such as ebth can
be read as a lexeme (the verb “capture”, third per-
son singular feminine past), as e+bth “that+field”,
e+b+th “that+in+tea”, ebt+h “her sitting” or even as
e+bt+h “that her daughter”. When a definite nomi-
nal is prefixed by one of the prepositions b, k or l,
the definite article h is assimilated with the prepo-
sition and the resulting form becomes ambiguous as
to whether or not it is definite: bth can be read either
as b+th “in tea” or as b+h+th “in the tea”.
An added complexity stems from the fact that
there exist two main standards for the Hebrew
script: one in which vocalization diacritics, known
as niqqud “dots”, decorate the words, and another
in which the dots are missing, and other characters
represent some, but not all of the vowels. Most of the
texts in Hebrew are of the latter kind; unfortunately,
different authors use different conventions for the
undotted script. Thus, the same word can be writ-
ten in more than one way, sometimes even within
the same document, again adding to the ambiguity.
In light of the above, morphological analysis of
Hebrew forms is a non-trivial task. Observe that
simply stipulating a list of surface forms is not a vi-
able option, both because of the huge number of po-
tential forms and because of the complete inability
of such an approach to handle out-of-lexicon items;
the number of such items in Hebrew is significantly
larger than in European languages due to the combi-
nation of prefix particles with open-class words such
as proper names. The solution must be a dedicated
morphological analyzer, implementing the morpho-
logical and orthographic rules of the language.
Several morphological processors of Hebrew have
been proposed, including works by Choueka (1980;
1990), Ornan and Kazatski (1986), Bentur et al.
(1992) and Segal (1997); see a survey in Wintner
(2004). Most of them are proprietary and hence can-
not be fully evaluated. However, the main limitation
of existing approaches is that they are ad-hoc: the
rules that govern word formation and inflection are
only implicit in such systems, usually intertwined
with control structures and general code. This makes
the maintenance of such systems difficult: correc-
tions, modifications and extensions of the lexicon
are nearly impossible. An additional drawback is
that all existing systems can be used for analysis but
not for generation. Finally, the efficiency of such
systems depends on the quality of the code, and is
sometimes sub-optimal.
</bodyText>
<sectionHeader confidence="0.990059" genericHeader="method">
2 Finite-state technology
</sectionHeader>
<bodyText confidence="0.997945454545454">
Finite-state technology (Beesley and Karttunen,
2003) solves the three problems elegantly. It pro-
vides a language of extended regular expressions
which can be used to define very natural linguis-
tically motivated grammar rules. Such expressions
can then be compiled into finite-state networks (au-
tomata and transducers), on which efficient algo-
rithms can be applied to implement both analysis
and generation. Using this methodology, a computa-
tional linguist can design rules which closely follow
standard linguistic notation, and automatically ob-
</bodyText>
<page confidence="0.996921">
10
</page>
<bodyText confidence="0.99987390625">
tain a highly efficient morphological processor.
While the original Two-Level formulation
(Koskenniemi, 1983) of finite-state technology
for morphology was not particularly well suited
to Semitic languages (Lavie et al., 1988), mod-
ifications of the Two-Level paradigm and more
advanced finite-state implementations have been
applied successfully to a variety of Semitic lan-
guages, including Ancient Akkadian (Kataja and
Koskenniemi, 1988), Syriac (Kiraz, 2000) and
Arabic. In a number of works, Beesley (1996;
1998; 2001) describes a finite-state morphological
analyzer of Modern Standard Arabic which handles
both inflectional and derivational morphology,
including interdigitation. In the following section
we focus on a particular finite-state toolbox which
was successfully used for Arabic.
In this work we use XFST (Beesley and Kart-
tunen, 2003), an extended regular expression lan-
guage augmented by a sophisticated implementation
of several finite-state algorithms, which can be used
to compactly store and process very large-scale net-
works. XFST grammars define a binary relation (a
transduction) on sets of strings: a grammar maps
each member of a (possibly infinite) set of strings,
known as the surface, or lower language, to a set
of strings (the lexical, or upper language). The
idea is that the surface language defines all and only
the grammatical words in the language; and each
grammatical word is associated with a set of lexical
strings which constitutes its analyses. As an exam-
ple, the surface string ebth may be associated by the
grammar with the set of lexical strings, or analyses,
depicted in figure 1.
XFST enables the definition of variables, whose
values, or denotations, are sets of strings, or lan-
guages. Grammars can set and use those variables
by applying a variety of operators. For example, the
concatenation operator (unfortunately indicated by
a space) can be used to concatenate two languages:
the expression ‘A B’ denotes the set of strings ob-
tained by concatenating the strings in A with the
strings in B. Similarly, the operator ‘|’ denotes set
union, ‘&amp;’ denotes intersection, ‘˜’ set complement,
‘-’ set difference and ‘*’ Kleene closure; ‘$A’ de-
notes the set of strings containing at least one in-
stance of a string from A as a substring. The empty
string is denoted by ‘0’ and ‘?’ stands for any alpha-
bet symbol. Square brackets are used for bracketing.
In addition to sets of strings, XFST enables the
definition of binary relations over such sets. By de-
fault, every set is interpreted as the identity relation,
whereby each string is mapped to itself. But re-
lations can be explicitly defined using a variety of
operators. The ‘.x.’ operator denotes cross prod-
uct: the expression ‘A.x.B’ denotes the relation in
which each string in A is mapped to each string in B.
An extremely useful operation is composition: de-
noted by ‘.o.’, it takes two relations, A and B, and
produces a new relation of pairs (a, c) such that there
exists some b that (a, b) is a member of A and (b, c)
is a member of B.
Finally, XFST provides also several replace rules.
Expressions of the form ‘A-&gt;B  ||L _R’ de-
note the relation obtained by replacing strings from
A by strings from B, whenever the former occur
in the context of strings from L on the left and
R on the right. Each of the context markers can
be replaced by the special symbol ‘.#.’, indicat-
ing a word boundary. For example, the expression
‘[h]-&gt;[t]  ||? _ .#.’ replaces occurrences
of ‘h’ by ‘t’ whenever the former occurs before the
end of a word. Composing this example rule on an
(identity) relation whose strings are various words
results in replacing final h with final t in all the
words, not affecting the other strings in the relation.
XFST supports diverse alphabets. In particular, it
supports UTF-8 encoding, which we use for Hebrew
(although subsequent examples use a transliteration
to facilitate readability). Also, the alphabet can in-
clude multi-character symbols; in other words, one
can define alphabet symbols which consist of several
(print) characters, e.g., ‘number’ or ‘tense’. This
comes in handy when tags are defined, see below.
Characters with special meaning (such as ‘+’ or ‘[’)
can be escaped using the symbol ‘%’. For example,
the symbol ‘%+’ is a literal plus sign.
Programming in XFST is different from program-
ming in high level languages. While XFST rules
are very expressive, and enable a true implementa-
tion of some linguistic phenomena, it is frequently
necessary to specify, within the rules, information
that is used mainly for “book-keeping”. Due to
the limited memory of finite-state networks, such
information is encoded in tags, which are multi-
character symbols attached to strings. These tags
</bodyText>
<page confidence="0.988457">
11
</page>
<figure confidence="0.991797125">
[+verb][+id]9430[+base]ebt[+root]ebt[+binyan]+Pa’al[+agr]+3p/F/Sg[+tense]+past
[+verb][+id]1541[+base]ebh[+root]ebh[+binyan]+Pa’al[+agr]+3p/F/Sg[+tense]+past
[+conj]e[+prep]b[+noun][+id]19804[+base]th[+gender]+M[+number]+Sg[+construct]+true
[+conj]e[+prep]b[+noun][+id]19804[+base]th[+gender]+M[+number]+Sg[+construct]+false
[+conj]e[+prep]b[+defArt][+noun][+id]19804[+base]th[+gender]+M[+number]+Sg[+construct]+false
[+conj]e[+noun][+id]19130[+base]bth[+gender]+F[+number]+Sg[+construct]+false
[+conj]e[+noun][+id]1379[+base]bt[+gender]+F[+number]+Sg[+construct]+false[+poss]+3p/F/Sg
[+noun][+id]17280[+base]ebt[+gender]+F[+number]+Sg[+construct]+false[+poss]+3p/F/Sg
</figure>
<figureCaption confidence="0.999993">
Figure 1: The analyses of the surface string 7MMV ebth
</figureCaption>
<bodyText confidence="0.999968636363636">
can be manipulated by the rules and thus propa-
gate information among rules. For example, nouns
are specified for number, and the number feature
is expressed as a concatenation of the tag number
with the multi-character symbol +singular or
+plural. Rules which apply to plural nouns only
can use this information: if nouns is an XFST vari-
able denoting the set of all nouns, then the expres-
sion $[number %+plural] .o. nouns de-
notes only the plural nouns. Once all linguistic pro-
cessing is complete, “book-keeping” tags are erased.
</bodyText>
<sectionHeader confidence="0.983252" genericHeader="method">
3 A morphological grammar of Hebrew
</sectionHeader>
<bodyText confidence="0.999831">
The importance of morphological analysis as a pre-
liminary phase in a variety of natural language pro-
cessing applications cannot be over-estimated. The
lack of good morphological analysis and disam-
biguation systems for Hebrew is reported as one of
the main bottlenecks of a Hebrew to English ma-
chine translation system (Lavie et al. (2004)). The
contribution of our system is manyfold:
</bodyText>
<listItem confidence="0.9991245625">
• HAMSAH is the broadest-coverage and most
accurate publicly available morphological an-
alyzer of Modern Hebrew. It is based on a
lexicon of over 20,000 entries, which is con-
stantly being updated and expanded, and its set
of rules cover all the morphological, morpho-
phonological and orthographic phenomena ob-
served in contemporary Hebrew texts. Com-
pared to Segal (1997), our rules are probably
similar in coverage but our lexicon is signif-
icantly larger. HAMSAH also supports non-
standard spellings which are excluded from the
work of Segal (1997).
• The system is fully reversible: it can be used
both for analysis and for generation.
• Due to the use of finite-state technology, the
</listItem>
<bodyText confidence="0.9932622">
system is highly efficient. While the network
has close to 2 million states and over 2 million
arcs, its compiled size is approximately 4Mb
and analysis is extremely fast (between 50
and 100 words per second).
</bodyText>
<listItem confidence="0.822751333333333">
• Morphological knowledge is expressed through
linguistically motivated rules. To the best of
our knowledge, this is the first formal grammar
</listItem>
<bodyText confidence="0.972772363636364">
for the morphology of Modern Hebrew.
The system consists of two main components: a
lexicon represented in Extensible Markup Language
(XML), and a set of finite-state rules, implemented
in XFST. The use of XML supports standardization,
allows a format that is both human and machine
readable, and supports interoperability with other
applications. For compatibility with the rules, the
lexicon is automatically converted to XFST by ded-
icated programs. We briefly describe the lexicon in
section 3.1 and the rules in section 3.2.
</bodyText>
<subsectionHeader confidence="0.996515">
3.1 The lexicon
</subsectionHeader>
<bodyText confidence="0.993563571428571">
The lexicon is a list of lexical entries, each with a
base (citation) form and a unique id. The base form
of nouns and adjectives is the absolute singular mas-
culine, and for verbs it is the third person singu-
lar masculine, past tense. It is listed in dotted and
undotted script as well as using a one-to-one Latin
transliteration. Figure 2 depicts the lexical entry of
the word bli “without”. In subsequent examples we
retain only the transliteration forms and suppress the
Hebrew ones.
&lt;item dotted=&amp;quot;&apos;�V&amp;quot; id=&amp;quot;4917&amp;quot;
translit=&amp;quot;bli&amp;quot; undotted=&amp;quot;&apos;�M&amp;quot;&gt;
&lt;conjunction type=&amp;quot;coord&amp;quot;/&gt;
&lt;/item&gt;
</bodyText>
<figureCaption confidence="0.996644">
Figure 2: The lexical entry of bli “without”
</figureCaption>
<page confidence="0.991526">
12
</page>
<bodyText confidence="0.936213">
The lexicon specifies morpho-syntactic features
(such as gender or number), which can later be used
by parsers and other applications. It also lists sev-
eral lexical proerties which are specifically targeted
at morphological analysis. A typical example is the
feminine suffix of adjectives, which can be one of
h, it or t, and cannot be predicted from the base
form. The lexicon lists information pertaining to
non-default behavior with idiosyncratic entries.
Adjectives inflect regularly, with few exceptions.
Their citation form is the absolute singular mascu-
line, which is used to generate the feminine form,
the masculine plural and the feminine plural. An
additional dimension is status, which can be ab-
solute or construct. Figure 3 lists the lexicon en-
try of the adjective yilai “supreme”: its feminine
form is obtained by adding the t suffix (hence
feminine=&amp;quot;t&amp;quot;). Other features are determined
by default. This lexicon entry yields yilai, yilait, yi-
laiim, yilaiwt etc.
&lt;item id=&amp;quot;13852&amp;quot; translit=&amp;quot;yilai&amp;quot;&gt;
&lt;adjective feminine=&amp;quot;t&amp;quot; /&gt;
&lt;/item&gt;
</bodyText>
<figureCaption confidence="0.999589">
Figure 3: A lexicon item for yilai “supreme”
</figureCaption>
<bodyText confidence="0.987122066666667">
Similarly, the citation form of nouns is the ab-
solute singular masculine form. Hebrew has gram-
matical gender, and the gender of nouns that denote
animate entities coincides with their natural gender.
The lexicon specifies the feminine suffix via the fem-
inine attribute. Nouns regularly inflect for number,
but some nouns have only a plural or only a singu-
lar form. The plural suffix (im for masculine, wt for
feminine by default) is specified through the plural
attribute. Figure 4 demonstrates a masculine noun
with an irregular plural suffix, wt.
&lt;item id=&amp;quot;5044&amp;quot; translit=&amp;quot;ewlxn&amp;quot;&gt;
&lt;noun gender=&amp;quot;masculine&amp;quot;
number=&amp;quot;singular&amp;quot;
plural=&amp;quot;wt&amp;quot; /&gt;&lt;/item&gt;
</bodyText>
<figureCaption confidence="0.999166">
Figure 4: A lexicon item for the noun ewlxn “table”
</figureCaption>
<bodyText confidence="0.998539431372549">
Closed-class words are listed in the lexicon in a
similar manner, where the specific category deter-
mines which attributes are associated with the cita-
tion form. For example, some adverbs inflect for
person, number and gender (e.g., lav “slowly”), so
this is indicated in the lexicon. The lexicon also
specifies the person, number and gender of pro-
nouns, the type of proper names (location, person,
organization), etc. The lexical representation of
verbs is more involved and is suppressed for lack
of space.
Irregularities are expressed directly in the lexi-
con, in the form of additional or alternative lexi-
cal entries. This is facilitated through the use of
three optional elements in lexicon items: add, re-
place and remove. For example, the noun chriim
“noon” is also commonly spelled chrim, so the addi-
tional spelling is specified in the lexicon, along with
the standard spelling, using add. As another exam-
ple, consider Segolate nouns such as bwqr “morn-
ing”. Its plural form is bqrim rather than the default
bwqrim; such stem changing behavior is specified
in the lexicon using replace. Finally, the verb ykwl
“can” does not have imperative inflections, which
are generated by default for all verbs. To prevent the
default behavior, the superfluous forms are removed.
The processing of irregular lexicon entries re-
quires some explanation. Lexicon items containing
add, remove and replace elements are included in
the general lexicon without the add, remove and re-
place elements, which are listed in special lexicons.
The general lexicon is used to build a basic morpho-
logical finite-state network. Additional networks are
built using the same set of rules for the add, remove
and replace lexicons. The final network is obtained
by subtracting the remove network from the general
one (using the set difference operator), adding the
add network (using the set union operator), and fi-
nally applying priority union with the replace net-
work. This final finite-state network contains only
and all the valid inflected forms.
The lexicon is represented in XML, while the
morphological analyzer is implemented in XFST,
so the former has to be converted to the latter. In
XFST, a lexical entry is a relation which holds be-
tween the surface form of the lemma and a set of
lexical strings. As a surface lemma is processed by
the rules, its associated lexical strings are manipu-
lated to reflect the impact of inflectional morphol-
ogy. The surface string of XFST lexical entries is the
citation form specified in the XML lexicon. Figure 5
</bodyText>
<page confidence="0.997949">
13
</page>
<bodyText confidence="0.997225">
lists the XFST representation of the lexical entry of
the word bli, whose XML representation was listed
in figure 2.
</bodyText>
<figure confidence="0.612488">
[+negation][+id]21542[+undotted]
❽➀⑩[+translit]bli
</figure>
<figureCaption confidence="0.999385">
Figure 5: The lexicon item of bli in XFST
</figureCaption>
<subsectionHeader confidence="0.99932">
3.2 Morphological and orthographic rules
</subsectionHeader>
<bodyText confidence="0.99982058974359">
In this section we discuss the set of rules which
constitute the morphological grammar, i.e., the im-
plementation of linguistic structures in XFST. The
grammar includes hundreds of rules; we present a
small sample, exemplifying the principles that gov-
ern the overall organization of the grammar. The
linguistic information was collected from several
sources (Barkali, 1962; Zdaqa, 1974; Alon, 1995;
Cohen, 1996; Schwarzwald, 2001; Schwarzwald,
2002; Ornan, 2003).
The grammar consists of specific rules for every
part of speech category, which are applied to the ap-
propriate lexicons. For each category, a variable is
defined whose denotation is the set of all lexical en-
tries of that category. Combined with the category-
specific rules, we obtain morphological grammars
for every category (not including idiosyncrasies).
These grammars are too verbose on the lexical side,
as they contain all the information that was listed in
the lexicon. Filters are therefore applied to the lexi-
cal side to remove the unneeded information.
Our rules support surface forms that are made of
zero or more prefix particles, followed by a (pos-
sibly inflected) lexicon item. Figure 6 depicts the
high-level organization of the grammar (recall from
section 2 that ‘.o.’ denotes composition). The vari-
able inflectedWord denotes a union of all the
possible inflections of the entire lexicon. Similarly,
prefixes is the set of all the possible sequences
of prefixes. When the two are concatenated, they
yield a language of all possible surface forms, vastly
over-generating. On the upper side of this language
a prefix particle filter is composed, which enforces
linguistically motivated constraints on the possible
combinations of prefixes with words. On top of
this another filter is composed, which handles “cos-
metic” changes, such as removing “book-keeping”
tags. A similar filter is applied to the the lower side
of the network.
</bodyText>
<figure confidence="0.891904428571428">
tagAffixesFilter
.o.
prefixesFilters
.o.
[ prefixes inflectedWord ]
.o.
removeTagsFilter
</figure>
<figureCaption confidence="0.999877">
Figure 6: A high level view of the analyzer
</figureCaption>
<bodyText confidence="0.907304409090909">
As an example, consider the feminine singular
form of adjectives, which is generated from the
masculine singular by adding a suffix, either h, it
or t. Some idiosyncratic forms have no masculine
singular form, but do have a feminine singular form,
for example hrh “pregnant”. Therefore, as figure 7
shows, singular feminine adjectives are either ex-
tracted verbatim from the lexicon or generated from
the singular masculine form by suffixation. The rule
[ %+feminine &lt;- ?  ||%+gender _ ]
changes the gender attribute to feminine for the
inflected feminine forms. This is a special form of
a replace rule which replaces any symbol (‘?’) by
the multi-character symbol ‘+feminine’, in the
context of occurring after ‘+gender’. The right
context is empty, meaning anything.
define feminineSingularAdjective [
[$[%+gender [%+feminine]]
.o. adjective ] |
[ %+feminine &lt;- ?  ||%+gender _ ]
.o. [ sufH  |sufT  |sufIT ]
];
</bodyText>
<figureCaption confidence="0.997918">
Figure 7: Feminine adjectives
</figureCaption>
<bodyText confidence="0.9939315">
Figure 8 shows how the suffix h (the value of the
variable HE) is used in the inflection. The default
is not to add an additional h if the masculine ad-
jective already terminates with it, as in mwrh “male
teacher” —* mwrh “female teacher”. This means that
exceptions to this default, such as gbwh “tall, m” —*
gbwhh “tall, f”, are being improperly treated. Such
forms are explicitly listed in the lexicon as idiosyn-
crasies (using the add/replace/remove mechanism),
and will be corrected at a later stage. The suffixes t
</bodyText>
<page confidence="0.996746">
14
</page>
<bodyText confidence="0.422956375">
and it are handled in a similar way.
define sufH [
[ [ $[%+feminine %+h] .o.
masculineSingularAdjective ]
[ 0 .x. addedHE ] ]
.o. [ addedHE -&gt; 0  ||HE _ .#. ]
.o. [ addedHE -&gt; HE ]
];
</bodyText>
<figureCaption confidence="0.998193">
Figure 8: Adding the suffix h
</figureCaption>
<bodyText confidence="0.991944588235294">
Figure 9 shows how plural nouns with the wt suf-
fix are processed. On the lower side some condi-
tional alternations are performed before the suffix is
added. The first alternation rule replaces iih with
ih at the end of a word, ensuring that nouns wrttent
with a spurious i such as eniih “second” are properly
inflected as eniwt “seconds” rather than eniiwt. The
second alternation rule removes final t to ensure that
a singular noun such as meait “truck” is properly in-
flected to its plural form meaiwt. The third ensures
that nouns ending in wt such as smkwt “authority”
are properly inflected as smkwiwt. Of course, ir-
regular nouns such as xnit “spear”, whose plural is
xnitwt rather than xniwt, are lexically specified and
handled separately. Finally, a final h is removed by
the fourth rule, and subsequently the plural suffix is
concatenated.
</bodyText>
<figure confidence="0.996122916666667">
define pluralWTNoun [
[
[ %+plural &lt;- %+singular  ||%+number _ ]
.o. $[%+number %+singular]
.o. $[%+plural %+wt]
.o. noun
.o. [ YOD YOD HE -&gt; YOD HE  ||_ .#. ]
.o. [ ALEF YOD TAV -&gt; ALEF YOD  ||_ .#. ]
.o. [ VAV TAV -&gt; VAV YOD  ||_ .#. ]
.o. [ [HE|TAV] -&gt; 0  ||_ .#. ]
] [ 0 .x. [VAV TAV] ]
];
</figure>
<figureCaption confidence="0.999905">
Figure 9: Plural nouns with wt suffix
</figureCaption>
<bodyText confidence="0.999851571428572">
The above rules only superficially demonstrate
the capabilities of our grammar. The bulk of the
grammar consists of rules for inflecting verbs, in-
cluding a complete coverage of the weak paradigms.
The grammar also contains rules which govern the
possible combinations of prefix particles and the
words they combine with.
</bodyText>
<sectionHeader confidence="0.998663" genericHeader="conclusions">
4 Conclusion
</sectionHeader>
<bodyText confidence="0.998367288888889">
We described a broad-coverage finite-state grammar
of Modern Hebrew, consisting of two main compo-
nents: a lexicon and a set of rules. The current un-
derlying lexicon includes over 20,000 items. The av-
erage number of inflected forms for a lexicon item
is 33 (not including prefix sequences). Due to the
use of finite-state technology, the grammar can be
used for generation or for analysis. It induces a very
efficient morphological analyzer: in practice, over
eighty words per second can be analyzed on a con-
temporary workstation.
For lack of space we cannot fully demonstrate the
output of the analyzer; refer back to figure 1 for
an example. HAMSAH is now used for a number
of projects, including as a front end for a Hebrew
to English machine translation system (Lavie et al.,
2004). It is routinely tested on a variety of texts,
and tokens with zero analyses are being inspected
manually. A systematic evaluation of the quality of
the analyzer is difficult due to the lack of available
alternative resources. Nevertheless, we conducted
a small-scale evaluation experiment by asking two
annotators to review the output produced by the an-
alyzer for a randomly chosen set of newspaper arti-
cles comprising of approximately 1000 word tokens.
The following table summarizes the results of this
experiment.
tokens
no analysis
no correct analysis
correct analysis produced
The majority of the missing analyses are due to out-
of-lexicon items, particularly proper names.
In addition to maintenance and expansion of the
lexicon, we intend to extend this work in two main
directions. First, we are interested in automatic
methods for expanding the lexicon, especially for
named entities. Second, we are currently working on
a disambiguation module which will rank the analy-
ses produced by the grammar according to context-
dependent criteria. Existing works on part-of-speech
tagging and morphological disambiguation in He-
brew (Segal, 1999; Adler, 2004; Bar-Haim, 2005)
leave much room for further research. Incorpo-
rating state-of-the-art machine learning techniques
</bodyText>
<figure confidence="0.9953948">
number %
959 100.00%
37 3.86%
41 4.28%
881 91.86%
</figure>
<page confidence="0.953695">
15
</page>
<bodyText confidence="0.999960666666667">
for morphological disambiguation to the output pro-
duced by the analyzer will generate an optimal sys-
tem which is broad-coverage, effective and accurate.
</bodyText>
<sectionHeader confidence="0.995491" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.9992924">
This work was funded by the Israeli Ministry of
Science and Technology, under the auspices of the
Knowledge Center for Processing Hebrew. We are
grateful to Yael Cohen-Sygal, Shira Schwartz and
Alon Itai for their help.
</bodyText>
<sectionHeader confidence="0.998521" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999937554347826">
Meni Adler. 2004. Word-based statistical language mod-
eling: Two-dimensional approach. Thesis proposal,
Ben Gurion University, Beer Sheva, April.
Emmanuel Alon. 1995. Unvocalized Hebrew Writing:
The Structure of Hebrew Words in Syntactic Context.
Ben-Gurion University of the Negev Press. In Hebrew.
Roy Bar-Haim. 2005. Part-of-speech tagging for Hebrew
and other Semitic languages. Master’s thesis, Com-
puter Science Department, Technion, Haifa, Israel.
Shaul Barkali. 1962. Lux HaP’alim HaShalem (The
Complete Verbs Table). Reuven Mass, Jerusalem. In
Hebrew.
Kenneth R. Beesley and Lauri Karttunen. 2003. Finite-
State Morphology: Xerox Tools and Techniques.
CSLI, Stanford.
Kenneth R. Beesley. 1996. Arabic finite-state mor-
phological analysis and generation. In Proceedings
of COLING-96, the 16th International Conference on
Computational Linguistics, Copenhagen.
Kenneth R. Beesley. 1998. Arabic morphology using
only finite-state operations. In Michael Rosner, ed-
itor, Proceedings of the Workshop on Computational
Approaches to Semitic languages, pages 50–57, Mon-
treal, Quebec, August. COLING-ACL’98.
Kenneth R. Beesley. 2001. Finite-state morphological
analysis and generation of Arabic at Xerox Research:
Status and plans in 2001. In ACL Workshop on Arabic
Language Processing: Status and Perspective, pages
1–8, Toulouse, France, July.
Esther Bentur, Aviella Angel, Danit Segev, and Alon
Lavie. 1992. Analysis and generation of the nouns
inflection in Hebrew. In Uzzi Ornan, Gideon Arieli,
and Edit Doron, editors, Hebrew Computational Lin-
guistics, chapter 3, pages 36–38. Ministry of Science
and Technology. In Hebrew.
Yaacov Choueka. 1980. Computerized full-text retrieval
systems and research in the humanities: The Responsa
project. Computers and the Humanities, 14:153–169.
Yaacov Choueka. 1990. MLIM - a system for full, exact,
on-line grammatical analysis of Modern Hebrew. In
Yehuda Eizenberg, editor, Proceedings of the Annual
Conference on Computers in Education, page 63, Tel
Aviv, April. In Hebrew.
Haim A. Cohen. 1996. klalei ha-ktiv xasar ha-niqqud.
leshonenu la&amp;am, special edition, May. In Hebrew.
Laura Kataja and Kimmo Koskenniemi. 1988. Finite-
state description of Semitic morphology: A case study
of Ancient Akkadian. In COLING, pages 313–315.
George Anton Kiraz. 2000. Multitiered nonlinear mor-
phology using multitape finite automata: a case study
on Syriac and Arabic. Computational Linguistics,
26(1):77–105, March.
Kimmo Koskenniemi. 1983. Two-Level Morphology: a
General Computational Model for Word-Form Recog-
nition and Production. The Department of General
Linguistics, University of Helsinki.
Alon Lavie, Alon Itai, Uzzi Ornan, and Mori Rimon.
1988. On the applicability of two-level morphology
to the inflection of Hebrew verbs. In Proceedings of
the International Conference of the ALLC, Jerusalem,
Israel.
Alon Lavie, Shuly Wintner, Yaniv Eytani, Erik Peterson,
and Katharina Probst. 2004. Rapid prototyping of a
transfer-based Hebrew-to-English machine translation
system. In Proceedings of TMI-2004: The 10th Inter-
national Conference on Theoretical and Methodolog-
ical Issues in Machine Translation, Baltimore, MD,
October.
Uzzi Ornan and Wadim Kazatski. 1986. Analysis and
synthesis processes in Hebrew morphology. In Pro-
ceedings of the 21 National Data Processing Confer-
ence. In Hebrew.
Uzzi Ornan. 2003. The Final Word. University of Haifa
Press, Haifa, Israel. In Hebrew.
Ora Schwarzwald. 2001. Moden Hebrew, volume 127
of Languages of the World/Materials. LINCOM EU-
ROPA.
Ora Schwarzwald. 2002. Studies in Hebrew Morphol-
ogy. The Open University of Israel.
Erel Segal. 1997. Morphological analyzer for unvo-
calized hebrew words. Unpublished work, available
from http://www.cs.technion.ac.il/-
˜erelsgl/hmntx.zip.
Erel Segal. 1999. Hebrew morphological analyzer for
Hebrew undotted texts. Master’s thesis, Technion, Is-
rael Institute of Technology, Haifa, October. In He-
brew.
Shuly Wintner. 2004. Hebrew computational linguis-
tics: Past and future. Artificial Intelligence Review,
21(2):113–138.
Yizxaq Zdaqa. 1974. Luxot HaPoal (The Verb Tables).
Kiryath Sepher, Jerusalem. In Hebrew.
</reference>
<page confidence="0.998701">
16
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.000359">
<title confidence="0.996827">A finite-state morphological grammar of Hebrew</title>
<author confidence="0.971417">Shlomo</author>
<affiliation confidence="0.9998315">Department of Computer University of</affiliation>
<address confidence="0.99788">31905 Haifa,</address>
<email confidence="0.999015">shlomo@cs.haifa.ac.il</email>
<author confidence="0.891315">Shuly</author>
<affiliation confidence="0.999819">Department of Computer University of</affiliation>
<address confidence="0.997878">31905 Haifa,</address>
<email confidence="0.999457">shuly@cs.haifa.ac.il</email>
<abstract confidence="0.998759875000002">Morphological analysis is a crucial component of several natural language processing tasks, especially for languages with a highly productive morphology, where stipulating a full lexicon of surface forms is not feasible. We describe HAMSAH (HAifa Morphological System for Analyzing Hebrew), a morphological processor for Modern Hebrew, based on finite-state linguistically motivated rules and a broad coverage lexicon. The set of rules comprehensively covers the morphological, morpho-phonological and orthographic phenomena that are observable in contemporary Hebrew texts. Reliance on finite-state technology facilitates the construction of a highly efficient, completely bidirectional system for analysis and generation. HAMSAH is currently the broadest-coverage and most accurate freely-available system for Hebrew. 1 Hebrew morphology: the challenge Hebrew, like other Semitic languages, has a rich and complex morphology. The major word formation machinery is root-and-pattern, where roots are sequences of three (typically) or more consonants, and patterns are sequences of vowels and, sometimes, also consonants, with “slots” into which the root’s consonants are being inserted (interdigitation). Inflectional morphology is highly productive and consists mostly of suffixes, but sometimes of prefixes or circumfixes. 9 As an example of root-and-pattern morphology, the roots the where the ‘C’s indicate the slots. When the roots combine with these the resulting lexemes are gidwl, respectively. After the root combines with the pattern, some morpho-phonological alternations take place, which may be non-trivial: example, the triggers assimiwhen the first consonant of the root is thus, The same triggers metathesis when the first radical is than the Frequently, root consonants such altogether missing from the resulting Other include roots whose radical is roots whose second and third are identical. Thus, the roots g.n.n, when combining with the yield the seemingly similar lexemes hplh respectively. The combination of a root with a pattern produces a which can then be inflected in various forms. Nouns, adjectives and numerals inflect for number (singular, plural and, in rare cases, also dual) and gender (masculine or feminine). In addition, all these three types of nominals have two distinct forms, known as the abso- Unfortunately, in the stanorthography approximately half of the nomifacilitate readability we sometimes use a transliteration of Hebrew using ASCII characters: a b g d h w z x v i k N M ] 7 17 1 T n t0 &apos; � l m n s y p c q r e t �7 0 ] o r E) Y 7 -1 PTI r of the ACL Workshop on Computational Approaches to Semitic pages 9–16, Arbor, June 2005. Association for Computational Linguistics nals appear to have identical forms in both states, a fact which substantially increases the ambiguity. In addition, nominals take pronominal suffixes which are interpreted as possessives. These inflect number, gender and person: book”, etc. As expected, these processes involve certain morphologialternations, as in queen”, queen”. Verbs inflect for number, gender and person (first, second and third) and also for a combination of tense and aspect, which is traditionally analyzed as having the values past, present, future, imperative and infinite. Verbs can also take pronominal suffixes, which in this case are interpreted as direct objects, but such constructions are rare in contemporary Hebrew of the registers we are interested in. These matters are complicated further due to two sources: first, the standard Hebrew orthography leaves most of the vowels unspecified. It does not does not distinguish between leaves many of the un- Furthermore, the single letter used for the vowels for the conwhereas similarly used both for vowel for the consonant On top of that, the script dictates that many particles, includfour of the most frequent prepositions and the definite article the coordinating conjunction and subordinating conjunctions (such as all attach to the words which immefollow them. Thus, a form such as be read as a lexeme (the verb “capture”, third persingular feminine past), as sitting” or even as her daughter”. When a definite nomiis prefixed by one of the prepositions definite article assimilated with the preposition and the resulting form becomes ambiguous as whether or not it is definite: be read either tea” or as the tea”. An added complexity stems from the fact that there exist two main standards for the Hebrew script: one in which vocalization diacritics, known decorate the words, and another in which the dots are missing, and other characters represent some, but not all of the vowels. Most of the texts in Hebrew are of the latter kind; unfortunately, different authors use different conventions for the undotted script. Thus, the same word can be written in more than one way, sometimes even within the same document, again adding to the ambiguity. In light of the above, morphological analysis of Hebrew forms is a non-trivial task. Observe that simply stipulating a list of surface forms is not a viable option, both because of the huge number of potential forms and because of the complete inability of such an approach to handle out-of-lexicon items; the number of such items in Hebrew is significantly larger than in European languages due to the combination of prefix particles with open-class words such as proper names. The solution must be a dedicated morphological analyzer, implementing the morphological and orthographic rules of the language. Several morphological processors of Hebrew have been proposed, including works by Choueka (1980; 1990), Ornan and Kazatski (1986), Bentur et al. (1992) and Segal (1997); see a survey in Wintner (2004). Most of them are proprietary and hence cannot be fully evaluated. However, the main limitation of existing approaches is that they are ad-hoc: the rules that govern word formation and inflection are only implicit in such systems, usually intertwined with control structures and general code. This makes the maintenance of such systems difficult: corrections, modifications and extensions of the lexicon are nearly impossible. An additional drawback is that all existing systems can be used for analysis but not for generation. Finally, the efficiency of such systems depends on the quality of the code, and is sometimes sub-optimal. 2 Finite-state technology technology and Karttunen, 2003) solves the three problems elegantly. It provides a language of extended regular expressions which can be used to define very natural linguistically motivated grammar rules. Such expressions can then be compiled into finite-state networks (automata and transducers), on which efficient algorithms can be applied to implement both analysis and generation. Using this methodology, a computational linguist can design rules which closely follow linguistic notation, and automatically ob- 10 tain a highly efficient morphological processor. While the original Two-Level formulation (Koskenniemi, 1983) of finite-state technology for morphology was not particularly well suited to Semitic languages (Lavie et al., 1988), modifications of the Two-Level paradigm and more advanced finite-state implementations have been applied successfully to a variety of Semitic languages, including Ancient Akkadian (Kataja and Koskenniemi, 1988), Syriac (Kiraz, 2000) and Arabic. In a number of works, Beesley (1996; 1998; 2001) describes a finite-state morphological analyzer of Modern Standard Arabic which handles both inflectional and derivational morphology, including interdigitation. In the following section we focus on a particular finite-state toolbox which was successfully used for Arabic. In this work we use XFST (Beesley and Karttunen, 2003), an extended regular expression language augmented by a sophisticated implementation of several finite-state algorithms, which can be used to compactly store and process very large-scale networks. XFST grammars define a binary relation (a on sets of strings: a grammar maps each member of a (possibly infinite) set of strings, as the or to a set strings (the or The idea is that the surface language defines all and only the grammatical words in the language; and each grammatical word is associated with a set of lexical which constitutes its As an examthe surface string be associated by the grammar with the set of lexical strings, or analyses, depicted in figure 1. enables the definition of whose or are sets of strings, or languages. Grammars can set and use those variables applying a variety of For example, the (unfortunately indicated by a space) can be used to concatenate two languages: expression denotes the set of strings obby concatenating the strings in the in Similarly, the operator denotes set denotes intersection, set complement, set difference and Kleene closure; denotes the set of strings containing at least one inof a string from a substring. The empty is denoted by and stands for any alphabet symbol. Square brackets are used for bracketing. In addition to sets of strings, XFST enables the definition of binary relations over such sets. By default, every set is interpreted as the identity relation, whereby each string is mapped to itself. But relations can be explicitly defined using a variety of The operator denotes cross prodthe expression denotes the relation in each string in mapped to each string in An extremely useful operation is composition: deby it takes two and a new relation of pairs that there some a member of a member of XFST provides also several of the form  ||L denote the relation obtained by replacing strings from strings from whenever the former occur the context of strings from the left and the right. Each of the context markers can replaced by the special symbol indicating a word boundary. For example, the expression  ||? _ replaces occurrences by whenever the former occurs before the end of a word. Composing this example rule on an (identity) relation whose strings are various words in replacing final final all the words, not affecting the other strings in the relation. XFST supports diverse alphabets. In particular, it supports UTF-8 encoding, which we use for Hebrew (although subsequent examples use a transliteration to facilitate readability). Also, the alphabet can inin other words, one can define alphabet symbols which consist of several characters, e.g., or This in handy when defined, see below. with special meaning (such as or be escaped using the symbol For example, symbol is a literal plus sign. Programming in XFST is different from programming in high level languages. While XFST rules are very expressive, and enable a true implementation of some linguistic phenomena, it is frequently necessary to specify, within the rules, information that is used mainly for “book-keeping”. Due to the limited memory of finite-state networks, such is encoded in which are multicharacter symbols attached to strings. These tags 11 [+verb][+id]9430[+base]ebt[+root]ebt[+binyan]+Pa’al[+agr]+3p/F/Sg[+tense]+past [+verb][+id]1541[+base]ebh[+root]ebh[+binyan]+Pa’al[+agr]+3p/F/Sg[+tense]+past [+conj]e[+prep]b[+noun][+id]19804[+base]th[+gender]+M[+number]+Sg[+construct]+true [+conj]e[+prep]b[+noun][+id]19804[+base]th[+gender]+M[+number]+Sg[+construct]+false [+conj]e[+prep]b[+defArt][+noun][+id]19804[+base]th[+gender]+M[+number]+Sg[+construct]+false [+conj]e[+noun][+id]19130[+base]bth[+gender]+F[+number]+Sg[+construct]+false [+conj]e[+noun][+id]1379[+base]bt[+gender]+F[+number]+Sg[+construct]+false[+poss]+3p/F/Sg [+noun][+id]17280[+base]ebt[+gender]+F[+number]+Sg[+construct]+false[+poss]+3p/F/Sg 1: The analyses of the surface string can be manipulated by the rules and thus propagate information among rules. For example, nouns specified for and the number feature expressed as a concatenation of the tag the multi-character symbol Rules which apply to plural nouns only use this information: if an XFST variable denoting the set of all nouns, then the expres- %+plural] .o. nouns denotes only the plural nouns. Once all linguistic processing is complete, “book-keeping” tags are erased. 3 A morphological grammar of Hebrew The importance of morphological analysis as a preliminary phase in a variety of natural language processing applications cannot be over-estimated. The lack of good morphological analysis and disambiguation systems for Hebrew is reported as one of the main bottlenecks of a Hebrew to English machine translation system (Lavie et al. (2004)). The contribution of our system is manyfold: • HAMSAH is the broadest-coverage and most accurate publicly available morphological analyzer of Modern Hebrew. It is based on a lexicon of over 20,000 entries, which is constantly being updated and expanded, and its set of rules cover all the morphological, morphophonological and orthographic phenomena observed in contemporary Hebrew texts. Compared to Segal (1997), our rules are probably similar in coverage but our lexicon is significantly larger. HAMSAH also supports nonstandard spellings which are excluded from the work of Segal (1997). • The system is fully reversible: it can be used both for analysis and for generation. • Due to the use of finite-state technology, the system is highly efficient. While the network has close to 2 million states and over 2 million arcs, its compiled size is approximately 4Mb and analysis is extremely fast (between 50 and 100 words per second). • Morphological knowledge is expressed through linguistically motivated rules. To the best of our knowledge, this is the first formal grammar for the morphology of Modern Hebrew. The system consists of two main components: a in Extensible Markup Language (XML), and a set of finite-state rules, implemented in XFST. The use of XML supports standardization, allows a format that is both human and machine readable, and supports interoperability with other applications. For compatibility with the rules, the lexicon is automatically converted to XFST by dedicated programs. We briefly describe the lexicon in section 3.1 and the rules in section 3.2. 3.1 The lexicon The lexicon is a list of lexical entries, each with a form and a unique The base form of nouns and adjectives is the absolute singular masculine, and for verbs it is the third person singular masculine, past tense. It is listed in dotted and undotted script as well as using a one-to-one Latin transliteration. Figure 2 depicts the lexical entry of word In subsequent examples we retain only the transliteration forms and suppress the Hebrew ones. id=&amp;quot;4917&amp;quot; &lt;conjunction type=&amp;quot;coord&amp;quot;/&gt; &lt;/item&gt; 2: The lexical entry of 12 The lexicon specifies morpho-syntactic features (such as gender or number), which can later be used by parsers and other applications. It also lists several lexical proerties which are specifically targeted at morphological analysis. A typical example is the feminine suffix of adjectives, which can be one of it and cannot be predicted from the base form. The lexicon lists information pertaining to non-default behavior with idiosyncratic entries. Adjectives inflect regularly, with few exceptions. Their citation form is the absolute singular masculine, which is used to generate the feminine form, the masculine plural and the feminine plural. An additional dimension is status, which can be absolute or construct. Figure 3 lists the lexicon enof the adjective its feminine is obtained by adding the (hence Other features are determined default. This lexicon entry yields yilait, yiyilaiwt &lt;item id=&amp;quot;13852&amp;quot; translit=&amp;quot;yilai&amp;quot;&gt; &lt;adjective feminine=&amp;quot;t&amp;quot; /&gt; &lt;/item&gt; 3: A lexicon item for Similarly, the citation form of nouns is the absolute singular masculine form. Hebrew has grammatical gender, and the gender of nouns that denote animate entities coincides with their natural gender. lexicon specifies the feminine suffix via the fem- Nouns regularly inflect for number, but some nouns have only a plural or only a singuform. The plural suffix masculine, by default) is specified through the attribute. Figure 4 demonstrates a masculine noun an irregular plural suffix, &lt;item id=&amp;quot;5044&amp;quot; translit=&amp;quot;ewlxn&amp;quot;&gt; &lt;noun gender=&amp;quot;masculine&amp;quot; number=&amp;quot;singular&amp;quot; plural=&amp;quot;wt&amp;quot; /&gt;&lt;/item&gt; 4: A lexicon item for the noun Closed-class words are listed in the lexicon in a similar manner, where the specific category determines which attributes are associated with the citation form. For example, some adverbs inflect for number and gender (e.g., so this is indicated in the lexicon. The lexicon also specifies the person, number and gender of pronouns, the type of proper names (location, person, organization), etc. The lexical representation of verbs is more involved and is suppressed for lack of space. Irregularities are expressed directly in the lexicon, in the form of additional or alternative lexical entries. This is facilitated through the use of optional elements in lexicon items: re- For example, the noun is also commonly spelled so the additional spelling is specified in the lexicon, along with standard spelling, using As another examconsider Segolate nouns such as “morn- Its plural form is than the default such stem changing behavior is specified the lexicon using Finally, the verb “can” does not have imperative inflections, which are generated by default for all verbs. To prevent the behavior, the superfluous forms are The processing of irregular lexicon entries requires some explanation. Lexicon items containing are included in general lexicon without the rewhich are listed in special lexicons. The general lexicon is used to build a basic morphological finite-state network. Additional networks are using the same set of rules for the The final network is obtained subtracting the from the general one (using the set difference operator), adding the (using the set union operator), and fiapplying union the network. This final finite-state network contains only and all the valid inflected forms. The lexicon is represented in XML, while the morphological analyzer is implemented in XFST, so the former has to be converted to the latter. In XFST, a lexical entry is a relation which holds between the surface form of the lemma and a set of lexical strings. As a surface lemma is processed by the rules, its associated lexical strings are manipulated to reflect the impact of inflectional morphology. The surface string of XFST lexical entries is the citation form specified in the XML lexicon. Figure 5 13 lists the XFST representation of the lexical entry of word whose XML representation was listed in figure 2. [+negation][+id]21542[+undotted] 5: The lexicon item of XFST 3.2 Morphological and orthographic rules In this section we discuss the set of rules which constitute the morphological grammar, i.e., the implementation of linguistic structures in XFST. The grammar includes hundreds of rules; we present a small sample, exemplifying the principles that govern the overall organization of the grammar. The linguistic information was collected from several sources (Barkali, 1962; Zdaqa, 1974; Alon, 1995; Cohen, 1996; Schwarzwald, 2001; Schwarzwald, 2002; Ornan, 2003). The grammar consists of specific rules for every part of speech category, which are applied to the appropriate lexicons. For each category, a variable is defined whose denotation is the set of all lexical entries of that category. Combined with the categoryspecific rules, we obtain morphological grammars for every category (not including idiosyncrasies). These grammars are too verbose on the lexical side, as they contain all the information that was listed in the lexicon. Filters are therefore applied to the lexical side to remove the unneeded information. Our rules support surface forms that are made of zero or more prefix particles, followed by a (possibly inflected) lexicon item. Figure 6 depicts the high-level organization of the grammar (recall from 2 that denotes composition). The varia union of all the possible inflections of the entire lexicon. Similarly, the set of all the possible sequences of prefixes. When the two are concatenated, they yield a language of all possible surface forms, vastly over-generating. On the upper side of this language a prefix particle filter is composed, which enforces linguistically motivated constraints on the possible combinations of prefixes with words. On top of this another filter is composed, which handles “cosmetic” changes, such as removing “book-keeping” tags. A similar filter is applied to the the lower side of the network. tagAffixesFilter .o. prefixesFilters .o. [ prefixes inflectedWord ] .o. removeTagsFilter Figure 6: A high level view of the analyzer As an example, consider the feminine singular form of adjectives, which is generated from the singular by adding a suffix, either it Some idiosyncratic forms have no masculine singular form, but do have a feminine singular form, example Therefore, as figure 7 shows, singular feminine adjectives are either extracted verbatim from the lexicon or generated from the singular masculine form by suffixation. The rule [ %+feminine &lt;- ?  ||%+gender _ ] the gender attribute to the inflected feminine forms. This is a special form of replace rule which replaces any symbol by multi-character symbol in the of occurring after The right is empty, meaning define feminineSingularAdjective [ [$[%+gender [%+feminine]] .o. adjective ] | [ %+feminine &lt;- ?  ||%+gender _ ] .o. [ sufH  |sufT  |sufIT ] ]; Figure 7: Feminine adjectives 8 shows how the suffix value of the is used in the inflection. The default not to add an additional the masculine adalready terminates with it, as in teacher”. This means that to this default, such as m” f”, are being improperly treated. Such forms are explicitly listed in the lexicon as idiosyncrasies (using the add/replace/remove mechanism), will be corrected at a later stage. The suffixes 14 handled in a similar way. define sufH [ [ [ $[%+feminine %+h] .o. masculineSingularAdjective ] [ 0 .x. addedHE ] ] .o. [ addedHE -&gt; 0  ||HE _ .#. ] .o. [ addedHE -&gt; HE ] ]; 8: Adding the suffix 9 shows how plural nouns with the suffix are processed. On the lower side some conditional alternations are performed before the suffix is The first alternation rule replaces the end of a word, ensuring that nouns wrttent a spurious as are properly as rather than The alternation rule removes final ensure that singular noun such as is properly into its plural form The third ensures nouns ending in as properly inflected as Of course, irnouns such as whose plural is than are lexically specified and separately. Finally, a final removed by the fourth rule, and subsequently the plural suffix is concatenated. define pluralWTNoun [ [ [ %+plural &lt;- %+singular  ||%+number _ ] .o. $[%+number %+singular] .o. $[%+plural %+wt] .o. noun .o. [ YOD YOD HE -&gt; YOD HE  ||_ .#. ] .o. [ ALEF YOD TAV -&gt; ALEF YOD  ||_ .#. ] .o. [ VAV TAV -&gt; VAV YOD  ||_ .#. ] .o. [ [HE|TAV] -&gt; 0  ||_ .#. ] ] [ 0 .x. [VAV TAV] ] ]; 9: Plural nouns with The above rules only superficially demonstrate the capabilities of our grammar. The bulk of the grammar consists of rules for inflecting verbs, including a complete coverage of the weak paradigms. The grammar also contains rules which govern the possible combinations of prefix particles and the words they combine with. 4 Conclusion We described a broad-coverage finite-state grammar of Modern Hebrew, consisting of two main components: a lexicon and a set of rules. The current underlying lexicon includes over 20,000 items. The average number of inflected forms for a lexicon item is 33 (not including prefix sequences). Due to the use of finite-state technology, the grammar can be used for generation or for analysis. It induces a very efficient morphological analyzer: in practice, over eighty words per second can be analyzed on a contemporary workstation. For lack of space we cannot fully demonstrate the output of the analyzer; refer back to figure 1 for an example. HAMSAH is now used for a number of projects, including as a front end for a Hebrew to English machine translation system (Lavie et al., 2004). It is routinely tested on a variety of texts, and tokens with zero analyses are being inspected manually. A systematic evaluation of the quality of the analyzer is difficult due to the lack of available alternative resources. Nevertheless, we conducted a small-scale evaluation experiment by asking two annotators to review the output produced by the analyzer for a randomly chosen set of newspaper articles comprising of approximately 1000 word tokens. The following table summarizes the results of this experiment. tokens no analysis no correct analysis correct analysis produced The majority of the missing analyses are due to outof-lexicon items, particularly proper names. In addition to maintenance and expansion of the lexicon, we intend to extend this work in two main directions. First, we are interested in automatic methods for expanding the lexicon, especially for named entities. Second, we are currently working on a disambiguation module which will rank the analyses produced by the grammar according to contextdependent criteria. Existing works on part-of-speech tagging and morphological disambiguation in Hebrew (Segal, 1999; Adler, 2004; Bar-Haim, 2005) leave much room for further research. Incorporating state-of-the-art machine learning techniques number % 959 100.00% 37 3.86% 41 4.28% 881 91.86% 15 for morphological disambiguation to the output produced by the analyzer will generate an optimal system which is broad-coverage, effective and accurate.</abstract>
<note confidence="0.927975272727273">Acknowledgments This work was funded by the Israeli Ministry of Science and Technology, under the auspices of the Knowledge Center for Processing Hebrew. We are grateful to Yael Cohen-Sygal, Shira Schwartz and Alon Itai for their help. References Meni Adler. 2004. Word-based statistical language modeling: Two-dimensional approach. Thesis proposal, Ben Gurion University, Beer Sheva, April. Alon. 1995. Hebrew Writing:</note>
<title confidence="0.8454965">Structure of Hebrew Words in Syntactic Ben-Gurion University of the Negev Press. In Hebrew.</title>
<author confidence="0.830487">Part-of-speech tagging for Hebrew</author>
<note confidence="0.944046407407408">and other Semitic languages. Master’s thesis, Computer Science Department, Technion, Haifa, Israel. Barkali. 1962. HaP’alim HaShalem (The Verbs Reuven Mass, Jerusalem. In Hebrew. R. Beesley and Lauri Karttunen. 2003. Finite- Morphology: Xerox Tools and CSLI, Stanford. Kenneth R. Beesley. 1996. Arabic finite-state moranalysis and generation. In of COLING-96, the 16th International Conference on Copenhagen. Kenneth R. Beesley. 1998. Arabic morphology using only finite-state operations. In Michael Rosner, edof the Workshop on Computational to Semitic pages 50–57, Montreal, Quebec, August. COLING-ACL’98. Kenneth R. Beesley. 2001. Finite-state morphological analysis and generation of Arabic at Xerox Research: and plans in 2001. In Workshop on Arabic Processing: Status and pages 1–8, Toulouse, France, July. Esther Bentur, Aviella Angel, Danit Segev, and Alon Lavie. 1992. Analysis and generation of the nouns inflection in Hebrew. In Uzzi Ornan, Gideon Arieli, Edit Doron, editors, Computational Linchapter 3, pages 36–38. Ministry of Science</note>
<abstract confidence="0.886123294117647">and Technology. In Hebrew. Yaacov Choueka. 1980. Computerized full-text retrieval systems and research in the humanities: The Responsa and the 14:153–169. Yaacov Choueka. 1990. MLIM a system for full, exact, on-line grammatical analysis of Modern Hebrew. In Eizenberg, editor, of the Annual on Computers in page 63, Tel Aviv, April. In Hebrew. Haim A. Cohen. 1996. klalei ha-ktiv xasar ha-niqqud. special edition, May. In Hebrew. Laura Kataja and Kimmo Koskenniemi. 1988. Finitestate description of Semitic morphology: A case study Ancient Akkadian. In pages 313–315. George Anton Kiraz. 2000. Multitiered nonlinear morphology using multitape finite automata: a case study Syriac and Arabic.</abstract>
<address confidence="0.802204">26(1):77–105, March. Koskenniemi. 1983. Morphology: a</address>
<affiliation confidence="0.839177666666667">General Computational Model for Word-Form Recogand The Department of General Linguistics, University of Helsinki.</affiliation>
<note confidence="0.907382">Alon Lavie, Alon Itai, Uzzi Ornan, and Mori Rimon. 1988. On the applicability of two-level morphology the inflection of Hebrew verbs. In of</note>
<affiliation confidence="0.520399">International Conference of the Jerusalem,</affiliation>
<address confidence="0.906771">Israel.</address>
<author confidence="0.962306">Alon Lavie</author>
<author confidence="0.962306">Shuly Wintner</author>
<author confidence="0.962306">Yaniv Eytani</author>
<author confidence="0.962306">Erik Peterson</author>
<abstract confidence="0.5535025">and Katharina Probst. 2004. Rapid prototyping of a transfer-based Hebrew-to-English machine translation</abstract>
<note confidence="0.828349740740741">In of TMI-2004: The 10th International Conference on Theoretical and Methodolog- Issues in Machine Baltimore, MD, October. Uzzi Ornan and Wadim Kazatski. 1986. Analysis and processes in Hebrew morphology. In Proceedings of the 21 National Data Processing Confer- In Hebrew. Ornan. 2003. Final University of Haifa Press, Haifa, Israel. In Hebrew. Schwarzwald. 2001. volume 127 of the LINCOM EU- ROPA. Schwarzwald. 2002. in Hebrew Morphol- The Open University of Israel. Erel Segal. 1997. Morphological analyzer for unvocalized hebrew words. Unpublished work, available Erel Segal. 1999. Hebrew morphological analyzer for Hebrew undotted texts. Master’s thesis, Technion, Israel Institute of Technology, Haifa, October. In Hebrew. Shuly Wintner. 2004. Hebrew computational linguis- Past and future. Intelligence 21(2):113–138. Zdaqa. 1974. HaPoal (The Verb Kiryath Sepher, Jerusalem. In Hebrew. 16</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Meni Adler</author>
</authors>
<title>Word-based statistical language modeling: Two-dimensional approach. Thesis proposal,</title>
<date>2004</date>
<institution>Ben Gurion University, Beer Sheva,</institution>
<marker>Adler, 2004</marker>
<rawString>Meni Adler. 2004. Word-based statistical language modeling: Two-dimensional approach. Thesis proposal, Ben Gurion University, Beer Sheva, April.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Emmanuel Alon</author>
</authors>
<title>Unvocalized Hebrew Writing: The Structure of Hebrew Words in Syntactic Context. Ben-Gurion University of the Negev Press. In Hebrew.</title>
<date>1995</date>
<contexts>
<context position="21699" citStr="Alon, 1995" startWordPosition="3392" endWordPosition="3393">lexical entry of the word bli, whose XML representation was listed in figure 2. [+negation][+id]21542[+undotted] [+translit]bli Figure 5: The lexicon item of bli in XFST 3.2 Morphological and orthographic rules In this section we discuss the set of rules which constitute the morphological grammar, i.e., the implementation of linguistic structures in XFST. The grammar includes hundreds of rules; we present a small sample, exemplifying the principles that govern the overall organization of the grammar. The linguistic information was collected from several sources (Barkali, 1962; Zdaqa, 1974; Alon, 1995; Cohen, 1996; Schwarzwald, 2001; Schwarzwald, 2002; Ornan, 2003). The grammar consists of specific rules for every part of speech category, which are applied to the appropriate lexicons. For each category, a variable is defined whose denotation is the set of all lexical entries of that category. Combined with the categoryspecific rules, we obtain morphological grammars for every category (not including idiosyncrasies). These grammars are too verbose on the lexical side, as they contain all the information that was listed in the lexicon. Filters are therefore applied to the lexical side to rem</context>
</contexts>
<marker>Alon, 1995</marker>
<rawString>Emmanuel Alon. 1995. Unvocalized Hebrew Writing: The Structure of Hebrew Words in Syntactic Context. Ben-Gurion University of the Negev Press. In Hebrew.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Roy Bar-Haim</author>
</authors>
<title>Part-of-speech tagging for Hebrew and other Semitic languages.</title>
<date>2005</date>
<tech>Master’s thesis,</tech>
<institution>Computer Science Department,</institution>
<location>Technion, Haifa,</location>
<marker>Bar-Haim, 2005</marker>
<rawString>Roy Bar-Haim. 2005. Part-of-speech tagging for Hebrew and other Semitic languages. Master’s thesis, Computer Science Department, Technion, Haifa, Israel.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Shaul Barkali</author>
</authors>
<title>Lux HaP’alim HaShalem (The Complete Verbs Table). Reuven Mass,</title>
<date>1962</date>
<location>Jerusalem. In Hebrew.</location>
<contexts>
<context position="21674" citStr="Barkali, 1962" startWordPosition="3388" endWordPosition="3389"> XFST representation of the lexical entry of the word bli, whose XML representation was listed in figure 2. [+negation][+id]21542[+undotted] [+translit]bli Figure 5: The lexicon item of bli in XFST 3.2 Morphological and orthographic rules In this section we discuss the set of rules which constitute the morphological grammar, i.e., the implementation of linguistic structures in XFST. The grammar includes hundreds of rules; we present a small sample, exemplifying the principles that govern the overall organization of the grammar. The linguistic information was collected from several sources (Barkali, 1962; Zdaqa, 1974; Alon, 1995; Cohen, 1996; Schwarzwald, 2001; Schwarzwald, 2002; Ornan, 2003). The grammar consists of specific rules for every part of speech category, which are applied to the appropriate lexicons. For each category, a variable is defined whose denotation is the set of all lexical entries of that category. Combined with the categoryspecific rules, we obtain morphological grammars for every category (not including idiosyncrasies). These grammars are too verbose on the lexical side, as they contain all the information that was listed in the lexicon. Filters are therefore applied t</context>
</contexts>
<marker>Barkali, 1962</marker>
<rawString>Shaul Barkali. 1962. Lux HaP’alim HaShalem (The Complete Verbs Table). Reuven Mass, Jerusalem. In Hebrew.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth R Beesley</author>
<author>Lauri Karttunen</author>
</authors>
<title>FiniteState Morphology: Xerox Tools and Techniques.</title>
<date>2003</date>
<location>CSLI, Stanford.</location>
<contexts>
<context position="7631" citStr="Beesley and Karttunen, 2003" startWordPosition="1220" endWordPosition="1223">limitation of existing approaches is that they are ad-hoc: the rules that govern word formation and inflection are only implicit in such systems, usually intertwined with control structures and general code. This makes the maintenance of such systems difficult: corrections, modifications and extensions of the lexicon are nearly impossible. An additional drawback is that all existing systems can be used for analysis but not for generation. Finally, the efficiency of such systems depends on the quality of the code, and is sometimes sub-optimal. 2 Finite-state technology Finite-state technology (Beesley and Karttunen, 2003) solves the three problems elegantly. It provides a language of extended regular expressions which can be used to define very natural linguistically motivated grammar rules. Such expressions can then be compiled into finite-state networks (automata and transducers), on which efficient algorithms can be applied to implement both analysis and generation. Using this methodology, a computational linguist can design rules which closely follow standard linguistic notation, and automatically ob10 tain a highly efficient morphological processor. While the original Two-Level formulation (Koskenniemi, 1</context>
<context position="8975" citStr="Beesley and Karttunen, 2003" startWordPosition="1412" endWordPosition="1416">1988), modifications of the Two-Level paradigm and more advanced finite-state implementations have been applied successfully to a variety of Semitic languages, including Ancient Akkadian (Kataja and Koskenniemi, 1988), Syriac (Kiraz, 2000) and Arabic. In a number of works, Beesley (1996; 1998; 2001) describes a finite-state morphological analyzer of Modern Standard Arabic which handles both inflectional and derivational morphology, including interdigitation. In the following section we focus on a particular finite-state toolbox which was successfully used for Arabic. In this work we use XFST (Beesley and Karttunen, 2003), an extended regular expression language augmented by a sophisticated implementation of several finite-state algorithms, which can be used to compactly store and process very large-scale networks. XFST grammars define a binary relation (a transduction) on sets of strings: a grammar maps each member of a (possibly infinite) set of strings, known as the surface, or lower language, to a set of strings (the lexical, or upper language). The idea is that the surface language defines all and only the grammatical words in the language; and each grammatical word is associated with a set of lexical str</context>
</contexts>
<marker>Beesley, Karttunen, 2003</marker>
<rawString>Kenneth R. Beesley and Lauri Karttunen. 2003. FiniteState Morphology: Xerox Tools and Techniques. CSLI, Stanford.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth R Beesley</author>
</authors>
<title>Arabic finite-state morphological analysis and generation.</title>
<date>1996</date>
<booktitle>In Proceedings of COLING-96, the 16th International Conference on Computational Linguistics,</booktitle>
<location>Copenhagen.</location>
<contexts>
<context position="8634" citStr="Beesley (1996" startWordPosition="1367" endWordPosition="1368">onal linguist can design rules which closely follow standard linguistic notation, and automatically ob10 tain a highly efficient morphological processor. While the original Two-Level formulation (Koskenniemi, 1983) of finite-state technology for morphology was not particularly well suited to Semitic languages (Lavie et al., 1988), modifications of the Two-Level paradigm and more advanced finite-state implementations have been applied successfully to a variety of Semitic languages, including Ancient Akkadian (Kataja and Koskenniemi, 1988), Syriac (Kiraz, 2000) and Arabic. In a number of works, Beesley (1996; 1998; 2001) describes a finite-state morphological analyzer of Modern Standard Arabic which handles both inflectional and derivational morphology, including interdigitation. In the following section we focus on a particular finite-state toolbox which was successfully used for Arabic. In this work we use XFST (Beesley and Karttunen, 2003), an extended regular expression language augmented by a sophisticated implementation of several finite-state algorithms, which can be used to compactly store and process very large-scale networks. XFST grammars define a binary relation (a transduction) on se</context>
</contexts>
<marker>Beesley, 1996</marker>
<rawString>Kenneth R. Beesley. 1996. Arabic finite-state morphological analysis and generation. In Proceedings of COLING-96, the 16th International Conference on Computational Linguistics, Copenhagen.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth R Beesley</author>
</authors>
<title>Arabic morphology using only finite-state operations.</title>
<date>1998</date>
<booktitle>Proceedings of the Workshop on Computational Approaches to Semitic languages,</booktitle>
<pages>50--57</pages>
<editor>In Michael Rosner, editor,</editor>
<location>Montreal, Quebec,</location>
<marker>Beesley, 1998</marker>
<rawString>Kenneth R. Beesley. 1998. Arabic morphology using only finite-state operations. In Michael Rosner, editor, Proceedings of the Workshop on Computational Approaches to Semitic languages, pages 50–57, Montreal, Quebec, August. COLING-ACL’98.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth R Beesley</author>
</authors>
<title>Finite-state morphological analysis and generation of Arabic at Xerox Research: Status and plans in</title>
<date>2001</date>
<booktitle>In ACL Workshop on Arabic Language Processing: Status and Perspective,</booktitle>
<pages>1--8</pages>
<location>Toulouse, France,</location>
<marker>Beesley, 2001</marker>
<rawString>Kenneth R. Beesley. 2001. Finite-state morphological analysis and generation of Arabic at Xerox Research: Status and plans in 2001. In ACL Workshop on Arabic Language Processing: Status and Perspective, pages 1–8, Toulouse, France, July.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Esther Bentur</author>
<author>Aviella Angel</author>
<author>Danit Segev</author>
<author>Alon Lavie</author>
</authors>
<title>Analysis and generation of the nouns inflection in Hebrew.</title>
<date>1992</date>
<booktitle>In Uzzi Ornan, Gideon Arieli, and Edit Doron, editors, Hebrew Computational Linguistics, chapter 3,</booktitle>
<pages>36--38</pages>
<contexts>
<context position="6868" citStr="Bentur et al. (1992)" startWordPosition="1103" endWordPosition="1106">ms is not a viable option, both because of the huge number of potential forms and because of the complete inability of such an approach to handle out-of-lexicon items; the number of such items in Hebrew is significantly larger than in European languages due to the combination of prefix particles with open-class words such as proper names. The solution must be a dedicated morphological analyzer, implementing the morphological and orthographic rules of the language. Several morphological processors of Hebrew have been proposed, including works by Choueka (1980; 1990), Ornan and Kazatski (1986), Bentur et al. (1992) and Segal (1997); see a survey in Wintner (2004). Most of them are proprietary and hence cannot be fully evaluated. However, the main limitation of existing approaches is that they are ad-hoc: the rules that govern word formation and inflection are only implicit in such systems, usually intertwined with control structures and general code. This makes the maintenance of such systems difficult: corrections, modifications and extensions of the lexicon are nearly impossible. An additional drawback is that all existing systems can be used for analysis but not for generation. Finally, the efficienc</context>
</contexts>
<marker>Bentur, Angel, Segev, Lavie, 1992</marker>
<rawString>Esther Bentur, Aviella Angel, Danit Segev, and Alon Lavie. 1992. Analysis and generation of the nouns inflection in Hebrew. In Uzzi Ornan, Gideon Arieli, and Edit Doron, editors, Hebrew Computational Linguistics, chapter 3, pages 36–38. Ministry of Science and Technology. In Hebrew.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yaacov Choueka</author>
</authors>
<title>Computerized full-text retrieval systems and research in the humanities:</title>
<date>1980</date>
<booktitle>The Responsa project. Computers and the Humanities,</booktitle>
<pages>14--153</pages>
<contexts>
<context position="6812" citStr="Choueka (1980" startWordPosition="1096" endWordPosition="1097">rve that simply stipulating a list of surface forms is not a viable option, both because of the huge number of potential forms and because of the complete inability of such an approach to handle out-of-lexicon items; the number of such items in Hebrew is significantly larger than in European languages due to the combination of prefix particles with open-class words such as proper names. The solution must be a dedicated morphological analyzer, implementing the morphological and orthographic rules of the language. Several morphological processors of Hebrew have been proposed, including works by Choueka (1980; 1990), Ornan and Kazatski (1986), Bentur et al. (1992) and Segal (1997); see a survey in Wintner (2004). Most of them are proprietary and hence cannot be fully evaluated. However, the main limitation of existing approaches is that they are ad-hoc: the rules that govern word formation and inflection are only implicit in such systems, usually intertwined with control structures and general code. This makes the maintenance of such systems difficult: corrections, modifications and extensions of the lexicon are nearly impossible. An additional drawback is that all existing systems can be used for</context>
</contexts>
<marker>Choueka, 1980</marker>
<rawString>Yaacov Choueka. 1980. Computerized full-text retrieval systems and research in the humanities: The Responsa project. Computers and the Humanities, 14:153–169.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yaacov Choueka</author>
</authors>
<title>MLIM - a system for full, exact, on-line grammatical analysis of Modern Hebrew.</title>
<date>1990</date>
<booktitle>In Yehuda Eizenberg, editor, Proceedings of the Annual Conference on Computers in Education, page 63, Tel Aviv, April. In Hebrew.</booktitle>
<marker>Choueka, 1990</marker>
<rawString>Yaacov Choueka. 1990. MLIM - a system for full, exact, on-line grammatical analysis of Modern Hebrew. In Yehuda Eizenberg, editor, Proceedings of the Annual Conference on Computers in Education, page 63, Tel Aviv, April. In Hebrew.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Haim A Cohen</author>
</authors>
<title>klalei ha-ktiv xasar ha-niqqud. leshonenu la&amp;am, special edition, May. In Hebrew.</title>
<date>1996</date>
<contexts>
<context position="21712" citStr="Cohen, 1996" startWordPosition="3394" endWordPosition="3395">y of the word bli, whose XML representation was listed in figure 2. [+negation][+id]21542[+undotted] [+translit]bli Figure 5: The lexicon item of bli in XFST 3.2 Morphological and orthographic rules In this section we discuss the set of rules which constitute the morphological grammar, i.e., the implementation of linguistic structures in XFST. The grammar includes hundreds of rules; we present a small sample, exemplifying the principles that govern the overall organization of the grammar. The linguistic information was collected from several sources (Barkali, 1962; Zdaqa, 1974; Alon, 1995; Cohen, 1996; Schwarzwald, 2001; Schwarzwald, 2002; Ornan, 2003). The grammar consists of specific rules for every part of speech category, which are applied to the appropriate lexicons. For each category, a variable is defined whose denotation is the set of all lexical entries of that category. Combined with the categoryspecific rules, we obtain morphological grammars for every category (not including idiosyncrasies). These grammars are too verbose on the lexical side, as they contain all the information that was listed in the lexicon. Filters are therefore applied to the lexical side to remove the unnee</context>
</contexts>
<marker>Cohen, 1996</marker>
<rawString>Haim A. Cohen. 1996. klalei ha-ktiv xasar ha-niqqud. leshonenu la&amp;am, special edition, May. In Hebrew.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Laura Kataja</author>
<author>Kimmo Koskenniemi</author>
</authors>
<title>Finitestate description of Semitic morphology: A case study of Ancient Akkadian. In</title>
<date>1988</date>
<booktitle>COLING,</booktitle>
<pages>313--315</pages>
<contexts>
<context position="8564" citStr="Kataja and Koskenniemi, 1988" startWordPosition="1353" endWordPosition="1356">applied to implement both analysis and generation. Using this methodology, a computational linguist can design rules which closely follow standard linguistic notation, and automatically ob10 tain a highly efficient morphological processor. While the original Two-Level formulation (Koskenniemi, 1983) of finite-state technology for morphology was not particularly well suited to Semitic languages (Lavie et al., 1988), modifications of the Two-Level paradigm and more advanced finite-state implementations have been applied successfully to a variety of Semitic languages, including Ancient Akkadian (Kataja and Koskenniemi, 1988), Syriac (Kiraz, 2000) and Arabic. In a number of works, Beesley (1996; 1998; 2001) describes a finite-state morphological analyzer of Modern Standard Arabic which handles both inflectional and derivational morphology, including interdigitation. In the following section we focus on a particular finite-state toolbox which was successfully used for Arabic. In this work we use XFST (Beesley and Karttunen, 2003), an extended regular expression language augmented by a sophisticated implementation of several finite-state algorithms, which can be used to compactly store and process very large-scale n</context>
</contexts>
<marker>Kataja, Koskenniemi, 1988</marker>
<rawString>Laura Kataja and Kimmo Koskenniemi. 1988. Finitestate description of Semitic morphology: A case study of Ancient Akkadian. In COLING, pages 313–315.</rawString>
</citation>
<citation valid="true">
<authors>
<author>George Anton Kiraz</author>
</authors>
<title>Multitiered nonlinear morphology using multitape finite automata: a case study on Syriac and Arabic.</title>
<date>2000</date>
<journal>Computational Linguistics,</journal>
<volume>26</volume>
<issue>1</issue>
<contexts>
<context position="8586" citStr="Kiraz, 2000" startWordPosition="1358" endWordPosition="1359">generation. Using this methodology, a computational linguist can design rules which closely follow standard linguistic notation, and automatically ob10 tain a highly efficient morphological processor. While the original Two-Level formulation (Koskenniemi, 1983) of finite-state technology for morphology was not particularly well suited to Semitic languages (Lavie et al., 1988), modifications of the Two-Level paradigm and more advanced finite-state implementations have been applied successfully to a variety of Semitic languages, including Ancient Akkadian (Kataja and Koskenniemi, 1988), Syriac (Kiraz, 2000) and Arabic. In a number of works, Beesley (1996; 1998; 2001) describes a finite-state morphological analyzer of Modern Standard Arabic which handles both inflectional and derivational morphology, including interdigitation. In the following section we focus on a particular finite-state toolbox which was successfully used for Arabic. In this work we use XFST (Beesley and Karttunen, 2003), an extended regular expression language augmented by a sophisticated implementation of several finite-state algorithms, which can be used to compactly store and process very large-scale networks. XFST grammars</context>
</contexts>
<marker>Kiraz, 2000</marker>
<rawString>George Anton Kiraz. 2000. Multitiered nonlinear morphology using multitape finite automata: a case study on Syriac and Arabic. Computational Linguistics, 26(1):77–105, March.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kimmo Koskenniemi</author>
</authors>
<title>Two-Level Morphology: a General Computational Model for Word-Form Recognition and Production. The Department of General Linguistics,</title>
<date>1983</date>
<institution>University of Helsinki.</institution>
<contexts>
<context position="8235" citStr="Koskenniemi, 1983" startWordPosition="1309" endWordPosition="1310">rttunen, 2003) solves the three problems elegantly. It provides a language of extended regular expressions which can be used to define very natural linguistically motivated grammar rules. Such expressions can then be compiled into finite-state networks (automata and transducers), on which efficient algorithms can be applied to implement both analysis and generation. Using this methodology, a computational linguist can design rules which closely follow standard linguistic notation, and automatically ob10 tain a highly efficient morphological processor. While the original Two-Level formulation (Koskenniemi, 1983) of finite-state technology for morphology was not particularly well suited to Semitic languages (Lavie et al., 1988), modifications of the Two-Level paradigm and more advanced finite-state implementations have been applied successfully to a variety of Semitic languages, including Ancient Akkadian (Kataja and Koskenniemi, 1988), Syriac (Kiraz, 2000) and Arabic. In a number of works, Beesley (1996; 1998; 2001) describes a finite-state morphological analyzer of Modern Standard Arabic which handles both inflectional and derivational morphology, including interdigitation. In the following section </context>
</contexts>
<marker>Koskenniemi, 1983</marker>
<rawString>Kimmo Koskenniemi. 1983. Two-Level Morphology: a General Computational Model for Word-Form Recognition and Production. The Department of General Linguistics, University of Helsinki.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alon Lavie</author>
<author>Alon Itai</author>
<author>Uzzi Ornan</author>
<author>Mori Rimon</author>
</authors>
<title>On the applicability of two-level morphology to the inflection of Hebrew verbs.</title>
<date>1988</date>
<booktitle>In Proceedings of the International Conference of the ALLC,</booktitle>
<location>Jerusalem, Israel.</location>
<contexts>
<context position="8352" citStr="Lavie et al., 1988" startWordPosition="1324" endWordPosition="1327"> be used to define very natural linguistically motivated grammar rules. Such expressions can then be compiled into finite-state networks (automata and transducers), on which efficient algorithms can be applied to implement both analysis and generation. Using this methodology, a computational linguist can design rules which closely follow standard linguistic notation, and automatically ob10 tain a highly efficient morphological processor. While the original Two-Level formulation (Koskenniemi, 1983) of finite-state technology for morphology was not particularly well suited to Semitic languages (Lavie et al., 1988), modifications of the Two-Level paradigm and more advanced finite-state implementations have been applied successfully to a variety of Semitic languages, including Ancient Akkadian (Kataja and Koskenniemi, 1988), Syriac (Kiraz, 2000) and Arabic. In a number of works, Beesley (1996; 1998; 2001) describes a finite-state morphological analyzer of Modern Standard Arabic which handles both inflectional and derivational morphology, including interdigitation. In the following section we focus on a particular finite-state toolbox which was successfully used for Arabic. In this work we use XFST (Beesl</context>
</contexts>
<marker>Lavie, Itai, Ornan, Rimon, 1988</marker>
<rawString>Alon Lavie, Alon Itai, Uzzi Ornan, and Mori Rimon. 1988. On the applicability of two-level morphology to the inflection of Hebrew verbs. In Proceedings of the International Conference of the ALLC, Jerusalem, Israel.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alon Lavie</author>
<author>Shuly Wintner</author>
<author>Yaniv Eytani</author>
<author>Erik Peterson</author>
<author>Katharina Probst</author>
</authors>
<title>Rapid prototyping of a transfer-based Hebrew-to-English machine translation system.</title>
<date>2004</date>
<booktitle>In Proceedings of TMI-2004: The 10th International Conference on Theoretical and Methodological Issues in Machine Translation,</booktitle>
<location>Baltimore, MD,</location>
<contexts>
<context position="14474" citStr="Lavie et al. (2004)" startWordPosition="2237" endWordPosition="2240">ly can use this information: if nouns is an XFST variable denoting the set of all nouns, then the expression $[number %+plural] .o. nouns denotes only the plural nouns. Once all linguistic processing is complete, “book-keeping” tags are erased. 3 A morphological grammar of Hebrew The importance of morphological analysis as a preliminary phase in a variety of natural language processing applications cannot be over-estimated. The lack of good morphological analysis and disambiguation systems for Hebrew is reported as one of the main bottlenecks of a Hebrew to English machine translation system (Lavie et al. (2004)). The contribution of our system is manyfold: • HAMSAH is the broadest-coverage and most accurate publicly available morphological analyzer of Modern Hebrew. It is based on a lexicon of over 20,000 entries, which is constantly being updated and expanded, and its set of rules cover all the morphological, morphophonological and orthographic phenomena observed in contemporary Hebrew texts. Compared to Segal (1997), our rules are probably similar in coverage but our lexicon is significantly larger. HAMSAH also supports nonstandard spellings which are excluded from the work of Segal (1997). • The </context>
<context position="27312" citStr="Lavie et al., 2004" startWordPosition="4341" endWordPosition="4344">includes over 20,000 items. The average number of inflected forms for a lexicon item is 33 (not including prefix sequences). Due to the use of finite-state technology, the grammar can be used for generation or for analysis. It induces a very efficient morphological analyzer: in practice, over eighty words per second can be analyzed on a contemporary workstation. For lack of space we cannot fully demonstrate the output of the analyzer; refer back to figure 1 for an example. HAMSAH is now used for a number of projects, including as a front end for a Hebrew to English machine translation system (Lavie et al., 2004). It is routinely tested on a variety of texts, and tokens with zero analyses are being inspected manually. A systematic evaluation of the quality of the analyzer is difficult due to the lack of available alternative resources. Nevertheless, we conducted a small-scale evaluation experiment by asking two annotators to review the output produced by the analyzer for a randomly chosen set of newspaper articles comprising of approximately 1000 word tokens. The following table summarizes the results of this experiment. tokens no analysis no correct analysis correct analysis produced The majority of </context>
</contexts>
<marker>Lavie, Wintner, Eytani, Peterson, Probst, 2004</marker>
<rawString>Alon Lavie, Shuly Wintner, Yaniv Eytani, Erik Peterson, and Katharina Probst. 2004. Rapid prototyping of a transfer-based Hebrew-to-English machine translation system. In Proceedings of TMI-2004: The 10th International Conference on Theoretical and Methodological Issues in Machine Translation, Baltimore, MD, October.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Uzzi Ornan</author>
<author>Wadim Kazatski</author>
</authors>
<title>Analysis and synthesis processes in Hebrew morphology.</title>
<date>1986</date>
<booktitle>In Proceedings of the 21 National Data Processing Conference. In Hebrew.</booktitle>
<contexts>
<context position="6846" citStr="Ornan and Kazatski (1986)" startWordPosition="1099" endWordPosition="1102">ating a list of surface forms is not a viable option, both because of the huge number of potential forms and because of the complete inability of such an approach to handle out-of-lexicon items; the number of such items in Hebrew is significantly larger than in European languages due to the combination of prefix particles with open-class words such as proper names. The solution must be a dedicated morphological analyzer, implementing the morphological and orthographic rules of the language. Several morphological processors of Hebrew have been proposed, including works by Choueka (1980; 1990), Ornan and Kazatski (1986), Bentur et al. (1992) and Segal (1997); see a survey in Wintner (2004). Most of them are proprietary and hence cannot be fully evaluated. However, the main limitation of existing approaches is that they are ad-hoc: the rules that govern word formation and inflection are only implicit in such systems, usually intertwined with control structures and general code. This makes the maintenance of such systems difficult: corrections, modifications and extensions of the lexicon are nearly impossible. An additional drawback is that all existing systems can be used for analysis but not for generation. </context>
</contexts>
<marker>Ornan, Kazatski, 1986</marker>
<rawString>Uzzi Ornan and Wadim Kazatski. 1986. Analysis and synthesis processes in Hebrew morphology. In Proceedings of the 21 National Data Processing Conference. In Hebrew.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Uzzi Ornan</author>
</authors>
<title>The Final Word.</title>
<date>2003</date>
<publisher>University of Haifa Press,</publisher>
<location>Haifa, Israel. In Hebrew.</location>
<contexts>
<context position="21764" citStr="Ornan, 2003" startWordPosition="3400" endWordPosition="3401">ted in figure 2. [+negation][+id]21542[+undotted] [+translit]bli Figure 5: The lexicon item of bli in XFST 3.2 Morphological and orthographic rules In this section we discuss the set of rules which constitute the morphological grammar, i.e., the implementation of linguistic structures in XFST. The grammar includes hundreds of rules; we present a small sample, exemplifying the principles that govern the overall organization of the grammar. The linguistic information was collected from several sources (Barkali, 1962; Zdaqa, 1974; Alon, 1995; Cohen, 1996; Schwarzwald, 2001; Schwarzwald, 2002; Ornan, 2003). The grammar consists of specific rules for every part of speech category, which are applied to the appropriate lexicons. For each category, a variable is defined whose denotation is the set of all lexical entries of that category. Combined with the categoryspecific rules, we obtain morphological grammars for every category (not including idiosyncrasies). These grammars are too verbose on the lexical side, as they contain all the information that was listed in the lexicon. Filters are therefore applied to the lexical side to remove the unneeded information. Our rules support surface forms tha</context>
</contexts>
<marker>Ornan, 2003</marker>
<rawString>Uzzi Ornan. 2003. The Final Word. University of Haifa Press, Haifa, Israel. In Hebrew.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ora Schwarzwald</author>
</authors>
<title>Moden Hebrew, volume 127 of Languages of the World/Materials.</title>
<date>2001</date>
<publisher>LINCOM EUROPA.</publisher>
<contexts>
<context position="21731" citStr="Schwarzwald, 2001" startWordPosition="3396" endWordPosition="3397"> bli, whose XML representation was listed in figure 2. [+negation][+id]21542[+undotted] [+translit]bli Figure 5: The lexicon item of bli in XFST 3.2 Morphological and orthographic rules In this section we discuss the set of rules which constitute the morphological grammar, i.e., the implementation of linguistic structures in XFST. The grammar includes hundreds of rules; we present a small sample, exemplifying the principles that govern the overall organization of the grammar. The linguistic information was collected from several sources (Barkali, 1962; Zdaqa, 1974; Alon, 1995; Cohen, 1996; Schwarzwald, 2001; Schwarzwald, 2002; Ornan, 2003). The grammar consists of specific rules for every part of speech category, which are applied to the appropriate lexicons. For each category, a variable is defined whose denotation is the set of all lexical entries of that category. Combined with the categoryspecific rules, we obtain morphological grammars for every category (not including idiosyncrasies). These grammars are too verbose on the lexical side, as they contain all the information that was listed in the lexicon. Filters are therefore applied to the lexical side to remove the unneeded information. Ou</context>
</contexts>
<marker>Schwarzwald, 2001</marker>
<rawString>Ora Schwarzwald. 2001. Moden Hebrew, volume 127 of Languages of the World/Materials. LINCOM EUROPA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ora Schwarzwald</author>
</authors>
<title>Studies in Hebrew Morphology. The Open</title>
<date>2002</date>
<institution>University of Israel.</institution>
<contexts>
<context position="21750" citStr="Schwarzwald, 2002" startWordPosition="3398" endWordPosition="3399">resentation was listed in figure 2. [+negation][+id]21542[+undotted] [+translit]bli Figure 5: The lexicon item of bli in XFST 3.2 Morphological and orthographic rules In this section we discuss the set of rules which constitute the morphological grammar, i.e., the implementation of linguistic structures in XFST. The grammar includes hundreds of rules; we present a small sample, exemplifying the principles that govern the overall organization of the grammar. The linguistic information was collected from several sources (Barkali, 1962; Zdaqa, 1974; Alon, 1995; Cohen, 1996; Schwarzwald, 2001; Schwarzwald, 2002; Ornan, 2003). The grammar consists of specific rules for every part of speech category, which are applied to the appropriate lexicons. For each category, a variable is defined whose denotation is the set of all lexical entries of that category. Combined with the categoryspecific rules, we obtain morphological grammars for every category (not including idiosyncrasies). These grammars are too verbose on the lexical side, as they contain all the information that was listed in the lexicon. Filters are therefore applied to the lexical side to remove the unneeded information. Our rules support sur</context>
</contexts>
<marker>Schwarzwald, 2002</marker>
<rawString>Ora Schwarzwald. 2002. Studies in Hebrew Morphology. The Open University of Israel.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Erel Segal</author>
</authors>
<title>Morphological analyzer for unvocalized hebrew words.</title>
<date>1997</date>
<note>Unpublished work, available from http://www.cs.technion.ac.il/-˜erelsgl/hmntx.zip.</note>
<contexts>
<context position="6885" citStr="Segal (1997)" startWordPosition="1108" endWordPosition="1109">, both because of the huge number of potential forms and because of the complete inability of such an approach to handle out-of-lexicon items; the number of such items in Hebrew is significantly larger than in European languages due to the combination of prefix particles with open-class words such as proper names. The solution must be a dedicated morphological analyzer, implementing the morphological and orthographic rules of the language. Several morphological processors of Hebrew have been proposed, including works by Choueka (1980; 1990), Ornan and Kazatski (1986), Bentur et al. (1992) and Segal (1997); see a survey in Wintner (2004). Most of them are proprietary and hence cannot be fully evaluated. However, the main limitation of existing approaches is that they are ad-hoc: the rules that govern word formation and inflection are only implicit in such systems, usually intertwined with control structures and general code. This makes the maintenance of such systems difficult: corrections, modifications and extensions of the lexicon are nearly impossible. An additional drawback is that all existing systems can be used for analysis but not for generation. Finally, the efficiency of such systems</context>
<context position="14889" citStr="Segal (1997)" startWordPosition="2305" endWordPosition="2306">ated. The lack of good morphological analysis and disambiguation systems for Hebrew is reported as one of the main bottlenecks of a Hebrew to English machine translation system (Lavie et al. (2004)). The contribution of our system is manyfold: • HAMSAH is the broadest-coverage and most accurate publicly available morphological analyzer of Modern Hebrew. It is based on a lexicon of over 20,000 entries, which is constantly being updated and expanded, and its set of rules cover all the morphological, morphophonological and orthographic phenomena observed in contemporary Hebrew texts. Compared to Segal (1997), our rules are probably similar in coverage but our lexicon is significantly larger. HAMSAH also supports nonstandard spellings which are excluded from the work of Segal (1997). • The system is fully reversible: it can be used both for analysis and for generation. • Due to the use of finite-state technology, the system is highly efficient. While the network has close to 2 million states and over 2 million arcs, its compiled size is approximately 4Mb and analysis is extremely fast (between 50 and 100 words per second). • Morphological knowledge is expressed through linguistically motivated rul</context>
</contexts>
<marker>Segal, 1997</marker>
<rawString>Erel Segal. 1997. Morphological analyzer for unvocalized hebrew words. Unpublished work, available from http://www.cs.technion.ac.il/-˜erelsgl/hmntx.zip.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Erel Segal</author>
</authors>
<title>Hebrew morphological analyzer for Hebrew undotted texts.</title>
<date>1999</date>
<booktitle>Master’s thesis, Technion, Israel Institute of Technology,</booktitle>
<location>Haifa,</location>
<marker>Segal, 1999</marker>
<rawString>Erel Segal. 1999. Hebrew morphological analyzer for Hebrew undotted texts. Master’s thesis, Technion, Israel Institute of Technology, Haifa, October. In Hebrew.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Shuly Wintner</author>
</authors>
<title>Hebrew computational linguistics: Past and future.</title>
<date>2004</date>
<journal>Artificial Intelligence Review,</journal>
<volume>21</volume>
<issue>2</issue>
<contexts>
<context position="6917" citStr="Wintner (2004)" startWordPosition="1114" endWordPosition="1115">ber of potential forms and because of the complete inability of such an approach to handle out-of-lexicon items; the number of such items in Hebrew is significantly larger than in European languages due to the combination of prefix particles with open-class words such as proper names. The solution must be a dedicated morphological analyzer, implementing the morphological and orthographic rules of the language. Several morphological processors of Hebrew have been proposed, including works by Choueka (1980; 1990), Ornan and Kazatski (1986), Bentur et al. (1992) and Segal (1997); see a survey in Wintner (2004). Most of them are proprietary and hence cannot be fully evaluated. However, the main limitation of existing approaches is that they are ad-hoc: the rules that govern word formation and inflection are only implicit in such systems, usually intertwined with control structures and general code. This makes the maintenance of such systems difficult: corrections, modifications and extensions of the lexicon are nearly impossible. An additional drawback is that all existing systems can be used for analysis but not for generation. Finally, the efficiency of such systems depends on the quality of the c</context>
</contexts>
<marker>Wintner, 2004</marker>
<rawString>Shuly Wintner. 2004. Hebrew computational linguistics: Past and future. Artificial Intelligence Review, 21(2):113–138.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yizxaq Zdaqa</author>
</authors>
<title>Luxot HaPoal (The Verb Tables). Kiryath Sepher,</title>
<date>1974</date>
<location>Jerusalem. In Hebrew.</location>
<contexts>
<context position="21687" citStr="Zdaqa, 1974" startWordPosition="3390" endWordPosition="3391">ation of the lexical entry of the word bli, whose XML representation was listed in figure 2. [+negation][+id]21542[+undotted] [+translit]bli Figure 5: The lexicon item of bli in XFST 3.2 Morphological and orthographic rules In this section we discuss the set of rules which constitute the morphological grammar, i.e., the implementation of linguistic structures in XFST. The grammar includes hundreds of rules; we present a small sample, exemplifying the principles that govern the overall organization of the grammar. The linguistic information was collected from several sources (Barkali, 1962; Zdaqa, 1974; Alon, 1995; Cohen, 1996; Schwarzwald, 2001; Schwarzwald, 2002; Ornan, 2003). The grammar consists of specific rules for every part of speech category, which are applied to the appropriate lexicons. For each category, a variable is defined whose denotation is the set of all lexical entries of that category. Combined with the categoryspecific rules, we obtain morphological grammars for every category (not including idiosyncrasies). These grammars are too verbose on the lexical side, as they contain all the information that was listed in the lexicon. Filters are therefore applied to the lexical</context>
</contexts>
<marker>Zdaqa, 1974</marker>
<rawString>Yizxaq Zdaqa. 1974. Luxot HaPoal (The Verb Tables). Kiryath Sepher, Jerusalem. In Hebrew.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>