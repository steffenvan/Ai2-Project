<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.002137">
<title confidence="0.999497">
Current Issues in Software Engineering
for Natural Language Processing
</title>
<author confidence="0.995417">
Jochen L. Leidner
</author>
<affiliation confidence="0.856664">
School of Informatics, University of Edinburgh,
2 Buccleuch Place, Edinburgh EH8 9LW, Scotland, UK.
</affiliation>
<email confidence="0.992598">
jochen.leidner@ed.ac.uk
</email>
<bodyText confidence="0.989126705882353">
Abstract
In Natural Language Processing (NLP), research re-
sults from software engineering and software tech-
nology have often been neglected.
This paper describes some factors that add complex-
ity to the task of engineering reusable NLP systems
(beyond conventional software systems). Current
work in the area of design patterns and composi-
tion languages is described and claimed relevant for
natural language processing. The benefits of NLP
componentware and barriers to reuse are outlined,
and the dichotomies “system versus experiment” and
“toolkit versus framework” are discussed.
It is argued that in order to live up to its name lan- Figure 1: Dimensions of Language Engineering Com-
guage engineering must not neglect component qual- plexity.
ity and architectural evaluation when reporting new
NLP research.
</bodyText>
<sectionHeader confidence="0.999129" genericHeader="abstract">
1 Introduction
</sectionHeader>
<bodyText confidence="0.990013694915254">
It is notoriously difficult to construct conven-
tional software systems systematically and timely
(Sommerville, 2001), with up to 20% of industrial
development projects failing. For Natural Language
Processing (NLP) applications, the author is not aware
of any studies that estimate project failure rate. The risks
of failure seem even higher in this area, because the
language engineer faces additional complexity (Figure
1):
Accuracy. A fundamental difference between NLP
systems and conventional software is the incompleteness
property: since current language processing techniques
can never guarantee to provide all and only the correct
results, the whole system design is affected by having
to take this into account and providing appropriate fall-
backs.
Efficiency. Human users are very demanding:
(Shneiderman, 1997) reports that system response times
4s can render a system unacceptable. It is also debated
in which scenarios natural language interaction with ma-
chines is superior to menus, keyboard commands or other
means. To date, it unclear how efficiently NLP systems
can be, since efficiency is not a top priority in research
and many questions related to software design and tech-
nology are often considered a mere `implementation de-
tail”. This is in contrast to other areas of computing,
where data structures and algorithms are often carefully
selected and customized to be of maximum gain for a do-
main, and learning how to partition a problem into classes
is seen as part of the knowledge acquisition process of at-
tacking a problem.
Productivity. Time is a very scarce resource. Research
environments often produce prototypes that demonstrate
the feasibility of a method and leave efficient and
more complete implementation to industrial exploitation.
However, because in industry time is even more press-
ing, the re-implementation (from prototype to `produc-
tion system”) often doesn’t happen. In research, produc-
tivity loss occurs because of lack of knowledge of exist-
ing resources, lack of trust in non-in-house components,
or the inability to install or integrate existing software.
Price or licensing concerns also play a role. It is argued
here that software engineering techniques can improve
overall productivity of researchers after some little initial
investment. Section 3 relates short-term productivity to
long-term gains to the choice between building a frame-
work and carrying out an experiment.
Flexibility. Like any software, NLP systems need to
be flexible: a parser developed primarily to analyze writ-
ten online newspaper text might well be employed tomor-
row to process business e-mails. Different data formats
have to be handled, so representational and input/output
knowledge needs to be factored out from core linguis-
tic processing knowledge. Section 2.7 describes how de-
sign patterns can help NLP in this regard, and Section 2.2
gives an example of how componentization leads to more
flexibility.
Robustness. In engineering, robustness refers to a de-
vice’s ability to work even under varying conditions. In
language engineering, the terms robustness and portabil-
ity have obtained a more narrow meaning: both are typi-
cally used to describe the viability of a linguistic method
when applied across different text types or domains (in
terms of precision/recall).&apos; But a decrease in robustness
in the latter sense often means a `soft” degradation rather
than complete system failure. This is the type of fail-
ure that needs to be handled even in a working system
( accuracy above), but decreases in overall performance
are also more subtle and therefore difficult to detect.
Scalability. If an NLP system is to be deployed, it
usually needs to be run in a distributed fashion to cope
with a large number of users or documents. However, of-
ten complexity and observed runtime and memory results
are not reported. In an engineering scenario, space and
runtime limits are specified in advance by product man-
agement or lead architects and techniques are selected
according to whether their properties are consistent with
the requirements. Often NLP components rely on other
components, and overall resource demands are high com-
pared to the system the NLP component is part of (e.g. a
text editor).
Multimodality. A language engineer applying the
same parser to investigate the discourse structure of 18th
century novels does not encounter the same challenges
as her colleague trying to apply it to speech dialogs (e.g.
absence of letter case information). Different modalities
have their own idiosyncrasies, and it is difficult to fac-
tor out all of them, but this is necessary because there
is a trend toward multi-modal systems, and intra-system
reuse requires a high degree of adaptability.
Data Sparseness. Current NLP methods are often
1 cf. the forthcoming Special Issue on Natural Language Ro-
bustness of the journal Natural Language Engineering.
data-driven, which means they rely on the availability of
a potentially large number of training examples to learn
from. Such training corpora are typically expensive or
virtually non-existent (data resource bottleneck). This
holds even more so in a multilingual scenario. Insuffi-
cient training data yields unacceptable accuracy.
Multilinguality. In a globalized world, users want to
work with a system in multiple languages. This is already
an issue in conventional software: independence of char-
acter encodings, different lexicographic sorting orders,
display of numbers, dates etc. (internationalization, or
`I18N”) need to be ensured and translations of iconic and
textual messages into the user’s currently preferred lan-
guage of interaction (localization, or `L10N”) have to be
provided (Tuthill-Smallberg,1997; Lunde, 1999). NLP
applications are more complex, because grammars, lex-
icons, rule-sets, statistical models are language-specific,
and need to be re-created for each new target language,
often at a cost that is a significant proportion of the total
NLP sub-system’s budget. Often, heterogeneous compo-
nents from different suppliers and following incompati-
ble linguistic or software paradigms must be integrated.
(Maynard et al., forthcoming) argue convincingly that ar-
chitectural support can improve the predictability of the
construction process.
</bodyText>
<sectionHeader confidence="0.997194" genericHeader="method">
2 Reuse
</sectionHeader>
<subsectionHeader confidence="0.998747">
2.1 The need for reuse
</subsectionHeader>
<bodyText confidence="0.999994307692308">
In NLP, the global amount of reuse is low, and currently,
activities of the community en large focus on reuse of
data resources (via annotation standards or data reposi-
tories like LDC and ELRA). On the software side, de-
spite similar efforts (Declerck et al., 2000), reuse rate is
low, partially because the difficulty of integration is high
(and often underestimated), for instance because devel-
opers use different implementation languages, deprecated
environments or diverse paradigms. Especially, “Far too
often developers of language engineering components do
not put enough effort in designing and defining the API.”
(Gamb¨ack and Olsson, 2000). Thus, re-implementation
and integration cause major productivity loss.
</bodyText>
<subsectionHeader confidence="0.99113">
2.2 Properties that lead to reuse
</subsectionHeader>
<bodyText confidence="0.9998691">
How can productivity loss be avoided? Researchers
should build their prototypes around sound Application
Programming Interfaces (APIs); all input/output should
be separated from the core functionality. Then not only
will the workings of the algorithms become clearer, also
the re-usability will be increased, since most applications
make different assumptions about data formats. Potential
sloppiness (e.g. lack of error-handling) caused by time
pressure can then be restricted to the prototype applica-
tion shell without impairing the core code. The main
</bodyText>
<table confidence="0.9953014375">
LTG MUC-7 Hybrid MUC-7 Named Entity Recognizer
based on maximum entropy classification
and DFSTs
ltchunk DFST-based English chunk parser
ltpos HMM-based English POS tagger
ltstop Maximum entropy-based English sentence
lttok splitter
DFST-based tokenizer for English text
LT TTT Suite of XML/SGML-aware tools for
fsgmatch building DFSTs
sgdelmarkup Deterministic Finite-State Transducer
sgtr (DFST) construction toolkit
sgsed Remove SGML markup from text
SGML replacement tool
SGML stream editor
LT XML LTG’s XML API
</table>
<tableCaption confidence="0.737088">
Table 1: The SGML-Aware NLP Tools of the University
of Edinburgh’s Language Technology Group.
</tableCaption>
<figure confidence="0.807239">
Semi−Ergodic (m : n)
</figure>
<figureCaption confidence="0.941212">
Figure 2: Some Global Architectural Choices.
</figureCaption>
<figure confidence="0.952022333333333">
Blackboard
Pipeline
Blackboard
</figure>
<bodyText confidence="0.919736">
principle behind good design is to dissect the problem
domain into a set of highly cohesive components that in-
teract in a loosely coupled fashion (Sommerville, 2001).
</bodyText>
<subsectionHeader confidence="0.99614">
2.3 Barriers to reuse
</subsectionHeader>
<bodyText confidence="0.999975090909091">
Reuse of software components can be blocked by sev-
eral factors, including the lack of knowledge of existing
components, lack of trust in component quality, a mis-
match between component properties and project require-
ments, unacceptable licensing policies or patent/cost is-
sues. Political issues include the investment needed to
make and package reusable components, for which there
might not be any budget provided. Technical issues con-
tain software-platform incompatibility and dependencies,
installation difficulties, lack of documentation or support,
and inconsistencies with other modules.
Considering NLP components in specific, formalisms
might not be linguistically compatible. Components
might differ in language coverage, accuracy and effi-
ciency. With linguistic components, a black box in-
tegration is particularly tricky, since if the technique
used internally is unknown, the component might break
down in case the domain is changed (domain-specific
rules/training). A further problem is posed by the fact that
different paradigms perform sub-tasks on different levels
(e.g. disambiguation). Case-sensitivity/case-awareness
can also be problematic.
</bodyText>
<subsectionHeader confidence="0.991404">
2.4 Code reuse: toolkits
</subsectionHeader>
<bodyText confidence="0.99942">
The Edinburgh Language Technology Group’s SGML-
aware NLP tools (Mikheev et al., 1999) comprise a set
of programs that rely on the common LT XML API2 to
annotate text using cascading (deterministic) Finite-State
Transducers (Table 1).
The tools are typically used in a sequential UNIX
pipeline (Figure 2, top). An integrated query language
allows selective processing of parts of the XML/SGML
document instance tree.
A major advantage of the LTG pipeline toolkit ap-
proach over frameworks (described below) is the maxi-
mal decoupling of its components (communication only
by means data exchange in a “fat XML pipe”), so no
toolkit-specific “glue” code needs to be developed and
developers can work in their programming language of
choice. A disadvantage is that repeated XML parsing be-
tween components may be too time-consuming in a pro-
duction scenario.
</bodyText>
<subsectionHeader confidence="0.98199">
2.5 Code and design reuse: frameworks
</subsectionHeader>
<bodyText confidence="0.982051655172414">
A framework is a collection of pre-defined services that
embody a certain, given organization, within which the
user can extend the functionality provided; frameworks
impose certain organizational principles on the developer
(Griffel, 1998).
The General Architecture for Text Engineer-
ing (GATE)3 is a theory-neutral framework for
the management and integration of NLP com-
ponents and documents on which they operate
(Cunningham et al., 1996; Cunningham, 2000;
Bontcheva et al., 2002; Cunningham et al., 2002;
Maynard et al., forthcoming). GATE 2 is compliant with
the TIPSTER architecture (Grishman, 1995), contains
the example IE system ANNIE and is freely available
including source (in Java, which makes it also open for
all languages due to the underlying use of UNICODE).
A data type for annotating text spans is provided, which
allows for generic visualization and editing components
and a graphical plug-and-play development environment.
2 http://www.ltg.ed.ac.uk/software/xml/ 3 http://gate.ac.uk/
Developers can make use of a sample component
toolbox.
(Zajac et al., 1997) present Corelli, another TIP-
STER compliant architecture implemented in Java (see
(Basili et al., 1999) for a comparison). The WHITE-
BOARD project (Crysmann et al., 2002) uses monotonic
XML annotation to integrate deep and shallow process-
ing (Figure 2, middle). Finally, the closest coupling takes
place in architectures where most or all components are
allowed to talk to each other, such as the German Verb-
mobil speech translation system (G¨orz et al., 1996).
ALEP, the Advanced Language Engineer-
ing Platform (Simpkins and Groenendijk, 1994;
Bredenkamp et al., 1997) is an early framework that
focused on multilinguality. It offers an HPSG like, typed
AVM-based unification formalism (and parsers for it) as
well as some infrastructural support. In the LS-GRAM
project, it has been used to build analyzers for nine
languages. However, it has been criticized for being
`too committed to a particular approach to linguistic
analysis and representation” ( Cunningham et al., 1997).
ALEP’s Text Handling component (Declerck, 1997) uses
a particular SGML-based annotation that can be enriched
with user-defined tags. Some standard components are
provided, and rules allow the mapping of SGML tags to
AVMs (`lifting”). SRI’s Open Agent Architecture (OAA) 4
(Martin et al., 1999; Cheyer and Martin, 2001) is a soft-
ware platform that offers a library for distributed agent
implementation with bindings for several programming
languages (C/C++, Java, LISP, PROLOG etc.). Agents
request services from service agents via facilitation, a
coordinating service procedure of transparent delegation,
whereby facilitators can consider strategic knowledge
provided by requesting agents, trying to distribute and
optimize goal completion. Control is specified in a
PROLOG-like Interagent Communication Language
(ICL), which contains, but separates, declarative and
procedural knowledge (how to do and what to do).
</bodyText>
<subsectionHeader confidence="0.874763">
2.6 Discussion
</subsectionHeader>
<bodyText confidence="0.999866166666667">
Framework or Toolkit? The disadvantage of frame-
works is that any such infrastructure is bound to have
a steep learning curve (how to write wrapper/glue code,
understand control) and developers are often reluctant to
adopt existing frameworks. Using one frameworks also
often excludes using another (due to the inherited `de-
sign dogma”).
Toolkits, on the other hand, are typically smaller and eas-
ier to adopt than frameworks and allow for more free-
dom with respect to architectural choices, but of course
the flip-side of this coin is that toolkits offer less guid-
ance and reuse of architecture and infrastructure. See
</bodyText>
<footnote confidence="0.653555">
4 http://www.ai.sri.com/ oaa/
</footnote>
<bodyText confidence="0.959321">
(Menzel, 2002) for a further discussion of architectural
issues in NLP.
</bodyText>
<subsectionHeader confidence="0.816624">
2.7 Design reuse with design patterns
</subsectionHeader>
<bodyText confidence="0.998866230769231">
Design patterns (Gamma et al., 1994;
Harrison et al., 2000) are reusable units of software
architecture design that have emerged from object-
oriented software development research, where certain
collaborative object configurations were found to
re-occur in different contexts.
Finite-State Automata (FSAs) were historically the
first devices that have received a software engineer-
ing treatment (Watson, 1995), as they are pervasive
from compiler technology to software engineering it-
self. (Yacoub and Ammar, 2000) describe how using
a FiniteStateMachine design pattern that separates
out certain facets can facilitate interoperability between
Mealy, Moore and hybrid FSAs.
(Manolescu, 2000) identifies the FeatureExtraction
pattern as a useful abstraction for information
retrieval and natural language processing: a
FeatureExtractorManager is a Factory of
FeatureExtractor objects, where each knows a
MappingStrategy, a FilteringStrategy and a
Database. Numerical techniques often used in machine
learning to overcome the `curse of dimensionality”
( data sparseness above) such as Singular Value De-
composition, Latent Semantic Indexing, or Principle
Component Analysis (PCA) are also instances of this
pattern. It is worth noting that some of these patterns
are domain-specific, i.e. the software engineering
aspects interact with the type of linguistic processing.
(Basili et al., 1999) generalize over typical NLP compo-
nents, combining Data Flow Diagrams for a Linguistic
Processing Module (LM), a Lexical Acquisition Module
(LAM) and an Application Module (AM) to a generic
model of an NLP application. The result of the LAM
is what (Cunningham et al., 1997) would call a Data
Resource (as opposed to a Processing Resource, which
corresponds to a LM). (Basili et al., 1999) also present
an UML model of a class for linguistically annotated
text, LinguisticInformation, that is interoperable
with application-dependent classes.
</bodyText>
<subsectionHeader confidence="0.933928">
2.8 Productivity gain with composition languages?
</subsectionHeader>
<bodyText confidence="0.992147375">
Recently, work in software engineering has focused on
composition languages (Nierstrasz and Meijler, 1994),
which allow to construct systems on a meta-level by
specifying composition transformations in a separate
glue notation without editing component source code
(Aßmann, 2003). Such an approach would support a view
held by (Daelemans et al., 1998), who argue that “all
NLP tasks can be seen as either
</bodyText>
<figureCaption confidence="0.999011">
Figure 3: Productivity Pyramid.
</figureCaption>
<bodyText confidence="0.9683396875">
light NLP tasks involving disambiguation or seg-
mentation locally at one language level or between
two closely-related language levels; or as
compositions of light NLP tasks, when the task sur-
passes the complexity of single light NLP tasks.”
That NLP processing often involves generic pre-
processing (such as POS-tagging) can be taken as evi-
dence for the need for dedicated linguistic composition
languages.5 Whereas toolkits and frameworks for NLP
have already been developed, to date there exists no ded-
icated NLP composition language. In such a language,
both linguistic structures (such as typed AVMs) and pro-
cessing resources (such as taggers or tag-set mappers)
had first-order status. Composition languages are a logi-
cal next step in the ongoing development of new abstrac-
tion layers for computing.6
</bodyText>
<sectionHeader confidence="0.949847" genericHeader="method">
3 Experiment or System?
</sectionHeader>
<bodyText confidence="0.999912777777778">
Figure 3 depicts the trade-off researchers have to face
when deciding between carrying out an experiment,
building a prototype program, implementing a more
fleshed-out self-contained system, building a complete,
generic, redistributable toolkit or whether they invest
long-term in providing the community with a new frame-
work.7 On the one hand, experiments ensure high
short-term productivity with hardly any reuse or cross-
fertilization to other projects. Frameworks, on the other
</bodyText>
<footnote confidence="0.674806">
5 The visual application builder part of GATE 2 can be seen as
a visual composition language.
6 See (Abelson and Sussman, 1996) for a view that program-
ming is indeed constant development and application of a grow-
ing collection of abstraction mechanisms.
7 There may be a difference of several orders of magnitude in
complexity between the tip and the bottom of the pyramid in
</footnote>
<figureCaption confidence="0.858037">
Figure 3.
</figureCaption>
<bodyText confidence="0.9998214">
hand, which are only possible in larger groups and with
long-range funding, pay back relatively late, but of-
fer many synergies due to their all-embracing nature if
they can overcome developers reluctance to adopt a new
framework.
</bodyText>
<sectionHeader confidence="0.907815" genericHeader="conclusions">
4 Summary and Conclusion
</sectionHeader>
<bodyText confidence="0.988127388888889">
Whereas the evaluation of effectiveness of NLP methods
has become an integral part of research papers, archi-
tectural evaluation is often neglected. It should also be
recognized as vital part of engineering research publica-
tions, including an assessment of standard compliance,
rapid deployability, maintainability and flexibility of de-
sign (Nyberg and Mitamura, 2002). Researchers should
strive toward development of component APIs rather than
prototypes to foster cross-fertilization and reuse. Frame-
works are a valuable asset on the way as they embody
common assumptions, but (unlike toolkits) they are not
normally inter-operable with other frameworks. Already
the horizon, NLP composition languages and could be an
attractive solution to problems of productivity and reuse.
Acknowledgments. The author would like to acknowledge
the financial support of the German Academic Exchange Ser-
vice (DAAD) under grant D/02/01831 and of Linguit GmbH
(research contract UK-2002/2).
</bodyText>
<sectionHeader confidence="0.9982" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999168916030534">
Harold Abelson and Gerald Jay Sussman. 1996. Structure
and Interpretation of Computer Programs. MIT Press, Cam-
bridge, MA, 2nd edition.
Uwe Aßmann. 2003. Invasive Software Composition.
Springer, Berlin.
Roberto Basili, Massimo Di Nanni, and Maria Theresia
Pazienza. 1999. Engineering of IE systems: an object-
oriented approach. In Maria Theresia Pazienza, editor, In-
formation Extraction. Lecture Notes in Artificial Intelligence
(LNAI1714), pages 134–164. Springer, Berlin.
K. Bontcheva, H. Cunningham, V. Tablan, D. Maynard, and
H. Saggion. 2002. Developing reusable and robust lan-
guage processing components for information systems using
GATE. In Proceedings of the Third International Workshop
on Natural Language and Information Systems (NLIS’2002).
Andrew Bredenkamp, Thierry Declerck, Frederik Fouvry,
Bradley Music, and Axel Theofilidis. 1997. Linguistic en-
gineering using ALEP. In Proceedings of the International
Conference on Recent Advances in Natural Language Pro-
cessing (RANLP’97), Sofia, Bulgaria, September.
Adam Cheyer and David Martin. 2001. The Open Agent Ar-
chitecture. Journal of Autonomous Agents and Multi-Agent
Systems, 4:143–148.
B. Crysmann, A. Frank, B. Kiefer, H. Krieger, S. Mller, G. Neu-
mann, J. Piskorski, U. Schfer, M. Siegel, H. Uszkoreit, and
F. Xu. 2002. An integrated architecture for shallow and deep
processing. In Proceesdings of the Association for Computa-
tional Linguistics 40th Anniversary Meeting (ACL’02), Uni-
versity of Pennsylvania, Philadelphia, July.
H. Cunningham, Y. Wilks, and R. Gaizauskas. 1996. GATE –
A General Architecture for Text Engineering. In Proceed-
ings of the 16th Conference on Computational Linguistics
(COLING’96), Copenhagen.
H. Cunningham, K. Humphreys, R. Gaizauskas, and Y. Wilks.
1997. Software infrastructure for natural language process-
ing. In Proceedings of the Fifth Conference on Applied Natu-
ral Language Processing (ANLP’97), pages 237–244, Wash-
ington.
H. Cunningham, D. Maynard, K. Bontcheva, and V. Tablan.
2002. GATE: A framework and graphical development envi-
ronment for robust NLP tools and applications. In Proceed-
ings of the 40th Anniversary Meeting of the Association for
Computational Linguistics (ACL’02), Philadelphia.
H. Cunningham. 2000. Software Architecture for Language
Engineering. Ph.D. thesis, Department of Computer Sci-
ence, University of Sheffield, Sheffield, UK.
Walter Daelemans, Antal van den Bosch, Jakub Zavrel, Jorn
Veenstra, Sabine Buchholz, and Bertjan Busser. 1998. Rapid
development of NLP modules with Memory-Based Learn-
ing. In Proceedings of ELSNET in Wonderland, pages 105–
113.
Thierry Declerck, Alexander Werner Jachmann, and Hans
Uszkoreit. 2000. The new edition of the natural language
software registry (an initiative of ACL hosted at DFKI). In
Proceedings of the 2nd International Conference on Lan-
guage Resources and Evaluation (LREC’2000), May 31–
June 2, Athens, Greece. ELRA.
Thierry Declerck. 1997. An interface between text struc-
tures and linguistic descriptions. In Ellen Christoffersen and
Bradley Music, editors, Proceedings of the Datalingvistisk
Forening (DALF’97), June 9-10, pages 8–22, Kolding, Den-
mark.
Bj&amp;quot;orn Gamb&amp;quot;ack and Fredrik Olsson. 2000. Experiences of lan-
guage engineering algorithm reuse. In Proceedings of the
First International Conference on Language Resources and
Evaluation (LREC’00).
Erich Gamma, Richard Helm, Ralph Johnson, and John Vlis-
sides. 1994. Design Patterns: Elements of Reusable Object-
Oriented Software. Addison-Wesley, Reading, MA.
G&amp;quot;unther G&amp;quot;orz, Markus Kesseler, J&amp;quot;org Spilker, and Hans We-
ber. 1996. Research on architectures for integrated
speech/language systems in Verbmobil. In Proceedings of
the Conference on Computational Linguistics (COLING’96),
Copenhagen.
Frank Griffel. 1998. Componentware. Konzepte und Techniken
eines Softwareparadigmas. dpunkt, Heidelberg.
Ralph Grishman. 1995. TIPSTER Phase II architrecture de-
sign document (Tinman architecture). version 2.3. Technical
report, New York University, New York.
Neil Harrison, Brian Foote, and Hans Rohnert, editors. 2000.
Pattern Languages of Program Design 4. Addison-Wesley,
Reading, MA.
Ken Lunde. 1999. CJKV Information Processing. O’Reilly,
Sebastopol, CA.
Dragos-Anton Manolescu. 2000. Feature extraction: A
pattern for information retrieval. In Harrison et al.
(Harrison et al., 2000), pages 391–412.
D. Martin, A. Cheyer, and D. Moran. 1999. The Open Agent
Architecture: a framework for building distributed software
systems. Applied Artificial Intelligence, 13(1/2):91–128.
Diana Maynard, Valentin Tablan, Hamish Cunningham, Cris-
tian Ursu, Horacio Saggion, Kalina Bontcheva, and Yorick
Wilks. forthcoming. Architectural elements of language en-
gineering robustness. Natural Language Engineering. Spe-
cial Issue on Robust Methods in Analysis of Natural Lan-
guage Data.
Wolfgang Menzel. 2002. Architecture as a problem of infor-
mation fusion. In Proceedings of the International Sympo-
sium Natural Language Processing between Linguistic In-
quiry and Systems Engineering, pages 74–84, Hamburg.
Andrei Mikheev, Claire Grover, and Marc Moens. 1999. XML
tools and architecture for named entity recognition. Journal
ofMarkup Languages: Theory and Practice, 1:89–113.
Oscar Nierstrasz and Theo Dirk Meijler. 1994. Architecture
as a problem of information fusion. In Proceedings of the
ECOOP’94 Workshop on Models and Languages for the Co-
ordination of Parallelism and Distribution.
Eric Nyberg and Teruko Mitamura. 2002. Evaluating QA sys-
tem on multiple dimensions. In Proceedings of LREC 2002
Workshop on QA Strategy and Resources, Las Palmas, Gran
Canaria, Spain.
Ben Shneiderman. 1997. Designing the User Interface.
Addison-Wesley, Reading, MA, 3rd edition.
Neil Simpkins and Marius Groenendijk. 1994. The ALEP
project. Technical report, Cray Systems / CEC, Luxem-
bourg.
Ian Sommerville. 2001. Software Engineering. Addison-
Wesley, Reading, MA, 6th edition.
Tuthill-Smallberg. 1997. Creating Worldwide Software. Sun
Microsystems Press, Mountain View, CA.
Bruce W. Watson. 1995. Taxonomies and Toolkits of Reg-
ular Language Algorithms. Ph.D. thesis, Department for
Mathematics and Computer Science, Eindhoven University
of Technology, Eindhoven, The Netherlands.
Sherif M. Yacoub and Hany H. Ammar. 2000. Finite state
machine patterns. In Harrison et al. (Harrison et al., 2000),
pages 413–443.
Remi Zajac, Mark Casper, and Nigel Sharples. 1997. An open
distributed architecture for reuse and integration of hetero-
geneous NLP components. In Fifth Conference on Applied
Natural Language Processing (ANLP’97).
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.281836">
<title confidence="0.999154">Current Issues in Software for Natural Language Processing</title>
<author confidence="0.995488">L Jochen</author>
<affiliation confidence="0.7976185">School of Informatics, University of 2 Buccleuch Place, Edinburgh EH8 9LW, Scotland,</affiliation>
<email confidence="0.999535">jochen.leidner@ed.ac.uk</email>
<abstract confidence="0.9997365">In Natural Language Processing (NLP), research re-sults from software engineering and software tech-nology have often been neglected.</abstract>
<note confidence="0.564723">This paper describes some factors that add complex-ity to the task of engineering reusable NLP systems (beyond conventional software systems). Current work in the area of design patterns and composi-tion languages is described and claimed relevant for natural language processing. The benefits of NLP componentware and barriers to reuse are outlined, and the dichotomies “system versus experiment” and “toolkit versus framework” are discussed. It is argued that in order to live up to its name lan-guage engineering must not neglect component qual-ity and architectural evaluation when reporting new NLP research. Figure 1: Dimensions of Language Engineering Com-plexity.</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Harold Abelson</author>
<author>Gerald Jay Sussman</author>
</authors>
<title>Structure and Interpretation of Computer Programs.</title>
<date>1996</date>
<publisher>MIT Press,</publisher>
<location>Cambridge, MA,</location>
<note>2nd edition.</note>
<contexts>
<context position="19192" citStr="Abelson and Sussman, 1996" startWordPosition="2862" endWordPosition="2865">riment or System? Figure 3 depicts the trade-off researchers have to face when deciding between carrying out an experiment, building a prototype program, implementing a more fleshed-out self-contained system, building a complete, generic, redistributable toolkit or whether they invest long-term in providing the community with a new framework.7 On the one hand, experiments ensure high short-term productivity with hardly any reuse or crossfertilization to other projects. Frameworks, on the other 5 The visual application builder part of GATE 2 can be seen as a visual composition language. 6 See (Abelson and Sussman, 1996) for a view that programming is indeed constant development and application of a growing collection of abstraction mechanisms. 7 There may be a difference of several orders of magnitude in complexity between the tip and the bottom of the pyramid in Figure 3. hand, which are only possible in larger groups and with long-range funding, pay back relatively late, but offer many synergies due to their all-embracing nature if they can overcome developers reluctance to adopt a new framework. 4 Summary and Conclusion Whereas the evaluation of effectiveness of NLP methods has become an integral part of </context>
</contexts>
<marker>Abelson, Sussman, 1996</marker>
<rawString>Harold Abelson and Gerald Jay Sussman. 1996. Structure and Interpretation of Computer Programs. MIT Press, Cambridge, MA, 2nd edition.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Uwe Aßmann</author>
</authors>
<title>Invasive Software Composition.</title>
<date>2003</date>
<publisher>Springer,</publisher>
<location>Berlin.</location>
<contexts>
<context position="17597" citStr="Aßmann, 2003" startWordPosition="2614" endWordPosition="2615">m et al., 1997) would call a Data Resource (as opposed to a Processing Resource, which corresponds to a LM). (Basili et al., 1999) also present an UML model of a class for linguistically annotated text, LinguisticInformation, that is interoperable with application-dependent classes. 2.8 Productivity gain with composition languages? Recently, work in software engineering has focused on composition languages (Nierstrasz and Meijler, 1994), which allow to construct systems on a meta-level by specifying composition transformations in a separate glue notation without editing component source code (Aßmann, 2003). Such an approach would support a view held by (Daelemans et al., 1998), who argue that “all NLP tasks can be seen as either Figure 3: Productivity Pyramid. light NLP tasks involving disambiguation or segmentation locally at one language level or between two closely-related language levels; or as compositions of light NLP tasks, when the task surpasses the complexity of single light NLP tasks.” That NLP processing often involves generic preprocessing (such as POS-tagging) can be taken as evidence for the need for dedicated linguistic composition languages.5 Whereas toolkits and frameworks for</context>
</contexts>
<marker>Aßmann, 2003</marker>
<rawString>Uwe Aßmann. 2003. Invasive Software Composition. Springer, Berlin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Roberto Basili</author>
<author>Massimo Di Nanni</author>
<author>Maria Theresia Pazienza</author>
</authors>
<title>Engineering of IE systems: an objectoriented approach.</title>
<date>1999</date>
<booktitle>In Maria Theresia Pazienza, editor, Information Extraction. Lecture Notes in Artificial Intelligence (LNAI1714),</booktitle>
<pages>134--164</pages>
<publisher>Springer,</publisher>
<location>Berlin.</location>
<marker>Basili, Di Nanni, Pazienza, 1999</marker>
<rawString>Roberto Basili, Massimo Di Nanni, and Maria Theresia Pazienza. 1999. Engineering of IE systems: an objectoriented approach. In Maria Theresia Pazienza, editor, Information Extraction. Lecture Notes in Artificial Intelligence (LNAI1714), pages 134–164. Springer, Berlin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Bontcheva</author>
<author>H Cunningham</author>
<author>V Tablan</author>
<author>D Maynard</author>
<author>H Saggion</author>
</authors>
<title>Developing reusable and robust language processing components for information systems using GATE.</title>
<date>2002</date>
<booktitle>In Proceedings of the Third International Workshop on Natural Language and Information Systems (NLIS’2002).</booktitle>
<contexts>
<context position="12070" citStr="Bontcheva et al., 2002" startWordPosition="1802" endWordPosition="1805">ge is that repeated XML parsing between components may be too time-consuming in a production scenario. 2.5 Code and design reuse: frameworks A framework is a collection of pre-defined services that embody a certain, given organization, within which the user can extend the functionality provided; frameworks impose certain organizational principles on the developer (Griffel, 1998). The General Architecture for Text Engineering (GATE)3 is a theory-neutral framework for the management and integration of NLP components and documents on which they operate (Cunningham et al., 1996; Cunningham, 2000; Bontcheva et al., 2002; Cunningham et al., 2002; Maynard et al., forthcoming). GATE 2 is compliant with the TIPSTER architecture (Grishman, 1995), contains the example IE system ANNIE and is freely available including source (in Java, which makes it also open for all languages due to the underlying use of UNICODE). A data type for annotating text spans is provided, which allows for generic visualization and editing components and a graphical plug-and-play development environment. 2 http://www.ltg.ed.ac.uk/software/xml/ 3 http://gate.ac.uk/ Developers can make use of a sample component toolbox. (Zajac et al., 1997) </context>
</contexts>
<marker>Bontcheva, Cunningham, Tablan, Maynard, Saggion, 2002</marker>
<rawString>K. Bontcheva, H. Cunningham, V. Tablan, D. Maynard, and H. Saggion. 2002. Developing reusable and robust language processing components for information systems using GATE. In Proceedings of the Third International Workshop on Natural Language and Information Systems (NLIS’2002).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andrew Bredenkamp</author>
<author>Thierry Declerck</author>
<author>Frederik Fouvry</author>
<author>Bradley Music</author>
<author>Axel Theofilidis</author>
</authors>
<title>Linguistic engineering using ALEP.</title>
<date>1997</date>
<booktitle>In Proceedings of the International Conference on Recent Advances in Natural Language Processing (RANLP’97),</booktitle>
<location>Sofia, Bulgaria,</location>
<contexts>
<context position="13236" citStr="Bredenkamp et al., 1997" startWordPosition="1977" endWordPosition="1980">e use of a sample component toolbox. (Zajac et al., 1997) present Corelli, another TIPSTER compliant architecture implemented in Java (see (Basili et al., 1999) for a comparison). The WHITEBOARD project (Crysmann et al., 2002) uses monotonic XML annotation to integrate deep and shallow processing (Figure 2, middle). Finally, the closest coupling takes place in architectures where most or all components are allowed to talk to each other, such as the German Verbmobil speech translation system (G¨orz et al., 1996). ALEP, the Advanced Language Engineering Platform (Simpkins and Groenendijk, 1994; Bredenkamp et al., 1997) is an early framework that focused on multilinguality. It offers an HPSG like, typed AVM-based unification formalism (and parsers for it) as well as some infrastructural support. In the LS-GRAM project, it has been used to build analyzers for nine languages. However, it has been criticized for being `too committed to a particular approach to linguistic analysis and representation” ( Cunningham et al., 1997). ALEP’s Text Handling component (Declerck, 1997) uses a particular SGML-based annotation that can be enriched with user-defined tags. Some standard components are provided, and rules allow</context>
</contexts>
<marker>Bredenkamp, Declerck, Fouvry, Music, Theofilidis, 1997</marker>
<rawString>Andrew Bredenkamp, Thierry Declerck, Frederik Fouvry, Bradley Music, and Axel Theofilidis. 1997. Linguistic engineering using ALEP. In Proceedings of the International Conference on Recent Advances in Natural Language Processing (RANLP’97), Sofia, Bulgaria, September.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Adam Cheyer</author>
<author>David Martin</author>
</authors>
<title>The Open Agent Architecture.</title>
<date>2001</date>
<journal>Journal of Autonomous Agents and Multi-Agent Systems,</journal>
<pages>4--143</pages>
<contexts>
<context position="13967" citStr="Cheyer and Martin, 2001" startWordPosition="2089" endWordPosition="2092"> formalism (and parsers for it) as well as some infrastructural support. In the LS-GRAM project, it has been used to build analyzers for nine languages. However, it has been criticized for being `too committed to a particular approach to linguistic analysis and representation” ( Cunningham et al., 1997). ALEP’s Text Handling component (Declerck, 1997) uses a particular SGML-based annotation that can be enriched with user-defined tags. Some standard components are provided, and rules allow the mapping of SGML tags to AVMs (`lifting”). SRI’s Open Agent Architecture (OAA) 4 (Martin et al., 1999; Cheyer and Martin, 2001) is a software platform that offers a library for distributed agent implementation with bindings for several programming languages (C/C++, Java, LISP, PROLOG etc.). Agents request services from service agents via facilitation, a coordinating service procedure of transparent delegation, whereby facilitators can consider strategic knowledge provided by requesting agents, trying to distribute and optimize goal completion. Control is specified in a PROLOG-like Interagent Communication Language (ICL), which contains, but separates, declarative and procedural knowledge (how to do and what to do). 2.</context>
</contexts>
<marker>Cheyer, Martin, 2001</marker>
<rawString>Adam Cheyer and David Martin. 2001. The Open Agent Architecture. Journal of Autonomous Agents and Multi-Agent Systems, 4:143–148.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Crysmann</author>
<author>A Frank</author>
<author>B Kiefer</author>
<author>H Krieger</author>
<author>S Mller</author>
<author>G Neumann</author>
<author>J Piskorski</author>
<author>U Schfer</author>
<author>M Siegel</author>
<author>H Uszkoreit</author>
<author>F Xu</author>
</authors>
<title>An integrated architecture for shallow and deep processing.</title>
<date>2002</date>
<booktitle>In Proceesdings of the Association for Computational Linguistics 40th Anniversary Meeting (ACL’02),</booktitle>
<institution>University of Pennsylvania,</institution>
<location>Philadelphia,</location>
<contexts>
<context position="12838" citStr="Crysmann et al., 2002" startWordPosition="1915" endWordPosition="1918">IE system ANNIE and is freely available including source (in Java, which makes it also open for all languages due to the underlying use of UNICODE). A data type for annotating text spans is provided, which allows for generic visualization and editing components and a graphical plug-and-play development environment. 2 http://www.ltg.ed.ac.uk/software/xml/ 3 http://gate.ac.uk/ Developers can make use of a sample component toolbox. (Zajac et al., 1997) present Corelli, another TIPSTER compliant architecture implemented in Java (see (Basili et al., 1999) for a comparison). The WHITEBOARD project (Crysmann et al., 2002) uses monotonic XML annotation to integrate deep and shallow processing (Figure 2, middle). Finally, the closest coupling takes place in architectures where most or all components are allowed to talk to each other, such as the German Verbmobil speech translation system (G¨orz et al., 1996). ALEP, the Advanced Language Engineering Platform (Simpkins and Groenendijk, 1994; Bredenkamp et al., 1997) is an early framework that focused on multilinguality. It offers an HPSG like, typed AVM-based unification formalism (and parsers for it) as well as some infrastructural support. In the LS-GRAM project</context>
</contexts>
<marker>Crysmann, Frank, Kiefer, Krieger, Mller, Neumann, Piskorski, Schfer, Siegel, Uszkoreit, Xu, 2002</marker>
<rawString>B. Crysmann, A. Frank, B. Kiefer, H. Krieger, S. Mller, G. Neumann, J. Piskorski, U. Schfer, M. Siegel, H. Uszkoreit, and F. Xu. 2002. An integrated architecture for shallow and deep processing. In Proceesdings of the Association for Computational Linguistics 40th Anniversary Meeting (ACL’02), University of Pennsylvania, Philadelphia, July.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Cunningham</author>
<author>Y Wilks</author>
<author>R Gaizauskas</author>
</authors>
<title>GATE – A General Architecture for Text Engineering.</title>
<date>1996</date>
<booktitle>In Proceedings of the 16th Conference on Computational Linguistics (COLING’96),</booktitle>
<location>Copenhagen.</location>
<contexts>
<context position="12028" citStr="Cunningham et al., 1996" startWordPosition="1796" endWordPosition="1799">rogramming language of choice. A disadvantage is that repeated XML parsing between components may be too time-consuming in a production scenario. 2.5 Code and design reuse: frameworks A framework is a collection of pre-defined services that embody a certain, given organization, within which the user can extend the functionality provided; frameworks impose certain organizational principles on the developer (Griffel, 1998). The General Architecture for Text Engineering (GATE)3 is a theory-neutral framework for the management and integration of NLP components and documents on which they operate (Cunningham et al., 1996; Cunningham, 2000; Bontcheva et al., 2002; Cunningham et al., 2002; Maynard et al., forthcoming). GATE 2 is compliant with the TIPSTER architecture (Grishman, 1995), contains the example IE system ANNIE and is freely available including source (in Java, which makes it also open for all languages due to the underlying use of UNICODE). A data type for annotating text spans is provided, which allows for generic visualization and editing components and a graphical plug-and-play development environment. 2 http://www.ltg.ed.ac.uk/software/xml/ 3 http://gate.ac.uk/ Developers can make use of a sampl</context>
</contexts>
<marker>Cunningham, Wilks, Gaizauskas, 1996</marker>
<rawString>H. Cunningham, Y. Wilks, and R. Gaizauskas. 1996. GATE – A General Architecture for Text Engineering. In Proceedings of the 16th Conference on Computational Linguistics (COLING’96), Copenhagen.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Cunningham</author>
<author>K Humphreys</author>
<author>R Gaizauskas</author>
<author>Y Wilks</author>
</authors>
<title>Software infrastructure for natural language processing.</title>
<date>1997</date>
<booktitle>In Proceedings of the Fifth Conference on Applied Natural Language Processing (ANLP’97),</booktitle>
<pages>237--244</pages>
<location>Washington.</location>
<contexts>
<context position="13647" citStr="Cunningham et al., 1997" startWordPosition="2041" endWordPosition="2044">llowed to talk to each other, such as the German Verbmobil speech translation system (G¨orz et al., 1996). ALEP, the Advanced Language Engineering Platform (Simpkins and Groenendijk, 1994; Bredenkamp et al., 1997) is an early framework that focused on multilinguality. It offers an HPSG like, typed AVM-based unification formalism (and parsers for it) as well as some infrastructural support. In the LS-GRAM project, it has been used to build analyzers for nine languages. However, it has been criticized for being `too committed to a particular approach to linguistic analysis and representation” ( Cunningham et al., 1997). ALEP’s Text Handling component (Declerck, 1997) uses a particular SGML-based annotation that can be enriched with user-defined tags. Some standard components are provided, and rules allow the mapping of SGML tags to AVMs (`lifting”). SRI’s Open Agent Architecture (OAA) 4 (Martin et al., 1999; Cheyer and Martin, 2001) is a software platform that offers a library for distributed agent implementation with bindings for several programming languages (C/C++, Java, LISP, PROLOG etc.). Agents request services from service agents via facilitation, a coordinating service procedure of transparent deleg</context>
<context position="16999" citStr="Cunningham et al., 1997" startWordPosition="2529" endWordPosition="2532">sionality” ( data sparseness above) such as Singular Value Decomposition, Latent Semantic Indexing, or Principle Component Analysis (PCA) are also instances of this pattern. It is worth noting that some of these patterns are domain-specific, i.e. the software engineering aspects interact with the type of linguistic processing. (Basili et al., 1999) generalize over typical NLP components, combining Data Flow Diagrams for a Linguistic Processing Module (LM), a Lexical Acquisition Module (LAM) and an Application Module (AM) to a generic model of an NLP application. The result of the LAM is what (Cunningham et al., 1997) would call a Data Resource (as opposed to a Processing Resource, which corresponds to a LM). (Basili et al., 1999) also present an UML model of a class for linguistically annotated text, LinguisticInformation, that is interoperable with application-dependent classes. 2.8 Productivity gain with composition languages? Recently, work in software engineering has focused on composition languages (Nierstrasz and Meijler, 1994), which allow to construct systems on a meta-level by specifying composition transformations in a separate glue notation without editing component source code (Aßmann, 2003). </context>
</contexts>
<marker>Cunningham, Humphreys, Gaizauskas, Wilks, 1997</marker>
<rawString>H. Cunningham, K. Humphreys, R. Gaizauskas, and Y. Wilks. 1997. Software infrastructure for natural language processing. In Proceedings of the Fifth Conference on Applied Natural Language Processing (ANLP’97), pages 237–244, Washington.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Cunningham</author>
<author>D Maynard</author>
<author>K Bontcheva</author>
<author>V Tablan</author>
</authors>
<title>GATE: A framework and graphical development environment for robust NLP tools and applications.</title>
<date>2002</date>
<booktitle>In Proceedings of the 40th Anniversary Meeting of the Association for Computational Linguistics (ACL’02),</booktitle>
<location>Philadelphia.</location>
<contexts>
<context position="12095" citStr="Cunningham et al., 2002" startWordPosition="1806" endWordPosition="1809">parsing between components may be too time-consuming in a production scenario. 2.5 Code and design reuse: frameworks A framework is a collection of pre-defined services that embody a certain, given organization, within which the user can extend the functionality provided; frameworks impose certain organizational principles on the developer (Griffel, 1998). The General Architecture for Text Engineering (GATE)3 is a theory-neutral framework for the management and integration of NLP components and documents on which they operate (Cunningham et al., 1996; Cunningham, 2000; Bontcheva et al., 2002; Cunningham et al., 2002; Maynard et al., forthcoming). GATE 2 is compliant with the TIPSTER architecture (Grishman, 1995), contains the example IE system ANNIE and is freely available including source (in Java, which makes it also open for all languages due to the underlying use of UNICODE). A data type for annotating text spans is provided, which allows for generic visualization and editing components and a graphical plug-and-play development environment. 2 http://www.ltg.ed.ac.uk/software/xml/ 3 http://gate.ac.uk/ Developers can make use of a sample component toolbox. (Zajac et al., 1997) present Corelli, another </context>
</contexts>
<marker>Cunningham, Maynard, Bontcheva, Tablan, 2002</marker>
<rawString>H. Cunningham, D. Maynard, K. Bontcheva, and V. Tablan. 2002. GATE: A framework and graphical development environment for robust NLP tools and applications. In Proceedings of the 40th Anniversary Meeting of the Association for Computational Linguistics (ACL’02), Philadelphia.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Cunningham</author>
</authors>
<title>Software Architecture for Language Engineering.</title>
<date>2000</date>
<tech>Ph.D. thesis,</tech>
<institution>Department of Computer Science, University of Sheffield,</institution>
<location>Sheffield, UK.</location>
<contexts>
<context position="12046" citStr="Cunningham, 2000" startWordPosition="1800" endWordPosition="1801">oice. A disadvantage is that repeated XML parsing between components may be too time-consuming in a production scenario. 2.5 Code and design reuse: frameworks A framework is a collection of pre-defined services that embody a certain, given organization, within which the user can extend the functionality provided; frameworks impose certain organizational principles on the developer (Griffel, 1998). The General Architecture for Text Engineering (GATE)3 is a theory-neutral framework for the management and integration of NLP components and documents on which they operate (Cunningham et al., 1996; Cunningham, 2000; Bontcheva et al., 2002; Cunningham et al., 2002; Maynard et al., forthcoming). GATE 2 is compliant with the TIPSTER architecture (Grishman, 1995), contains the example IE system ANNIE and is freely available including source (in Java, which makes it also open for all languages due to the underlying use of UNICODE). A data type for annotating text spans is provided, which allows for generic visualization and editing components and a graphical plug-and-play development environment. 2 http://www.ltg.ed.ac.uk/software/xml/ 3 http://gate.ac.uk/ Developers can make use of a sample component toolbo</context>
</contexts>
<marker>Cunningham, 2000</marker>
<rawString>H. Cunningham. 2000. Software Architecture for Language Engineering. Ph.D. thesis, Department of Computer Science, University of Sheffield, Sheffield, UK.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Walter Daelemans</author>
<author>Antal van den Bosch</author>
<author>Jakub Zavrel</author>
<author>Jorn Veenstra</author>
<author>Sabine Buchholz</author>
<author>Bertjan Busser</author>
</authors>
<title>Rapid development of NLP modules with Memory-Based Learning.</title>
<date>1998</date>
<booktitle>In Proceedings of ELSNET in Wonderland,</booktitle>
<pages>105--113</pages>
<marker>Daelemans, van den Bosch, Zavrel, Veenstra, Buchholz, Busser, 1998</marker>
<rawString>Walter Daelemans, Antal van den Bosch, Jakub Zavrel, Jorn Veenstra, Sabine Buchholz, and Bertjan Busser. 1998. Rapid development of NLP modules with Memory-Based Learning. In Proceedings of ELSNET in Wonderland, pages 105– 113.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Thierry Declerck</author>
<author>Alexander Werner Jachmann</author>
<author>Hans Uszkoreit</author>
</authors>
<title>The new edition of the natural language software registry (an initiative of ACL hosted at DFKI).</title>
<date>2000</date>
<booktitle>In Proceedings of the 2nd International Conference on Language Resources and Evaluation (LREC’2000),</booktitle>
<volume>31</volume>
<location>Athens, Greece. ELRA.</location>
<contexts>
<context position="7575" citStr="Declerck et al., 2000" startWordPosition="1153" endWordPosition="1156">cant proportion of the total NLP sub-system’s budget. Often, heterogeneous components from different suppliers and following incompatible linguistic or software paradigms must be integrated. (Maynard et al., forthcoming) argue convincingly that architectural support can improve the predictability of the construction process. 2 Reuse 2.1 The need for reuse In NLP, the global amount of reuse is low, and currently, activities of the community en large focus on reuse of data resources (via annotation standards or data repositories like LDC and ELRA). On the software side, despite similar efforts (Declerck et al., 2000), reuse rate is low, partially because the difficulty of integration is high (and often underestimated), for instance because developers use different implementation languages, deprecated environments or diverse paradigms. Especially, “Far too often developers of language engineering components do not put enough effort in designing and defining the API.” (Gamb¨ack and Olsson, 2000). Thus, re-implementation and integration cause major productivity loss. 2.2 Properties that lead to reuse How can productivity loss be avoided? Researchers should build their prototypes around sound Application Prog</context>
</contexts>
<marker>Declerck, Jachmann, Uszkoreit, 2000</marker>
<rawString>Thierry Declerck, Alexander Werner Jachmann, and Hans Uszkoreit. 2000. The new edition of the natural language software registry (an initiative of ACL hosted at DFKI). In Proceedings of the 2nd International Conference on Language Resources and Evaluation (LREC’2000), May 31– June 2, Athens, Greece. ELRA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Thierry Declerck</author>
</authors>
<title>An interface between text structures and linguistic descriptions.</title>
<date>1997</date>
<booktitle>Proceedings of the Datalingvistisk Forening (DALF’97),</booktitle>
<pages>8--22</pages>
<editor>In Ellen Christoffersen and Bradley Music, editors,</editor>
<location>Kolding, Denmark.</location>
<contexts>
<context position="13696" citStr="Declerck, 1997" startWordPosition="2049" endWordPosition="2050"> speech translation system (G¨orz et al., 1996). ALEP, the Advanced Language Engineering Platform (Simpkins and Groenendijk, 1994; Bredenkamp et al., 1997) is an early framework that focused on multilinguality. It offers an HPSG like, typed AVM-based unification formalism (and parsers for it) as well as some infrastructural support. In the LS-GRAM project, it has been used to build analyzers for nine languages. However, it has been criticized for being `too committed to a particular approach to linguistic analysis and representation” ( Cunningham et al., 1997). ALEP’s Text Handling component (Declerck, 1997) uses a particular SGML-based annotation that can be enriched with user-defined tags. Some standard components are provided, and rules allow the mapping of SGML tags to AVMs (`lifting”). SRI’s Open Agent Architecture (OAA) 4 (Martin et al., 1999; Cheyer and Martin, 2001) is a software platform that offers a library for distributed agent implementation with bindings for several programming languages (C/C++, Java, LISP, PROLOG etc.). Agents request services from service agents via facilitation, a coordinating service procedure of transparent delegation, whereby facilitators can consider strategi</context>
</contexts>
<marker>Declerck, 1997</marker>
<rawString>Thierry Declerck. 1997. An interface between text structures and linguistic descriptions. In Ellen Christoffersen and Bradley Music, editors, Proceedings of the Datalingvistisk Forening (DALF’97), June 9-10, pages 8–22, Kolding, Denmark.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bjorn Gamback</author>
<author>Fredrik Olsson</author>
</authors>
<title>Experiences of language engineering algorithm reuse.</title>
<date>2000</date>
<booktitle>In Proceedings of the First International Conference on Language Resources and Evaluation (LREC’00).</booktitle>
<marker>Gamback, Olsson, 2000</marker>
<rawString>Bj&amp;quot;orn Gamb&amp;quot;ack and Fredrik Olsson. 2000. Experiences of language engineering algorithm reuse. In Proceedings of the First International Conference on Language Resources and Evaluation (LREC’00).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Erich Gamma</author>
<author>Richard Helm</author>
<author>Ralph Johnson</author>
<author>John Vlissides</author>
</authors>
<title>Design Patterns: Elements of Reusable ObjectOriented Software.</title>
<date>1994</date>
<publisher>Addison-Wesley,</publisher>
<location>Reading, MA.</location>
<contexts>
<context position="15373" citStr="Gamma et al., 1994" startWordPosition="2298" endWordPosition="2301">l) and developers are often reluctant to adopt existing frameworks. Using one frameworks also often excludes using another (due to the inherited `design dogma”). Toolkits, on the other hand, are typically smaller and easier to adopt than frameworks and allow for more freedom with respect to architectural choices, but of course the flip-side of this coin is that toolkits offer less guidance and reuse of architecture and infrastructure. See 4 http://www.ai.sri.com/ oaa/ (Menzel, 2002) for a further discussion of architectural issues in NLP. 2.7 Design reuse with design patterns Design patterns (Gamma et al., 1994; Harrison et al., 2000) are reusable units of software architecture design that have emerged from objectoriented software development research, where certain collaborative object configurations were found to re-occur in different contexts. Finite-State Automata (FSAs) were historically the first devices that have received a software engineering treatment (Watson, 1995), as they are pervasive from compiler technology to software engineering itself. (Yacoub and Ammar, 2000) describe how using a FiniteStateMachine design pattern that separates out certain facets can facilitate interoperability b</context>
</contexts>
<marker>Gamma, Helm, Johnson, Vlissides, 1994</marker>
<rawString>Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. 1994. Design Patterns: Elements of Reusable ObjectOriented Software. Addison-Wesley, Reading, MA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gunther Gorz</author>
<author>Markus Kesseler</author>
<author>Jorg Spilker</author>
<author>Hans Weber</author>
</authors>
<title>Research on architectures for integrated speech/language systems in Verbmobil.</title>
<date>1996</date>
<booktitle>In Proceedings of the Conference on Computational Linguistics (COLING’96),</booktitle>
<location>Copenhagen.</location>
<marker>Gorz, Kesseler, Spilker, Weber, 1996</marker>
<rawString>G&amp;quot;unther G&amp;quot;orz, Markus Kesseler, J&amp;quot;org Spilker, and Hans Weber. 1996. Research on architectures for integrated speech/language systems in Verbmobil. In Proceedings of the Conference on Computational Linguistics (COLING’96), Copenhagen.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Frank Griffel</author>
</authors>
<date>1998</date>
<booktitle>Componentware. Konzepte und Techniken eines Softwareparadigmas. dpunkt,</booktitle>
<location>Heidelberg.</location>
<contexts>
<context position="11829" citStr="Griffel, 1998" startWordPosition="1767" endWordPosition="1768">imal decoupling of its components (communication only by means data exchange in a “fat XML pipe”), so no toolkit-specific “glue” code needs to be developed and developers can work in their programming language of choice. A disadvantage is that repeated XML parsing between components may be too time-consuming in a production scenario. 2.5 Code and design reuse: frameworks A framework is a collection of pre-defined services that embody a certain, given organization, within which the user can extend the functionality provided; frameworks impose certain organizational principles on the developer (Griffel, 1998). The General Architecture for Text Engineering (GATE)3 is a theory-neutral framework for the management and integration of NLP components and documents on which they operate (Cunningham et al., 1996; Cunningham, 2000; Bontcheva et al., 2002; Cunningham et al., 2002; Maynard et al., forthcoming). GATE 2 is compliant with the TIPSTER architecture (Grishman, 1995), contains the example IE system ANNIE and is freely available including source (in Java, which makes it also open for all languages due to the underlying use of UNICODE). A data type for annotating text spans is provided, which allows </context>
</contexts>
<marker>Griffel, 1998</marker>
<rawString>Frank Griffel. 1998. Componentware. Konzepte und Techniken eines Softwareparadigmas. dpunkt, Heidelberg.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ralph Grishman</author>
</authors>
<title>TIPSTER Phase II architrecture design document (Tinman architecture). version 2.3. Technical report,</title>
<date>1995</date>
<location>New York University, New York.</location>
<contexts>
<context position="12193" citStr="Grishman, 1995" startWordPosition="1822" endWordPosition="1823">frameworks A framework is a collection of pre-defined services that embody a certain, given organization, within which the user can extend the functionality provided; frameworks impose certain organizational principles on the developer (Griffel, 1998). The General Architecture for Text Engineering (GATE)3 is a theory-neutral framework for the management and integration of NLP components and documents on which they operate (Cunningham et al., 1996; Cunningham, 2000; Bontcheva et al., 2002; Cunningham et al., 2002; Maynard et al., forthcoming). GATE 2 is compliant with the TIPSTER architecture (Grishman, 1995), contains the example IE system ANNIE and is freely available including source (in Java, which makes it also open for all languages due to the underlying use of UNICODE). A data type for annotating text spans is provided, which allows for generic visualization and editing components and a graphical plug-and-play development environment. 2 http://www.ltg.ed.ac.uk/software/xml/ 3 http://gate.ac.uk/ Developers can make use of a sample component toolbox. (Zajac et al., 1997) present Corelli, another TIPSTER compliant architecture implemented in Java (see (Basili et al., 1999) for a comparison). T</context>
</contexts>
<marker>Grishman, 1995</marker>
<rawString>Ralph Grishman. 1995. TIPSTER Phase II architrecture design document (Tinman architecture). version 2.3. Technical report, New York University, New York.</rawString>
</citation>
<citation valid="true">
<date>2000</date>
<booktitle>Pattern Languages of Program Design 4.</booktitle>
<editor>Neil Harrison, Brian Foote, and Hans Rohnert, editors.</editor>
<publisher>Addison-Wesley,</publisher>
<location>Reading, MA.</location>
<marker>2000</marker>
<rawString>Neil Harrison, Brian Foote, and Hans Rohnert, editors. 2000. Pattern Languages of Program Design 4. Addison-Wesley, Reading, MA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ken Lunde</author>
</authors>
<date>1999</date>
<booktitle>CJKV Information Processing.</booktitle>
<location>O’Reilly, Sebastopol, CA.</location>
<contexts>
<context position="6746" citStr="Lunde, 1999" startWordPosition="1027" endWordPosition="1028">k). This holds even more so in a multilingual scenario. Insufficient training data yields unacceptable accuracy. Multilinguality. In a globalized world, users want to work with a system in multiple languages. This is already an issue in conventional software: independence of character encodings, different lexicographic sorting orders, display of numbers, dates etc. (internationalization, or `I18N”) need to be ensured and translations of iconic and textual messages into the user’s currently preferred language of interaction (localization, or `L10N”) have to be provided (Tuthill-Smallberg,1997; Lunde, 1999). NLP applications are more complex, because grammars, lexicons, rule-sets, statistical models are language-specific, and need to be re-created for each new target language, often at a cost that is a significant proportion of the total NLP sub-system’s budget. Often, heterogeneous components from different suppliers and following incompatible linguistic or software paradigms must be integrated. (Maynard et al., forthcoming) argue convincingly that architectural support can improve the predictability of the construction process. 2 Reuse 2.1 The need for reuse In NLP, the global amount of reuse </context>
</contexts>
<marker>Lunde, 1999</marker>
<rawString>Ken Lunde. 1999. CJKV Information Processing. O’Reilly, Sebastopol, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dragos-Anton Manolescu</author>
</authors>
<title>Feature extraction: A pattern for information retrieval.</title>
<date>2000</date>
<booktitle>In Harrison et</booktitle>
<pages>391--412</pages>
<contexts>
<context position="16027" citStr="Manolescu, 2000" startWordPosition="2389" endWordPosition="2390">units of software architecture design that have emerged from objectoriented software development research, where certain collaborative object configurations were found to re-occur in different contexts. Finite-State Automata (FSAs) were historically the first devices that have received a software engineering treatment (Watson, 1995), as they are pervasive from compiler technology to software engineering itself. (Yacoub and Ammar, 2000) describe how using a FiniteStateMachine design pattern that separates out certain facets can facilitate interoperability between Mealy, Moore and hybrid FSAs. (Manolescu, 2000) identifies the FeatureExtraction pattern as a useful abstraction for information retrieval and natural language processing: a FeatureExtractorManager is a Factory of FeatureExtractor objects, where each knows a MappingStrategy, a FilteringStrategy and a Database. Numerical techniques often used in machine learning to overcome the `curse of dimensionality” ( data sparseness above) such as Singular Value Decomposition, Latent Semantic Indexing, or Principle Component Analysis (PCA) are also instances of this pattern. It is worth noting that some of these patterns are domain-specific, i.e. the s</context>
</contexts>
<marker>Manolescu, 2000</marker>
<rawString>Dragos-Anton Manolescu. 2000. Feature extraction: A pattern for information retrieval. In Harrison et al. (Harrison et al., 2000), pages 391–412.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Martin</author>
<author>A Cheyer</author>
<author>D Moran</author>
</authors>
<title>The Open Agent Architecture: a framework for building distributed software systems.</title>
<date>1999</date>
<journal>Applied Artificial Intelligence,</journal>
<pages>13--1</pages>
<contexts>
<context position="13941" citStr="Martin et al., 1999" startWordPosition="2085" endWordPosition="2088">AVM-based unification formalism (and parsers for it) as well as some infrastructural support. In the LS-GRAM project, it has been used to build analyzers for nine languages. However, it has been criticized for being `too committed to a particular approach to linguistic analysis and representation” ( Cunningham et al., 1997). ALEP’s Text Handling component (Declerck, 1997) uses a particular SGML-based annotation that can be enriched with user-defined tags. Some standard components are provided, and rules allow the mapping of SGML tags to AVMs (`lifting”). SRI’s Open Agent Architecture (OAA) 4 (Martin et al., 1999; Cheyer and Martin, 2001) is a software platform that offers a library for distributed agent implementation with bindings for several programming languages (C/C++, Java, LISP, PROLOG etc.). Agents request services from service agents via facilitation, a coordinating service procedure of transparent delegation, whereby facilitators can consider strategic knowledge provided by requesting agents, trying to distribute and optimize goal completion. Control is specified in a PROLOG-like Interagent Communication Language (ICL), which contains, but separates, declarative and procedural knowledge (how</context>
</contexts>
<marker>Martin, Cheyer, Moran, 1999</marker>
<rawString>D. Martin, A. Cheyer, and D. Moran. 1999. The Open Agent Architecture: a framework for building distributed software systems. Applied Artificial Intelligence, 13(1/2):91–128.</rawString>
</citation>
<citation valid="false">
<authors>
<author>forthcoming</author>
</authors>
<title>Architectural elements of language engineering robustness. Natural Language Engineering. Special Issue on Robust Methods in Analysis of Natural Language Data.</title>
<marker>forthcoming, </marker>
<rawString>Diana Maynard, Valentin Tablan, Hamish Cunningham, Cristian Ursu, Horacio Saggion, Kalina Bontcheva, and Yorick Wilks. forthcoming. Architectural elements of language engineering robustness. Natural Language Engineering. Special Issue on Robust Methods in Analysis of Natural Language Data.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Wolfgang Menzel</author>
</authors>
<title>Architecture as a problem of information fusion.</title>
<date>2002</date>
<booktitle>In Proceedings of the International Symposium Natural Language Processing between Linguistic Inquiry and Systems Engineering,</booktitle>
<pages>74--84</pages>
<location>Hamburg.</location>
<contexts>
<context position="15242" citStr="Menzel, 2002" startWordPosition="2279" endWordPosition="2280">rks is that any such infrastructure is bound to have a steep learning curve (how to write wrapper/glue code, understand control) and developers are often reluctant to adopt existing frameworks. Using one frameworks also often excludes using another (due to the inherited `design dogma”). Toolkits, on the other hand, are typically smaller and easier to adopt than frameworks and allow for more freedom with respect to architectural choices, but of course the flip-side of this coin is that toolkits offer less guidance and reuse of architecture and infrastructure. See 4 http://www.ai.sri.com/ oaa/ (Menzel, 2002) for a further discussion of architectural issues in NLP. 2.7 Design reuse with design patterns Design patterns (Gamma et al., 1994; Harrison et al., 2000) are reusable units of software architecture design that have emerged from objectoriented software development research, where certain collaborative object configurations were found to re-occur in different contexts. Finite-State Automata (FSAs) were historically the first devices that have received a software engineering treatment (Watson, 1995), as they are pervasive from compiler technology to software engineering itself. (Yacoub and Amma</context>
</contexts>
<marker>Menzel, 2002</marker>
<rawString>Wolfgang Menzel. 2002. Architecture as a problem of information fusion. In Proceedings of the International Symposium Natural Language Processing between Linguistic Inquiry and Systems Engineering, pages 74–84, Hamburg.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andrei Mikheev</author>
<author>Claire Grover</author>
<author>Marc Moens</author>
</authors>
<title>XML tools and architecture for named entity recognition.</title>
<date>1999</date>
<booktitle>Journal ofMarkup Languages: Theory and Practice,</booktitle>
<pages>1--89</pages>
<contexts>
<context position="10785" citStr="Mikheev et al., 1999" startWordPosition="1604" endWordPosition="1607">ht not be linguistically compatible. Components might differ in language coverage, accuracy and efficiency. With linguistic components, a black box integration is particularly tricky, since if the technique used internally is unknown, the component might break down in case the domain is changed (domain-specific rules/training). A further problem is posed by the fact that different paradigms perform sub-tasks on different levels (e.g. disambiguation). Case-sensitivity/case-awareness can also be problematic. 2.4 Code reuse: toolkits The Edinburgh Language Technology Group’s SGMLaware NLP tools (Mikheev et al., 1999) comprise a set of programs that rely on the common LT XML API2 to annotate text using cascading (deterministic) Finite-State Transducers (Table 1). The tools are typically used in a sequential UNIX pipeline (Figure 2, top). An integrated query language allows selective processing of parts of the XML/SGML document instance tree. A major advantage of the LTG pipeline toolkit approach over frameworks (described below) is the maximal decoupling of its components (communication only by means data exchange in a “fat XML pipe”), so no toolkit-specific “glue” code needs to be developed and developers</context>
</contexts>
<marker>Mikheev, Grover, Moens, 1999</marker>
<rawString>Andrei Mikheev, Claire Grover, and Marc Moens. 1999. XML tools and architecture for named entity recognition. Journal ofMarkup Languages: Theory and Practice, 1:89–113.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Oscar Nierstrasz</author>
<author>Theo Dirk Meijler</author>
</authors>
<title>Architecture as a problem of information fusion.</title>
<date>1994</date>
<booktitle>In Proceedings of the ECOOP’94 Workshop on Models and Languages for the Coordination of Parallelism and Distribution.</booktitle>
<contexts>
<context position="17424" citStr="Nierstrasz and Meijler, 1994" startWordPosition="2588" endWordPosition="2591">for a Linguistic Processing Module (LM), a Lexical Acquisition Module (LAM) and an Application Module (AM) to a generic model of an NLP application. The result of the LAM is what (Cunningham et al., 1997) would call a Data Resource (as opposed to a Processing Resource, which corresponds to a LM). (Basili et al., 1999) also present an UML model of a class for linguistically annotated text, LinguisticInformation, that is interoperable with application-dependent classes. 2.8 Productivity gain with composition languages? Recently, work in software engineering has focused on composition languages (Nierstrasz and Meijler, 1994), which allow to construct systems on a meta-level by specifying composition transformations in a separate glue notation without editing component source code (Aßmann, 2003). Such an approach would support a view held by (Daelemans et al., 1998), who argue that “all NLP tasks can be seen as either Figure 3: Productivity Pyramid. light NLP tasks involving disambiguation or segmentation locally at one language level or between two closely-related language levels; or as compositions of light NLP tasks, when the task surpasses the complexity of single light NLP tasks.” That NLP processing often in</context>
</contexts>
<marker>Nierstrasz, Meijler, 1994</marker>
<rawString>Oscar Nierstrasz and Theo Dirk Meijler. 1994. Architecture as a problem of information fusion. In Proceedings of the ECOOP’94 Workshop on Models and Languages for the Coordination of Parallelism and Distribution.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Eric Nyberg</author>
<author>Teruko Mitamura</author>
</authors>
<title>Evaluating QA system on multiple dimensions.</title>
<date>2002</date>
<booktitle>In Proceedings of LREC 2002 Workshop on QA Strategy and Resources,</booktitle>
<location>Las Palmas, Gran Canaria,</location>
<contexts>
<context position="20073" citStr="Nyberg and Mitamura, 2002" startWordPosition="3001" endWordPosition="3004"> 3. hand, which are only possible in larger groups and with long-range funding, pay back relatively late, but offer many synergies due to their all-embracing nature if they can overcome developers reluctance to adopt a new framework. 4 Summary and Conclusion Whereas the evaluation of effectiveness of NLP methods has become an integral part of research papers, architectural evaluation is often neglected. It should also be recognized as vital part of engineering research publications, including an assessment of standard compliance, rapid deployability, maintainability and flexibility of design (Nyberg and Mitamura, 2002). Researchers should strive toward development of component APIs rather than prototypes to foster cross-fertilization and reuse. Frameworks are a valuable asset on the way as they embody common assumptions, but (unlike toolkits) they are not normally inter-operable with other frameworks. Already the horizon, NLP composition languages and could be an attractive solution to problems of productivity and reuse. Acknowledgments. The author would like to acknowledge the financial support of the German Academic Exchange Service (DAAD) under grant D/02/01831 and of Linguit GmbH (research contract UK-2</context>
</contexts>
<marker>Nyberg, Mitamura, 2002</marker>
<rawString>Eric Nyberg and Teruko Mitamura. 2002. Evaluating QA system on multiple dimensions. In Proceedings of LREC 2002 Workshop on QA Strategy and Resources, Las Palmas, Gran Canaria, Spain.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ben Shneiderman</author>
</authors>
<title>Designing the User Interface.</title>
<date>1997</date>
<publisher>Addison-Wesley,</publisher>
<location>Reading, MA,</location>
<note>3rd edition.</note>
<contexts>
<context position="1861" citStr="Shneiderman, 1997" startWordPosition="267" endWordPosition="268">ssing (NLP) applications, the author is not aware of any studies that estimate project failure rate. The risks of failure seem even higher in this area, because the language engineer faces additional complexity (Figure 1): Accuracy. A fundamental difference between NLP systems and conventional software is the incompleteness property: since current language processing techniques can never guarantee to provide all and only the correct results, the whole system design is affected by having to take this into account and providing appropriate fallbacks. Efficiency. Human users are very demanding: (Shneiderman, 1997) reports that system response times 4s can render a system unacceptable. It is also debated in which scenarios natural language interaction with machines is superior to menus, keyboard commands or other means. To date, it unclear how efficiently NLP systems can be, since efficiency is not a top priority in research and many questions related to software design and technology are often considered a mere `implementation detail”. This is in contrast to other areas of computing, where data structures and algorithms are often carefully selected and customized to be of maximum gain for a domain, and</context>
</contexts>
<marker>Shneiderman, 1997</marker>
<rawString>Ben Shneiderman. 1997. Designing the User Interface. Addison-Wesley, Reading, MA, 3rd edition.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Neil Simpkins</author>
<author>Marius Groenendijk</author>
</authors>
<date>1994</date>
<booktitle>The ALEP project. Technical report, Cray Systems / CEC,</booktitle>
<contexts>
<context position="13210" citStr="Simpkins and Groenendijk, 1994" startWordPosition="1973" endWordPosition="1976">//gate.ac.uk/ Developers can make use of a sample component toolbox. (Zajac et al., 1997) present Corelli, another TIPSTER compliant architecture implemented in Java (see (Basili et al., 1999) for a comparison). The WHITEBOARD project (Crysmann et al., 2002) uses monotonic XML annotation to integrate deep and shallow processing (Figure 2, middle). Finally, the closest coupling takes place in architectures where most or all components are allowed to talk to each other, such as the German Verbmobil speech translation system (G¨orz et al., 1996). ALEP, the Advanced Language Engineering Platform (Simpkins and Groenendijk, 1994; Bredenkamp et al., 1997) is an early framework that focused on multilinguality. It offers an HPSG like, typed AVM-based unification formalism (and parsers for it) as well as some infrastructural support. In the LS-GRAM project, it has been used to build analyzers for nine languages. However, it has been criticized for being `too committed to a particular approach to linguistic analysis and representation” ( Cunningham et al., 1997). ALEP’s Text Handling component (Declerck, 1997) uses a particular SGML-based annotation that can be enriched with user-defined tags. Some standard components are</context>
</contexts>
<marker>Simpkins, Groenendijk, 1994</marker>
<rawString>Neil Simpkins and Marius Groenendijk. 1994. The ALEP project. Technical report, Cray Systems / CEC, Luxembourg.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ian Sommerville</author>
</authors>
<date>2001</date>
<booktitle>Software Engineering.</booktitle>
<publisher>AddisonWesley,</publisher>
<location>Reading, MA,</location>
<note>6th edition.</note>
<contexts>
<context position="1156" citStr="Sommerville, 2001" startWordPosition="164" endWordPosition="165">s and composition languages is described and claimed relevant for natural language processing. The benefits of NLP componentware and barriers to reuse are outlined, and the dichotomies “system versus experiment” and “toolkit versus framework” are discussed. It is argued that in order to live up to its name lan- Figure 1: Dimensions of Language Engineering Comguage engineering must not neglect component qual- plexity. ity and architectural evaluation when reporting new NLP research. 1 Introduction It is notoriously difficult to construct conventional software systems systematically and timely (Sommerville, 2001), with up to 20% of industrial development projects failing. For Natural Language Processing (NLP) applications, the author is not aware of any studies that estimate project failure rate. The risks of failure seem even higher in this area, because the language engineer faces additional complexity (Figure 1): Accuracy. A fundamental difference between NLP systems and conventional software is the incompleteness property: since current language processing techniques can never guarantee to provide all and only the correct results, the whole system design is affected by having to take this into acc</context>
<context position="9493" citStr="Sommerville, 2001" startWordPosition="1426" endWordPosition="1427">for English text LT TTT Suite of XML/SGML-aware tools for fsgmatch building DFSTs sgdelmarkup Deterministic Finite-State Transducer sgtr (DFST) construction toolkit sgsed Remove SGML markup from text SGML replacement tool SGML stream editor LT XML LTG’s XML API Table 1: The SGML-Aware NLP Tools of the University of Edinburgh’s Language Technology Group. Semi−Ergodic (m : n) Figure 2: Some Global Architectural Choices. Blackboard Pipeline Blackboard principle behind good design is to dissect the problem domain into a set of highly cohesive components that interact in a loosely coupled fashion (Sommerville, 2001). 2.3 Barriers to reuse Reuse of software components can be blocked by several factors, including the lack of knowledge of existing components, lack of trust in component quality, a mismatch between component properties and project requirements, unacceptable licensing policies or patent/cost issues. Political issues include the investment needed to make and package reusable components, for which there might not be any budget provided. Technical issues contain software-platform incompatibility and dependencies, installation difficulties, lack of documentation or support, and inconsistencies wit</context>
</contexts>
<marker>Sommerville, 2001</marker>
<rawString>Ian Sommerville. 2001. Software Engineering. AddisonWesley, Reading, MA, 6th edition.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tuthill-Smallberg</author>
</authors>
<title>Creating Worldwide Software.</title>
<date>1997</date>
<publisher>Sun Microsystems Press,</publisher>
<location>Mountain View, CA.</location>
<marker>Tuthill-Smallberg, 1997</marker>
<rawString>Tuthill-Smallberg. 1997. Creating Worldwide Software. Sun Microsystems Press, Mountain View, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bruce W Watson</author>
</authors>
<title>Taxonomies and Toolkits of Regular Language Algorithms.</title>
<date>1995</date>
<tech>Ph.D. thesis,</tech>
<institution>Department for Mathematics and Computer Science, Eindhoven University of Technology,</institution>
<location>Eindhoven, The Netherlands.</location>
<contexts>
<context position="15745" citStr="Watson, 1995" startWordPosition="2350" endWordPosition="2351">r less guidance and reuse of architecture and infrastructure. See 4 http://www.ai.sri.com/ oaa/ (Menzel, 2002) for a further discussion of architectural issues in NLP. 2.7 Design reuse with design patterns Design patterns (Gamma et al., 1994; Harrison et al., 2000) are reusable units of software architecture design that have emerged from objectoriented software development research, where certain collaborative object configurations were found to re-occur in different contexts. Finite-State Automata (FSAs) were historically the first devices that have received a software engineering treatment (Watson, 1995), as they are pervasive from compiler technology to software engineering itself. (Yacoub and Ammar, 2000) describe how using a FiniteStateMachine design pattern that separates out certain facets can facilitate interoperability between Mealy, Moore and hybrid FSAs. (Manolescu, 2000) identifies the FeatureExtraction pattern as a useful abstraction for information retrieval and natural language processing: a FeatureExtractorManager is a Factory of FeatureExtractor objects, where each knows a MappingStrategy, a FilteringStrategy and a Database. Numerical techniques often used in machine learning t</context>
</contexts>
<marker>Watson, 1995</marker>
<rawString>Bruce W. Watson. 1995. Taxonomies and Toolkits of Regular Language Algorithms. Ph.D. thesis, Department for Mathematics and Computer Science, Eindhoven University of Technology, Eindhoven, The Netherlands.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Sherif M Yacoub</author>
<author>Hany H Ammar</author>
</authors>
<title>Finite state machine patterns.</title>
<date>2000</date>
<booktitle>In Harrison et</booktitle>
<pages>413--443</pages>
<contexts>
<context position="15850" citStr="Yacoub and Ammar, 2000" startWordPosition="2364" endWordPosition="2367"> (Menzel, 2002) for a further discussion of architectural issues in NLP. 2.7 Design reuse with design patterns Design patterns (Gamma et al., 1994; Harrison et al., 2000) are reusable units of software architecture design that have emerged from objectoriented software development research, where certain collaborative object configurations were found to re-occur in different contexts. Finite-State Automata (FSAs) were historically the first devices that have received a software engineering treatment (Watson, 1995), as they are pervasive from compiler technology to software engineering itself. (Yacoub and Ammar, 2000) describe how using a FiniteStateMachine design pattern that separates out certain facets can facilitate interoperability between Mealy, Moore and hybrid FSAs. (Manolescu, 2000) identifies the FeatureExtraction pattern as a useful abstraction for information retrieval and natural language processing: a FeatureExtractorManager is a Factory of FeatureExtractor objects, where each knows a MappingStrategy, a FilteringStrategy and a Database. Numerical techniques often used in machine learning to overcome the `curse of dimensionality” ( data sparseness above) such as Singular Value Decomposition, L</context>
</contexts>
<marker>Yacoub, Ammar, 2000</marker>
<rawString>Sherif M. Yacoub and Hany H. Ammar. 2000. Finite state machine patterns. In Harrison et al. (Harrison et al., 2000), pages 413–443.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Remi Zajac</author>
<author>Mark Casper</author>
<author>Nigel Sharples</author>
</authors>
<title>An open distributed architecture for reuse and integration of heterogeneous NLP components.</title>
<date>1997</date>
<booktitle>In Fifth Conference on Applied Natural Language Processing (ANLP’97).</booktitle>
<contexts>
<context position="12669" citStr="Zajac et al., 1997" startWordPosition="1889" endWordPosition="1892">ntcheva et al., 2002; Cunningham et al., 2002; Maynard et al., forthcoming). GATE 2 is compliant with the TIPSTER architecture (Grishman, 1995), contains the example IE system ANNIE and is freely available including source (in Java, which makes it also open for all languages due to the underlying use of UNICODE). A data type for annotating text spans is provided, which allows for generic visualization and editing components and a graphical plug-and-play development environment. 2 http://www.ltg.ed.ac.uk/software/xml/ 3 http://gate.ac.uk/ Developers can make use of a sample component toolbox. (Zajac et al., 1997) present Corelli, another TIPSTER compliant architecture implemented in Java (see (Basili et al., 1999) for a comparison). The WHITEBOARD project (Crysmann et al., 2002) uses monotonic XML annotation to integrate deep and shallow processing (Figure 2, middle). Finally, the closest coupling takes place in architectures where most or all components are allowed to talk to each other, such as the German Verbmobil speech translation system (G¨orz et al., 1996). ALEP, the Advanced Language Engineering Platform (Simpkins and Groenendijk, 1994; Bredenkamp et al., 1997) is an early framework that focus</context>
</contexts>
<marker>Zajac, Casper, Sharples, 1997</marker>
<rawString>Remi Zajac, Mark Casper, and Nigel Sharples. 1997. An open distributed architecture for reuse and integration of heterogeneous NLP components. In Fifth Conference on Applied Natural Language Processing (ANLP’97).</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>