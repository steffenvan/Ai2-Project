<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.003457">
<title confidence="0.67128">
TYPES IN FUNCTIONAL UNIFICATION GRAMMARS
</title>
<author confidence="0.854996">
Michael Elhadad
</author>
<affiliation confidence="0.9969545">
Department of Computer Science
Columbia University
</affiliation>
<address confidence="0.985219">
New York, NY 10027
</address>
<email confidence="0.990936">
Internet: Elhadad@cs.columbia.edu
</email>
<sectionHeader confidence="0.987592" genericHeader="abstract">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.9997688">
Functional Unification Grammars (FUGs) are
popular for natural language applications because the
formalism uses very few primitives and is uniform and
expressive. In our work on text generation, we have
found that it also has annoying limitations: it is not
suited for the expression of simple, yet very common,
taxonomic relations and it does not allow the
specification of completeness conditions. We have
implemented an extension of traditional functional
unification. This extension addresses these limitations
while preserving the desirable properties of FUGs. It
is based on the notions of typed features and typed
constituents. We show the advantages of this exten-
sion in the context of a grammar used for text genera-
tion.
</bodyText>
<sectionHeader confidence="0.99911" genericHeader="introduction">
1 INTRODUCTION
</sectionHeader>
<bodyText confidence="0.996583596491229">
Unification-based formalisms are increasingly
used in linguistic theories (Shieber, 1986) and com-
putational linguistics. In particular, one type of
unification formalism, functional unification grammar
(FUG) is widely used for text generation (Kay, 1979,
McKeown, 1985, Appelt, 1985, Paris, 1987,
McKeown &amp; Elhadad, 1990) and is beginning to be
used for parsing (Kay, 1985, Kasper, 1987). FUG
enjoys such popularity mainly because it allies expres-
siveness with a simple economical formalism. It uses
very few primitives, has a clean semantics
(Pereira&amp;Shieber, 1984, Kasper &amp; Rounds, 1986, El-
hadad, 1990), is monotonic, and grants equal status to
function and structure in the descriptions.
We have implemented a functional unifier (El-
hadad, 1988) covering all the features described in
(Kay, 1979) and (McKeown &amp; Paris, 1987). Having
used this implementation extensively, we have found
all these properties very useful, but we also have met
with limitations. The functional unification (FU) for-
malism is not well suited for the expression of simple,
yet very common, taxonomic relations. The tradi-
tional way to implement such relations in FUG is ver-
bose, inefficient and unreadable. It is also impossible
to express completeness constraints on descriptions.
In this paper, we present several extensions to the
FU formalism that address these limitations. These
extensions are based on the formal semantics
presented in (Elharlad, 1990). They have been im-
plemented and tested on several applications.
We first introduce the notion of typed features. It
allows the definition of a structure over the primitive
symbols used in the grammar. The unifier can take
advantage of this structure in a manner similar to (Alt-
Kaci, 1984). We then introduce the notion of typed
constituents and the FSET construct. It allows the dec-
laration of explicit constraints on the set of admissible
paths in functional descriptions. Typing the primitive
elements of the formalism and the constituents allows
a more concise expression of grammars and better
checking of the input descriptions. It also provides
more readable and better documented grammars.
Most work in computational linguistics using a
unification-based formalism (e.g., (Sag &amp; Pollard,
1987, Uszkoreit, 1986, Karttunen, 1986, Kay, 1979,
Kaplan &amp; Bresnan, 1982)) does not make use of ex-
plicit typing. In (Ait-Kaci, 1984), Ait-Kaci introduced
Y-terms, which are very similar to feature structures,
and introduced the use of type inheritance in unifica-
tion. &apos;P-terms were intended to be general-purpose
programming constructs. We base our extension for
typed features on this work but we also add the notion
of typed constituents and the ability to express com-
pleteness constraints. We also integrate the idea of
typing with the particulars of FUGs (notion of con-
stituent, NONE, ANY and CSET constructs) and show
the relevance of typing for linguistic applications.
</bodyText>
<sectionHeader confidence="0.9981385" genericHeader="method">
2 TRADITIONAL FUNCTIONAL
UNIFICATION ALGORITHM
</sectionHeader>
<bodyText confidence="0.998802777777778">
The Functional Unifier takes as input two descrip-
tions, called functional descriptions or FDs and
produces a new FD if unification succeeds and failure
otherwise.
An FD describes a set of objects (most often lin-
guistic entities) that satisfy certain properties. It is
represented by a set of pairs [ a : v], called features,
where a is an attribute (the name of the property) and
v is a value, either an atomic symbol or recursively an
FD. An attribute a is allowed to appear at most once
in a given FD F, so that the phrase &amp;quot;the a of F&amp;quot; is
always non ambiguous (Kay, 1979).
It is possible to define a natural partial order over
the set of FDs. An FD Xis more specific than the FD
Y if X contains at least all the features of Y (that is
X c Y). Two FDs are compatible if they are not con-
tradictory on the value of an attribute. Let X and Y be
two compatible FDs. The unification of X and Y is by
</bodyText>
<page confidence="0.996521">
157
</page>
<bodyText confidence="0.997607735294118">
definition the most general FD that is more specific
than both X and For example, the unification of
{year:88, time:{hour:5}) and
{time:{mns:22), month:101 is lyear:88,
month:10, time:(hour:5, irms:221).
When properties are simple (all the values are atomic),
unification is therefore very similar to the union of
two sets: Xt...)Y is the smallest set containing both X
and Y. There are two problems that make unification
different from set union: first, in general, the union of
two FDs is not a consistent FD (it can contain two
different values for the same label); second, values of
features can be complex FDs. The mechanism of
unification is therefore a little more complex than sug-
gested, but the EU mechanism is abstractly best under-
stood as a union operation over FDs (cf (Kay,
1979) for a full description of the algorithm).
Note that contrary to structural unification (SU, as
used in Prolog for example), FU is not based on order
and length. Therefore, 1 a : 1 , b : 2 ) and•{ b : 2 ,
a :1 } are equivalent in FU but not in SU, and a :1 )
and lb:2, ad) are compatible in FU but not in
SU (FDs have no fixed arity) (cf. (Knight, 1989,
p.105) for a comparison SU vs. FU).
TERMINOLOGY: We introduce here terms that
constitute a convenient vocabulary to describe our ex-
tensions. In the rest of the paper, we consider the
unification of two FDs that we call input and gram-
ma. We define L as a set of labels or attribute names
and C as a set of constants, or simple atomic values. A
string of labels (that is an element of Ls) is called a
path, and is noted &lt;11...11.. A grammar defines a
domain of admissible paths, A c L&apos;. A defines the
skeleton of well-formed FD:s.
</bodyText>
<listItem confidence="0.8642425625">
• An FD can be an atom (element of C) or a
set of features. One of the most attractive
characteristics of FU is that non-atomic
FDs can be abstractly viewed in two
ways: either as a flat list of equations or
as a structure equivalent to a directed
graph with labeled arcs (Karttunen,
1984). The possibility of using a non-
structured representation removes the em-
phasis that has traditionally been placed
on structure and constituency in language.
• The meta-FDs NONE and ANY are
provided to refer to the status of a feature
in a description rather than to its value.
( 1 ab e 1 : NONE) indicates that label
cannot have a ground value in the ED
</listItem>
<bodyText confidence="0.937378956521739">
resulting from the unification.
[label: my] indicates that label
must have a ground value in the resulting
FD. Note that NONE is best viewed as
imposing constraints on the definition of
A: an equation &lt;11...15&gt;=NoNE means that
• A constituent of a complex FD is a distin-
guished subset of features. The special
label CSET (Constituent Set) is used to
identify constituents. The value of CSET
is a list of paths leading to all the con-
stituents of the ED. Constituents trigger
recursion in the EU algorithm. Note that
CSET is part of the formalism, and that its
value is not a valid ED. A related con-
struct of the formalism, PATTERN, imple-
ments ordering constraints on the strings
denoted by the FDs.
Among the many unification-based formalisms,
the constructs NONE, ANY, PATTERN, CSET and the no-
tion of constituent are specific to FUGs. A formal
semantics of FUGs covering all these special con-
structs is presented in (Elhadad, 1990).
</bodyText>
<sectionHeader confidence="0.99871" genericHeader="method">
3 TYPED FEATURES
</sectionHeader>
<bodyText confidence="0.9964601">
A LIMITATION OF RIGS: NO STRUCTURE OVER
THE SET OF VALUES: In FU, the set of constants C has
no structure. It is a fiat collection of symbols with no
relations between each other. All constraints among
symbols must be expressed in the grammar. In lin-
guistics, however, grammars assume a rich structure
between properties: some groups of features are
mutually exclusive; some features are only defined in
the context of other features.
Let&apos;s consider a fragment of grammar describing
noun-phrases (NPs) (cf Figure 1) using the systemic
notation given in (Winograd, 1983). Systemic net-
works, such as this one, encode the choices that need
to be made to produce a complex linguistic entity.
They indicate how features can be combined or
whether features are inconsistent with other combina-
tions. The configuration illustrated by this fragment is
typical, and occurs very often in grammars.&apos; The
schema indicates that a noun can be either a pronoun,
a proper noun or a common noun. Note that these
</bodyText>
<figure confidence="0.9976451">
1 Question
1 Personal
Pronoun --1
1 Demonstrative
1 Quantified
Noun
Proper
1 Count
Common --- 1
1 Mass
</figure>
<figureCaption confidence="0.999921">
Figure 1: A system for NPs
</figureCaption>
<bodyText confidence="0.872683">
&apos;We have implemented a grammar similar to (Winograd, 1983,
appendix B) containing 111 systems. In this grammar, more than
158 40% of the systems are similar to the one described here.
</bodyText>
<figure confidence="0.9926655">
( (cat noun)
(alt (((noun pronoun)
(pronoun
((alt (question
((noun proper))
((noun common)
(common ((alt
personal demonstrative quantified)))))
mass)) ) I I)))
(count
</figure>
<figureCaption confidence="0.847136">
Figure 2: A faulty FUG for the NP system
</figureCaption>
<figure confidence="0.999203166666667">
((alt (((noun pronoun)
(common mm)
(pronoun
((alt (question personal demonstrative quantified)))))
( (noun proper) (pronoun Non) (common NONE))
((noun common)
(pronoun mxiE)
(common ((alt (count mass))))))))
The input Ft) describing a personal pronoun is then:
( (cat noun)
(noun pronoun)
(pronoun personal))
</figure>
<figureCaption confidence="0.999756">
Figure 3: A correct FUG for the NP system
</figureCaption>
<bodyText confidence="0.997772933333334">
three features are mutually exclusive. Note also that
the choice between the features ( question, per-
sonal, demonstrative, quantified} is
relevant only when the feature pronoun is selected.
This system therefore forbids combinations of the type
(pronoun, proper) and c ommon,
personal).
The traditional technique for expressing these con-
straints in a FUG is to define a label for each non
terminal symbol in the system. The resulting gram-
mar is shown in Figure 2.1 This grammar is, however,
incorrect, as it allows combinations of the type
( (noun proper) (pronoun question) ) or
even worse ( (noun proper) (pronoun
zouz ou) ) . Because unification is similar to union
of features sets, a feature (pronoun question)
in the input would simply get added to the output. In
order to enforce the correct constraints, it is therefore
necessary to use the meta-FD NONE (which prevents
the addition of unwanted features) as shown in Figure
3.
There are two problems with this corrected FUG
implementation. First, both the input FD describing a
pronoun and the grammar are redundant and longer
than needed. Second, the branches of the alternations
in the grammar are interdependent: you need to know
in the branch for pronouns that common nouns can be
sub-categorized and what the other classes of nouns
are. This interdependence prevents any modularity: if
a branch is added to an alternation, all other branches
</bodyText>
<footnote confidence="0.684743">
2ALT indicates that the lists that follow are alternative noun types. 159
</footnote>
<bodyText confidence="0.995383677419355">
need to be modified. It is also an inefficient
mechanism as the number of pairs processed during
unification is 0(nd) for a taxonomy of depth d with an
average of it branches at each level.
TYPED FEATURES The problem thus is that FUGs
do not gracefully implement mutual exclusion and
hierarchical relations. The system of nouns is a typi-
cal taxonomic relation. The deeper the taxonomy, the
more problems we have expressing it using traditional
FUGs.
We propose extracting hierarchical information
from the FUG and expressing it as a constraint over
the symbols used. The solution is to define a sub-
sumption relation over the set of constants C. One
way to define this order is to define types of symbols,
as illustrated in Figure 4. This is similar to &apos;F-terms
defined in (Ait-Kaci, 1984).
Once types and a subsumption relation are defined,
the unification algorithm must be modified. The
atoms X and Y can be unified if they are equal OR if
one subsumes the other. The result is the most
specific of X and Y. The formal semantics of this
extension is detailed in (Elhadad, 1990).
With this new definition of unification, taking ad-
vantage of the structure over constants, the grammar
and the input become much smaller and more readable
as shown in Figure 4. There is no need to introduce
artificial labels. The input FD describing a pronoun is
a simple ( (cat personal-pronoun) ) instead
of the redundant chain down the hierarchy ( (cat
noun) (noun pronoun) (pronoun
</bodyText>
<figure confidence="0.649363857142857">
(define-type noun (pronoun proper common))
(define-type pronoun
(personal-pronoun question-pronoun
demonstrative-pronoun quantified-pronoun))
(define-type common (count-noun mass-noun))
The grammar becomes:
((cat noun)
(alt (((cat pronoun)
(cat Halt (question-pronoun personal-pronoun
demonstrative-pronoun quantified-pronoun)))))
((cat proper))
((cat common)
(cat ((alt (count-noun mass-noun))))))))
Andtheinput: ((cat personal-pronoun))
</figure>
<figureCaption confidence="0.972236">
Figure 4: Using typed features
</figureCaption>
<figure confidence="0.995709375">
Type declarations:
(define-constituent determiner
(definite distance demonstrative possessive))
Input FD describing a determiner:
(determiner ((definite yes)
(distance far)
(demonstrative no)
(possessive no)))
</figure>
<figureCaption confidence="0.999888">
Figure 5: A typed constituent
</figureCaption>
<bodyText confidence="0.9999681">
personal) ) . Because values can now share the
same label CAT, mutual exclusion is enforced without
adding any pair [1: NONE 1 .3 Note that it is now pos-
sible to have several pairs [ a :v1] in an FD F, but
that the phrase &amp;quot;the a of F&amp;quot; is still non-ambiguous: it
refers to the most specific of the v1. Finally, the fact
that there is a taxonomy is explicitly stated in the type
definition section whereas it used to be buried in the
code of the FUG. This taxonomy is used to document
the grammar and to check the validity of input FDs.
</bodyText>
<sectionHeader confidence="0.9996875" genericHeader="method">
4 TYPED CONSTITUENTS: 1HE FSET
CONSTRUCT
</sectionHeader>
<bodyText confidence="0.942309536585365">
A natural extension of the notion of typed features
is to type constituents: typing a feature restricts its
possible values; typing a constituent restricts the pos-
sible features it can have.
Figure 5 illustrates the idea. The define
constituent statement allows only the four given
features to appear under the constituent
determiner. This statement declares what the
3In this example, the grammar could be a simple flat alternation
((cat ((alt (noun pronoun personal-pronoun ... common mass-noun
count-noun))))), but this expression would hide the structure of the
grammar. 160
grammar knows about determiners. Define
constituent is a completeness constraint as
defined in LFGs (Kaplan &amp; Bresnan, 1982); it says
what the grammar needs in order to consider a con-
stituent complete. Without this construct, FDs can
only express partial information.
Note that expressing such a constraint (a limit on
the arity of a constituent) is impossible in the tradi-
tional FU formalism. It would be the equivalent of
putting a NONE in the attribute field of a pair as in
NONE:NONE.
In general, the set of features that are allowed un-
der a certain constituent depends on the value of
another feature. Figure 6 illustrates the problem. The
fragment of grammar shown defines what inherent
roles are defined for different types of processes (it
follows the classification provided in (14aIliday,
1985)). We also want to enforce the constraint that
the set of inherent roles is &amp;quot;closed&amp;quot;: for an action, the
inherent roles are agent, medium and benef and noth-
ing else. This constraint cannot be expressed by the
standard FUG formalism. A define
constituent makes it possible, but nonetheless
not very efficient: the set of possible features under
the constituent inherent—roles depends on the
value of the feature process—type. The first part
of Figure 6 shows how the correct constraint can be
implemented with define constituent only:
we need to exclude all the roles that are not defined
</bodyText>
<figure confidence="0.994882655172414">
Without FSET:
(define-constituent inherent-roles
(agent medium benef carrier attribute processor phenomenon))
((cat clause)
(sit (((process-type action)
(inherent-roles ((carrier Non)
(attribute NONE)
(processor Non)
(phenomenon NONE) ) ) )
((Process-type attributive)
(inherent-roles ((agent NONE)
(medium NONE)
(benef NUM)
(processor NOM
(phenomenon NONE))))
((process-type mental)
(inherent-roles ((agent mm)
(medium NONE)
(benef NONE)
(carrier MXT)
(attribute mm)))))))
With FM&apos;:
((cat clause)
(alt (((process-type action)
(inherent-roles UPSET (agent medium benef)))))
((process-type attributive)
(inherent-roles ((FSET (carrier attribute)))))
((process-type mental)
(inherent-roles ((nu (processor phenomenon))))))))
</figure>
<figureCaption confidence="0.999986">
Figure 6: The FSET Construct
</figureCaption>
<bodyText confidence="0.998255790697674">
for the process-type. Note that the problems are very
similar to those encountered on the pronoun system:
explosion of NONE branches, interdependent branches,
long and inefficient grammar.
To solve this problem, we introduce the construct
FSET (feature set). FSET specifies the complete set of
legal features at a given level of an FD. BET adds
constraints on the definition of the domain of admis-
sible paths A. The syntax is the same as CSET. Note
that all the features specified in PSET do not need to
appear in an FD: only a subset of those can appear.
For example, to define the class of middle verbs (e.g.,
&amp;quot;to shine&amp;quot; which accepts only a medium as inherent
role and no agent), the following statement can be
unified with the fragment of grammar given in Figure
6:
((verb ((lex wshine&amp;quot;)))
(process-type action)
(voice-class middle)
(inherent-roles ((FSET (medium)))))
The feature (FSET (medium) ) can be unified
with (FSET (agent medium bene f ) ) and the
result is (FSET (medium) ).
Typing constituents is necessary to implement the
theoretical claim of LFG that the number of syntactic
functions is limited. It also has practical advantages.161
The first advantage is good documentation of the
grammar. Typing also allows checking the validity of
inputs as defined by the type declarations.
The second advantage is that it can be used to
define more efficient data-structures to represent FDs.
As suggested by the definition of FDs, two types of
data-structures can be used to internally represent
FDs: a flat list of equations (which is more appropriate
for a language like Prolog) and a structured represen-
tation (which is more natural for a language like Lisp).
When all constituents are typed, it becomes possible
to use arrays or hash-tables to store FDs in Lisp,
which is much more efficient. We are currently inves-
tigating alternative internal representations for FDs
(cf. (Pereira, 1985, Karttunen, 1985, Boyer, 1988,
Hirsh, 1988) for discussions of data-structures and
compilation of FUGs).
</bodyText>
<sectionHeader confidence="0.998514" genericHeader="conclusions">
5 CONCLUSION
</sectionHeader>
<bodyText confidence="0.996030657894737">
Functional Descriptions are built from two com-
ponents: a set C of primitives and a set L of labels.
Traditionally, all structuring of FDs is done using
strings of labels. We have shown in this paper that
there is much to be gained by delegating some of the
structuring to a set of primitives. The set C is no
longer a flat set of symbols, but is viewed as a richly
structured world. The idea of typed-unification is not
new (Ait-Kaci, 1984), but we have integrated it for the
first time in the context of FUGs and have shown its
linguistic relevance. We have also introduced the
FSET construct, not previously used in unification, en-
dowing FUGs with the capacity to represent and
reason about complete information in certain situa-
tions.
The structure of C can be used as a meta-
description of the grammar: the type declarations
specify what the grammar knows, and are used to
check input FDs. It allows the writing of much more
concise grammars, which perform more efficiently. It
is a great resource for documenting the grammar.
The extended formalism described in this paper is
implemented in Common Lisp using the Union-Find
algorithm (Elhadad, 1988), as suggested in (Huet,
1976, Ait-Kaci, 1984, Escalada-Imaz &amp; Ghallab,
1988) and is used in several research projects (Smadja
&amp; McKeown, 1990, Elhadad eta!, 1989, McKeown &amp;
Elhadad, 1990, McKeown et al, 1991). The source
code for the unifier is available to other researchers.
Please contact the author for further details.
We are investigating other extensions to the FU
formalism, and particularly, ways to modify control
over grammars: we have developed indexing schemes
for more efficient search through the grammar and
have extended the formalism to allow the expression
of complex constraints (set union and intersection).
We are now exploring ways to integrate these later
extensions more tightly to the FUG formalism.
</bodyText>
<sectionHeader confidence="0.999619" genericHeader="acknowledgments">
ACKNOWLEDGMENTS
</sectionHeader>
<bodyText confidence="0.976883">
This work was supported by DARPA under con-
tract #N00039-84-C-0165 and NSF grant
IRT-84-51438. I would like to thank Kathy
McKeown for her guidance on my work and precious
comments on earlier drafts of this paper. Thanks to
Tony Weida, Frank Smadja and Jacques Robin for
their help in shaping this paper. I also want to thank
Bob Kasper for originally suggesting using types in
FUGs.
</bodyText>
<page confidence="0.996292">
162
</page>
<sectionHeader confidence="0.995459" genericHeader="references">
REFERENCES
</sectionHeader>
<reference confidence="0.999334836734693">
Ait-Kaci, Hassan. (1984). A Lattice-theoretic Ap-
proach to Computation Based on a Calculus of
Partially Ordered Type Structures. Doctoral
dissertation, University of Pennsylvania. UMI
#8505030.
Appelt, Douglass E. (1985). Planning English
Sentences. Studies in Natural Language
Processing. Cambridge, England: Cambridge
University Press.
Boyer, Michel. (1988). Towards Functional Logic
Grammars. In Dahl, V. and Saint-Dizier
P. (Ed.), Natural Language Programming and
Logic Programming, II. Amsterdam: North
Holland.
Elhadad, Michael. (1988). The FUF Functional
Unifier: User&apos;s manual. Technical Report
CUCS-408-88, Columbia University.
Elhadad, Michael. (1990). A Set-theoretic Semantics
for Extended FUGs. Technical Report
CUCS-020-90, Columbia University.
Elhadad, Michael, Seligmann, Doree D., Feiner, Steve
and McKeown, Kathleen R. (1989). A Com-
mon Intention Description Language for Inter-
active Multi-media Systems. Presented at the
Workshop on Intelligent Interfaces, IJCAI 89.
Detroit, MI.
Escalada-Imaz, G. and M. Ghallab. (1988). A Prac-
tically Efficient and Almost Linear Unification
Algorithm . Artificial Intelligence, 36, 249-263.
Halliday, Michael A.K. (1985). An Introduction to
Functional Grammar. London: Edward Ar-
nold.
Hirsh, Susan. (1988). P-PATR: A Compiler for
Unification-based Grammars. In Dahl, V. and
Saint-Dizier, P. (Ed.), Natural Language Un-
derstanding and Logic Programming, IL
Amsterdam: North Holland.
Huet, George. (1976). Resolution d&apos;Equations dans
des langages d&apos;ordre 1,2,...,co. Doctoral disser-
tation, Universite de Paris VII, France.
Kaplan, R.M. and J. Bresnan. (1982). Lexical-
functional grammar: A formal system for gram-
matical representation. In The Mental
Representation of Grammatical Relations.
Cambridge, MA: MIT Press.
Karttunen, Lauri. (July 1984). Features and Values.
Coling84. Stanford, California: COLING,
28-33.
Karttunen, Lauri. (1985). Structure Sharing with Bi-
</reference>
<page confidence="0.821071">
163
</page>
<reference confidence="0.997295535714286">
nary Trees. Proceedings of the 23rd annual
meeting of the ACL. ACL, 133-137.
Karttunen, Lauri. (1986). Radical Lexicalism. Tech-
nical Report CSLI-86-66, CSLI - Stanford
University.
Kasper, Robert. (1987). Systemic Gramrnar and
Functional Unification Grammar. In Benson &amp;
Greaves (Ed.), Systemic Functional Perspec-
tives on discourse: selected papers from the
12th International Systemic Workshop. Nor-
wood, NJ: Ablex.
Kasper, Robert and William Rounds. (June 1986). A
Logical Semantics for Feature Structures.
Proceedings of the 24th meeting of the ACL.
Columbia University, New York, NY: ACL,
257-266.
Kay, M. (1979). Functional Grammar. Proceedings
of the 5th meeting of the Berkeley Linguistics
Society. Berkeley Linguistics Society.
Kay, M. (1985). Parsing in Unification grammar. In
Dowty, Karttunen &amp; Zwicky (Ed.), Natural
Language Parsing. Cambridge, England:
Cambridge University Press.
Knight, Kevin. (March 1989). Unification: a Mul-
tidisciplinary Survey. Computing Surveys,
21(1), 93-124.
McKeown, Kathleen R. (1985). Text Generation:
Using Discourse Strategies and Focus Con-
straints to Generate Natural Language Text.
Studies in Natural Language Processing.
Cambridge, England: Cambridge University
Press.
McKeown, Kathleen and Michael Elhadad. (1990). A
Contrastive Evaluation of Functional Unifica-
tion Grammar for Surface Language
Generators: A Case Study in Choice of Connec-
tives. In Cecile L Paris, William R. Swartout
and William C. Mann (Eds.), Natural Language
Generation in Artificial Intelligence and Com-
putational Linguistics. Kluwer Academic
Publishers. (to appear, also available as Tech-
nical Report CUCS-407-88, Columbia Univer-
sity).
McKeown, Kathleen R. and Paris, Cecile L. (July
1987). Functional Unification Grammar
Revisited. Proceedings of the ACL conference.
ACL, 97-103.
McKeown, K., Elhadad, M., Fukumoto, Y., Lim, J.,
Lombardi, C., Robin,]. and Smadja, F. (1991).
Natural Language Generation in COMET. In
Dale, R., Mellish, C. and Zock, M. (Ed.),
Proceedings of the second European Workshop
on Natural Language Generation. To appear.
Paris, Cecile L. (1987). The Use of Explicit User
models in Text Generation: Tailoring to a
User&apos;s level of expertise. Doctoral dissertation,
Columbia University.
Pereira, Fernando. (1985). A Structure Sharing For-
malism for Unification-based Formalisms.
Proceedings of the 23rd annual meeting of the
ACL. ACL, 137-144.
Pereira, Fernando and Stuart Shieber. (July 1984).
The Semantics of Grammar Formalisms Seen as
Computer Languages. Proceedings of the Tenth
International Conference on Computational
Linguistics. Stanford University, Stanford, Ca:
ACL, 123-129.
Sag, I.A. and Pollard, C. (1987). Head-driven phrase
structure grammar: an informal synopsis. Tech-
nical Report CSL1-87-79, Center for the Study
of Language and Information.
Shieber, Stuart. (1986). CSLI Lecture Notes. Vol. 4:
An introduction to Unification-Based Ap-
proaches to Grammar. Chicago, II: University
of Chicago Press.
Smadja, Frank A. and McKeown, Kathleen R. (1990).
Automatically Extracting and Representing Col-
locations for Language Generation.
Proceedings of the 28th annual meeting of the
ACL. Pittsburgh: ACL.
Uszkoreit, Ham. (1986). Categorial Unification
Grammars.
Winograd, Terry. (1983). Language as a Cognitive
Process. Reading, Ma.: Addison-Wesley.
</reference>
<page confidence="0.997736">
3.64
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.819505">
<title confidence="0.999073">TYPES IN FUNCTIONAL UNIFICATION GRAMMARS</title>
<author confidence="0.999975">Michael Elhadad</author>
<affiliation confidence="0.9998725">Department of Computer Science Columbia University</affiliation>
<address confidence="0.999767">New York, NY 10027</address>
<email confidence="0.98041">Internet:Elhadad@cs.columbia.edu</email>
<abstract confidence="0.9895806875">Functional Unification Grammars (FUGs) are popular for natural language applications because the formalism uses very few primitives and is uniform and expressive. In our work on text generation, we have found that it also has annoying limitations: it is not suited for the expression of simple, yet very common, taxonomic relations and it does not allow the specification of completeness conditions. We have implemented an extension of traditional functional unification. This extension addresses these limitations while preserving the desirable properties of FUGs. It is based on the notions of typed features and typed constituents. We show the advantages of this extension in the context of a grammar used for text generation.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Hassan Ait-Kaci</author>
</authors>
<title>A Lattice-theoretic Approach to Computation Based on a Calculus of Partially Ordered Type Structures. Doctoral dissertation,</title>
<date>1984</date>
<pages>8505030</pages>
<institution>University of Pennsylvania. UMI</institution>
<contexts>
<context position="3280" citStr="Ait-Kaci, 1984" startWordPosition="495" endWordPosition="496">otion of typed constituents and the FSET construct. It allows the declaration of explicit constraints on the set of admissible paths in functional descriptions. Typing the primitive elements of the formalism and the constituents allows a more concise expression of grammars and better checking of the input descriptions. It also provides more readable and better documented grammars. Most work in computational linguistics using a unification-based formalism (e.g., (Sag &amp; Pollard, 1987, Uszkoreit, 1986, Karttunen, 1986, Kay, 1979, Kaplan &amp; Bresnan, 1982)) does not make use of explicit typing. In (Ait-Kaci, 1984), Ait-Kaci introduced Y-terms, which are very similar to feature structures, and introduced the use of type inheritance in unification. &apos;P-terms were intended to be general-purpose programming constructs. We base our extension for typed features on this work but we also add the notion of typed constituents and the ability to express completeness constraints. We also integrate the idea of typing with the particulars of FUGs (notion of constituent, NONE, ANY and CSET constructs) and show the relevance of typing for linguistic applications. 2 TRADITIONAL FUNCTIONAL UNIFICATION ALGORITHM The Funct</context>
<context position="12173" citStr="Ait-Kaci, 1984" startWordPosition="2036" endWordPosition="2037">s at each level. TYPED FEATURES The problem thus is that FUGs do not gracefully implement mutual exclusion and hierarchical relations. The system of nouns is a typical taxonomic relation. The deeper the taxonomy, the more problems we have expressing it using traditional FUGs. We propose extracting hierarchical information from the FUG and expressing it as a constraint over the symbols used. The solution is to define a subsumption relation over the set of constants C. One way to define this order is to define types of symbols, as illustrated in Figure 4. This is similar to &apos;F-terms defined in (Ait-Kaci, 1984). Once types and a subsumption relation are defined, the unification algorithm must be modified. The atoms X and Y can be unified if they are equal OR if one subsumes the other. The result is the most specific of X and Y. The formal semantics of this extension is detailed in (Elhadad, 1990). With this new definition of unification, taking advantage of the structure over constants, the grammar and the input become much smaller and more readable as shown in Figure 4. There is no need to introduce artificial labels. The input FD describing a pronoun is a simple ( (cat personal-pronoun) ) instead </context>
<context position="19321" citStr="Ait-Kaci, 1984" startWordPosition="3150" endWordPosition="3151">ive internal representations for FDs (cf. (Pereira, 1985, Karttunen, 1985, Boyer, 1988, Hirsh, 1988) for discussions of data-structures and compilation of FUGs). 5 CONCLUSION Functional Descriptions are built from two components: a set C of primitives and a set L of labels. Traditionally, all structuring of FDs is done using strings of labels. We have shown in this paper that there is much to be gained by delegating some of the structuring to a set of primitives. The set C is no longer a flat set of symbols, but is viewed as a richly structured world. The idea of typed-unification is not new (Ait-Kaci, 1984), but we have integrated it for the first time in the context of FUGs and have shown its linguistic relevance. We have also introduced the FSET construct, not previously used in unification, endowing FUGs with the capacity to represent and reason about complete information in certain situations. The structure of C can be used as a metadescription of the grammar: the type declarations specify what the grammar knows, and are used to check input FDs. It allows the writing of much more concise grammars, which perform more efficiently. It is a great resource for documenting the grammar. The extende</context>
</contexts>
<marker>Ait-Kaci, 1984</marker>
<rawString>Ait-Kaci, Hassan. (1984). A Lattice-theoretic Approach to Computation Based on a Calculus of Partially Ordered Type Structures. Doctoral dissertation, University of Pennsylvania. UMI #8505030.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Douglass E Appelt</author>
</authors>
<title>Planning English Sentences.</title>
<date>1985</date>
<booktitle>Studies in Natural Language Processing.</booktitle>
<publisher>Cambridge University Press.</publisher>
<location>Cambridge, England:</location>
<contexts>
<context position="1197" citStr="Appelt, 1985" startWordPosition="170" endWordPosition="171">nted an extension of traditional functional unification. This extension addresses these limitations while preserving the desirable properties of FUGs. It is based on the notions of typed features and typed constituents. We show the advantages of this extension in the context of a grammar used for text generation. 1 INTRODUCTION Unification-based formalisms are increasingly used in linguistic theories (Shieber, 1986) and computational linguistics. In particular, one type of unification formalism, functional unification grammar (FUG) is widely used for text generation (Kay, 1979, McKeown, 1985, Appelt, 1985, Paris, 1987, McKeown &amp; Elhadad, 1990) and is beginning to be used for parsing (Kay, 1985, Kasper, 1987). FUG enjoys such popularity mainly because it allies expressiveness with a simple economical formalism. It uses very few primitives, has a clean semantics (Pereira&amp;Shieber, 1984, Kasper &amp; Rounds, 1986, Elhadad, 1990), is monotonic, and grants equal status to function and structure in the descriptions. We have implemented a functional unifier (Elhadad, 1988) covering all the features described in (Kay, 1979) and (McKeown &amp; Paris, 1987). Having used this implementation extensively, we have f</context>
</contexts>
<marker>Appelt, 1985</marker>
<rawString>Appelt, Douglass E. (1985). Planning English Sentences. Studies in Natural Language Processing. Cambridge, England: Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michel Boyer</author>
</authors>
<title>Towards Functional Logic Grammars. In</title>
<date>1988</date>
<booktitle>Natural Language Programming and Logic Programming,</booktitle>
<location>II. Amsterdam: North Holland.</location>
<contexts>
<context position="18792" citStr="Boyer, 1988" startWordPosition="3056" endWordPosition="3057">s that it can be used to define more efficient data-structures to represent FDs. As suggested by the definition of FDs, two types of data-structures can be used to internally represent FDs: a flat list of equations (which is more appropriate for a language like Prolog) and a structured representation (which is more natural for a language like Lisp). When all constituents are typed, it becomes possible to use arrays or hash-tables to store FDs in Lisp, which is much more efficient. We are currently investigating alternative internal representations for FDs (cf. (Pereira, 1985, Karttunen, 1985, Boyer, 1988, Hirsh, 1988) for discussions of data-structures and compilation of FUGs). 5 CONCLUSION Functional Descriptions are built from two components: a set C of primitives and a set L of labels. Traditionally, all structuring of FDs is done using strings of labels. We have shown in this paper that there is much to be gained by delegating some of the structuring to a set of primitives. The set C is no longer a flat set of symbols, but is viewed as a richly structured world. The idea of typed-unification is not new (Ait-Kaci, 1984), but we have integrated it for the first time in the context of FUGs a</context>
</contexts>
<marker>Boyer, 1988</marker>
<rawString>Boyer, Michel. (1988). Towards Functional Logic Grammars. In Dahl, V. and Saint-Dizier P. (Ed.), Natural Language Programming and Logic Programming, II. Amsterdam: North Holland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Elhadad</author>
</authors>
<title>The FUF Functional Unifier: User&apos;s manual.</title>
<date>1988</date>
<tech>Technical Report CUCS-408-88,</tech>
<institution>Columbia University.</institution>
<contexts>
<context position="1662" citStr="Elhadad, 1988" startWordPosition="242" endWordPosition="244">r, one type of unification formalism, functional unification grammar (FUG) is widely used for text generation (Kay, 1979, McKeown, 1985, Appelt, 1985, Paris, 1987, McKeown &amp; Elhadad, 1990) and is beginning to be used for parsing (Kay, 1985, Kasper, 1987). FUG enjoys such popularity mainly because it allies expressiveness with a simple economical formalism. It uses very few primitives, has a clean semantics (Pereira&amp;Shieber, 1984, Kasper &amp; Rounds, 1986, Elhadad, 1990), is monotonic, and grants equal status to function and structure in the descriptions. We have implemented a functional unifier (Elhadad, 1988) covering all the features described in (Kay, 1979) and (McKeown &amp; Paris, 1987). Having used this implementation extensively, we have found all these properties very useful, but we also have met with limitations. The functional unification (FU) formalism is not well suited for the expression of simple, yet very common, taxonomic relations. The traditional way to implement such relations in FUG is verbose, inefficient and unreadable. It is also impossible to express completeness constraints on descriptions. In this paper, we present several extensions to the FU formalism that address these limi</context>
<context position="20033" citStr="Elhadad, 1988" startWordPosition="3268" endWordPosition="3269">c relevance. We have also introduced the FSET construct, not previously used in unification, endowing FUGs with the capacity to represent and reason about complete information in certain situations. The structure of C can be used as a metadescription of the grammar: the type declarations specify what the grammar knows, and are used to check input FDs. It allows the writing of much more concise grammars, which perform more efficiently. It is a great resource for documenting the grammar. The extended formalism described in this paper is implemented in Common Lisp using the Union-Find algorithm (Elhadad, 1988), as suggested in (Huet, 1976, Ait-Kaci, 1984, Escalada-Imaz &amp; Ghallab, 1988) and is used in several research projects (Smadja &amp; McKeown, 1990, Elhadad eta!, 1989, McKeown &amp; Elhadad, 1990, McKeown et al, 1991). The source code for the unifier is available to other researchers. Please contact the author for further details. We are investigating other extensions to the FU formalism, and particularly, ways to modify control over grammars: we have developed indexing schemes for more efficient search through the grammar and have extended the formalism to allow the expression of complex constraints </context>
</contexts>
<marker>Elhadad, 1988</marker>
<rawString>Elhadad, Michael. (1988). The FUF Functional Unifier: User&apos;s manual. Technical Report CUCS-408-88, Columbia University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Elhadad</author>
</authors>
<title>A Set-theoretic Semantics for Extended FUGs.</title>
<date>1990</date>
<tech>Technical Report CUCS-020-90,</tech>
<institution>Columbia University.</institution>
<contexts>
<context position="1236" citStr="Elhadad, 1990" startWordPosition="176" endWordPosition="177">tional unification. This extension addresses these limitations while preserving the desirable properties of FUGs. It is based on the notions of typed features and typed constituents. We show the advantages of this extension in the context of a grammar used for text generation. 1 INTRODUCTION Unification-based formalisms are increasingly used in linguistic theories (Shieber, 1986) and computational linguistics. In particular, one type of unification formalism, functional unification grammar (FUG) is widely used for text generation (Kay, 1979, McKeown, 1985, Appelt, 1985, Paris, 1987, McKeown &amp; Elhadad, 1990) and is beginning to be used for parsing (Kay, 1985, Kasper, 1987). FUG enjoys such popularity mainly because it allies expressiveness with a simple economical formalism. It uses very few primitives, has a clean semantics (Pereira&amp;Shieber, 1984, Kasper &amp; Rounds, 1986, Elhadad, 1990), is monotonic, and grants equal status to function and structure in the descriptions. We have implemented a functional unifier (Elhadad, 1988) covering all the features described in (Kay, 1979) and (McKeown &amp; Paris, 1987). Having used this implementation extensively, we have found all these properties very useful, </context>
<context position="8020" citStr="Elhadad, 1990" startWordPosition="1351" endWordPosition="1352">SET (Constituent Set) is used to identify constituents. The value of CSET is a list of paths leading to all the constituents of the ED. Constituents trigger recursion in the EU algorithm. Note that CSET is part of the formalism, and that its value is not a valid ED. A related construct of the formalism, PATTERN, implements ordering constraints on the strings denoted by the FDs. Among the many unification-based formalisms, the constructs NONE, ANY, PATTERN, CSET and the notion of constituent are specific to FUGs. A formal semantics of FUGs covering all these special constructs is presented in (Elhadad, 1990). 3 TYPED FEATURES A LIMITATION OF RIGS: NO STRUCTURE OVER THE SET OF VALUES: In FU, the set of constants C has no structure. It is a fiat collection of symbols with no relations between each other. All constraints among symbols must be expressed in the grammar. In linguistics, however, grammars assume a rich structure between properties: some groups of features are mutually exclusive; some features are only defined in the context of other features. Let&apos;s consider a fragment of grammar describing noun-phrases (NPs) (cf Figure 1) using the systemic notation given in (Winograd, 1983). Systemic n</context>
<context position="12464" citStr="Elhadad, 1990" startWordPosition="2089" endWordPosition="2090">acting hierarchical information from the FUG and expressing it as a constraint over the symbols used. The solution is to define a subsumption relation over the set of constants C. One way to define this order is to define types of symbols, as illustrated in Figure 4. This is similar to &apos;F-terms defined in (Ait-Kaci, 1984). Once types and a subsumption relation are defined, the unification algorithm must be modified. The atoms X and Y can be unified if they are equal OR if one subsumes the other. The result is the most specific of X and Y. The formal semantics of this extension is detailed in (Elhadad, 1990). With this new definition of unification, taking advantage of the structure over constants, the grammar and the input become much smaller and more readable as shown in Figure 4. There is no need to introduce artificial labels. The input FD describing a pronoun is a simple ( (cat personal-pronoun) ) instead of the redundant chain down the hierarchy ( (cat noun) (noun pronoun) (pronoun (define-type noun (pronoun proper common)) (define-type pronoun (personal-pronoun question-pronoun demonstrative-pronoun quantified-pronoun)) (define-type common (count-noun mass-noun)) The grammar becomes: ((cat</context>
<context position="20220" citStr="Elhadad, 1990" startWordPosition="3297" endWordPosition="3298">ituations. The structure of C can be used as a metadescription of the grammar: the type declarations specify what the grammar knows, and are used to check input FDs. It allows the writing of much more concise grammars, which perform more efficiently. It is a great resource for documenting the grammar. The extended formalism described in this paper is implemented in Common Lisp using the Union-Find algorithm (Elhadad, 1988), as suggested in (Huet, 1976, Ait-Kaci, 1984, Escalada-Imaz &amp; Ghallab, 1988) and is used in several research projects (Smadja &amp; McKeown, 1990, Elhadad eta!, 1989, McKeown &amp; Elhadad, 1990, McKeown et al, 1991). The source code for the unifier is available to other researchers. Please contact the author for further details. We are investigating other extensions to the FU formalism, and particularly, ways to modify control over grammars: we have developed indexing schemes for more efficient search through the grammar and have extended the formalism to allow the expression of complex constraints (set union and intersection). We are now exploring ways to integrate these later extensions more tightly to the FUG formalism. ACKNOWLEDGMENTS This work was supported by DARPA under contr</context>
</contexts>
<marker>Elhadad, 1990</marker>
<rawString>Elhadad, Michael. (1990). A Set-theoretic Semantics for Extended FUGs. Technical Report CUCS-020-90, Columbia University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Elhadad</author>
<author>Doree D Seligmann</author>
<author>Steve Feiner</author>
<author>Kathleen R McKeown</author>
</authors>
<title>A Common Intention Description Language for Interactive Multi-media Systems.</title>
<date>1989</date>
<booktitle>Presented at the Workshop on Intelligent Interfaces, IJCAI 89.</booktitle>
<location>Detroit, MI.</location>
<marker>Elhadad, Seligmann, Feiner, McKeown, 1989</marker>
<rawString>Elhadad, Michael, Seligmann, Doree D., Feiner, Steve and McKeown, Kathleen R. (1989). A Common Intention Description Language for Interactive Multi-media Systems. Presented at the Workshop on Intelligent Interfaces, IJCAI 89. Detroit, MI.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Escalada-Imaz</author>
<author>M Ghallab</author>
</authors>
<title>A Practically Efficient and Almost Linear Unification Algorithm .</title>
<date>1988</date>
<journal>Artificial Intelligence,</journal>
<volume>36</volume>
<pages>249--263</pages>
<contexts>
<context position="20110" citStr="Escalada-Imaz &amp; Ghallab, 1988" startWordPosition="3277" endWordPosition="3280">previously used in unification, endowing FUGs with the capacity to represent and reason about complete information in certain situations. The structure of C can be used as a metadescription of the grammar: the type declarations specify what the grammar knows, and are used to check input FDs. It allows the writing of much more concise grammars, which perform more efficiently. It is a great resource for documenting the grammar. The extended formalism described in this paper is implemented in Common Lisp using the Union-Find algorithm (Elhadad, 1988), as suggested in (Huet, 1976, Ait-Kaci, 1984, Escalada-Imaz &amp; Ghallab, 1988) and is used in several research projects (Smadja &amp; McKeown, 1990, Elhadad eta!, 1989, McKeown &amp; Elhadad, 1990, McKeown et al, 1991). The source code for the unifier is available to other researchers. Please contact the author for further details. We are investigating other extensions to the FU formalism, and particularly, ways to modify control over grammars: we have developed indexing schemes for more efficient search through the grammar and have extended the formalism to allow the expression of complex constraints (set union and intersection). We are now exploring ways to integrate these la</context>
</contexts>
<marker>Escalada-Imaz, Ghallab, 1988</marker>
<rawString>Escalada-Imaz, G. and M. Ghallab. (1988). A Practically Efficient and Almost Linear Unification Algorithm . Artificial Intelligence, 36, 249-263.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael A K Halliday</author>
</authors>
<title>An Introduction to Functional Grammar.</title>
<date>1985</date>
<location>London: Edward Arnold.</location>
<marker>Halliday, 1985</marker>
<rawString>Halliday, Michael A.K. (1985). An Introduction to Functional Grammar. London: Edward Arnold.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Susan Hirsh</author>
</authors>
<title>P-PATR: A Compiler for Unification-based Grammars. In</title>
<date>1988</date>
<booktitle>Natural Language Understanding and Logic Programming, IL</booktitle>
<location>Amsterdam: North Holland.</location>
<contexts>
<context position="18806" citStr="Hirsh, 1988" startWordPosition="3058" endWordPosition="3059"> be used to define more efficient data-structures to represent FDs. As suggested by the definition of FDs, two types of data-structures can be used to internally represent FDs: a flat list of equations (which is more appropriate for a language like Prolog) and a structured representation (which is more natural for a language like Lisp). When all constituents are typed, it becomes possible to use arrays or hash-tables to store FDs in Lisp, which is much more efficient. We are currently investigating alternative internal representations for FDs (cf. (Pereira, 1985, Karttunen, 1985, Boyer, 1988, Hirsh, 1988) for discussions of data-structures and compilation of FUGs). 5 CONCLUSION Functional Descriptions are built from two components: a set C of primitives and a set L of labels. Traditionally, all structuring of FDs is done using strings of labels. We have shown in this paper that there is much to be gained by delegating some of the structuring to a set of primitives. The set C is no longer a flat set of symbols, but is viewed as a richly structured world. The idea of typed-unification is not new (Ait-Kaci, 1984), but we have integrated it for the first time in the context of FUGs and have shown </context>
</contexts>
<marker>Hirsh, 1988</marker>
<rawString>Hirsh, Susan. (1988). P-PATR: A Compiler for Unification-based Grammars. In Dahl, V. and Saint-Dizier, P. (Ed.), Natural Language Understanding and Logic Programming, IL Amsterdam: North Holland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>George Huet</author>
</authors>
<title>Resolution d&apos;Equations dans des langages d&apos;ordre</title>
<date>1976</date>
<booktitle>1,2,...,co. Doctoral dissertation, Universite de</booktitle>
<location>Paris VII,</location>
<contexts>
<context position="20062" citStr="Huet, 1976" startWordPosition="3273" endWordPosition="3274">ced the FSET construct, not previously used in unification, endowing FUGs with the capacity to represent and reason about complete information in certain situations. The structure of C can be used as a metadescription of the grammar: the type declarations specify what the grammar knows, and are used to check input FDs. It allows the writing of much more concise grammars, which perform more efficiently. It is a great resource for documenting the grammar. The extended formalism described in this paper is implemented in Common Lisp using the Union-Find algorithm (Elhadad, 1988), as suggested in (Huet, 1976, Ait-Kaci, 1984, Escalada-Imaz &amp; Ghallab, 1988) and is used in several research projects (Smadja &amp; McKeown, 1990, Elhadad eta!, 1989, McKeown &amp; Elhadad, 1990, McKeown et al, 1991). The source code for the unifier is available to other researchers. Please contact the author for further details. We are investigating other extensions to the FU formalism, and particularly, ways to modify control over grammars: we have developed indexing schemes for more efficient search through the grammar and have extended the formalism to allow the expression of complex constraints (set union and intersection).</context>
</contexts>
<marker>Huet, 1976</marker>
<rawString>Huet, George. (1976). Resolution d&apos;Equations dans des langages d&apos;ordre 1,2,...,co. Doctoral dissertation, Universite de Paris VII, France.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R M Kaplan</author>
<author>J Bresnan</author>
</authors>
<title>Lexicalfunctional grammar: A formal system for grammatical representation. In The Mental Representation of Grammatical Relations.</title>
<date>1982</date>
<publisher>MIT Press.</publisher>
<location>Cambridge, MA:</location>
<contexts>
<context position="3221" citStr="Kaplan &amp; Bresnan, 1982" startWordPosition="482" endWordPosition="485">ure in a manner similar to (AltKaci, 1984). We then introduce the notion of typed constituents and the FSET construct. It allows the declaration of explicit constraints on the set of admissible paths in functional descriptions. Typing the primitive elements of the formalism and the constituents allows a more concise expression of grammars and better checking of the input descriptions. It also provides more readable and better documented grammars. Most work in computational linguistics using a unification-based formalism (e.g., (Sag &amp; Pollard, 1987, Uszkoreit, 1986, Karttunen, 1986, Kay, 1979, Kaplan &amp; Bresnan, 1982)) does not make use of explicit typing. In (Ait-Kaci, 1984), Ait-Kaci introduced Y-terms, which are very similar to feature structures, and introduced the use of type inheritance in unification. &apos;P-terms were intended to be general-purpose programming constructs. We base our extension for typed features on this work but we also add the notion of typed constituents and the ability to express completeness constraints. We also integrate the idea of typing with the particulars of FUGs (notion of constituent, NONE, ANY and CSET constructs) and show the relevance of typing for linguistic application</context>
<context position="14841" citStr="Kaplan &amp; Bresnan, 1982" startWordPosition="2442" endWordPosition="2445">ing a feature restricts its possible values; typing a constituent restricts the possible features it can have. Figure 5 illustrates the idea. The define constituent statement allows only the four given features to appear under the constituent determiner. This statement declares what the 3In this example, the grammar could be a simple flat alternation ((cat ((alt (noun pronoun personal-pronoun ... common mass-noun count-noun))))), but this expression would hide the structure of the grammar. 160 grammar knows about determiners. Define constituent is a completeness constraint as defined in LFGs (Kaplan &amp; Bresnan, 1982); it says what the grammar needs in order to consider a constituent complete. Without this construct, FDs can only express partial information. Note that expressing such a constraint (a limit on the arity of a constituent) is impossible in the traditional FU formalism. It would be the equivalent of putting a NONE in the attribute field of a pair as in NONE:NONE. In general, the set of features that are allowed under a certain constituent depends on the value of another feature. Figure 6 illustrates the problem. The fragment of grammar shown defines what inherent roles are defined for different</context>
</contexts>
<marker>Kaplan, Bresnan, 1982</marker>
<rawString>Kaplan, R.M. and J. Bresnan. (1982). Lexicalfunctional grammar: A formal system for grammatical representation. In The Mental Representation of Grammatical Relations. Cambridge, MA: MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
</authors>
<title>Features and Values.</title>
<date>1984</date>
<booktitle>Coling84.</booktitle>
<pages>28--33</pages>
<publisher>COLING,</publisher>
<location>Stanford, California:</location>
<contexts>
<context position="6735" citStr="Karttunen, 1984" startWordPosition="1126" endWordPosition="1127">FDs that we call input and gramma. We define L as a set of labels or attribute names and C as a set of constants, or simple atomic values. A string of labels (that is an element of Ls) is called a path, and is noted &lt;11...11.. A grammar defines a domain of admissible paths, A c L&apos;. A defines the skeleton of well-formed FD:s. • An FD can be an atom (element of C) or a set of features. One of the most attractive characteristics of FU is that non-atomic FDs can be abstractly viewed in two ways: either as a flat list of equations or as a structure equivalent to a directed graph with labeled arcs (Karttunen, 1984). The possibility of using a nonstructured representation removes the emphasis that has traditionally been placed on structure and constituency in language. • The meta-FDs NONE and ANY are provided to refer to the status of a feature in a description rather than to its value. ( 1 ab e 1 : NONE) indicates that label cannot have a ground value in the ED resulting from the unification. [label: my] indicates that label must have a ground value in the resulting FD. Note that NONE is best viewed as imposing constraints on the definition of A: an equation &lt;11...15&gt;=NoNE means that • A constituent of </context>
</contexts>
<marker>Karttunen, 1984</marker>
<rawString>Karttunen, Lauri. (July 1984). Features and Values. Coling84. Stanford, California: COLING, 28-33.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
</authors>
<title>Structure Sharing with Binary Trees.</title>
<date>1985</date>
<booktitle>Proceedings of the 23rd annual meeting of the ACL. ACL,</booktitle>
<pages>133--137</pages>
<contexts>
<context position="18779" citStr="Karttunen, 1985" startWordPosition="3054" endWordPosition="3055">econd advantage is that it can be used to define more efficient data-structures to represent FDs. As suggested by the definition of FDs, two types of data-structures can be used to internally represent FDs: a flat list of equations (which is more appropriate for a language like Prolog) and a structured representation (which is more natural for a language like Lisp). When all constituents are typed, it becomes possible to use arrays or hash-tables to store FDs in Lisp, which is much more efficient. We are currently investigating alternative internal representations for FDs (cf. (Pereira, 1985, Karttunen, 1985, Boyer, 1988, Hirsh, 1988) for discussions of data-structures and compilation of FUGs). 5 CONCLUSION Functional Descriptions are built from two components: a set C of primitives and a set L of labels. Traditionally, all structuring of FDs is done using strings of labels. We have shown in this paper that there is much to be gained by delegating some of the structuring to a set of primitives. The set C is no longer a flat set of symbols, but is viewed as a richly structured world. The idea of typed-unification is not new (Ait-Kaci, 1984), but we have integrated it for the first time in the cont</context>
</contexts>
<marker>Karttunen, 1985</marker>
<rawString>Karttunen, Lauri. (1985). Structure Sharing with Binary Trees. Proceedings of the 23rd annual meeting of the ACL. ACL, 133-137.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
</authors>
<title>Radical Lexicalism.</title>
<date>1986</date>
<tech>Technical Report CSLI-86-66,</tech>
<institution>CSLI - Stanford University.</institution>
<contexts>
<context position="3185" citStr="Karttunen, 1986" startWordPosition="478" endWordPosition="479">ake advantage of this structure in a manner similar to (AltKaci, 1984). We then introduce the notion of typed constituents and the FSET construct. It allows the declaration of explicit constraints on the set of admissible paths in functional descriptions. Typing the primitive elements of the formalism and the constituents allows a more concise expression of grammars and better checking of the input descriptions. It also provides more readable and better documented grammars. Most work in computational linguistics using a unification-based formalism (e.g., (Sag &amp; Pollard, 1987, Uszkoreit, 1986, Karttunen, 1986, Kay, 1979, Kaplan &amp; Bresnan, 1982)) does not make use of explicit typing. In (Ait-Kaci, 1984), Ait-Kaci introduced Y-terms, which are very similar to feature structures, and introduced the use of type inheritance in unification. &apos;P-terms were intended to be general-purpose programming constructs. We base our extension for typed features on this work but we also add the notion of typed constituents and the ability to express completeness constraints. We also integrate the idea of typing with the particulars of FUGs (notion of constituent, NONE, ANY and CSET constructs) and show the relevance </context>
</contexts>
<marker>Karttunen, 1986</marker>
<rawString>Karttunen, Lauri. (1986). Radical Lexicalism. Technical Report CSLI-86-66, CSLI - Stanford University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert Kasper</author>
</authors>
<title>Systemic Gramrnar and Functional Unification Grammar.</title>
<date>1987</date>
<booktitle>In Benson &amp; Greaves (Ed.), Systemic Functional Perspectives on discourse: selected papers from the 12th International Systemic Workshop.</booktitle>
<publisher>Ablex.</publisher>
<location>Norwood, NJ:</location>
<contexts>
<context position="1302" citStr="Kasper, 1987" startWordPosition="188" endWordPosition="189">e preserving the desirable properties of FUGs. It is based on the notions of typed features and typed constituents. We show the advantages of this extension in the context of a grammar used for text generation. 1 INTRODUCTION Unification-based formalisms are increasingly used in linguistic theories (Shieber, 1986) and computational linguistics. In particular, one type of unification formalism, functional unification grammar (FUG) is widely used for text generation (Kay, 1979, McKeown, 1985, Appelt, 1985, Paris, 1987, McKeown &amp; Elhadad, 1990) and is beginning to be used for parsing (Kay, 1985, Kasper, 1987). FUG enjoys such popularity mainly because it allies expressiveness with a simple economical formalism. It uses very few primitives, has a clean semantics (Pereira&amp;Shieber, 1984, Kasper &amp; Rounds, 1986, Elhadad, 1990), is monotonic, and grants equal status to function and structure in the descriptions. We have implemented a functional unifier (Elhadad, 1988) covering all the features described in (Kay, 1979) and (McKeown &amp; Paris, 1987). Having used this implementation extensively, we have found all these properties very useful, but we also have met with limitations. The functional unification </context>
</contexts>
<marker>Kasper, 1987</marker>
<rawString>Kasper, Robert. (1987). Systemic Gramrnar and Functional Unification Grammar. In Benson &amp; Greaves (Ed.), Systemic Functional Perspectives on discourse: selected papers from the 12th International Systemic Workshop. Norwood, NJ: Ablex.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert Kasper</author>
<author>William Rounds</author>
</authors>
<title>A Logical Semantics for Feature Structures.</title>
<date>1986</date>
<booktitle>Proceedings of the 24th meeting of the ACL.</booktitle>
<pages>257--266</pages>
<publisher>ACL,</publisher>
<institution>Columbia University,</institution>
<location>New York, NY:</location>
<contexts>
<context position="1503" citStr="Kasper &amp; Rounds, 1986" startWordPosition="216" endWordPosition="219"> text generation. 1 INTRODUCTION Unification-based formalisms are increasingly used in linguistic theories (Shieber, 1986) and computational linguistics. In particular, one type of unification formalism, functional unification grammar (FUG) is widely used for text generation (Kay, 1979, McKeown, 1985, Appelt, 1985, Paris, 1987, McKeown &amp; Elhadad, 1990) and is beginning to be used for parsing (Kay, 1985, Kasper, 1987). FUG enjoys such popularity mainly because it allies expressiveness with a simple economical formalism. It uses very few primitives, has a clean semantics (Pereira&amp;Shieber, 1984, Kasper &amp; Rounds, 1986, Elhadad, 1990), is monotonic, and grants equal status to function and structure in the descriptions. We have implemented a functional unifier (Elhadad, 1988) covering all the features described in (Kay, 1979) and (McKeown &amp; Paris, 1987). Having used this implementation extensively, we have found all these properties very useful, but we also have met with limitations. The functional unification (FU) formalism is not well suited for the expression of simple, yet very common, taxonomic relations. The traditional way to implement such relations in FUG is verbose, inefficient and unreadable. It i</context>
</contexts>
<marker>Kasper, Rounds, 1986</marker>
<rawString>Kasper, Robert and William Rounds. (June 1986). A Logical Semantics for Feature Structures. Proceedings of the 24th meeting of the ACL. Columbia University, New York, NY: ACL, 257-266.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Kay</author>
</authors>
<title>Functional Grammar.</title>
<date>1979</date>
<booktitle>Proceedings of the 5th meeting of the</booktitle>
<institution>Berkeley Linguistics Society. Berkeley Linguistics Society.</institution>
<contexts>
<context position="1168" citStr="Kay, 1979" startWordPosition="166" endWordPosition="167">onditions. We have implemented an extension of traditional functional unification. This extension addresses these limitations while preserving the desirable properties of FUGs. It is based on the notions of typed features and typed constituents. We show the advantages of this extension in the context of a grammar used for text generation. 1 INTRODUCTION Unification-based formalisms are increasingly used in linguistic theories (Shieber, 1986) and computational linguistics. In particular, one type of unification formalism, functional unification grammar (FUG) is widely used for text generation (Kay, 1979, McKeown, 1985, Appelt, 1985, Paris, 1987, McKeown &amp; Elhadad, 1990) and is beginning to be used for parsing (Kay, 1985, Kasper, 1987). FUG enjoys such popularity mainly because it allies expressiveness with a simple economical formalism. It uses very few primitives, has a clean semantics (Pereira&amp;Shieber, 1984, Kasper &amp; Rounds, 1986, Elhadad, 1990), is monotonic, and grants equal status to function and structure in the descriptions. We have implemented a functional unifier (Elhadad, 1988) covering all the features described in (Kay, 1979) and (McKeown &amp; Paris, 1987). Having used this implemen</context>
<context position="3196" citStr="Kay, 1979" startWordPosition="480" endWordPosition="481">this structure in a manner similar to (AltKaci, 1984). We then introduce the notion of typed constituents and the FSET construct. It allows the declaration of explicit constraints on the set of admissible paths in functional descriptions. Typing the primitive elements of the formalism and the constituents allows a more concise expression of grammars and better checking of the input descriptions. It also provides more readable and better documented grammars. Most work in computational linguistics using a unification-based formalism (e.g., (Sag &amp; Pollard, 1987, Uszkoreit, 1986, Karttunen, 1986, Kay, 1979, Kaplan &amp; Bresnan, 1982)) does not make use of explicit typing. In (Ait-Kaci, 1984), Ait-Kaci introduced Y-terms, which are very similar to feature structures, and introduced the use of type inheritance in unification. &apos;P-terms were intended to be general-purpose programming constructs. We base our extension for typed features on this work but we also add the notion of typed constituents and the ability to express completeness constraints. We also integrate the idea of typing with the particulars of FUGs (notion of constituent, NONE, ANY and CSET constructs) and show the relevance of typing f</context>
<context position="4444" citStr="Kay, 1979" startWordPosition="692" endWordPosition="693">NAL FUNCTIONAL UNIFICATION ALGORITHM The Functional Unifier takes as input two descriptions, called functional descriptions or FDs and produces a new FD if unification succeeds and failure otherwise. An FD describes a set of objects (most often linguistic entities) that satisfy certain properties. It is represented by a set of pairs [ a : v], called features, where a is an attribute (the name of the property) and v is a value, either an atomic symbol or recursively an FD. An attribute a is allowed to appear at most once in a given FD F, so that the phrase &amp;quot;the a of F&amp;quot; is always non ambiguous (Kay, 1979). It is possible to define a natural partial order over the set of FDs. An FD Xis more specific than the FD Y if X contains at least all the features of Y (that is X c Y). Two FDs are compatible if they are not contradictory on the value of an attribute. Let X and Y be two compatible FDs. The unification of X and Y is by 157 definition the most general FD that is more specific than both X and For example, the unification of {year:88, time:{hour:5}) and {time:{mns:22), month:101 is lyear:88, month:10, time:(hour:5, irms:221). When properties are simple (all the values are atomic), unification i</context>
</contexts>
<marker>Kay, 1979</marker>
<rawString>Kay, M. (1979). Functional Grammar. Proceedings of the 5th meeting of the Berkeley Linguistics Society. Berkeley Linguistics Society.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Kay</author>
</authors>
<title>Parsing in Unification grammar.</title>
<date>1985</date>
<booktitle>In Dowty, Karttunen &amp; Zwicky (Ed.), Natural Language Parsing.</booktitle>
<publisher>Cambridge University Press.</publisher>
<location>Cambridge, England:</location>
<contexts>
<context position="1287" citStr="Kay, 1985" startWordPosition="186" endWordPosition="187">ations while preserving the desirable properties of FUGs. It is based on the notions of typed features and typed constituents. We show the advantages of this extension in the context of a grammar used for text generation. 1 INTRODUCTION Unification-based formalisms are increasingly used in linguistic theories (Shieber, 1986) and computational linguistics. In particular, one type of unification formalism, functional unification grammar (FUG) is widely used for text generation (Kay, 1979, McKeown, 1985, Appelt, 1985, Paris, 1987, McKeown &amp; Elhadad, 1990) and is beginning to be used for parsing (Kay, 1985, Kasper, 1987). FUG enjoys such popularity mainly because it allies expressiveness with a simple economical formalism. It uses very few primitives, has a clean semantics (Pereira&amp;Shieber, 1984, Kasper &amp; Rounds, 1986, Elhadad, 1990), is monotonic, and grants equal status to function and structure in the descriptions. We have implemented a functional unifier (Elhadad, 1988) covering all the features described in (Kay, 1979) and (McKeown &amp; Paris, 1987). Having used this implementation extensively, we have found all these properties very useful, but we also have met with limitations. The function</context>
</contexts>
<marker>Kay, 1985</marker>
<rawString>Kay, M. (1985). Parsing in Unification grammar. In Dowty, Karttunen &amp; Zwicky (Ed.), Natural Language Parsing. Cambridge, England: Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kevin Knight</author>
</authors>
<title>Unification: a Multidisciplinary Survey.</title>
<date>1989</date>
<journal>Computing Surveys,</journal>
<volume>21</volume>
<issue>1</issue>
<pages>93--124</pages>
<contexts>
<context position="5915" citStr="Knight, 1989" startWordPosition="971" endWordPosition="972">ifferent values for the same label); second, values of features can be complex FDs. The mechanism of unification is therefore a little more complex than suggested, but the EU mechanism is abstractly best understood as a union operation over FDs (cf (Kay, 1979) for a full description of the algorithm). Note that contrary to structural unification (SU, as used in Prolog for example), FU is not based on order and length. Therefore, 1 a : 1 , b : 2 ) and•{ b : 2 , a :1 } are equivalent in FU but not in SU, and a :1 ) and lb:2, ad) are compatible in FU but not in SU (FDs have no fixed arity) (cf. (Knight, 1989, p.105) for a comparison SU vs. FU). TERMINOLOGY: We introduce here terms that constitute a convenient vocabulary to describe our extensions. In the rest of the paper, we consider the unification of two FDs that we call input and gramma. We define L as a set of labels or attribute names and C as a set of constants, or simple atomic values. A string of labels (that is an element of Ls) is called a path, and is noted &lt;11...11.. A grammar defines a domain of admissible paths, A c L&apos;. A defines the skeleton of well-formed FD:s. • An FD can be an atom (element of C) or a set of features. One of th</context>
</contexts>
<marker>Knight, 1989</marker>
<rawString>Knight, Kevin. (March 1989). Unification: a Multidisciplinary Survey. Computing Surveys, 21(1), 93-124.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kathleen R McKeown</author>
</authors>
<title>Text Generation: Using Discourse Strategies and Focus Constraints to Generate Natural Language Text.</title>
<date>1985</date>
<booktitle>Studies in Natural Language Processing.</booktitle>
<publisher>Cambridge University Press.</publisher>
<location>Cambridge, England:</location>
<contexts>
<context position="1183" citStr="McKeown, 1985" startWordPosition="168" endWordPosition="169">We have implemented an extension of traditional functional unification. This extension addresses these limitations while preserving the desirable properties of FUGs. It is based on the notions of typed features and typed constituents. We show the advantages of this extension in the context of a grammar used for text generation. 1 INTRODUCTION Unification-based formalisms are increasingly used in linguistic theories (Shieber, 1986) and computational linguistics. In particular, one type of unification formalism, functional unification grammar (FUG) is widely used for text generation (Kay, 1979, McKeown, 1985, Appelt, 1985, Paris, 1987, McKeown &amp; Elhadad, 1990) and is beginning to be used for parsing (Kay, 1985, Kasper, 1987). FUG enjoys such popularity mainly because it allies expressiveness with a simple economical formalism. It uses very few primitives, has a clean semantics (Pereira&amp;Shieber, 1984, Kasper &amp; Rounds, 1986, Elhadad, 1990), is monotonic, and grants equal status to function and structure in the descriptions. We have implemented a functional unifier (Elhadad, 1988) covering all the features described in (Kay, 1979) and (McKeown &amp; Paris, 1987). Having used this implementation extensiv</context>
</contexts>
<marker>McKeown, 1985</marker>
<rawString>McKeown, Kathleen R. (1985). Text Generation: Using Discourse Strategies and Focus Constraints to Generate Natural Language Text. Studies in Natural Language Processing. Cambridge, England: Cambridge University Press.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Kathleen McKeown</author>
<author>Michael Elhadad</author>
</authors>
<title>A Contrastive Evaluation of Functional Unification Grammar for Surface Language Generators: A Case Study in Choice of Connectives.</title>
<date>1990</date>
<booktitle>In Cecile</booktitle>
<tech>Technical Report CUCS-407-88,</tech>
<publisher>Kluwer Academic Publishers.</publisher>
<institution>Columbia University).</institution>
<note>to appear, also available as</note>
<contexts>
<context position="1236" citStr="McKeown &amp; Elhadad, 1990" startWordPosition="174" endWordPosition="177">ional functional unification. This extension addresses these limitations while preserving the desirable properties of FUGs. It is based on the notions of typed features and typed constituents. We show the advantages of this extension in the context of a grammar used for text generation. 1 INTRODUCTION Unification-based formalisms are increasingly used in linguistic theories (Shieber, 1986) and computational linguistics. In particular, one type of unification formalism, functional unification grammar (FUG) is widely used for text generation (Kay, 1979, McKeown, 1985, Appelt, 1985, Paris, 1987, McKeown &amp; Elhadad, 1990) and is beginning to be used for parsing (Kay, 1985, Kasper, 1987). FUG enjoys such popularity mainly because it allies expressiveness with a simple economical formalism. It uses very few primitives, has a clean semantics (Pereira&amp;Shieber, 1984, Kasper &amp; Rounds, 1986, Elhadad, 1990), is monotonic, and grants equal status to function and structure in the descriptions. We have implemented a functional unifier (Elhadad, 1988) covering all the features described in (Kay, 1979) and (McKeown &amp; Paris, 1987). Having used this implementation extensively, we have found all these properties very useful, </context>
<context position="20220" citStr="McKeown &amp; Elhadad, 1990" startWordPosition="3295" endWordPosition="3298"> certain situations. The structure of C can be used as a metadescription of the grammar: the type declarations specify what the grammar knows, and are used to check input FDs. It allows the writing of much more concise grammars, which perform more efficiently. It is a great resource for documenting the grammar. The extended formalism described in this paper is implemented in Common Lisp using the Union-Find algorithm (Elhadad, 1988), as suggested in (Huet, 1976, Ait-Kaci, 1984, Escalada-Imaz &amp; Ghallab, 1988) and is used in several research projects (Smadja &amp; McKeown, 1990, Elhadad eta!, 1989, McKeown &amp; Elhadad, 1990, McKeown et al, 1991). The source code for the unifier is available to other researchers. Please contact the author for further details. We are investigating other extensions to the FU formalism, and particularly, ways to modify control over grammars: we have developed indexing schemes for more efficient search through the grammar and have extended the formalism to allow the expression of complex constraints (set union and intersection). We are now exploring ways to integrate these later extensions more tightly to the FUG formalism. ACKNOWLEDGMENTS This work was supported by DARPA under contr</context>
</contexts>
<marker>McKeown, Elhadad, 1990</marker>
<rawString>McKeown, Kathleen and Michael Elhadad. (1990). A Contrastive Evaluation of Functional Unification Grammar for Surface Language Generators: A Case Study in Choice of Connectives. In Cecile L Paris, William R. Swartout and William C. Mann (Eds.), Natural Language Generation in Artificial Intelligence and Computational Linguistics. Kluwer Academic Publishers. (to appear, also available as Technical Report CUCS-407-88, Columbia University).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kathleen R McKeown</author>
<author>Cecile L Paris</author>
</authors>
<title>Functional Unification Grammar Revisited.</title>
<date>1987</date>
<booktitle>Proceedings of the ACL conference. ACL,</booktitle>
<pages>97--103</pages>
<contexts>
<context position="1741" citStr="McKeown &amp; Paris, 1987" startWordPosition="254" endWordPosition="257">UG) is widely used for text generation (Kay, 1979, McKeown, 1985, Appelt, 1985, Paris, 1987, McKeown &amp; Elhadad, 1990) and is beginning to be used for parsing (Kay, 1985, Kasper, 1987). FUG enjoys such popularity mainly because it allies expressiveness with a simple economical formalism. It uses very few primitives, has a clean semantics (Pereira&amp;Shieber, 1984, Kasper &amp; Rounds, 1986, Elhadad, 1990), is monotonic, and grants equal status to function and structure in the descriptions. We have implemented a functional unifier (Elhadad, 1988) covering all the features described in (Kay, 1979) and (McKeown &amp; Paris, 1987). Having used this implementation extensively, we have found all these properties very useful, but we also have met with limitations. The functional unification (FU) formalism is not well suited for the expression of simple, yet very common, taxonomic relations. The traditional way to implement such relations in FUG is verbose, inefficient and unreadable. It is also impossible to express completeness constraints on descriptions. In this paper, we present several extensions to the FU formalism that address these limitations. These extensions are based on the formal semantics presented in (Elhar</context>
</contexts>
<marker>McKeown, Paris, 1987</marker>
<rawString>McKeown, Kathleen R. and Paris, Cecile L. (July 1987). Functional Unification Grammar Revisited. Proceedings of the ACL conference. ACL, 97-103.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Smadja</author>
</authors>
<title>Natural Language Generation in COMET. In</title>
<date>1991</date>
<booktitle>Proceedings of the second European Workshop on Natural Language Generation.</booktitle>
<note>To appear.</note>
<marker>Smadja, 1991</marker>
<rawString>McKeown, K., Elhadad, M., Fukumoto, Y., Lim, J., Lombardi, C., Robin,]. and Smadja, F. (1991). Natural Language Generation in COMET. In Dale, R., Mellish, C. and Zock, M. (Ed.), Proceedings of the second European Workshop on Natural Language Generation. To appear.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Cecile L Paris</author>
</authors>
<title>The Use of Explicit User models in Text Generation: Tailoring to a User&apos;s level of expertise. Doctoral dissertation,</title>
<date>1987</date>
<institution>Columbia University.</institution>
<contexts>
<context position="1210" citStr="Paris, 1987" startWordPosition="172" endWordPosition="173">ion of traditional functional unification. This extension addresses these limitations while preserving the desirable properties of FUGs. It is based on the notions of typed features and typed constituents. We show the advantages of this extension in the context of a grammar used for text generation. 1 INTRODUCTION Unification-based formalisms are increasingly used in linguistic theories (Shieber, 1986) and computational linguistics. In particular, one type of unification formalism, functional unification grammar (FUG) is widely used for text generation (Kay, 1979, McKeown, 1985, Appelt, 1985, Paris, 1987, McKeown &amp; Elhadad, 1990) and is beginning to be used for parsing (Kay, 1985, Kasper, 1987). FUG enjoys such popularity mainly because it allies expressiveness with a simple economical formalism. It uses very few primitives, has a clean semantics (Pereira&amp;Shieber, 1984, Kasper &amp; Rounds, 1986, Elhadad, 1990), is monotonic, and grants equal status to function and structure in the descriptions. We have implemented a functional unifier (Elhadad, 1988) covering all the features described in (Kay, 1979) and (McKeown &amp; Paris, 1987). Having used this implementation extensively, we have found all thes</context>
</contexts>
<marker>Paris, 1987</marker>
<rawString>Paris, Cecile L. (1987). The Use of Explicit User models in Text Generation: Tailoring to a User&apos;s level of expertise. Doctoral dissertation, Columbia University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fernando Pereira</author>
</authors>
<title>A Structure Sharing Formalism for Unification-based Formalisms.</title>
<date>1985</date>
<booktitle>Proceedings of the 23rd annual meeting of the ACL. ACL,</booktitle>
<pages>137--144</pages>
<contexts>
<context position="18762" citStr="Pereira, 1985" startWordPosition="3052" endWordPosition="3053">arations. The second advantage is that it can be used to define more efficient data-structures to represent FDs. As suggested by the definition of FDs, two types of data-structures can be used to internally represent FDs: a flat list of equations (which is more appropriate for a language like Prolog) and a structured representation (which is more natural for a language like Lisp). When all constituents are typed, it becomes possible to use arrays or hash-tables to store FDs in Lisp, which is much more efficient. We are currently investigating alternative internal representations for FDs (cf. (Pereira, 1985, Karttunen, 1985, Boyer, 1988, Hirsh, 1988) for discussions of data-structures and compilation of FUGs). 5 CONCLUSION Functional Descriptions are built from two components: a set C of primitives and a set L of labels. Traditionally, all structuring of FDs is done using strings of labels. We have shown in this paper that there is much to be gained by delegating some of the structuring to a set of primitives. The set C is no longer a flat set of symbols, but is viewed as a richly structured world. The idea of typed-unification is not new (Ait-Kaci, 1984), but we have integrated it for the first</context>
</contexts>
<marker>Pereira, 1985</marker>
<rawString>Pereira, Fernando. (1985). A Structure Sharing Formalism for Unification-based Formalisms. Proceedings of the 23rd annual meeting of the ACL. ACL, 137-144.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fernando Pereira</author>
<author>Stuart Shieber</author>
</authors>
<title>The Semantics of Grammar Formalisms Seen as Computer Languages.</title>
<date>1984</date>
<booktitle>Proceedings of the Tenth International Conference on Computational Linguistics.</booktitle>
<pages>123--129</pages>
<publisher>ACL,</publisher>
<institution>Stanford University,</institution>
<location>Stanford, Ca:</location>
<marker>Pereira, Shieber, 1984</marker>
<rawString>Pereira, Fernando and Stuart Shieber. (July 1984). The Semantics of Grammar Formalisms Seen as Computer Languages. Proceedings of the Tenth International Conference on Computational Linguistics. Stanford University, Stanford, Ca: ACL, 123-129.</rawString>
</citation>
<citation valid="true">
<authors>
<author>I A Sag</author>
<author>C Pollard</author>
</authors>
<title>Head-driven phrase structure grammar: an informal synopsis.</title>
<date>1987</date>
<tech>Technical Report CSL1-87-79,</tech>
<institution>Center for</institution>
<contexts>
<context position="3151" citStr="Sag &amp; Pollard, 1987" startWordPosition="472" endWordPosition="475">used in the grammar. The unifier can take advantage of this structure in a manner similar to (AltKaci, 1984). We then introduce the notion of typed constituents and the FSET construct. It allows the declaration of explicit constraints on the set of admissible paths in functional descriptions. Typing the primitive elements of the formalism and the constituents allows a more concise expression of grammars and better checking of the input descriptions. It also provides more readable and better documented grammars. Most work in computational linguistics using a unification-based formalism (e.g., (Sag &amp; Pollard, 1987, Uszkoreit, 1986, Karttunen, 1986, Kay, 1979, Kaplan &amp; Bresnan, 1982)) does not make use of explicit typing. In (Ait-Kaci, 1984), Ait-Kaci introduced Y-terms, which are very similar to feature structures, and introduced the use of type inheritance in unification. &apos;P-terms were intended to be general-purpose programming constructs. We base our extension for typed features on this work but we also add the notion of typed constituents and the ability to express completeness constraints. We also integrate the idea of typing with the particulars of FUGs (notion of constituent, NONE, ANY and CSET c</context>
</contexts>
<marker>Sag, Pollard, 1987</marker>
<rawString>Sag, I.A. and Pollard, C. (1987). Head-driven phrase structure grammar: an informal synopsis. Technical Report CSL1-87-79, Center for the Study of Language and Information.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart Shieber</author>
</authors>
<title>An introduction to Unification-Based Approaches to Grammar.</title>
<date>1986</date>
<journal>CSLI Lecture Notes.</journal>
<volume>4</volume>
<publisher>University of Chicago Press.</publisher>
<location>Chicago, II:</location>
<contexts>
<context position="1004" citStr="Shieber, 1986" startWordPosition="143" endWordPosition="144">o has annoying limitations: it is not suited for the expression of simple, yet very common, taxonomic relations and it does not allow the specification of completeness conditions. We have implemented an extension of traditional functional unification. This extension addresses these limitations while preserving the desirable properties of FUGs. It is based on the notions of typed features and typed constituents. We show the advantages of this extension in the context of a grammar used for text generation. 1 INTRODUCTION Unification-based formalisms are increasingly used in linguistic theories (Shieber, 1986) and computational linguistics. In particular, one type of unification formalism, functional unification grammar (FUG) is widely used for text generation (Kay, 1979, McKeown, 1985, Appelt, 1985, Paris, 1987, McKeown &amp; Elhadad, 1990) and is beginning to be used for parsing (Kay, 1985, Kasper, 1987). FUG enjoys such popularity mainly because it allies expressiveness with a simple economical formalism. It uses very few primitives, has a clean semantics (Pereira&amp;Shieber, 1984, Kasper &amp; Rounds, 1986, Elhadad, 1990), is monotonic, and grants equal status to function and structure in the descriptions</context>
</contexts>
<marker>Shieber, 1986</marker>
<rawString>Shieber, Stuart. (1986). CSLI Lecture Notes. Vol. 4: An introduction to Unification-Based Approaches to Grammar. Chicago, II: University of Chicago Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Frank A Smadja</author>
<author>Kathleen R McKeown</author>
</authors>
<title>Automatically Extracting and Representing Collocations for Language Generation.</title>
<date>1990</date>
<booktitle>Proceedings of the 28th annual meeting of the ACL.</booktitle>
<publisher>ACL.</publisher>
<location>Pittsburgh:</location>
<contexts>
<context position="20175" citStr="Smadja &amp; McKeown, 1990" startWordPosition="3288" endWordPosition="3291">ent and reason about complete information in certain situations. The structure of C can be used as a metadescription of the grammar: the type declarations specify what the grammar knows, and are used to check input FDs. It allows the writing of much more concise grammars, which perform more efficiently. It is a great resource for documenting the grammar. The extended formalism described in this paper is implemented in Common Lisp using the Union-Find algorithm (Elhadad, 1988), as suggested in (Huet, 1976, Ait-Kaci, 1984, Escalada-Imaz &amp; Ghallab, 1988) and is used in several research projects (Smadja &amp; McKeown, 1990, Elhadad eta!, 1989, McKeown &amp; Elhadad, 1990, McKeown et al, 1991). The source code for the unifier is available to other researchers. Please contact the author for further details. We are investigating other extensions to the FU formalism, and particularly, ways to modify control over grammars: we have developed indexing schemes for more efficient search through the grammar and have extended the formalism to allow the expression of complex constraints (set union and intersection). We are now exploring ways to integrate these later extensions more tightly to the FUG formalism. ACKNOWLEDGMENTS</context>
</contexts>
<marker>Smadja, McKeown, 1990</marker>
<rawString>Smadja, Frank A. and McKeown, Kathleen R. (1990). Automatically Extracting and Representing Collocations for Language Generation. Proceedings of the 28th annual meeting of the ACL. Pittsburgh: ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ham Uszkoreit</author>
</authors>
<title>Categorial Unification Grammars.</title>
<date>1986</date>
<contexts>
<context position="3168" citStr="Uszkoreit, 1986" startWordPosition="476" endWordPosition="477">The unifier can take advantage of this structure in a manner similar to (AltKaci, 1984). We then introduce the notion of typed constituents and the FSET construct. It allows the declaration of explicit constraints on the set of admissible paths in functional descriptions. Typing the primitive elements of the formalism and the constituents allows a more concise expression of grammars and better checking of the input descriptions. It also provides more readable and better documented grammars. Most work in computational linguistics using a unification-based formalism (e.g., (Sag &amp; Pollard, 1987, Uszkoreit, 1986, Karttunen, 1986, Kay, 1979, Kaplan &amp; Bresnan, 1982)) does not make use of explicit typing. In (Ait-Kaci, 1984), Ait-Kaci introduced Y-terms, which are very similar to feature structures, and introduced the use of type inheritance in unification. &apos;P-terms were intended to be general-purpose programming constructs. We base our extension for typed features on this work but we also add the notion of typed constituents and the ability to express completeness constraints. We also integrate the idea of typing with the particulars of FUGs (notion of constituent, NONE, ANY and CSET constructs) and sh</context>
</contexts>
<marker>Uszkoreit, 1986</marker>
<rawString>Uszkoreit, Ham. (1986). Categorial Unification Grammars.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Terry Winograd</author>
</authors>
<title>Language as a Cognitive Process.</title>
<date>1983</date>
<publisher>Addison-Wesley.</publisher>
<location>Reading, Ma.:</location>
<contexts>
<context position="8608" citStr="Winograd, 1983" startWordPosition="1447" endWordPosition="1448">resented in (Elhadad, 1990). 3 TYPED FEATURES A LIMITATION OF RIGS: NO STRUCTURE OVER THE SET OF VALUES: In FU, the set of constants C has no structure. It is a fiat collection of symbols with no relations between each other. All constraints among symbols must be expressed in the grammar. In linguistics, however, grammars assume a rich structure between properties: some groups of features are mutually exclusive; some features are only defined in the context of other features. Let&apos;s consider a fragment of grammar describing noun-phrases (NPs) (cf Figure 1) using the systemic notation given in (Winograd, 1983). Systemic networks, such as this one, encode the choices that need to be made to produce a complex linguistic entity. They indicate how features can be combined or whether features are inconsistent with other combinations. The configuration illustrated by this fragment is typical, and occurs very often in grammars.&apos; The schema indicates that a noun can be either a pronoun, a proper noun or a common noun. Note that these 1 Question 1 Personal Pronoun --1 1 Demonstrative 1 Quantified Noun Proper 1 Count Common --- 1 1 Mass Figure 1: A system for NPs &apos;We have implemented a grammar similar to (Wi</context>
</contexts>
<marker>Winograd, 1983</marker>
<rawString>Winograd, Terry. (1983). Language as a Cognitive Process. Reading, Ma.: Addison-Wesley.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>