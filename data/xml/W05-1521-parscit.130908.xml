<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.091858">
<title confidence="0.969224">
The Quick Check Pre-unification Filter for Typed Grammars: Extensions
</title>
<author confidence="0.962184">
Liviu Ciortuz
</author>
<affiliation confidence="0.931848">
CS Department, University of Ias¸i, Romania
</affiliation>
<email confidence="0.969973">
ciortuz@infoiasi.ro
</email>
<bodyText confidence="0.999771916666667">
The so called quick check (henceforth QC) pre-
unification filter for feature structure (FS) unifica-
tion was introduced by (Kiefer et al., 1999). QC is
considered the most important speed-up technique
in the framework of non-compiled FS unification.
We present two potential ways in which the design
of the quick check can be further extended: con-
sistency sort check on coreferenced paths, and pre-
unification type-checking. We analyse the effect of
these extensions on LinGO, the large-scale HPSG
grammar for English (Flickinger et al., 2000) using
the compiler system LIGHT (Ciortuz, 2002).
</bodyText>
<sectionHeader confidence="0.9573" genericHeader="abstract">
1 Coreferenced Based Quick Check
</sectionHeader>
<bodyText confidence="0.998079333333334">
Suppose that the FS ϕ is going to be unified with
ψ, and that ϕ contains the coreference ϕ.π .� ϕ.π&apos;.
In this setup, if for a certain path η it happens that
sort(ϕ.(πη)) ∧ sort(ψ.(πη)) ∧ sort(ψ.(π&apos;η)) = L,
then certainly ϕ and ψ are not unifiable. There is
no a priori reason why, on certain typed grammars,
coreference-based sort inconsistency would not be
more effective in ruling out FS unification than sort
inconsistency on mutual paths. Moreover, the in-
tegration of the two forms of QC is not compli-
cated. However, up to our knowledge no system
parsing LinGO-like grammars included the above
newly presented form of (coreference-based) pre-
unification QC test.
On the GR-reduced form LinGO (Ciortuz, 2004)
we identified 12 pairs of non-cross argument coref-
erences inside rule arguments (at LinGO’s source
level). Interestingly enough, all these coreferences
occur inside key arguments, belonging to only 8 (out
of the total of 61) rules in LinGO.
To perform coreference-based QC, we computed
the closure of this set A of coreference paths. The
closure of A will be denoted A. If the pair π1 and π2
is in A, then together with it will be included in A� all
pairs of QC-paths such that π1η and π2η, where η
is a feature path (a common suffix to the two newly
selected paths). For the GR-reduced form of LinGO,
the closure of A defined as above amounted to 38
pairs. It is on these pairs of paths that we performed
the coreference-based QC test.
Using all these coreference paths pairs, 70,581
unification failures (out of a total of 2,912,623 at-
tempted unifications) were detected on the CSLI test
suite. Only 364 of these failures were not detectable
through classical QC. When measuring the “sensi-
tivity” of coreferenced-based QC to individual rule
arguments, we found that out of a total of 91 rule
arguments in LinGO only for 4 rule arguments the
coreference-based QC detects inconsistencies, and
the number of these inconsistencies is far lower than
those detected by the classical QC on the same ar-
guments. None of the pairs of coreference paths ex-
hibited a higher failure detection rate than the first
ranked 32 QC-paths. If one would work with 42 QC-
paths, then only 4 of the pairs of coreference paths
would score failure detection frequencies that would
qualify them to be taken into consideration for the
(extended form of) QC-test.
As a conclusion, it is clear that for LinGO, run-
ning the coreference-based QC test is virtually of
no use. For other grammars (or other applications
involving FS unification), one may come to a dif-
ferent conclusion, if the use of non-cross argument
coreferences balances (or outnumbers) that of cross-
</bodyText>
<page confidence="0.944744">
188
</page>
<bodyText confidence="0.674185">
Proceedings of the Ninth International Workshop on Parsing Technologies (IWPT), pages 188–189,
Vancouver, October 2005. c�2005 Association for Computational Linguistics
argument coreferences.
</bodyText>
<sectionHeader confidence="0.735951" genericHeader="categories and subject descriptors">
2 Type Checking Based Quick Check
</sectionHeader>
<bodyText confidence="0.92335972">
Failure of run-time type checking — the third po-
tential source of inconsistency when unifying two
typed FSs — is in general not so easily/efficiently
detectable at pre-unification time, because this check
requires calling a type consistency check routine
which is much more expensive than the simple sort
consistency operation.
While exploring the possibility to filter unifica-
tion failures due to type-checking, the measurements
we did using LinGO (the GR-reduced form) on the
CSLI test suite resulted in the following facts:
1. Only 137 types out of all 5235 (non-rule and non-
lexical) types in LinGO were involved in (either suc-
cessful or failed) type-checks.1 Of these types, only
29 types were leading to type checking failure.2
2. Without using QC, 449,779 unification fail-
ures were due to type-checking on abstract instruc-
tions, namely on intersects sort; type-checking on
test feature acts in fact as type unfolding. When
the first 32 QC-paths (from the GR-set of paths)
were used (as standard), that number of failures went
down to 92,447. And when using all 132 QC-paths
(which have been detected on the non GR-reduced
form of LinGO), it remained close to the preceding
figure: 86,841.
</bodyText>
<listItem confidence="0.938342">
3. For QC on 32 paths, we counted that failed type-
checking at intersect sort occurs only on 14 GR-
paths. Of these paths, only 9 produced more than
1000 failures, only 4 produced more than 10,000
failures and finally, for only one GR-path the num-
ber of failed type-checks exceeded 20,000.
</listItem>
<bodyText confidence="0.9998787">
The numbers given at the above second point sug-
gest that when trying to extend the ‘classical’ form
of QC towards finding all/most of failures, a consid-
erably high number of type inconsistencies will re-
main in the FSs produced during parsing, even when
we use all (GR-paths as) QC-paths. Most of these in-
consistencies are due to failed type-checking. And
as shown, neither the classical QC nor its exten-
sion to (non-cross argument) coreference-based QC
is able to detect these inconsistencies.
</bodyText>
<footnote confidence="0.9999025">
1For 32 QC-paths: 122 types, for 132 QC-paths: also 122.
2For 32 QC-paths and 132 QC-paths: 24 and 22 respectively.
</footnote>
<figure confidence="0.932739636363636">
s = GRϕ[ i ] ∧ GRψ[ i ];
if s =� GRϕ[ i ] and s =� GRψ[ i ] and
ϕ.π; or ψ.π; is defined for
a certain non-empty path π; = πiπ,
an extension of πi,
such that π; is a QC-path,
then
if T(s).π∧ GR,p[i] = L, where
a T(s) is the type corresponding to s,
or type-checking ψ.πi with T(s) fails
then ϕ and ψ do not unify.
</figure>
<figureCaption confidence="0.997809">
Figure 1: The core of a type-checking specialised
compiled QC sub-procedure.
</figureCaption>
<bodyText confidence="0.9999725625">
The first and third points from above say that in
parsing the CSLI test suite with LinGO, the failures
due to type checking tend to agglomerate on cer-
tain paths. But due to the fact that type-checking
is usually time-costly, our conclusion, like in the
case of non-cross argument coreference-based QC,
is that extending the classical QC by doing a cer-
tain amount of type-checking at pre-unification time
is not likely to improve significantly the unification
(and parsing) performances on LinGO.
For another type-unification grammar one can ex-
tend (or replace) the classical QC test with a type-
check QC filter procedure. Basically, after identify-
ing the set of paths (and types) which most probably
cause failure during type-checking, that procedure
works as shown in Figure 1.
</bodyText>
<sectionHeader confidence="0.999256" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999528333333333">
L. Ciortuz. 2002. LIGHT — a constraint language and
compiler system for typed-unification grammars. KI-
2002: Advances in Artificial Intelligence. M. Jarke, J.
Koehler and G. Lakemeyer (eds.), pp. 3–17. Springer-
Verlag, vol. 2479.
L. Ciortuz. 2004. On two classes of feature paths in
large-scale unification grammars. Recent Advances in
Parsing Technologies. H. Bunt, J. carroll and G. Satta
(eds.). Kluwer Academic Publishers.
D. Flickinger, A. Copestake and I. Sag. 2000. HPSG
analysis of English. Verbmobil: Foundations of
speech-to-speech translation. Wolfgang Wahlster
(ed.), pp. 254–263. Springer-Verlag.
B. Kiefer, H-U. Krieger, J. Carroll and R. Malouf. 1999.
A bag of useful techniques for efficient and robust
parsing. Proceedings ofthe 37th annual meeting of the
Association for Computational Linguistics, pp. 473–
480.
</reference>
<page confidence="0.998923">
189
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.073157">
<title confidence="0.999166">The Quick Check Pre-unification Filter for Typed Grammars: Extensions</title>
<author confidence="0.982311">Liviu Ciortuz</author>
<affiliation confidence="0.989847">Department, University of</affiliation>
<abstract confidence="0.991390952702703">ciortuz@infoiasi.ro The so called quick check (henceforth QC) preunification filter for feature structure (FS) unification was introduced by (Kiefer et al., 1999). QC is considered the most important speed-up technique in the framework of non-compiled FS unification. We present two potential ways in which the design of the quick check can be further extended: consistency sort check on coreferenced paths, and preunification type-checking. We analyse the effect of these extensions on LinGO, the large-scale HPSG grammar for English (Flickinger et al., 2000) using compiler system 2002). 1 Coreferenced Based Quick Check that the FS going to be unified with and that the coreference this setup, if for a certain path happens that = certainly not unifiable. There is no a priori reason why, on certain typed grammars, coreference-based sort inconsistency would not be more effective in ruling out FS unification than sort inconsistency on mutual paths. Moreover, the integration of the two forms of QC is not complicated. However, up to our knowledge no system parsing LinGO-like grammars included the above newly presented form of (coreference-based) preunification QC test. On the GR-reduced form LinGO (Ciortuz, 2004) we identified 12 pairs of non-cross argument coreferences inside rule arguments (at LinGO’s source level). Interestingly enough, all these coreferences occur inside key arguments, belonging to only 8 (out of the total of 61) rules in LinGO. To perform coreference-based QC, we computed closure of this set coreference paths. The of be denoted If the pair in then together with it will be included in of QC-paths such that where is a feature path (a common suffix to the two newly selected paths). For the GR-reduced form of LinGO, closure of as above amounted to 38 pairs. It is on these pairs of paths that we performed the coreference-based QC test. Using all these coreference paths pairs, 70,581 unification failures (out of a total of 2,912,623 attempted unifications) were detected on the CSLI test suite. Only 364 of these failures were not detectable through classical QC. When measuring the “sensitivity” of coreferenced-based QC to individual rule arguments, we found that out of a total of 91 rule arguments in LinGO only for 4 rule arguments the coreference-based QC detects inconsistencies, and the number of these inconsistencies is far lower than those detected by the classical QC on the same arguments. None of the pairs of coreference paths exhibited a higher failure detection rate than the first ranked 32 QC-paths. If one would work with 42 QCpaths, then only 4 of the pairs of coreference paths would score failure detection frequencies that would qualify them to be taken into consideration for the (extended form of) QC-test. As a conclusion, it is clear that for LinGO, running the coreference-based QC test is virtually of no use. For other grammars (or other applications involving FS unification), one may come to a different conclusion, if the use of non-cross argument balances (or outnumbers) that of cross- 188 of the Ninth International Workshop on Parsing Technologies pages 188–189, October 2005. Association for Computational Linguistics argument coreferences. 2 Type Checking Based Quick Check Failure of run-time type checking — the third potential source of inconsistency when unifying two typed FSs — is in general not so easily/efficiently detectable at pre-unification time, because this check requires calling a type consistency check routine which is much more expensive than the simple sort consistency operation. While exploring the possibility to filter unification failures due to type-checking, the measurements we did using LinGO (the GR-reduced form) on the CSLI test suite resulted in the following facts: 1. Only 137 types out of all 5235 (non-rule and nonlexical) types in LinGO were involved in (either sucor failed) Of these types, only types were leading to type checking 2. Without using QC, 449,779 unification failures were due to type-checking on abstract instrucnamely on type-checking on feature in fact as type unfolding. When the first 32 QC-paths (from the GR-set of paths) were used (as standard), that number of failures went down to 92,447. And when using all 132 QC-paths (which have been detected on the non GR-reduced form of LinGO), it remained close to the preceding figure: 86,841. 3. For QC on 32 paths, we counted that failed typeat sort only on 14 GRpaths. Of these paths, only 9 produced more than 1000 failures, only 4 produced more than 10,000 failures and finally, for only one GR-path the number of failed type-checks exceeded 20,000. The numbers given at the above second point suggest that when trying to extend the ‘classical’ form of QC towards finding all/most of failures, a considerably high number of type inconsistencies will remain in the FSs produced during parsing, even when we use all (GR-paths as) QC-paths. Most of these inconsistencies are due to failed type-checking. And as shown, neither the classical QC nor its extension to (non-cross argument) coreference-based QC is able to detect these inconsistencies. 32 QC-paths: 122 types, for 132 QC-paths: also 122. 32 QC-paths and 132 QC-paths: 24 and 22 respectively. i ] i ]; i ] and i ] and defined for certain non-empty path extension of that a QC-path, then = where the type corresponding to type-checking not unify. Figure 1: The core of a type-checking specialised compiled QC sub-procedure. The first and third points from above say that in parsing the CSLI test suite with LinGO, the failures due to type checking tend to agglomerate on certain paths. But due to the fact that type-checking usually time-costly, our like in the case of non-cross argument coreference-based QC, is that extending the classical QC by doing a certain amount of type-checking at pre-unification time is not likely to improve significantly the unification (and parsing) performances on LinGO. For another type-unification grammar one can ex- (or replace) the classical QC test with a type- QC filter Basically, after identifying the set of paths (and types) which most probably cause failure during type-checking, that procedure works as shown in Figure 1. References Ciortuz. 2002. a constraint language and system for typed-unification grammars. KI-</abstract>
<note confidence="0.803445">Advances in Artificial M. Jarke, J. Koehler and G. Lakemeyer (eds.), pp. 3–17. Springer- Verlag, vol. 2479. L. Ciortuz. 2004. On two classes of feature paths in unification grammars. Advances in H. Bunt, J. carroll and G. Satta (eds.). Kluwer Academic Publishers. D. Flickinger, A. Copestake and I. Sag. 2000. HPSG of English. Foundations of Wolfgang Wahlster (ed.), pp. 254–263. Springer-Verlag. B. Kiefer, H-U. Krieger, J. Carroll and R. Malouf. 1999. A bag of useful techniques for efficient and robust ofthe 37th annual meeting of the for Computational pp. 473– 480. 189</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>L Ciortuz</author>
</authors>
<title>LIGHT — a constraint language and compiler system for typed-unification grammars.</title>
<date>2002</date>
<booktitle>KI2002: Advances in Artificial Intelligence.</booktitle>
<volume>vol.</volume>
<pages>3--17</pages>
<editor>M. Jarke, J. Koehler and G. Lakemeyer (eds.),</editor>
<publisher>SpringerVerlag,</publisher>
<contexts>
<context position="736" citStr="Ciortuz, 2002" startWordPosition="108" endWordPosition="109">mania ciortuz@infoiasi.ro The so called quick check (henceforth QC) preunification filter for feature structure (FS) unification was introduced by (Kiefer et al., 1999). QC is considered the most important speed-up technique in the framework of non-compiled FS unification. We present two potential ways in which the design of the quick check can be further extended: consistency sort check on coreferenced paths, and preunification type-checking. We analyse the effect of these extensions on LinGO, the large-scale HPSG grammar for English (Flickinger et al., 2000) using the compiler system LIGHT (Ciortuz, 2002). 1 Coreferenced Based Quick Check Suppose that the FS ϕ is going to be unified with ψ, and that ϕ contains the coreference ϕ.π .� ϕ.π&apos;. In this setup, if for a certain path η it happens that sort(ϕ.(πη)) ∧ sort(ψ.(πη)) ∧ sort(ψ.(π&apos;η)) = L, then certainly ϕ and ψ are not unifiable. There is no a priori reason why, on certain typed grammars, coreference-based sort inconsistency would not be more effective in ruling out FS unification than sort inconsistency on mutual paths. Moreover, the integration of the two forms of QC is not complicated. However, up to our knowledge no system parsing LinGO-</context>
</contexts>
<marker>Ciortuz, 2002</marker>
<rawString>L. Ciortuz. 2002. LIGHT — a constraint language and compiler system for typed-unification grammars. KI2002: Advances in Artificial Intelligence. M. Jarke, J. Koehler and G. Lakemeyer (eds.), pp. 3–17. SpringerVerlag, vol. 2479.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Ciortuz</author>
</authors>
<title>On two classes of feature paths in large-scale unification grammars. Recent Advances in Parsing Technologies.</title>
<date>2004</date>
<editor>H. Bunt, J. carroll and G. Satta (eds.).</editor>
<publisher>Kluwer Academic Publishers.</publisher>
<contexts>
<context position="1481" citStr="Ciortuz, 2004" startWordPosition="234" endWordPosition="235">ϕ.π&apos;. In this setup, if for a certain path η it happens that sort(ϕ.(πη)) ∧ sort(ψ.(πη)) ∧ sort(ψ.(π&apos;η)) = L, then certainly ϕ and ψ are not unifiable. There is no a priori reason why, on certain typed grammars, coreference-based sort inconsistency would not be more effective in ruling out FS unification than sort inconsistency on mutual paths. Moreover, the integration of the two forms of QC is not complicated. However, up to our knowledge no system parsing LinGO-like grammars included the above newly presented form of (coreference-based) preunification QC test. On the GR-reduced form LinGO (Ciortuz, 2004) we identified 12 pairs of non-cross argument coreferences inside rule arguments (at LinGO’s source level). Interestingly enough, all these coreferences occur inside key arguments, belonging to only 8 (out of the total of 61) rules in LinGO. To perform coreference-based QC, we computed the closure of this set A of coreference paths. The closure of A will be denoted A. If the pair π1 and π2 is in A, then together with it will be included in A� all pairs of QC-paths such that π1η and π2η, where η is a feature path (a common suffix to the two newly selected paths). For the GR-reduced form of LinG</context>
</contexts>
<marker>Ciortuz, 2004</marker>
<rawString>L. Ciortuz. 2004. On two classes of feature paths in large-scale unification grammars. Recent Advances in Parsing Technologies. H. Bunt, J. carroll and G. Satta (eds.). Kluwer Academic Publishers.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Flickinger</author>
<author>A Copestake</author>
<author>I Sag</author>
</authors>
<title>HPSG analysis of English. Verbmobil: Foundations of speech-to-speech translation.</title>
<date>2000</date>
<pages>254--263</pages>
<editor>Wolfgang Wahlster (ed.),</editor>
<publisher>Springer-Verlag.</publisher>
<contexts>
<context position="688" citStr="Flickinger et al., 2000" startWordPosition="99" endWordPosition="102">sions Liviu Ciortuz CS Department, University of Ias¸i, Romania ciortuz@infoiasi.ro The so called quick check (henceforth QC) preunification filter for feature structure (FS) unification was introduced by (Kiefer et al., 1999). QC is considered the most important speed-up technique in the framework of non-compiled FS unification. We present two potential ways in which the design of the quick check can be further extended: consistency sort check on coreferenced paths, and preunification type-checking. We analyse the effect of these extensions on LinGO, the large-scale HPSG grammar for English (Flickinger et al., 2000) using the compiler system LIGHT (Ciortuz, 2002). 1 Coreferenced Based Quick Check Suppose that the FS ϕ is going to be unified with ψ, and that ϕ contains the coreference ϕ.π .� ϕ.π&apos;. In this setup, if for a certain path η it happens that sort(ϕ.(πη)) ∧ sort(ψ.(πη)) ∧ sort(ψ.(π&apos;η)) = L, then certainly ϕ and ψ are not unifiable. There is no a priori reason why, on certain typed grammars, coreference-based sort inconsistency would not be more effective in ruling out FS unification than sort inconsistency on mutual paths. Moreover, the integration of the two forms of QC is not complicated. Howev</context>
</contexts>
<marker>Flickinger, Copestake, Sag, 2000</marker>
<rawString>D. Flickinger, A. Copestake and I. Sag. 2000. HPSG analysis of English. Verbmobil: Foundations of speech-to-speech translation. Wolfgang Wahlster (ed.), pp. 254–263. Springer-Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Kiefer</author>
<author>H-U Krieger</author>
<author>J Carroll</author>
<author>R Malouf</author>
</authors>
<title>A bag of useful techniques for efficient and robust parsing.</title>
<date>1999</date>
<booktitle>Proceedings ofthe 37th annual meeting of the Association for Computational Linguistics,</booktitle>
<pages>473--480</pages>
<marker>Kiefer, Krieger, Carroll, Malouf, 1999</marker>
<rawString>B. Kiefer, H-U. Krieger, J. Carroll and R. Malouf. 1999. A bag of useful techniques for efficient and robust parsing. Proceedings ofthe 37th annual meeting of the Association for Computational Linguistics, pp. 473– 480.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>