<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.019240">
<title confidence="0.99959">
A Dynamic Programming Approach to
Document Length Constraints
</title>
<author confidence="0.993009">
Keith Vander Linden
</author>
<affiliation confidence="0.931058">
Department of Computer Science
Calvin College
</affiliation>
<address confidence="0.856319">
Grand Rapids, MI 49546, USA
</address>
<email confidence="0.99572">
kvlinden@calvin.edu
</email>
<sectionHeader confidence="0.995589" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999278071428572">
Natural language generation (NLG) applica-
tions must occasionally deliver rhetorically
coherent output under length constraints. For
example, certain types of documents must fit
on a single webpage, on a cell phone screen,
or into a fixed number of printed pages. To
date, applications have achieved this goal by
structuring their content as a rhetorical tree
and using a greedy algorithm to pick the dis-
course elements to include in the final docu-
ment. Greedy algorithms are known to pick
sub-optimal solutions. This paper presents an
alternate approach based on dynamic pro-
gramming.
</bodyText>
<sectionHeader confidence="0.966993" genericHeader="method">
1 Document Length Constraints
</sectionHeader>
<bodyText confidence="0.999983071428571">
A number of language engineering applications
have addressed the issue of generating coherent
documents under length constraints, including
NLG applications, e.g., SciFly (Paris, et al, 2008),
STOP (Reiter, 2000), ILEX (O&apos;Donnell, 1997), and
summarization applications, e.g., Daniel Marcu
(1999). These applications all address the issue by
representing the content to be delivered as a rhetor-
ical tree and using some formulation of a greedy
algorithm that satisfies the length constraints by
either selecting the most important elements of the
tree or pruning the least important elements.1
As an example, consider the two sample outputs
shown in Figure 1. Both outputs were produced by
</bodyText>
<footnote confidence="0.943143666666666">
1 The STOP system identifies the problem as a bin-packing
problem but then describes its mechanism using terms com-
mon to greedy algorithms (Reiter, 2000).
</footnote>
<bodyText confidence="0.999865538461539">
a prototype that delivers information about a com-
puter science department to prospective students
via email; cf. (Paris, et al, 2008). The output is
composed of coarse-grained elements (e.g., im-
ages, phrases and paragraphs) and is formatted in
post-card size using HTML and includes hyper-
links to related pages on the main department web-
site. The goal is to get the prospective student to
visit the main website. The key difference between
the two examples is their length. The one on the
left, which is shorter, was generated using a greedy
algorithm. The one on the right, which uses the
space more fully, was generated using a dynamic
programming algorithm. The greedy algorithm
included the “FAQ” section because it fit at the
time; the dynamic algorithm realized that waiting
to include the “News” and the “Alumni” sections
would be a more effective use of the space.
This paper discusses the mechanisms used to
generate these two examples. It starts with a dis-
cussion of the rhetorical tree used as input for both
sample outputs, and then details the algorithms
used to satisfy the length constraint. The length
constraint problem is viewed as a precedence-
constrained 0-1 knapsack problem, and the algo-
rithm is formulated using dynamic programming.
</bodyText>
<sectionHeader confidence="0.899819" genericHeader="method">
2 Rhetorical Structure Trees
</sectionHeader>
<bodyText confidence="0.999267">
Researchers have long viewed rhetorical trees
as a means of structuring textual output and of dis-
tinguishing those elements that should be ex-
pressed (often called nuclei) from those that could
be omitted (often called satellites) (Spark-Jones,
1993), and there is psycholinguistic evidence that
this view is valid (Marcu, 1999). This paper will
</bodyText>
<page confidence="0.993831">
177
</page>
<figureCaption confidence="0.999395">
Figure 1. Two Sample Outputs – The greedy output is on the left, the dynamic is on the right.
</figureCaption>
<bodyText confidence="0.999964462962963">
build its trees using Rhetorical Structure Theory
(RST), the most common of the theories deployed
for rhetorical structuring (Mann &amp; Thompson,
1988).
Figure 2 shows the annotated RST tree used as
the basis for generating both of the sample outputs
shown in Figure 1. The highest level of the tree
shows a template that affixes the header image as a
preparation satellite and the footer as a background
satellite. The next level down shows the structure
of the content of the email. Each node is asso-
ciated with a block of text or an image in the out-
put. The initial line (i.e., “Ima Sample...”) is
represented as a satellite setting the context for the
main content in the nucleus (i.e., “Thanks for your
interest...”). There then follows a set of six elabo-
ration satellites, each with internal structures of its
own (i.e., an image/caption pair, which is not rea-
lized in either sample output because of its cost,
and a set of five topic/hyperlink pairs).
Each expressible node in the figure has an esti-
mated length, denoted as a cost c measured in pix-
els, and an estimated importance, denoted as a
benefit b. The cost of an expressible node is esti-
mated based on the size of the text/image and spe-
cified format. Generally, the leaves are the
expressible nodes, but in the case where multiple
leaves should be expressed together, the RST tree
places a combined cost value in the parent node
(e.g., the header and footer should be expressed
together or not at all, so their parent node shows
their combined cost of 100 pixels).
The benefit setting, denoted b(n,D), for a node n
in a discourse tree D is formulated as follows:
Here, P(n) denotes the parent of node n and W(r)
denotes the weight of the satellite’s rhetorical rela-
tion (e.g., in this paper, more important relations
like context have weight 0.5 and less important
relations like preparation, elaboration, background
have weight 0.4). This formulation gives higher
benefit values to nuclei. No penalty is placed on
nodes lower in the tree. This formulation is imple-
mented as a recursive decent algorithm whose val-
ues for the samples can be seen in Figure 2.
The tree is produced by a Moore and Paris-
styled text planner (Moore &amp; Paris, 1993). Select-
ing the appropriate content from a content man-
agement system, structuring it appropriately and
estimating the cost/benefit of each node are inter-
esting problems, but are not the focus of this paper.
In preparation for the length constraint algo-
rithm, the system creates a queue of expressible
nodes, each with its cost and benefit values. Nuc-
lei are queued before satellites.
</bodyText>
<page confidence="0.993849">
178
</page>
<figureCaption confidence="0.999066">
Figure 2. Sample Discourse Tree for the Output in Figure 1 with Cost/Benefit Settings
</figureCaption>
<sectionHeader confidence="0.993834" genericHeader="method">
3 A Length Constraint Algorithm
</sectionHeader>
<bodyText confidence="0.93470296875">
This paper views the length constraint problem as a
precedence-constrained 0-1 knapsack problem
(Samphaiboon &amp; Yamada, 2000); the output im-
ages/paragraphs are viewed as items for the knap-
sack, their length in pixels is viewed as their cost,
and their rhetorical importance is viewed as their
benefit. The prohibition against expressing a satel-
lite without also expressing its governing nuclei is
viewed as a precedence constraint on the items.
A common formulation for this problem is to
define the solution in terms of the maximum bene-
fit for a subset of the first k nodes given a maxi-
mum cost c as follows:
Here, and are the benefit and cost of node k
respectively, and is defined by b(n, D) above. If
the node k will fit within the maximum cost con-
straint c, then B(k, c) is defined as the maximum of
either the:
previous solution for the first k-1 nodes not
including node k; or
previous solution with space for node k.
A dynamic programming algorithm that imple-
ments this formulation can be specified as follows:
Function: format(C, Q, T)
Input:
A positive integer maximum cost limit C
A queue Q of N nodes with positive integer
cost (c;) and real benefit (b;) settings
A tree T specifying rhetorical relationships
Output:
A 2-D array B[n+1, c+1] specifying the val-
ues for B(k,c) as defined above
</bodyText>
<equation confidence="0.784230777777778">
for c ← 0 to C
B[0,c] ← 0
for k ← 1 to N
for c ← 0 to C
B[0,c] ← B[0,c-1]
for c ← ck to C
if (not unexpressedNucleus(B,c,k,T) and
B[k-1,c-c;] + b; &gt; B[k-1,c])
B[k,c] ← B[k-1,c-c;] + b;
</equation>
<bodyText confidence="0.99832">
The format(C, Q, T) algorithm declares a 2-D array
of maximum benefit values and sets the first row to
0s. For each expressible node k in Q (rows 1
through N), it copies the previous row of benefit
values and then, for each cost value above the cost
of the current node (columns ck through C), it ei-
ther keeps the previous benefit value without node
k or inserts the benefit that includes node k.
Given the array of maximal benefit values out-
put by format(C, Q, T), the following algorithm
will compute set of nodes corresponding to a given
benefit value:
</bodyText>
<page confidence="0.994565">
179
</page>
<table confidence="0.435906090909091">
Function: output(B, k, c)
Input:
An array B of maximal benefit values
A node number k
B’s maximum cost value c.
Output:
The set of nodes with total cost c and total
benefit B(k, c).
while k,c &gt; 0
if B[k,c] ≠ B[k-1,c]
include nodek
</table>
<equation confidence="0.954527">
c ← c - ck
k ← k - 1
</equation>
<bodyText confidence="0.999977615384616">
The use of unexpressedNucleus(B,c,k,T) in the
format(C, Q, T) if-condition is an extension of the
standard algorithm for the 0-1 knapsack problem
that addresses rhetorical precedence constraints. In
RST-based NLG, satellites are not expressed with-
out their nuclei. For example, we would not want
to include the context expression (i.e., “Ima Sam-
ple...”) without also including its nucleus (i.e.,
“Thanks for...”). Note that these “governing” nuc-
lei are not always at the same level in the tree (e.g.,
the header image satellite is dependent upon the
“Thanks for...” nucleus one level down).
The unexpressedNucleus(B,c,k,T) condition im-
plements this constraint by requiring that
before including any
node n, where G(n,T) is the set of governing nuclei
for n in tree T and is formulated as follows:
Here, G+() looks up the tree, G-() looks down the
tree, P(n) is n’s parent node, and NC(n) is the set
of n’s nucleus children. G() includes only express-
ible nodes. G() can be implemented by a set of
three mutually recursive functions and can be me-
moized to improve efficiency.
The greedy algorithm used for the output in Fig-
ure 1 uses the same input and a precedence queue
of expressible nodes ordered by decreasing benefit.
</bodyText>
<sectionHeader confidence="0.948643" genericHeader="conclusions">
4 Analysis and Conclusions
</sectionHeader>
<bodyText confidence="0.99979775">
The dynamic programming algorithm will always
perform at least as well as the greedy algorithm,
and sometimes better. For example, given a total
cost maximum of 325, the greedy algorithm’s out-
put in Figure 1 has total cost/benefit: 297/3.7,
while the dynamic algorithm’s output has 316/4.1.
Dynamic programming algorithms are noto-
riously expensive in terms of space and time re-
quirements. They are pseudo-polynomial time,
O(NC), but if N and C are “small” they can work
in practice. Typical document formatting problems
with dozens of expressible nodes and hundreds of
pixels of length are tractable.
Further work on this project will follow a num-
ber of directions, including: (1) doing a more com-
plete quantitative analysis of the algorithm; (2)
figuring out a more principled way to assign bene-
fit values; (3) generalizing the problem to two di-
mensions and multiple pages; (4) drawing the
content from a content management system.
</bodyText>
<sectionHeader confidence="0.999098" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999376413793103">
Mann, W. C., &amp; Thompson, S. A. (1988). Rhetorical
structure theory: Toward a functional theory of text
organization. Text , 8 (3), 243-281.
Marcu, D. (1999). Discourse trees are good indicators of
importance in text. In I. Mani, &amp; M. Maybury (Ed.),
Advances in Automatic Text Summarization (pp.
123-136). MIT Press.
Moore, J. D., &amp; Paris, C. L. (1993). Planning text for
advisory dialogues: Capturing intentional and
rhetorical information. Computational Linguistics ,
19 (4), 651-694.
O&apos;Donnell, M. (1997). Variable Length On-Line
Document Generation. Proceedings of the Sixth
European Workshop on NLG. Duisburg, Germany:
Gehard Mercator University.
Paris, C. L., Colineau, N., Lampert, A., &amp; Giralt Duran,
J. (2008). Generation under Space Constraints.
Sydney: CSIRO.
Reiter, E. (2000). Pipelines and Size Constraints.
Computational Linguistics , 26 (2), 251-259.
Samphaiboon, N., &amp; Yamada, T. (2000). Heuristic and
Exact Algorithms for the Precedence-Constrained
Knapsack Problem. Journal of Optimization Theory
and Applications , 105 (3), 659-676.
Spark-Jones, K. (1993). What might be in a summary?
In Knorz, Krause, &amp; Womser-Hacker (Ed.),
Proceedings of Information Retrieval 93: Von der
modellierung zur anwendung (pp. 9-26).
Universitatsverlag Konstanz.
</reference>
<page confidence="0.997726">
180
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.014688">
<title confidence="0.996755">A Dynamic Programming Approach Document Length Constraints</title>
<author confidence="0.999891">Keith Vander</author>
<affiliation confidence="0.8872375">Department of Computer Calvin</affiliation>
<address confidence="0.550413">Grand Rapids, MI 49546,</address>
<email confidence="0.999664">kvlinden@calvin.edu</email>
<abstract confidence="0.997665871244635">Natural language generation (NLG) applications must occasionally deliver rhetorically coherent output under length constraints. For example, certain types of documents must fit on a single webpage, on a cell phone screen, or into a fixed number of printed pages. To date, applications have achieved this goal by structuring their content as a rhetorical tree and using a greedy algorithm to pick the discourse elements to include in the final document. Greedy algorithms are known to pick sub-optimal solutions. This paper presents an alternate approach based on dynamic programming. 1 Document Length Constraints A number of language engineering applications have addressed the issue of generating coherent documents under length constraints, including applications, e.g., SciFly (Paris, 2008), STOP (Reiter, 2000), ILEX (O&apos;Donnell, 1997), and summarization applications, e.g., Daniel Marcu (1999). These applications all address the issue by representing the content to be delivered as a rhetorical tree and using some formulation of a greedy algorithm that satisfies the length constraints by either selecting the most important elements of the or pruning the least important As an example, consider the two sample outputs shown in Figure 1. Both outputs were produced by STOP system identifies the problem as a bin-packing problem but then describes its mechanism using terms common to greedy algorithms (Reiter, 2000). a prototype that delivers information about a computer science department to prospective students email; cf. (Paris, 2008). The output is composed of coarse-grained elements (e.g., images, phrases and paragraphs) and is formatted in post-card size using HTML and includes hyperlinks to related pages on the main department website. The goal is to get the prospective student to visit the main website. The key difference between the two examples is their length. The one on the left, which is shorter, was generated using a greedy algorithm. The one on the right, which uses the space more fully, was generated using a dynamic programming algorithm. The greedy algorithm included the “FAQ” section because it fit at the time; the dynamic algorithm realized that waiting to include the “News” and the “Alumni” sections would be a more effective use of the space. This paper discusses the mechanisms used to generate these two examples. It starts with a discussion of the rhetorical tree used as input for both sample outputs, and then details the algorithms used to satisfy the length constraint. The length constraint problem is viewed as a precedenceconstrained 0-1 knapsack problem, and the algorithm is formulated using dynamic programming. 2 Rhetorical Structure Trees Researchers have long viewed rhetorical trees as a means of structuring textual output and of distinguishing those elements that should be expressed (often called nuclei) from those that could be omitted (often called satellites) (Spark-Jones, 1993), and there is psycholinguistic evidence that this view is valid (Marcu, 1999). This paper will 177 1. Two Sample Outputs greedy output is on the left, the dynamic is on the right. build its trees using Rhetorical Structure Theory (RST), the most common of the theories deployed for rhetorical structuring (Mann &amp; Thompson, 1988). Figure 2 shows the annotated RST tree used as the basis for generating both of the sample outputs shown in Figure 1. The highest level of the tree shows a template that affixes the header image as a preparation satellite and the footer as a background satellite. The next level down shows the structure of the content of the email. Each node is associated with a block of text or an image in the output. The initial line (i.e., “Ima Sample...”) is represented as a satellite setting the context for the main content in the nucleus (i.e., “Thanks for your There then a set of six elaboration satellites, each with internal structures of its own (i.e., an image/caption pair, which is not realized in either sample output because of its cost, and a set of five topic/hyperlink pairs). Each expressible node in the figure has an estilength, denoted as a cost in pixels, and an estimated importance, denoted as a The cost of an expressible node is estimated based on the size of the text/image and specified format. Generally, the leaves are the expressible nodes, but in the case where multiple leaves should be expressed together, the RST tree places a combined cost value in the parent node (e.g., the header and footer should be expressed together or not at all, so their parent node shows their combined cost of 100 pixels). benefit setting, denoted for a node a discourse tree formulated as follows: the parent of node the weight of the satellite’s rhetorical tion (e.g., in this paper, more important relations like context have weight 0.5 and less important relations like preparation, elaboration, background have weight 0.4). This formulation gives higher benefit values to nuclei. No penalty is placed on nodes lower in the tree. This formulation is implemented as a recursive decent algorithm whose values for the samples can be seen in Figure 2. The tree is produced by a Moore and Parisstyled text planner (Moore &amp; Paris, 1993). Selecting the appropriate content from a content management system, structuring it appropriately and estimating the cost/benefit of each node are interesting problems, but are not the focus of this paper. In preparation for the length constraint algorithm, the system creates a queue of expressible nodes, each with its cost and benefit values. Nuclei are queued before satellites. 178 Figure 2. Sample Discourse Tree for the Output in Figure 1 with Cost/Benefit Settings 3 A Length Constraint Algorithm This paper views the length constraint problem as a precedence-constrained 0-1 knapsack problem (Samphaiboon &amp; Yamada, 2000); the output images/paragraphs are viewed as items for the knapsack, their length in pixels is viewed as their cost, and their rhetorical importance is viewed as their benefit. The prohibition against expressing a satellite without also expressing its governing nuclei is viewed as a precedence constraint on the items. A common formulation for this problem is to define the solution in terms of the maximum benefor a subset of the first given a maxicost follows: Here, and are the benefit and cost of node k and is defined by D) If node fit within the maximum cost conthen c) defined as the maximum of either the: solution for the first not node or solution with space for node A dynamic programming algorithm that implements this formulation can be specified as follows: Q, T) Input: positive integer maximum cost limit queue with positive integer and real benefit settings tree rhetorical relationships Output: 2-D array specifying the valfor defined above ← 0 ← 1 to N + ← + Q, T) declares a 2-D array of maximum benefit values and sets the first row to For each expressible node it copies the previous row of benefit values and then, for each cost value above the cost the current node (columns it either keeps the previous benefit value without node or inserts the benefit that includes node Given the array of maximal benefit values outby Q, T), following algorithm will compute set of nodes corresponding to a given benefit value: 179 k, c) Input: array maximal benefit values node number maximum value Output: The set of nodes with total cost c and total &gt; 0 ≠ - - 1 use of the Q, T) is an extension of the standard algorithm for the 0-1 knapsack problem that addresses rhetorical precedence constraints. In RST-based NLG, satellites are not expressed without their nuclei. For example, we would not want the context expression (i.e., “Ima without also including its nucleus Note that these lei are not always at the same level in the tree (e.g., the header image satellite is dependent upon the for...” one level down). implements this constraint by requiring that before including any where the set of governing nuclei tree is formulated as follows: up the tree, down the parent and the set children. only expressnodes. be implemented by a set of three mutually recursive functions and can be memoized to improve efficiency. The greedy algorithm used for the output in Figure 1 uses the same input and a precedence queue of expressible nodes ordered by decreasing benefit. 4 Analysis and Conclusions dynamic programming algorithm will always perform at least as well as the greedy algorithm, and sometimes better. For example, given a total maximum of 325, greedy algorithm’s output in Figure 1 has total cost/benefit: 297/3.7, dynamic algorithm’s output 316/4.1. Dynamic programming algorithms are notoriously expensive in terms of space and time requirements. They are pseudo-polynomial time, but N and C are “small” can work in practice. Typical document formatting problems with dozens of expressible nodes and hundreds of pixels of length are tractable. Further work on this project will follow a number of directions, including: (1) doing a more complete quantitative analysis of the algorithm; (2) figuring out a more principled way to assign benefit values; (3) generalizing the problem to two dimensions and multiple pages; (4) drawing the content from a content management system.</abstract>
<note confidence="0.676072935483871">References Mann, W. C., &amp; Thompson, S. A. (1988). Rhetorical structure theory: Toward a functional theory of text organization. Text , 8 (3), 243-281. Marcu, D. (1999). Discourse trees are good indicators of importance in text. In I. Mani, &amp; M. Maybury (Ed.), Advances in Automatic Text Summarization (pp. 123-136). MIT Press. Moore, J. D., &amp; Paris, C. L. (1993). Planning text for advisory dialogues: Capturing intentional and information. Linguistics , 651-694. O&apos;Donnell, M. (1997). Variable Length On-Line Generation. of the Sixth Workshop on NLG. Germany: Gehard Mercator University. Paris, C. L., Colineau, N., Lampert, A., &amp; Giralt Duran, (2008). under Space Constraints. Sydney: CSIRO. Reiter, E. (2000). Pipelines and Size Constraints. Linguistics , 26 251-259. Samphaiboon, N., &amp; Yamada, T. (2000). Heuristic and Exact Algorithms for the Precedence-Constrained Problem. of Optimization Theory Applications , 105 659-676. Spark-Jones, K. (1993). What might be in a summary? In Knorz, Krause, &amp; Womser-Hacker (Ed.), Proceedings of Information Retrieval 93: Von der zur anwendung 9-26). Universitatsverlag Konstanz. 180</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>W C Mann</author>
<author>S A Thompson</author>
</authors>
<title>Rhetorical structure theory: Toward a functional theory of text organization.</title>
<date>1988</date>
<journal>Text ,</journal>
<volume>8</volume>
<issue>3</issue>
<pages>243--281</pages>
<contexts>
<context position="3517" citStr="Mann &amp; Thompson, 1988" startWordPosition="550" endWordPosition="553">. 2 Rhetorical Structure Trees Researchers have long viewed rhetorical trees as a means of structuring textual output and of distinguishing those elements that should be expressed (often called nuclei) from those that could be omitted (often called satellites) (Spark-Jones, 1993), and there is psycholinguistic evidence that this view is valid (Marcu, 1999). This paper will 177 Figure 1. Two Sample Outputs – The greedy output is on the left, the dynamic is on the right. build its trees using Rhetorical Structure Theory (RST), the most common of the theories deployed for rhetorical structuring (Mann &amp; Thompson, 1988). Figure 2 shows the annotated RST tree used as the basis for generating both of the sample outputs shown in Figure 1. The highest level of the tree shows a template that affixes the header image as a preparation satellite and the footer as a background satellite. The next level down shows the structure of the content of the email. Each node is associated with a block of text or an image in the output. The initial line (i.e., “Ima Sample...”) is represented as a satellite setting the context for the main content in the nucleus (i.e., “Thanks for your interest...”). There then follows a set of </context>
</contexts>
<marker>Mann, Thompson, 1988</marker>
<rawString>Mann, W. C., &amp; Thompson, S. A. (1988). Rhetorical structure theory: Toward a functional theory of text organization. Text , 8 (3), 243-281.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Marcu</author>
</authors>
<title>Discourse trees are good indicators of importance in text. In</title>
<date>1999</date>
<booktitle>Advances in Automatic Text Summarization</booktitle>
<pages>123--136</pages>
<publisher>MIT Press.</publisher>
<contexts>
<context position="1094" citStr="Marcu (1999)" startWordPosition="157" endWordPosition="158">d this goal by structuring their content as a rhetorical tree and using a greedy algorithm to pick the discourse elements to include in the final document. Greedy algorithms are known to pick sub-optimal solutions. This paper presents an alternate approach based on dynamic programming. 1 Document Length Constraints A number of language engineering applications have addressed the issue of generating coherent documents under length constraints, including NLG applications, e.g., SciFly (Paris, et al, 2008), STOP (Reiter, 2000), ILEX (O&apos;Donnell, 1997), and summarization applications, e.g., Daniel Marcu (1999). These applications all address the issue by representing the content to be delivered as a rhetorical tree and using some formulation of a greedy algorithm that satisfies the length constraints by either selecting the most important elements of the tree or pruning the least important elements.1 As an example, consider the two sample outputs shown in Figure 1. Both outputs were produced by 1 The STOP system identifies the problem as a bin-packing problem but then describes its mechanism using terms common to greedy algorithms (Reiter, 2000). a prototype that delivers information about a comput</context>
<context position="3253" citStr="Marcu, 1999" startWordPosition="507" endWordPosition="508">ed as input for both sample outputs, and then details the algorithms used to satisfy the length constraint. The length constraint problem is viewed as a precedenceconstrained 0-1 knapsack problem, and the algorithm is formulated using dynamic programming. 2 Rhetorical Structure Trees Researchers have long viewed rhetorical trees as a means of structuring textual output and of distinguishing those elements that should be expressed (often called nuclei) from those that could be omitted (often called satellites) (Spark-Jones, 1993), and there is psycholinguistic evidence that this view is valid (Marcu, 1999). This paper will 177 Figure 1. Two Sample Outputs – The greedy output is on the left, the dynamic is on the right. build its trees using Rhetorical Structure Theory (RST), the most common of the theories deployed for rhetorical structuring (Mann &amp; Thompson, 1988). Figure 2 shows the annotated RST tree used as the basis for generating both of the sample outputs shown in Figure 1. The highest level of the tree shows a template that affixes the header image as a preparation satellite and the footer as a background satellite. The next level down shows the structure of the content of the email. Ea</context>
</contexts>
<marker>Marcu, 1999</marker>
<rawString>Marcu, D. (1999). Discourse trees are good indicators of importance in text. In I. Mani, &amp; M. Maybury (Ed.), Advances in Automatic Text Summarization (pp. 123-136). MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J D Moore</author>
<author>C L Paris</author>
</authors>
<title>Planning text for advisory dialogues: Capturing intentional and rhetorical information.</title>
<date>1993</date>
<journal>Computational Linguistics ,</journal>
<volume>19</volume>
<issue>4</issue>
<pages>651--694</pages>
<contexts>
<context position="5571" citStr="Moore &amp; Paris, 1993" startWordPosition="913" endWordPosition="916">discourse tree D is formulated as follows: Here, P(n) denotes the parent of node n and W(r) denotes the weight of the satellite’s rhetorical relation (e.g., in this paper, more important relations like context have weight 0.5 and less important relations like preparation, elaboration, background have weight 0.4). This formulation gives higher benefit values to nuclei. No penalty is placed on nodes lower in the tree. This formulation is implemented as a recursive decent algorithm whose values for the samples can be seen in Figure 2. The tree is produced by a Moore and Parisstyled text planner (Moore &amp; Paris, 1993). Selecting the appropriate content from a content management system, structuring it appropriately and estimating the cost/benefit of each node are interesting problems, but are not the focus of this paper. In preparation for the length constraint algorithm, the system creates a queue of expressible nodes, each with its cost and benefit values. Nuclei are queued before satellites. 178 Figure 2. Sample Discourse Tree for the Output in Figure 1 with Cost/Benefit Settings 3 A Length Constraint Algorithm This paper views the length constraint problem as a precedence-constrained 0-1 knapsack proble</context>
</contexts>
<marker>Moore, Paris, 1993</marker>
<rawString>Moore, J. D., &amp; Paris, C. L. (1993). Planning text for advisory dialogues: Capturing intentional and rhetorical information. Computational Linguistics , 19 (4), 651-694.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M O&apos;Donnell</author>
</authors>
<title>Variable Length On-Line Document Generation.</title>
<date>1997</date>
<booktitle>Proceedings of the Sixth European Workshop on NLG.</booktitle>
<institution>Gehard Mercator University.</institution>
<location>Duisburg, Germany:</location>
<contexts>
<context position="1035" citStr="O&apos;Donnell, 1997" startWordPosition="150" endWordPosition="151">xed number of printed pages. To date, applications have achieved this goal by structuring their content as a rhetorical tree and using a greedy algorithm to pick the discourse elements to include in the final document. Greedy algorithms are known to pick sub-optimal solutions. This paper presents an alternate approach based on dynamic programming. 1 Document Length Constraints A number of language engineering applications have addressed the issue of generating coherent documents under length constraints, including NLG applications, e.g., SciFly (Paris, et al, 2008), STOP (Reiter, 2000), ILEX (O&apos;Donnell, 1997), and summarization applications, e.g., Daniel Marcu (1999). These applications all address the issue by representing the content to be delivered as a rhetorical tree and using some formulation of a greedy algorithm that satisfies the length constraints by either selecting the most important elements of the tree or pruning the least important elements.1 As an example, consider the two sample outputs shown in Figure 1. Both outputs were produced by 1 The STOP system identifies the problem as a bin-packing problem but then describes its mechanism using terms common to greedy algorithms (Reiter, </context>
</contexts>
<marker>O&apos;Donnell, 1997</marker>
<rawString>O&apos;Donnell, M. (1997). Variable Length On-Line Document Generation. Proceedings of the Sixth European Workshop on NLG. Duisburg, Germany: Gehard Mercator University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C L Paris</author>
<author>N Colineau</author>
<author>A Lampert</author>
<author>Giralt Duran</author>
<author>J</author>
</authors>
<title>Generation under Space Constraints.</title>
<date>2008</date>
<publisher>CSIRO.</publisher>
<location>Sydney:</location>
<contexts>
<context position="990" citStr="Paris, et al, 2008" startWordPosition="142" endWordPosition="145">le webpage, on a cell phone screen, or into a fixed number of printed pages. To date, applications have achieved this goal by structuring their content as a rhetorical tree and using a greedy algorithm to pick the discourse elements to include in the final document. Greedy algorithms are known to pick sub-optimal solutions. This paper presents an alternate approach based on dynamic programming. 1 Document Length Constraints A number of language engineering applications have addressed the issue of generating coherent documents under length constraints, including NLG applications, e.g., SciFly (Paris, et al, 2008), STOP (Reiter, 2000), ILEX (O&apos;Donnell, 1997), and summarization applications, e.g., Daniel Marcu (1999). These applications all address the issue by representing the content to be delivered as a rhetorical tree and using some formulation of a greedy algorithm that satisfies the length constraints by either selecting the most important elements of the tree or pruning the least important elements.1 As an example, consider the two sample outputs shown in Figure 1. Both outputs were produced by 1 The STOP system identifies the problem as a bin-packing problem but then describes its mechanism usin</context>
</contexts>
<marker>Paris, Colineau, Lampert, Duran, J, 2008</marker>
<rawString>Paris, C. L., Colineau, N., Lampert, A., &amp; Giralt Duran, J. (2008). Generation under Space Constraints. Sydney: CSIRO.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Reiter</author>
</authors>
<title>Pipelines and Size Constraints.</title>
<date>2000</date>
<journal>Computational Linguistics ,</journal>
<volume>26</volume>
<issue>2</issue>
<pages>251--259</pages>
<contexts>
<context position="1011" citStr="Reiter, 2000" startWordPosition="147" endWordPosition="148"> screen, or into a fixed number of printed pages. To date, applications have achieved this goal by structuring their content as a rhetorical tree and using a greedy algorithm to pick the discourse elements to include in the final document. Greedy algorithms are known to pick sub-optimal solutions. This paper presents an alternate approach based on dynamic programming. 1 Document Length Constraints A number of language engineering applications have addressed the issue of generating coherent documents under length constraints, including NLG applications, e.g., SciFly (Paris, et al, 2008), STOP (Reiter, 2000), ILEX (O&apos;Donnell, 1997), and summarization applications, e.g., Daniel Marcu (1999). These applications all address the issue by representing the content to be delivered as a rhetorical tree and using some formulation of a greedy algorithm that satisfies the length constraints by either selecting the most important elements of the tree or pruning the least important elements.1 As an example, consider the two sample outputs shown in Figure 1. Both outputs were produced by 1 The STOP system identifies the problem as a bin-packing problem but then describes its mechanism using terms common to gre</context>
</contexts>
<marker>Reiter, 2000</marker>
<rawString>Reiter, E. (2000). Pipelines and Size Constraints. Computational Linguistics , 26 (2), 251-259.</rawString>
</citation>
<citation valid="true">
<authors>
<author>N Samphaiboon</author>
<author>T Yamada</author>
</authors>
<title>Heuristic and Exact Algorithms for the Precedence-Constrained Knapsack Problem.</title>
<date>2000</date>
<journal>Journal of Optimization Theory and Applications ,</journal>
<volume>105</volume>
<issue>3</issue>
<pages>659--676</pages>
<contexts>
<context position="6201" citStr="Samphaiboon &amp; Yamada, 2000" startWordPosition="1012" endWordPosition="1015">electing the appropriate content from a content management system, structuring it appropriately and estimating the cost/benefit of each node are interesting problems, but are not the focus of this paper. In preparation for the length constraint algorithm, the system creates a queue of expressible nodes, each with its cost and benefit values. Nuclei are queued before satellites. 178 Figure 2. Sample Discourse Tree for the Output in Figure 1 with Cost/Benefit Settings 3 A Length Constraint Algorithm This paper views the length constraint problem as a precedence-constrained 0-1 knapsack problem (Samphaiboon &amp; Yamada, 2000); the output images/paragraphs are viewed as items for the knapsack, their length in pixels is viewed as their cost, and their rhetorical importance is viewed as their benefit. The prohibition against expressing a satellite without also expressing its governing nuclei is viewed as a precedence constraint on the items. A common formulation for this problem is to define the solution in terms of the maximum benefit for a subset of the first k nodes given a maximum cost c as follows: Here, and are the benefit and cost of node k respectively, and is defined by b(n, D) above. If the node k will fit </context>
</contexts>
<marker>Samphaiboon, Yamada, 2000</marker>
<rawString>Samphaiboon, N., &amp; Yamada, T. (2000). Heuristic and Exact Algorithms for the Precedence-Constrained Knapsack Problem. Journal of Optimization Theory and Applications , 105 (3), 659-676.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Spark-Jones</author>
</authors>
<title>What might be in a summary?</title>
<date>1993</date>
<booktitle>In Knorz, Krause, &amp; Womser-Hacker (Ed.), Proceedings of Information Retrieval 93: Von der modellierung zur anwendung</booktitle>
<pages>9--26</pages>
<institution>Universitatsverlag Konstanz.</institution>
<contexts>
<context position="3175" citStr="Spark-Jones, 1993" startWordPosition="495" endWordPosition="496">o generate these two examples. It starts with a discussion of the rhetorical tree used as input for both sample outputs, and then details the algorithms used to satisfy the length constraint. The length constraint problem is viewed as a precedenceconstrained 0-1 knapsack problem, and the algorithm is formulated using dynamic programming. 2 Rhetorical Structure Trees Researchers have long viewed rhetorical trees as a means of structuring textual output and of distinguishing those elements that should be expressed (often called nuclei) from those that could be omitted (often called satellites) (Spark-Jones, 1993), and there is psycholinguistic evidence that this view is valid (Marcu, 1999). This paper will 177 Figure 1. Two Sample Outputs – The greedy output is on the left, the dynamic is on the right. build its trees using Rhetorical Structure Theory (RST), the most common of the theories deployed for rhetorical structuring (Mann &amp; Thompson, 1988). Figure 2 shows the annotated RST tree used as the basis for generating both of the sample outputs shown in Figure 1. The highest level of the tree shows a template that affixes the header image as a preparation satellite and the footer as a background sate</context>
</contexts>
<marker>Spark-Jones, 1993</marker>
<rawString>Spark-Jones, K. (1993). What might be in a summary? In Knorz, Krause, &amp; Womser-Hacker (Ed.), Proceedings of Information Retrieval 93: Von der modellierung zur anwendung (pp. 9-26). Universitatsverlag Konstanz.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>