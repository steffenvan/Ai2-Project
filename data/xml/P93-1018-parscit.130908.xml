<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<note confidence="0.940899">
PARALLEL MULTIPLE CONTEXT-FREE GRAMMARS, FINITE-STATE
TRANSLATION SYSTEMS, AND POLYNOMIAL-TIME RECOGNIZABLE
SUBCLASSES OF LEXICAL-FUNCTIONAL GRAMMARS
</note>
<title confidence="0.571304">
Hiroyuki Seki tt Ryuichi Nakanishi t Yuichi Kaji
</title>
<author confidence="0.955477">
Sachiko Ando t Tadao Kasami &amp;quot;
</author>
<affiliation confidence="0.803852666666667">
t Department of Information and Computer Sciences, Faculty of Engineering Science, Osaka University
1-1 Machikaneyarna, Toyonaka, Osaka 560, Japan
Graduate School of Information Science, Advanced Institute of Science and Technology, Nara
</affiliation>
<address confidence="0.664328">
8916-5 Takayama, Ikoma, Nara 630-01, Japan
</address>
<email confidence="0.994584">
Internet: seki@ics.es.osaka-u.ac.jp
</email>
<sectionHeader confidence="0.998536" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.99996162962963">
A number of grammatical formalisms were intro-
duced to define the syntax of natural languages.
Among them are parallel multiple context-free
grammars (pmcfg&apos;s) and lexical-functional gram-
mars (lfg&apos;s). Pmcfg&apos;s and their subclass called
multiple context-free grammars (mcfg&apos;s) are nat-
ural extensions of cfg&apos;s, and pmcfg&apos;s are known
to be recognizable in polynomial time. Some sub-
classes of lfg&apos;s have been proposed, but they were
shown to generate an NP-complete language. Fi-
nite state translation systems (fts&apos;) were intro-
duced as a computational model of transforma-
tional grammars. In this paper, three subclasses
of lfg&apos;s called nc-lfg&apos;s, dc-lfg&apos;s and fc-lfg&apos;s are
introduced and the generative capacities of the
above mentioned grammatical formalisms are in-
vestigated. First, we show that the generative
capacity of fts&apos; is equal to that of nc-lfg&apos;s. As
relations among subclasses of those formalisms,
it is shown that the generative capacities of de-
terministic fts&apos;, dc-lfg&apos;s, and pmcfg&apos;s are equal to
each other, and the generative capacity of fc-lfg&apos;s
is equal to that of mcfg&apos;s. It is also shown that
at least one NP-complete language is generated
by fts&apos;. Consequently, deterministic fts&apos;, dc-lfg&apos;s
and fc-lfg&apos;s can be recognized in polynomial time.
However, fts&apos; (and nc-lfg&apos;s) cannot, if P A/ P.
</bodyText>
<sectionHeader confidence="0.99947" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999783719298246">
A number of grammatical formalisms such as
lexical-functional grammars (Kaplan 1982), head
grammars (Pollard 1984) and tree adjoining
grammars (Joshi 1975)(Vijay-Shanker 1987) were
introduced to define the syntax of natural lan-
guages. On the other hand, there has been
much effort to propose well-defined computa-
tional models of transformational grammars. One
of these is the one to extend devices which oper-
ate on strings, such as generalized sequential ma-
chines (gsm&apos;s) to devices which operate on trees.
It is fundamentally significant to clarify the gen-
erative capacities of such grammars and devices.
Parallel multiple context-free grammars (pm-
cfg&apos;s) and multiple context-free grammars (mcfg&apos;s)
were introduced in (Kasami 1988a)(Seki 1991) as
natural extensions of cfg&apos;s. The subsystem of lin-
ear context-free rewriting systems (lcfrs&apos;) (Vijay-
Shanker 1987) which deals with only strings is
the same formalism as mcfg&apos;s. The class of cfl&apos;s
is properly included in the class of languages gen-
erated by pmcfg&apos;s, which in turn is properly in-
cluded in the one generated by mcfg&apos;s. The class
of languages generated by pmcfg&apos;s is properly
included in that of context-sensitive languages
(Kasami 1988a). Pmcfg&apos;s have been shown
to be recognized in polynomial time (Kasami
1988b)(Seki 1991).
A tree transducer (Rounds 1969) takes a tree
as an input, starts from the initial state with its
head scanning the root node of an input. Ac-
cording to the current state and the label of the
scanned node, it transforms an input tree into
an output tree in a top-down way. A finite state
translation system (fts) is a tree transducer with
its input domain being the set of derivation trees
of a cfg (Rounds 1969)(Thatcher 1967). A num-
ber of equivalence relations between the classes
of yield languages generated by fts&apos; and other
computational models have been established (En-
gelfriet 1991)(Engelfriet 1980)(Weir 1992). Espe-
cially, it has been shown that the class of yield
languages generated by finite-copying fts&apos; equals
to the class of languages generated by lcfrs&apos; (Weir
1992), hence by mcfg&apos;s.
In lexical-functional grammars (lfg&apos;s) (Ka-
plan 1982), associated with each node v of a
derivation tree is a finite set F of pairs of at-
tribute names and their values. F is called the f-
structure of v. An lfg G consists of a cfg Go called
the underlying cfg of G and a finite set Pf, of
equations called functional schemata which spec-
ify constraints between the f-structures of nodes
in a derivation tree. Functional schemata are at-
tached to symbols in productions of Go. It has
been shown in (Nakanishi 1992) that the class of
languages generated by lfg&apos;s is equal to that of re-
</bodyText>
<page confidence="0.994573">
130
</page>
<bodyText confidence="0.999766843137255">
cursively enumerable languages even though the
underlying cfg&apos;s are restricted to regular gram-
mars. In (Gazdar 1985)(Kaplan 1982)(Nishino
1991), subclasses of lfg&apos;s were proposed in order
to guarantee the recursiveness (and/or the effi-
cient recognition) of languages generated by lfg&apos;s.
However, these classes were shown to generate an
ArP-complete language (Nakanishi 1992).
In this paper, three subclasses of lfg&apos;s called
nc-lfg&apos;s, dc-lfg&apos;s and fc-lfg&apos;s are proposed, two
of which can be recognized in polynomial time.
Moreover, this paper clarifies the relations among
the generative capacities of pmcfg&apos;s, fts&apos; and these
subclasses of lfg&apos;s.
In nc-lfg&apos;s, a functional schema either speci-
fies the value of a specific attribute, say atr, im-
mediately (iatr = vai) or specifies that the value
of a specific attribute of a node v is equal to the
whole f-structure of a child node of v (iatr =1).
An nc-lfg is called a dc-lfg if each pair of rules
P1 : A —&gt; al and p2 : A --+ a2 whose left-hand
sides are the same is inconsistent in the sense
that there exists no f-structure that locally sat-
isfies both of the functional schemata of /31 and
those of p2. Intuitively, in a dc-lfg G, for each pair
(t1, t2) of derivation trees in G, if the f-structure
and nonterminal of the root of t1 are the same as
those of t2, then t1 and t2 derive the same termi-
nal string.
Let G be an nc-lfg. A multiset M of nonter-
minals of G is called an SPN multiset in G if the
following condition holds:
Let M = A2, • • • An}} be a mul-
tiset of nonterminals where different A&apos;s
are not always distinct. There exist a
derivation tree t and a subset of nodes
V = {vi, v2, • • • ,v,} of t such that the
label of v, is Ai (1 &lt; i &lt; n) and the f-
structures of vi&apos;s are the same with each
other by functional schemata of G.
If the number of SPN multisets in G is finite, then
G is called an fc-lfg.
Our main result is that the generative capac-
ity of nc-lfg&apos;s is equal to that of fts&apos;. As relations
among proper subclasses of the above mentioned
formalisms, it is shown that the generative capac-
ities of dc-lfg&apos;s, deterministic fts&apos; and pmcfg&apos;s are
equal to each other, and the generative capacity
of fc-lfg&apos;s is equal to that of mcfg&apos;s. It is also
shown that a (nondeterministic) fts generates an
ATP-complete language.
</bodyText>
<sectionHeader confidence="0.942081" genericHeader="introduction">
2 Parallel Multiple Context-Free
Grammars
</sectionHeader>
<bodyText confidence="0.99764775">
A parallel multiple context-free grammar (pmcfg
is defined to be a 5-tuple G = (N,T,F,P,S
which satisfies the following conditions (G1
through (G5) (Kasami 1988a)(Seki 1991).
</bodyText>
<listItem confidence="0.6644076">
(G1) N is a finite set of nonterminal symbols. A
positive integer d(A) is given for each nonter-
minal symbol A E N.
(G2) T is a finite set of terminal symbols which
is disjoint with N.
</listItem>
<bodyText confidence="0.739199642857143">
(G3) F is a finite set of functions satisfying the
following conditions. For a positive integer d,
let (T*)&apos; denote the set of all the d-tuples of
strings over T. For each f E F with arity
a(f), positive integers r(f) and di(f) (1 _&lt;
i &lt; a(f)) are given, and f is a total function
from (7)d1(f) x (T*)4(1) x • • • x (T*)d-(1)(f) to
(T*)r(f) which satisfies the following condition
(f1). Let
xi= (Xil x22) • • • )Xid.(f))
denote the ith argument off for 1 &lt; i &lt; a(f).
(11) For 1 &lt; h &lt; r(f), the hth component of
f, denoted by f[h], is defined as;
f [h][1, .. • , f )] = h,0 X i.(h,0)77(h,O)a
</bodyText>
<listItem confidence="0.560049">
• • • t - X 14(h,nh -1)71(kro -1)a h,n4 (2.1)
</listItem>
<bodyText confidence="0.992722">
where ah,k E T* for 0 &lt; k 5_ nh, 1 5
i.z(h,j) 5 a(f) and 1 5 n(h,j) 5 dy(h,j)(f)
for 0 &lt;j &lt;flh —1.
</bodyText>
<listItem confidence="0.7822995">
(G4) P is a finite set of productions of
the form A —&gt; f[441, A2, , Aa(n] where
</listItem>
<bodyText confidence="0.9038506">
A, Ai, A2, , Aa(f) €N, f E F, r(f) = d(A)
and d(f) = d(Ai) (1 &lt;i &lt; a(f)). If a(f) = 0,
i.e., f E (T*)r&amp;quot;), the production is called a
terminating production, otherwise it is called
a nonterminating production.
</bodyText>
<listItem confidence="0.491356">
(G5) S E N is the initial symbol, and d(S) = 1.
</listItem>
<bodyText confidence="0.985914454545454">
If all the functions of a pmcfg G satisfy the
following Right Linearity condition, then G is
called a multiple context-free grammar (mcfg).
[Right Linearity For each x2, the total num-
ber of occurrences of xii in the right-hand
sides of (2.1) from h = 1 through r(f) is at
most one.
The language generated by a pmcfg G =
(N,T , F, P, S) is defined as follows. For A E N,
let us define LG(A) as the smallest set satisfying
the following two conditions:
</bodyText>
<listItem confidence="0.7830794">
(L1.) If a terminating production A a is in P,
then a E LG(A).
(L2) If A —&gt; f[Al,A2, .. • , Aa(f)] E P and
at E LG(Az) _&lt; i 5 a(f)), then
f[ai, a2, • • • , -6a( nf E LG(A).
</listItem>
<page confidence="0.972">
131
</page>
<construct confidence="0.4238284">
Define L(G)LG(S). L(G) is called the par-
allel multiple context-free language (pmcfl) gen-
erated by G. If G is an mcfg, L(G) is called the
multiple context-free language (mcfl) generated by
G.
</construct>
<equation confidence="0.697281">
Example 2.1(Kasami 1988a): Let GExi = (N,
T, F, P, S), N = {S}, T = {a}, F = {fa, fl,P =
{7.1 : S fa, ro S f[S]}, where ía
</equation>
<bodyText confidence="0.971758">
a, a, f[(x)] = XX. GExi is a pmcfg but is not an
mcfg since the function f does not satisfy Right
Linearity. The language generated by GExi is
{a2&apos; In &gt; OE which cannot be generated by any
mcfg (see Lemma 6 of (Kasami 1988a)).
The empty string is denoted by E.
</bodyText>
<construct confidence="0.701569666666667">
Example 2.2: Let GEX2 = (N, T, F, P, S) be
a pmcfg, where N = {S, A}, T = {a, b}, F =
{gri, x2)1I = x1x2, .faRxi, x2)] = (xi a, x2a),
</construct>
<equation confidence="0.99164275">
fb (xi, x2) = (xi b, x2b), fe = (E, 6)}, and, P=
{Po S g[A], P1 A —+ MA], p2 : A
f 01, p : A —&gt; M. Note that GEx2 is an mcfg.
L (G E x2) = {ww I w E fa,b1*}. 0
</equation>
<bodyText confidence="0.98958525">
Lemma 2.1(Kasami 1988b)(Seki 1991): Let G
be a pmcfg. For a given string w, it is decidable
whether w E L (G) or not in time polynomial of
lw I, where HI denotes the length of W.
</bodyText>
<sectionHeader confidence="0.989501" genericHeader="method">
3 Finite State Translation Systems
</sectionHeader>
<bodyText confidence="0.9980408">
A set E of symbols is a ranked alphabet if, for
each a E E, a unique non-negative number p(o)
is associated. p(o) is the rank of cr. For a set X,
we define free algebra TE (X) as the smallest set
such that;
</bodyText>
<listItem confidence="0.999302">
• TE(X) includes X.
• If p(o) = 0 for o- E E, then o- E TE(X).
• If p(o) = n (&gt; 1) for a E E and t1,. • • tit E
</listItem>
<bodyText confidence="0.83716425">
TE(X), then t , tn) E TE(X). cr is
called the root symbol, or shortly, the root of
t.
Hereafter, a term in TE (X) is also called a tree,
and we use terminology of trees such as subtree,
node and so on.
Let G = (N, T, P, S) be a context-free gram-
mar (cfg) where N, T, P and S are a set of non-
terminal symbols, a set of terminal symbols, a
set of productions and the initial symbol, respec-
tively. A derivation tree in cfg G is a term defined
as follows.
</bodyText>
<listItem confidence="0.6468275">
(Ti) Every a E T is a derivation tree in G.
(T2) Assume that there are a production p :
</listItem>
<equation confidence="0.461614">
A —&gt; X1- • • X,. (A E N, X1,. , X,E Nu T)
</equation>
<bodyText confidence="0.73456">
in P and n derivation trees tn, whose
roots are labeled with ,p„,, respectively,
and
</bodyText>
<listItem confidence="0.9088978">
• ifX EN, then pi is a production X, • • •,
whose left-hand side is Xi, and
• if X. E T, then pi = ti = X.
Then p(ti, , tn) is a derivation tree in G.
(T3) There are no other derivation trees.
</listItem>
<bodyText confidence="0.995119214285714">
Let &apos;TZ(G) be the set of derivation trees in G, and
7Zs(G) C &apos;R(G) be the set of derivation trees
whose root is labeled with a production of which
left-hand side is the initial symbol S. Clearly,
&apos;R8(G) C TE(0) holds. Remark that &apos;Rs(G) is a
multi-sorted algebra, where the nonterminals are
sorts, and the terminals and the labels of produc-
tions are operators.
A tree transducer (Rounds 1969) defines a
mapping from trees to trees. Since we are mainly
interested in the string language generated by
a tree transducer, a &amp;quot;tree-to-string&amp;quot; version of
transducer defined in (Engelfriet 1980) is used in
this paper. For sets Q and X, let
</bodyText>
<equation confidence="0.426616">
Q[X]={q[x] I q E Q, x E X}.
</equation>
<bodyText confidence="0.882785911764706">
A tree-to-string transducer (yT-transducer
or simply transducer) is defined to be a 5-tuple
M (Q, E, q0, R) where (1) Q is a finite set of
states, (2) E is an input ranked alphabet, (3) A is
an output alphabet, (4) qo E Q is the initial state,
and (5) R is a finite set of rules of the form
q[cr(xi,. ,xn)] v
where q E Q, o- E E, n = p(o-) and v E (AUQRxt,
...,xn}D*. If any different rules in R have differ-
ent left-hand sides, then M is called deterministic
(Engelfriet 1980).
A configuration of a yT-transducer is an ele-
ment in (A U Q[TE(0)])* . Derivation of M is de-
fined as follows. Let t = tnAct2 be
a configuration where c1, c2 E (A U Q[7E(0)])* ,
q E Q, o- E E, p(o-) = n and ,t, E TE(q5).
Assume that there is a rule q[cr(xi, • • • ,x,)] v
in R. Let t&apos; be obtained from v by substituting
t1, , ti, for xl, , xn, respectively, then we de-
fine t zM ct1ticx2. Let =be be the reflexive and
transitive closure of If t•*Al t&apos;, then we say
t&apos; is derived from t. If there is no V.1 E A* such
that t w, then we say no output is derived
from t.
A tree-to-string finite state translation sys-
tem (yT-fts or fts) is defined by a yT-transducer
M and a cfg G, written as (M, G) (Rounds
1969)(Thatcher 1967).
We define yL(M,G), called the yield lan-
guage generated by yT-fts (M, C), as
y L(M , E A* I 3t E s (G) , ga[t] •*m w}
where A is an output alphabet and qo is the initial
state of M. An fts is called deterministic (Engel-
friet 1980) if the transducer M is deterministic.
</bodyText>
<figure confidence="0.5183335">
LI
Li
</figure>
<page confidence="0.980706">
132
</page>
<bodyText confidence="0.996064185185185">
Engelfriet introduced a subclass of fts&apos; called
finite-copying fts&apos; as follows (Engelfriet 1980):
Let (M, G) be an fts with output alphabet A
and initial state go, t be a derivation tree in G
and t&apos; be a subtree of t. Assume that there is
a derivation a : go[t] =* w. Now, delete from
this derivation a all the derivation steps which
operates on t&apos;. This leads to the following new
derivation which keeps t&apos; untouched;
a&apos; : go [t] wi gi, [e]w2 • • • wThg,,„ [t&apos;lw„,±1
where wi E A for 1 &lt;i &lt; n + 1.
The state sequence of t&apos; in derivation a is
defined to be (gi„ , Derivation a has
copying-bound k if, for every subtree of t, the
length of its state sequence is at most k. An Its
(M, G) is a finite-copying, if there is a constant
k and for each w E yL(M,G), there is a deriva-
tion tree tin G and a derivation go [t] = w with
copying-bound k. It is known that the determin-
ism does not weaken the generative capacity of
finite-copying fts&apos; (Engelfriet 1980).
We note that an fts (M, G) can be considered
to be a model of a transformational grammar: A
deep-structure of a sentence is represented by a
derivation tree of G, and M can be considered to
transform the deep-structure into a sentence (or
its surface structure).
</bodyText>
<sectionHeader confidence="0.782119" genericHeader="method">
4 Subclasses of Lexical-functional
grammars
</sectionHeader>
<bodyText confidence="0.999796956521739">
A simple subclass of lfg&apos;s, called r-lfg&apos;s, is in-
troduced in (Nishino 1992), which is shown to
generate all the recursively enumerable languages
(Nakanishi 1992). Here, we define a nondeter-
ministic copying lfg (nc-lfg) as a proper subclass
of r-lfg&apos;s. An nc-lfg is defined to be a 6-tuple
G = (N, T, P, S, Nat, Aat,a) where: (1) N is a fi-
nite set of nonterminal symbols, (2) T is a finite
set of terminal symbols, and (3) P is a finite set of
annotated productions. Sometimes, a nonterminal
symbol, a terminal symbol and an annotated pro-
duction are abbreviated as a nonterminal, a ter-
minal and a production, respectively. (4) S E N
is the initial symbol, (5) Nat,. is a finite set of at-
tributes, and (6) Aatm is a finite set of atoms.
An equation of the form I atr =j, (atr E
Nap) is called an S (structure synthesizing)
schema, and an equation of the form I atr =
val (atr E Natr, val E Aatm) is called a V (im-
mediate value) schema. A functional schema is
either an S schema or a V schema.
Each production p E P has the following
form:
</bodyText>
<equation confidence="0.985823">
p : A —4 B1 B2 • • • Bq, (4.2)
Ev ES1 E52 &apos; • • Esq
</equation>
<bodyText confidence="0.996690733333333">
where A E N, B1, B2, • • • , Bq E N u T. Ev is a
finite set of V schemata and E53 (1 &lt; j &lt; q) is
a singleton of an S schema. A —&gt; B1./32 - • • Bq in
(4.2) is called the underlying production of p. Let
Po be the set of all the underlying productions of
P. Cfg Go = (N, T, Po, S) is called the underlying
cfg of G.
An f-structure of G is recursively defined as a
set F = {(atri, v , (atr2 , v al2) , • • • , (atrk, valk)}
where atri, atr2, • • •, and atrk are distinct at-
tributes, and each of va/i, va/2, • •, and va/k is an
atom or an f-structure. We say that val i (1 &lt; i &lt;
k) is the value of atr, in F and write F. atr, = val.
For a cfg G&apos; = (N&apos; ,T&apos; , P&apos;, S&apos;), derivation re-
lations in G&apos;, denoted by A G, a and A
a (A E ,a e (N&apos; U r)*) are defined in the
usual way.
Suppose Go = (N, T, Po, S) is the underlying
cfg of an nc-lfg G = (N,T, P, Natr)Aatm). Let
t be a derivation tree in Go. (In 4.,7. and 8., the
label of a leaf of a derivation tree is allowed to be
a nonterminal.) Every internal node v in t has
an f-structure, which is called the f-structure of
v and written as F„. If an underlying production
Po : A —+ Bi • • • Bq E Po is applied at v, then v is
labeled with either po itself, or p (E P) of which
Po is the underlying production, if necessary. Let
vi be the ith child of v (1 &lt; i &lt; q). We define
the values of both sides of a functional schema
attached to the symbol in p (on v) as follows:
</bodyText>
<listItem confidence="0.9903035">
• the value of I atr(atr E Nat,.) is F,,. atr,
• the value of 1. in an S schema is F„, if the
S schema is attached to the i(1 &lt; i &lt; g)th
symbol in the right-hand side of p, and
• the value of atom atm in a V schema is atm
itself.
</listItem>
<bodyText confidence="0.956653791666667">
We say that v satisfies functional schemata if for
each functional schema ifs = r5 of p, the val-
ues of ifs and rf, on v are defined and equals
with each other. In this case, it is also said that
F„ locally satisfies the functional schemata of p.
NOTE: Because the meaning of a V schema is in-
dependent of the position where it is annotated,
✓ schemata are attached to the left-hand side in
this paper.
For a nonterminal A E N and a sentential
form a E (N U T)*, let t be a derivation tree of
a derivation A =a. If all internal nodes in
t satisfy functional schemata, then a is said to
be derived from A and written as A = a . In
this case, the tree t is called a derivation tree of
A =&apos;6 a. We also call t a derivation tree (of a)
in G simply.
The language generated by an nc-lfg G, de-
noted by L(G), is defined as L(G) = {w E
T*I S = w}.
NOTE: In the definition of nc-lfg, even if
&amp;quot;Esi (1 5_ j 5_ q) is a singleton of an S
schema&amp;quot;
is replaced with
</bodyText>
<page confidence="0.995074">
133
</page>
<bodyText confidence="0.413286857142857">
&amp;quot;Esj (1 &lt; j &lt; g) is either a singleton of
an S schema or an empty set&amp;quot;,
the generative capacity of nc-lfg is not changed.
Example 4.1: Let G EXS = (N, T, P, S, Nair,
Aatm) be an nc-lfg where N = {S, A, B}, T
{a, b, c, d}, Nair = {count}, Aaim = {e}, and pro-
ductions in P are;
</bodyText>
<equation confidence="0.625268222222222">
A
count =I} {1 count =1} ,
count =1} b
A
count =1} d
P14 --+
{1 couAnt = e}
E
P15 {I count = el •
</equation>
<bodyText confidence="0.981604428571429">
The language generated by G Ex3 is L (G EX3) =
{anbncndn Iii &gt; 0}. Figure 1 shows a derivation
tree of SEx3 aabbccdd in GExs.
Example 4.2: Let GEx4 = (N, T, P, S, Nati&apos;)
Aatm) be an nc-lfg where N = {S}, T = {a},
Nati. = {log}, Aatm = {e}, and productions in P
are;
</bodyText>
<equation confidence="0.996534">
P21 : S —+ S
{T lo=} {1
P22 {I = e} a&amp;quot;
</equation>
<bodyText confidence="0.929548285714286">
The language generated by GEx4 is L(GEx4) =
{a2&amp;quot; In 0}. LI
Example 4.3: Let G Ex5 = (N, T, P, S,
Aatm) be an nc-lfg where N = {S,S&apos;,A,B},
T = {the, woman, men, and, drinks, smoke, respec-
tively}, Nor = {num, list}, Aatm = {sg,pl,nil},
and productions in P are;
</bodyText>
<equation confidence="0.996251566666667">
P30 : S -- S&apos; respectively
,
P31 : {i list =1}
S&apos;—* the woman and A drinks and B
{inum=sg} {Ilist=1} {1list=1}&apos;
P32 : S&apos;-4 the men and A smoke and B
{Ilist=1,} {Ilist=1}&apos;
P33
: {Num= pl}
A -- the woman and A
P34 : { I nul= sg} —&gt; the men andffi iliiissitit:11}}:
{I nurn = pl}
P35 : A —+ the woman
1 i num = sg 1
i iist . na
t
P36 : A he men
{
&apos; Num = pl I
lust . nil
P37 : B —&gt; drinks and B
{1 num = sg} {1 list =1} &apos;
P38 : B -- smoke and B
{ i num = pl} {i /ist =1} ,
P39 : B drinks
1 1 num = sg }
i iist = nil
P310 : mumB= pi 1 --
i smoke
1 i iist = nil
</equation>
<bodyText confidence="0.9767658">
G Ex5 generates &amp;quot;respectively&amp;quot; sentences such as
&amp;quot;the woman and the men drinks and smoke re-
spectively&amp;quot;.
For a set X of functional schemata, X is con-
sistent ill&apos; neither the following (1) nor (2) holds.
</bodyText>
<equation confidence="0.832481">
(1) {I atr = atr = val2} c X
</equation>
<bodyText confidence="0.5512625">
for some atr E Nat,. and some va/i, va/2 E
Aatm such that vadi vad2.
</bodyText>
<listItem confidence="0.486063">
(2) {I atr = val,i atr =.1} cx
</listItem>
<bodyText confidence="0.971998066666667">
for some atr E Nat,. and some vat E Aatm.
Productionspi., • • • ,pn are consistent if
U1&lt;i&lt;n E(i) is consistent where E(i) is the set of
functional schemata of pi. If productions are not
consistent then they are called inconsistent.
An nc-lfg G is called a deterministically copy-
ing lfg (dc-hg), if any two productions A al
and A a2 whoes left-hand sides are the same
are inconsistent.
Suppose G = (N,T, P, S, Nab&amp;quot; Actim) is an
nc-lfg. Let {{el, e2,•• • , en}} denote the multi-
set which consists of elements el, e2, • • • , en that
are not necessarily distinct. An SPN (SubPhrase
Nonterminal) multiset in G is recursively defined
as the following 1 through 3:
</bodyText>
<listItem confidence="0.889171">
1. {{S}} is an SPN multiset.
2. Suppose that {{A1, A2 , • • • , Ah}} (A1, A2 • • •,
</listItem>
<figure confidence="0.915431666666667">
Ah E N) is an SPN multiset. Let A1 al,
[count [count::
[count :[count [count::
[count :[count : el
[count: e
count: e]
</figure>
<figureCaption confidence="0.994473">
Figure 1: A derivation tree of aabbccdd
</figureCaption>
<figure confidence="0.649868">
Pn :S—* {T
P12 a
P13 : B c
II
</figure>
<page confidence="0.971982">
134
</page>
<listItem confidence="0.998391142857143">
• Ah oth be consistent productions. For
each air E Natr, let MSat, be the multi-
set consisting of all the nonterminals which
appear in ai, • • • , ah and have an S schema
air =J. If MS,. is not empty, then MSat,
is also an SPN multiset.
3. There is no other SPN multiset.
</listItem>
<bodyText confidence="0.969818454545454">
An nc-lfg such that the number of SPN multisets
in G is finite is called a finite-copying lfg (fc-lfg).
Example 4.4: Consider GEx3 in Example 4.1.
Productions p12 and pH are inconsistent with
each other and so are p13 and pi5. SPN multisets
in GEx3 are {{S}} and {{A, B}}. Hence GEX3
is a dc-lfg and is an fc-lfg. GEx5 is also a dc-lfg
and is an fc-lfg by the similar reason. Similarly,
GEx4 in Example 4.2 is a dc-lfg. SPN multisets
in GEx4 are {{S}}, {{S, S}}, {{S, S, S, SD, • • • .
Hence GEx4 is not an fc-lfg.
</bodyText>
<equation confidence="0.955095">
NOTE:LI
L (G Ex5) is generated by a tree adjoining
</equation>
<bodyText confidence="0.999674">
grammar. Suppose that a sentence has three or
more phrases which have co-occurrence relation
like the one between the subject phrase and the
verb phrase in the &amp;quot;respectively&amp;quot; sentence. Tree
adjoining grammars can not generate such syntax
while fc-lfg&apos;s or dc-lfg&apos;s can, although the authors
do not know a natural language which has such
syntax so far.
By Lemma 2.1 and Theorem 8.1, fc-lfg&apos;s are
polynomial-time recognizable. Hence, it is desir-
able that whether a given lfg G is an fc-lfg or not
is decidable. Fortunately, it is decidable by the
following lemma.
Lemma 4.1: For a given nc-lfg G, it is decid-
able whether the number of SPN multisets in G
is finite or infinite.
Proof. The problem can be reduced to the
boundedness problem of Petri nets, which is
known to be decidable (Peterson 1981).
</bodyText>
<sectionHeader confidence="0.671444" genericHeader="method">
5 Overview of the Results
</sectionHeader>
<bodyText confidence="0.999037142857143">
Let rn,_kfg, rdc-lfg and fc-lfg denote the classes
of languages generated by nc-lfg&apos;s, dc-lfg&apos;s and
fc-lfg&apos;s, respectively, and let y.C.ft,, yrd_ft, and
yGfe_fts denote the classes of yield languages gen-
erated by fts&apos;, deterministic fts&apos; and finite-copying
fts&apos;, respectively. Let Lp,,,fg and rrhcfg be the
classes of languages generated by pmcfg&apos;s and
mcfg&apos;s, respectively. Also let Ltag be the class of
language generated by tree adjoining grammars.
Inclusion relations among these classes of
languages are summarized in Figure 2. An equiv-
alence relation *1 is shown in (Weir 1992). Re-
lations *2 are new results which we prove in this
paper. We also note that all the inclusion rela-
</bodyText>
<equation confidence="0.900777833333333">
tions are proper; indeed,
{ceila72W3&apos;cil: I n 0} E D — E
{a7a&apos;22 • • ce22,7,_ia&apos;22m n &gt; 0} E C — D for m &gt; 3,
(by (Vijay-Shanker 1987).)
{a2n n &gt; 0} E B — C,
(by (Kasami 1988a)(Seki 1991).)
</equation>
<bodyText confidence="0.9995651">
A relation B A is shown in (Engelfriet 1980). By
Lemma 2.1, all languages in the region enclosed
with the bold line are recognizable in polynomial
time. On the other hand, it is shown in this
paper that Unary-3SAT, which is known to be
./VP-complete (Nakanishi 1992), is in A. Hence,
if P _ATP, then Unary-3SAT E A — B and the
languages generated by fts&apos; (or equivalently, nc-
lfg&apos;s) are not recognizable in polynomial time in
general.
</bodyText>
<sectionHeader confidence="0.993412" genericHeader="method">
6 Generative Capacity of fts&apos;
</sectionHeader>
<subsectionHeader confidence="0.958279">
6.1 Deterministic fts&apos;
</subsectionHeader>
<bodyText confidence="0.935222333333333">
Here, the proof of an inclusion relation yrd_ft, C
Lpmcfg is sketched.
Let (M, G) be a deterministic yT-fts where
</bodyText>
<equation confidence="0.9854155">
M = (Q, E, , R) and G (N,T, P, S). We
assume that Q = {qi, ,qt}, T = {al, • • • an}
</equation>
<bodyText confidence="0.928945928571429">
and P = {pi, ,Pm}. Since the input for M is
the set of derivation trees of G, we assume that
= {Pi, ,Pm,ai,..,a} without loss of gen-
erality.
We will construct a pmcfg G&apos; = (N&apos;,T&apos; , F&apos;,
P&apos;, S&apos;) such that yL(M, G) = L(G&apos;) n A*. Since
Lpmcfg is closed under the intersection with a
regular set (Kasami 1988a)(Seki 1991), it follows
that yL(M,G) E Lprhcfg. Let T&apos; =A U {b} where
b is a newly introduced symbol and let
= {S&apos; Rrn, A1, • • • An}
where d(Rt) = d(A) = for 1 &lt; j &lt; m and
1 &lt;j &lt; n. Productions and functions of G&apos; will
be constructed to have the following property.
</bodyText>
<figureCaption confidence="0.993019">
Figure 2: Inclusion relations between classes of
languages. (1) : The class of language generated
by lcfrs&apos; is equal to C. (2) : The class of language
generated by head grammars is equal to D.
</figureCaption>
<figure confidence="0.9989763">
TA
L B
yLns rnc-lfg
*2
y d-fts 112 rdc-lfg
yl:fi,fts =
*2 Lfc—lfg
(2) ct.g -
E Lcfg
Li
</figure>
<page confidence="0.982674">
135
</page>
<bodyText confidence="0.876763571428571">
Property 6.1: There is (ai, ... ,a) E LG&apos;(Rh)
(resp. LG,(Ah)) such that
{
each of a3,,... , a,. does not contain b, and
every remaining at„ ..., at. contains b
if and only if there is a derivation tree t of G such
that the root is ph (resp. ah) and
</bodyText>
<equation confidence="0.729163">
qs,[t] as, (1 &lt; j &lt; u)
no output is derived from qt,[t] (1 &lt; j &lt; v).
LI
</equation>
<bodyText confidence="0.981522545454545">
The basic idea is to simulate the move of tree
transducer M which is scanning a symbol ph
(resp. ah) with state qi by the ith component of
the nonterminal Rh (resp. Ah) of pmcfg . Dur-
ing the move of M, it may happen that no rule
is defined for a current configuration and hence
no output will be derived. The symbol b is intro-
duced to represent such an undefined move ex-
plicitly.
We define RS(X) (X E N U T) as follows.
{Rh I the left-hand side of ph is X}
</bodyText>
<equation confidence="0.83705425">
RS (X) = if X E N
{Ah}
ifX=ahET.
Productions and functions are defined as follows.
</equation>
<bodyText confidence="0.88707025">
Step 1: For each production ph : 170 -4
Yi--• Yk (170 EN,YuENUTfor 1 &lt;u&lt;k)
of cfg G, construct nonterminating produc-
tions
</bodyText>
<equation confidence="0.664269">
Rh fph[Zi, • • • , Zic]
</equation>
<bodyText confidence="0.9871815">
for every Zu E RS(Y,2) (1 &lt;u &lt; k), where fph
is defined as follows: For 1 &lt; i &lt; t,
</bodyText>
<listItem confidence="0.973443875">
• if the transducer M has no rule whose left-
hand side is qi[ph(xi,... , xk)], then
ft[,,][xi, • . • , tkj-=%, (6.3)
• if M has a rule
qi[Ph(xi, • • •, xk)1 ai,o 4710,o)[xpo,o)]ai,i
• • • ai,ni_ign(i,n,-1)[xpo,n,-1)]ifltj then
fk,![t-i.,.• • , -±ki =cti,oxpo,o),70,0)ao (6.4)
• • • cti,n, - ),70 ,ni -
</listItem>
<bodyText confidence="0.941231714285714">
where ..th = (x.i, • • . ,x) (1 &lt; u &lt; k).
(Since M is deterministic, there exists at most
one rule whose left-hand side is qi[ph(• • •)] and
hence the above construction is well defined.)
Step 2: For each ah E T, construct a terminat-
ing production Ah fah where fah is defined
as follows: For 1 &lt; i &lt; t,
</bodyText>
<listItem confidence="0.95703275">
• if M has no rule whose left-hand side is
qi[ah], then
• if M has a rule qz[ah] ai, then fit,
Step 3: For each Rh E RS(S), construct S&apos; --+
</listItem>
<bodyText confidence="0.951145933333333">
ifirst[Rh] where ffirst,[(Xi, Xt)]L4Xi. Intu-
itively, the right-hand side of this production
corresponds to the initial configuration, that
is, M is in the initial state qi and scanning
the root symbol ph of a derivation tree, where
the left-hand side of ph is the initial symbol
S.
The pmcfg GI constructed above satisfies
Property 6.1. Its proof is found in (Kaji 1992)
and omitted in this paper. By Property 6.1, we
obtain the following lemma.
Lemma 6.1: yLd-fts Lpmcfg• LI
The reverse inclusion relation Cpn,th C
yEd_ft, can be shown in a similar way, and the
following theorem holds.
</bodyText>
<construct confidence="0.591626">
Theorem 6.2: Y --r cl-fts = Lpmcfg. LI
</construct>
<subsectionHeader confidence="0.990506">
6.2 Nondeterministic fts&apos;
</subsectionHeader>
<bodyText confidence="0.999697470588235">
In this section, the generative capacity of nonde-
terministic yT-fts&apos; is investigated, from the view-
point of computational complexity. We have al-
ready shown that yLd_fis = rp,u4g, and hence
every language in this class can be recognized in
time polynomial of the length of an input string.
Our result here is: there is a nondeterministic Its
that generates an ,NP-complete language. In the
following, a language called Unary-3SAT, which
is .VP-complete (Nakanishi 1992), is considered,
and then it is shown to belong to y
A Unary-3CNF is a (nonempty) 3CNF in
which the subscripts of variables are represented
in unary. A positive literal xi in a 3CNF is rep-
resented by lt$ in a Unary-3CNF. Similarly, a
negative literal is represented by 1&apos;#. For
example, a 3CNF
</bodyText>
<equation confidence="0.693506666666667">
(x1 V x2 V -a3) A (x3 V --Ix1 V -1x2)
is represented by a Unary-3CNF
1$11$111# A 111$1#11#.
</equation>
<bodyText confidence="0.984522166666667">
Unary-3SAT is the set of all satisfiable Unary-
3CNF&apos;s.
Next, we construct a nondeterministic yT-fts
(M, G) that generates Unary-3SAT. Define a cfg
G = (N,T, P, S) where N = {S,T, F}, T = {e}
and the productions in P are as follows:
</bodyText>
<equation confidence="0.9961138">
rss : S —&gt; S rre : T e
rsT : S T r FT : F T
rsp, : S F r.FF : F F
rTy. : T — T r Fe : F e
rTF : T F.
</equation>
<page confidence="0.805189">
136
</page>
<bodyText confidence="0.718122">
Let M = (Q, E, q0, R) where
</bodyText>
<equation confidence="0.954003666666667">
go&gt; qc,qt,qa},
rss,...,rFel,
1, A, $, #}.
</equation>
<bodyText confidence="0.997432666666667">
Since there are many rules in R, we will use an ab-
breviated notation. For example, following four
rules
</bodyText>
<equation confidence="0.9299065">
qa[rTe(x)] 1$, qa[rTe(x)] —&gt; 1#
qa[r Fe(x)] -4 1$, qa[rFe(x)] —&gt; 1#
</equation>
<bodyText confidence="0.82270425">
are abbreviated as &amp;quot;qa[rTe(x)] =- qa[rFe(x)]
1$ or 1#&amp;quot;. By using this notation, the rules in R
are defined as follows.
go Irss (x) qe [x] A qo [x]
</bodyText>
<equation confidence="0.999663">
qc[rss(x) qe[x]
9o[r sT(x)] = qo[r sF(x)} = qc[r sT(x)1
= qa[r sF(x) qt[x]qa[x]qa[x] or
qa[x]qt[x]qa[x] or qa[x]qa[x]qt[x]
qt[rTT(x)] = qt[rTF(x) 1q[x] or 1$
qt[rTe(x) —&gt; 1$
qt[rFT(x)] = qt[r FF(x) lqt[x] or 1#
qt[rFe(x) —&gt; 1#
qa[rTT(x)] = qa[rTF(x) = qa[r FT (x)]
= qa[rFF(x) lqa[x] or 1$ or 1#
qa[rTe(x)] = qa[r Fe(x) —&gt; 1$ or 1#.
</equation>
<bodyText confidence="0.9638475">
The readers can easily verify that this yT-fts
generates Unary-3SAT.
</bodyText>
<sectionHeader confidence="0.607228" genericHeader="method">
7 Equivalence of Lnc_tyg and yLtt
</sectionHeader>
<subsectionHeader confidence="0.349376">
s
</subsectionHeader>
<bodyText confidence="0.994361882352941">
First, we show Gyjc_ug C yr. For a given nc-
lfg G = (N,T,P, S, Nat, Aatm), an equivalent Its
(M, G&apos;) is constructed in the following way.
Let t be a derivation tree in lfg G and
the f-structure of the root node of t be F =
{ (atri, FO, • • , (atr„,Fa)}. F is represented by
a derivation tree T = pisp(Ti , • • • , Tn) in G&apos;, where
ri (1 &lt; i &lt; n) is a derivation tree in G&apos; which rep-
resents Fi recursively. And sp is a set of produc-
tions such that F locally satisfies the functional
schemata of all productions in sp. M transforms
T into the yield of t, i.e., the terminal string ob-
tained by concatenating the labels of leaves, in a
top-down way.
[TRANS 7.1] Let N = {Al,. • • , Ara}, S = A1
and Nat,. = { atri, • • , atrn}. Define SP as the set
of all consistent subsets of P.
</bodyText>
<equation confidence="0.9608356">
Step 1: G&apos; = , {d}, P&apos; , S&apos;), where N&apos; =
IS spisp E SP} U {S&apos;} and
P1 = {p&apos;sp : S82, —&gt; • • S&apos;}
U{liguess„, : S&apos; Sspisp E SP}
U{p&apos;t„,n: S&apos; d • • • cl}.
</equation>
<bodyText confidence="0.976938782608696">
For a derivation tree r in G&apos; and a node v
where p&apos;82, is applied, the subtree rooted by the
ith child of v represents the value of attribute
atri.
Step 2: M = (Q, E, T, qi, R) is defined as fol-
lows.
Define Q = , q,.„}. A state q3 (1 j &lt;m)
corresponds to nonterminal A) in N. Define E =
fp is p I sp E SP} U {eguess.p I sp E SP} U {piterm} u
{d} where p(p) =P(Pigue,..p) = P(Perm) = n
and p(d) = 0. And define R by the following (i)
through (iii).
4314..38„(x)1 -4 43[x] (1 _&lt; j m) belongs
to R for each sp E SP.
(ii) Let T be a derivation tree in C&apos;. When p&apos;sp
is the production applied at the root of T and
a state of M is q,,„ M chooses a production
p whose left-hand side is Apo, if exists, in sp.
NOTE : Since productions in sp are consis-
tent, there is an f-structure, which locally sat-
isfies the functional schemata of all produc-
tions in sp.
For each production p E sp in SP
</bodyText>
<equation confidence="0.489438">
p: ao Aihi al . aL-1 Apz, aL
Ev {T atrvi =.1.} • • • { atrvr, =.1.1
</equation>
<bodyText confidence="0.946025307692308">
where Am, E N and ai E T*(0 &lt; 1 &lt; L), the
following rule belongs to R:
ff--■°[P asi Po(qx 121 joex ceL-igAL [xvLiaL. (7.5)
(iii) No other rule belongs to R. III
Next, yLii, c Encg is shown. For a given
fts (M, G), the following algorithm constructs an
nc-lfg G&apos; such that L(G&apos;) = yL(M,G).
[TRANS 7.2] Suppose that a given fts (M, G) is
G = (N,T, P, S) and M = (Q, E, qi, R) where
Q = {qi, q2, • • • , qm,}. Let n be the maximum
length of the right-hand side of a production in P.
Define an nc-lfg G&apos; = (N&apos;, A, , Natr, Aatm)
as follows.
</bodyText>
<equation confidence="0.9737224">
Step 1: N&apos; = {C[j] IC E N,1 &lt; j &lt;m}
Li-ta[i] a E T,1 &lt;j &lt;m},
S&apos; =
Nat,. = {atr, 11 &lt; i &lt; n} U {rule}, and
Aatm = {pip is the label of
</equation>
<bodyText confidence="0.940165888888889">
a production in P}.
A derivation tree t = p(ti, • • • , th) in G is rep-
resented by an f-structure {(rule,p),(atri, F1),
• • ,(atrh, Fh)} of G&apos; where F,(1 &lt; i &lt; h) is
an f-structure which represents the subtree te
recursively.
Each pair of a symbol (either nonterminal or
terminal) X of G and a state qj of M is rep-
resented by a single nonterminal Xi•i1 in G&apos;.
</bodyText>
<equation confidence="0.629821">
Q=
E =
A =
</equation>
<page confidence="0.914533">
137
</page>
<bodyText confidence="0.839817">
Step 2: A move when M at state qi reads a
symbol p which is the label of a production
p: C -4 • • •, can be simulated by a production
in GI whose left-hand side is C111 .
</bodyText>
<equation confidence="0.552816">
{intle =
</equation>
<bodyText confidence="0.941466">
Formally, the set P&apos; of productions of Gi is con-
structed as follows.
(i) Let p: C Xl• • • Xh be a production in P
where C E N, X2 E NUT (1 &lt; i &lt; h), and
let:
</bodyText>
<equation confidence="0.9303435">
qi[P(xi, • • • , xh )]
jail • • • qq[xv,,,,]cejL,
</equation>
<bodyText confidence="0.628160333333333">
be a rule in R where otik E A* (0 &lt; k &lt;
E Q, and x,, E {x1, • • • , xh} (1 &lt; / &lt;
Then, the following production belongs to P&apos;:
</bodyText>
<equation confidence="0.984292">
a30 ail • • • Xv[ri&apos;LL&apos;i aiL., •
{irule= p} { =0 {1atr,,,L3, =f}
</equation>
<bodyText confidence="0.961970142857143">
(ii) Let q3[al 03 be a rule in R where a E T
and p; E A*. Then the production a[i] Pi
belongs to P&apos;.
(iii) No other production belongs to P&apos;.
By TRANS 7.1 and TRANS 7.2, the fol-
lowing theorem is obtained. A formal proof is
found in (Nakanishi 1993).
</bodyText>
<equation confidence="0.6051055">
Theorem 7.1: = Kfts.
Corollary 7.2: Gdc_ifg = yLd_tts.
</equation>
<bodyText confidence="0.999518555555556">
Proof. In TRANS 7.1, if G is a dc-lfg, then
no sp E SP contains distinct productions whose
left-hand sides are the same and hence the con-
structed transducer M becomes deterministic by
the construction. Conversely, in TRANS 7.2, if
M is deterministic, then there exist no consistent
productions and p&apos;2 in P&apos; whose left-hand sides
are the same and hence the constructed nc-lfg is
a dc-lfg.
</bodyText>
<sectionHeader confidence="0.623529" genericHeader="method">
8 Equivalence of G fc_lfg and mcfg
</sectionHeader>
<bodyText confidence="0.961709333333333">
To prove Cfc-ifg C .Cmcfg, we give an al-
gorithm which translates a given fc-lfg G =
(N, T, P, S, Nair, Aeire) into an mcfg G&apos; such that
</bodyText>
<equation confidence="0.793717">
L (G&apos;) = L (G).
</equation>
<bodyText confidence="0.62388725">
[TRANS 8] We explain the algorithm by us-
ing the fc-lfg GEX3 in Example 4.1. An mcfg
= (N&apos; ,T, F, F&apos;, S) is constructed as follows.
Step 1: N&apos; = (the set of nonterminals which
has a one-to-one correspond-
ence with the set of SPN multi-
sets in G)
= {(S), (A, B)}
(for GEX3
P&apos; = 0, and
F = 0.
Step 2: For each SPN multiset Mo = {{Ai, A2)
</bodyText>
<listItem confidence="0.964241">
• • • , AO} of G, consider every tuple (731,P21
•
</listItem>
<bodyText confidence="0.996907222222222">
,Pk) of productions in P whose left-
hand sides are A1, A2, • • • , Ak respectively and
which are consistent. (Suppose that, if we
write an SPN multiset as {{Ai, A2, • • •
then A3&apos;s are arranged according to a pre-
defined total order &lt; on N, that is, Ai &lt;
A2 &lt; • • • &lt; Ak hold.) For an SPN multiset
{{A, B}} in GEX3, the following two pairs of
productions have to be considered:
</bodyText>
<equation confidence="0.930775125">
P12 A a A
{icount =1}
P13 B -4 c B d,
I. {icount =1}
{ P14 A
{icount = e}
pis e .
{icount = e}
</equation>
<bodyText confidence="0.99789747368421">
For (pi, p2, • • • ,pk), a production p&apos; and a
function f of GI are constructed and added
to P&apos; and F, respectively as follows.
The multiset M of the nonterminals appearing
in the right-hand side of some p3 (1 &lt; i &lt; k)
are partitioned into multisets MI, M2, • • • ,
with respect to the S schemata attached
to the nonterminals in p3&apos;s. That is,
(M1, M2 • • ) are the coarsest partition of
M such that for each Mu (1 &lt;u &lt; h), the fol-
lowing condition holds.
Each nonterminal in Mu has the same S
schema.
By the definition, each Mu (1 &lt; u &lt; h) is an
SPN multiset in G. Construct a production of
mcfg p&apos;: Mo f[Mi, M2, • • • , Mh] where Mu
is the nonterminal of G&apos; which corresponds to
M(1 &lt;U &lt; Add p&apos; to /31 and f to F
where f is defined as follows. Suppose
</bodyText>
<equation confidence="0.844252">
p3 : A3 crioB3ia31 • • • 133L3ajL, (1 &lt;j &lt; k)
where A3 E N, B31 E N (1 &lt; 1 &lt; L3) and
cx31 E T* (0 &lt; 1 &lt; L3), and let
Mu = { { Cul Cu21. • ,Cus„}} U h)
</equation>
<bodyText confidence="0.97204075">
where Cua E N(1 &lt; v &lt; se). Then, for 1 &lt;
j &lt; k, the jth component PA of f is:
f[31 (±-1, &apos; • &apos; xh)ctioYilailY32 • • • YjLia3L,
where x-u = (xui, xu2, • • • , xus„) (1 &lt; u &lt; h).
For j (1 &lt; j &lt; k) and / (1 &lt; / &lt; L3), if
B31 = Cue then y3ixua. Note that, since
Ma&apos;s are a partition of M, f satisfies Right
Linearity (see 2.) and hence G&apos; is an mcfg.
For example, consider the above (
v7312,P13)•
The nonterminals appearing in the right-hand
in Example 4.1)
</bodyText>
<page confidence="0.96268">
138
</page>
<bodyText confidence="0.905674428571429">
sides are A and B, and their S schemata are
the same. Thus, we construct the following
mcfg production:
(A, B) fi [(A, B)]
where fi [(xi , x2)] = (axib, cx2d).
Consider the following pair of productions as
another example:
</bodyText>
<figure confidence="0.98051075">
: A a
B b D
p&apos;2 : B -&gt; A liatri =1)-(Tatr2 =1}
C c D
</figure>
<figureCaption confidence="0.477185">
{tatri =1} liatr2 =1,1 {iatr2 =1}
</figureCaption>
<bodyText confidence="0.997595571428571">
The multiset of nonterminals in the right-
hand sides are partitioned into M1 =
{{A,B}} (for atr 1) and M2 = IIC, D, Dil
(for atr2). For (24,112), the following mcfg
production is constructed:
(A, B) g [(A, B), (C, D)]
where g [(xi&apos;, x3.2),
</bodyText>
<equation confidence="0.572416555555556">
Example 8.1: TRANS 8 translates fc-lfg
G Ex3 in Example 4.1 into an equivalent mcfg
GIEx3 = (N&apos; ,T, F, P&apos; , S&apos;) where N&apos; , S&apos; are those
illustrated in TRANS 8, F = {foRxi, x2)] =
x1x2, h[(xi, x2)] (axib,cx2d), f2 = 01,
and, P&apos; = {(S) -+ f 0[(A, B)], (A, B)
fiRA, BA, (A, -13) ---+ f2}. LI
Theorem 8.1: Crricf g = rfc-lfg•
Proof : f c_if g C f g can be proved by
</equation>
<bodyText confidence="0.9518905">
TRANS 8. Conversely, for a given mcfg G, an
fc-lfg G&apos; such that L (G&apos;) = L (G) can be con-
structed in a similar way to TRANS 8. Details
are found in (Ando 1992). LI
</bodyText>
<sectionHeader confidence="0.997127" genericHeader="conclusions">
9 Conclusion
</sectionHeader>
<bodyText confidence="0.9999288">
In this paper, we introduce three subclasses of
lfg&apos;s, two of which can be recognized in polyno-
mial time. Also this paper clarifies the relations
between the generative capacities of those sub-
classes, pmcfg&apos;s and fts&apos;.
</bodyText>
<sectionHeader confidence="0.998997" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999230527777777">
Ando, S. et al. 1992. &amp;quot;Subclasses of Lexical-
Functional Grammars Which Are Recognizable
in Polynomial Time&amp;quot;, IEICE Technical Report,
COMP92-44.
Engelfriet, J. and Heyker, L. 1991. &amp;quot;The String Gen-
erating Power of Context-Free Hypergraph Gram-
mars&amp;quot;, J. Comput. &amp; Syst. Sci., 43:328-360.
Engelfriet, J., Rosenberg, G. and Slutzki, G. 1980.
&amp;quot;Tree Transducers, L Systems, and Two-Way Ma-
chines&amp;quot;, J. Comput. &amp; Syst. Sci., 20:150-202.
Joshi, A.K., Levy, L. and Takahashi, M. 1975 &amp;quot;Tree
Adjunct Grammars&amp;quot;, J. of Comput. &amp; Syst. Sci.,
10:136-163.
Gazdar, G. and Pullum, G.K. 1985. &amp;quot;Computa-
tionally Relevant Properties of Natural Languages
and Their Grammars&amp;quot;, New Generation Computing,
3:273-306.
Kaji, Y. et al. 1992. &amp;quot;Parallel Multiple Context-
Free Grammars and Finite State Translation Systems
&amp;quot;, IEICE Technical Report, COMP92-34.
Kaplan, R. and Bresnan, J. 1982. &amp;quot;Lexical-
Functional Grammar&amp;quot;, The Mental Representation
of Grammatical Relations, J.Bresnan (ed.), MIT
press:173-281.
Kasami, T. et al. 1988a. &amp;quot;Generalized Context-Free
Grammars and Multiple Context-Free Grammars&amp;quot;,
Trans. IEICE, J71-D-I, 5:758-765.
Kasami, T. et al. 1988b. &amp;quot;On the Membership Prob-
lem for Head Language and Multiple Context-Free
Languages, Trans. IEICE, J71-D-I, 6:935-941.
Nakanishi, R. et al. 1993. &amp;quot;On the Generative
Capacity of Tree Translation Systems and Lexi-
cal Functional-Grammars&amp;quot;, Technical Paper of FAI,
Japanese Society for Artificial Intelligence, SIG-
FAI-9202.
Nakanishi, R. et al. 1992. &amp;quot;On the Generative Capac-
ity of Lexical-Functional Grammars&amp;quot;, IEICE Trans.
Inf. and Syst., 75-D, 7:509-516.
Nishino, T. 1991. &amp;quot;Mathematical Analysis of Lexical-
Functional Grammars -Complexity, Parsability, and
Learnability-&amp;quot;, Language Research Institute, Seoul
National University.
Nishino, T. 1992. &amp;quot;Relating Attribute Grammars
and Lexical-Functional Grammars&amp;quot;, Information Sci-
ences, 66:1-22.
Peterson, J.L. 1981. &amp;quot;Petri Net Theory and the Mod-
eling of Systems&amp;quot;, Prentice-Hall.
Pollard, C.J. 1984. &amp;quot;Generalized Phrase Structure
Grammars, Head Grammars and Natural Language&amp;quot;,
Ph.D. dissertation, Stanford University.
Rounds, W.C. 1969. &amp;quot;Context-Free Grammars on
Trees&amp;quot;, Proc. of ACM STOC:143-148.
Seki, H. et al. 1991. &amp;quot;On Multiple Context-
Free Grammars&amp;quot;, Theoretical Computer Science, 88,
2:191-229.
Thatcher, J.W. 1967. &amp;quot;Characterizing Derivation
Trees of Context-Free Grammars through a Gener-
alarization of Finite Automata Theory&amp;quot;. J. Comput.
Rz Syst. Sci., 1:317-322.
Vijay-Shanker, K. 1987. &amp;quot;A Study of Tree Adjoining
Grammars&amp;quot;, Ph.D. thesis, University of Pennsylva-
nia.
Vijay-Shanker, K., Weir, D.J. and Joshi, A.K. 1987.
&amp;quot;Characterizing structural descriptions produced by
various grammatical formalisms&amp;quot;, Proc. of 25th
meeting of Assoc. Comput. Ling.:104-111.
Weir, D.J. 1988. &amp;quot;Characterizing Mildly Context-
Sensitive Grammar Formalisms&amp;quot;, Ph.D. thesis, Uni-
versity of Pennsylvania.
Weir, D.J. 1992. &amp;quot;Linear Context-Free Rewriting
Systems and Deterministic Tree-Walking Transduc-
ers&amp;quot;, Proc. of 30th meeting of Assoc. Comput. Ling.
</reference>
<figure confidence="0.588599333333333">
X11X21CX23)•
(x21, x22, x23)](axi2bx22,
LI
</figure>
<page confidence="0.980397">
139
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.371073">
<title confidence="0.989723333333333">PARALLEL MULTIPLE CONTEXT-FREE GRAMMARS, FINITE-STATE TRANSLATION SYSTEMS, AND POLYNOMIAL-TIME RECOGNIZABLE SUBCLASSES OF LEXICAL-FUNCTIONAL GRAMMARS</title>
<author confidence="0.860166">Hiroyuki Seki tt Ryuichi Nakanishi t Yuichi Kaji Sachiko Ando t Tadao Kasami</author>
<affiliation confidence="0.999902">of Information and Computer Sciences, Faculty of Engineering Science, Osaka University</affiliation>
<address confidence="0.985597">1-1 Machikaneyarna, Toyonaka, Osaka 560, Japan</address>
<affiliation confidence="0.724123">Graduate School of Information Science, Advanced Institute of Science and Technology, Nara</affiliation>
<address confidence="0.992782">8916-5 Takayama, Ikoma, Nara 630-01, Japan</address>
<email confidence="0.772546">Internet:seki@ics.es.osaka-u.ac.jp</email>
<abstract confidence="0.999944777777778">A number of grammatical formalisms were introduced to define the syntax of natural languages. Among them are parallel multiple context-free grammars (pmcfg&apos;s) and lexical-functional grammars (lfg&apos;s). Pmcfg&apos;s and their subclass called multiple context-free grammars (mcfg&apos;s) are natural extensions of cfg&apos;s, and pmcfg&apos;s are known to be recognizable in polynomial time. Some subclasses of lfg&apos;s have been proposed, but they were to generate an language. Finite state translation systems (fts&apos;) were introduced as a computational model of transformational grammars. In this paper, three subclasses of lfg&apos;s called nc-lfg&apos;s, dc-lfg&apos;s and fc-lfg&apos;s are introduced and the generative capacities of the above mentioned grammatical formalisms are investigated. First, we show that the generative capacity of fts&apos; is equal to that of nc-lfg&apos;s. As relations among subclasses of those formalisms, it is shown that the generative capacities of deterministic fts&apos;, dc-lfg&apos;s, and pmcfg&apos;s are equal to each other, and the generative capacity of fc-lfg&apos;s is equal to that of mcfg&apos;s. It is also shown that at least one NP-complete language is generated by fts&apos;. Consequently, deterministic fts&apos;, dc-lfg&apos;s and fc-lfg&apos;s can be recognized in polynomial time.</abstract>
<intro confidence="0.958313">fts&apos; (and nc-lfg&apos;s) cannot, if P</intro>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>S Ando</author>
</authors>
<title>Subclasses of LexicalFunctional Grammars Which Are Recognizable in Polynomial Time&amp;quot;,</title>
<date>1992</date>
<tech>IEICE Technical Report, COMP92-44.</tech>
<marker>Ando, 1992</marker>
<rawString>Ando, S. et al. 1992. &amp;quot;Subclasses of LexicalFunctional Grammars Which Are Recognizable in Polynomial Time&amp;quot;, IEICE Technical Report, COMP92-44.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Engelfriet</author>
<author>L Heyker</author>
</authors>
<title>The String Generating Power of Context-Free Hypergraph Grammars&amp;quot;,</title>
<date>1991</date>
<journal>J. Comput. &amp; Syst. Sci.,</journal>
<pages>43--328</pages>
<marker>Engelfriet, Heyker, 1991</marker>
<rawString>Engelfriet, J. and Heyker, L. 1991. &amp;quot;The String Generating Power of Context-Free Hypergraph Grammars&amp;quot;, J. Comput. &amp; Syst. Sci., 43:328-360.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Engelfriet</author>
<author>G Rosenberg</author>
<author>G Slutzki</author>
</authors>
<title>Tree Transducers,</title>
<date>1980</date>
<journal>L Systems, and Two-Way Machines&amp;quot;, J. Comput. &amp; Syst. Sci.,</journal>
<pages>20--150</pages>
<marker>Engelfriet, Rosenberg, Slutzki, 1980</marker>
<rawString>Engelfriet, J., Rosenberg, G. and Slutzki, G. 1980. &amp;quot;Tree Transducers, L Systems, and Two-Way Machines&amp;quot;, J. Comput. &amp; Syst. Sci., 20:150-202.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A K Joshi</author>
<author>L Levy</author>
<author>M Takahashi</author>
</authors>
<title>Tree Adjunct Grammars&amp;quot;,</title>
<date>1975</date>
<journal>J. of Comput. &amp; Syst. Sci.,</journal>
<pages>10--136</pages>
<marker>Joshi, Levy, Takahashi, 1975</marker>
<rawString>Joshi, A.K., Levy, L. and Takahashi, M. 1975 &amp;quot;Tree Adjunct Grammars&amp;quot;, J. of Comput. &amp; Syst. Sci., 10:136-163.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Gazdar</author>
<author>G K Pullum</author>
</authors>
<title>Computationally Relevant Properties of Natural Languages and Their Grammars&amp;quot;,</title>
<date>1985</date>
<journal>New Generation Computing,</journal>
<pages>3--273</pages>
<marker>Gazdar, Pullum, 1985</marker>
<rawString>Gazdar, G. and Pullum, G.K. 1985. &amp;quot;Computationally Relevant Properties of Natural Languages and Their Grammars&amp;quot;, New Generation Computing, 3:273-306.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Kaji</author>
</authors>
<title>Parallel Multiple ContextFree Grammars and Finite State Translation Systems &amp;quot;, IEICE</title>
<date>1992</date>
<tech>Technical Report, COMP92-34.</tech>
<contexts>
<context position="27317" citStr="Kaji 1992" startWordPosition="5373" endWordPosition="5374"> ah E T, construct a terminating production Ah fah where fah is defined as follows: For 1 &lt; i &lt; t, • if M has no rule whose left-hand side is qi[ah], then • if M has a rule qz[ah] ai, then fit, Step 3: For each Rh E RS(S), construct S&apos; --+ ifirst[Rh] where ffirst,[(Xi, Xt)]L4Xi. Intuitively, the right-hand side of this production corresponds to the initial configuration, that is, M is in the initial state qi and scanning the root symbol ph of a derivation tree, where the left-hand side of ph is the initial symbol S. The pmcfg GI constructed above satisfies Property 6.1. Its proof is found in (Kaji 1992) and omitted in this paper. By Property 6.1, we obtain the following lemma. Lemma 6.1: yLd-fts Lpmcfg• LI The reverse inclusion relation Cpn,th C yEd_ft, can be shown in a similar way, and the following theorem holds. Theorem 6.2: Y --r cl-fts = Lpmcfg. LI 6.2 Nondeterministic fts&apos; In this section, the generative capacity of nondeterministic yT-fts&apos; is investigated, from the viewpoint of computational complexity. We have already shown that yLd_fis = rp,u4g, and hence every language in this class can be recognized in time polynomial of the length of an input string. Our result here is: there is</context>
</contexts>
<marker>Kaji, 1992</marker>
<rawString>Kaji, Y. et al. 1992. &amp;quot;Parallel Multiple ContextFree Grammars and Finite State Translation Systems &amp;quot;, IEICE Technical Report, COMP92-34.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Kaplan</author>
<author>J Bresnan</author>
</authors>
<title>LexicalFunctional Grammar&amp;quot;, The Mental Representation of Grammatical Relations,</title>
<date>1982</date>
<pages>173--281</pages>
<editor>J.Bresnan (ed.),</editor>
<marker>Kaplan, Bresnan, 1982</marker>
<rawString>Kaplan, R. and Bresnan, J. 1982. &amp;quot;LexicalFunctional Grammar&amp;quot;, The Mental Representation of Grammatical Relations, J.Bresnan (ed.), MIT press:173-281.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Kasami</author>
</authors>
<title>Generalized Context-Free Grammars and Multiple Context-Free Grammars&amp;quot;,</title>
<date>1988</date>
<journal>Trans. IEICE,</journal>
<volume>71</volume>
<pages>5--758</pages>
<contexts>
<context position="2605" citStr="Kasami 1988" startWordPosition="378" endWordPosition="379">ree adjoining grammars (Joshi 1975)(Vijay-Shanker 1987) were introduced to define the syntax of natural languages. On the other hand, there has been much effort to propose well-defined computational models of transformational grammars. One of these is the one to extend devices which operate on strings, such as generalized sequential machines (gsm&apos;s) to devices which operate on trees. It is fundamentally significant to clarify the generative capacities of such grammars and devices. Parallel multiple context-free grammars (pmcfg&apos;s) and multiple context-free grammars (mcfg&apos;s) were introduced in (Kasami 1988a)(Seki 1991) as natural extensions of cfg&apos;s. The subsystem of linear context-free rewriting systems (lcfrs&apos;) (VijayShanker 1987) which deals with only strings is the same formalism as mcfg&apos;s. The class of cfl&apos;s is properly included in the class of languages generated by pmcfg&apos;s, which in turn is properly included in the one generated by mcfg&apos;s. The class of languages generated by pmcfg&apos;s is properly included in that of context-sensitive languages (Kasami 1988a). Pmcfg&apos;s have been shown to be recognized in polynomial time (Kasami 1988b)(Seki 1991). A tree transducer (Rounds 1969) takes a tree </context>
<context position="7027" citStr="Kasami 1988" startWordPosition="1158" endWordPosition="1159">ult is that the generative capacity of nc-lfg&apos;s is equal to that of fts&apos;. As relations among proper subclasses of the above mentioned formalisms, it is shown that the generative capacities of dc-lfg&apos;s, deterministic fts&apos; and pmcfg&apos;s are equal to each other, and the generative capacity of fc-lfg&apos;s is equal to that of mcfg&apos;s. It is also shown that a (nondeterministic) fts generates an ATP-complete language. 2 Parallel Multiple Context-Free Grammars A parallel multiple context-free grammar (pmcfg is defined to be a 5-tuple G = (N,T,F,P,S which satisfies the following conditions (G1 through (G5) (Kasami 1988a)(Seki 1991). (G1) N is a finite set of nonterminal symbols. A positive integer d(A) is given for each nonterminal symbol A E N. (G2) T is a finite set of terminal symbols which is disjoint with N. (G3) F is a finite set of functions satisfying the following conditions. For a positive integer d, let (T*)&apos; denote the set of all the d-tuples of strings over T. For each f E F with arity a(f), positive integers r(f) and di(f) (1 _&lt; i &lt; a(f)) are given, and f is a total function from (7)d1(f) x (T*)4(1) x • • • x (T*)d-(1)(f) to (T*)r(f) which satisfies the following condition (f1). Let xi= (Xil x</context>
<context position="9141" citStr="Kasami 1988" startWordPosition="1593" endWordPosition="1594">s of (2.1) from h = 1 through r(f) is at most one. The language generated by a pmcfg G = (N,T , F, P, S) is defined as follows. For A E N, let us define LG(A) as the smallest set satisfying the following two conditions: (L1.) If a terminating production A a is in P, then a E LG(A). (L2) If A —&gt; f[Al,A2, .. • , Aa(f)] E P and at E LG(Az) _&lt; i 5 a(f)), then f[ai, a2, • • • , -6a( nf E LG(A). 131 Define L(G)LG(S). L(G) is called the parallel multiple context-free language (pmcfl) generated by G. If G is an mcfg, L(G) is called the multiple context-free language (mcfl) generated by G. Example 2.1(Kasami 1988a): Let GExi = (N, T, F, P, S), N = {S}, T = {a}, F = {fa, fl,P = {7.1 : S fa, ro S f[S]}, where ía a, a, f[(x)] = XX. GExi is a pmcfg but is not an mcfg since the function f does not satisfy Right Linearity. The language generated by GExi is {a2&apos; In &gt; OE which cannot be generated by any mcfg (see Lemma 6 of (Kasami 1988a)). The empty string is denoted by E. Example 2.2: Let GEX2 = (N, T, F, P, S) be a pmcfg, where N = {S, A}, T = {a, b}, F = {gri, x2)1I = x1x2, .faRxi, x2)] = (xi a, x2a), fb (xi, x2) = (xi b, x2b), fe = (E, 6)}, and, P= {Po S g[A], P1 A —+ MA], p2 : A f 01, p : A —&gt; M. Note t</context>
<context position="23555" citStr="Kasami 1988" startWordPosition="4620" endWordPosition="4621">e-copying fts&apos;, respectively. Let Lp,,,fg and rrhcfg be the classes of languages generated by pmcfg&apos;s and mcfg&apos;s, respectively. Also let Ltag be the class of language generated by tree adjoining grammars. Inclusion relations among these classes of languages are summarized in Figure 2. An equivalence relation *1 is shown in (Weir 1992). Relations *2 are new results which we prove in this paper. We also note that all the inclusion relations are proper; indeed, {ceila72W3&apos;cil: I n 0} E D — E {a7a&apos;22 • • ce22,7,_ia&apos;22m n &gt; 0} E C — D for m &gt; 3, (by (Vijay-Shanker 1987).) {a2n n &gt; 0} E B — C, (by (Kasami 1988a)(Seki 1991).) A relation B A is shown in (Engelfriet 1980). By Lemma 2.1, all languages in the region enclosed with the bold line are recognizable in polynomial time. On the other hand, it is shown in this paper that Unary-3SAT, which is known to be ./VP-complete (Nakanishi 1992), is in A. Hence, if P _ATP, then Unary-3SAT E A — B and the languages generated by fts&apos; (or equivalently, nclfg&apos;s) are not recognizable in polynomial time in general. 6 Generative Capacity of fts&apos; 6.1 Deterministic fts&apos; Here, the proof of an inclusion relation yrd_ft, C Lpmcfg is sketched. Let (M, G) be a determinis</context>
</contexts>
<marker>Kasami, 1988</marker>
<rawString>Kasami, T. et al. 1988a. &amp;quot;Generalized Context-Free Grammars and Multiple Context-Free Grammars&amp;quot;, Trans. IEICE, J71-D-I, 5:758-765.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Kasami</author>
</authors>
<title>On the Membership Problem for Head Language and Multiple Context-Free Languages, Trans. IEICE,</title>
<date>1988</date>
<pages>71--6</pages>
<contexts>
<context position="2605" citStr="Kasami 1988" startWordPosition="378" endWordPosition="379">ree adjoining grammars (Joshi 1975)(Vijay-Shanker 1987) were introduced to define the syntax of natural languages. On the other hand, there has been much effort to propose well-defined computational models of transformational grammars. One of these is the one to extend devices which operate on strings, such as generalized sequential machines (gsm&apos;s) to devices which operate on trees. It is fundamentally significant to clarify the generative capacities of such grammars and devices. Parallel multiple context-free grammars (pmcfg&apos;s) and multiple context-free grammars (mcfg&apos;s) were introduced in (Kasami 1988a)(Seki 1991) as natural extensions of cfg&apos;s. The subsystem of linear context-free rewriting systems (lcfrs&apos;) (VijayShanker 1987) which deals with only strings is the same formalism as mcfg&apos;s. The class of cfl&apos;s is properly included in the class of languages generated by pmcfg&apos;s, which in turn is properly included in the one generated by mcfg&apos;s. The class of languages generated by pmcfg&apos;s is properly included in that of context-sensitive languages (Kasami 1988a). Pmcfg&apos;s have been shown to be recognized in polynomial time (Kasami 1988b)(Seki 1991). A tree transducer (Rounds 1969) takes a tree </context>
<context position="7027" citStr="Kasami 1988" startWordPosition="1158" endWordPosition="1159">ult is that the generative capacity of nc-lfg&apos;s is equal to that of fts&apos;. As relations among proper subclasses of the above mentioned formalisms, it is shown that the generative capacities of dc-lfg&apos;s, deterministic fts&apos; and pmcfg&apos;s are equal to each other, and the generative capacity of fc-lfg&apos;s is equal to that of mcfg&apos;s. It is also shown that a (nondeterministic) fts generates an ATP-complete language. 2 Parallel Multiple Context-Free Grammars A parallel multiple context-free grammar (pmcfg is defined to be a 5-tuple G = (N,T,F,P,S which satisfies the following conditions (G1 through (G5) (Kasami 1988a)(Seki 1991). (G1) N is a finite set of nonterminal symbols. A positive integer d(A) is given for each nonterminal symbol A E N. (G2) T is a finite set of terminal symbols which is disjoint with N. (G3) F is a finite set of functions satisfying the following conditions. For a positive integer d, let (T*)&apos; denote the set of all the d-tuples of strings over T. For each f E F with arity a(f), positive integers r(f) and di(f) (1 _&lt; i &lt; a(f)) are given, and f is a total function from (7)d1(f) x (T*)4(1) x • • • x (T*)d-(1)(f) to (T*)r(f) which satisfies the following condition (f1). Let xi= (Xil x</context>
<context position="9141" citStr="Kasami 1988" startWordPosition="1593" endWordPosition="1594">s of (2.1) from h = 1 through r(f) is at most one. The language generated by a pmcfg G = (N,T , F, P, S) is defined as follows. For A E N, let us define LG(A) as the smallest set satisfying the following two conditions: (L1.) If a terminating production A a is in P, then a E LG(A). (L2) If A —&gt; f[Al,A2, .. • , Aa(f)] E P and at E LG(Az) _&lt; i 5 a(f)), then f[ai, a2, • • • , -6a( nf E LG(A). 131 Define L(G)LG(S). L(G) is called the parallel multiple context-free language (pmcfl) generated by G. If G is an mcfg, L(G) is called the multiple context-free language (mcfl) generated by G. Example 2.1(Kasami 1988a): Let GExi = (N, T, F, P, S), N = {S}, T = {a}, F = {fa, fl,P = {7.1 : S fa, ro S f[S]}, where ía a, a, f[(x)] = XX. GExi is a pmcfg but is not an mcfg since the function f does not satisfy Right Linearity. The language generated by GExi is {a2&apos; In &gt; OE which cannot be generated by any mcfg (see Lemma 6 of (Kasami 1988a)). The empty string is denoted by E. Example 2.2: Let GEX2 = (N, T, F, P, S) be a pmcfg, where N = {S, A}, T = {a, b}, F = {gri, x2)1I = x1x2, .faRxi, x2)] = (xi a, x2a), fb (xi, x2) = (xi b, x2b), fe = (E, 6)}, and, P= {Po S g[A], P1 A —+ MA], p2 : A f 01, p : A —&gt; M. Note t</context>
<context position="23555" citStr="Kasami 1988" startWordPosition="4620" endWordPosition="4621">e-copying fts&apos;, respectively. Let Lp,,,fg and rrhcfg be the classes of languages generated by pmcfg&apos;s and mcfg&apos;s, respectively. Also let Ltag be the class of language generated by tree adjoining grammars. Inclusion relations among these classes of languages are summarized in Figure 2. An equivalence relation *1 is shown in (Weir 1992). Relations *2 are new results which we prove in this paper. We also note that all the inclusion relations are proper; indeed, {ceila72W3&apos;cil: I n 0} E D — E {a7a&apos;22 • • ce22,7,_ia&apos;22m n &gt; 0} E C — D for m &gt; 3, (by (Vijay-Shanker 1987).) {a2n n &gt; 0} E B — C, (by (Kasami 1988a)(Seki 1991).) A relation B A is shown in (Engelfriet 1980). By Lemma 2.1, all languages in the region enclosed with the bold line are recognizable in polynomial time. On the other hand, it is shown in this paper that Unary-3SAT, which is known to be ./VP-complete (Nakanishi 1992), is in A. Hence, if P _ATP, then Unary-3SAT E A — B and the languages generated by fts&apos; (or equivalently, nclfg&apos;s) are not recognizable in polynomial time in general. 6 Generative Capacity of fts&apos; 6.1 Deterministic fts&apos; Here, the proof of an inclusion relation yrd_ft, C Lpmcfg is sketched. Let (M, G) be a determinis</context>
</contexts>
<marker>Kasami, 1988</marker>
<rawString>Kasami, T. et al. 1988b. &amp;quot;On the Membership Problem for Head Language and Multiple Context-Free Languages, Trans. IEICE, J71-D-I, 6:935-941.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Nakanishi</author>
</authors>
<title>On the Generative Capacity of Tree Translation Systems and Lexical Functional-Grammars&amp;quot;,</title>
<date>1993</date>
<journal>Technical Paper of FAI, Japanese Society for Artificial Intelligence,</journal>
<volume>9202</volume>
<contexts>
<context position="33367" citStr="Nakanishi 1993" startWordPosition="6653" endWordPosition="6654">ns of Gi is constructed as follows. (i) Let p: C Xl• • • Xh be a production in P where C E N, X2 E NUT (1 &lt; i &lt; h), and let: qi[P(xi, • • • , xh )] jail • • • qq[xv,,,,]cejL, be a rule in R where otik E A* (0 &lt; k &lt; E Q, and x,, E {x1, • • • , xh} (1 &lt; / &lt; Then, the following production belongs to P&apos;: a30 ail • • • Xv[ri&apos;LL&apos;i aiL., • {irule= p} { =0 {1atr,,,L3, =f} (ii) Let q3[al 03 be a rule in R where a E T and p; E A*. Then the production a[i] Pi belongs to P&apos;. (iii) No other production belongs to P&apos;. By TRANS 7.1 and TRANS 7.2, the following theorem is obtained. A formal proof is found in (Nakanishi 1993). Theorem 7.1: = Kfts. Corollary 7.2: Gdc_ifg = yLd_tts. Proof. In TRANS 7.1, if G is a dc-lfg, then no sp E SP contains distinct productions whose left-hand sides are the same and hence the constructed transducer M becomes deterministic by the construction. Conversely, in TRANS 7.2, if M is deterministic, then there exist no consistent productions and p&apos;2 in P&apos; whose left-hand sides are the same and hence the constructed nc-lfg is a dc-lfg. 8 Equivalence of G fc_lfg and mcfg To prove Cfc-ifg C .Cmcfg, we give an algorithm which translates a given fc-lfg G = (N, T, P, S, Nair, Aeire) into an m</context>
</contexts>
<marker>Nakanishi, 1993</marker>
<rawString>Nakanishi, R. et al. 1993. &amp;quot;On the Generative Capacity of Tree Translation Systems and Lexical Functional-Grammars&amp;quot;, Technical Paper of FAI, Japanese Society for Artificial Intelligence, SIGFAI-9202.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Nakanishi</author>
</authors>
<title>On the Generative Capacity of Lexical-Functional Grammars&amp;quot;,</title>
<date>1992</date>
<journal>IEICE Trans. Inf. and Syst.,</journal>
<volume>75</volume>
<pages>7--509</pages>
<contexts>
<context position="4465" citStr="Nakanishi 1992" startWordPosition="694" endWordPosition="695">d by finite-copying fts&apos; equals to the class of languages generated by lcfrs&apos; (Weir 1992), hence by mcfg&apos;s. In lexical-functional grammars (lfg&apos;s) (Kaplan 1982), associated with each node v of a derivation tree is a finite set F of pairs of attribute names and their values. F is called the fstructure of v. An lfg G consists of a cfg Go called the underlying cfg of G and a finite set Pf, of equations called functional schemata which specify constraints between the f-structures of nodes in a derivation tree. Functional schemata are attached to symbols in productions of Go. It has been shown in (Nakanishi 1992) that the class of languages generated by lfg&apos;s is equal to that of re130 cursively enumerable languages even though the underlying cfg&apos;s are restricted to regular grammars. In (Gazdar 1985)(Kaplan 1982)(Nishino 1991), subclasses of lfg&apos;s were proposed in order to guarantee the recursiveness (and/or the efficient recognition) of languages generated by lfg&apos;s. However, these classes were shown to generate an ArP-complete language (Nakanishi 1992). In this paper, three subclasses of lfg&apos;s called nc-lfg&apos;s, dc-lfg&apos;s and fc-lfg&apos;s are proposed, two of which can be recognized in polynomial time. Moreo</context>
<context position="14752" citStr="Nakanishi 1992" startWordPosition="2760" endWordPosition="2761">o [t] = w with copying-bound k. It is known that the determinism does not weaken the generative capacity of finite-copying fts&apos; (Engelfriet 1980). We note that an fts (M, G) can be considered to be a model of a transformational grammar: A deep-structure of a sentence is represented by a derivation tree of G, and M can be considered to transform the deep-structure into a sentence (or its surface structure). 4 Subclasses of Lexical-functional grammars A simple subclass of lfg&apos;s, called r-lfg&apos;s, is introduced in (Nishino 1992), which is shown to generate all the recursively enumerable languages (Nakanishi 1992). Here, we define a nondeterministic copying lfg (nc-lfg) as a proper subclass of r-lfg&apos;s. An nc-lfg is defined to be a 6-tuple G = (N, T, P, S, Nat, Aat,a) where: (1) N is a finite set of nonterminal symbols, (2) T is a finite set of terminal symbols, and (3) P is a finite set of annotated productions. Sometimes, a nonterminal symbol, a terminal symbol and an annotated production are abbreviated as a nonterminal, a terminal and a production, respectively. (4) S E N is the initial symbol, (5) Nat,. is a finite set of attributes, and (6) Aatm is a finite set of atoms. An equation of the form I </context>
<context position="23837" citStr="Nakanishi 1992" startWordPosition="4668" endWordPosition="4669">gure 2. An equivalence relation *1 is shown in (Weir 1992). Relations *2 are new results which we prove in this paper. We also note that all the inclusion relations are proper; indeed, {ceila72W3&apos;cil: I n 0} E D — E {a7a&apos;22 • • ce22,7,_ia&apos;22m n &gt; 0} E C — D for m &gt; 3, (by (Vijay-Shanker 1987).) {a2n n &gt; 0} E B — C, (by (Kasami 1988a)(Seki 1991).) A relation B A is shown in (Engelfriet 1980). By Lemma 2.1, all languages in the region enclosed with the bold line are recognizable in polynomial time. On the other hand, it is shown in this paper that Unary-3SAT, which is known to be ./VP-complete (Nakanishi 1992), is in A. Hence, if P _ATP, then Unary-3SAT E A — B and the languages generated by fts&apos; (or equivalently, nclfg&apos;s) are not recognizable in polynomial time in general. 6 Generative Capacity of fts&apos; 6.1 Deterministic fts&apos; Here, the proof of an inclusion relation yrd_ft, C Lpmcfg is sketched. Let (M, G) be a deterministic yT-fts where M = (Q, E, , R) and G (N,T, P, S). We assume that Q = {qi, ,qt}, T = {al, • • • an} and P = {pi, ,Pm}. Since the input for M is the set of derivation trees of G, we assume that = {Pi, ,Pm,ai,..,a} without loss of generality. We will construct a pmcfg G&apos; = (N&apos;,T&apos; , </context>
<context position="28068" citStr="Nakanishi 1992" startWordPosition="5495" endWordPosition="5496"> Cpn,th C yEd_ft, can be shown in a similar way, and the following theorem holds. Theorem 6.2: Y --r cl-fts = Lpmcfg. LI 6.2 Nondeterministic fts&apos; In this section, the generative capacity of nondeterministic yT-fts&apos; is investigated, from the viewpoint of computational complexity. We have already shown that yLd_fis = rp,u4g, and hence every language in this class can be recognized in time polynomial of the length of an input string. Our result here is: there is a nondeterministic Its that generates an ,NP-complete language. In the following, a language called Unary-3SAT, which is .VP-complete (Nakanishi 1992), is considered, and then it is shown to belong to y A Unary-3CNF is a (nonempty) 3CNF in which the subscripts of variables are represented in unary. A positive literal xi in a 3CNF is represented by lt$ in a Unary-3CNF. Similarly, a negative literal is represented by 1&apos;#. For example, a 3CNF (x1 V x2 V -a3) A (x3 V --Ix1 V -1x2) is represented by a Unary-3CNF 1$11$111# A 111$1#11#. Unary-3SAT is the set of all satisfiable Unary3CNF&apos;s. Next, we construct a nondeterministic yT-fts (M, G) that generates Unary-3SAT. Define a cfg G = (N,T, P, S) where N = {S,T, F}, T = {e} and the productions in P</context>
</contexts>
<marker>Nakanishi, 1992</marker>
<rawString>Nakanishi, R. et al. 1992. &amp;quot;On the Generative Capacity of Lexical-Functional Grammars&amp;quot;, IEICE Trans. Inf. and Syst., 75-D, 7:509-516.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Nishino</author>
</authors>
<title>Mathematical Analysis of LexicalFunctional Grammars -Complexity, Parsability, and Learnability-&amp;quot;,</title>
<date>1991</date>
<institution>Language Research Institute, Seoul National University.</institution>
<contexts>
<context position="4682" citStr="Nishino 1991" startWordPosition="728" endWordPosition="729">ite set F of pairs of attribute names and their values. F is called the fstructure of v. An lfg G consists of a cfg Go called the underlying cfg of G and a finite set Pf, of equations called functional schemata which specify constraints between the f-structures of nodes in a derivation tree. Functional schemata are attached to symbols in productions of Go. It has been shown in (Nakanishi 1992) that the class of languages generated by lfg&apos;s is equal to that of re130 cursively enumerable languages even though the underlying cfg&apos;s are restricted to regular grammars. In (Gazdar 1985)(Kaplan 1982)(Nishino 1991), subclasses of lfg&apos;s were proposed in order to guarantee the recursiveness (and/or the efficient recognition) of languages generated by lfg&apos;s. However, these classes were shown to generate an ArP-complete language (Nakanishi 1992). In this paper, three subclasses of lfg&apos;s called nc-lfg&apos;s, dc-lfg&apos;s and fc-lfg&apos;s are proposed, two of which can be recognized in polynomial time. Moreover, this paper clarifies the relations among the generative capacities of pmcfg&apos;s, fts&apos; and these subclasses of lfg&apos;s. In nc-lfg&apos;s, a functional schema either specifies the value of a specific attribute, say atr, imm</context>
</contexts>
<marker>Nishino, 1991</marker>
<rawString>Nishino, T. 1991. &amp;quot;Mathematical Analysis of LexicalFunctional Grammars -Complexity, Parsability, and Learnability-&amp;quot;, Language Research Institute, Seoul National University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Nishino</author>
</authors>
<title>Relating Attribute Grammars and Lexical-Functional Grammars&amp;quot;,</title>
<date>1992</date>
<journal>Information Sciences,</journal>
<pages>66--1</pages>
<contexts>
<context position="14666" citStr="Nishino 1992" startWordPosition="2748" endWordPosition="2749">tant k and for each w E yL(M,G), there is a derivation tree tin G and a derivation go [t] = w with copying-bound k. It is known that the determinism does not weaken the generative capacity of finite-copying fts&apos; (Engelfriet 1980). We note that an fts (M, G) can be considered to be a model of a transformational grammar: A deep-structure of a sentence is represented by a derivation tree of G, and M can be considered to transform the deep-structure into a sentence (or its surface structure). 4 Subclasses of Lexical-functional grammars A simple subclass of lfg&apos;s, called r-lfg&apos;s, is introduced in (Nishino 1992), which is shown to generate all the recursively enumerable languages (Nakanishi 1992). Here, we define a nondeterministic copying lfg (nc-lfg) as a proper subclass of r-lfg&apos;s. An nc-lfg is defined to be a 6-tuple G = (N, T, P, S, Nat, Aat,a) where: (1) N is a finite set of nonterminal symbols, (2) T is a finite set of terminal symbols, and (3) P is a finite set of annotated productions. Sometimes, a nonterminal symbol, a terminal symbol and an annotated production are abbreviated as a nonterminal, a terminal and a production, respectively. (4) S E N is the initial symbol, (5) Nat,. is a finit</context>
</contexts>
<marker>Nishino, 1992</marker>
<rawString>Nishino, T. 1992. &amp;quot;Relating Attribute Grammars and Lexical-Functional Grammars&amp;quot;, Information Sciences, 66:1-22.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J L Peterson</author>
</authors>
<title>Petri Net Theory and the Modeling of Systems&amp;quot;,</title>
<date>1981</date>
<publisher>Prentice-Hall.</publisher>
<contexts>
<context position="22669" citStr="Peterson 1981" startWordPosition="4465" endWordPosition="4466">. Tree adjoining grammars can not generate such syntax while fc-lfg&apos;s or dc-lfg&apos;s can, although the authors do not know a natural language which has such syntax so far. By Lemma 2.1 and Theorem 8.1, fc-lfg&apos;s are polynomial-time recognizable. Hence, it is desirable that whether a given lfg G is an fc-lfg or not is decidable. Fortunately, it is decidable by the following lemma. Lemma 4.1: For a given nc-lfg G, it is decidable whether the number of SPN multisets in G is finite or infinite. Proof. The problem can be reduced to the boundedness problem of Petri nets, which is known to be decidable (Peterson 1981). 5 Overview of the Results Let rn,_kfg, rdc-lfg and fc-lfg denote the classes of languages generated by nc-lfg&apos;s, dc-lfg&apos;s and fc-lfg&apos;s, respectively, and let y.C.ft,, yrd_ft, and yGfe_fts denote the classes of yield languages generated by fts&apos;, deterministic fts&apos; and finite-copying fts&apos;, respectively. Let Lp,,,fg and rrhcfg be the classes of languages generated by pmcfg&apos;s and mcfg&apos;s, respectively. Also let Ltag be the class of language generated by tree adjoining grammars. Inclusion relations among these classes of languages are summarized in Figure 2. An equivalence relation *1 is shown in </context>
</contexts>
<marker>Peterson, 1981</marker>
<rawString>Peterson, J.L. 1981. &amp;quot;Petri Net Theory and the Modeling of Systems&amp;quot;, Prentice-Hall.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C J Pollard</author>
</authors>
<title>Generalized Phrase Structure Grammars, Head Grammars and Natural Language&amp;quot;,</title>
<date>1984</date>
<institution>Stanford University.</institution>
<note>Ph.D. dissertation,</note>
<contexts>
<context position="1988" citStr="Pollard 1984" startWordPosition="285" endWordPosition="286">&apos; is equal to that of nc-lfg&apos;s. As relations among subclasses of those formalisms, it is shown that the generative capacities of deterministic fts&apos;, dc-lfg&apos;s, and pmcfg&apos;s are equal to each other, and the generative capacity of fc-lfg&apos;s is equal to that of mcfg&apos;s. It is also shown that at least one NP-complete language is generated by fts&apos;. Consequently, deterministic fts&apos;, dc-lfg&apos;s and fc-lfg&apos;s can be recognized in polynomial time. However, fts&apos; (and nc-lfg&apos;s) cannot, if P A/ P. 1 Introduction A number of grammatical formalisms such as lexical-functional grammars (Kaplan 1982), head grammars (Pollard 1984) and tree adjoining grammars (Joshi 1975)(Vijay-Shanker 1987) were introduced to define the syntax of natural languages. On the other hand, there has been much effort to propose well-defined computational models of transformational grammars. One of these is the one to extend devices which operate on strings, such as generalized sequential machines (gsm&apos;s) to devices which operate on trees. It is fundamentally significant to clarify the generative capacities of such grammars and devices. Parallel multiple context-free grammars (pmcfg&apos;s) and multiple context-free grammars (mcfg&apos;s) were introduce</context>
</contexts>
<marker>Pollard, 1984</marker>
<rawString>Pollard, C.J. 1984. &amp;quot;Generalized Phrase Structure Grammars, Head Grammars and Natural Language&amp;quot;, Ph.D. dissertation, Stanford University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W C Rounds</author>
</authors>
<title>Context-Free Grammars on Trees&amp;quot;,</title>
<date>1969</date>
<booktitle>Proc. of ACM</booktitle>
<pages>143--148</pages>
<contexts>
<context position="3191" citStr="Rounds 1969" startWordPosition="471" endWordPosition="472">introduced in (Kasami 1988a)(Seki 1991) as natural extensions of cfg&apos;s. The subsystem of linear context-free rewriting systems (lcfrs&apos;) (VijayShanker 1987) which deals with only strings is the same formalism as mcfg&apos;s. The class of cfl&apos;s is properly included in the class of languages generated by pmcfg&apos;s, which in turn is properly included in the one generated by mcfg&apos;s. The class of languages generated by pmcfg&apos;s is properly included in that of context-sensitive languages (Kasami 1988a). Pmcfg&apos;s have been shown to be recognized in polynomial time (Kasami 1988b)(Seki 1991). A tree transducer (Rounds 1969) takes a tree as an input, starts from the initial state with its head scanning the root node of an input. According to the current state and the label of the scanned node, it transforms an input tree into an output tree in a top-down way. A finite state translation system (fts) is a tree transducer with its input domain being the set of derivation trees of a cfg (Rounds 1969)(Thatcher 1967). A number of equivalence relations between the classes of yield languages generated by fts&apos; and other computational models have been established (Engelfriet 1991)(Engelfriet 1980)(Weir 1992). Especially, i</context>
<context position="11581" citStr="Rounds 1969" startWordPosition="2135" endWordPosition="2136">th ,p„,, respectively, and • ifX EN, then pi is a production X, • • •, whose left-hand side is Xi, and • if X. E T, then pi = ti = X. Then p(ti, , tn) is a derivation tree in G. (T3) There are no other derivation trees. Let &apos;TZ(G) be the set of derivation trees in G, and 7Zs(G) C &apos;R(G) be the set of derivation trees whose root is labeled with a production of which left-hand side is the initial symbol S. Clearly, &apos;R8(G) C TE(0) holds. Remark that &apos;Rs(G) is a multi-sorted algebra, where the nonterminals are sorts, and the terminals and the labels of productions are operators. A tree transducer (Rounds 1969) defines a mapping from trees to trees. Since we are mainly interested in the string language generated by a tree transducer, a &amp;quot;tree-to-string&amp;quot; version of transducer defined in (Engelfriet 1980) is used in this paper. For sets Q and X, let Q[X]={q[x] I q E Q, x E X}. A tree-to-string transducer (yT-transducer or simply transducer) is defined to be a 5-tuple M (Q, E, q0, R) where (1) Q is a finite set of states, (2) E is an input ranked alphabet, (3) A is an output alphabet, (4) qo E Q is the initial state, and (5) R is a finite set of rules of the form q[cr(xi,. ,xn)] v where q E Q, o- E E, n</context>
<context position="13033" citStr="Rounds 1969" startWordPosition="2433" endWordPosition="2434">ned as follows. Let t = tnAct2 be a configuration where c1, c2 E (A U Q[7E(0)])* , q E Q, o- E E, p(o-) = n and ,t, E TE(q5). Assume that there is a rule q[cr(xi, • • • ,x,)] v in R. Let t&apos; be obtained from v by substituting t1, , ti, for xl, , xn, respectively, then we define t zM ct1ticx2. Let =be be the reflexive and transitive closure of If t•*Al t&apos;, then we say t&apos; is derived from t. If there is no V.1 E A* such that t w, then we say no output is derived from t. A tree-to-string finite state translation system (yT-fts or fts) is defined by a yT-transducer M and a cfg G, written as (M, G) (Rounds 1969)(Thatcher 1967). We define yL(M,G), called the yield language generated by yT-fts (M, C), as y L(M , E A* I 3t E s (G) , ga[t] •*m w} where A is an output alphabet and qo is the initial state of M. An fts is called deterministic (Engelfriet 1980) if the transducer M is deterministic. LI Li 132 Engelfriet introduced a subclass of fts&apos; called finite-copying fts&apos; as follows (Engelfriet 1980): Let (M, G) be an fts with output alphabet A and initial state go, t be a derivation tree in G and t&apos; be a subtree of t. Assume that there is a derivation a : go[t] =* w. Now, delete from this derivation a al</context>
</contexts>
<marker>Rounds, 1969</marker>
<rawString>Rounds, W.C. 1969. &amp;quot;Context-Free Grammars on Trees&amp;quot;, Proc. of ACM STOC:143-148.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Seki</author>
</authors>
<title>On Multiple ContextFree Grammars&amp;quot;,</title>
<date>1991</date>
<journal>Theoretical Computer Science,</journal>
<volume>88</volume>
<pages>2--191</pages>
<contexts>
<context position="2618" citStr="Seki 1991" startWordPosition="379" endWordPosition="380">grammars (Joshi 1975)(Vijay-Shanker 1987) were introduced to define the syntax of natural languages. On the other hand, there has been much effort to propose well-defined computational models of transformational grammars. One of these is the one to extend devices which operate on strings, such as generalized sequential machines (gsm&apos;s) to devices which operate on trees. It is fundamentally significant to clarify the generative capacities of such grammars and devices. Parallel multiple context-free grammars (pmcfg&apos;s) and multiple context-free grammars (mcfg&apos;s) were introduced in (Kasami 1988a)(Seki 1991) as natural extensions of cfg&apos;s. The subsystem of linear context-free rewriting systems (lcfrs&apos;) (VijayShanker 1987) which deals with only strings is the same formalism as mcfg&apos;s. The class of cfl&apos;s is properly included in the class of languages generated by pmcfg&apos;s, which in turn is properly included in the one generated by mcfg&apos;s. The class of languages generated by pmcfg&apos;s is properly included in that of context-sensitive languages (Kasami 1988a). Pmcfg&apos;s have been shown to be recognized in polynomial time (Kasami 1988b)(Seki 1991). A tree transducer (Rounds 1969) takes a tree as an input, </context>
<context position="7040" citStr="Seki 1991" startWordPosition="1159" endWordPosition="1160">e generative capacity of nc-lfg&apos;s is equal to that of fts&apos;. As relations among proper subclasses of the above mentioned formalisms, it is shown that the generative capacities of dc-lfg&apos;s, deterministic fts&apos; and pmcfg&apos;s are equal to each other, and the generative capacity of fc-lfg&apos;s is equal to that of mcfg&apos;s. It is also shown that a (nondeterministic) fts generates an ATP-complete language. 2 Parallel Multiple Context-Free Grammars A parallel multiple context-free grammar (pmcfg is defined to be a 5-tuple G = (N,T,F,P,S which satisfies the following conditions (G1 through (G5) (Kasami 1988a)(Seki 1991). (G1) N is a finite set of nonterminal symbols. A positive integer d(A) is given for each nonterminal symbol A E N. (G2) T is a finite set of terminal symbols which is disjoint with N. (G3) F is a finite set of functions satisfying the following conditions. For a positive integer d, let (T*)&apos; denote the set of all the d-tuples of strings over T. For each f E F with arity a(f), positive integers r(f) and di(f) (1 _&lt; i &lt; a(f)) are given, and f is a total function from (7)d1(f) x (T*)4(1) x • • • x (T*)d-(1)(f) to (T*)r(f) which satisfies the following condition (f1). Let xi= (Xil x22) • • • )Xi</context>
<context position="9830" citStr="Seki 1991" startWordPosition="1759" endWordPosition="1760">ro S f[S]}, where ía a, a, f[(x)] = XX. GExi is a pmcfg but is not an mcfg since the function f does not satisfy Right Linearity. The language generated by GExi is {a2&apos; In &gt; OE which cannot be generated by any mcfg (see Lemma 6 of (Kasami 1988a)). The empty string is denoted by E. Example 2.2: Let GEX2 = (N, T, F, P, S) be a pmcfg, where N = {S, A}, T = {a, b}, F = {gri, x2)1I = x1x2, .faRxi, x2)] = (xi a, x2a), fb (xi, x2) = (xi b, x2b), fe = (E, 6)}, and, P= {Po S g[A], P1 A —+ MA], p2 : A f 01, p : A —&gt; M. Note that GEx2 is an mcfg. L (G E x2) = {ww I w E fa,b1*}. 0 Lemma 2.1(Kasami 1988b)(Seki 1991): Let G be a pmcfg. For a given string w, it is decidable whether w E L (G) or not in time polynomial of lw I, where HI denotes the length of W. 3 Finite State Translation Systems A set E of symbols is a ranked alphabet if, for each a E E, a unique non-negative number p(o) is associated. p(o) is the rank of cr. For a set X, we define free algebra TE (X) as the smallest set such that; • TE(X) includes X. • If p(o) = 0 for o- E E, then o- E TE(X). • If p(o) = n (&gt; 1) for a E E and t1,. • • tit E TE(X), then t , tn) E TE(X). cr is called the root symbol, or shortly, the root of t. Hereafter, a te</context>
<context position="23568" citStr="Seki 1991" startWordPosition="4621" endWordPosition="4622">, respectively. Let Lp,,,fg and rrhcfg be the classes of languages generated by pmcfg&apos;s and mcfg&apos;s, respectively. Also let Ltag be the class of language generated by tree adjoining grammars. Inclusion relations among these classes of languages are summarized in Figure 2. An equivalence relation *1 is shown in (Weir 1992). Relations *2 are new results which we prove in this paper. We also note that all the inclusion relations are proper; indeed, {ceila72W3&apos;cil: I n 0} E D — E {a7a&apos;22 • • ce22,7,_ia&apos;22m n &gt; 0} E C — D for m &gt; 3, (by (Vijay-Shanker 1987).) {a2n n &gt; 0} E B — C, (by (Kasami 1988a)(Seki 1991).) A relation B A is shown in (Engelfriet 1980). By Lemma 2.1, all languages in the region enclosed with the bold line are recognizable in polynomial time. On the other hand, it is shown in this paper that Unary-3SAT, which is known to be ./VP-complete (Nakanishi 1992), is in A. Hence, if P _ATP, then Unary-3SAT E A — B and the languages generated by fts&apos; (or equivalently, nclfg&apos;s) are not recognizable in polynomial time in general. 6 Generative Capacity of fts&apos; 6.1 Deterministic fts&apos; Here, the proof of an inclusion relation yrd_ft, C Lpmcfg is sketched. Let (M, G) be a deterministic yT-fts wh</context>
</contexts>
<marker>Seki, 1991</marker>
<rawString>Seki, H. et al. 1991. &amp;quot;On Multiple ContextFree Grammars&amp;quot;, Theoretical Computer Science, 88, 2:191-229.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J W Thatcher</author>
</authors>
<title>Characterizing Derivation Trees of Context-Free Grammars through a Generalarization of Finite Automata Theory&amp;quot;.</title>
<date>1967</date>
<journal>J. Comput. Rz Syst. Sci.,</journal>
<pages>1--317</pages>
<contexts>
<context position="3585" citStr="Thatcher 1967" startWordPosition="544" endWordPosition="545">ages generated by pmcfg&apos;s is properly included in that of context-sensitive languages (Kasami 1988a). Pmcfg&apos;s have been shown to be recognized in polynomial time (Kasami 1988b)(Seki 1991). A tree transducer (Rounds 1969) takes a tree as an input, starts from the initial state with its head scanning the root node of an input. According to the current state and the label of the scanned node, it transforms an input tree into an output tree in a top-down way. A finite state translation system (fts) is a tree transducer with its input domain being the set of derivation trees of a cfg (Rounds 1969)(Thatcher 1967). A number of equivalence relations between the classes of yield languages generated by fts&apos; and other computational models have been established (Engelfriet 1991)(Engelfriet 1980)(Weir 1992). Especially, it has been shown that the class of yield languages generated by finite-copying fts&apos; equals to the class of languages generated by lcfrs&apos; (Weir 1992), hence by mcfg&apos;s. In lexical-functional grammars (lfg&apos;s) (Kaplan 1982), associated with each node v of a derivation tree is a finite set F of pairs of attribute names and their values. F is called the fstructure of v. An lfg G consists of a cfg </context>
<context position="13048" citStr="Thatcher 1967" startWordPosition="2434" endWordPosition="2435">s. Let t = tnAct2 be a configuration where c1, c2 E (A U Q[7E(0)])* , q E Q, o- E E, p(o-) = n and ,t, E TE(q5). Assume that there is a rule q[cr(xi, • • • ,x,)] v in R. Let t&apos; be obtained from v by substituting t1, , ti, for xl, , xn, respectively, then we define t zM ct1ticx2. Let =be be the reflexive and transitive closure of If t•*Al t&apos;, then we say t&apos; is derived from t. If there is no V.1 E A* such that t w, then we say no output is derived from t. A tree-to-string finite state translation system (yT-fts or fts) is defined by a yT-transducer M and a cfg G, written as (M, G) (Rounds 1969)(Thatcher 1967). We define yL(M,G), called the yield language generated by yT-fts (M, C), as y L(M , E A* I 3t E s (G) , ga[t] •*m w} where A is an output alphabet and qo is the initial state of M. An fts is called deterministic (Engelfriet 1980) if the transducer M is deterministic. LI Li 132 Engelfriet introduced a subclass of fts&apos; called finite-copying fts&apos; as follows (Engelfriet 1980): Let (M, G) be an fts with output alphabet A and initial state go, t be a derivation tree in G and t&apos; be a subtree of t. Assume that there is a derivation a : go[t] =* w. Now, delete from this derivation a all the derivatio</context>
</contexts>
<marker>Thatcher, 1967</marker>
<rawString>Thatcher, J.W. 1967. &amp;quot;Characterizing Derivation Trees of Context-Free Grammars through a Generalarization of Finite Automata Theory&amp;quot;. J. Comput. Rz Syst. Sci., 1:317-322.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shanker</author>
</authors>
<title>A Study of Tree Adjoining Grammars&amp;quot;,</title>
<date>1987</date>
<tech>Ph.D. thesis,</tech>
<institution>University of Pennsylvania.</institution>
<contexts>
<context position="2049" citStr="Vijay-Shanker 1987" startWordPosition="292" endWordPosition="293">lasses of those formalisms, it is shown that the generative capacities of deterministic fts&apos;, dc-lfg&apos;s, and pmcfg&apos;s are equal to each other, and the generative capacity of fc-lfg&apos;s is equal to that of mcfg&apos;s. It is also shown that at least one NP-complete language is generated by fts&apos;. Consequently, deterministic fts&apos;, dc-lfg&apos;s and fc-lfg&apos;s can be recognized in polynomial time. However, fts&apos; (and nc-lfg&apos;s) cannot, if P A/ P. 1 Introduction A number of grammatical formalisms such as lexical-functional grammars (Kaplan 1982), head grammars (Pollard 1984) and tree adjoining grammars (Joshi 1975)(Vijay-Shanker 1987) were introduced to define the syntax of natural languages. On the other hand, there has been much effort to propose well-defined computational models of transformational grammars. One of these is the one to extend devices which operate on strings, such as generalized sequential machines (gsm&apos;s) to devices which operate on trees. It is fundamentally significant to clarify the generative capacities of such grammars and devices. Parallel multiple context-free grammars (pmcfg&apos;s) and multiple context-free grammars (mcfg&apos;s) were introduced in (Kasami 1988a)(Seki 1991) as natural extensions of cfg&apos;s</context>
<context position="23515" citStr="Vijay-Shanker 1987" startWordPosition="4609" endWordPosition="4610"> generated by fts&apos;, deterministic fts&apos; and finite-copying fts&apos;, respectively. Let Lp,,,fg and rrhcfg be the classes of languages generated by pmcfg&apos;s and mcfg&apos;s, respectively. Also let Ltag be the class of language generated by tree adjoining grammars. Inclusion relations among these classes of languages are summarized in Figure 2. An equivalence relation *1 is shown in (Weir 1992). Relations *2 are new results which we prove in this paper. We also note that all the inclusion relations are proper; indeed, {ceila72W3&apos;cil: I n 0} E D — E {a7a&apos;22 • • ce22,7,_ia&apos;22m n &gt; 0} E C — D for m &gt; 3, (by (Vijay-Shanker 1987).) {a2n n &gt; 0} E B — C, (by (Kasami 1988a)(Seki 1991).) A relation B A is shown in (Engelfriet 1980). By Lemma 2.1, all languages in the region enclosed with the bold line are recognizable in polynomial time. On the other hand, it is shown in this paper that Unary-3SAT, which is known to be ./VP-complete (Nakanishi 1992), is in A. Hence, if P _ATP, then Unary-3SAT E A — B and the languages generated by fts&apos; (or equivalently, nclfg&apos;s) are not recognizable in polynomial time in general. 6 Generative Capacity of fts&apos; 6.1 Deterministic fts&apos; Here, the proof of an inclusion relation yrd_ft, C Lpmcfg</context>
</contexts>
<marker>Vijay-Shanker, 1987</marker>
<rawString>Vijay-Shanker, K. 1987. &amp;quot;A Study of Tree Adjoining Grammars&amp;quot;, Ph.D. thesis, University of Pennsylvania.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shanker</author>
<author>D J Weir</author>
<author>A K Joshi</author>
</authors>
<title>Characterizing structural descriptions produced by various grammatical formalisms&amp;quot;,</title>
<date>1987</date>
<booktitle>Proc. of 25th meeting of Assoc. Comput.</booktitle>
<pages>104--111</pages>
<marker>Vijay-Shanker, Weir, Joshi, 1987</marker>
<rawString>Vijay-Shanker, K., Weir, D.J. and Joshi, A.K. 1987. &amp;quot;Characterizing structural descriptions produced by various grammatical formalisms&amp;quot;, Proc. of 25th meeting of Assoc. Comput. Ling.:104-111.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D J Weir</author>
</authors>
<title>Characterizing Mildly ContextSensitive Grammar Formalisms&amp;quot;,</title>
<date>1988</date>
<tech>Ph.D. thesis,</tech>
<institution>University of Pennsylvania.</institution>
<marker>Weir, 1988</marker>
<rawString>Weir, D.J. 1988. &amp;quot;Characterizing Mildly ContextSensitive Grammar Formalisms&amp;quot;, Ph.D. thesis, University of Pennsylvania.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D J Weir</author>
</authors>
<title>Linear Context-Free Rewriting Systems and Deterministic Tree-Walking Transducers&amp;quot;,</title>
<date>1992</date>
<booktitle>Proc. of 30th meeting of Assoc. Comput. Ling.</booktitle>
<contexts>
<context position="3776" citStr="Weir 1992" startWordPosition="571" endWordPosition="572"> transducer (Rounds 1969) takes a tree as an input, starts from the initial state with its head scanning the root node of an input. According to the current state and the label of the scanned node, it transforms an input tree into an output tree in a top-down way. A finite state translation system (fts) is a tree transducer with its input domain being the set of derivation trees of a cfg (Rounds 1969)(Thatcher 1967). A number of equivalence relations between the classes of yield languages generated by fts&apos; and other computational models have been established (Engelfriet 1991)(Engelfriet 1980)(Weir 1992). Especially, it has been shown that the class of yield languages generated by finite-copying fts&apos; equals to the class of languages generated by lcfrs&apos; (Weir 1992), hence by mcfg&apos;s. In lexical-functional grammars (lfg&apos;s) (Kaplan 1982), associated with each node v of a derivation tree is a finite set F of pairs of attribute names and their values. F is called the fstructure of v. An lfg G consists of a cfg Go called the underlying cfg of G and a finite set Pf, of equations called functional schemata which specify constraints between the f-structures of nodes in a derivation tree. Functional sch</context>
<context position="23280" citStr="Weir 1992" startWordPosition="4559" endWordPosition="4560"> 5 Overview of the Results Let rn,_kfg, rdc-lfg and fc-lfg denote the classes of languages generated by nc-lfg&apos;s, dc-lfg&apos;s and fc-lfg&apos;s, respectively, and let y.C.ft,, yrd_ft, and yGfe_fts denote the classes of yield languages generated by fts&apos;, deterministic fts&apos; and finite-copying fts&apos;, respectively. Let Lp,,,fg and rrhcfg be the classes of languages generated by pmcfg&apos;s and mcfg&apos;s, respectively. Also let Ltag be the class of language generated by tree adjoining grammars. Inclusion relations among these classes of languages are summarized in Figure 2. An equivalence relation *1 is shown in (Weir 1992). Relations *2 are new results which we prove in this paper. We also note that all the inclusion relations are proper; indeed, {ceila72W3&apos;cil: I n 0} E D — E {a7a&apos;22 • • ce22,7,_ia&apos;22m n &gt; 0} E C — D for m &gt; 3, (by (Vijay-Shanker 1987).) {a2n n &gt; 0} E B — C, (by (Kasami 1988a)(Seki 1991).) A relation B A is shown in (Engelfriet 1980). By Lemma 2.1, all languages in the region enclosed with the bold line are recognizable in polynomial time. On the other hand, it is shown in this paper that Unary-3SAT, which is known to be ./VP-complete (Nakanishi 1992), is in A. Hence, if P _ATP, then Unary-3SA</context>
</contexts>
<marker>Weir, 1992</marker>
<rawString>Weir, D.J. 1992. &amp;quot;Linear Context-Free Rewriting Systems and Deterministic Tree-Walking Transducers&amp;quot;, Proc. of 30th meeting of Assoc. Comput. Ling.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>