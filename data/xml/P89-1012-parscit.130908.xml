<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<note confidence="0.6459492">
DICTIONARIES, DICTIONARY GRAMMARS AND DICTIONARY ENTRY PARSING
Mary S. Neff
IBM T. J. Watson Research Center, P. 0. Box 704, Yorktown Heights, New York 10598
Branimir K. Boguraev
IBM T. J. Watson Research Center, P. 0. Box 704, Yorktown Heights, New York 10598;
</note>
<affiliation confidence="0.808755">
Computer Laboratory, University of Cambridge, New Museums Site, Cambridge CB2 3QG
</affiliation>
<bodyText confidence="0.947890555555555">
Computerist: ... But, great Scott, what about structure? You can&apos;t just bang that lot into a machine
without structure. Half a gigabyte of sequential file ...
Lexicographer: Oh, we know all about structure. Take this entry for example. You see here italics
as the typical ambiguous structural element marker, being apparently used as an undefined
phrase-entry lemma, but in fact being the subordinate entry headword address preceding the
small-cap cross-reference headword address which is nested within the gloss to a defined phrase
entry, itself nested within a subordinate (bold lower-case letter) sense section in the second branch
of a forked multiple part of speech main entry. Now that&apos;s typical of the kind of structural re-
lationship that must be made crystal-clear in the eventual database.
</bodyText>
<title confidence="0.427477">
from &amp;quot;Taking the Words out of His Mouth&amp;quot; —
</title>
<author confidence="0.775752">
Edmund Weiner on computerising the Oxford English Dictionary
</author>
<affiliation confidence="0.769145">
(The Guardian, London, March, 1985)
</affiliation>
<sectionHeader confidence="0.901637" genericHeader="abstract">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.999943913043478">
We identify two complementary processes in the
conversion of machine-readable dictionaries into
lexical databases: recovery of the dictionary
structure from the typographical markings which
persist on the dictionary distribution tapes and
embody the publishers&apos; notational conventions;
followed by making explicit all of the codified and
ellided information packed into individual entries.
We discuss notational conventions and tape for-
mats, outline structural properties of dictionaries,
observe a range of representational phenomena
particularly relevant to dictionary parsing, and
derive a set of minimal requirements for a dic-
tionary grammar formalism. We present a gen-
eral purpose dictionary entry parser which uses a
formal notation designed to describe the structure
of entries and performs a mapping from the flat
character stream on the tape to a highly struc-
tured and fully instantiated representation of the
dictionary. We demonstrate the power of the
formalism by drawing examples from a range of
dictionary sources which have been processed and
converted into lexical databases.
</bodyText>
<sectionHeader confidence="0.98923" genericHeader="method">
I. INTRODUCTION
</sectionHeader>
<bodyText confidence="0.999371538461538">
Machine-readable dictionaries (MR D&apos;s) are typi-
cally available in the form of publishers&apos;
typesetting tapes, and consequently are repres-
ented by a flat character stream where lexical data
proper is heavily interspersed with special (con-
trol) characters. These map to the font changes
and other notational conventions used in the
printed form of the dictionary and designed to
pack, and present in a codified compact visual
format, as much lexical data as possible.
To make maximal use of MRD&apos;s, it is necessary
to make their data, as well as structure, fully ex-
plicit, in a data base format that lends itself to
flexible querying. However, since none of the
lexical data base (LDB) creation efforts to date
fully addresses both of these issues, they fail to
offer a general framework for processing the wide
range of dictionary resources available in
machine-readable form. As one extreme, the
conversion of an MRD into an LDB may be
carried out by a `one-off program — such as, for
example, used for the Longman Dictionary of
Contemporary English (LDOCE) and described
in Boguraev and Briscoe, 1989. While the re-
sulting LDB is quite explicit and complete with
respect to the data in the source, all knowledge
of the dictionary structure is embodied in the
conversion program. On the other hand, more
modular architectures consisting of a parser and
a grammar — best exemplified by Kazrnan&apos;s
(1986) analysis of the Oxford English Dictionary
(OED) — do not deliver the structurally rich and
explicit LDB ideally required for easy and un-
constrained access to the source data.
The majority of computational lexicography
projects, in fact, fall in the first of the categories
above, in that they typically concentrate on the
conversion of a single dictionary into an LDB:
examples here include the work by e.g. Ahlswede
et at., 1986, on The Webster&apos;s Seventh New
Collegiate Dictionary; Fox et at., 1988, on The
Collins English Dictionary; Calzolari and Picchi,
1988, on II Nuovo Dizionario Italiano Garzanti;
van der Steen, 1982, and Nakamura, 1988, on
LDOCE. Even work based on multiple diction-
aries (e.g. in bilingual context: see Calzolari and
Picchi, 1986) appear to have used specialized
programs for each dictionary source. In addition,
not an uncommon property of the LDB&apos;s cited
above is their incompleteness with respect to the
ongmal source: there is a tendency to extract, in
a pre-processing phase, only some fragments (e.g.
</bodyText>
<page confidence="0.770385">
9 1
</page>
<bodyText confidence="0.999259097560976">
part of speech information or definition fields)
while ignoring others (e.g. etymology, pronun-
ciation or usage notes).
We have built a Dictionary Entry Parser (DEP)
together with grammars for several different dic-
tionaries. Our goal has been to create a general
mechanism for converting to a common LDB
format a wide range of MRD&apos;s demonstrating a
wide range of phenomena. In contrast to the
OED project, where the data in the dictionary is
only tagged to indicate its structural character-
istics, we identify two processes which are crucial
for the &apos;unfolding&apos;, or making explicit, the struc-
ture of an MRD: identification of the structural
markers, followed by their interpretation in con-
text resulting in detailed parse trees for individual
entries. Furthermore, unlike the tagging of the
OED, carried out in several passes over the data
and using different grammars (in order to cope
with the highly complex, idiosyncratic and am-
biguous nature of dictionary entries), we employ
a parsing engine exploiting unification and back-
tracking, and using a single grammar consisting
of three different sets of rules. The advantages
of handling the structural complexities of MRD
sources and deriving corresponding LDB&apos;s in one
operation become clear below.
While DEP has been described in general terms
before (Byrd et al., 1987; Neff et aL, 1988), this
paper draws on our experience in parsing the
Collins German-English I Collins English-German
(CGE/CEG) and LDOCE dictionaries, which
represent two very different types of machine-
readable sources vis-a-vis format of the
typesetting tapes and notational conventions ex-
ploited by the lexicographers. We examine more
closely some of the phenomena encountered in
these dictionaries, trace their implications for
MRD-to-LDB parsing, show how they motivate
the design of the DEP grammar formalism, and
discuss treatment of typical entry configurations.
</bodyText>
<sectionHeader confidence="0.986388" genericHeader="method">
2. STRUCTURAL PROPERTIES OF IVIRD&apos;S
</sectionHeader>
<bodyText confidence="0.990437615384616">
The structure of dictionary entries is mostly im-
plicit in the font codes and other special charac-
ters controlling the layout of an entry on the
printed page; furthermore, data is typically com-
pacted to save space in print, and it is common
for different fields within an entry to employ rad-
ically different compaction schemes and
abbreviatory devices. For example, the notation
T5a,b,3 stands for the LDOCE grammar codes
T5a;T5b:T3 (Boguraey and Briscoe, 1989, pres-
ent a detailed description of the grammar coding
system in this dictionary), and many adverbs are
stored as run-ons of the adjectives, using the
abbreviatory convention —ly (the same conven-
tion applies to certain types of affixation in gen-
eral: -,er, —less, —ness, etc.). In CGE, German
compounds with a common first element appear
grouped together under it:
Kinder-: m children&apos;s choir; ~dor&apos; &apos;if children&apos;s
village; --ehe f child marriage.
Dictionaries often factor out common substrings
in data fields as in the following LDOCE and
CEG entries:
in.cu.ba.tor ... a machine for a keeping e,7,.:s warm until
they HATCH b keeping alive babies that are too small
to live and breathe in ordinary air
</bodyText>
<figureCaption confidence="0.913331">
Figure I. Definition-initial common fragment
</figureCaption>
<bodyText confidence="0.77354825">
Bankrott m -(e)s, -e bankruptcy; (fig) breakdown,
collapse; (moralisch ) bankruptcy. — machen to
become or go bankrupt; den — anmelden or ansagen or
erklaren to declare oneself bankrupt.
</bodyText>
<figureCaption confidence="0.99895">
Figure 2. Definition-final common fragment
</figureCaption>
<bodyText confidence="0.999955469387755">
Furthermore, a variety of conventions exists for
making text fragments perform more than one
function (the capitalization of &amp;quot;HATCH&amp;quot; above.
for instance, signals a close conceptual link with
the word being defined). Data of this sort is not
very useful to an LDB user without explicit ex-
pansion and recovery of compacted headwords
and fragments of entries. Parsing a dictionary to
create an LDB that can be easily queried by a
user or a program therefore implies not only fag-
ging the data in the entry, but also recovering
elided information, both in form and content.
There are two broad types of machine-readable
source, each requiring a different strategy for re-
covery of implicit structure and content of dic-
tionary entries. On the one hand tapes may
consist of a character stream with no explicit
structure markings (as OED and the Collins bi-
linguals exemplify); all of their structure is implied
in the font changes and the overall syntax of the
entry. On the other hand, sources may employ
mixed representation, incorporating both global
record delimiters and local structure encoded in
font change codes and/or special character se-
quences (LDOCE and Webster&apos;s Seventh).
Ideally, all MRD&apos;s should be mapped onto LDB
structures of the same type, accessible with a sin-
gle query language that preserves the user&apos;s intui-
tion about the structure of lexical data (Neff et
al., 1988; Tompa, 1986). Dictionary entries can
be naturally represented as shallow hierarchies
with a variable number of instances of certain
items at each level, e.g. multiple homographs
within an entry or multiple senses within a
homograph. The usual inheritance mechanisms
associated with a hierarchical organisation of data
not only ensure compactness of representation,
but also fit lexical intuitions. The figures overleaf
show sample entries from CGE and LDOCE and
their LDB forms with explicitly &apos;unfolded&apos; struc-
ture.
Within the taxonomy of normal forms (NF) de-
fined by relational data base theory, dictionary
entries are `urmormalized relations&apos; in which at-
tributes can contain other relations, rather than
simple scalar values; LDB&apos;s, therefore, cannot be
correctly viewed as relational data bases (see Neff
et al., 1988). Other kinds of hierarchically struc-
tured data similarly fall outside of the relational
</bodyText>
<page confidence="0.962617">
92
</page>
<figure confidence="0.9629166">
title [...] n (a) Titel m (also Sport); (of chapter)
Uberschrift f, (Film) Untertitel m; (form of address)
Anrede f. what -- do you give a bishop? wie redet or
spricht man einen Bischof an? (b) (Jur) (right)
(Rechts)anspruch (to auf + acc), Titel (spec) m;
(document) Eigentumsurkundef.
entry
+-hckv: title
+-superhoto
+:gor:Inunc:
+-pos: n
+-sans
+-sensnum: a
+-tran_group
+-tran
+-word: Titel
4-gender: m
4-doom in: also Sport
-tran_group
+-usage_note: of chapter
+-tran
+-word: Oberschrift
+-gender: I
-tran_group
+-domain: Film
+-tran
+-word: Untertitel
+-gender: m
+-tran_group
I .0. -usage_note: form of address
+-tran
1 +-word: Anrede
I+-gender: f
f-collocat
+-source: what - do you give a bishop?
+-targ
+-target
+-phrase: wie redet /or/ spricht
man omen Bischof an?
+-sons
+-sensnum: b
+-domain: Jur
+-tran_group
+-usage_note: right
+-tran
+-word: Rochtsanspruch
+-word: Anspnmh
+-complement
1 +-engcomp: to
+-garcomp: auf + acc
+-gender: m
-tran
+-word: Titel
+-style: spec
+-gender: m
+-tran_group
+-usage_note: document
+-t ran
+-word: Eigentumsurkunde
+-gender: f
</figure>
<figureCaption confidence="0.999722">
Figure 3. LDB for a CEG entry
</figureCaption>
<bodyText confidence="0.909026923076923">
NF mould; indeed recently there have been ef-
forts to design a generalized data model which
treats flat relations, lists, and hierarchical struc-
tures uniformly (Dadam et aL, 1986). Our LDB
format and Lexical Query Language (LQL) sup-
port the hierarchical model for dictionary data;
the output of the parser, similar to the examples
in Figure 3 and Figure 4, is compacted, encoded,
and loaded into an LDB.
nui-sance tnjumans II n 1 a person or animal that
annoys or causes trouble, PEST: Don&apos;t make a
nuisance of yourself: sit down and be quiet! 2 an action
or state of affairs which causes trouble, offence, or
</bodyText>
<figure confidence="0.981926611111111">
unpleasantness: at a nuisance! I&apos;ve forgotten my
ticket 3 Commit no nuisance (as a notice in a public
place) Do not use this place as a a lavatory b a TIP4
+-hdwehrese: Commit no nuisance
+-qua if ier: as a notice in a public place
+-sub_defn
1 +-seq_no: a
1 +-defn
1 +-def_string: Do not use this place
as a lavatory
+-sub_defn
+-seq_no:
+-defn
+-implici t_xrf
1 +-to: tip
1 +-hem no: 4
+-def_siring: Do not use this place
as a tip
</figure>
<figureCaption confidence="0.998581">
Figure 4. LDB for an LDOCE entry
</figureCaption>
<sectionHeader confidence="0.989881" genericHeader="method">
3. DEP GRAMMAR FORMALISM
</sectionHeader>
<bodyText confidence="0.999946266666667">
The choice of the hierarchical model for the rep-
resentation of the LDB entries (and thus the
output of DEP) has consequences for the parsing
mechanism. For us, parsing involves determining
the structure of all the data, retrieving implicit
information to make it explicit, reconstructing
elided information, and filling _a (recursive) tem-
plate, without any data loss. This contrasts with
a strategy that fills slots in predefined (and finite)
sets of records for a relational system, often dis-
carding information that does not fit.
In order to meet these needs, the formalism for
dictionary entry grammars must meet at least
three criteria, m addition to being simply a nota-
tional device capable of describing any particular
</bodyText>
<figure confidence="0.99831609375">
entry
nuisance
+-superhom
+-print_form: nuisance
+-pronunc
1 +-primary
1 +-pron_string: &apos;nju:sEns
+-synca t : n
+-sense_def
+-sense no: I
+-defn
1 +-implicit_xrf
1 1 +-to: pest
+-daf_string: a person or animal that
annoys or causes trouble;
pest
+-example
+-ex_string: Don&apos;t make a nuisance of
yourself: sit down and
be quiet/
-sense_def
+-sense no: 2
+-defn
1 +-def_string: an action or state of affairs
which causes trouble, offence,
or unpleasantness
+-example
+-ex_string: What a nuisance!
I&apos;ve forgotten my ticket
-sense_def
+-sense no: 3
+-defn
</figure>
<page confidence="0.993131">
93
</page>
<bodyText confidence="0.996889">
dictionary format. Below we outline the basic
requirements for such a formalism.
</bodyText>
<subsectionHeader confidence="0.905961">
3.1 Effects of context
</subsectionHeader>
<bodyText confidence="0.999995317073171">
The grammar formalism should be capable of
handling &apos;mildly context sensitive&apos; input streams,
as structurally identical items may have widely
differing functions depending on both local and
fglobal contexts. For example, parts of speech,
ield labels, ,paraphrases of cultural items, and
many other dictionary fragments all appear in the
CEG in italics, but their context defines their
identity and, consequently, their interpretation.
Thus, in the example entry in Figure 3 above,
m, (also Sport), (of- chapter), and (spec) acquire
the very different labels of pos, domain,
usage_note, and style. In addition, to distin-
guish between domain labels, style labels, dialect
labels, and usage notes, the rules must be able to
test candidate elements against a closed set of
items. Situations like this, involving subsidiary
application of auxiliary procedures (e.g. string
matching, or dictionary lookup required for an
example below), require that the rules be allowed
to selectively invoke external functions.
The assignment of labels discussed above is based
on what we will refer to in the rest of this paper
as global context. In procedural terms, this is
defined as the expectations of a particular gram-
mar fragment, reflected in the names of the asso-
ciated rules, which will be activated on a given
path through the grammar. Global context is a
dynamic notion, best thought of as a &apos;snapshot&apos;
of the state of the parser at any point of process-
ing an entry. In contrast, local context is defined
by finite-length patterns of input tokens, and has
the effect of identifyingtypographic &apos;clues&apos; to the
structure of an entry. Finally, immediate context
reflects very local character patterns which tend
to drive the initial segmentation of the &apos;raw&apos; tape
character stream and its fragmentation into
structure- and information-carrying tokens.
These three notions underlie our approach to
structural analysis of dictionaries and are funda-
mental to the grammar formalism design.
</bodyText>
<subsectionHeader confidence="0.999973">
3.2 Structure manipulation
</subsectionHeader>
<bodyText confidence="0.981927125">
The formalism should allow operations on the
(partial) structures delivered during parsing, and
not as separate tree transformations once proc-
essing is complete. This is needed, for instance,
in order to handle a variety of scoping phenom-
ena (discussed in section 5 below), factor out
items common to more than one fragment within
the same entry, and duplicate (sub-)trees as com-
plete LDB representations are being fleshed out.
Consider the CEG entry for &amp;quot;abutment&amp;quot;:
Iabutment [...] n (Archit) FlOgel- or Wangenmauer f.
Here, as well as in &amp;quot;title&amp;quot; (Figure 3), a copy of
the gender marker common to both translations
needs to migrate back to the first ti-an. In addi-
tion, a copy of the common second compound
element -mauer also needs to migrate (note that
</bodyText>
<figure confidence="0.954324769230769">
entry
+-hchot: abutment
+-superheat
+-pronunc:
&amp;quot;n°111+-pos: n
+-domain: Archit
+-tran_groty
4-ti-an
do
rd: Flugelmauer
I +-gender: f
41 -word: o rd: wangenmauer
+-gender: I
</figure>
<bodyText confidence="0.9999364">
identifying this needs a separate noun compound
parser augmented with dictionary lookup).
An example of structure duplication is illustrated
by our treatment of (implicit) cross-references in
LDOCE, where a link between two closely re-
lated words is indicated by having one of them
typeset in small capitals embedded in a definition
of the other (e.g. &apos;PEST&amp;quot; and &amp;quot;TIP&amp;quot; in the defi-
nitions of &amp;quot;nuisance&amp;quot; in Figure 4). The dual
purpose such words serve requires them to appear
on at least two different nodes in the final LDB
structure: def_string and implicit_xrf. In or-
der to perform the required transformations, the
grammar formalism must provide an explicit
handle on partial structures, as they are being
built by the parser, together with operations
which can manipulate them — both in terms of
structure decomposition and node migration.
In general, the formalism must be able to deal
with, discontinuous constituents, a problem not
dissimilar to the problems of discontinuous con-
stituents in natural language parsing; however in
dictionaries like the ones we discuss the phe-
nomena seem less regular (if discontinuous con-
stituents can be regarded as regular at all).
</bodyText>
<subsectionHeader confidence="0.999087">
3.3 Graceful failure
</subsectionHeader>
<bodyText confidence="0.99378492">
The nature of the information contained in dic-
tionaries is such that certain fields within entries
do not use any conventions or formal systems to
present their data. For instance, the &amp;quot;USAGE&amp;quot;
notes in LDOCE can be arbitrarily complex and
unstructured fragments, combining straight text
with a variety of notational devices (e.g. font
changes, item highlighting and notes segmenta-
tion) in such a way that no principled structure
may be imposed on them. Consider, for example,
the annotation of &amp;quot;loan&amp;quot;:
loan2 v esp. AmE to give (someone) the use of,
lend USAGE It is perfectly good AmE to use
loan in the meaning of lend: He loaned me ten dollars.
The word is often used in BrE, esp. in the meaning &apos;to
lend formally for a long period&apos;: He loaned his
collection of pictures to the public GALLERY but many
people do not like it to be used simply in the meaning
of lend in BrE...
Notwithstanding its complexity, we would still
like to be able to process the complete entry, re-
covering as much as we can from the regularly
encoded information and only &apos;skipping&apos; over its
truly unparseable fragment(s). Consequently, the
formalism and the underlying processing frame-
</bodyText>
<page confidence="0.991548">
914
</page>
<bodyText confidence="0.999959333333333">
work should incorporate a suitable mechanism
for explicitly handling such data, systematically
occumng in dictionanes.
The notion of graceful failure is, in fact, best re-
garded as &apos;selective parsing&apos;. Such a mechanism
has the additional benefit of allowing the incre-
mental development of dictionary grammars with
(eventually) complete coverage, and arbitrary
depth of analysis, of the source data: a particular
grammar might choose, for instance, to treat ev-
erything but the headword, part of speech, and
pronunciation as &apos;junk&apos;, and concentrate on
elaborate parsing of the pronunciation fields,
while still being able to accept all input without
having to assign any structure to most of it.
</bodyText>
<sectionHeader confidence="0.991655" genericHeader="method">
4. OVERVIEW OF DEP
</sectionHeader>
<bodyText confidence="0.99994152173913">
DEP uses as input a collection of &apos;raw&apos;
typesetting images of entries from a dictionary
(i.e. a typesetting tape with &apos;begin-end&apos; bounda-
ries of entries explicitly marked) and, by consult-
ing an externally supplied grammar specific for
that particular dictionary, produces exphcit struc-
tural representations for the individual entries,
which are either displayed or loaded into an LDB.
The system consists of a rule compiler, a parsing
engine, a dictionary entry template generator, an
LDB loader, and various development facilities,
all in a PROLOG shell. User-written PROLOG
functions and primitives are easily added to the
system. The formalism and rule compiler use the
Modular Logic Grammars of McCord (1987) as
a point of departure, but they have been sub-
stantially modified and extended to reflect the re-
quirements of parsing dictionary entries.
The compiler accepts three different kinds of rules
corresponding to the three phases of dictionary
entry analysis: tokenization, retokenization, and
parsing proper. Below we present informally
highlights of the grammar formalism.
</bodyText>
<subsectionHeader confidence="0.896956">
4.1 Tokenization
</subsectionHeader>
<bodyText confidence="0.99933228">
Unlike in sentence parsing, where tokenization
(or lexical analysis) is driven entirely by blanks
and punctuation, the DEP grammar writer ex-
plicitly defines token delimiters and token substi-
tutions. Tokenization rules specify a one-to-one
mapping from a character substring to a rewrite
token; the mapping is applied whenever the
specified substnng is encountered in the original
typesetting tape character stream, and is only
sensitive to immediate context. Delimiters are
usually font change codes and other special char-
acters or symbols; substitutions are atoms (e.g.
ital_correction, fiald_sep) CT structured terms
(e.g. font( italic), sap( &amp;quot;1&amp;quot;)). Tokenization
breaks the source character stream into a mixture
of tokens and strings; the former embody the
notational conventions employed by the printed
dictionary, and are used by the parser to assign
structure to an entry; the latter cony the textual
(lexical) content of the dictionary. Some sample
rules for the LDOCE machine-readable source,
marking the beginning and end of font changes,
or making explicit special print symbols, are
shown below (to facilitate readability, c*A8) re-
presents the hexadecimal symbol x
</bodyText>
<table confidence="0.439124">
dalim(&amp;quot;(*46)&amp;quot;, font( italic)).
delict &amp;quot;(*CA)&amp;quot;, fent(bagin(ssoll caps))).
dalim(&amp;quot;01C8)&amp;quot;, fent(andIsmall caps))).
deli.( &amp;quot;(*64)&amp;quot;, ital_correctioA).
delict &amp;quot;(*80)&amp;quot;, hyphan_mark).
</table>
<bodyText confidence="0.893758214285714">
Immediate context, as well as local string rewrite,
can be specified by more elaborate tokenization
rules, in which two additional arguments specify
strings to be &apos;glued&apos; to the strings on the left and
right of the token delimiter, respectively. For
CEG, for instance, we have
&gt;1.14&lt;&amp;quot;, pd, U&amp;quot;, &amp;quot;&gt;u4&lt;&amp;quot;).
delict &amp;quot;)u4&lt;&amp;quot;, font( bold)).
delict &amp;quot;&gt;u5&lt;&amp;quot;, fent(reman)).
Tokenization operates recursively on the string
fragments formed by an active rule; thus, appli-
cation of the first two rules above to the string
fixxx. x.ift&lt; yyy&amp;quot; results in the following token
list: &amp;quot;xxx&amp;quot; . pd . fontlboold) . &amp;quot;yyy&amp;quot;.
</bodyText>
<subsectionHeader confidence="0.865189">
4.2 Retokenization
</subsectionHeader>
<bodyText confidence="0.968902090909091">
Longer-range (but still local) context sensitivity
is implemented via retokenization, the effect Of
which is the &apos;normalization&apos; of the token list.
Retokenization rules conform to a general rewrite
format — a pattern on the left-hand side defines
a context as a sequence of (explicit or variable
place holder) tokens, in which the token list
should be adjusted as indicated by the right-hand
side — and can be used to perform a range of
cleaning up tasks before parsing proper.
Streamlining the token list. Tokens without in-
formation- or structure-bearing content, such as
associated with the codes for italic correction or
thin space, are removed:
ital_correction : +Sag &lt;=&gt; +Seg.
Superfluous font control characters can be simply
deleted, when they follow or precede certain
data-carrying tokens which also incorporate
typesetting information (such as a homograph
superscript symbol or a pronunciation marker
indicating the beginning of the scope of a pho-
netic font):
</bodyText>
<equation confidence="0.536068">
pron mark : fon*( phonetic) &lt;=&gt; pron mark.
fentTX) : sup(N) &lt;=&gt; sup(R).
</equation>
<bodyText confidence="0.9907835">
(Re)adjusting the token list. New tokens can be
introduced in place of certain token sequences:
</bodyText>
<equation confidence="0.644295">
bre : fentlitalic) &lt;=&gt; baginlrestriction).
font(roman) : kat &lt;=&gt; andtrestriction).
</equation>
<bodyText confidence="0.998863857142857">
Reconstruction of string segments. Where the
initial (blind) tokenization has produced spurious
fragmentation, string segments can be suitably
reconstructed. For instance, a hyphen-delimited
sequence of syllables in place of the .print form
of a headword, created. by tokenization on
hypivin_mar4c), can be &apos;glued&apos; back as follows:
</bodyText>
<subsectionHeader confidence="0.533458">
+Syl_l : hyphen mark : +Sy1_2
SstringprSyl 1) : Sstringp(Syl 2) :
</subsectionHeader>
<bodyText confidence="0.90239825">
&lt;=&gt; an(Seg, :
+Sea.
This rule demonstrates a characteristic property
of the DEP formalism, discussed in more detail
</bodyText>
<page confidence="0.994796">
95
</page>
<bodyText confidence="0.999792714285714">
later: arbitrary Prolog predicates can be invoked
to e.g. constrain rule application or manipulate
strings. Thus, the rule only applies to string to-
kens surrounding a hyphen character; it manu-
factures, by string concatenation, a new segment
which replaces the triggering pattern.
Further segmentation. Often strings need to be
split, with new tokens inserted between the
pieces, to correct infelicities in the tapes, or to
insert markers between recognizably distinct con-
tiguous segments that appear in the same font.
The rule below implements the CGE/CEG con-
vention that a swung dash is an implicit switch
to bold if the current font is not bold already.
</bodyText>
<equation confidence="0.961931">
font(X) : IN.,X=bold) : +E.• istrirgp(E) :
Scancet(J616E) 1 *concatt&amp;quot; -&amp;quot;s*,B)
</equation>
<bodyText confidence="0.914258897435897">
&lt;=&gt; font(X) :+A : tont(bold) : +D.
Dealing with irregular input. Rules that rear-
range tokens are often needed to correct errors in
the tapes. In CEG/CGE, parentheses surround-
ing italic items often appear (erroneously) in a
roman font. A suite of rules detaches the stray
parentheses from the surrounding tokens, moves
them around the font marker, and glues them to
the item to which they belong.
retaken invokes retokenization recursively on the
sublist beginning with fent( F) and including all
tokens to its right. In principle, the three rules
can be subsumed by a single one; in practice,
separate rules also &apos;catch&apos; other types of errone-
ous or noisy input.
Although retokenization is conceptually a sepa-
rate process, it. is interleaved in practice with
tokemzation, bringing improvements in perform-
ance. Upon completion, the tape stream corre-
sponding, for instance, to the LDOCE entry
au.tis.tic icetistik, adj suffering from AUTISM&apos;:
autistic child/behaviour — adv [Watt]
F&lt;autistic&lt;F&lt;&gt;au(*80)tis(*80)ticP&lt;C:&amp;quot;tIst
IkWadj&lt;S&lt;O000&lt;D&lt;suffering from(*CA)autis
m(*C11)(*8A):(*46)autistic children/behavi
our(*64)R&lt;01&lt;R&lt;-ally&lt;R&lt;&gt;&lt;adv&lt;Na4&lt;
is converted into the following token list:
head marker .
fld_iep . pf_marker .
pron_marker .
pos marker .
fldr-sep . scod_merker .
defrg marker .
fonttbegintsmall cops)).
s14p(&amp;quot;1&amp;quot;) . begin-61,4w) .
runon marker .
beginrderiv) .
end(deriv) . fld_sep •
fld_sep .
</bodyText>
<subsectionHeader confidence="0.991617">
4.3 Parsing
</subsectionHeader>
<bodyText confidence="0.97617004477612">
Parsing proper makes use of unification and
backtracking to handle identification of segments
by context, and is heavily augmented with some
non-trivial manipulation of (partial) trees, as im-
plicit and/or elided information packed in the
entries is being recovered and reorganized Pars-
ing is a top-down depth-first operation, and only
the first successful parse is used. This strategy,
augmented by a &apos;junk collection&apos; mechanism
(discussed below) to recover from parsing failures,
turns out to be adequate for handling all of the
phenomena encountered while assigning struc-
tural descriptions to dictionary entries.
Dictionary grammars follow the basic notational
conventions of logic grammars; however, we use
additional operators tailored to the structure ma-
nipulation requirements of dictionary parsing. In
particular, the nght-hand side of grammar rules
admits the use ot four different types of operators,
designed to deal with token list consumption, to-
ken list manipulation, structure assignment, and
(local) tree transformations. These operators
suitably modify the expansions of grammar rules;
ultimately, all rules are compiled into Prolog.
Token consumption. Tokens are removed from
the token list by the + and - operators; + also as-
signs them as terminal nodes under the head of
the invoking rule. Typically, delimiters intro-
duced by tokenization (and retokenization) are
removed once they serve their primary function
of identifying local context; string segments of the
token list are assigned labels and migrate to ap-
propriate places in the final structural represen-
tation of an entry. A simple rule for the part of
speech fields in CEG (Figure 3) would be:
pos mm&gt; -font(italic) : +Seg.
011M1UXed untn stposs &amp;quot;n&amp;quot;.nil) is built as a
result of the rule consuming, for instance, the to-
ken &amp;quot;n&amp;quot;, Rule names are associated with attri-
butes in the LDB representation for a dictionary
entry; structures built by rules are pairs of the
form stnemes Value), where Value is a list of one
or more elements (strings or further structures
&apos;returned&apos; by recursively invoked rules).
Token list manipulation. Adjustment of the to-
ken list may be required in, for instance, simple
cases of recovering ellided information or reor-
dering tokens in the input stream. This is
achieved by the ins and insl operators, which
respectively insert single, or sequences of, tokens
into the token list at the current position; and the
4+ operator, which inserts tokens (or arbitrary
tree fragments) directly into the structure under
construction. Assuming a global variable, Head,
bound to the headword of the current entry, and
the ability to invoke a Prolog string concat-
enation function from within a rule (via the $
operator; see below), abbreviated morphological
derivations stored as run-ons might be recovered
by:
run_an ==&gt; -runan mark : -font(bold) : -Sag :
*conceit&amp;quot; &amp;quot;2 Xs Seg)
*ise(Xs suffix) •
Scancet(Neads Xs Derivl :
++Deriv.
(isa is separately defined to test for membership
of a closed class of suffixes.)
</bodyText>
<equation confidence="0.884616">
+E : Sstrinflp(E) :
&lt;=&gt; &apos;) : +El.
font(F) :
&lt;=&gt; : rat
+E : istringp(E) :
</equation>
<figure confidence="0.986611944444445">
&lt;a&gt; +El.
Sconcet(&amp;quot;) &amp;quot;sElsE)
/* detach */
431414!1:112:44:45111/
/1. glum */
&amp;quot;autistic&amp;quot;
&amp;quot;au-tis-tic&amp;quot;
&amp;quot;C:&amp;quot;tIstIk&amp;quot;
•Ijfl
&amp;quot;0000&amp;quot;
&amp;quot;suffering from&amp;quot;
&amp;quot;autism&amp;quot;
&amp;quot;autistic
child/behaviour&amp;quot;
&amp;quot;01&amp;quot;
&amp;quot;autistically&amp;quot;
&amp;quot;adv&amp;quot;
&amp;quot;Na4&amp;quot; . fld_sep .
</figure>
<page confidence="0.993098">
96
</page>
<bodyText confidence="0.999482">
Structure assignment. The ++ operator can only
assign arbitrary structures directly to the node in
the tree which is currently under construction. A
more general mechanism for retaining structures
for future use is provided by allowing variables to
be (optionally) associated with grammar rules: in
this way the grammar writer can obtain an ex-
plicit handle on tree fragments, in contrast to the
default situation where each rule implicitly
&apos;returns&apos; the structure it constructs to its caller.
The following rule, for example, provides a skel-
eton treatment to the situation exemplified in
Figure 4, where a definition-initial substring is
common to more than one sub-definition:
</bodyText>
<equation confidence="0.9895765">
clefs ==&gt; $stringp(S061)
s.ciefs(
subdefs(X) ==&gt; subdef(X) : opt(subdefs(X)).
subdef(X) ==&gt; -font(bold) :
sd_letter : -fonts roman) :
-Se :
$cong catlX, Seg, DefString) :
ins(DefString) : def_string.
</equation>
<bodyText confidence="0.995694464285714">
sd letter ==&gt; +Sag : $verify(Segy &amp;quot;abc&amp;quot;).
de_string ==&gt; +Seg : $stringp(Seg).
The clefs rule removes the definition-initial string
segment and passes it on to the repeatedly in-
voiced subdofs. This manufactures the complete
definition string by concatenating the common
initial segment, available as an argument
instantiated two levels higher, with the continua-
tion string specific to any given sub-definition.
Tree transformations. The ability to refer, by
name, to fragments of the tree being constructed
by an active grammar rule, allows arbitrary tree
transformations using the complementary opera-
tors -z and +z. They can only be applied to
non-terminal grammar rules, and require the ex-
plicit specification of a place-holder variable as a
rule argument; this is bound to the structure
constructed by the rule. The effect of these op-
erators on the tree fragments constructed by the
rules they modify is to prevent their incorporation
into the local tree (in the case of -z), to explicitly
splice it in (in the case of +z), or simply to capture
it .(z). The use of this mechanism in conjunction
with the structure naming facility allows both
permanent deletion of nodes, as well as their
practically unconstrained migration between, and
within, different levels of grammar (thus imple-
menting node raising and reordering). It is also
possible to write a rule which builds no structure
(the utility of such rules, in particular for con-
trolling token consumption and junk collection,
is discussed in section 5).
Node-raising is illustrated by the grammar frag-
ment below, which might be used to deal with
certain collocation phenomena. Sometimes dic-
tionaries choose to explain a word in the course
of defining another related word by arbitrarily in-
serting mini-entries in their definitions:
lachzy.mal lmkrimal ad] IWa51 of or concerning tears
of the organ (lachrymal gland!&apos;... ../) of the body that
produces them
The potentially complex structure associated with
the embedded entry specification does not belong
to the definition string, and should be factored
out as a separate node moved to a higher level of
the tree, or even used to create a new tree entirely.
The rule for parsing the definition fields of an
entry makes a provision for embedded entries; the
structure built as an embedded_entry is bound to
the strue argument in the defn rule. The -z op-
erator prevents the eatbedded_entry node from
being incorporated as a daughter to defn; how-
ever, by unification, it begins its migration
&apos;upwards&apos; through the tree, tint is &apos;caught&apos; by the
entry rule several levels higher and inserted (via
+x) in its logically appropriate place.
</bodyText>
<equation confidence="0.8787063">
head : prim pos : code :
defn(Embedded) :
+Zembedded_entry(Embedded).
-Segl : $stringp(Segl) :
-Zembedded entry(Struc) :
-Seg2 : $siringp(Seg2) :
$concat(SegltSeg2,
DefString) :
++DefString.
-bra • • -kat.
</equation>
<bodyText confidence="0.999057928571429">
Capturing generalizations / execution control.
The expressive power of the system is further en-
hanced by allowing optionality (via the opt oper-
ator), alternations ( i) and conditional constructs
in the gr.::--:nar rules; the latter are useful both for
more cor..; act rule specification and to control
backtracking while parsing. Rule application
may be constrained by. arbitrary tests (invoked,
as Prolog predicates, via a $ operator), and a
string operator is available for sampling local
context. The mechanism of escaping to Prolog,
the motivation for which we discuss below, can
also be invoked when arbitrary manipulation of
lexical data — ranging from e.g.. simple string
processing to complex morphological analysis —
is required during parsing.
Tree structures. Additional control over the
shape of dictionary entry trees is provided by
having two types of non-terminal nodes: weak
and strong ones. The difference is in the explicit
presence or absence of nodes, corresponding to
the rule names, in the final tree: a structure frag-
ment manufactured by a weak non-terminal is
effectively &apos;spliced&apos; into the higher level structure,
without an intermediate level of naming. One
common use of such a device is the &apos;flattening&apos;
of branching constructions, typically built by re-
cursive rules: the declaration
</bodyText>
<subsectionHeader confidence="0.809645">
strong_nontereinals (clefs . subdef . nil).
</subsectionHeader>
<bodyText confidence="0.999988">
when applied to the sub-definitions fragment
above, would lead to the creation of a group of
sister subdef nodes, immediately dominated by a
dos node. Another use of the distinction be-
tween weak and strong non-terminals is the ef-
fective mapping from typographically identical
entry segments to appropriately named structure
fragments, with global context driving the name
assignment. Thus, assuming a weak label rule
which captures the label string for further testing,
analysis of the example labels discussed in 3.1
could be achieved as follows (also see Figure 3):
</bodyText>
<equation confidence="0.999525333333333">
entry = = &gt;
defn(Struc) = = &gt;
embedded_entry ==&gt;
</equation>
<page confidence="0.62014">
97
</page>
<equation confidence="0.85517075">
label(X) X ) ==&gt; -begin( restriction )
astrinw( X ) : -and( restriction ).
tran ==&gt; opt ( domain I style I dial I
usage_note 3 : word.
</equation>
<bodyText confidence="0.90427">
style ==&gt; label( X ) : Sisal X, styl lab ) .
domain ==&gt; label(X) X ) : Sisa( X, doerrlab I.
dial ==&gt; label( X ) : SisatX • diaClab ) .
usage_note ==&gt; label( X 1.
Such a mechanism captures generalities in
typograp:4 conventions employed across any
given dictionary, and yet preserves the distinct
name spaces required for a meaningful &apos;unfolding&apos;
of a dictionary entry structure.
</bodyText>
<sectionHeader confidence="0.965922" genericHeader="method">
5. RANGE OF PHENOMENA TO HANDLE
</sectionHeader>
<bodyText confidence="0.954853780487805">
Below we describe some typical phenomena en-
countered in the dictionaries we have parsed and
discuss their treatment.
5.1 Messy token lists: controlling token
consumption
The unsystematic encoding of font changes be-
fore, as well as after, punctuation marks (com-
mas, semicolons, parentheses) causes blind
tokenization to remove punctuation marks from
the data to which they are visually and concep-
tually attached. As already discussed (see 4.2),
most errors of this nature can be corrected by
retokenization. Similarly, the confusing effects
of another pervasive error, namely the occurrence
of consecuti e font changes, can be avoided by
having a retokenization rule simply remove all
but the last one. In general, context sensitivity is
handled by (re)adjusting the token list;
retokenization, however, is only sensitive to local
context. Since global context cannot be deter-
mined unequivocally till parsing, the grammar
writer is given complete control over the con-
sumption and addition of tokens as parsing pro-
ceeds from left to right — this allows for
motivated recovery of ellisions, as well as dis-
carding of tokens in local transformations.
For instance, spurious occurrences of a font
marker before a print symbol such as an opening
parenthesis, which is not affected by a font dec-
laration, clearly cannot be removed by a
retokenization rule
font( roman ) : bra &lt;=&gt; bra.
(The marker may he genuinely closing a font
segment prior to a different entry fragment which
commences with, e.g., a left parenthesis). Instead,
a grammar rule anticipating a bra token within its
scope can readjust the token list using either of:
==&gt; : -font( roman) : -bra : ins( bra ).
==&gt; : -font( roman : string( bra .*).
(The string operator tests for a token list with
bra as its first element.)
</bodyText>
<subsectionHeader confidence="0.998162">
5.2 The Peter-1 principle: scoping phenomena
</subsectionHeader>
<bodyText confidence="0.979557576923077">
Consider the entry for &amp;quot;Bankrott&amp;quot; in Figure 2.
Translations sharing the label (jig) (&amp;quot;breakdown,
collapse&amp;quot;) are grouped together with commas and
separated from other lists with semicolons. The
restriction (context or label) precedes the list and
can be said to scope &apos;right&apos; to the next semicolon.
We place the right-scoping labels or context un-
der the (semicolon-delimited) tran_group as sister
nodes to the multiple (comma-delimited) tran
nodes (see also the representation of &amp;quot;title&amp;quot; in
Figure . 3). Two principles are at work here:
mamtaming implicit evidence of synonymy
among terms in the target language responds to
the &amp;quot;do not discard anything&amp;quot; philosophy; placing
common data items as high as possible in the tree
(the &apos;Peter-minus-1 principle&apos;) is in the spirit of
Flickinger et al. (1985), and implements the
notion of placing a terminal node at the highest
position in the tree where its value is valid in
combination with the values at or below its sister
nodes. The latter principle also motivates sets of
rules like
entry ==&gt; prow : homograph ... .
homograph ==&gt; pron .
used to account for entries in English where the
pronunciation differs for different homographs.
</bodyText>
<subsectionHeader confidence="0.626448">
5.3 Tribal memory: rule variables
</subsectionHeader>
<bodyText confidence="0.999709333333333">
Some compaction or notational conventions in
dictionaries require a mechanism for a rule to re-
member (part of) its ancestry or know its sister&apos;s
descendants. Consider the problem of determin-
ing the scope of gender or labels immediately
following variants of the headword:
</bodyText>
<subsectionHeader confidence="0.655075">
Advskaturbere nt (Sw), Advekaturskanzlei f (Aus)
lawyer&apos;s office.
</subsectionHeader>
<bodyText confidence="0.959970615384615">
Tippfraulein nt (inn, Tippsef (pej) typist.
Alchemic (esp Aus) , Alchimief alchemy.
The first two entries show forms differing, re-
spectively, in dialect and gender, and register and
gender. The third illustrates other combinations.
The rule accounting for labels after a variant must
know whether items of like type have already
been found after the headword, since items before
the variant belong to the headword, different
items of identical type following both belong in-
dividually, and all the rest are common to both.
This &apos;tribal&apos; memory is implemented using rule
variables:
</bodyText>
<equation confidence="0.8384078">
entry ==&gt; ( (dial : SIN=dial 1 ) I
( N=nodial ) 1 :
opt( subhead( N)) . .
subhead( N ) ==&gt; ... opt( SI Niodial 1 :
opt(dial) : .
</equation>
<bodyText confidence="0.999783571428571">
In addition to enforcing rule constraints via
unification, rule arguments also act as &apos;channels&apos;
for node raising and as a mechanism for control-
ling rule behaviour depending on invocation
context.
This latter need stems from a pervasive phenom-
enon in dictionaries: the notational conventions
for a logical unit within an entry persist across
different contexts, and the sub-grammar for such
a unit should be aware of the environment it is
activated in. Implicit cross-references in LDOCE
are consistently introduced by font( small_caps ),
independent of whether the running text is a de-
finition (roman font), example (italic), or an em-
</bodyText>
<page confidence="0.99194">
98
</page>
<bodyText confidence="0.98617525">
bedded phrase or idiom (bold); by enforcing the
return to the font active before the invocation of
iniplicit_wrf, we allow the analysis of cross-
references to be shared:
</bodyText>
<table confidence="0.5624362">
implicit_wrfl X ) ==&gt; -font( begin( smell caps ) )
: : -font(X).-
df_txt ==&gt; : implicit xrfiroman)
ex txt ==&gt; : implicit-xrf(italic)
id-txt ==&gt; : implicit:xrf(bold)
</table>
<subsectionHeader confidence="0.3917525">
5.4 Unpacking, duplication and movement of
structures: node migration
</subsectionHeader>
<bodyText confidence="0.9997632">
The whole range of phenomena requiring explicit
manipulation of entry fragment trees is handled
by the mechanisms for node raising, reordering,
and deletion. Our analysis of implicit cross-
references in LDOCE factors them out as sepa-
rate structural units participating in the make-up
of a word sense definition, as well as reconstructs
a &apos;text image&apos; of the definition text, with just the
orthography of the cross-reference item &apos;spliced
in&apos; (see Figure 4).
</bodyText>
<table confidence="0.6575788">
def segs(0 String) :
def:stringtO_String).
del nugget(Seg)
( dif segs!Str 01 i
Str-O = &amp;quot; l-
toconcit(SegsStr_O,StL1).
Ximplicit_xrf
sit°, Ptr.nill.Rest)).
-Sag : istringp(Seg).
def_string1 Def ) ==&gt; ++Def. .
</table>
<bodyText confidence="0.999341481481481">
The rules build a definition string from any se-
quence of substrings or lexical items used. as
cross-references: by invoking the appropnate
def_nugget rule, the simple segments are retained
only for splicing the complete definition text;
cross-reference pointers are extracted from the
structural representation of an implicit cross-
reference; and implicit_wrf nodes are propagated
up to a sister position to the def_string. The
string image is built incrementally (by string con-
catenation, as the individual def_nuggetS are
parsed); ultimately the def_string rule simply
incorporates it into the structure for defn. IDe-
clanng defn, def_string and implicit_xrf to be
strong non-terminals ultimately results in a deft,
structure similar to the one illustrated in
Figure 4.
Copying and lateral migration of common gender
labels in CEG translations, exemplified by &amp;quot;title&amp;quot;
(Figure 3) and &amp;quot;abutment&amp;quot; (section 3.2), makes
a different use of the +x operator. To capture the
leftward scope of gender labels, in contrast to
common (right-scopmg) context labels, we create,
for each noun translation (trim), a gender node
with an empty value. The comma-delimited tran
nodes are collected by a recursive weak non-
terminal trans rule.
</bodyText>
<equation confidence="0.487556">
trans ==&gt; tren(G) : opt( -au : trans(G) I.
tran(G) ==&gt; ... word ... :
opt( -XgenderI G1 ) : +Zgender( ) .
</equation>
<bodyText confidence="0.94963055">
The (conditional) removal of gender in the sec-
ond rule followed by (obligatory) insertion of a
gender node captures the gender if present and
&apos;digs a hole&apos; for it if absent. Unification on the
last iteration of trans fills the holes.
Noun compound fragments, as in &amp;quot;abutment&amp;quot;
can be copied and migrated forward or backward
using the same mechanism. Since we have not
implemented the noun compound parsing mech-
anism required for identification of segments to
be copied, we .have temporized by naming the
fragments needing partners alt_pfx or alt_sfx.
5.5 Conflated lexical entries: homograph
unpacking
We have implemented a mechanism to allow
creation of additional entries out of a single one.
for example from orthographic, dialect. or
morphological variants of the original headword.
Some CGE examples were given in sections 2 and
5.3 above. To handle these, the rules build the
second entry inside the main one and manufac-
ture cross reference information for both main
form and variant, in anticipation of the imple-
mentation of a splitting mechanism. Examples
of other types appear in both CGE and CEG:
vampire [...] n (lit) Vampir, Blutsauger (old) m; (fig)
Vampir m. -•• bat Vampir, Blutsauger (old) m.
wader [...) n (a) (Orn) Watvogel m. (b) -s pl (boots)
Watstiefel pl.
house in cpds Haus-; arrest n Hausarrest m; -- boat
n Hausboot nr, bound ad] ans Haus gefesselt;
house: -hunt vi auf Haussuche sein; they have started
--hunting sie haben angefangen, nach einem Haus zu
suchen; -hunting n Haussuche n;
The conventions for morphological variants, used
heavily in e.g. LDOCE and Webster&apos;s Seventh,
are different and would require a different mech-
anism. We have not yet developed a generalized
rule mechanism for ordering any kind of split;
indeed we do not know if it is possible, given the
wide variation in seemingly act hoc conventions
for &apos;sneaking in&apos; logically separate entries into re-
lated headword definitions: the case of &amp;quot;lachrymal
gland&amp;quot; in 4.3 is just one instance of this phe-
nomena; below we list some more conceptually
similar, but notationally different, examples,
demonstrating the embedding of homographs in
the variant, run-on, word-sense and example
fields of LDOCE.
daddy long legs ..dmdi loplegz also (fml) crane fly - n
... a type of flying insect with long legs
ac.ri.mo.ny n bitterness, as of manner or language
- -nious Im,kri&apos;mauniasi ad): an acrimonious quarrel -
-Piously adv
crash&apos; v ... 6 infml also gatecrash - to join (a party)
without having been invited ...
folk et.y.mol.o.gy n the changing of strahge or
foreign words so that they become like quite common
ones: some people say sparrowgrass instead of
ASPARAGUS.- that is an example of folk etymology
</bodyText>
<figure confidence="0.977697">
defn
def_segs(Str_1)
def-nu9Get(Ptr)
def-nugget(Seg) ==&gt;
</figure>
<page confidence="0.95667">
99
</page>
<subsectionHeader confidence="0.689213">
5.6 Notational promiscuity: selective
</subsectionHeader>
<bodyText confidence="0.995407541666667">
tokenization
Often distinctly different data items appear con-
tiguous in the same font: the grammar codes of
LIDOCE (section 2) are just one example. Such
run-together segments clearly need their own
tokenization rules, which can only be applied
when they are located during parsing. Thus,
commas and parentheses take on special meaning
in the string &amp;quot;X(to be)1,7&amp;quot;, indicating, respec-
tively, ellision of data and optionality of phrase.
This is a different interpretation from e.g. alter-
nation (consider the meaning of &amp;quot;ad], noun&amp;quot;) or
the enclosing of italic labels in parentheses (Fig-
ure 3). Submission of a string token to further
tokenization is best done by invoking a special
purpose pattern matching module; thus we avoid
global (and blind) tokenization on common (and
ambiguous) characters such as punctuation
marks. The functionality required for selective
tokenization is provided by a parse primitive;
below we demonstrate the construction of a list
of sister syncat nodes from a segment like &amp;quot;n,
v, adj&amp;quot;, repetitively invoking parse to break a
string into two substrings separated by a comma:
</bodyText>
<figure confidence="0.1899356">
syncets ==&gt; -seg : Sstrinsp(Seg)
Sparse(Hd.&amp;quot; .Rest.nil, Sag) :
insl(Hd.Rest.nil) :
syncat :.opt(syncats).
==&gt; + ftsa(Seg, partofspeech).
</figure>
<subsectionHeader confidence="0.987315">
5.7 Parsing failures: junk collection
</subsectionHeader>
<bodyText confidence="0.960141666666667">
The systematic irregularity of dictionary data (see
section 3.3) is only one problem when parsing
dictionary entries. Parsing failures in general are
common during grammar development; more
specifically, they might arise due to the format of
an entry segment being beyond (easy) capturing
within the grammar formalism, or requiring non-
trivial external functionality (such as compound
word parsing or noun/verb phrase analysis).
Typically, external procedures operate on a newly
constructed string token which represents a
`packed&apos; unruly token list. Alternatively, if no
format need be assigned to the input, the gram-
mar should be able to &apos;skip over&apos; the tokens in the
list, collecting them under a `junk&apos; node.
If data loss is not an issue for a specific applica-
tion, there is no need even to collect tokens from
irregular token lists; a simple rule to skip over
USAGE fields might be written as
usage ==&gt; -usage_mark : use_field.
use_field ==&gt; -U Token : Snot(end ufield) :
opT(use_field). -
(Rules like these, building no structure, are espe-
cially convenient when extensive reorganization
of the token list is required — typically in cases
of grammar-driven token reordering or token de-
letion without token consumption.)
In order to achieve skipping over unparseable in-
put without data loss, we have implemented a
eenectiv, rule class. The structure built by such
rules the (transitive) concatenation of all the
character strings in. daughter segments. Coping
with gross irregularities is achieved by picking up
any number of tokens and `packing&apos; them to-
g.ether. This strategy is illustrated by a grammar
for phrases conjoined with italic &apos;or&apos; in example
sentences and/or their translations (see Figure 3).
The italic conjunction is surrounded by slashes in
the resulting collected string as an audit trail. The
extra argument to conj enforces, following the
strategy outlined in section 5.3, rule application
only in the correct font context.
</bodyText>
<figure confidence="0.872763625">
strong_nonterminals (source .targ . nil).
collectives (con) . nil).
source ==&gt; conj(bold).
targ ==&gt; con(roman).
conj(X) ==&gt; -font(X) : +Seg : -font(ital) :
++&amp;quot; /&amp;quot; : +&amp;quot;or&amp;quot;
•
-font(X) : +Seg.
</figure>
<bodyText confidence="0.97072537254902">
Finally,. for the most complex cases of truly ir-
regular input, a mechanism exists for constraining
junk collection to operate only as a last resort and
only at the point at which parsing can go no fur-
ther.
5.8 Augmenting the power of the formalism:
escape to Prolog
Several of the mechanisms described above, such
as contextual control of token consumption (sec-
tion 5.1), explicit structure handling (5.4), or se-
lective tokenization (5.6), are implemented as
• separate Prolog. modules. Invoking such external
functionality from the grammar rules allows the
natural integration of the form- and content-
recovery procedures into the top-down process
of dictionary entry analysis. The utility of this
device should be clear from the examples so far.
Such escape to the underlying implementation
language goes against the grain of recent devel-
opments of declarative grammar formalisms (the
procedural ramifications of, for instance, being
able to call arbitrary LISP functions from the arcs
of an ATN grammar have been discussed at
length: see, for instance, the opening chapters in
Whitelock et al., 1987). However, we feel justi-
fied in augmenting the formalism in such a way,
as we are dealing with input which is different in
nature from, and on occasions possibly more
complex than, straight natural language. Unho-
mogeneous mixtures of heavily formal notations
and annotations in totally free format, inter-
spersed with (occasionally incomplete) fragments
of natural language phrases, can easily defeat any
attempts at `clean&apos; parsing. Since the DEP sys-
tem is designed to deal with an open-ended set
of dictionaries, it must be able to confront a sim-
ilarly open-ended set of notational conventions
and abbreviatory devices. Furthermore. dealing
in full with some of these notations requires ac-
cess to mechanisms and theories well beyond the
power of any grammar formalism: consider, for
instance, what is involved in analyzing pronun-
ciation fields in a dictionary, where alternative
pronunciation patterns are marked only for
syllable(s) which differ from the primary pronun-
ciation (as in arch.bish.op: /,aarbijap_ ,ar-i);
where the pronunciation string itself is not
marked for syllable structure; and where the as-
signment of syllable boundaries is far from trivial
(as in fas.cist: rfwja-st/)!
syncat
</bodyText>
<page confidence="0.92563">
100
</page>
<sectionHeader confidence="0.997647" genericHeader="method">
6. CURRENT STATUS
</sectionHeader>
<bodyText confidence="0.985524793103448">
The run-time environment of DEP includes
grammar debugging utilities, and a number of
options. All facilities have been implemented,
except where noted. We have very detailed
ars for CGE (parsing 98% of the entries),
Errain(95%), and LDOCE (93%); less detailed
ars for Webster&apos;s Seventh (98%), and both
grammars
the Collins French Dictionary (approxi-
mately 90%).
The Dictionary Entry Parser is an integral part
of a larger system designed to recover dictionary
structure to an arbitrary depth of detail, convert
the resulting trees into LDB records, and make
the data available to end users via a flexible and
powerful lexical query language (LQL). Indeed,
we have built LDB&apos;s for all dictionaries we have
parsed; further development of LQL and the ex-
ploitation of the LDB&apos;s via query for a number
of lexical studies are separate projects.
Finally, we note that, in the light of recent efforts
to develop an interchange standard for (English
mono-lingual) dictionaries (Amsler and Tompa,
1988), DEP acquires additional relevance, since
it can be used, given a suitable annotation of the
grammar rules for the machine-readable source,
to transduce a typesetting tape into an inter-
changeable dictionary source, available to a larger
user community.
</bodyText>
<sectionHeader confidence="0.997082" genericHeader="acknowledgments">
ACKNOWLEDGEMENTS
</sectionHeader>
<bodyText confidence="0.9999824">
We would like to thank Roy Byrd, Judith
Klavans and Beth Levin for many discussions
concerning the Dictionary Entry Parser system in
general, and this paper in particular. Any re-
maining errors are ours, and ours only.
</bodyText>
<sectionHeader confidence="0.999533" genericHeader="references">
REFERENCES
</sectionHeader>
<reference confidence="0.994053976744186">
Ahlswede, T, M Evens, K Rossi and J Markowitz
(1986) &amp;quot;Building a Lexical Database by Parsing
Webster&apos;s Seventh New Collegiate Dictionary&apos;,
Advances in Lexicology, Second Annual Confer-
ence of the UW Centre for the New Oxford
English Dictionary, 65— 78.
Amsler, R and F Tompa (1988) &amp;quot;An
SGML-Based Standard for English Monolingual
Dictionaries&amp;quot;, Information in Text, Fourth An-
nual Conference of the UW Centre for the New
Oxford English Dictionary, 61 — 79.
Boguraev, B, and E Briscoe (Eds) (1989) Com-
putational Lexicography for Natural Language
Processing, Longman, Harlow.
Byrd, R, N Calzolari, M Chodorow, J Klavans,
M Neff and 0 Rizk (1987) &amp;quot;Tools and Methods
for Computational Lexicology&amp;quot;, Computational
Linguistics, vol.13(3 —4), 219-240.
Calzolari, N and E Picchi (1986) &amp;quot;A Project for
a Bilingual Lexical Database System&amp;quot;, Advances
in Lexicology, Second Annual Conference of the
UW Centre for the New Oxford English Dic-
tionary, 79— 92.
Calzolari, N and E Picchi (1988) &amp;quot;Acquisition of
Semantic Information from an On-Line
Dictionary.&amp;quot;, Proceedings of the 12th Interna-
tional Conference on Computational Linguistics,
87— 92.
Collins (1980) Collins German Dictionary:
German— English, English— German, Collins
Publishers, Glasgow.
Garzanti (1984) II Nuovo Dizionario Italiano
Garzanti, Garzanti, Milano.
Longman (1978) Longman Dictionary of Con-
temporary English, Longman Group, London.
Dadam, P, K Kuespert, F Andersen, H Blanken,
R Erbe, J Guenauer, V Lum, P Pistor and G
Walsh (1986) &amp;quot;A DBMS Prototype to Support
Extended NF2 Relations: An Integrated View on
Flat Tables and Hierarchies&amp;quot;, Proceedings of
ACM SIGMOD`86: International Conference on
Management of Data, 356 — 367.
Flickinger, D, C Pollard, T Wasow (1985)
&amp;quot;Structure Sharing in Lexical Representation&amp;quot;,
Proceedings of the 23rd Annual Meeting of the
Association for Computational Linguistics,
262— 267.
Fox, E, T Nutter, T Alhswede, M Evens and J
Markowitz (1988) &amp;quot;Building a Large Thesaurus
for Information Retrieval&amp;quot;, Proceedings of the
Second Conference on Applied Natural Language
Processing, 101— 108.
Kazman, R (1986) &amp;quot;Structuring the Text of the
Oxford English Dictionary through Finite State
Transduction&amp;quot;, University of Waterloo Technical
Report No. TR —86— 20.
McCord, M (1987) &amp;quot;Natural Language Process-
ing and Prolog&amp;quot;, in A Walker, M McCord, J
Sowa and W Wilson (Eds) Knowledge Systems
and Prolog, Addison-Wesley, Waltham,
Massachusetts, 291-402.
Nakamura, J and Makoto N (1988) &amp;quot;Extraction
of Semantic Information from an Ordinary Eng-
lish Dictionary and Its Evaluation&amp;quot;, Proceedings
of the 12th International Conference on Computa-
tional Linguistics, 459-464.
Neff, M, R Byrd and 0 Rizk (1988) &amp;quot;Creating
and Querying Hierarchical Lexical Data Bases&amp;quot;,
Proceedings of the Second Conference on Applied
Natural Language Processing, 84— 93.
van der Steen, G J (1982) &amp;quot;A Treatment of Que-
ries in Large Text Corpora&amp;quot;, in S Johansson (Ed)
Computer Corpora in English Language
Research, Norwegian Computing Centre for the
Humanities, Bergen, 49— 6.
Tompa, F (1986) &amp;quot;Database Design for a Dic-
tionary of the Future&amp;quot;, University of Waterloo,
unpublished.
W7 (1967) Webster&apos;s Seventh New Collegiate
Dictionary, C.8LC. Merriam Company,
Springfield, Massachussetts.
Whitelock, P, M Wood, H Somers, R Johnson
and P Bennett (Eds) (1987) Linguistic Theory and
Computer Applications, Academic Press, New
York.
1 0 1
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.995943">DICTIONARIES, DICTIONARY GRAMMARS AND DICTIONARY ENTRY PARSING</title>
<author confidence="0.77033325">Yorktown Heights</author>
<author confidence="0.77033325">New York Branimir K Boguraev IBM T J Watson Research Center</author>
<author confidence="0.77033325">P</author>
<affiliation confidence="0.837796">Computer Laboratory, University of Cambridge, New Museums Site, Cambridge CB2 3QG</affiliation>
<abstract confidence="0.912983818181818">Computerist: ... But, great Scott, what about structure? You can&apos;t just bang that lot into a machine without structure. Half a gigabyte of sequential file ... Lexicographer: Oh, we know all about structure. Take this entry for example. You see here italics as the typical ambiguous structural element marker, being apparently used as an undefined phrase-entry lemma, but in fact being the subordinate entry headword address preceding the small-cap cross-reference headword address which is nested within the gloss to a defined phrase entry, itself nested within a subordinate (bold lower-case letter) sense section in the second branch of a forked multiple part of speech main entry. Now that&apos;s typical of the kind of structural relationship that must be made crystal-clear in the eventual database. from &amp;quot;Taking the Words out of His Mouth&amp;quot; — Weiner on computerising the English Dictionary</abstract>
<date confidence="0.605248">Guardian, March, 1985</date>
<abstract confidence="0.995012094117648">We identify two complementary processes in the conversion of machine-readable dictionaries into databases: recovery of the from the typographical markings persist on the dictionary distribution tapes and embody the publishers&apos; notational conventions; followed by making explicit all of the codified and ellided information packed into individual entries. We discuss notational conventions and tape formats, outline structural properties of dictionaries, observe a range of representational phenomena particularly relevant to dictionary parsing, and derive a set of minimal requirements for a dictionary grammar formalism. We present a general purpose dictionary entry parser which uses a formal notation designed to describe the structure of entries and performs a mapping from the flat character stream on the tape to a highly structured and fully instantiated representation of the dictionary. We demonstrate the power of the formalism by drawing examples from a range of dictionary sources which have been processed and converted into lexical databases. Machine-readable dictionaries (MR D&apos;s) are typically available in the form of publishers&apos; typesetting tapes, and consequently are represented by a flat character stream where lexical data proper is heavily interspersed with special (control) characters. These map to the font changes and other notational conventions used in the printed form of the dictionary and designed to pack, and present in a codified compact visual format, as much lexical data as possible. To make maximal use of MRD&apos;s, it is necessary make their data, as well as structure, fully explicit, in a data base format that lends itself to flexible querying. However, since none of the lexical data base (LDB) creation efforts to date fully addresses both of these issues, they fail to offer a general framework for processing the wide range of dictionary resources available in machine-readable form. As one extreme, the conversion of an MRD into an LDB may be carried out by a `one-off program — such as, for used for the Dictionary of English and described in Boguraev and Briscoe, 1989. While the resulting LDB is quite explicit and complete with respect to the data in the source, all knowledge of the dictionary structure is embodied in the conversion program. On the other hand, more modular architectures consisting of a parser and a grammar — best exemplified by Kazrnan&apos;s (1986) analysis of the Oxford English Dictionary (OED) — do not deliver the structurally rich and explicit LDB ideally required for easy and unconstrained access to the source data. The majority of computational lexicography projects, in fact, fall in the first of the categories in that they on the of a dictionary into an LDB: here the work by e.g. Ahlswede at., on Webster&apos;s Seventh New Dictionary; at., on English Dictionary; and Picchi, on Nuovo Dizionario Italiano Garzanti; van der Steen, 1982, and Nakamura, 1988, on LDOCE. Even work based on multiple dictionaries (e.g. in bilingual context: see Calzolari and Picchi, 1986) appear to have used specialized programs for each dictionary source. In addition, not an uncommon property of the LDB&apos;s cited above is their incompleteness with respect to the ongmal source: there is a tendency to extract, in a pre-processing phase, only some fragments (e.g. 9 1 part of speech information or definition fields) while ignoring others (e.g. etymology, pronunciation or usage notes). We have built a Dictionary Entry Parser (DEP) together with grammars for several different dictionaries. Our goal has been to create a general mechanism for converting to a common LDB format a wide range of MRD&apos;s demonstrating a wide range of phenomena. In contrast to the OED project, where the data in the dictionary is only tagged to indicate its structural characteristics, we identify two processes which are crucial for the &apos;unfolding&apos;, or making explicit, the structure of an MRD: identification of the structural markers, followed by their interpretation in context resulting in detailed parse trees for individual entries. Furthermore, unlike the tagging of the OED, carried out in several passes over the data and using different grammars (in order to cope with the highly complex, idiosyncratic and ambiguous nature of dictionary entries), we employ a parsing engine exploiting unification and backtracking, and using a single grammar consisting of three different sets of rules. The advantages of handling the structural complexities of MRD sources and deriving corresponding LDB&apos;s in one operation become clear below. While DEP has been described in general terms (Byrd al., et aL, this paper draws on our experience in parsing the Collins German-English I Collins English-German (CGE/CEG) and LDOCE dictionaries, which represent two very different types of machinereadable sources vis-a-vis format of the typesetting tapes and notational conventions exploited by the lexicographers. We examine more closely some of the phenomena encountered in these dictionaries, trace their implications for MRD-to-LDB parsing, show how they motivate the design of the DEP grammar formalism, and discuss treatment of typical entry configurations. 2. STRUCTURAL PROPERTIES OF IVIRD&apos;S The structure of dictionary entries is mostly implicit in the font codes and other special characters controlling the layout of an entry on the printed page; furthermore, data is typically compacted to save space in print, and it is common for different fields within an entry to employ radically different compaction schemes and abbreviatory devices. For example, the notation for the LDOCE grammar codes and Briscoe, 1989, present a detailed description of the grammar coding system in this dictionary), and many adverbs are stored as run-ons of the adjectives, using the abbreviatory convention —ly (the same convention applies to certain types of affixation in gen- —less, —ness, etc.). In CGE, German compounds with a common first element appear grouped together under it: children&apos;s choir; marriage. Dictionaries often factor out common substrings in data fields as in the following LDOCE and CEG entries: ... machine for warm until HATCH alive babies that are too small to live and breathe in ordinary air Figure I. Definition-initial common fragment bankruptcy; ) — to bankrupt; — anmelden declare oneself bankrupt. Figure 2. Definition-final common fragment Furthermore, a variety of conventions exists for making text fragments perform more than one function (the capitalization of &amp;quot;HATCH&amp;quot; above. for instance, signals a close conceptual link with the word being defined). Data of this sort is not very useful to an LDB user without explicit expansion and recovery of compacted headwords and fragments of entries. Parsing a dictionary to create an LDB that can be easily queried by a user or a program therefore implies not only fagging the data in the entry, but also recovering elided information, both in form and content. There are two broad types of machine-readable source, each requiring a different strategy for recovery of implicit structure and content of dictionary entries. On the one hand tapes may consist of a character stream with no explicit markings (as OED and the bilinguals exemplify); all of their structure is implied in the font changes and the overall syntax of the entry. On the other hand, sources may employ mixed representation, incorporating both global record delimiters and local structure encoded in font change codes and/or special character se- (LDOCE and Seventh). Ideally, all MRD&apos;s should be mapped onto LDB structures of the same type, accessible with a single query language that preserves the user&apos;s intuiabout the structure of lexical data (Neff Tompa, 1986). Dictionary entries can be naturally represented as shallow hierarchies with a variable number of instances of certain items at each level, e.g. multiple homographs within an entry or multiple senses within a homograph. The usual inheritance mechanisms associated with a hierarchical organisation of data not only ensure compactness of representation, but also fit lexical intuitions. The figures overleaf show sample entries from CGE and LDOCE and their LDB forms with explicitly &apos;unfolded&apos; structure. Within the taxonomy of normal forms (NF) defined by relational data base theory, dictionary entries are `urmormalized relations&apos; in which attributes can contain other relations, rather than simple scalar values; LDB&apos;s, therefore, cannot be correctly viewed as relational data bases (see Neff al., Other kinds of hierarchically structured data similarly fall outside of the relational [...] m Sport); (of chapter) (form of address) -do you give a bishop? redet man einen Bischof an? (right) + m; entry +-superhoto +-sans +-tran_group +-tran in: Sport -tran_group chapter +-tran -tran_group +-tran +-tran_group of address +-tran +-word: Anrede do you give a bishop? +-targ +-target redet /or/ spricht man omen Bischof an? +-sons +-tran_group +-tran +-word: Anspnmh +-complement +-engcomp: +-garcomp: auf + acc -tran +-tran_group Figure 3. LDB for a CEG entry NF mould; indeed recently there have been efforts to design a generalized data model which treats flat relations, lists, and hierarchical strucuniformly (Dadam 1986). Our LDB format and Lexical Query Language (LQL) support the hierarchical model for dictionary data; the output of the parser, similar to the examples in Figure 3 and Figure 4, is compacted, encoded, and loaded into an LDB. II 1 person or animal that or causes trouble, PEST: make a of yourself: sit down and be quiet! action or state of affairs which causes trouble, offence, or nuisance! I&apos;ve forgotten my no nuisance a notice in a public Do not use this place as lavatory no nuisance if ier: a notice in a public place +-sub_defn 1 +-seq_no: a 1 +-defn +-def_string: not use this place as a lavatory +-sub_defn +-seq_no: +-defn +-implici t_xrf +-to: +-hem not use place as a tip Figure 4. LDB for an LDOCE entry 3. DEP GRAMMAR FORMALISM The choice of the hierarchical model for the representation of the LDB entries (and thus the output of DEP) has consequences for the parsing mechanism. For us, parsing involves determining the structure of all the data, retrieving implicit information to make it explicit, reconstructing information, and filling (recursive) template, without any data loss. This contrasts with a strategy that fills slots in predefined (and finite) sets of records for a relational system, often discarding information that does not fit. In order to meet these needs, the formalism for dictionary entry grammars must meet at least three criteria, m addition to being simply a notational device capable of describing any particular entry nuisance +-superhom +-pronunc 1 +-primary +-pron_string: &apos;nju:sEns : +-sense_def +-sense no: I +-defn 1 +-implicit_xrf 1 +-to: +-daf_string: a person or animal that annoys or causes trouble; pest +-example make a nuisance of yourself: sit down and be quiet/ -sense_def no: +-defn +-def_string: action or state trouble, offence, or unpleasantness +-example a nuisance! I&apos;ve forgotten my ticket -sense_def +-sense no: 3 +-defn 93 dictionary format. Below we outline the basic requirements for such a formalism. 3.1 Effects of context The grammar formalism should be capable of handling &apos;mildly context sensitive&apos; input streams, as structurally identical items may have widely differing functions depending on both local and For example, parts of speech, ield labels, ,paraphrases of cultural items, and many other dictionary fragments all appear in the CEG in italics, but their context defines their identity and, consequently, their interpretation. Thus, in the example entry in Figure 3 above, (also Sport), chapter), very different labels of domain, addition, to distinguish between domain labels, style labels, dialect labels, and usage notes, the rules must be able to test candidate elements against a closed set of items. Situations like this, involving subsidiary application of auxiliary procedures (e.g. string matching, or dictionary lookup required for an example below), require that the rules be allowed to selectively invoke external functions. The assignment of labels discussed above is based on what we will refer to in the rest of this paper In procedural terms, this is defined as the expectations of a particular grammar fragment, reflected in the names of the associated rules, which will be activated on a given path through the grammar. Global context is a dynamic notion, best thought of as a &apos;snapshot&apos; of the state of the parser at any point of processan entry. In contrast, is defined by finite-length patterns of input tokens, and has the effect of identifyingtypographic &apos;clues&apos; to the of an entry. Finally, reflects very local character patterns which tend to drive the initial segmentation of the &apos;raw&apos; tape character stream and its fragmentation into structureand information-carrying tokens. These three notions underlie our approach to analysis of dictionaries fundamental to the grammar formalism design. 3.2 Structure manipulation The formalism should allow operations on the structures delivered and not as separate tree transformations once processing is complete. This is needed, for instance, in order to handle a variety of scoping phenomena (discussed in section 5 below), factor out items common to more than one fragment within the same entry, and duplicate (sub-)trees as complete LDB representations are being fleshed out. Consider the CEG entry for &amp;quot;abutment&amp;quot;: n Here, as well as in &amp;quot;title&amp;quot; (Figure 3), a copy of the gender marker common to both translations to migrate back to the first addition, a copy of the common second compound needs to migrate (note that entry +-superheat +-pronunc: +-tran_groty 4-ti-an do o rd: identifying this needs a separate noun compound parser augmented with dictionary lookup). An example of structure duplication is illustrated by our treatment of (implicit) cross-references in LDOCE, where a link between two closely related words is indicated by having one of them in small in a definition of the other (e.g. &apos;PEST&amp;quot; and &amp;quot;TIP&amp;quot; in the definitions of &amp;quot;nuisance&amp;quot; in Figure 4). The dual purpose such words serve requires them to appear on at least two different nodes in the final LDB order to perform the required transformations, the grammar formalism must provide an explicit handle on partial structures, as they are being built by the parser, together with operations which can manipulate them — both in terms of structure decomposition and node migration. In general, the formalism must be able to deal with, discontinuous constituents, a problem not dissimilar to the problems of discontinuous constituents in natural language parsing; however in dictionaries like the ones we discuss the phenomena seem less regular (if discontinuous constituents can be regarded as regular at all). failure The nature of the information contained in dictionaries is such that certain fields within entries do not use any conventions or formal systems to present their data. For instance, the &amp;quot;USAGE&amp;quot; notes in LDOCE can be arbitrarily complex and unstructured fragments, combining straight text with a variety of notational devices (e.g. font changes, item highlighting and notes segmentation) in such a way that no principled structure may be imposed on them. Consider, for example, the annotation of &amp;quot;loan&amp;quot;: v esp. AmE give (someone) the use of, USAGE It is perfectly good use the meaning of ten dollars. word is often used in in the meaning &apos;to formally for a long period&apos;: of pictures to the public but many people do not like it to be used simply in the meaning Notwithstanding its complexity, we would still like to be able to process the complete entry, recovering as much as we can from the regularly encoded information and only &apos;skipping&apos; over its truly unparseable fragment(s). Consequently, the and the underlying processing framework should incorporate a suitable mechanism for explicitly handling such data, systematically occumng in dictionanes. The notion of graceful failure is, in fact, best reas &apos;selective parsing&apos;. Such a mechanism the additional benefit of allowing the increof dictionary grammars with (eventually) complete coverage, and arbitrary depth of analysis, of the source data: a particular grammar might choose, for instance, to treat everything but the headword, part of speech, and pronunciation as &apos;junk&apos;, and concentrate on elaborate parsing of the pronunciation fields, while still being able to accept all input without having to assign any structure to most of it. 4. OVERVIEW OF DEP DEP uses as input a collection of &apos;raw&apos; typesetting images of entries from a dictionary (i.e. a typesetting tape with &apos;begin-end&apos; boundaries of entries explicitly marked) and, by consulting an externally supplied grammar specific for that particular dictionary, produces exphcit structural representations for the individual entries, which are either displayed or loaded into an LDB. The system consists of a rule compiler, a parsing engine, a dictionary entry template generator, an LDB loader, and various development facilities, all in a PROLOG shell. User-written PROLOG functions and primitives are easily added to the system. The formalism and rule compiler use the Modular Logic Grammars of McCord (1987) as a point of departure, but they have been substantially modified and extended to reflect the requirements of parsing dictionary entries. The compiler accepts three different kinds of rules corresponding to the three phases of dictionary analysis: retokenization, proper. we present informally highlights of the grammar formalism. 4.1 Tokenization Unlike in sentence parsing, where tokenization (or lexical analysis) is driven entirely by blanks and punctuation, the DEP grammar writer explicitly defines token delimiters and token substitutions. Tokenization rules specify a one-to-one mapping from a character substring to a rewrite token; the mapping is applied whenever the specified substnng is encountered in the original typesetting tape character stream, and is only sensitive to immediate context. Delimiters are usually font change codes and other special characters or symbols; substitutions are atoms (e.g. fiald_sep) terms italic), sap( Tokenization breaks the source character stream into a mixture of tokens and strings; the former embody the notational conventions employed by the printed dictionary, and are used by the parser to assign structure to an entry; the latter cony the textual (lexical) content of the dictionary. Some sample rules for the LDOCE machine-readable source, marking the beginning and end of font changes, or making explicit special print symbols, are shown below (to facilitate readability, c*A8) represents the hexadecimal symbol x dalim(&amp;quot;(*46)&amp;quot;, font( italic)). delict &amp;quot;(*CA)&amp;quot;, fent(bagin(ssoll caps))). dalim(&amp;quot;01C8)&amp;quot;, fent(andIsmall caps))). deli.( &amp;quot;(*64)&amp;quot;, ital_correctioA). delict &amp;quot;(*80)&amp;quot;, hyphan_mark). Immediate context, as well as local string rewrite, can be specified by more elaborate tokenization in which two additional arguments strings to be &apos;glued&apos; to the strings on the left and right of the token delimiter, respectively. For CEG, for instance, we have delict &amp;quot;)u4&lt;&amp;quot;, font( bold)). delict &amp;quot;&gt;u5&lt;&amp;quot;, fent(reman)). Tokenization operates recursively on the string fragments formed by an active rule; thus, application of the first two rules above to the string x.ift&lt; in the following token . . fontlboold) . &amp;quot;yyy&amp;quot;. 4.2 Retokenization Longer-range (but still local) context sensitivity is implemented via retokenization, the effect Of which is the &apos;normalization&apos; of the token list. Retokenization rules conform to a general rewrite format — a pattern on the left-hand side defines a context as a sequence of (explicit or variable place holder) tokens, in which the token list should be adjusted as indicated by the right-hand side — and can be used to perform a range of cleaning up tasks before parsing proper. Streamlining the token list. Tokens without informationor structure-bearing content, such as associated with the codes for italic correction or thin space, are removed: ital_correction : +Sag &lt;=&gt; +Seg. Superfluous font control characters can be simply deleted, when they follow or precede certain data-carrying tokens which also incorporate typesetting information (such as a homograph superscript symbol or a pronunciation marker indicating the beginning of the scope of a phonetic font): pron mark : fon*( phonetic) &lt;=&gt; pron mark. fentTX) : sup(N) &lt;=&gt; sup(R). (Re)adjusting the token list. New tokens can be introduced in place of certain token sequences: bre : fentlitalic) &lt;=&gt; baginlrestriction). font(roman) : kat &lt;=&gt; andtrestriction). Reconstruction of string segments. Where the initial (blind) tokenization has produced spurious fragmentation, string segments can be suitably reconstructed. For instance, a hyphen-delimited of syllables in place of the form a headword, created. by on hypivin_mar4c), can be &apos;glued&apos; back as follows: +Syl_l : hyphen mark : +Sy1_2 SstringprSyl 1) : Sstringp(Syl 2) : &lt;=&gt; an(Seg, : +Sea. This rule demonstrates a characteristic property of the DEP formalism, discussed in more detail 95 later: arbitrary Prolog predicates can be invoked to e.g. constrain rule application or manipulate strings. Thus, the rule only applies to string tokens surrounding a hyphen character; it manufactures, by string concatenation, a new segment which replaces the triggering pattern. Further segmentation. Often strings need to be split, with new tokens inserted between the pieces, to correct infelicities in the tapes, or to insert markers between recognizably distinct contiguous segments that appear in the same font. The rule below implements the CGE/CEG convention that a swung dash is an implicit switch to bold if the current font is not bold already. : : +E.• istrirgp(E) : 1 *concatt&amp;quot; : tont(bold) : +D. Dealing with irregular input. Rules that rearrange tokens are often needed to correct errors in the tapes. In CEG/CGE, parentheses surrounding italic items often appear (erroneously) in a roman font. A suite of rules detaches the stray parentheses from the surrounding tokens, moves them around the font marker, and glues them to the item to which they belong. retaken invokes retokenization recursively on the beginning with F) including all tokens to its right. In principle, the three rules can be subsumed by a single one; in practice, separate rules also &apos;catch&apos; other types of erroneous or noisy input. Although retokenization is conceptually a sepaprocess, is interleaved in practice with tokemzation, bringing improvements in performance. Upon completion, the tape stream corresponding, for instance, to the LDOCE entry from AUTISM&apos;: autistic child/behaviour — adv [Watt] F&lt;autistic&lt;F&lt;&gt;au(*80)tis(*80)ticP&lt;C:&amp;quot;tIst IkWadj&lt;S&lt;O000&lt;D&lt;suffering from(*CA)autis m(*C11)(*8A):(*46)autistic children/behavi our(*64)R&lt;01&lt;R&lt;-ally&lt;R&lt;&gt;&lt;adv&lt;Na4&lt; is converted into the following token list: head marker . fld_iep . pf_marker . pron_marker . pos marker . . scod_merker . defrg marker . fonttbegintsmall cops)). . . runon marker . beginrderiv) . end(deriv) . fld_sep • fld_sep . 4.3 Parsing Parsing proper makes use of unification and backtracking to handle identification of segments by context, and is heavily augmented with some non-trivial manipulation of (partial) trees, as implicit and/or elided information packed in the entries is being recovered and reorganized Parsing is a top-down depth-first operation, and only the first successful parse is used. This strategy, augmented by a &apos;junk collection&apos; mechanism (discussed below) to recover from parsing failures, turns out to be adequate for handling all of the phenomena encountered while assigning structural descriptions to dictionary entries. Dictionary grammars follow the basic notational conventions of logic grammars; however, we use additional operators tailored to the structure manipulation requirements of dictionary parsing. In particular, the nght-hand side of grammar rules admits the use ot four different types of operators, to deal with list consumption, tolist manipulation, structure assignment, tree transformations. operators suitably modify the expansions of grammar rules; ultimately, all rules are compiled into Prolog. Token consumption. Tokens are removed from the token list by the + and operators; + also assigns them as terminal nodes under the head of the invoking rule. Typically, delimiters introduced by tokenization (and retokenization) are removed once they serve their primary function of identifying local context; string segments of the token list are assigned labels and migrate to appropriate places in the final structural representation of an entry. A simple rule for the part of speech fields in CEG (Figure 3) would be: posmm&gt; : +Seg. untn stposs &amp;quot;n&amp;quot;.nil) is built as result of the rule consuming, for instance, the token &amp;quot;n&amp;quot;, Rule names are associated with attributes in the LDB representation for a dictionary entry; structures built by rules are pairs of the stnemes a list of one or more elements (strings or further structures &apos;returned&apos; by recursively invoked rules). Token list manipulation. Adjustment of the token list may be required in, for instance, simple cases of recovering ellided information or reordering tokens in the input stream. This is achieved by the ins and insl operators, which respectively insert single, or sequences of, tokens into the token list at the current position; and the 4+ operator, which inserts tokens (or arbitrary tree fragments) directly into the structure under Assuming a global variable, bound to the headword of the current entry, and the ability to invoke a Prolog string concatenation function from within a rule (via the $ operator; see below), abbreviated morphological derivations stored as run-ons might be recovered by: run_an ==&gt; -runan mark : -font(bold) : -Sag : Scancet(Neads Xs Derivl : ++Deriv. (isa is separately defined to test for membership of a closed class of suffixes.)</abstract>
<degree confidence="0.7640585">E : Sstrinflp(E) : &apos;) : font(F) : rat +E : istringp(E) : Sconcet(&amp;quot;) &amp;quot;sElsE</degree>
<abstract confidence="0.99290046875">detach */ */ &amp;quot;autistic&amp;quot; &amp;quot;au-tis-tic&amp;quot; &amp;quot;C:&amp;quot;tIstIk&amp;quot; • &amp;quot;0000&amp;quot; &amp;quot;suffering from&amp;quot; &amp;quot;autism&amp;quot; &amp;quot;autistic child/behaviour&amp;quot; &amp;quot;01&amp;quot; &amp;quot;autistically&amp;quot; &amp;quot;adv&amp;quot; &amp;quot;Na4&amp;quot; . fld_sep . 96 Structure assignment. The ++ operator can only assign arbitrary structures directly to the node in the tree which is currently under construction. A more general mechanism for retaining structures for future use is provided by allowing variables to be (optionally) associated with grammar rules: in this way the grammar writer can obtain an explicit handle on tree fragments, in contrast to the default situation where each rule implicitly &apos;returns&apos; the structure it constructs to its caller. The following rule, for example, provides a skeleton treatment to the situation exemplified in Figure 4, where a definition-initial substring is common to more than one sub-definition: clefs ==&gt; $stringp(S061) subdefs(X) ==&gt; subdef(X) : opt(subdefs(X)).</abstract>
<degree confidence="0.8635705">subdef(X) ==&gt; -font(bold) : sd_letter : -fonts roman) : -Se : catlX, Seg, DefString) :</degree>
<abstract confidence="0.995953578947368">ins(DefString) : def_string. sd letter ==&gt; +Sag : $verify(Segy &amp;quot;abc&amp;quot;). de_string ==&gt; +Seg : $stringp(Seg). The clefs rule removes the definition-initial string segment and passes it on to the repeatedly invoiced subdofs. This manufactures the complete definition string by concatenating the common initial segment, available as an argument instantiated two levels higher, with the continuation string specific to any given sub-definition. transformations. ability to refer, by name, to fragments of the tree being constructed by an active grammar rule, allows arbitrary tree transformations using the complementary operators -z and +z. They can only be applied to non-terminal grammar rules, and require the explicit specification of a place-holder variable as a rule argument; this is bound to the structure constructed by the rule. The effect of these opon the tree fragments constructed by rules they modify is to prevent their incorporation into the local tree (in the case of -z), to explicitly splice it in (in the case of +z), or simply to capture The use of this mechanism in conjunction with the structure naming facility allows both permanent deletion of nodes, as well as their practically unconstrained migration between, and within, different levels of grammar (thus implementing node raising and reordering). It is also possible to write a rule which builds no structure (the utility of such rules, in particular for controlling token consumption and junk collection, is discussed in section 5). Node-raising is illustrated by the grammar fragment below, which might be used to deal with certain collocation phenomena. Sometimes dictionaries choose to explain a word in the course of defining another related word by arbitrarily inserting mini-entries in their definitions: lmkrimal of or concerning tears of the organ (lachrymal gland!&apos;... ../) of the body that produces them The potentially complex structure associated with the embedded entry specification does not belong to the definition string, and should be factored out as a separate node moved to a higher level of the tree, or even used to create a new tree entirely. The rule for parsing the definition fields of an entry makes a provision for embedded entries; the built as an bound to strue argument in the The -z opprevents the from incorporated as a daughter to however, by unification, it begins its migration &apos;upwards&apos; through the tree, tint is &apos;caught&apos; by the several levels higher and inserted (via +x) in its logically appropriate place.</abstract>
<degree confidence="0.880360142857143">head : prim pos : code : defn(Embedded) : +Zembedded_entry(Embedded). -Segl : $stringp(Segl) : -Zembedded entry(Struc) : -Seg2 : $siringp(Seg2) : DefString) :</degree>
<abstract confidence="0.99781725925926">DefString. • •-kat. Capturing generalizations / execution control. The expressive power of the system is further enby allowing optionality (via the operator), alternations ( i) and conditional constructs the rules; the latter are useful both for more cor..; act rule specification and to control backtracking while parsing. Rule application be constrained arbitrary tests (invoked, as Prolog predicates, via a $ operator), and a is available for sampling local of escaping to Prolog, the motivation for which we discuss below, can also be invoked when arbitrary manipulation of lexical data — ranging from e.g.. simple string processing to complex morphological analysis — is required during parsing. structures. control over the of dictionary entry trees is provided two types of non-terminal nodes: The difference is in the explicit presence or absence of nodes, corresponding to the rule names, in the final tree: a structure fragment manufactured by a weak non-terminal is effectively &apos;spliced&apos; into the higher level structure, without an intermediate level of naming. One common use of such a device is the &apos;flattening&apos; of branching constructions, typically built by recursive rules: the declaration strong_nontereinals (clefs . subdef . nil). when applied to the sub-definitions fragment above, would lead to the creation of a group of immediately dominated by a node. Another use of the distinction beand strong non-terminals is the effective mapping from typographically identical entry segments to appropriately named structure fragments, with global context driving the name Thus, assuming a weak which captures the label string for further testing, analysis of the example labels discussed in 3.1 could be achieved as follows (also see Figure 3): = &gt; &gt; 97 label(X) X ) ==&gt; -begin( restriction ) astrinw( X ) : -and( restriction ). tran ==&gt; opt ( domain I style I dial I usage_note 3 : word. style ==&gt; label( X ) : Sisal X, styl lab ) . domain ==&gt; label(X) X ) : Sisa( X, doerrlab I. dial ==&gt; label( X ) : SisatX • diaClab ) . usage_note ==&gt; label( X 1. Such a mechanism captures generalities in typograp:4 conventions employed across any given dictionary, and yet preserves the distinct name spaces required for a meaningful &apos;unfolding&apos; of a dictionary entry structure. 5. RANGE OF PHENOMENA TO HANDLE Below we describe some typical phenomena encountered in the dictionaries we have parsed and discuss their treatment. 5.1 Messy token lists: controlling token consumption The unsystematic encoding of font changes before, as well as after, punctuation marks (commas, semicolons, parentheses) causes blind tokenization to remove punctuation marks from the data to which they are visually and conceptually attached. As already discussed (see 4.2), most errors of this nature can be corrected by retokenization. Similarly, the confusing effects of another pervasive error, namely the occurrence consecuti changes, can be avoided by having a retokenization rule simply remove all but the last one. In general, context sensitivity is handled by (re)adjusting the token list; retokenization, however, is only sensitive to local context. Since global context cannot be determined unequivocally till parsing, the grammar writer is given complete control over the consumption and addition of tokens as parsing proceeds from left to right — this allows for motivated recovery of ellisions, as well as discarding of tokens in local transformations. For instance, spurious occurrences of a font marker before a print symbol such as an opening parenthesis, which is not affected by a font declaration, clearly cannot be removed by a retokenization rule font( roman ) : bra &lt;=&gt; bra. (The marker may he genuinely closing a font segment prior to a different entry fragment which commences with, e.g., a left parenthesis). Instead, grammar rule anticipating a within its scope can readjust the token list using either of: : roman) : -bra : ins( bra ). ==&gt; : -font( roman : string( bra .*). tests for a token list with its first element.) 5.2 The Peter-1 principle: scoping phenomena Consider the entry for &amp;quot;Bankrott&amp;quot; in Figure 2. sharing the label collapse&amp;quot;) are grouped together with commas and separated from other lists with semicolons. The restriction (context or label) precedes the list and can be said to scope &apos;right&apos; to the next semicolon. We place the right-scoping labels or context unthe (semicolon-delimited) sister to the multiple (comma-delimited) nodes (see also the representation of &amp;quot;title&amp;quot; in Figure . 3). Two principles are at work here: mamtaming implicit evidence of synonymy among terms in the target language responds to the &amp;quot;do not discard anything&amp;quot; philosophy; placing common data items as high as possible in the tree (the &apos;Peter-minus-1 principle&apos;) is in the spirit of al. and implements the notion of placing a terminal node at the highest position in the tree where its value is valid in combination with the values at or below its sister nodes. The latter principle also motivates sets of rules like entry ==&gt; prow : homograph ... . homograph ==&gt; pron . used to account for entries in English where the pronunciation differs for different homographs. 5.3 Tribal memory: rule variables Some compaction or notational conventions in dictionaries require a mechanism for a rule to remember (part of) its ancestry or know its sister&apos;s descendants. Consider the problem of determining the scope of gender or labels immediately following variants of the headword: (Sw), (Aus) lawyer&apos;s office. (inn, Aus) , The first two entries show forms differing, respectively, in dialect and gender, and register and gender. The third illustrates other combinations. The rule accounting for labels after a variant must know whether items of like type have already been found after the headword, since items before the variant belong to the headword, different items of identical type following both belong individually, and all the rest are common to both. This &apos;tribal&apos; memory is implemented using rule variables: entry ==&gt; ( (dial : SIN=dial 1 ) I ( N=nodial ) 1 : opt( subhead( N)) . . subhead( N ) ==&gt; ... opt( SI Niodial 1 : opt(dial) : . In addition to enforcing rule constraints via unification, rule arguments also act as &apos;channels&apos; for node raising and as a mechanism for controlling rule behaviour depending on invocation context. This latter need stems from a pervasive phenomenon in dictionaries: the notational conventions for a logical unit within an entry persist across different contexts, and the sub-grammar for such a unit should be aware of the environment it is activated in. Implicit cross-references in LDOCE consistently introduced by small_caps ), independent of whether the running text is a de- (roman font), example (italic), or an em- 98 bedded phrase or idiom (bold); by enforcing the return to the font active before the invocation of allow the analysis of crossreferences to be shared: implicit_wrfl X ) ==&gt; -font( begin( smell caps ) ) : df_txt ==&gt; : implicit xrfiroman) txt ==&gt; : ==&gt; : implicit:xrf(bold) 5.4 Unpacking, duplication and movement of structures: node migration The whole range of phenomena requiring explicit manipulation of entry fragment trees is handled by the mechanisms for node raising, reordering, and deletion. Our analysis of implicit crossreferences in LDOCE factors them out as separate structural units participating in the make-up of a word sense definition, as well as reconstructs a &apos;text image&apos; of the definition text, with just the orthography of the cross-reference item &apos;spliced in&apos; (see Figure 4). def segs(0 String) : def:stringtO_String). del nugget(Seg) ( dif segs!Str 01 i = &amp;quot; toconcit(SegsStr_O,StL1). Ximplicit_xrf sit°, Ptr.nill.Rest)). -Sag : istringp(Seg). def_string1 Def ) ==&gt; ++Def. . The rules build a definition string from any seof substrings or lexical items as cross-references: by invoking the appropnate the simple segments are retained only for splicing the complete definition text; cross-reference pointers are extracted from the structural representation of an implicit crossand are propagated to a sister position to the string image is built incrementally (by string conas the individual ultimately the simply it into the structure for IDedef_string to strong non-terminals ultimately results in a deft, structure similar to the one illustrated in Figure 4. Copying and lateral migration of common gender labels in CEG translations, exemplified by &amp;quot;title&amp;quot; (Figure 3) and &amp;quot;abutment&amp;quot; (section 3.2), makes a different use of the +x operator. To capture the leftward scope of gender labels, in contrast to common (right-scopmg) context labels, we create, for each noun translation (trim), a gender node an empty value. The comma-delimited nodes are collected by a recursive weak nontrans ==&gt; tren(G) : opt( -au : trans(G) I. tran(G) ==&gt; ... word ... : opt( -XgenderI G1 ) : +Zgender( ) . (conditional) removal of the second rule followed by (obligatory) insertion of a captures the gender if present and &apos;digs a hole&apos; for it if absent. Unification on the iteration of the holes. Noun compound fragments, as in &amp;quot;abutment&amp;quot; can be copied and migrated forward or backward using the same mechanism. Since we have not implemented the noun compound parsing mechanism required for identification of segments to copied, we temporized by naming the needing partners 5.5 Conflated lexical entries: homograph unpacking We have implemented a mechanism to allow creation of additional entries out of a single one. for example from orthographic, dialect. or morphological variants of the original headword. Some CGE examples were given in sections 2 and 5.3 above. To handle these, the rules build the second entry inside the main one and manufacture cross reference information for both main form and variant, in anticipation of the implementation of a splitting mechanism. Examples of other types appear in both CGE and CEG: [...] (lit) Blutsauger m; (fig) Blutsauger m. n m. (boots) cpds Hausarrest m; -- Haus gefesselt; -hunt Haussuche sein; they started haben angefangen, nach einem Haus zu The conventions for morphological variants, used in e.g. LDOCE and Seventh, are different and would require a different mechanism. We have not yet developed a generalized rule mechanism for ordering any kind of split; indeed we do not know if it is possible, given the variation in seemingly act for &apos;sneaking in&apos; logically separate entries into related headword definitions: the case of &amp;quot;lachrymal gland&amp;quot; in 4.3 is just one instance of this phenomena; below we list some more conceptually similar, but notationally different, examples, demonstrating the embedding of homographs in the variant, run-on, word-sense and example fields of LDOCE. long legs loplegz (fml) fly type of flying insect with long legs bitterness, as of manner or language Im,kri&apos;mauniasi an acrimonious quarrel v ... 6 join (a party) without having been invited ... et.y.mol.o.gy changing of strahge or foreign words so that they become like quite common people say of that is an example of folk etymology defn def_segs(Str_1) def-nu9Get(Ptr) def-nugget(Seg) ==&gt; 99 5.6 Notational promiscuity: selective tokenization Often distinctly different data items appear contiguous in the same font: the grammar codes of LIDOCE (section 2) are just one example. Such run-together segments clearly need their own rules, which can only be when they are located during parsing. Thus, commas and parentheses take on special meaning the string &amp;quot;X(to respectively, ellision of data and optionality of phrase. This is a different interpretation from e.g. alter- (consider the meaning of noun&amp;quot;) the enclosing of italic labels in parentheses (Figure 3). Submission of a string token to further tokenization is best done by invoking a special purpose pattern matching module; thus we avoid global (and blind) tokenization on common (and ambiguous) characters such as punctuation marks. The functionality required for selective is provided by a below we demonstrate the construction of a list sister from a segment like adj&amp;quot;, invoking break a string into two substrings separated by a comma: syncets ==&gt; -seg : Sstrinsp(Seg) Sparse(Hd.&amp;quot; .Rest.nil, Sag) : insl(Hd.Rest.nil) : ==&gt; + ftsa(Seg, partofspeech). 5.7 Parsing failures: junk collection The systematic irregularity of dictionary data (see section 3.3) is only one problem when parsing dictionary entries. Parsing failures in general are common during grammar development; more specifically, they might arise due to the format of an entry segment being beyond (easy) capturing within the grammar formalism, or requiring nontrivial external functionality (such as compound word parsing or noun/verb phrase analysis). Typically, external procedures operate on a newly constructed string token which represents a `packed&apos; unruly token list. Alternatively, if no format need be assigned to the input, the grammar should be able to &apos;skip over&apos; the tokens in the list, collecting them under a `junk&apos; node. If data loss is not an issue for a specific application, there is no need even to collect tokens from irregular token lists; a simple rule to skip over USAGE fields might be written as usage ==&gt; -usage_mark : use_field. use_field ==&gt; -U Token : Snot(end ufield) : opT(use_field). these, building no structure, are especially convenient when extensive reorganization of the token list is required — typically in cases of grammar-driven token reordering or token deconsumption.) In order to achieve skipping over unparseable input without data loss, we have implemented a eenectiv, rule class. The structure built by such rules the (transitive) concatenation of all the strings daughter segments. Coping with gross irregularities is achieved by picking up number of tokens and `packing&apos; them tog.ether. This strategy is illustrated by a grammar for phrases conjoined with italic &apos;or&apos; in example sentences and/or their translations (see Figure 3). The italic conjunction is surrounded by slashes in the resulting collected string as an audit trail. The argument to following the strategy outlined in section 5.3, rule application only in the correct font context. strong_nonterminals (source .targ . nil). collectives (con) . nil). source ==&gt; conj(bold). targ ==&gt; con(roman). conj(X) ==&gt; -font(X) : +Seg : -font(ital) : ++&amp;quot; /&amp;quot; : +&amp;quot;or&amp;quot; • -font(X) : +Seg. Finally,. for the most complex cases of truly irregular input, a mechanism exists for constraining junk collection to operate only as a last resort and only at the point at which parsing can go no further. 5.8 Augmenting the power of the formalism: escape to Prolog Several of the mechanisms described above, such as contextual control of token consumption (section 5.1), explicit structure handling (5.4), or selective tokenization (5.6), are implemented as • separate Prolog. modules. Invoking such external functionality from the grammar rules allows the natural integration of the formand contentrecovery procedures into the top-down process of dictionary entry analysis. The utility of this device should be clear from the examples so far. Such escape to the underlying implementation language goes against the grain of recent developments of declarative grammar formalisms (the procedural ramifications of, for instance, being able to call arbitrary LISP functions from the arcs of an ATN grammar have been discussed at length: see, for instance, the opening chapters in al., However, we feel justified in augmenting the formalism in such a way, as we are dealing with input which is different in nature from, and on occasions possibly more complex than, straight natural language. Unhomogeneous mixtures of heavily formal notations annotations in free interspersed with (occasionally incomplete) fragments of natural language phrases, can easily defeat any at `clean&apos; parsing. Since the sysdesigned to deal with an open-ended set of dictionaries, it must be able to confront a similarly open-ended set of notational conventions and abbreviatory devices. Furthermore. dealing in full with some of these notations requires access to mechanisms and theories well beyond the power of any grammar formalism: consider, for instance, what is involved in analyzing pronunciation fields in a dictionary, where alternative pronunciation patterns are marked only for which differ from the primary pronun- (as in pronunciation string itself is marked for syllable structure; and where the assignment of syllable boundaries is far from trivial in 100 6. CURRENT STATUS The run-time environment of DEP includes grammar debugging utilities, and a number of options. All facilities have been implemented, except where noted. We have very detailed ars for CGE (parsing 98% of the entries), and LDOCE (93%); less detailed for Seventh and both grammars French Dictionary (approximately 90%). The Dictionary Entry Parser is an integral part of a larger system designed to recover dictionary structure to an arbitrary depth of detail, convert the resulting trees into LDB records, and make the data available to end users via a flexible and powerful lexical query language (LQL). Indeed, we have built LDB&apos;s for all dictionaries we have parsed; further development of LQL and the exploitation of the LDB&apos;s via query for a number of lexical studies are separate projects. Finally, we note that, in the light of recent efforts to develop an interchange standard for (English mono-lingual) dictionaries (Amsler and Tompa, 1988), DEP acquires additional relevance, since it can be used, given a suitable annotation of the grammar rules for the machine-readable source, to transduce a typesetting tape into an interchangeable dictionary source, available to a larger user community. ACKNOWLEDGEMENTS We would like to thank Roy Byrd, Judith Klavans and Beth Levin for many discussions concerning the Dictionary Entry Parser system in general, and this paper in particular. Any remaining errors are ours, and ours only.</abstract>
<note confidence="0.731554706896552">REFERENCES Ahlswede, T, M Evens, K Rossi and J Markowitz (1986) &amp;quot;Building a Lexical Database by Parsing Seventh New Collegiate in Lexicology, Annual Conference of the UW Centre for the New Oxford English Dictionary, 65— 78. Amsler, R and F Tompa (1988) &amp;quot;An SGML-Based Standard for English Monolingual in Text, Annual Conference of the UW Centre for the New Oxford English Dictionary, 61 — 79. B, and E Briscoe (Eds) (1989) Computational Lexicography for Natural Language Harlow. Byrd, R, N Calzolari, M Chodorow, J Klavans, M Neff and 0 Rizk (1987) &amp;quot;Tools and Methods Computational Lexicology&amp;quot;, —4), 219-240. Calzolari, N and E Picchi (1986) &amp;quot;A Project for Bilingual Lexical Database System&amp;quot;, Lexicology, Annual Conference of the UW Centre for the New Oxford English Dictionary, 79— 92. Calzolari, N and E Picchi (1988) &amp;quot;Acquisition of Semantic Information from an On-Line of the 12th International Conference on Computational Linguistics, 87— 92. (1980) German Dictionary: English, English— German, Publishers, Glasgow. (1984) Nuovo Dizionario Italiano Milano. (1978) Dictionary of Con- English, Group, London. Dadam, P, K Kuespert, F Andersen, H Blanken, R Erbe, J Guenauer, V Lum, P Pistor and G Walsh (1986) &amp;quot;A DBMS Prototype to Support Extended NF2 Relations: An Integrated View on Tables and Hierarchies&amp;quot;, of ACM SIGMOD`86: International Conference on of Data, — 367. D, C Pollard, T Wasow &amp;quot;Structure Sharing in Lexical Representation&amp;quot;, Proceedings of the 23rd Annual Meeting of the Association for Computational Linguistics, 262— 267. Fox, E, T Nutter, T Alhswede, M Evens and J Markowitz (1988) &amp;quot;Building a Large Thesaurus Information Retrieval&amp;quot;, of the Second Conference on Applied Natural Language 108. R (1986) the Text of the Oxford English Dictionary through Finite State of Waterloo Technical Report No. TR —86— 20. McCord, M (1987) &amp;quot;Natural Language Process-</note>
<author confidence="0.522333">ing</author>
<author confidence="0.522333">in A Walker Prolog</author>
<author confidence="0.522333">M McCord</author>
<author confidence="0.522333">J</author>
<affiliation confidence="0.753513">and W Wilson (Eds) Systems</affiliation>
<address confidence="0.857011">Prolog, Waltham, Massachusetts, 291-402.</address>
<note confidence="0.6734109375">Nakamura, J and Makoto N (1988) &amp;quot;Extraction of Semantic Information from an Ordinary Eng- Dictionary and Its Evaluation&amp;quot;, of the 12th International Conference on Computa- Linguistics, Neff, M, R Byrd and 0 Rizk (1988) &amp;quot;Creating and Querying Hierarchical Lexical Data Bases&amp;quot;, Proceedings of the Second Conference on Applied Language Processing, 93. van der Steen, G J (1982) &amp;quot;A Treatment of Quein Large Text Corpora&amp;quot;, in S Johansson Computer Corpora in English Language Computing Centre for the Bergen, 49— F (1986) Design for a Dicof the Future&amp;quot;, of Waterloo,</note>
<email confidence="0.555661">unpublished.</email>
<affiliation confidence="0.7338955">(1967) Seventh New Collegiate Merriam Company,</affiliation>
<address confidence="0.789926">Springfield, Massachussetts.</address>
<note confidence="0.7389002">Whitelock, P, M Wood, H Somers, R Johnson P Bennett (Eds) (1987) Theory and Applications, Academic New York. 1 0 1</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>T Ahlswede</author>
<author>M Evens</author>
<author>K Rossi</author>
<author>J Markowitz</author>
</authors>
<title>Building a Lexical Database by Parsing Webster&apos;s Seventh New Collegiate Dictionary&apos;,</title>
<date>1986</date>
<booktitle>Advances in Lexicology, Second Annual Conference of the UW Centre for the New Oxford English Dictionary,</booktitle>
<volume>65</volume>
<pages>78</pages>
<marker>Ahlswede, Evens, Rossi, Markowitz, 1986</marker>
<rawString>Ahlswede, T, M Evens, K Rossi and J Markowitz (1986) &amp;quot;Building a Lexical Database by Parsing Webster&apos;s Seventh New Collegiate Dictionary&apos;, Advances in Lexicology, Second Annual Conference of the UW Centre for the New Oxford English Dictionary, 65— 78.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Amsler</author>
<author>F Tompa</author>
</authors>
<title>An SGML-Based Standard for English Monolingual Dictionaries&amp;quot;, Information in Text,</title>
<date>1988</date>
<booktitle>Fourth Annual Conference of the UW Centre for the New Oxford English Dictionary, 61 — 79.</booktitle>
<marker>Amsler, Tompa, 1988</marker>
<rawString>Amsler, R and F Tompa (1988) &amp;quot;An SGML-Based Standard for English Monolingual Dictionaries&amp;quot;, Information in Text, Fourth Annual Conference of the UW Centre for the New Oxford English Dictionary, 61 — 79.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Boguraev</author>
<author>E Briscoe</author>
</authors>
<date>1989</date>
<booktitle>Computational Lexicography for Natural Language Processing,</booktitle>
<location>Longman, Harlow.</location>
<contexts>
<context position="3500" citStr="Boguraev and Briscoe, 1989" startWordPosition="540" endWordPosition="543">maximal use of MRD&apos;s, it is necessary to make their data, as well as structure, fully explicit, in a data base format that lends itself to flexible querying. However, since none of the lexical data base (LDB) creation efforts to date fully addresses both of these issues, they fail to offer a general framework for processing the wide range of dictionary resources available in machine-readable form. As one extreme, the conversion of an MRD into an LDB may be carried out by a `one-off program — such as, for example, used for the Longman Dictionary of Contemporary English (LDOCE) and described in Boguraev and Briscoe, 1989. While the resulting LDB is quite explicit and complete with respect to the data in the source, all knowledge of the dictionary structure is embodied in the conversion program. On the other hand, more modular architectures consisting of a parser and a grammar — best exemplified by Kazrnan&apos;s (1986) analysis of the Oxford English Dictionary (OED) — do not deliver the structurally rich and explicit LDB ideally required for easy and unconstrained access to the source data. The majority of computational lexicography projects, in fact, fall in the first of the categories above, in that they typical</context>
</contexts>
<marker>Boguraev, Briscoe, 1989</marker>
<rawString>Boguraev, B, and E Briscoe (Eds) (1989) Computational Lexicography for Natural Language Processing, Longman, Harlow.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Byrd</author>
<author>N Calzolari</author>
<author>M Chodorow</author>
<author>J Klavans</author>
</authors>
<title>Tools and Methods for Computational Lexicology&amp;quot;,</title>
<date>1987</date>
<journal>M Neff and</journal>
<volume>0</volume>
<pages>219--240</pages>
<location>Rizk</location>
<contexts>
<context position="6159" citStr="Byrd et al., 1987" startWordPosition="968" endWordPosition="971">n detailed parse trees for individual entries. Furthermore, unlike the tagging of the OED, carried out in several passes over the data and using different grammars (in order to cope with the highly complex, idiosyncratic and ambiguous nature of dictionary entries), we employ a parsing engine exploiting unification and backtracking, and using a single grammar consisting of three different sets of rules. The advantages of handling the structural complexities of MRD sources and deriving corresponding LDB&apos;s in one operation become clear below. While DEP has been described in general terms before (Byrd et al., 1987; Neff et aL, 1988), this paper draws on our experience in parsing the Collins German-English I Collins English-German (CGE/CEG) and LDOCE dictionaries, which represent two very different types of machinereadable sources vis-a-vis format of the typesetting tapes and notational conventions exploited by the lexicographers. We examine more closely some of the phenomena encountered in these dictionaries, trace their implications for MRD-to-LDB parsing, show how they motivate the design of the DEP grammar formalism, and discuss treatment of typical entry configurations. 2. STRUCTURAL PROPERTIES OF </context>
</contexts>
<marker>Byrd, Calzolari, Chodorow, Klavans, 1987</marker>
<rawString>Byrd, R, N Calzolari, M Chodorow, J Klavans, M Neff and 0 Rizk (1987) &amp;quot;Tools and Methods for Computational Lexicology&amp;quot;, Computational Linguistics, vol.13(3 —4), 219-240.</rawString>
</citation>
<citation valid="true">
<authors>
<author>N Calzolari</author>
<author>E Picchi</author>
</authors>
<title>A Project for a Bilingual Lexical Database System&amp;quot;,</title>
<date>1986</date>
<booktitle>Advances in Lexicology, Second Annual Conference of the UW Centre for the New Oxford English Dictionary,</booktitle>
<volume>79</volume>
<pages>92</pages>
<contexts>
<context position="4557" citStr="Calzolari and Picchi, 1986" startWordPosition="712" endWordPosition="715">and unconstrained access to the source data. The majority of computational lexicography projects, in fact, fall in the first of the categories above, in that they typically concentrate on the conversion of a single dictionary into an LDB: examples here include the work by e.g. Ahlswede et at., 1986, on The Webster&apos;s Seventh New Collegiate Dictionary; Fox et at., 1988, on The Collins English Dictionary; Calzolari and Picchi, 1988, on II Nuovo Dizionario Italiano Garzanti; van der Steen, 1982, and Nakamura, 1988, on LDOCE. Even work based on multiple dictionaries (e.g. in bilingual context: see Calzolari and Picchi, 1986) appear to have used specialized programs for each dictionary source. In addition, not an uncommon property of the LDB&apos;s cited above is their incompleteness with respect to the ongmal source: there is a tendency to extract, in a pre-processing phase, only some fragments (e.g. 9 1 part of speech information or definition fields) while ignoring others (e.g. etymology, pronunciation or usage notes). We have built a Dictionary Entry Parser (DEP) together with grammars for several different dictionaries. Our goal has been to create a general mechanism for converting to a common LDB format a wide ra</context>
</contexts>
<marker>Calzolari, Picchi, 1986</marker>
<rawString>Calzolari, N and E Picchi (1986) &amp;quot;A Project for a Bilingual Lexical Database System&amp;quot;, Advances in Lexicology, Second Annual Conference of the UW Centre for the New Oxford English Dictionary, 79— 92.</rawString>
</citation>
<citation valid="true">
<authors>
<author>N Calzolari</author>
<author>E Picchi</author>
</authors>
<title>Acquisition of Semantic Information from an On-Line Dictionary.&amp;quot;,</title>
<date>1988</date>
<booktitle>Proceedings of the 12th International Conference on Computational Linguistics, 87—</booktitle>
<pages>92</pages>
<contexts>
<context position="4362" citStr="Calzolari and Picchi, 1988" startWordPosition="681" endWordPosition="684">f a parser and a grammar — best exemplified by Kazrnan&apos;s (1986) analysis of the Oxford English Dictionary (OED) — do not deliver the structurally rich and explicit LDB ideally required for easy and unconstrained access to the source data. The majority of computational lexicography projects, in fact, fall in the first of the categories above, in that they typically concentrate on the conversion of a single dictionary into an LDB: examples here include the work by e.g. Ahlswede et at., 1986, on The Webster&apos;s Seventh New Collegiate Dictionary; Fox et at., 1988, on The Collins English Dictionary; Calzolari and Picchi, 1988, on II Nuovo Dizionario Italiano Garzanti; van der Steen, 1982, and Nakamura, 1988, on LDOCE. Even work based on multiple dictionaries (e.g. in bilingual context: see Calzolari and Picchi, 1986) appear to have used specialized programs for each dictionary source. In addition, not an uncommon property of the LDB&apos;s cited above is their incompleteness with respect to the ongmal source: there is a tendency to extract, in a pre-processing phase, only some fragments (e.g. 9 1 part of speech information or definition fields) while ignoring others (e.g. etymology, pronunciation or usage notes). We ha</context>
</contexts>
<marker>Calzolari, Picchi, 1988</marker>
<rawString>Calzolari, N and E Picchi (1988) &amp;quot;Acquisition of Semantic Information from an On-Line Dictionary.&amp;quot;, Proceedings of the 12th International Conference on Computational Linguistics, 87— 92.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Collins</author>
</authors>
<title>Collins German Dictionary:</title>
<date>1980</date>
<location>German— English, English— German, Collins Publishers, Glasgow.</location>
<marker>Collins, 1980</marker>
<rawString>Collins (1980) Collins German Dictionary: German— English, English— German, Collins Publishers, Glasgow.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Garzanti</author>
</authors>
<title>II Nuovo Dizionario Italiano Garzanti,</title>
<date>1984</date>
<location>Garzanti, Milano.</location>
<marker>Garzanti, 1984</marker>
<rawString>Garzanti (1984) II Nuovo Dizionario Italiano Garzanti, Garzanti, Milano.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Longman</author>
</authors>
<title>Longman Dictionary of Contemporary English,</title>
<date>1978</date>
<publisher>Longman Group,</publisher>
<location>London.</location>
<marker>Longman, 1978</marker>
<rawString>Longman (1978) Longman Dictionary of Contemporary English, Longman Group, London.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Dadam</author>
<author>K Kuespert</author>
<author>F Andersen</author>
<author>H Blanken</author>
<author>R Erbe</author>
<author>J Guenauer</author>
<author>V Lum</author>
<author>P Pistor</author>
<author>G Walsh</author>
</authors>
<title>A DBMS Prototype to Support Extended NF2 Relations: An Integrated View on Flat Tables and Hierarchies&amp;quot;,</title>
<date>1986</date>
<booktitle>Proceedings of ACM SIGMOD`86: International Conference on Management of Data, 356 —</booktitle>
<pages>367</pages>
<marker>Dadam, Kuespert, Andersen, Blanken, Erbe, Guenauer, Lum, Pistor, Walsh, 1986</marker>
<rawString>Dadam, P, K Kuespert, F Andersen, H Blanken, R Erbe, J Guenauer, V Lum, P Pistor and G Walsh (1986) &amp;quot;A DBMS Prototype to Support Extended NF2 Relations: An Integrated View on Flat Tables and Hierarchies&amp;quot;, Proceedings of ACM SIGMOD`86: International Conference on Management of Data, 356 — 367.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Flickinger</author>
<author>C Pollard</author>
<author>T Wasow</author>
</authors>
<title>Structure Sharing in Lexical Representation&amp;quot;,</title>
<date>1985</date>
<booktitle>Proceedings of the 23rd Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>262--267</pages>
<contexts>
<context position="39213" citStr="Flickinger et al. (1985)" startWordPosition="6175" endWordPosition="6178">h semicolons. The restriction (context or label) precedes the list and can be said to scope &apos;right&apos; to the next semicolon. We place the right-scoping labels or context under the (semicolon-delimited) tran_group as sister nodes to the multiple (comma-delimited) tran nodes (see also the representation of &amp;quot;title&amp;quot; in Figure . 3). Two principles are at work here: mamtaming implicit evidence of synonymy among terms in the target language responds to the &amp;quot;do not discard anything&amp;quot; philosophy; placing common data items as high as possible in the tree (the &apos;Peter-minus-1 principle&apos;) is in the spirit of Flickinger et al. (1985), and implements the notion of placing a terminal node at the highest position in the tree where its value is valid in combination with the values at or below its sister nodes. The latter principle also motivates sets of rules like entry ==&gt; prow : homograph ... . homograph ==&gt; pron . used to account for entries in English where the pronunciation differs for different homographs. 5.3 Tribal memory: rule variables Some compaction or notational conventions in dictionaries require a mechanism for a rule to remember (part of) its ancestry or know its sister&apos;s descendants. Consider the problem of d</context>
</contexts>
<marker>Flickinger, Pollard, Wasow, 1985</marker>
<rawString>Flickinger, D, C Pollard, T Wasow (1985) &amp;quot;Structure Sharing in Lexical Representation&amp;quot;, Proceedings of the 23rd Annual Meeting of the Association for Computational Linguistics, 262— 267.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Fox</author>
<author>T Nutter</author>
<author>T Alhswede</author>
<author>M Evens</author>
<author>J Markowitz</author>
</authors>
<title>Building a Large Thesaurus for Information Retrieval&amp;quot;,</title>
<date>1988</date>
<booktitle>Proceedings of the Second Conference on Applied Natural Language Processing,</booktitle>
<volume>101</volume>
<pages>108</pages>
<marker>Fox, Nutter, Alhswede, Evens, Markowitz, 1988</marker>
<rawString>Fox, E, T Nutter, T Alhswede, M Evens and J Markowitz (1988) &amp;quot;Building a Large Thesaurus for Information Retrieval&amp;quot;, Proceedings of the Second Conference on Applied Natural Language Processing, 101— 108.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Kazman</author>
</authors>
<title>Structuring the Text of the Oxford English Dictionary through Finite State Transduction&amp;quot;,</title>
<date>1986</date>
<tech>Technical Report No. TR —86—</tech>
<pages>20</pages>
<institution>University of Waterloo</institution>
<marker>Kazman, 1986</marker>
<rawString>Kazman, R (1986) &amp;quot;Structuring the Text of the Oxford English Dictionary through Finite State Transduction&amp;quot;, University of Waterloo Technical Report No. TR —86— 20.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M McCord</author>
</authors>
<title>Natural Language Processing and Prolog&amp;quot;, in A</title>
<date>1987</date>
<pages>291--402</pages>
<publisher>Addison-Wesley,</publisher>
<location>Waltham, Massachusetts,</location>
<contexts>
<context position="20802" citStr="McCord (1987)" startWordPosition="3301" endWordPosition="3302">pesetting tape with &apos;begin-end&apos; boundaries of entries explicitly marked) and, by consulting an externally supplied grammar specific for that particular dictionary, produces exphcit structural representations for the individual entries, which are either displayed or loaded into an LDB. The system consists of a rule compiler, a parsing engine, a dictionary entry template generator, an LDB loader, and various development facilities, all in a PROLOG shell. User-written PROLOG functions and primitives are easily added to the system. The formalism and rule compiler use the Modular Logic Grammars of McCord (1987) as a point of departure, but they have been substantially modified and extended to reflect the requirements of parsing dictionary entries. The compiler accepts three different kinds of rules corresponding to the three phases of dictionary entry analysis: tokenization, retokenization, and parsing proper. Below we present informally highlights of the grammar formalism. 4.1 Tokenization Unlike in sentence parsing, where tokenization (or lexical analysis) is driven entirely by blanks and punctuation, the DEP grammar writer explicitly defines token delimiters and token substitutions. Tokenization </context>
</contexts>
<marker>McCord, 1987</marker>
<rawString>McCord, M (1987) &amp;quot;Natural Language Processing and Prolog&amp;quot;, in A Walker, M McCord, J Sowa and W Wilson (Eds) Knowledge Systems and Prolog, Addison-Wesley, Waltham, Massachusetts, 291-402.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Nakamura</author>
<author>N Makoto</author>
</authors>
<title>Extraction of Semantic Information from an Ordinary English Dictionary and Its Evaluation&amp;quot;,</title>
<date>1988</date>
<booktitle>Proceedings of the 12th International Conference on Computational Linguistics,</booktitle>
<pages>459--464</pages>
<marker>Nakamura, Makoto, 1988</marker>
<rawString>Nakamura, J and Makoto N (1988) &amp;quot;Extraction of Semantic Information from an Ordinary English Dictionary and Its Evaluation&amp;quot;, Proceedings of the 12th International Conference on Computational Linguistics, 459-464.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Neff</author>
<author>R Byrd</author>
</authors>
<title>Creating and Querying Hierarchical Lexical Data Bases&amp;quot;,</title>
<date>1988</date>
<booktitle>Proceedings of the Second Conference on Applied Natural Language Processing,</booktitle>
<volume>84</volume>
<pages>93</pages>
<marker>Neff, Byrd, 1988</marker>
<rawString>Neff, M, R Byrd and 0 Rizk (1988) &amp;quot;Creating and Querying Hierarchical Lexical Data Bases&amp;quot;, Proceedings of the Second Conference on Applied Natural Language Processing, 84— 93.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G J van der Steen</author>
</authors>
<title>A Treatment of Queries in Large Text Corpora&amp;quot;,</title>
<date>1982</date>
<journal>in S Johansson (Ed) Computer Corpora in English Language Research, Norwegian Computing Centre for the Humanities, Bergen,</journal>
<volume>49</volume>
<pages>6</pages>
<marker>van der Steen, 1982</marker>
<rawString>van der Steen, G J (1982) &amp;quot;A Treatment of Queries in Large Text Corpora&amp;quot;, in S Johansson (Ed) Computer Corpora in English Language Research, Norwegian Computing Centre for the Humanities, Bergen, 49— 6.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Tompa</author>
</authors>
<title>Database Design for a Dictionary of the Future&amp;quot;,</title>
<date>1986</date>
<location>University of Waterloo, unpublished.</location>
<contexts>
<context position="9600" citStr="Tompa, 1986" startWordPosition="1517" endWordPosition="1518"> with no explicit structure markings (as OED and the Collins bilinguals exemplify); all of their structure is implied in the font changes and the overall syntax of the entry. On the other hand, sources may employ mixed representation, incorporating both global record delimiters and local structure encoded in font change codes and/or special character sequences (LDOCE and Webster&apos;s Seventh). Ideally, all MRD&apos;s should be mapped onto LDB structures of the same type, accessible with a single query language that preserves the user&apos;s intuition about the structure of lexical data (Neff et al., 1988; Tompa, 1986). Dictionary entries can be naturally represented as shallow hierarchies with a variable number of instances of certain items at each level, e.g. multiple homographs within an entry or multiple senses within a homograph. The usual inheritance mechanisms associated with a hierarchical organisation of data not only ensure compactness of representation, but also fit lexical intuitions. The figures overleaf show sample entries from CGE and LDOCE and their LDB forms with explicitly &apos;unfolded&apos; structure. Within the taxonomy of normal forms (NF) defined by relational data base theory, dictionary entr</context>
</contexts>
<marker>Tompa, 1986</marker>
<rawString>Tompa, F (1986) &amp;quot;Database Design for a Dictionary of the Future&amp;quot;, University of Waterloo, unpublished.</rawString>
</citation>
<citation valid="true">
<title>Webster&apos;s Seventh New Collegiate Dictionary,</title>
<date>1967</date>
<publisher>Company,</publisher>
<location>C.8LC. Merriam</location>
<marker>1967</marker>
<rawString>W7 (1967) Webster&apos;s Seventh New Collegiate Dictionary, C.8LC. Merriam Company, Springfield, Massachussetts.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Whitelock</author>
<author>M Wood</author>
<author>H Somers</author>
<author>R Johnson</author>
<author>P Bennett</author>
</authors>
<title>Linguistic Theory and Computer Applications,</title>
<date>1987</date>
<publisher>Academic Press,</publisher>
<location>New York.</location>
<contexts>
<context position="51017" citStr="Whitelock et al., 1987" startWordPosition="8056" endWordPosition="8059">odules. Invoking such external functionality from the grammar rules allows the natural integration of the form- and contentrecovery procedures into the top-down process of dictionary entry analysis. The utility of this device should be clear from the examples so far. Such escape to the underlying implementation language goes against the grain of recent developments of declarative grammar formalisms (the procedural ramifications of, for instance, being able to call arbitrary LISP functions from the arcs of an ATN grammar have been discussed at length: see, for instance, the opening chapters in Whitelock et al., 1987). However, we feel justified in augmenting the formalism in such a way, as we are dealing with input which is different in nature from, and on occasions possibly more complex than, straight natural language. Unhomogeneous mixtures of heavily formal notations and annotations in totally free format, interspersed with (occasionally incomplete) fragments of natural language phrases, can easily defeat any attempts at `clean&apos; parsing. Since the DEP system is designed to deal with an open-ended set of dictionaries, it must be able to confront a similarly open-ended set of notational conventions and a</context>
</contexts>
<marker>Whitelock, Wood, Somers, Johnson, Bennett, 1987</marker>
<rawString>Whitelock, P, M Wood, H Somers, R Johnson and P Bennett (Eds) (1987) Linguistic Theory and Computer Applications, Academic Press, New York.</rawString>
</citation>
<citation valid="false">
<volume>1</volume>
<marker></marker>
<rawString>1 0 1</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>