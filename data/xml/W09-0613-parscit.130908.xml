<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.009834">
<title confidence="0.989731">
SimpleNLG: A realisation engine for practical applications
</title>
<author confidence="0.989269">
Albert Gatt and Ehud Reiter
</author>
<affiliation confidence="0.9978715">
Department of Computing Science
University of Aberdeen
</affiliation>
<address confidence="0.975163">
Aberdeen AB24 3UE, UK
</address>
<email confidence="0.999676">
{a.gatt,e.reiter}@abdn.ac.uk
</email>
<sectionHeader confidence="0.9974" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999689285714286">
This paper describes SimpleNLG, a re-
alisation engine for English which aims
to provide simple and robust interfaces to
generate syntactic structures and linearise
them. The library is also flexible in al-
lowing the use of mixed (canned and non-
canned) representations.
</bodyText>
<sectionHeader confidence="0.999645" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999037586206897">
Over the past several years, a significant consensus
has emerged over the definition of the realisation
task, through the development of realisers such as
REALPRO (Lavoie and Rambow, 1997), ALETH-
GEN (Coch, 1996), KPML (Bateman, 1997),
FUF/SURGE (Elhadad and Robin, 1996), HALO-
GEN (Langkilde, 2000), YAG (McRoy et al., 2000),
and OPENCCG (White, 2006).
Realisation involves two logically distinguish-
able tasks. Tactical generation involves making
appropriate linguistic choices given the semantic
input. However, once tactical decisions have been
taken, building a syntactic representation, apply-
ing the right morphological operations, and lin-
earising the sentence as a string are comparatively
mechanical tasks. With the possible exception
of template-based realisers, such as YAG, exist-
ing wide-coverage realisers usually carry out both
tasks. By contrast, a realisation engine focuses on
the second of the two tasks, making no commit-
ments as to how semantic inputs are mapped to
syntactic outputs. This leaves the (tactical) prob-
lem of defining mappings from semantic inputs
to morphosyntactic structures entirely up to the
developer, something which may be attractive in
those applications where full control of the out-
put of generation is required. Such control is not
always easily available in wide-coverage tactical
generators, for a number of reasons:
</bodyText>
<listItem confidence="0.975281533333333">
1. Many such realisers define an input formal-
ism, which effectively circumscribes the (se-
mantic) space of possibilities that the realiser
handles. The developer needs to ensure that
the input to realisation is mapped to the req-
uisite formalism.
2. Since the tactical problem involves search
through a space of linguistic choices, the
broader the coverage, the more efficiency
may be compromised. Where real-time de-
ployment is a goal, this may be an obstacle.
3. Many application domains have sub-
language requirements. For example, the
language used in summaries of weather data
(Reiter et al., 2005) or patient information
</listItem>
<bodyText confidence="0.87183172">
(Portet et al., to appear) differs from standard
usage, and does not always allow variation
to the same extent. Since realisers don’t
typically address such requirements, their
use in a particular application may require
the alteration of the realiser’s rule-base or,
in the case of statistical realisers, re-training
on large volumes of appropruately annotated
data.
This paper describes SimpleNLG, a realisa-
tion engine which grew out of recent experiences
in building large-scale data-to-text NLG systems,
whose goal is to summarise large volumes of nu-
meric and symbolic data (Reiter, 2007). Sub-
language requirements and efficiency are impor-
tant considerations in such systems. Although
meeting these requirements was the initial motiva-
tion behind SimpleNLG, it has since been devel-
oped into an engine with significant coverage of
English syntax and morphology, while at the same
time providing a simple API that offers users di-
rect programmatic control over the realisation pro-
cess.
Proceedings of the 12th European Workshop on Natural Language Generation, pages 90–93,
Athens, Greece, 30 – 31 March 2009. c�2009 Association for Computational Linguistics
</bodyText>
<page confidence="0.991599">
90
</page>
<table confidence="0.999956214285714">
Feature Values Applicable classes
lexical ADJPOSITION Attrib1/2/3, PostNominal, Predicative ADJ
ADVPOSITION Sentential, PostVerbal, Verbal ADV
AGRTYPE Count, Mass, Group, Inv-Pl, Inv-Sg N
COMPLTYPE AdjP, AdvP, B-Inf, WhFin, WhInf, ... V
VTYPE Aux, Main, Modal V
phrasal FUNCTION Subject, Obj, I-Obj, Prep-Obj, Modifier all
SFORM B-Inf, Gerund, Imper, Inf, Subj S
INTERROGTYPE Yes/No, How, What,... S
NUMBERAGR Plural, Singular NP
TENSE Pres, Past, Fut VP
TAXIS (boolean) true (=perfective), false VP
POSSESSIVE (boolean) true (=possessive), false NP
PASSIVE (boolean) true, false VP
</table>
<tableCaption confidence="0.9979">
Table 1: Features and values available in SimpleNLG
</tableCaption>
<sectionHeader confidence="0.789903" genericHeader="method">
2 Overview of SimpleNLG
</sectionHeader>
<bodyText confidence="0.997905454545455">
SimpleNLG is a Java library that provides inter-
faces offering direct control over the realisation
process, that is, over the way phrases are built and
combined, inflectional morphological operations,
and linearisation. It defines a set of lexical and
phrasal types, corresponding to the major gram-
matical categories, as well as ways of combining
these and setting various feature values. In con-
structing a syntactic structure and linearising it as
text with SimpleNLG, the following steps are un-
dertaken:
</bodyText>
<listItem confidence="0.9874558">
1. Initialisation of the basic constituents re-
quired, with the appropriate lexical items;
2. Using the operations provided in the API to
set features of the constituents, such as those
in bottom panel of Table 1;
3. Combining constituents into larger struc-
tures, again using the operations provided in
the API which apply to the constituents in
question;
4. Passing the resulting structure to the lin-
</listItem>
<bodyText confidence="0.998368035714286">
eariser, which traverses the constituent struc-
ture, applying the correct inflections and lin-
ear ordering depending on the features, be-
fore returning the realised string.
Constituents in SimpleNLG can be a mixture
of canned and non-canned representations. This
is useful in applications where certain inputs can
be mapped to an output string in a deterministic
fashion, while others require a more flexible map-
ping to outputs depending, for example, on seman-
tic features and context. SimpleNLG tries to meet
these needs by providing significant syntactic cov-
erage with the added option of combining canned
and non-canned strings.
Another aim of the engine is robustness: struc-
tures which are incomplete or not well-formed will
not result in a crash, but typically will yield infe-
licitous, though comprehensible, output. This is a
feature that SimpleNLG shares with YAG (McRoy
et al., 2000). A third design criterion was to
achieve a clear separation between morphological
and syntactic operations. The lexical component
of the library, which includes a wide-coverage
morphological generator, is distinct from the syn-
tactic component. This makes it useful for applica-
tions which do not require complex syntactic op-
erations, but which need output strings to be cor-
rectly inflected.
</bodyText>
<subsectionHeader confidence="0.987409">
2.1 Lexical operations
</subsectionHeader>
<bodyText confidence="0.999219176470588">
The lexical component provides interfaces that de-
fine a Lexicon, a MorphologicalRule, and
a LexicalTtem, with subtypes for different lex-
ical classes (Noun, Preposition etc). Mor-
phological rules, a re-implementation of those in
MORPHG (Minnen et al., 2001), cover the full
range of English inflection, including regular and
irregular forms1. In addition to the range of mor-
phological operations that apply to them, various
features can be specified for lexical items. For ex-
ample, as shown in the top panel of Table 1, ad-
jectives and adverbs can be specified for their typ-
ical syntactic positions. Thus, an adjective such
as red would have the values Attrib2, indicating
that it usually occurs in attribute position 2 (fol-
lowing Attrib1 adjectives such as large), and Pred-
icative. Similarly, nouns are classified to indicate
</bodyText>
<footnote confidence="0.866865">
1Thanks are due to John Carroll at the University of Sus-
sex for permission to re-use these rules.
</footnote>
<page confidence="0.997428">
91
</page>
<bodyText confidence="0.9998335">
their agreement features (count, mass, etc), while
verbs can be specified for the range of syntactic
complement types they allow (e.g. bare infinitives
and WH-complements).
A typical development scenario involves the
creation of a Lexicon, the repository of the rel-
evant items and their properties. Though this
can be done programmatically, the current distri-
bution of SimpleNLG provides an interface to a
database constructed from the NIH Specialist Lexi-
con2, a large (&gt; 300,000 entries) repository of lex-
ical items in the medical and general English do-
mains, which incorporates information about lexi-
cal features such as those in Table 1.
</bodyText>
<subsectionHeader confidence="0.997887">
2.2 Syntactic operations
</subsectionHeader>
<bodyText confidence="0.999960151515152">
The syntactic component of SimpleNLG de-
fines interfaces for HeadedPhrase and
CoordinatePhrase. Apart from various
phrasal subtypes (referred to as PhraseSpecs)
following the usage in Reiter and Dale (2000)),
several grammatical features are defined, includ-
ing Tense, Number, Person and Mood (see
Table 1). In addition, a StringPhraseSpec
represents a piece of canned text of arbitrary
length.
A complete syntactic structure is achieved by
initialising constituents with the relevant fea-
tures, and combining them using the operations
specified by the interface. Any syntactic struc-
ture can consist of a mixture of Phrase or
CoordinatePhrase types and canned strings.
The input lexical items to phrase constructors can
themselves be either strings or lexical items as de-
fined in the lexical component. Once syntactic
structures have been constructed, they are passed
to a lineariser, which also handles basic punctua-
tion and other orthographic conventions (such as
capitalisation).
The syntactic component covers the full range
of English verbal forms, including participals,
compound tenses, and progressive aspect. Sub-
types of CoordinatePhrase allow for fully
recursive coordination. As shown in the bottom
panel of Figure 1, subjunctive forms and different
kinds of interrogatives are also handled using the
same basic feature-setting mechanism.
The example below illustrates one way of con-
structing the phrase the boys left the house, ini-
</bodyText>
<footnote confidence="0.8004095">
2http://lexsrv3.nlm.nih.gov/
SPECIALIST/index.html
</footnote>
<bodyText confidence="0.99984425">
tialising a sentence with the main verb leave
and setting a Tense feature. Note that the
SPhraseSpec interface allows the setting of the
main verb, although this is internally represented
as the head of a VPPhraseSpec dominated by
the clause. An alternative would be to construct
the verb phrase directly, and set it as a constituent
of the sentence. Similarly, the direct object, which
is specified directly as a constituent of the sen-
tence, is internally represented as the object of the
verb phrase. In this example, the direct object
is an NPPhraseSpec consisting of two words,
passed as arguments and internally rendered as
lexical items of type Determiner and Noun re-
spectively. By contrast, the subject is defined as a
canned string.
</bodyText>
<equation confidence="0.992974375">
(1) Phrase s1 =
new SPhraseSpec(‘leave’);
s1.setTense(PAST);
s1.setObject(
new NPPhraseSpec(‘the’, ‘house’));
Phrase s2 =
new StringPhraseSpec(‘the boys’);
s1.setSubject(s2);
</equation>
<bodyText confidence="0.991812666666667">
Setting the INTERROGATIVETYPE feature of
sentence (1) turns it into a question. Two exam-
ples, are shown below. While (2) exemplifies a
simple yes/no question, in (3), a WH-constituent
is specified as establishing a dependency with the
direct object (the house).
</bodyText>
<listItem confidence="0.865843">
(2) s1.setInterrogative(YES NO);
(Did the boys leave home?)
(3) s1.setInterrogative(WHERE, OBJECT);
</listItem>
<bodyText confidence="0.9186302">
(Where did the boys leave?)
In summary, building syntactic structures in
SimpleNLG is largely a question of feature setting,
with no restrictions on whether representations are
partially or exclusively made up of canned strings.
</bodyText>
<subsectionHeader confidence="0.958188">
2.2.1 Interaction of lexicon and syntax
</subsectionHeader>
<bodyText confidence="0.999982090909091">
The phrasal features in the bottom panel of Table 1
determine the form of the output, since they are
automatically interpreted by the realiser as instruc-
tions to call the correct morphological operations
on lexical items. Hence, the syntactic and morpho-
logical components are closely integrated (though
distinct). Currently, however, lexical features such
as ADJPOSITION are not fully integrated with the
syntactic component. For example, although ad-
jectives in the lexicon are specified for their po-
sition relative to other modifiers, and nouns are
</bodyText>
<page confidence="0.990063">
92
</page>
<bodyText confidence="0.9999072">
specified for whether they take singular or plural
agreement, this informaiton is not currently used
automatically by the realiser. Full integration of
lexical features and syntactic realisation is cur-
rently the focus of ongoing development.
</bodyText>
<subsectionHeader confidence="0.995864">
2.3 Efficiency
</subsectionHeader>
<bodyText confidence="0.999879333333333">
As an indication of efficiency, we measured the
time taken to realise 26 summaries with an aver-
age text length of 160.8 tokens (14.4 sentences),
and sentences ranging in complexity from simple
declaratives to complex embedded clauses3. The
estimates, shown below, average over 100 itera-
tions per text (i.e. a total of 2600 runs of the re-
aliser) on a Dell Optiplex GX620 machine running
Windows XP with a 3.16 GHz Pentium proces-
sor. Separate times are given for the initialisation
of constituents based on semantic representations,
along the lines shown in (1), (SYN), and linearisa-
tion (LIN). These figures suggest that a medium-
length, multiparagraph text can be rendered in un-
der a second in most cases.
</bodyText>
<table confidence="0.904473">
MEAN (ms) SD MIN MAX
SYN 280.7 229.7 13.8 788.34
LIN 749.38 712.6 23.26 2700.38
</table>
<sectionHeader confidence="0.995555" genericHeader="conclusions">
3 Conclusions and future work
</sectionHeader>
<bodyText confidence="0.999957730769231">
This paper has described SimpleNLG, a realisa-
tion engine which differs from most tactical gen-
erators in that it provides a transparent API to carry
out low-level tasks such as inflection and syntac-
tic combination, while making no commitments
about input specifications or input-output map-
pings.
The simplicity of use of SimpleNLG is reflected
in its community of users. The currently avail-
able public distribution4, has been used by several
groups for three main purposes: (a) as a front-end
to NLG systems in projects where realisation is not
the primary research focus; (b) as a simple natu-
ral language component in user interfaces for other
kinds of systems, by researchers who do not work
in NLG proper; (c) as a teaching tool in advanced
undergraduate and postgraduate courses on Natu-
ral Language Processing.
SimpleNLG remains under continuous develop-
ment. Current work is focusing on the inclusion of
output formatting and punctuation modules, which
are currently handled using simple defaults. More-
over, an enhanced interface to the lexicon is being
developed to handle derivational morphology and
a fuller integration of complementation frames of
lexical items with the syntactic component.
</bodyText>
<sectionHeader confidence="0.995506" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.998045075">
J. A. Bateman. 1997. Enabling technology for multi-
lingual natural language generation: the KPML de-
velopment environment. Natural Language Engi-
neering, 3(1):15–55.
J. Coch. 1996. Overview of AlethGen. In Proceedings
of the 8th International Natural Language Genera-
tion Workshop.
M. Elhadad and J. Robin. 1996. An overview of
SURGE: A reusable comprehensive syntactic realiza-
tion component. In Proceedings of the 8th Interna-
tional Natural Language Generation Workshop.
I. Langkilde. 2000. Forest-based statistical language
generation. In Proceedings of the 1st Meeting of
the North American Chapter of the Association for
Computational Linguistics.
B. Lavoie and O. Rambow. 1997. A fast and portable
realizer for text generation systems. In Proceedings
of the 5th Conference on Applied Natural Language
Processing.
S.W. McRoy, S. Channarukul, and S. Ali. 2000. YAG:
A template-based generator for real-time systems.
In Proceedings of the 1st International Conference
on Natural Language Generation.
G. Minnen, J. J. Carroll, and D. Pearce. 2001. Ap-
plied morphological processing of English. Natural
Language Engineering, 7(3):207–223.
F. Portet, E. Reiter, A. Gatt, J. Hunter, S. Sripada,
Y. Freer, and C. Sykes. to appear. Automatic gener-
ation of textual summaries from neonatal intensive
care data. Artificial Intelligence.
E. Reiter and R. Dale. 2000. Building Natural Lan-
guage Generation Systems. Cambridge University
Press, Cambridge, UK.
E. Reiter, S. Sripada, J. Hunter, J. Yu, and I. Davy.
2005. Choosing words in computer-generated
weather forecasts. Artificial Intelligence, 167:137–
169.
E. Reiter. 2007. An architecture for Data-to-Text sys-
tems. In Proceedings of the 11th European Work-
shop on Natural Language Generation.
</reference>
<footnote confidence="0.9917578">
3The system that generates these summaries is fully de-
scribed by Portet et al. (to appear).
4SimpleNLG is available, with exhaus-
tive documentation, at the following URL:
http://www.csd.abdn.ac.uk/∼ereiter/simplenlg/.
</footnote>
<bodyText confidence="0.888331333333333">
M. White. 2006. Chart realization from disjunctive
inputs. In Proceedings of the 4th International Con-
ference on Natural Language Generation.
</bodyText>
<page confidence="0.998382">
93
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.332801">
<title confidence="0.999221">SimpleNLG: A realisation engine for practical applications</title>
<author confidence="0.999226">Albert Gatt</author>
<author confidence="0.999226">Ehud</author>
<affiliation confidence="0.985733">Department of Computing University of</affiliation>
<note confidence="0.386567">Aberdeen AB24 3UE,</note>
<abstract confidence="0.99096375">This paper describes SimpleNLG, a realisation engine for English which aims to provide simple and robust interfaces to generate syntactic structures and linearise them. The library is also flexible in allowing the use of mixed (canned and noncanned) representations.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>J A Bateman</author>
</authors>
<title>Enabling technology for multilingual natural language generation: the KPML development environment.</title>
<date>1997</date>
<journal>Natural Language Engineering,</journal>
<volume>3</volume>
<issue>1</issue>
<contexts>
<context position="717" citStr="Bateman, 1997" startWordPosition="103" endWordPosition="104">mputing Science University of Aberdeen Aberdeen AB24 3UE, UK {a.gatt,e.reiter}@abdn.ac.uk Abstract This paper describes SimpleNLG, a realisation engine for English which aims to provide simple and robust interfaces to generate syntactic structures and linearise them. The library is also flexible in allowing the use of mixed (canned and noncanned) representations. 1 Introduction Over the past several years, a significant consensus has emerged over the definition of the realisation task, through the development of realisers such as REALPRO (Lavoie and Rambow, 1997), ALETHGEN (Coch, 1996), KPML (Bateman, 1997), FUF/SURGE (Elhadad and Robin, 1996), HALOGEN (Langkilde, 2000), YAG (McRoy et al., 2000), and OPENCCG (White, 2006). Realisation involves two logically distinguishable tasks. Tactical generation involves making appropriate linguistic choices given the semantic input. However, once tactical decisions have been taken, building a syntactic representation, applying the right morphological operations, and linearising the sentence as a string are comparatively mechanical tasks. With the possible exception of template-based realisers, such as YAG, existing wide-coverage realisers usually carry out </context>
</contexts>
<marker>Bateman, 1997</marker>
<rawString>J. A. Bateman. 1997. Enabling technology for multilingual natural language generation: the KPML development environment. Natural Language Engineering, 3(1):15–55.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Coch</author>
</authors>
<title>Overview of AlethGen.</title>
<date>1996</date>
<booktitle>In Proceedings of the 8th International Natural Language Generation Workshop.</booktitle>
<contexts>
<context position="695" citStr="Coch, 1996" startWordPosition="100" endWordPosition="101">er Department of Computing Science University of Aberdeen Aberdeen AB24 3UE, UK {a.gatt,e.reiter}@abdn.ac.uk Abstract This paper describes SimpleNLG, a realisation engine for English which aims to provide simple and robust interfaces to generate syntactic structures and linearise them. The library is also flexible in allowing the use of mixed (canned and noncanned) representations. 1 Introduction Over the past several years, a significant consensus has emerged over the definition of the realisation task, through the development of realisers such as REALPRO (Lavoie and Rambow, 1997), ALETHGEN (Coch, 1996), KPML (Bateman, 1997), FUF/SURGE (Elhadad and Robin, 1996), HALOGEN (Langkilde, 2000), YAG (McRoy et al., 2000), and OPENCCG (White, 2006). Realisation involves two logically distinguishable tasks. Tactical generation involves making appropriate linguistic choices given the semantic input. However, once tactical decisions have been taken, building a syntactic representation, applying the right morphological operations, and linearising the sentence as a string are comparatively mechanical tasks. With the possible exception of template-based realisers, such as YAG, existing wide-coverage realis</context>
</contexts>
<marker>Coch, 1996</marker>
<rawString>J. Coch. 1996. Overview of AlethGen. In Proceedings of the 8th International Natural Language Generation Workshop.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Elhadad</author>
<author>J Robin</author>
</authors>
<title>An overview of SURGE: A reusable comprehensive syntactic realization component.</title>
<date>1996</date>
<booktitle>In Proceedings of the 8th International Natural Language Generation Workshop.</booktitle>
<contexts>
<context position="754" citStr="Elhadad and Robin, 1996" startWordPosition="106" endWordPosition="109">of Aberdeen Aberdeen AB24 3UE, UK {a.gatt,e.reiter}@abdn.ac.uk Abstract This paper describes SimpleNLG, a realisation engine for English which aims to provide simple and robust interfaces to generate syntactic structures and linearise them. The library is also flexible in allowing the use of mixed (canned and noncanned) representations. 1 Introduction Over the past several years, a significant consensus has emerged over the definition of the realisation task, through the development of realisers such as REALPRO (Lavoie and Rambow, 1997), ALETHGEN (Coch, 1996), KPML (Bateman, 1997), FUF/SURGE (Elhadad and Robin, 1996), HALOGEN (Langkilde, 2000), YAG (McRoy et al., 2000), and OPENCCG (White, 2006). Realisation involves two logically distinguishable tasks. Tactical generation involves making appropriate linguistic choices given the semantic input. However, once tactical decisions have been taken, building a syntactic representation, applying the right morphological operations, and linearising the sentence as a string are comparatively mechanical tasks. With the possible exception of template-based realisers, such as YAG, existing wide-coverage realisers usually carry out both tasks. By contrast, a realisatio</context>
</contexts>
<marker>Elhadad, Robin, 1996</marker>
<rawString>M. Elhadad and J. Robin. 1996. An overview of SURGE: A reusable comprehensive syntactic realization component. In Proceedings of the 8th International Natural Language Generation Workshop.</rawString>
</citation>
<citation valid="true">
<authors>
<author>I Langkilde</author>
</authors>
<title>Forest-based statistical language generation.</title>
<date>2000</date>
<booktitle>In Proceedings of the 1st Meeting of the North American Chapter of the Association for Computational Linguistics.</booktitle>
<contexts>
<context position="781" citStr="Langkilde, 2000" startWordPosition="112" endWordPosition="113">a.gatt,e.reiter}@abdn.ac.uk Abstract This paper describes SimpleNLG, a realisation engine for English which aims to provide simple and robust interfaces to generate syntactic structures and linearise them. The library is also flexible in allowing the use of mixed (canned and noncanned) representations. 1 Introduction Over the past several years, a significant consensus has emerged over the definition of the realisation task, through the development of realisers such as REALPRO (Lavoie and Rambow, 1997), ALETHGEN (Coch, 1996), KPML (Bateman, 1997), FUF/SURGE (Elhadad and Robin, 1996), HALOGEN (Langkilde, 2000), YAG (McRoy et al., 2000), and OPENCCG (White, 2006). Realisation involves two logically distinguishable tasks. Tactical generation involves making appropriate linguistic choices given the semantic input. However, once tactical decisions have been taken, building a syntactic representation, applying the right morphological operations, and linearising the sentence as a string are comparatively mechanical tasks. With the possible exception of template-based realisers, such as YAG, existing wide-coverage realisers usually carry out both tasks. By contrast, a realisation engine focuses on the sec</context>
</contexts>
<marker>Langkilde, 2000</marker>
<rawString>I. Langkilde. 2000. Forest-based statistical language generation. In Proceedings of the 1st Meeting of the North American Chapter of the Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Lavoie</author>
<author>O Rambow</author>
</authors>
<title>A fast and portable realizer for text generation systems.</title>
<date>1997</date>
<booktitle>In Proceedings of the 5th Conference on Applied Natural Language Processing.</booktitle>
<contexts>
<context position="672" citStr="Lavoie and Rambow, 1997" startWordPosition="94" endWordPosition="97">plications Albert Gatt and Ehud Reiter Department of Computing Science University of Aberdeen Aberdeen AB24 3UE, UK {a.gatt,e.reiter}@abdn.ac.uk Abstract This paper describes SimpleNLG, a realisation engine for English which aims to provide simple and robust interfaces to generate syntactic structures and linearise them. The library is also flexible in allowing the use of mixed (canned and noncanned) representations. 1 Introduction Over the past several years, a significant consensus has emerged over the definition of the realisation task, through the development of realisers such as REALPRO (Lavoie and Rambow, 1997), ALETHGEN (Coch, 1996), KPML (Bateman, 1997), FUF/SURGE (Elhadad and Robin, 1996), HALOGEN (Langkilde, 2000), YAG (McRoy et al., 2000), and OPENCCG (White, 2006). Realisation involves two logically distinguishable tasks. Tactical generation involves making appropriate linguistic choices given the semantic input. However, once tactical decisions have been taken, building a syntactic representation, applying the right morphological operations, and linearising the sentence as a string are comparatively mechanical tasks. With the possible exception of template-based realisers, such as YAG, existi</context>
</contexts>
<marker>Lavoie, Rambow, 1997</marker>
<rawString>B. Lavoie and O. Rambow. 1997. A fast and portable realizer for text generation systems. In Proceedings of the 5th Conference on Applied Natural Language Processing.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S W McRoy</author>
<author>S Channarukul</author>
<author>S Ali</author>
</authors>
<title>YAG: A template-based generator for real-time systems.</title>
<date>2000</date>
<booktitle>In Proceedings of the 1st International Conference on Natural Language Generation.</booktitle>
<contexts>
<context position="807" citStr="McRoy et al., 2000" startWordPosition="115" endWordPosition="118">c.uk Abstract This paper describes SimpleNLG, a realisation engine for English which aims to provide simple and robust interfaces to generate syntactic structures and linearise them. The library is also flexible in allowing the use of mixed (canned and noncanned) representations. 1 Introduction Over the past several years, a significant consensus has emerged over the definition of the realisation task, through the development of realisers such as REALPRO (Lavoie and Rambow, 1997), ALETHGEN (Coch, 1996), KPML (Bateman, 1997), FUF/SURGE (Elhadad and Robin, 1996), HALOGEN (Langkilde, 2000), YAG (McRoy et al., 2000), and OPENCCG (White, 2006). Realisation involves two logically distinguishable tasks. Tactical generation involves making appropriate linguistic choices given the semantic input. However, once tactical decisions have been taken, building a syntactic representation, applying the right morphological operations, and linearising the sentence as a string are comparatively mechanical tasks. With the possible exception of template-based realisers, such as YAG, existing wide-coverage realisers usually carry out both tasks. By contrast, a realisation engine focuses on the second of the two tasks, maki</context>
<context position="6080" citStr="McRoy et al., 2000" startWordPosition="919" endWordPosition="922"> in applications where certain inputs can be mapped to an output string in a deterministic fashion, while others require a more flexible mapping to outputs depending, for example, on semantic features and context. SimpleNLG tries to meet these needs by providing significant syntactic coverage with the added option of combining canned and non-canned strings. Another aim of the engine is robustness: structures which are incomplete or not well-formed will not result in a crash, but typically will yield infelicitous, though comprehensible, output. This is a feature that SimpleNLG shares with YAG (McRoy et al., 2000). A third design criterion was to achieve a clear separation between morphological and syntactic operations. The lexical component of the library, which includes a wide-coverage morphological generator, is distinct from the syntactic component. This makes it useful for applications which do not require complex syntactic operations, but which need output strings to be correctly inflected. 2.1 Lexical operations The lexical component provides interfaces that define a Lexicon, a MorphologicalRule, and a LexicalTtem, with subtypes for different lexical classes (Noun, Preposition etc). Morphologica</context>
</contexts>
<marker>McRoy, Channarukul, Ali, 2000</marker>
<rawString>S.W. McRoy, S. Channarukul, and S. Ali. 2000. YAG: A template-based generator for real-time systems. In Proceedings of the 1st International Conference on Natural Language Generation.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Minnen</author>
<author>J J Carroll</author>
<author>D Pearce</author>
</authors>
<title>Applied morphological processing of English.</title>
<date>2001</date>
<journal>Natural Language Engineering,</journal>
<volume>7</volume>
<issue>3</issue>
<contexts>
<context position="6749" citStr="Minnen et al., 2001" startWordPosition="1019" endWordPosition="1022"> separation between morphological and syntactic operations. The lexical component of the library, which includes a wide-coverage morphological generator, is distinct from the syntactic component. This makes it useful for applications which do not require complex syntactic operations, but which need output strings to be correctly inflected. 2.1 Lexical operations The lexical component provides interfaces that define a Lexicon, a MorphologicalRule, and a LexicalTtem, with subtypes for different lexical classes (Noun, Preposition etc). Morphological rules, a re-implementation of those in MORPHG (Minnen et al., 2001), cover the full range of English inflection, including regular and irregular forms1. In addition to the range of morphological operations that apply to them, various features can be specified for lexical items. For example, as shown in the top panel of Table 1, adjectives and adverbs can be specified for their typical syntactic positions. Thus, an adjective such as red would have the values Attrib2, indicating that it usually occurs in attribute position 2 (following Attrib1 adjectives such as large), and Predicative. Similarly, nouns are classified to indicate 1Thanks are due to John Carroll</context>
</contexts>
<marker>Minnen, Carroll, Pearce, 2001</marker>
<rawString>G. Minnen, J. J. Carroll, and D. Pearce. 2001. Applied morphological processing of English. Natural Language Engineering, 7(3):207–223.</rawString>
</citation>
<citation valid="false">
<authors>
<author>F Portet</author>
<author>E Reiter</author>
<author>A Gatt</author>
<author>J Hunter</author>
<author>S Sripada</author>
<author>Y Freer</author>
<author>C Sykes</author>
</authors>
<title>to appear. Automatic generation of textual summaries from neonatal intensive care data.</title>
<journal>Artificial Intelligence.</journal>
<marker>Portet, Reiter, Gatt, Hunter, Sripada, Freer, Sykes, </marker>
<rawString>F. Portet, E. Reiter, A. Gatt, J. Hunter, S. Sripada, Y. Freer, and C. Sykes. to appear. Automatic generation of textual summaries from neonatal intensive care data. Artificial Intelligence.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Reiter</author>
<author>R Dale</author>
</authors>
<title>Building Natural Language Generation Systems.</title>
<date>2000</date>
<publisher>Cambridge University Press,</publisher>
<location>Cambridge, UK.</location>
<contexts>
<context position="8290" citStr="Reiter and Dale (2000)" startWordPosition="1265" endWordPosition="1268">itory of the relevant items and their properties. Though this can be done programmatically, the current distribution of SimpleNLG provides an interface to a database constructed from the NIH Specialist Lexicon2, a large (&gt; 300,000 entries) repository of lexical items in the medical and general English domains, which incorporates information about lexical features such as those in Table 1. 2.2 Syntactic operations The syntactic component of SimpleNLG defines interfaces for HeadedPhrase and CoordinatePhrase. Apart from various phrasal subtypes (referred to as PhraseSpecs) following the usage in Reiter and Dale (2000)), several grammatical features are defined, including Tense, Number, Person and Mood (see Table 1). In addition, a StringPhraseSpec represents a piece of canned text of arbitrary length. A complete syntactic structure is achieved by initialising constituents with the relevant features, and combining them using the operations specified by the interface. Any syntactic structure can consist of a mixture of Phrase or CoordinatePhrase types and canned strings. The input lexical items to phrase constructors can themselves be either strings or lexical items as defined in the lexical component. Once </context>
</contexts>
<marker>Reiter, Dale, 2000</marker>
<rawString>E. Reiter and R. Dale. 2000. Building Natural Language Generation Systems. Cambridge University Press, Cambridge, UK.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Reiter</author>
<author>S Sripada</author>
<author>J Hunter</author>
<author>J Yu</author>
<author>I Davy</author>
</authors>
<title>Choosing words in computer-generated weather forecasts.</title>
<date>2005</date>
<journal>Artificial Intelligence,</journal>
<volume>167</volume>
<pages>169</pages>
<contexts>
<context position="2443" citStr="Reiter et al., 2005" startWordPosition="363" endWordPosition="366">a number of reasons: 1. Many such realisers define an input formalism, which effectively circumscribes the (semantic) space of possibilities that the realiser handles. The developer needs to ensure that the input to realisation is mapped to the requisite formalism. 2. Since the tactical problem involves search through a space of linguistic choices, the broader the coverage, the more efficiency may be compromised. Where real-time deployment is a goal, this may be an obstacle. 3. Many application domains have sublanguage requirements. For example, the language used in summaries of weather data (Reiter et al., 2005) or patient information (Portet et al., to appear) differs from standard usage, and does not always allow variation to the same extent. Since realisers don’t typically address such requirements, their use in a particular application may require the alteration of the realiser’s rule-base or, in the case of statistical realisers, re-training on large volumes of appropruately annotated data. This paper describes SimpleNLG, a realisation engine which grew out of recent experiences in building large-scale data-to-text NLG systems, whose goal is to summarise large volumes of numeric and symbolic dat</context>
</contexts>
<marker>Reiter, Sripada, Hunter, Yu, Davy, 2005</marker>
<rawString>E. Reiter, S. Sripada, J. Hunter, J. Yu, and I. Davy. 2005. Choosing words in computer-generated weather forecasts. Artificial Intelligence, 167:137– 169.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Reiter</author>
</authors>
<title>An architecture for Data-to-Text systems.</title>
<date>2007</date>
<booktitle>In Proceedings of the 11th European Workshop on Natural Language Generation.</booktitle>
<contexts>
<context position="3059" citStr="Reiter, 2007" startWordPosition="458" endWordPosition="459"> patient information (Portet et al., to appear) differs from standard usage, and does not always allow variation to the same extent. Since realisers don’t typically address such requirements, their use in a particular application may require the alteration of the realiser’s rule-base or, in the case of statistical realisers, re-training on large volumes of appropruately annotated data. This paper describes SimpleNLG, a realisation engine which grew out of recent experiences in building large-scale data-to-text NLG systems, whose goal is to summarise large volumes of numeric and symbolic data (Reiter, 2007). Sublanguage requirements and efficiency are important considerations in such systems. Although meeting these requirements was the initial motivation behind SimpleNLG, it has since been developed into an engine with significant coverage of English syntax and morphology, while at the same time providing a simple API that offers users direct programmatic control over the realisation process. Proceedings of the 12th European Workshop on Natural Language Generation, pages 90–93, Athens, Greece, 30 – 31 March 2009. c�2009 Association for Computational Linguistics 90 Feature Values Applicable class</context>
</contexts>
<marker>Reiter, 2007</marker>
<rawString>E. Reiter. 2007. An architecture for Data-to-Text systems. In Proceedings of the 11th European Workshop on Natural Language Generation.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>