<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.001226">
<note confidence="0.859395">
YAG : A Template-Based Generator for Real-Time Systems*
Susan W. McRoy Songsak Channarukul Syed S. All
fmcroy, songsak, syalil@cs.uwm.edu
Natural Language and Knowledge Representation Research Group
- •littp;lltiggencs. WO-1i edurnarrg
</note>
<affiliation confidence="0.786554">
Electrical Engineering and Computer Science Department
University of Wisconsin-Milwaukee
</affiliation>
<sectionHeader confidence="0.979152" genericHeader="abstract">
1 Introduction
</sectionHeader>
<bodyText confidence="0.997997811764706">
YAG (Yet Another Generator) is a real-time,
general-purpose, template-based generation system
that will enable interactive applications to adapt
natural language output to the interactive context
without requiring developers to write all possible
output strings ahead of time or to embed extensive
knowledge of the grammar of the target language
in the application. Currently, designers of interac-
tive systems who might wish to include dynamically
generated text face a number of barriers; for exam-
ple designers must decide (1) How hard will it be
to link the application to the generator? (2) Will
the generator be fast enough? (3) How much lin-
guistic information will the application need to pro-
vide in order to get reasonable quality output? (5)
How much effort will be required to write a genera-
tion grammar that covers all the potential outputs of
the application? The design and implementation of
YAG is intended to address each of these concerns.
In particular, YAG offers the following benefits to
applications and application designers:
Support for Underspecified Inputs YAG sup-
ports knowledge-based systems by accepting
two types of inputs: applications can either
provide a feature structure (a set of feature-
value pairs) or provide a syntactically under-
specified semantic structure that YAG will map
onto a feature-based representation for realiza-
tion. YAG also provides an opportunity for an
application to add syntactic constraints, such
as whether to express a proposition as a ques-
tion rather than a statement, as a noun-phrase
rather than as a sentence, or as a pronoun rather
than a full noun phrase.
Speed YAG has been designed to work in real-
thne. The YAG template processing engine
does not use search to realize text, thus the
speed of generation depends on the complex-
ity of the template that the application selects.
°This work lug; hum supported by the National Science
Foundation, under grants IRI-9701617 and -1,1114)523fi66, and
by Intel orporation.
not on the size of the grammar. Short, sim-
ple utterances are always realized faster than
longer ones. (In many other approaches, speed
is a function of the grammar size, because it
is searched during realization (Elhadad, 1992;
Elhadad, 1993; Mann, 1983; McKeown, 1982;
McKeown, 1985).)
Robustness In YAG, the realization of a template
cannot fail. Even if there are inconsistencies in
its input (such as subject-verb disagreement),
the generator will produce an understandable
(if not grammatical) output. Applications that
need to enforce grammaticality can use the
YAG preprocessor to detect missing or conflict-
ing features and to supply acceptable values.
The preprocessor makes use of a declarative
specification of slot constraints, based on an
attribute grammar (Channarukul et al., 2000).
This specification is modifiable and extensible
by the application designer.
Expressiveness YAG offers an expressive language
for specifying a generation grammar. This lan-
guage can express units as small as a word or
as large as a document equally well. Unlike
the typical template-based approach, the values
used to instantiate slots are not limited to sim-
ple strings, but can include a variety of struc-
tures, including conditional expressions or ref-
erences to other templates. (This paper will
include a more detailed discussion in the next
section.) Any declarative grammar, such as one
based on feature structures, would be express-
ible in YAG.
Coverage The coverage of YAG depends on the
number of templates that have been defined in
its specification language. In theory, any sen-
tence may he realized given an appropriate tem-
plate. In practice, an application builder must
be concerned with whether it is possible to re-
use existing templates or whether it is necessary
to create new ones. YAG simplifies the task
of specifying a generation grammar in several
ways:
</bodyText>
<page confidence="0.995925">
264
</page>
<bodyText confidence="0.999497384615385">
a It provides an expressive, declarative lan-
guage for specifying templates. This lan-
guage supports template re-use by allowing
template slots to be filled by other tem-
plates.
0 It includes a general-purpose, template-
based grammar for a core fragment of En-
glish. These templates include _default val-
ues for many of the slots, so an application
may omit a feature if it has no informa-
tion about it. Currently, the YAG distribu-
tion includes about 30 domain-independent
syntactic templates, along with some se-
mantic templates.
0 It offers a tool for helping people edit tem-
plates and see what text would be realized
from a template, given a set of values for
its slots.
YAG itself comes in two versions, one in CUSP,
one in JAVA, both of which run on a wide variety of
platforms, including Unix and Windows 95/98.
In the remainder of this paper, we will describe
YAG&apos;s template specification language, and some
examples that illustrate the use of YAG from an
application. More details can be found in (Chan-
narukul, 1999).
</bodyText>
<sectionHeader confidence="0.705261" genericHeader="keywords">
2 YAG&apos;s Template Specification
Language
</sectionHeader>
<bodyText confidence="0.991993264150943">
A template is a pre-defined form with parameters
that are specified by either the user or the applica-
tion at run-time. In YAG, each template is com-
posed of two main parts: template slots and tem-
plate rules. Template slots are parameters or vari-
ables that applications or users can fill with values.
Template rules express how to realize a surface con-
stituent. Templates are realized as strings by replac-
ing slots in each rule with values from the application
and then evaluating the rule. YAG template rules
support nested and recursive templates. There are
ten types of template rules.
The String rule returns a pre-defined string as a
result.
The Evaluation rule evaluates the value of a tem-
plate slot. If the value of the slot is another
featuree, structure, then that structure is e.1.-aiii-
ated recursively. If the value of the specified
slot is not a feature structure, this rule returns
the value without any further processing.
The Template rule returns the result of instanti-
ating a template with a given set of slot-value
pairs.
The If rule is similar to an if-then statement in
most programming_languages, returning a re-
sult when the antecedent of the rule is true.
The Condition rule is similar to the cond state-
ment in LISP, returning a result when one of its
antecedent conditions is true.
The Insertion rule returns the result of interleav-
ing the results of two template rules.
The Alternation rule selects one alternative
template rule to be realized based on a uniform
protrability =distribution , at h ereby adding variety
into a generated text.
The Punctuation rule concatenates a punctua-
tion mark to the specified end of adjacent
strings. The position of a punctuation mark
is either left, right, or both.
The Concatenation rule appends the the result
of one template rule with the results of a second
rule.
The Word rule is used in association with pre-
defined functions and a lexicon to realize expres-
sions that should not be &amp;quot;hard-coded&amp;quot; in a tem-
plate, such as the inflected forms of a word from
the dictionary or the cardinal/ordinal number
corresponding to an integer.
Figure 1 shows the template rules that would
be used to express propositions of the form
has-property(agent , pname, pval), such as
has-property(John, age, 20), which corre-
sponds to John&apos;s age ts 20). These rules are part of
</bodyText>
<figure confidence="0.467055263157895">
((COND (IF (equal pname nil)
(EVAL agent)
(IF (not (equal pname nil))
((CONCAT (EVAL agent)
(S &amp;quot;&apos;s&amp;quot;))
(EVAL pname))
))
(TEMPLATE verb-form
((verb &amp;quot;be&amp;quot;)
(person (agent person))
(number (agent number))
(gender (agent gender))
(tense present)) )
(COND (IF (not (equal property nil))
(EVAL property)
(IF (not (equal pval nil))
(EVAL pval)
))
(PUNC &amp;quot;.&amp;quot; left)
</figure>
<figureCaption confidence="0.995643">
Figure 1; Examples of Tmplate Rules
</figureCaption>
<page confidence="0.987457">
265
</page>
<bodyText confidence="0.999824666666667">
the OBJECT-PROPERTY semantic template. The rules
use the template slots agent, pname, pval, and
property and the template rule types IF, CONCAT,
S, TEMPLATE, COND, EVAL, and• PUNC. If agent =
&amp;quot;John&amp;quot;, pname = &amp;quot;age&amp;quot;, and pval = &amp;quot;20&amp;quot;, the
surface text will be &amp;quot;John&apos;s age is 20.&amp;quot;.
</bodyText>
<sectionHeader confidence="0.536282" genericHeader="method">
3 Examples of YAG in use
</sectionHeader>
<bodyText confidence="0.9999615">
YAG provides facilities for generation from two
types of inputs, a feature structure or a knowledge
representation. The latter is accomplished by the
use of a knowledge representation specific compo-
nent that must be defined for the particular knowl-
edge representation language to be used.
</bodyText>
<subsectionHeader confidence="0.9643935">
3.1 Generation from a Knowledge
Representation Structure
</subsectionHeader>
<bodyText confidence="0.9999423">
Example 1, shows a knowledge representation input
to YAG&apos; It contains two propositions and a list of
control features. In this representation, M2 is the
proposition that the discourse entity B2 is a member
of class &amp;quot;dog&amp;quot;. M5 is the proposition that the name
of the discourse entity 82 is &amp;quot;Pluto&amp;quot;. Thus, we can
read the whole proposition as &amp;quot;Pluto is a member of
class dog.&amp;quot; or simply &amp;quot;Pluto is a dog.&amp;quot;. The control
features state that the output should be generated
as a declarative sentence with &amp;quot;be&amp;quot; as the main verb.
</bodyText>
<equation confidence="0.913039571428571">
Example 1 Pluto is a dog.
(((M2 (CLASS &amp;quot;dog&amp;quot;)
(MEMBER 82))
(M5 (OBJECT B2)
(PROPERNAME &amp;quot;Pluto&amp;quot;)))
((form decl)
(attitude be) )
</equation>
<bodyText confidence="0.999971">
When processing this input, YAG treats the first
proposition as the primary proposition to be real-
ized. YAG will map the MEMBER-CLASS proposition
to the template shown in Figure 2.
The control features, form = decl and attitude
= be, are also used in selecting the template. (If
the form had been interrogative, a template for
generating ayes-no question would have been used.)
Example 2 shows an example where prominaliza-
tion is specified as part of the control features. The
primary proposition says that the agent (B4) is doing
the action &amp;quot;take&amp;quot; on the object (86). This proposi-
tion. along with the selected control features (form
</bodyText>
<figureCaption confidence="0.810195">
&apos;The knowledge reptusentatioir language lised in these ex-
amples follows Lite definition of SNet&apos;S Carr frames described
It:.(Shaniro et al., 1956). ..sNel&apos;S is a SCITIaIll IC network pro-
cessing system (Shapiro and Rapaport, 1i).12). However. in-
puts to VAC are parenthesized lists of symbols,. uot SNePS
data st ruct ures.
</figureCaption>
<equation confidence="0.688663875">
((EVAL member)
(TEMPLATE verb-form
((process &amp;quot;be&amp;quot;)
_ (person (member person))
(number (member number))
(gender (member gender))) )
.-(EVAL-class).
(PUNC &amp;quot;.&amp;quot; left) )
</equation>
<figureCaption confidence="0.999111">
Figure 2: A member-class Template.
</figureCaption>
<bodyText confidence="0.998441">
= decl and attitude = action), allows YAG to se-
lect the clause template.
</bodyText>
<equation confidence="0.97647725">
Example 2 &amp;quot;He takes it.&amp;quot;
(((M2 (AGENT B4)
(ACT (M1 (ACTION &amp;quot;take&amp;quot;)
(DOBJECT 86))))
(M5 (OBJECT 84)
(PROPERNAME &amp;quot;George&amp;quot;))
(M11 (CLASS &amp;quot;book&amp;quot;)
(MEMBER B6))
((form decl)
(attitude action)
(pronominal YES (B6 84))
(gender MASCULINE B4)))
</equation>
<bodyText confidence="0.999690166666667">
To override the gender default (NEUTRAL) of B4
and generate &amp;quot;He&amp;quot; instead of &amp;quot;It&amp;quot;, Example 2 spec-
ifies 84&apos;s gender as MASCULINE. To override the de-
fault expression type (full noun phrase) for both 84
and B6, Example 2 specifies (pronominal YES (136
B4)) which forces pronominalization.
</bodyText>
<subsectionHeader confidence="0.9976">
3.2 Generation from a Feature Structure
</subsectionHeader>
<bodyText confidence="0.999961266666667">
Example 3 shows a complete feature structure that
would be used to realize the text &amp;quot;Blood pressure in-
volves your heart and blood vessels.&amp;quot;. Within a fea-
ture structure, the name of the template that YAG
should use is given by the template feature. Thus, in
this example, YAG retrieves the clause template2
which is shown in Figure 3.
hi the clause template, the agent slot is bound
to &amp;quot;blood pressure&amp;quot; since its value is another fea-
ture structure representing the noun-phrase tem-
plate. The Evaluation rule then realizes it as &amp;quot;blood
pressure&amp;quot;. The Template rule realizes the verb &amp;quot;i:o-
milues&amp;quot;, by evaluating the verb-f orm template with
the process value taken from the clause template.
The other slots (which would normally be taken from
</bodyText>
<footnote confidence="0.997091">
2This template has been simplified to fac&apos;ilitate explana-
tion.
</footnote>
<page confidence="0.997371">
266
</page>
<figure confidence="0.980491523809524">
Example 3 &apos;&apos;Biood pressure involves your heart and
blood vessels.&amp;quot;
((TEMPLATE CLAUSE)
(PROCESS &amp;quot;involve&amp;quot;)
(AGENT
((TEMPLATE NOUN-PHRASE)
(HEAD &amp;quot;blood pressure&amp;quot;)
(DEFINITE NOART)))
(AFFECTED
((TEMPLATE NOUN-PHRASE)
(HEAD ((TEMPLATE CONJUNCTION)
(SENTENCE NO)
(FIRST ((TEMPLATE NOUN-PHRASE)
(HEAD &amp;quot;heart&amp;quot;)
(DEFINITE NOART)))
(SECOND ((TEMPLATE NOUN-PHRASE)
(HEAD &amp;quot;blood vessel&amp;quot;)
(NUMBER PLURAL)
(DEFINITE NOART)))))
(POSSESSOR ((TEMPLATE PRONOUN)
(PERSON SECOND)) ))))
</figure>
<bodyText confidence="0.998398">
the agent slot, if its value were available) are filled
by defaults (the defaults for number, person, and
gender are SINGULAR, THIRD, and NEUTRAL, respec-
tively.) within the verb-form template. The next
Evaluation rule realizes &amp;quot;your heart and blood ves-
sels&amp;quot;, which is the result of realizing the affected
slot (its value is a feature structure representing the
noun-phrase template). Finally, the surface string
is concatenated with a punctuation &amp;quot;.&amp;quot;.
</bodyText>
<figure confidence="0.49717775">
( (EVAL agent)
(TEMPLATE verb-form
((process &amp;quot;process)
(person (agent person))
(number (agent number))
(gender (agent gender))) )
(EVAL affected)
(PUNC &amp;quot; &amp;quot; left) )
</figure>
<figureCaption confidence="0.9546485">
Figure 3: A simplified template rule of the clause
template.
</figureCaption>
<sectionHeader confidence="0.998486" genericHeader="conclusions">
4 Conclusion
</sectionHeader>
<bodyText confidence="0.9997633">
We have presented a natural language generation
component_ called YAG (Yet Another Generator),
that has been designed to meet the needs of real-
time, interactive systems. YAG combines a fast,
template-based approach for the representation or
text structures with knowledge-based methods for
representing content. Its inputs can include concepts
or propositions along optional- annotations to
specify syntactic constraints. NAG can also realize
text from a feature-based representation of syntac-
tic structure. YAG can detect and correct missing
or conflicting features by using a preprocessor based
on attribute grammars. (One can also specify de-
fault values in the grammar itself.) YAG uses an
expressive, declarative language for specifying a gen-
eration grammar. The YAG distribution includes a
,graphical, tool fors.extendInand testing templates.
In these ways, YAG provides the speed, robustness,
flexibility, and maintainability needed by real-time
natural language dialog systems.
</bodyText>
<sectionHeader confidence="0.999239" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.994153590909091">
Songsak Channarukul, Susan W. McRoy, and
Syed S. Ali. 2000. Enriching Partially-Specified
Representations for Text Realization. In Proceed-
ings of The First International Natural Language
Generation Conference, Israel.
Songsak Channarukul. 1999. YAG: A Natural Lan-
guage Generator for Real-Time Systems. Mas-
ter&apos;s thesis, University of Wisconsin-Milwaukee,
December.
Michael Elhadad. 1992. Using argumentation to
control lexical choice: A functional unification-
based approach. Ph.D. thesis, Computer Science
Department, Columbia University.
Michael Elhadad. 1993. FUT: The universal uni-
fier - user manual, version 5.2. Technical Report
CUCS-038-91, Columbia University.
Barbara J. Grosz, Karen Sparck-Jones, and Bon-
nie Lynn Webber. 1986. Readings in Natural Lan-
guage Processing. Morgan Kaufmann Publishers,
Los Altos, CA.
William C. Mann. 1983. An overview of the
Penman text generation system. In Proceedings
of the Third National Conference on Artificial
Intelligence (AAAI-83), pages 261-265, Wash-
ington, DC, August 22-26,. Also appears as
USC/Inforrnation Sciences Institute Tech Report
RR-83-114.
Kathleen R. McKeown. 1982. The TEXT system
for natural language generation : An overview.
In Proceedings of the 20th Annual Meeting of the
ACL, pages 113-120, University of Toronto, On-
tario, Canada, June 16-18,.
Kathleen R. McKeown. 1985. Discourse strategies
- for generating -natural-language text. Artificial
Intelligence, 27(1):1-42. Also appears in (Grosz
et al., 1986), pages 479-499.
Stuart C. Shapiro and William J. Rapaport. 1992.
The SNePS family. Computers E Mathematics
with Applications, 23(2-5).
Stuart C. Shapiro, William J. Rapaport., Sung-Hye
Cho. J. Choi. E. Felt. Susan Ilalle.r..I. Elankiewicz,
and Deepak Kumar, 1996. A Dictionary of SNel&apos;S
Case Frames. Department. of Computer Science.
SUNY at Buffalo.
</reference>
<page confidence="0.997296">
267
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.990600">
<title confidence="0.999374">YAG : A Template-Based Generator for Real-Time Systems*</title>
<author confidence="0.99973">Susan W McRoy Songsak Channarukul Syed S All</author>
<email confidence="0.999607">fmcroy,songsak,syalil@cs.uwm.edu</email>
<affiliation confidence="0.997268666666667">Natural Language and Knowledge Representation Research Group Electrical Engineering and Computer Science University of Wisconsin-Milwaukee</affiliation>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Songsak Channarukul</author>
<author>Susan W McRoy</author>
<author>Syed S Ali</author>
</authors>
<title>Enriching Partially-Specified Representations for Text Realization.</title>
<date>2000</date>
<booktitle>In Proceedings of The First International Natural Language Generation Conference,</booktitle>
<contexts>
<context position="3113" citStr="Channarukul et al., 2000" startWordPosition="473" endWordPosition="476">because it is searched during realization (Elhadad, 1992; Elhadad, 1993; Mann, 1983; McKeown, 1982; McKeown, 1985).) Robustness In YAG, the realization of a template cannot fail. Even if there are inconsistencies in its input (such as subject-verb disagreement), the generator will produce an understandable (if not grammatical) output. Applications that need to enforce grammaticality can use the YAG preprocessor to detect missing or conflicting features and to supply acceptable values. The preprocessor makes use of a declarative specification of slot constraints, based on an attribute grammar (Channarukul et al., 2000). This specification is modifiable and extensible by the application designer. Expressiveness YAG offers an expressive language for specifying a generation grammar. This language can express units as small as a word or as large as a document equally well. Unlike the typical template-based approach, the values used to instantiate slots are not limited to simple strings, but can include a variety of structures, including conditional expressions or references to other templates. (This paper will include a more detailed discussion in the next section.) Any declarative grammar, such as one based on</context>
</contexts>
<marker>Channarukul, McRoy, Ali, 2000</marker>
<rawString>Songsak Channarukul, Susan W. McRoy, and Syed S. Ali. 2000. Enriching Partially-Specified Representations for Text Realization. In Proceedings of The First International Natural Language Generation Conference, Israel.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Songsak Channarukul</author>
</authors>
<title>YAG: A Natural Language Generator for Real-Time Systems. Master&apos;s thesis,</title>
<date>1999</date>
<institution>University of Wisconsin-Milwaukee,</institution>
<contexts>
<context position="5205" citStr="Channarukul, 1999" startWordPosition="825" endWordPosition="827">urrently, the YAG distribution includes about 30 domain-independent syntactic templates, along with some semantic templates. 0 It offers a tool for helping people edit templates and see what text would be realized from a template, given a set of values for its slots. YAG itself comes in two versions, one in CUSP, one in JAVA, both of which run on a wide variety of platforms, including Unix and Windows 95/98. In the remainder of this paper, we will describe YAG&apos;s template specification language, and some examples that illustrate the use of YAG from an application. More details can be found in (Channarukul, 1999). 2 YAG&apos;s Template Specification Language A template is a pre-defined form with parameters that are specified by either the user or the application at run-time. In YAG, each template is composed of two main parts: template slots and template rules. Template slots are parameters or variables that applications or users can fill with values. Template rules express how to realize a surface constituent. Templates are realized as strings by replacing slots in each rule with values from the application and then evaluating the rule. YAG template rules support nested and recursive templates. There are </context>
</contexts>
<marker>Channarukul, 1999</marker>
<rawString>Songsak Channarukul. 1999. YAG: A Natural Language Generator for Real-Time Systems. Master&apos;s thesis, University of Wisconsin-Milwaukee, December.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Elhadad</author>
</authors>
<title>Using argumentation to control lexical choice: A functional unificationbased approach.</title>
<date>1992</date>
<tech>Ph.D. thesis,</tech>
<institution>Computer Science Department, Columbia University.</institution>
<contexts>
<context position="2544" citStr="Elhadad, 1992" startWordPosition="392" endWordPosition="393">er than a full noun phrase. Speed YAG has been designed to work in realthne. The YAG template processing engine does not use search to realize text, thus the speed of generation depends on the complexity of the template that the application selects. °This work lug; hum supported by the National Science Foundation, under grants IRI-9701617 and -1,1114)523fi66, and by Intel orporation. not on the size of the grammar. Short, simple utterances are always realized faster than longer ones. (In many other approaches, speed is a function of the grammar size, because it is searched during realization (Elhadad, 1992; Elhadad, 1993; Mann, 1983; McKeown, 1982; McKeown, 1985).) Robustness In YAG, the realization of a template cannot fail. Even if there are inconsistencies in its input (such as subject-verb disagreement), the generator will produce an understandable (if not grammatical) output. Applications that need to enforce grammaticality can use the YAG preprocessor to detect missing or conflicting features and to supply acceptable values. The preprocessor makes use of a declarative specification of slot constraints, based on an attribute grammar (Channarukul et al., 2000). This specification is modifia</context>
</contexts>
<marker>Elhadad, 1992</marker>
<rawString>Michael Elhadad. 1992. Using argumentation to control lexical choice: A functional unificationbased approach. Ph.D. thesis, Computer Science Department, Columbia University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Elhadad</author>
</authors>
<title>FUT: The universal unifier - user manual, version 5.2.</title>
<date>1993</date>
<tech>Technical Report CUCS-038-91,</tech>
<institution>Columbia University.</institution>
<contexts>
<context position="2559" citStr="Elhadad, 1993" startWordPosition="394" endWordPosition="395">noun phrase. Speed YAG has been designed to work in realthne. The YAG template processing engine does not use search to realize text, thus the speed of generation depends on the complexity of the template that the application selects. °This work lug; hum supported by the National Science Foundation, under grants IRI-9701617 and -1,1114)523fi66, and by Intel orporation. not on the size of the grammar. Short, simple utterances are always realized faster than longer ones. (In many other approaches, speed is a function of the grammar size, because it is searched during realization (Elhadad, 1992; Elhadad, 1993; Mann, 1983; McKeown, 1982; McKeown, 1985).) Robustness In YAG, the realization of a template cannot fail. Even if there are inconsistencies in its input (such as subject-verb disagreement), the generator will produce an understandable (if not grammatical) output. Applications that need to enforce grammaticality can use the YAG preprocessor to detect missing or conflicting features and to supply acceptable values. The preprocessor makes use of a declarative specification of slot constraints, based on an attribute grammar (Channarukul et al., 2000). This specification is modifiable and extensi</context>
</contexts>
<marker>Elhadad, 1993</marker>
<rawString>Michael Elhadad. 1993. FUT: The universal unifier - user manual, version 5.2. Technical Report CUCS-038-91, Columbia University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Barbara J Grosz</author>
<author>Karen Sparck-Jones</author>
<author>Bonnie Lynn Webber</author>
</authors>
<date>1986</date>
<booktitle>Readings in Natural Language Processing.</booktitle>
<publisher>Morgan Kaufmann Publishers,</publisher>
<location>Los Altos, CA.</location>
<marker>Grosz, Sparck-Jones, Webber, 1986</marker>
<rawString>Barbara J. Grosz, Karen Sparck-Jones, and Bonnie Lynn Webber. 1986. Readings in Natural Language Processing. Morgan Kaufmann Publishers, Los Altos, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>William C Mann</author>
</authors>
<title>An overview of the Penman text generation system.</title>
<date>1983</date>
<booktitle>In Proceedings of the Third National Conference on Artificial Intelligence (AAAI-83),</booktitle>
<tech>Tech Report RR-83-114.</tech>
<pages>261--265</pages>
<location>Washington, DC,</location>
<contexts>
<context position="2571" citStr="Mann, 1983" startWordPosition="396" endWordPosition="397">eed YAG has been designed to work in realthne. The YAG template processing engine does not use search to realize text, thus the speed of generation depends on the complexity of the template that the application selects. °This work lug; hum supported by the National Science Foundation, under grants IRI-9701617 and -1,1114)523fi66, and by Intel orporation. not on the size of the grammar. Short, simple utterances are always realized faster than longer ones. (In many other approaches, speed is a function of the grammar size, because it is searched during realization (Elhadad, 1992; Elhadad, 1993; Mann, 1983; McKeown, 1982; McKeown, 1985).) Robustness In YAG, the realization of a template cannot fail. Even if there are inconsistencies in its input (such as subject-verb disagreement), the generator will produce an understandable (if not grammatical) output. Applications that need to enforce grammaticality can use the YAG preprocessor to detect missing or conflicting features and to supply acceptable values. The preprocessor makes use of a declarative specification of slot constraints, based on an attribute grammar (Channarukul et al., 2000). This specification is modifiable and extensible by the a</context>
</contexts>
<marker>Mann, 1983</marker>
<rawString>William C. Mann. 1983. An overview of the Penman text generation system. In Proceedings of the Third National Conference on Artificial Intelligence (AAAI-83), pages 261-265, Washington, DC, August 22-26,. Also appears as USC/Inforrnation Sciences Institute Tech Report RR-83-114.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kathleen R McKeown</author>
</authors>
<title>The TEXT system for natural language generation : An overview.</title>
<date>1982</date>
<booktitle>In Proceedings of the 20th Annual Meeting of the ACL,</booktitle>
<pages>113--120</pages>
<institution>University of Toronto,</institution>
<location>Ontario, Canada,</location>
<contexts>
<context position="2586" citStr="McKeown, 1982" startWordPosition="398" endWordPosition="399">been designed to work in realthne. The YAG template processing engine does not use search to realize text, thus the speed of generation depends on the complexity of the template that the application selects. °This work lug; hum supported by the National Science Foundation, under grants IRI-9701617 and -1,1114)523fi66, and by Intel orporation. not on the size of the grammar. Short, simple utterances are always realized faster than longer ones. (In many other approaches, speed is a function of the grammar size, because it is searched during realization (Elhadad, 1992; Elhadad, 1993; Mann, 1983; McKeown, 1982; McKeown, 1985).) Robustness In YAG, the realization of a template cannot fail. Even if there are inconsistencies in its input (such as subject-verb disagreement), the generator will produce an understandable (if not grammatical) output. Applications that need to enforce grammaticality can use the YAG preprocessor to detect missing or conflicting features and to supply acceptable values. The preprocessor makes use of a declarative specification of slot constraints, based on an attribute grammar (Channarukul et al., 2000). This specification is modifiable and extensible by the application desi</context>
</contexts>
<marker>McKeown, 1982</marker>
<rawString>Kathleen R. McKeown. 1982. The TEXT system for natural language generation : An overview. In Proceedings of the 20th Annual Meeting of the ACL, pages 113-120, University of Toronto, Ontario, Canada, June 16-18,.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kathleen R McKeown</author>
</authors>
<title>Discourse strategies - for generating -natural-language text.</title>
<date>1985</date>
<journal>Artificial Intelligence,</journal>
<pages>27--1</pages>
<note>Also appears in (Grosz et</note>
<contexts>
<context position="2602" citStr="McKeown, 1985" startWordPosition="400" endWordPosition="401">o work in realthne. The YAG template processing engine does not use search to realize text, thus the speed of generation depends on the complexity of the template that the application selects. °This work lug; hum supported by the National Science Foundation, under grants IRI-9701617 and -1,1114)523fi66, and by Intel orporation. not on the size of the grammar. Short, simple utterances are always realized faster than longer ones. (In many other approaches, speed is a function of the grammar size, because it is searched during realization (Elhadad, 1992; Elhadad, 1993; Mann, 1983; McKeown, 1982; McKeown, 1985).) Robustness In YAG, the realization of a template cannot fail. Even if there are inconsistencies in its input (such as subject-verb disagreement), the generator will produce an understandable (if not grammatical) output. Applications that need to enforce grammaticality can use the YAG preprocessor to detect missing or conflicting features and to supply acceptable values. The preprocessor makes use of a declarative specification of slot constraints, based on an attribute grammar (Channarukul et al., 2000). This specification is modifiable and extensible by the application designer. Expressive</context>
</contexts>
<marker>McKeown, 1985</marker>
<rawString>Kathleen R. McKeown. 1985. Discourse strategies - for generating -natural-language text. Artificial Intelligence, 27(1):1-42. Also appears in (Grosz et al., 1986), pages 479-499.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart C Shapiro</author>
<author>William J Rapaport</author>
</authors>
<title>The SNePS family.</title>
<date>1992</date>
<journal>Computers E Mathematics with Applications,</journal>
<pages>23--2</pages>
<marker>Shapiro, Rapaport, 1992</marker>
<rawString>Stuart C. Shapiro and William J. Rapaport. 1992. The SNePS family. Computers E Mathematics with Applications, 23(2-5).</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Choi E Felt Susan Ilalle r I Elankiewicz</author>
<author>Deepak Kumar</author>
</authors>
<title>A Dictionary of SNel&apos;S Case Frames.</title>
<date>1996</date>
<institution>Department. of Computer Science. SUNY at Buffalo.</institution>
<marker>Elankiewicz, Kumar, 1996</marker>
<rawString>Stuart C. Shapiro, William J. Rapaport., Sung-Hye Cho. J. Choi. E. Felt. Susan Ilalle.r..I. Elankiewicz, and Deepak Kumar, 1996. A Dictionary of SNel&apos;S Case Frames. Department. of Computer Science. SUNY at Buffalo.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>