<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000070">
<title confidence="0.997477">
Speech Translation with Grammatical Framework
</title>
<author confidence="0.998426">
Bj¨orn Bringert
</author>
<affiliation confidence="0.9993405">
Department of Computer Science and Engineering
Chalmers University of Technology and University of Gothenburg
</affiliation>
<email confidence="0.994696">
bringert@chalmers.se
</email>
<sectionHeader confidence="0.993774" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999707125">
Grammatical Framework (GF) is a gram-
mar formalism which supports interlingua-
based translation, library-based grammar
engineering, and compilation to speech
recognition grammars. We show how these
features can be used in the construction
of portable high-precision domain-specific
speech translators.
</bodyText>
<sectionHeader confidence="0.998786" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999845043478261">
Speech translators for safety-critical applications
such as medicine need to offer high-precision
translation. One way to achieve high precision
is to limit the coverage of the translator to a spe-
cific domain. The development of such high-
precision domain-specific translators can be re-
source intensive, and require rare combinations of
developer skills. For example, consider developing
a Russian–Swahili speech translator for the ortho-
pedic domain using direct translation between the
two languages. Developing such a system could
require an orthopedist programmer and linguist
who speaks Russian and Swahili. Such people may
be hard to find. Furthermore, developing transla-
tors for all pairs of N languages requires O(N2)
systems, developed by an equal number of bilin-
gual domain experts.
The language pair explosion and the need for
the same person to possess knowledge about the
source and target languages can be avoided by
using an interlingua-based approach. The re-
quirement that developers be both domain ex-
perts and linguists can be addressed by the use of
</bodyText>
<footnote confidence="0.9029355">
© 2008. Licensed under the Creative Commons
Attribution-Noncommercial-Share Alike 3.0 Unported li-
cense (http://creativecommons.org/licenses/by-nc-sa/3.0/).
Some rights reserved.
</footnote>
<bodyText confidence="0.999611315789474">
grammar libraries which implement the domain-
independent linguistic details of each language.
Grammatical Framework (GF) (Ranta, 2004)
is a type-theoretic grammar formalism which
is well suited to high-precision domain-specific
interlingua-based translation (Khegai, 2006), and
library-based grammar engineering (Ranta, 2008).
GF divides grammars into abstract syntax and con-
crete syntax. The abstract syntax defines what can
be said in the grammar, and the concrete syntax de-
fines how it is said in a particular language. If one
abstract syntax syntax is given multiple concrete
syntaxes, the abstract syntax can be used as an in-
terlingua. Given an abstract and a concrete syn-
tax, GF allows both parsing (text to abstract syn-
tax) and linearization (abstract syntax to text). This
means that interlingua-based translation is just a
matter of parsing in one language and linearizing
to another.
The GF resource grammar library (Ranta, 2008)
implements the domain-independent morphologi-
cal and syntactic details of eleven languages. A
grammar writer can use functions from a resource
grammar when defining the concrete syntax of an
application grammar. This is made possible by
GF’s support for grammar composition, and frees
the grammar writer from having to implement lin-
guistic details such as agreement, word order etc.
In addition to parsing and linearization, the
declarative nature of GF grammars allows them to
be compiled to other grammar formats. The GF
speech recognition grammar compiler (Bringert,
2007) can produce context-free grammars or finite-
state models which can be used to guide speech
recognizers.
These components, interlingua-based transla-
tion, grammar libraries, and speech recognition
grammar compilation, can be used to develop
</bodyText>
<page confidence="0.915708">
5
</page>
<note confidence="0.582463">
Coling 2008: Proceedings of the workshop on Speech Processing for Safety Critical Translation and Pervasive Applications, pages 5–8
</note>
<bodyText confidence="0.971330217391304">
Manchester, August 2008
domain-specific speech translators based on GF
grammars. Figure 1 shows an overview of a min-
imal unidirectional speech translator which uses
these components. This is a proof-of-concept sys-
tem that demonstrates how GF components can
be used for speech translation, and as such it can
hardly be compared to a more complete and mature
system such as MedSLT (Bouillon et al., 2005).
However, the system has some promising features
compared to systems based on unification gram-
mars: the expressive power of GF’s concrete syn-
tax allows us to use an application-specific inter-
lingua without any transfer rules, and the wide lan-
guage support of the GF Resource Grammar li-
brary makes it possible to quickly port applications
to new languages.
In Section 2 we show a small example grammar
for a medical speech translator. Section 3 briefly
discusses how a speech translator can be imple-
mented. Section 5 describes some possible ex-
tensions to the proof-of-concept system, and Sec-
tion 6 offers some conclusions.
</bodyText>
<sectionHeader confidence="0.909879" genericHeader="method">
2 Example Grammar
</sectionHeader>
<bodyText confidence="0.994726111111111">
We will show a fragment of a grammar for a med-
ical speech translator. The example comes from
Khegai’s (2006) work on domain-specific transla-
tion with GF, and has been updated to use the cur-
rent version of the GF resource library API.
The small abstract syntax (interlingua) shown
in Figure 2 has three categories (cat): the start
category Prop for complete utterances, Patient
for identifying patients, and Medicine for iden-
tifying medicines. Each category contains a
single function (fun). There are the nullary
functions ShePatient and PainKiller, and the bi-
nary NeedMedicine, which takes a Patient and a
Medicine as arguments, and produces a Prop. This
simple abstract syntax only allows us to construct
the term NeedMedicine ShePatient PainKiller.
A larger version could for example include cat-
egories for body parts, symptoms and illnesses,
and more functions in each category. An example
of a term in such an extended grammar could be
And (Injured TheyPatient Foot) (NeedMedicine
HePatient Laxative).
For this abstract syntax we can use the En-
glish resource grammar to write an English con-
crete syntax, as shown in Figure 3. The resource
grammar category NP is used as the linearization
type (lincat) of the application grammar categories
</bodyText>
<equation confidence="0.92678275">
abstract Health = {
flags startcat = Prop;
cat Patient; Medicine; Prop;
fun
ShePatient : Patient;
PainKiller : Medicine;
NeedMedicine : Patient → Medicine → Prop;
}
</equation>
<figureCaption confidence="0.994655">
Figure 2: Example abstract syntax.
</figureCaption>
<bodyText confidence="0.891544833333333">
Patient and Medicine, and S is used for Prop. The
linearizations (lin) of each abstract syntax function
use overloaded functions from the resource gram-
mar, such as mkCl and mkN which create clauses
and nouns, respectively.
concrete HealthEng of Health =
</bodyText>
<equation confidence="0.860925111111111">
open SyntaxEng, ParadigmsEng in {
lincat Patient, Medicine = NP; Prop = S;
lin
ShePatient = mkNP she Pron;
PainKiller =
mkNP indefSgDet (mkN “painkiller”);
NeedMedicine p m =
mkS (mkCl p (mkV2 (mkV “need”)) m);
}
</equation>
<figureCaption confidence="0.99772">
Figure 3: English concrete syntax.
</figureCaption>
<bodyText confidence="0.794111833333333">
Figure 4 shows a Swedish concrete syntax cre-
ated in the same way. Note that PainKiller in
Swedish uses a mass noun construction rather than
the indefinite article.
concrete HealthSwe of Health =
open SyntaxSwe, ParadigmsSwe in {
</bodyText>
<equation confidence="0.9435134">
lincat Patient, Medicine = NP; Prop = S;
lin
ShePatient = mkNP she Pron;
PainKiller =
mkNP massQuant
(mkN “sm¨artstillande”);
NeedMed p m =
mkS (mkCl p
(mkV2 (mkV “beh¨over”)) m);
}
</equation>
<figureCaption confidence="0.997693">
Figure 4: Swedish concrete syntax.
</figureCaption>
<page confidence="0.634838">
6
</page>
<figure confidence="0.999965044444445">
User
(&apos;1)
Speech
(L1)
Speech recognition
grammar compiler
Speech recognition
grammar (L1)
Speech
recognizer
(L1)
Abstract syntax Concrete syntax
(L1)
Application grammar
Concrete syntax
(L2)
Text
(L1)
PGF
Parser
(L1)
PGF interpreter
Abstract
syntax term
Grammar
compiler
PGF
Linearizer
(L2)
Text
(L2)
Resource grammar
(L2)
Resource grammar library
Speech translator
Speech
synthesizer
(L2)
Resource grammar
(L1)
Grammar development
Speech
(L2)
User
(&apos;2)
</figure>
<figureCaption confidence="0.999751">
Figure 1: Overview of a GF-based speech translator. The developer writes a multilingual application
</figureCaption>
<bodyText confidence="0.826267666666667">
grammar using the resource grammar library. This is compiled to a PGF (Portable Grammar Format)
grammar used for parsing and linearization, and a speech recognition grammar. Off-the-shelf speech
recognizers and speech synthesizers are used together with a PGF interpreter in the running system.
</bodyText>
<sectionHeader confidence="0.969708" genericHeader="method">
3 Speech Translator Implementation
</sectionHeader>
<bodyText confidence="0.999696739130435">
The GF grammar compiler takes grammars in
the GF source language used by programmers,
and produces grammars in a low-level language
(Portable Grammar Format, PGF (Angelov et
al., 2008)) for which interpreters can be eas-
ily and efficiently implemented. There are cur-
rently PGF implementations in Haskell, Java and
JavaScript. The GF speech recognition gram-
mar compiler (Bringert, 2007) targets many differ-
ent formats, including Nuance GSL, SRGS, JSGF
and HTK SLF. This means that speech transla-
tors based on GF can easily be implemented on
almost any platform for which there is a speech
recognizer and speech synthesizer. We have run
Java-based versions under Windows using Nuance
Recognizer and RealSpeak or FreeTTS, Haskell-
based versions under Linux using Nuance Recog-
nizer and RealSpeak, and JavaScript-based proto-
types in the Opera XHTML+Voice-enabled web
browser on Zaurus PDAs and Windows desktops.
The speech translation system itself is domain-
independent. All that is required to use it in a new
domain is an application grammar for that domain.
</bodyText>
<sectionHeader confidence="0.997211" genericHeader="method">
4 Evaluation
</sectionHeader>
<bodyText confidence="0.999988090909091">
Since we have presented a proof-of-concept sys-
tem that demonstrates the use of GF for speech
translation, rather than a complete system for any
particular domain, quantitative translation perfor-
mance evaluation would be out of place. Rather,
we have evaluated the portability and speed of pro-
totyping. Our basic speech translators written in
Java and Haskell, using existing speech compo-
nents and PGF interpreters, require less than 100
lines of code each. Developing a small domain for
the translator can be done in under 10 minutes.
</bodyText>
<sectionHeader confidence="0.999321" genericHeader="evaluation">
5 Extensions
</sectionHeader>
<subsectionHeader confidence="0.991512">
5.1 Interactive Disambiguation
</subsectionHeader>
<bodyText confidence="0.999880333333333">
The concrete syntax for the source language may
be ambiguous, i.e. there may be sentences for
which parsing produces multiple abstract syntax
</bodyText>
<page confidence="0.998846">
7
</page>
<bodyText confidence="0.999974821428571">
terms. The ambiguity can sometimes be preserved
in the target language, if all the abstract syntax
terms linearize to the same sentence.
In cases where the ambiguity cannot be pre-
served, or if we want to force disambiguation for
safety reasons, we can use a disambiguation gram-
mar to allow the user to choose an interpretation.
This is a second concrete syntax which is com-
pletely unambiguous. When the user inputs an
ambiguous sentence, the system linearizes each of
the abstract syntax terms with the disambiguation
grammar, and prompts the user to select the sen-
tence with the intended meaning. If only some
of the ambiguity can be preserved, the number
of choices can be reduced by grouping the ab-
stract syntax terms into equivalence classes based
on whether they produce the same sentences in the
target language. Since all terms in a class produce
the same output, the user only needs to select the
correct class of unambiguous sentences.
Another source of ambiguity is that two abstract
syntax terms can have distinct linearizations in the
source language, but identical target language lin-
earizations. In this case, the output sentence will
be ambiguous, even though the input was unam-
biguous. This could be addressed by using unam-
biguous linearizations for system output, though
this may lead to the use of unnatural constructions.
</bodyText>
<subsectionHeader confidence="0.997053">
5.2 Bidirectional Translation
</subsectionHeader>
<bodyText confidence="0.999996636363636">
Since GF uses the same grammar for parsing and
linearization, the grammar for a translator from L1
to L2 can also be used in a translator from L2 to
L1, provided that the appropriate speech compo-
nents are available. Two unidirectional translators
can be used as a bidirectional translator, something
which is straightforwardly achieved using two
computers. While PGF interpreters can already be
used for bidirectional translation, a single-device
bidirectional speech translator requires multiplex-
ing or duplicating the sound hardware.
</bodyText>
<subsectionHeader confidence="0.974553">
5.3 Larger Input Coverage
</subsectionHeader>
<bodyText confidence="0.85237">
GF’s variants feature allows an abstract syntax
function to have multiple representations in a given
concrete syntax. This permits some variation in
the input, while producing the same interlingua
term. For example, the linearization of PainKiller
in the English concrete syntax in Figure 3 could be
changed to:
mkNP indefSgDet (variants {
mkN “painkiller”; mkN “analgesic”});
</bodyText>
<sectionHeader confidence="0.99891" genericHeader="conclusions">
6 Conclusions
</sectionHeader>
<bodyText confidence="0.999978166666667">
Because it uses a domain-specific interlingua, a
GF-based speech translator can achieve high pre-
cision translation and scale to support a large num-
ber of languages.
The GF resource grammar library reduces the
development effort needed to implement a speech
translator for a new domain, and the need for the
developer to have detailed linguistic knowledge.
Systems created with GF are highly portable to
new platforms, because of the wide speech recog-
nition grammar format support, and the availability
of PGF interpreters for many platforms.
With additional work, GF could be used to im-
plement a full-scale speech translator. The ex-
isting GF components for grammar development,
speech recognition grammar compilation, parsing,
and linearization could also be used as parts of
larger systems.
</bodyText>
<sectionHeader confidence="0.999056" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.99790025">
Angelov, Krasimir, Bj¨orn Bringert, and Aarne
Ranta. 2008. PGF: A Portable Run-Time
Format for Type-Theoretical Grammars.
Manuscript, http://www.cs.chalmers.
se/˜bringert/publ/pgf/pgf.pdf.
Bouillon, P., M. Rayner, N. Chatzichrisafis, B. A.
Hockey, M. Santaholma, M. Starlander, H. Isahara,
K. Kanzaki, and Y. Nakao. 2005. A generic Multi-
Lingual Open Source Platform for Limited-Domain
Medical Speech Translation. pages 5–58, May.
Bringert, Bj¨orn. 2007. Speech Recognition Grammar
Compilation in Grammatical Framework. In Pro-
ceedings of the Workshop on Grammar-Based Ap-
proaches to Spoken Language Processing, pages 1–
8, Prague, Czech Republic.
Khegai, Janna. 2006. Grammatical Framework (GF)
for MT in sublanguage domains. In Proceedings
of EAMT-2006, 11th Annual conference of the Eu-
ropean Association for Machine Translation, Oslo,
Norway, pages 95–104, June.
Ranta, Aarne. 2004. Grammatical Framework: A
Type-Theoretical Grammar Formalism. Journal of
Functional Programming, 14(2):145–189, March.
Ranta, Aarne. 2008. Grammars as software libraries.
In Bertot, Yves, G´erard Huet, Jean-Jacques L´evy,
and Gordon Plotkin, editors, From semantics to com-
puter science: essays in honor of Gilles Kahn. Cam-
bridge University Press.
</reference>
<page confidence="0.998453">
8
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.817509">
<title confidence="0.999886">Speech Translation with Grammatical Framework</title>
<author confidence="0.99874">Bj¨orn</author>
<affiliation confidence="0.973873">Department of Computer Science and Chalmers University of Technology and University of</affiliation>
<email confidence="0.865397">bringert@chalmers.se</email>
<abstract confidence="0.998183666666667">Grammatical Framework (GF) is a grammar formalism which supports interlinguabased translation, library-based grammar engineering, and compilation to speech recognition grammars. We show how these features can be used in the construction of portable high-precision domain-specific speech translators.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Krasimir Angelov</author>
<author>Bj¨orn Bringert</author>
<author>Aarne Ranta</author>
</authors>
<title>PGF: A Portable Run-Time Format for Type-Theoretical Grammars.</title>
<date>2008</date>
<tech>Manuscript, http://www.cs.chalmers. se/˜bringert/publ/pgf/pgf.pdf.</tech>
<contexts>
<context position="8153" citStr="Angelov et al., 2008" startWordPosition="1237" endWordPosition="1240">r (&apos;2) Figure 1: Overview of a GF-based speech translator. The developer writes a multilingual application grammar using the resource grammar library. This is compiled to a PGF (Portable Grammar Format) grammar used for parsing and linearization, and a speech recognition grammar. Off-the-shelf speech recognizers and speech synthesizers are used together with a PGF interpreter in the running system. 3 Speech Translator Implementation The GF grammar compiler takes grammars in the GF source language used by programmers, and produces grammars in a low-level language (Portable Grammar Format, PGF (Angelov et al., 2008)) for which interpreters can be easily and efficiently implemented. There are currently PGF implementations in Haskell, Java and JavaScript. The GF speech recognition grammar compiler (Bringert, 2007) targets many different formats, including Nuance GSL, SRGS, JSGF and HTK SLF. This means that speech translators based on GF can easily be implemented on almost any platform for which there is a speech recognizer and speech synthesizer. We have run Java-based versions under Windows using Nuance Recognizer and RealSpeak or FreeTTS, Haskellbased versions under Linux using Nuance Recognizer and Real</context>
</contexts>
<marker>Angelov, Bringert, Ranta, 2008</marker>
<rawString>Angelov, Krasimir, Bj¨orn Bringert, and Aarne Ranta. 2008. PGF: A Portable Run-Time Format for Type-Theoretical Grammars. Manuscript, http://www.cs.chalmers. se/˜bringert/publ/pgf/pgf.pdf.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Bouillon</author>
<author>M Rayner</author>
<author>N Chatzichrisafis</author>
<author>B A Hockey</author>
<author>M Santaholma</author>
<author>M Starlander</author>
<author>H Isahara</author>
<author>K Kanzaki</author>
<author>Y Nakao</author>
</authors>
<title>A generic MultiLingual Open Source Platform for Limited-Domain Medical Speech Translation.</title>
<date>2005</date>
<pages>5--58</pages>
<contexts>
<context position="4049" citStr="Bouillon et al., 2005" startWordPosition="588" endWordPosition="591">grammar libraries, and speech recognition grammar compilation, can be used to develop 5 Coling 2008: Proceedings of the workshop on Speech Processing for Safety Critical Translation and Pervasive Applications, pages 5–8 Manchester, August 2008 domain-specific speech translators based on GF grammars. Figure 1 shows an overview of a minimal unidirectional speech translator which uses these components. This is a proof-of-concept system that demonstrates how GF components can be used for speech translation, and as such it can hardly be compared to a more complete and mature system such as MedSLT (Bouillon et al., 2005). However, the system has some promising features compared to systems based on unification grammars: the expressive power of GF’s concrete syntax allows us to use an application-specific interlingua without any transfer rules, and the wide language support of the GF Resource Grammar library makes it possible to quickly port applications to new languages. In Section 2 we show a small example grammar for a medical speech translator. Section 3 briefly discusses how a speech translator can be implemented. Section 5 describes some possible extensions to the proof-of-concept system, and Section 6 of</context>
</contexts>
<marker>Bouillon, Rayner, Chatzichrisafis, Hockey, Santaholma, Starlander, Isahara, Kanzaki, Nakao, 2005</marker>
<rawString>Bouillon, P., M. Rayner, N. Chatzichrisafis, B. A. Hockey, M. Santaholma, M. Starlander, H. Isahara, K. Kanzaki, and Y. Nakao. 2005. A generic MultiLingual Open Source Platform for Limited-Domain Medical Speech Translation. pages 5–58, May.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bj¨orn Bringert</author>
</authors>
<title>Speech Recognition Grammar Compilation in Grammatical Framework.</title>
<date>2007</date>
<booktitle>In Proceedings of the Workshop on Grammar-Based Approaches to Spoken Language Processing,</booktitle>
<volume>1</volume>
<pages>pages</pages>
<location>Prague, Czech Republic.</location>
<contexts>
<context position="3274" citStr="Bringert, 2007" startWordPosition="473" endWordPosition="474">F resource grammar library (Ranta, 2008) implements the domain-independent morphological and syntactic details of eleven languages. A grammar writer can use functions from a resource grammar when defining the concrete syntax of an application grammar. This is made possible by GF’s support for grammar composition, and frees the grammar writer from having to implement linguistic details such as agreement, word order etc. In addition to parsing and linearization, the declarative nature of GF grammars allows them to be compiled to other grammar formats. The GF speech recognition grammar compiler (Bringert, 2007) can produce context-free grammars or finitestate models which can be used to guide speech recognizers. These components, interlingua-based translation, grammar libraries, and speech recognition grammar compilation, can be used to develop 5 Coling 2008: Proceedings of the workshop on Speech Processing for Safety Critical Translation and Pervasive Applications, pages 5–8 Manchester, August 2008 domain-specific speech translators based on GF grammars. Figure 1 shows an overview of a minimal unidirectional speech translator which uses these components. This is a proof-of-concept system that demon</context>
<context position="8353" citStr="Bringert, 2007" startWordPosition="1269" endWordPosition="1270">mmar used for parsing and linearization, and a speech recognition grammar. Off-the-shelf speech recognizers and speech synthesizers are used together with a PGF interpreter in the running system. 3 Speech Translator Implementation The GF grammar compiler takes grammars in the GF source language used by programmers, and produces grammars in a low-level language (Portable Grammar Format, PGF (Angelov et al., 2008)) for which interpreters can be easily and efficiently implemented. There are currently PGF implementations in Haskell, Java and JavaScript. The GF speech recognition grammar compiler (Bringert, 2007) targets many different formats, including Nuance GSL, SRGS, JSGF and HTK SLF. This means that speech translators based on GF can easily be implemented on almost any platform for which there is a speech recognizer and speech synthesizer. We have run Java-based versions under Windows using Nuance Recognizer and RealSpeak or FreeTTS, Haskellbased versions under Linux using Nuance Recognizer and RealSpeak, and JavaScript-based prototypes in the Opera XHTML+Voice-enabled web browser on Zaurus PDAs and Windows desktops. The speech translation system itself is domainindependent. All that is required</context>
</contexts>
<marker>Bringert, 2007</marker>
<rawString>Bringert, Bj¨orn. 2007. Speech Recognition Grammar Compilation in Grammatical Framework. In Proceedings of the Workshop on Grammar-Based Approaches to Spoken Language Processing, pages 1– 8, Prague, Czech Republic.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Janna Khegai</author>
</authors>
<title>Grammatical Framework (GF) for MT in sublanguage domains.</title>
<date>2006</date>
<booktitle>In Proceedings of EAMT-2006, 11th Annual conference of the European Association for Machine Translation,</booktitle>
<pages>95--104</pages>
<location>Oslo,</location>
<contexts>
<context position="2032" citStr="Khegai, 2006" startWordPosition="277" endWordPosition="278">anguages can be avoided by using an interlingua-based approach. The requirement that developers be both domain experts and linguists can be addressed by the use of © 2008. Licensed under the Creative Commons Attribution-Noncommercial-Share Alike 3.0 Unported license (http://creativecommons.org/licenses/by-nc-sa/3.0/). Some rights reserved. grammar libraries which implement the domainindependent linguistic details of each language. Grammatical Framework (GF) (Ranta, 2004) is a type-theoretic grammar formalism which is well suited to high-precision domain-specific interlingua-based translation (Khegai, 2006), and library-based grammar engineering (Ranta, 2008). GF divides grammars into abstract syntax and concrete syntax. The abstract syntax defines what can be said in the grammar, and the concrete syntax defines how it is said in a particular language. If one abstract syntax syntax is given multiple concrete syntaxes, the abstract syntax can be used as an interlingua. Given an abstract and a concrete syntax, GF allows both parsing (text to abstract syntax) and linearization (abstract syntax to text). This means that interlingua-based translation is just a matter of parsing in one language and li</context>
</contexts>
<marker>Khegai, 2006</marker>
<rawString>Khegai, Janna. 2006. Grammatical Framework (GF) for MT in sublanguage domains. In Proceedings of EAMT-2006, 11th Annual conference of the European Association for Machine Translation, Oslo, Norway, pages 95–104, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Aarne Ranta</author>
</authors>
<title>Grammatical Framework: A Type-Theoretical Grammar Formalism.</title>
<date>2004</date>
<journal>Journal of Functional Programming,</journal>
<volume>14</volume>
<issue>2</issue>
<contexts>
<context position="1894" citStr="Ranta, 2004" startWordPosition="261" endWordPosition="262">bilingual domain experts. The language pair explosion and the need for the same person to possess knowledge about the source and target languages can be avoided by using an interlingua-based approach. The requirement that developers be both domain experts and linguists can be addressed by the use of © 2008. Licensed under the Creative Commons Attribution-Noncommercial-Share Alike 3.0 Unported license (http://creativecommons.org/licenses/by-nc-sa/3.0/). Some rights reserved. grammar libraries which implement the domainindependent linguistic details of each language. Grammatical Framework (GF) (Ranta, 2004) is a type-theoretic grammar formalism which is well suited to high-precision domain-specific interlingua-based translation (Khegai, 2006), and library-based grammar engineering (Ranta, 2008). GF divides grammars into abstract syntax and concrete syntax. The abstract syntax defines what can be said in the grammar, and the concrete syntax defines how it is said in a particular language. If one abstract syntax syntax is given multiple concrete syntaxes, the abstract syntax can be used as an interlingua. Given an abstract and a concrete syntax, GF allows both parsing (text to abstract syntax) and</context>
</contexts>
<marker>Ranta, 2004</marker>
<rawString>Ranta, Aarne. 2004. Grammatical Framework: A Type-Theoretical Grammar Formalism. Journal of Functional Programming, 14(2):145–189, March.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Aarne Ranta</author>
</authors>
<title>Grammars as software libraries.</title>
<date>2008</date>
<editor>In Bertot, Yves, G´erard Huet, Jean-Jacques L´evy, and Gordon Plotkin, editors,</editor>
<publisher>Cambridge University Press.</publisher>
<contexts>
<context position="2085" citStr="Ranta, 2008" startWordPosition="283" endWordPosition="284">approach. The requirement that developers be both domain experts and linguists can be addressed by the use of © 2008. Licensed under the Creative Commons Attribution-Noncommercial-Share Alike 3.0 Unported license (http://creativecommons.org/licenses/by-nc-sa/3.0/). Some rights reserved. grammar libraries which implement the domainindependent linguistic details of each language. Grammatical Framework (GF) (Ranta, 2004) is a type-theoretic grammar formalism which is well suited to high-precision domain-specific interlingua-based translation (Khegai, 2006), and library-based grammar engineering (Ranta, 2008). GF divides grammars into abstract syntax and concrete syntax. The abstract syntax defines what can be said in the grammar, and the concrete syntax defines how it is said in a particular language. If one abstract syntax syntax is given multiple concrete syntaxes, the abstract syntax can be used as an interlingua. Given an abstract and a concrete syntax, GF allows both parsing (text to abstract syntax) and linearization (abstract syntax to text). This means that interlingua-based translation is just a matter of parsing in one language and linearizing to another. The GF resource grammar library</context>
</contexts>
<marker>Ranta, 2008</marker>
<rawString>Ranta, Aarne. 2008. Grammars as software libraries. In Bertot, Yves, G´erard Huet, Jean-Jacques L´evy, and Gordon Plotkin, editors, From semantics to computer science: essays in honor of Gilles Kahn. Cambridge University Press.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>