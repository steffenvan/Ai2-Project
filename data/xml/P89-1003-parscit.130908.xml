<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.9668385">
A THREE-VALUED INTERPRETATION OF NEGATION IN
FEATURE STRUCTURE DESCRIPTIONS
</title>
<author confidence="0.948333">
Anuj Dawar
</author>
<affiliation confidence="0.877552333333333">
Dept. of Comp. and Info. Science
University of Pennsylvania
Philadelphia, PA 19104
K. Vijay-Shanker
Dept. of Comp. and Info. Science
University of Delaware
</affiliation>
<address confidence="0.8401715">
Newark, DE 19716
April 20, 1989
</address>
<sectionHeader confidence="0.913197" genericHeader="abstract">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.999967214285714">
Feature structures are informational elements that have
been used in several linguistic theories and in computa-
tional systems for natural-language processing. A logi-
cal calculus has been developed and used as a description
language for feature structures. In the present work, a
framework in three-valued logic is suggested for defining
the semantics of a feature structure description language,
allowing for a more complete set of logical operators. In
particular, the semantics of the negation and implication
operators are examined. Various proposed interpretations
of negation and implication are compared within the sug-
gested framework. One particular interpretation of the
description language with a negation operator is described
and its computational aspects studied.
</bodyText>
<sectionHeader confidence="0.992071" genericHeader="categories and subject descriptors">
1 Introduction and Background
</sectionHeader>
<bodyText confidence="0.999870739130435">
A number of linguistic theories and computational ap-
proaches to parsing natural language have employed the
notion of associating informational elements, called feature
structures, consisting of features and their values, with
phrases. Rounds and Kasper [KR86, RK86] developed a
logical calculus that serves as a description language for
these structures.
Several researchers have expressed a need for extending
this logic to include the operators of negation and impli-
cation. Various interpretations have been suggested that
define a semantics for these operators (see Section 1.2), but
none has gained universal acceptance. In [Feral, Pereira
set forth certain properties that any such interpretation
should satisfy.
In this paper we present an extended logical calculus,
with a semantics in three-valued logic (based on Kleene&apos;s
three-valued logic [K1e52]), that includes an interpretation
of negation motivated by the approach given by Kart-
tunen [Kar84]. We show that our logic meets the condi-
tions stated by Pereira. We also show that the three-valued
framework is powerful enough to express most of the pro-
posed definitions of negation and implication. It therefore
makes it possible to compare these different approaches.
</bodyText>
<subsectionHeader confidence="0.981658">
1.1 Rounds-Kasper Logic
</subsectionHeader>
<bodyText confidence="0.9999334">
In [Kas87] and [RK86], Rounds and Kasper introduced a
logical formalism to describe feature structures with dis-
junctive specification. The language is a form of modal
propositional logic (with modal operator &amp;quot;:&amp;quot;).
In order to define the semantics of this language, fea-
ture structures are formally defined in terms of acyclic
finite automata. These are finite-state automata whose
transition graphs are acyclic. The formal definition may
be found in [RK86].
A fundamental property of the semantics is that the set
of automata satisfying a given formula is upward-closed
under the operation of subsumption. This is important,
because we consider a formula to be only a partial descrip-
tion of a feature structure. The property is stated in the
following theorem [RK86]:
</bodyText>
<construct confidence="0.999052">
Theorem 1.1 A C B if and only if for every formula, 0,
if A 4) then B
</construct>
<subsectionHeader confidence="0.965089">
1.2 The Problem of Adding Negation
</subsectionHeader>
<bodyText confidence="0.998817285714286">
Several researchers in the area have suggested that the
logic described above should be extended to include nega-
tion and implication.
Karttunen [Kar841 provides examples of feature struc-
tures where a negation operator might be useful. For in-
stance, the most natural way to represent the number and
person attributes of a verb such as sleep would be to say
</bodyText>
<page confidence="0.995158">
18
</page>
<sectionHeader confidence="0.358903" genericHeader="general terms">
2 Feature Structure Descriptions with
Negation
</sectionHeader>
<bodyText confidence="0.986043483870968">
that it is not third person singular rather than expressing
it as a disjunction of the other five possibilities. Karttunen
also suggests an implementation technique to handle neg-
ative information.
Johnson [Joh87], defined an Attribute Value Logic
(AVL), similar to the Rounds-Kasper Logic, that included
a classical form of negation. Kasper [Kas88] discusses an
interpretation of negation and implication in an implemen-
tation of Functional Unification Grammar [Kay79] that in-
cludes conditionals. Kasper&apos;s semantics is classical, but
his unification procedure uses notions similar to those of
three-valued logic&apos;.
One aspect of the classical approach is that the prop-
erty of upward-closure under subsumption is lost. Thus
the evaluation of negation may not be freely interleaved
with unification 2.
In [Kas88], Kasper localized the effects of negation
by disallowing path expressions within the scope of a
negation. This restriction may not be linguistically war-
ranted as can be seen by the following example from
Pereira [Per87] which expresses the semantic constraint
that the subject and object of a clause cannot be coref-
erential unless the object is a reflexive pronoun:
obj :type : reflexive V —1(subj : ref 7z obj : ref)
Moshier and Rounds [MR87] proposed an intuitionistic
interpretation of negation that preserves upward-closure.
They replace the notion of satisfaction with one of model-
theoretic forcing as described in Fitting [Fit69]. They also
provide a complete proof system for their logic. The satis-
fiability problem for this logic was shown to be PS PACE-
complete.
</bodyText>
<subsectionHeader confidence="0.996776">
1.3 Outline of this Paper
</subsectionHeader>
<bodyText confidence="0.999897222222222">
In the following section we will present our proposed solu-
tion in a three-valued framework, for defining the seman-
tics of feature structure descriptions including negation&apos;.
This solution is a formalization of the notion of negation
in Karttunen [Kar84]. In Section 3 we will show that
the framework of three-valued logic is flexible enough to
express most of the different interpretations of negation
mentioned above. In Section 4 we will show that the satis-
fiability problem for the logic we propose is NP-complete.
</bodyText>
<subsectionHeader confidence="0.832465">
lsee Section 3.4
</subsectionHeader>
<footnote confidence="0.7050555">
2see Pereira (Per871 p.1006
3We shall concentrate only on the problem of extending the logic
to include the negation operator, and later in Section 3.4 discuss
implication.
</footnote>
<bodyText confidence="0.999734">
We will now present our extended version of the Rounds.
Kasper logic including negation. We do this by giving
the semantics of the logic in a three-valued setting. This
provides an interpretation of negation that is intuitively
appealing, formally simple and computationally no harder
than the original Rounds-Kasper logic.
With each formula we associate the set (Tset) of au-
tomata that satisfy the formula, a set (Fset) of automata
that contradict it and a set ( Uset) of automata which nei-
ther satisfy nor contradict ie. Different interpretations of
negation are obtained by varying definitions of what con-
stitutes &amp;quot;contradiction.&amp;quot; In the semantics we will define,
we choose a definition in which contradiction is equivalent
to essential incompatibility 5. We will define the Tset and
the Fset so that they are upward-closed with respect to
subsumption for all formulae. Thus, we avoid the prob-
lems associated with the classical interpretation of nega-
tion. In our logic, negation is defined so that an automaton
A satisfies -4 if and only if it contradicts 0.
</bodyText>
<subsectionHeader confidence="0.997739">
2.1 The Syntax
</subsectionHeader>
<bodyText confidence="0.983852333333333">
The symbols in the descriptive language, &amp;quot;other than the
connectives :, v, A, and are taken from two primitive
domains: Atoms (A), and Labels (L).
The set of well formed formulae (W), is given by: NIL;
TOP; a; 1: 0; 0 A 0; 0 V 0; —,0 and pi 192, where a E A;
I EL; 0,0 E Wand pi , p2 E L.
</bodyText>
<subsectionHeader confidence="0.999297">
2.2 The Semantics
</subsectionHeader>
<bodyText confidence="0.999260666666667">
Formally, the semantics is defined over the domain of par-
tial functions from acyclic finite automata6 to boolean val-
ues.
</bodyText>
<construct confidence="0.8421495">
Definition 2.1 An acyclic finite automaton is a 7-tuple
A =&lt; Q, E, r, b, go, F, X&gt;, where:
1. Q is a non-empty finite set (of states),
2. E is a countable set (the alphabet),
</construct>
<bodyText confidence="0.9245443">
4A similar notion was used by Kasper [Kas86], who introduces
the notion of compatibility. We shall compare this approach with
ours in greater detail in Section 3.4.
5In general, a feature structure is incompatible with a formula it
the information it contains is inconsistent with that in the formula.
We will distinguish two kinds of incompatibility. A feature struc-
ture is essentially incompatible with a formula if the information in
it contradicts the information in the formula. It is trivially incom-
patible with the formula if the inconsistency is due to an excess of
information within the formula itself.
</bodyText>
<subsectionHeader confidence="0.685748">
6In this paper we will not consider cyclic feature structures
</subsectionHeader>
<page confidence="0.975298">
19
</page>
<listItem confidence="0.813610636363636">
3. r is a countable set (the output alphabet),
4. 6 : Q x E --• Q is a finite partial function (the tran-
sition function),
5. qo E Q (the initial state),
6. F C Q (the set of final states),
7. A:F--•r is a total function (the output function),
8. the directed graph (Q, E) is acyclic, where pEq if
for some I E E, =
9. for every q E Q, there exists a directed path from go
to q in (Q, E), and
10. for every q E F, b(q,1) is not defined for any 1.
</listItem>
<bodyText confidence="0.898049666666667">
A formula 0 over the set of labels L and the set of
atoms A is characterized by a partial function:
: {AIA =&lt; Q, L, A, 6, qo , F, A &gt;} {True, False}
F4(A) is True iff A satisfies 0. It is False if A contra-
dicts q7 and is undefined otherwise. The formal definition
is given below.
</bodyText>
<construct confidence="0.999414">
Definition 2.2 For any formula 0, the partial func-
tion .F4, over the set of acyclic finite automata, A =&lt;
Q, L, A, 5, qo, F, &gt;, is defined as follows:
</construct>
<figure confidence="0.648341166666667">
1. if 0 = NIL then
F(A) = True for all A;
2. if 0 =TOP then
IVA) = False for all A;
3. if 0 = a for some a E A then
Fo(A)= True
</figure>
<construct confidence="0.886836444444444">
if A is atomic and A(q0) = a
= False
if A is atomic and A(q0) = b
for some b, b 0 a (see Note 2.)
74,(A) is undefined otherwise;
4. if (1) = 1: 01 for some 1 E L and 01 E W then
= Fo1(A11) if All is defined.
(see Note 3.)
F4,(A) is undefined otherwise;
</construct>
<page confidence="0.43392">
7 and therefore it satisfies the formula ,itS
</page>
<figure confidence="0.8679715">
5. if = 01 A 02 for some 151, €W then
.F4,(A) =True
</figure>
<construct confidence="0.881171111111111">
if Foi(A) =True and 7,1„ (A) = True
= False
if Toi(A)= False or 74,2(A) = False
To(A) is undefined otherwise ;
6. if 15= 01V 4)2 for some 1,q52 E W then
T0(A) = True
if F4,1(A) = True or .7.4, 2 (A) = True
To(A)= False
if .101(A)= False and ..ro,(A)= False
</construct>
<figure confidence="0.8823805">
To(A) is undefined otherwise ;
7. if 4, = -02 for some 01 E W then
= True if 74.,(A)= False
70(A) = False if Toi(A) = True
To(A) is undefined otherwise ;
8. if 0= p: p2 for some p1,P2 E L* then
Fo(A) =True
if b(qo, ) and b(q0,p2) are defined
and b(gto, pi) = 8(403,P2)
To(A)= False
if Alpi and Alp2 are both defined
and are not unifiable
To(A) is undefined otherwise (see Note 4.).
Notes:
</figure>
<listItem confidence="0.792127">
1. We have not included an implication operator in
the formal language, since we find that defining im-
plication in terms of negation and disjunction (i.e
4. sk Ei -10 V 0) yields a semantics for implica-
tion that corresponds exactly to our intuitive un-
derstanding of implication.
2. As one would expect, an atomic formula is satisfied
by the corresponding atomic feature structure. On
the other hand, only atomic feature structures are
</listItem>
<bodyText confidence="0.8694185">
defined as contradicting an atomic formula. Though
a complex feature structure is clearly incompatible
with an atomic formula we do not view it as being
essentially incompatible with it. An interpretation
of negation that defines a complex feature structure
as contradicting a (and hence satisfying --,a) is also
possible. However, our definition is motivated by
the linguistic intention of the negation operator as
given by Karttunen [Kar84]. Thus, for instance, we
require that an automaton satisfying the formula
case : -,dative have an atomic value for the case
feature.
</bodyText>
<listItem confidence="0.747651">
3. In 4. above, we state that: Yo(A) = (All) if .All
is defined. When All is defined, 74,1(A/1) may still
</listItem>
<page confidence="0.917489">
20
</page>
<bodyText confidence="0.953799578947368">
be True, False or undefined. In any of these cases,
Fp(A) = Fo1(A/08. .7.4,(A) is not defined if All
is not defined. Not only is this condition required
to preserve upward-closure, it is also linguistically
motivated.
Here again, we could have said that a formula of the
form I : gil is contradicted by any atomic feature
structure, but we have chosen not to do so for the
reasons outlined in the previous note.
4. We have chosen to state that the set of automata
that are incompatible with the formula p1 7)2 is not
the set of automata for which 6(go, pi) and 6(go, p2)
are defined and 5(go,pi) 5(go,p2), since such an
automaton could subsume one in which 6(go, pi) =
6(go,p2). Thus, we would lose the property of
upward-closure under subsumption. However, an
automaton, A, in which b(go,pi) and 6(go,p2) are
defined and A/pi is not unifiable&apos; with Alp2 can-
not subsume one in which 6(go, pi) = 5(go, p2 ).
</bodyText>
<subsectionHeader confidence="0.839324">
2.2.1 Upward-Closure
</subsectionHeader>
<bodyText confidence="0.99907425">
As has been stated before, the set of automata that satisfy
a given formula in the logic defined above is upward-closed
under subsumption. This property is formally stated be-
low.
</bodyText>
<construct confidence="0.736057666666667">
Theorem 2.1 Given a formula 4&apos; and two acyclic finite
automata A and 5, if 7,0(A) is defined and .4 C B then
F4(B) is defined and F4,(13)=
</construct>
<sectionHeader confidence="0.430841" genericHeader="introduction">
Proof:
</sectionHeader>
<bodyText confidence="0.999904">
The proof is by induction on the structure of the formula.
The details may be found in Dawar [Daw88].
</bodyText>
<subsectionHeader confidence="0.991072">
2.3 Examples
</subsectionHeader>
<bodyText confidence="0.999991">
We now take a look at the examples mentioned earlier and
see how they are interpreted in the logic just defined. The
first example expressed the agreement attribute of the verb
sleep by the following formula:
</bodyText>
<equation confidence="0.86914">
agreement : -,(person : third A number : singular) (1)
</equation>
<bodyText confidence="0.9983688">
This formula is satisfied by any structure that has an agree-
ment feature which, in turn, either has a person feature
with a value other than third or a number feature with a
value other than singular. Thus, for instance, the following
two structures satisfy the given formula:
</bodyText>
<equation confidence="0.881794">
[cat : VP
agreement : [ person : second
</equation>
<footnote confidence="0.9302305">
8Equality here is strong equality (i.e. if .74,1(A/1) is undefined
then so is .F.(A).)
9Two automata are not unifiable if and only if they do not have
a least upper bound
</footnote>
<equation confidence="0.94112575">
[ [
person :third
agreement :
number : plural
</equation>
<bodyText confidence="0.997765909090909">
On the other hand, for a structure to contradict formula( 1)
it must have an agreement feature defined for both person
and number with values third and singular respectively. All
other automata would have an undefined truth value for
formula( 1).
Turning to the other example mentioned earlier, the
formula:
obj : type : reflexive V -,(subj : ref obi : ref) (2)
is satisfied by the first two of the following structures, but
is contradicted by the third (here co-index boxes are used
to indicate co-reference or path-equivalence).
</bodyText>
<equation confidence="0.984129166666666">
obj : [ type : reflexive 3
[obj:[ ref: fl 3 I
subj :[ ref: 3
&amp;quot;) type : reflexive]
G.I. [ref :
subj : [ ref: 0 3
</equation>
<sectionHeader confidence="0.629539" genericHeader="method">
3 Comparison with Other Interpreta-
</sectionHeader>
<subsectionHeader confidence="0.312304">
tions of Negation
</subsectionHeader>
<bodyText confidence="0.999963714285714">
As we have stated before, the semantics for negation de-
scribed in the previous section is motivated by the dis-
cussion of negation in Karttunen (Kar84), and that it is
closely related to the interpretation of Kasper [Kas88]. In
this section, we take a look at the interpretations of nega-
tion that have been suggested and how they may be related
to interpretations in a three-valued framework.
</bodyText>
<subsectionHeader confidence="0.998226">
3.1 Classical Negation
</subsectionHeader>
<bodyText confidence="0.999818777777778">
By classical negation, we mean an interpretation in which
an automaton A satisfies a formula -NO if and only if it does
not satisfy 0. This is, of course, a two-valued logic. Such
an interpretation is used by Johnson in his Attribute-Value
Language [3oh81. We can express it in our framework by
making .7-4, a total function such that wherever .7&amp;quot;5(A) was
undefined, it is now defined to be False.
Returning to our earlier example, we can observe that
for formula( 1) the structure
</bodyText>
<equation confidence="0.512348">
[ agreement : [ person : third 3 3
</equation>
<bodyText confidence="0.900278166666667">
has a truth value of false in the classical semantics but
has an undefined truth value in the semantics we define.
This illustrates the problem of non-monotonicity in the
classical semantics since this structure does subsume one
that satisfies formula (1).
]
</bodyText>
<page confidence="0.990956">
21
</page>
<subsectionHeader confidence="0.993895">
3.2 Intuitionistic Logic
</subsectionHeader>
<bodyText confidence="0.998309238095238">
In [MR87], Moshier and Rounds describe an extension of
the Rounds-Kasper logic, including an implication opera-
tor and hence, by extension, negation. The semantics is
based on intuitionistic techniques. The notion of satisfying
is replaced by one of forcing. Given a set of automata K,
a formula 0, and A such that A E K, A forces in K -&amp;quot;qt.
(Al- - -,0) if and only if for all B E K such that A C B, B
does not force 0 in K. Thus, in order to find if a formula,
0, is satisfiable, we have to find a set K and an automaton
A such that forces in K
Moshier and Rounds consider a version in which forcing
is always done with respect to the set of all automata,
i.e. This means that the set of feature structures
that satisfy is the largest upward-closed set of feature
structures that do not satisfy 0 (i.e. the set of feature
structures incompatible with 0). We can capture this in
the three-valued framework described above by modifying
the definition of .7.0 to make it False for all automata that
are incompatible (trivially or essentially) with 0 (we call
this new function 7:6). The definition of .F differs from
that of F0 in the following cases:
</bodyText>
<figure confidence="0.220247923076923">
• 0 = a
.7-0(A) = True
if .4 is atomic and A(q0) = a
.F0(A) = False otherwise
• yt, = 1: 01
= True
if .7-0(A) = True
.F,;(4) = False
if All is defined and
VB(All C B ni(B) = False)
T&apos;i,(A) is undefined otherwise.
• fib, = 4;61 A 402
n(A) = True
</figure>
<construct confidence="0.349655666666667">
if .F01(.4) = True and .7-03(A) = True
11,(A) = False
if V B(A C B
</construct>
<listItem confidence="0.74912625">
F(8) 0 True or F4,2(B) 0 True)
70(.4) is undefined otherwise ;
• 4, = 01 V 02
.77(A) = True
</listItem>
<construct confidence="0.954654">
if .F0 , (A) = True or .F.02(A) = True
.F(A) = False
if VB(A C B
</construct>
<footnote confidence="0.204969">
771,1(8) 0 True and n2(5) 0 True)
.F.0(A) is undefined otherwise;
</footnote>
<figure confidence="0.515239428571429">
• 4) = P1 p2
.n(A) =True
iafn5(yo6pop
i,) i) = .5(g
and 5(yoo,,72)) are defined
d 6
7,11,(A) = False
</figure>
<bodyText confidence="0.987154787234042">
if Alpi and A/p2 are both defined
and are not unifiable or if A is atomic
.n(A) is undefined otherwise .
In the other cases, the definition of .7; parallels that
of F.
To illustrate the difference between .Fc;, and 74„ we
define the following (somewhat contrived) formula:
=(li : a v 12 : a) A :
We also define the automaton
A = [11 : b]
We can now observe that ./.0(A) is undefined but .14, (A) =
False. To see how this arises, note that in either system,
the truth value of A is undefined with respect to each of
the conjuncts of 0. This is so because A can certainly be
extended to satisfy either one of the conjuncts, just as it
can be extended to contradict either one of them. But, for
.F0(A) to be False, A must have a truth value of False
for one of the conjuncts and therefore F0(A) is undefined.
On the other hand, since A can never be extended to sat-
isfy both conjuncts of 0 simultaneously, it can never be
extended to satisfy 0. Hence A is certainly incompatible
with 0, but because this incompatibility is a result of the
excess of information in the formula itself, we say that it
is only trivially incompatible with 0.
To see more clearly what is going on in the above ex-
ample, consider the formula -10 and apply distributivity
and DeMorgan&apos;s law (which is a valid equivalence in the
logic described in the previous section, but not in the in-
tuitionistic logic of this section) which gives us:
-10 =(-ilj : a A : a) V : b
We can now see why we do not wish A to satisfy which
would be the case if F(A) were False.
One justification given for the use of forcing sets other
than K&apos; is the interpretation of formulae such as --,11 :
NIL. It is argued that since h: NIL denotes all feature
structures that have a feature labeled h, : NIL should
denote those structures that do not have such a feature.
However, the formula -di, : NIL is unsatisfiable both in
the interpretation given in the last section as well as in the
IC version of intuitionistic logic. It is our opinion that the
use of negation to assert the non-existence of features is
an operation distinct from the use of negation to describe
values and should be described by a distinct operator. The
present work attempts to deal only with the latter notion of
negation. The authors expect to present in a forthcomitg
paper a simple extension to the current semantics that will
deal with issues of existence of features.
</bodyText>
<page confidence="0.985621">
22
</page>
<subsectionHeader confidence="0.946824">
3.3 Karttunen&apos;s Implementation of Negation
</subsectionHeader>
<bodyText confidence="0.785286333333333">
As mentioned earlier, our approach was motivated by
Karttunen&apos;s implementation as described in [Kar84]. In
the unification algorithm given, negative constraints axe
attached to feature structures or automata (which them-
selves do not have any negative values). When the feature
structure is extended to have enough information to deter-
mine whether it satisfies or falsifies&apos; the formula then the
constraints may be dropped. We feel that our definition
of the Uset elegantly captures the notion of associating
constraints with automata that do not have sufficient in-
formation to determine whether they satisfy or contradict
a given formula.
</bodyText>
<sectionHeader confidence="0.8331805" genericHeader="method">
3.4 Kasper&apos;s Interpretation of Negation and
Conditionals
</sectionHeader>
<bodyText confidence="0.994199947368421">
As mentioned earlier, Kasper [Kas88] used the operations
of negation and implication in extending Functional Unifi-
cation Grammar. Though the semantics defined for these
operators is a classical one, for the purposes of the algo-
rithm Kasper identified three classes of automata associ-
ated with any formula: those that satisfy it, those that are
incompatible with it and those that are merely compatible
with it. We can observe that these are closely related to
our Tset, Fset and Uset respectively. For instance, Kasper
states that an automaton ,4 satisfies a formula 1: v if it
is defined for f with value v; it is incompatible with 1: v
if it is defined for f with value x (x v) and it is merely
compatible with f : v if it is not defined for f. In three-
valued logic, we incorporate these notions into the formal
semantics, thus providing a formal basis for the unification
procedure given by Kasper. Our logic also gives a more
uniform treatment to the negation operator since we have
removed the restriction that disallowed path equivalences
in the scope of a negation.
</bodyText>
<sectionHeader confidence="0.998591" genericHeader="method">
4 Computational Issues
</sectionHeader>
<bodyText confidence="0.958982111111111">
In this section, we will discuss some computational as-
pects related to determining whether a formula is satisfi-
able or not. We will show that the satisfiability problem is
NP-complete, which is not surprising considering that the
problem is NP-complete for the logic not involving nega-
tion (Rounds-Kasper logic).
The NP-hardness of this problem is trivially shown
if we observe that for any formula, 0, without negation,
Tset(0) is exactly the set of automata that satisfy 0 ac-
cording to the definition of satisfaction given by Rounds
10It is not clear whether falsification is equivalent to incompat-
ibility or only essential incompatibility, but from the examples in-
volving case and agreement, we believe that only essential incom-
patibility is intended.
and Kasper [KR86, RK86] in their original logic. Since
the satisfiability problem in that logic is NP-complete, the
given problem is NP-hard.
In order to see that the given problem is in NP, we
observe that a simple nondeterministic algorithm&amp;quot; can be
given that is linear in the length of the input formula 0
and that returns a minimal automaton which satisfies cb ,
provided it is satisfiable. To see this, note that the size
(in terms of the number of states) of a minimal automa-
ton satisfying 0 is linear in the length of 0 and verifying
whether a given automaton satisfies 0 is a problem linear
in the length of 0 and the size of the automaton. The
details of the algorithm can be found in Dawar [Daw881.
</bodyText>
<sectionHeader confidence="0.999874" genericHeader="conclusions">
5 Conclusions
</sectionHeader>
<bodyText confidence="0.999983666666667">
A logical formalism with a complete set of logical operators
has come to be accepted as a means of describing feature
structures. While the intended semantics of most of these
operators is well understood, the negation and implication
operators have raised some problems, leading to a vari-
ety of approaches in their interpretation. In the present
work, we have presented an interpretation that combines
the following advantages: it is formally simple as well as
uniform (it places no special restriction on the negation
operator); it is motivated by the linguistic applications of
feature structures; it takes into account the partial na-
ture of feature structures by preserving the property of
monotonicity under unification and it is computationally
no harder than the Rounds-Kasper logic. More signifi-
cantly, perhaps, we have shown that most existing inter-
pretations of negation can also be expressed within three-
valued logic. This framework therefore provides a means
for comparing and evaluating various interpretations.
</bodyText>
<sectionHeader confidence="0.999554" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.990805153846154">
[Daw88] Anuj Dawar. The Semantics of Negation in Fea-
ture Structure Descriptions. Master&apos;s thesis, Uni-
versity of Delaware, 1988.
[Fit69] Melvin Fitting. Intuitionistic Logic and Model
Theoretic Forcing. North-Holland, Amsterdam,
1969.
[Joh87] Mark Johnson. Attribute Value Logic and the
Theory of Grammar. PhD thesis, Stanford Uni-
versity, August 1987.
[Kar84] Lauri Karttunen. Features and values. In Pro-
ceedings of the Tenth International Conference on
Computational Linguistics, July 1984.
&amp;quot;this algorithm assumes that the set of atoms is finite.
</reference>
<page confidence="0.973406">
23
</page>
<reference confidence="0.999430193548387">
[Kas87] Robert T. Kasper. Feature Structures: A Logical
Theory with Application to Language Analysis.
PhD thesis, University of Michigan, 1987.
[Kas88] Robert T. Kasper. Conditional descriptions in
Functional Unification Grammar. In Proceedings
of the 26th Annual Meeting of the Association for
Computational Linguistics, pages 233-240, June
1988.
[Kay79] M. Kay. Functional grammar. In Proceedings of
the Fifth Annual Meeting of the Berkeley Linguis-
tics Society, 1979.
[K1e52] S. C. Kleene. Introduction to Metamathematics.
Van Nostrand, New York, 1952.
[KR86] Robert T. Kasper and William C. Rounds. A
logical semantics for feature structures. In Pro-
ceedings of the 24th Annual Meeting of the Asso-
ciation for Computational Linguistics, 1986.
[MR87] M. Drew Moshier and William C. Rounds. A
logic for partially specified data structures. In
ACM Symposium on the Principles of Program-
ming Languages, pages 156-167, ACM, 1987.
[Per87] Fernando C. N. Pereira. Grammars and logics
of partial information. In Jean-Louis Lasses, ed-
itor, Proceedings of the 4th International Con-
ference on Logic Programming, pages 989-1013,
May 1987.
[RK86] William C. Rounds and Robert T. Kasper.
A complete logical calculus for record struc-
tures representing linguistic information. In
IEEE Symposium on Logic in Computer Science,
pages 34-43, IEEE Computer Society, June 1986.
</reference>
<page confidence="0.998951">
214
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.896646">
<title confidence="0.9945945">A THREE-VALUED INTERPRETATION OF NEGATION IN FEATURE STRUCTURE DESCRIPTIONS</title>
<author confidence="0.980591">Anuj Dawar</author>
<affiliation confidence="0.999888">Dept. of Comp. and Info. Science University of Pennsylvania</affiliation>
<address confidence="0.999821">Philadelphia, PA 19104</address>
<author confidence="0.982482">K Vijay-Shanker</author>
<affiliation confidence="0.999904">Dept. of Comp. and Info. Science University of Delaware</affiliation>
<address confidence="0.965417">Newark, DE 19716</address>
<date confidence="0.994505">April 20, 1989</date>
<abstract confidence="0.998419533333333">Feature structures are informational elements that have been used in several linguistic theories and in computational systems for natural-language processing. A logical calculus has been developed and used as a description language for feature structures. In the present work, a framework in three-valued logic is suggested for defining the semantics of a feature structure description language, allowing for a more complete set of logical operators. In particular, the semantics of the negation and implication operators are examined. Various proposed interpretations of negation and implication are compared within the suggested framework. One particular interpretation of the description language with a negation operator is described and its computational aspects studied.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Anuj Dawar</author>
</authors>
<title>The Semantics of Negation in Feature Structure Descriptions. Master&apos;s thesis,</title>
<date>1988</date>
<institution>University of Delaware,</institution>
<contexts>
<context position="12767" citStr="[Daw88]" startWordPosition="2194" endWordPosition="2194">n. However, an automaton, A, in which b(go,pi) and 6(go,p2) are defined and A/pi is not unifiable&apos; with Alp2 cannot subsume one in which 6(go, pi) = 5(go, p2 ). 2.2.1 Upward-Closure As has been stated before, the set of automata that satisfy a given formula in the logic defined above is upward-closed under subsumption. This property is formally stated below. Theorem 2.1 Given a formula 4&apos; and two acyclic finite automata A and 5, if 7,0(A) is defined and .4 C B then F4(B) is defined and F4,(13)= Proof: The proof is by induction on the structure of the formula. The details may be found in Dawar [Daw88]. 2.3 Examples We now take a look at the examples mentioned earlier and see how they are interpreted in the logic just defined. The first example expressed the agreement attribute of the verb sleep by the following formula: agreement : -,(person : third A number : singular) (1) This formula is satisfied by any structure that has an agreement feature which, in turn, either has a person feature with a value other than third or a number feature with a value other than singular. Thus, for instance, the following two structures satisfy the given formula: [cat : VP agreement : [ person : second 8Equ</context>
</contexts>
<marker>[Daw88]</marker>
<rawString>Anuj Dawar. The Semantics of Negation in Feature Structure Descriptions. Master&apos;s thesis, University of Delaware, 1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Melvin Fitting</author>
</authors>
<title>Intuitionistic Logic and Model Theoretic Forcing.</title>
<date>1969</date>
<publisher>North-Holland,</publisher>
<location>Amsterdam,</location>
<contexts>
<context position="5065" citStr="[Fit69]" startWordPosition="774" endWordPosition="774">s of negation by disallowing path expressions within the scope of a negation. This restriction may not be linguistically warranted as can be seen by the following example from Pereira [Per87] which expresses the semantic constraint that the subject and object of a clause cannot be coreferential unless the object is a reflexive pronoun: obj :type : reflexive V —1(subj : ref 7z obj : ref) Moshier and Rounds [MR87] proposed an intuitionistic interpretation of negation that preserves upward-closure. They replace the notion of satisfaction with one of modeltheoretic forcing as described in Fitting [Fit69]. They also provide a complete proof system for their logic. The satisfiability problem for this logic was shown to be PS PACEcomplete. 1.3 Outline of this Paper In the following section we will present our proposed solution in a three-valued framework, for defining the semantics of feature structure descriptions including negation&apos;. This solution is a formalization of the notion of negation in Karttunen [Kar84]. In Section 3 we will show that the framework of three-valued logic is flexible enough to express most of the different interpretations of negation mentioned above. In Section 4 we wil</context>
</contexts>
<marker>[Fit69]</marker>
<rawString>Melvin Fitting. Intuitionistic Logic and Model Theoretic Forcing. North-Holland, Amsterdam, 1969.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Johnson</author>
</authors>
<title>Attribute Value Logic and the Theory of Grammar.</title>
<date>1987</date>
<tech>PhD thesis,</tech>
<institution>Stanford University,</institution>
<contexts>
<context position="3833" citStr="[Joh87]" startWordPosition="585" endWordPosition="585">earchers in the area have suggested that the logic described above should be extended to include negation and implication. Karttunen [Kar841 provides examples of feature structures where a negation operator might be useful. For instance, the most natural way to represent the number and person attributes of a verb such as sleep would be to say 18 2 Feature Structure Descriptions with Negation that it is not third person singular rather than expressing it as a disjunction of the other five possibilities. Karttunen also suggests an implementation technique to handle negative information. Johnson [Joh87], defined an Attribute Value Logic (AVL), similar to the Rounds-Kasper Logic, that included a classical form of negation. Kasper [Kas88] discusses an interpretation of negation and implication in an implementation of Functional Unification Grammar [Kay79] that includes conditionals. Kasper&apos;s semantics is classical, but his unification procedure uses notions similar to those of three-valued logic&apos;. One aspect of the classical approach is that the property of upward-closure under subsumption is lost. Thus the evaluation of negation may not be freely interleaved with unification 2. In [Kas88], Ka</context>
</contexts>
<marker>[Joh87]</marker>
<rawString>Mark Johnson. Attribute Value Logic and the Theory of Grammar. PhD thesis, Stanford University, August 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
</authors>
<title>Features and values.</title>
<date>1984</date>
<booktitle>In Proceedings of the Tenth International Conference on Computational Linguistics,</booktitle>
<contexts>
<context position="2047" citStr="[Kar84]" startWordPosition="294" endWordPosition="294">ures. Several researchers have expressed a need for extending this logic to include the operators of negation and implication. Various interpretations have been suggested that define a semantics for these operators (see Section 1.2), but none has gained universal acceptance. In [Feral, Pereira set forth certain properties that any such interpretation should satisfy. In this paper we present an extended logical calculus, with a semantics in three-valued logic (based on Kleene&apos;s three-valued logic [K1e52]), that includes an interpretation of negation motivated by the approach given by Karttunen [Kar84]. We show that our logic meets the conditions stated by Pereira. We also show that the three-valued framework is powerful enough to express most of the proposed definitions of negation and implication. It therefore makes it possible to compare these different approaches. 1.1 Rounds-Kasper Logic In [Kas87] and [RK86], Rounds and Kasper introduced a logical formalism to describe feature structures with disjunctive specification. The language is a form of modal propositional logic (with modal operator &amp;quot;:&amp;quot;). In order to define the semantics of this language, feature structures are formally defined</context>
<context position="5480" citStr="[Kar84]" startWordPosition="842" endWordPosition="842"> proposed an intuitionistic interpretation of negation that preserves upward-closure. They replace the notion of satisfaction with one of modeltheoretic forcing as described in Fitting [Fit69]. They also provide a complete proof system for their logic. The satisfiability problem for this logic was shown to be PS PACEcomplete. 1.3 Outline of this Paper In the following section we will present our proposed solution in a three-valued framework, for defining the semantics of feature structure descriptions including negation&apos;. This solution is a formalization of the notion of negation in Karttunen [Kar84]. In Section 3 we will show that the framework of three-valued logic is flexible enough to express most of the different interpretations of negation mentioned above. In Section 4 we will show that the satisfiability problem for the logic we propose is NP-complete. lsee Section 3.4 2see Pereira (Per871 p.1006 3We shall concentrate only on the problem of extending the logic to include the negation operator, and later in Section 3.4 discuss implication. We will now present our extended version of the Rounds. Kasper logic including negation. We do this by giving the semantics of the logic in a thr</context>
<context position="11172" citStr="[Kar84]" startWordPosition="1906" endWordPosition="1906">ication. 2. As one would expect, an atomic formula is satisfied by the corresponding atomic feature structure. On the other hand, only atomic feature structures are defined as contradicting an atomic formula. Though a complex feature structure is clearly incompatible with an atomic formula we do not view it as being essentially incompatible with it. An interpretation of negation that defines a complex feature structure as contradicting a (and hence satisfying --,a) is also possible. However, our definition is motivated by the linguistic intention of the negation operator as given by Karttunen [Kar84]. Thus, for instance, we require that an automaton satisfying the formula case : -,dative have an atomic value for the case feature. 3. In 4. above, we state that: Yo(A) = (All) if .All is defined. When All is defined, 74,1(A/1) may still 20 be True, False or undefined. In any of these cases, Fp(A) = Fo1(A/08. .7.4,(A) is not defined if All is not defined. Not only is this condition required to preserve upward-closure, it is also linguistically motivated. Here again, we could have said that a formula of the form I : gil is contradicted by any atomic feature structure, but we have chosen not to</context>
<context position="19820" citStr="[Kar84]" startWordPosition="3500" endWordPosition="3500"> version of intuitionistic logic. It is our opinion that the use of negation to assert the non-existence of features is an operation distinct from the use of negation to describe values and should be described by a distinct operator. The present work attempts to deal only with the latter notion of negation. The authors expect to present in a forthcomitg paper a simple extension to the current semantics that will deal with issues of existence of features. 22 3.3 Karttunen&apos;s Implementation of Negation As mentioned earlier, our approach was motivated by Karttunen&apos;s implementation as described in [Kar84]. In the unification algorithm given, negative constraints axe attached to feature structures or automata (which themselves do not have any negative values). When the feature structure is extended to have enough information to determine whether it satisfies or falsifies&apos; the formula then the constraints may be dropped. We feel that our definition of the Uset elegantly captures the notion of associating constraints with automata that do not have sufficient information to determine whether they satisfy or contradict a given formula. 3.4 Kasper&apos;s Interpretation of Negation and Conditionals As men</context>
</contexts>
<marker>[Kar84]</marker>
<rawString>Lauri Karttunen. Features and values. In Proceedings of the Tenth International Conference on Computational Linguistics, July 1984. &amp;quot;this algorithm assumes that the set of atoms is finite.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert T Kasper</author>
</authors>
<title>Feature Structures: A Logical Theory with Application to Language Analysis.</title>
<date>1987</date>
<tech>PhD thesis,</tech>
<institution>University of Michigan,</institution>
<contexts>
<context position="2353" citStr="[Kas87]" startWordPosition="343" endWordPosition="343">ertain properties that any such interpretation should satisfy. In this paper we present an extended logical calculus, with a semantics in three-valued logic (based on Kleene&apos;s three-valued logic [K1e52]), that includes an interpretation of negation motivated by the approach given by Karttunen [Kar84]. We show that our logic meets the conditions stated by Pereira. We also show that the three-valued framework is powerful enough to express most of the proposed definitions of negation and implication. It therefore makes it possible to compare these different approaches. 1.1 Rounds-Kasper Logic In [Kas87] and [RK86], Rounds and Kasper introduced a logical formalism to describe feature structures with disjunctive specification. The language is a form of modal propositional logic (with modal operator &amp;quot;:&amp;quot;). In order to define the semantics of this language, feature structures are formally defined in terms of acyclic finite automata. These are finite-state automata whose transition graphs are acyclic. The formal definition may be found in [RK86]. A fundamental property of the semantics is that the set of automata satisfying a given formula is upward-closed under the operation of subsumption. This </context>
</contexts>
<marker>[Kas87]</marker>
<rawString>Robert T. Kasper. Feature Structures: A Logical Theory with Application to Language Analysis. PhD thesis, University of Michigan, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert T Kasper</author>
</authors>
<title>Conditional descriptions in Functional Unification Grammar.</title>
<date>1988</date>
<booktitle>In Proceedings of the 26th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>233--240</pages>
<contexts>
<context position="3969" citStr="[Kas88]" startWordPosition="605" endWordPosition="605">r841 provides examples of feature structures where a negation operator might be useful. For instance, the most natural way to represent the number and person attributes of a verb such as sleep would be to say 18 2 Feature Structure Descriptions with Negation that it is not third person singular rather than expressing it as a disjunction of the other five possibilities. Karttunen also suggests an implementation technique to handle negative information. Johnson [Joh87], defined an Attribute Value Logic (AVL), similar to the Rounds-Kasper Logic, that included a classical form of negation. Kasper [Kas88] discusses an interpretation of negation and implication in an implementation of Functional Unification Grammar [Kay79] that includes conditionals. Kasper&apos;s semantics is classical, but his unification procedure uses notions similar to those of three-valued logic&apos;. One aspect of the classical approach is that the property of upward-closure under subsumption is lost. Thus the evaluation of negation may not be freely interleaved with unification 2. In [Kas88], Kasper localized the effects of negation by disallowing path expressions within the scope of a negation. This restriction may not be lingu</context>
<context position="14497" citStr="[Kas88]" startWordPosition="2503" endWordPosition="2503">j : type : reflexive V -,(subj : ref obi : ref) (2) is satisfied by the first two of the following structures, but is contradicted by the third (here co-index boxes are used to indicate co-reference or path-equivalence). obj : [ type : reflexive 3 [obj:[ ref: fl 3 I subj :[ ref: 3 &amp;quot;) type : reflexive] G.I. [ref : subj : [ ref: 0 3 3 Comparison with Other Interpretations of Negation As we have stated before, the semantics for negation described in the previous section is motivated by the discussion of negation in Karttunen (Kar84), and that it is closely related to the interpretation of Kasper [Kas88]. In this section, we take a look at the interpretations of negation that have been suggested and how they may be related to interpretations in a three-valued framework. 3.1 Classical Negation By classical negation, we mean an interpretation in which an automaton A satisfies a formula -NO if and only if it does not satisfy 0. This is, of course, a two-valued logic. Such an interpretation is used by Johnson in his Attribute-Value Language [3oh81. We can express it in our framework by making .7-4, a total function such that wherever .7&amp;quot;5(A) was undefined, it is now defined to be False. Returning</context>
<context position="20450" citStr="[Kas88]" startWordPosition="3595" endWordPosition="3595">gorithm given, negative constraints axe attached to feature structures or automata (which themselves do not have any negative values). When the feature structure is extended to have enough information to determine whether it satisfies or falsifies&apos; the formula then the constraints may be dropped. We feel that our definition of the Uset elegantly captures the notion of associating constraints with automata that do not have sufficient information to determine whether they satisfy or contradict a given formula. 3.4 Kasper&apos;s Interpretation of Negation and Conditionals As mentioned earlier, Kasper [Kas88] used the operations of negation and implication in extending Functional Unification Grammar. Though the semantics defined for these operators is a classical one, for the purposes of the algorithm Kasper identified three classes of automata associated with any formula: those that satisfy it, those that are incompatible with it and those that are merely compatible with it. We can observe that these are closely related to our Tset, Fset and Uset respectively. For instance, Kasper states that an automaton ,4 satisfies a formula 1: v if it is defined for f with value v; it is incompatible with 1: </context>
</contexts>
<marker>[Kas88]</marker>
<rawString>Robert T. Kasper. Conditional descriptions in Functional Unification Grammar. In Proceedings of the 26th Annual Meeting of the Association for Computational Linguistics, pages 233-240, June 1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Kay</author>
</authors>
<title>Functional grammar.</title>
<date>1979</date>
<booktitle>In Proceedings of the Fifth Annual Meeting of the Berkeley Linguistics Society,</booktitle>
<contexts>
<context position="4088" citStr="[Kay79]" startWordPosition="621" endWordPosition="621">way to represent the number and person attributes of a verb such as sleep would be to say 18 2 Feature Structure Descriptions with Negation that it is not third person singular rather than expressing it as a disjunction of the other five possibilities. Karttunen also suggests an implementation technique to handle negative information. Johnson [Joh87], defined an Attribute Value Logic (AVL), similar to the Rounds-Kasper Logic, that included a classical form of negation. Kasper [Kas88] discusses an interpretation of negation and implication in an implementation of Functional Unification Grammar [Kay79] that includes conditionals. Kasper&apos;s semantics is classical, but his unification procedure uses notions similar to those of three-valued logic&apos;. One aspect of the classical approach is that the property of upward-closure under subsumption is lost. Thus the evaluation of negation may not be freely interleaved with unification 2. In [Kas88], Kasper localized the effects of negation by disallowing path expressions within the scope of a negation. This restriction may not be linguistically warranted as can be seen by the following example from Pereira [Per87] which expresses the semantic constrain</context>
</contexts>
<marker>[Kay79]</marker>
<rawString>M. Kay. Functional grammar. In Proceedings of the Fifth Annual Meeting of the Berkeley Linguistics Society, 1979.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S C Kleene</author>
</authors>
<title>Introduction to Metamathematics.</title>
<date>1952</date>
<location>Van Nostrand, New York,</location>
<contexts>
<context position="1948" citStr="[K1e52]" startWordPosition="279" endWordPosition="279">er [KR86, RK86] developed a logical calculus that serves as a description language for these structures. Several researchers have expressed a need for extending this logic to include the operators of negation and implication. Various interpretations have been suggested that define a semantics for these operators (see Section 1.2), but none has gained universal acceptance. In [Feral, Pereira set forth certain properties that any such interpretation should satisfy. In this paper we present an extended logical calculus, with a semantics in three-valued logic (based on Kleene&apos;s three-valued logic [K1e52]), that includes an interpretation of negation motivated by the approach given by Karttunen [Kar84]. We show that our logic meets the conditions stated by Pereira. We also show that the three-valued framework is powerful enough to express most of the proposed definitions of negation and implication. It therefore makes it possible to compare these different approaches. 1.1 Rounds-Kasper Logic In [Kas87] and [RK86], Rounds and Kasper introduced a logical formalism to describe feature structures with disjunctive specification. The language is a form of modal propositional logic (with modal operat</context>
</contexts>
<marker>[K1e52]</marker>
<rawString>S. C. Kleene. Introduction to Metamathematics. Van Nostrand, New York, 1952.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert T Kasper</author>
<author>William C Rounds</author>
</authors>
<title>A logical semantics for feature structures.</title>
<date>1986</date>
<booktitle>In Proceedings of the 24th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<contexts>
<context position="1356" citStr="[KR86, RK86]" startWordPosition="191" endWordPosition="192">ular, the semantics of the negation and implication operators are examined. Various proposed interpretations of negation and implication are compared within the suggested framework. One particular interpretation of the description language with a negation operator is described and its computational aspects studied. 1 Introduction and Background A number of linguistic theories and computational approaches to parsing natural language have employed the notion of associating informational elements, called feature structures, consisting of features and their values, with phrases. Rounds and Kasper [KR86, RK86] developed a logical calculus that serves as a description language for these structures. Several researchers have expressed a need for extending this logic to include the operators of negation and implication. Various interpretations have been suggested that define a semantics for these operators (see Section 1.2), but none has gained universal acceptance. In [Feral, Pereira set forth certain properties that any such interpretation should satisfy. In this paper we present an extended logical calculus, with a semantics in three-valued logic (based on Kleene&apos;s three-valued logic [K1e52]), that </context>
<context position="22288" citStr="[KR86, RK86]" startWordPosition="3903" endWordPosition="3904">em is NP-complete, which is not surprising considering that the problem is NP-complete for the logic not involving negation (Rounds-Kasper logic). The NP-hardness of this problem is trivially shown if we observe that for any formula, 0, without negation, Tset(0) is exactly the set of automata that satisfy 0 according to the definition of satisfaction given by Rounds 10It is not clear whether falsification is equivalent to incompatibility or only essential incompatibility, but from the examples involving case and agreement, we believe that only essential incompatibility is intended. and Kasper [KR86, RK86] in their original logic. Since the satisfiability problem in that logic is NP-complete, the given problem is NP-hard. In order to see that the given problem is in NP, we observe that a simple nondeterministic algorithm&amp;quot; can be given that is linear in the length of the input formula 0 and that returns a minimal automaton which satisfies cb , provided it is satisfiable. To see this, note that the size (in terms of the number of states) of a minimal automaton satisfying 0 is linear in the length of 0 and verifying whether a given automaton satisfies 0 is a problem linear in the length of 0 and t</context>
</contexts>
<marker>[KR86]</marker>
<rawString>Robert T. Kasper and William C. Rounds. A logical semantics for feature structures. In Proceedings of the 24th Annual Meeting of the Association for Computational Linguistics, 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Drew Moshier</author>
<author>William C Rounds</author>
</authors>
<title>A logic for partially specified data structures.</title>
<date>1987</date>
<booktitle>In ACM Symposium on the Principles of Programming Languages,</booktitle>
<pages>156--167</pages>
<publisher>ACM,</publisher>
<contexts>
<context position="4873" citStr="[MR87]" startWordPosition="748" endWordPosition="748">ach is that the property of upward-closure under subsumption is lost. Thus the evaluation of negation may not be freely interleaved with unification 2. In [Kas88], Kasper localized the effects of negation by disallowing path expressions within the scope of a negation. This restriction may not be linguistically warranted as can be seen by the following example from Pereira [Per87] which expresses the semantic constraint that the subject and object of a clause cannot be coreferential unless the object is a reflexive pronoun: obj :type : reflexive V —1(subj : ref 7z obj : ref) Moshier and Rounds [MR87] proposed an intuitionistic interpretation of negation that preserves upward-closure. They replace the notion of satisfaction with one of modeltheoretic forcing as described in Fitting [Fit69]. They also provide a complete proof system for their logic. The satisfiability problem for this logic was shown to be PS PACEcomplete. 1.3 Outline of this Paper In the following section we will present our proposed solution in a three-valued framework, for defining the semantics of feature structure descriptions including negation&apos;. This solution is a formalization of the notion of negation in Karttunen </context>
<context position="15503" citStr="[MR87]" startWordPosition="2676" endWordPosition="2676">y Johnson in his Attribute-Value Language [3oh81. We can express it in our framework by making .7-4, a total function such that wherever .7&amp;quot;5(A) was undefined, it is now defined to be False. Returning to our earlier example, we can observe that for formula( 1) the structure [ agreement : [ person : third 3 3 has a truth value of false in the classical semantics but has an undefined truth value in the semantics we define. This illustrates the problem of non-monotonicity in the classical semantics since this structure does subsume one that satisfies formula (1). ] 21 3.2 Intuitionistic Logic In [MR87], Moshier and Rounds describe an extension of the Rounds-Kasper logic, including an implication operator and hence, by extension, negation. The semantics is based on intuitionistic techniques. The notion of satisfying is replaced by one of forcing. Given a set of automata K, a formula 0, and A such that A E K, A forces in K -&amp;quot;qt. (Al- - -,0) if and only if for all B E K such that A C B, B does not force 0 in K. Thus, in order to find if a formula, 0, is satisfiable, we have to find a set K and an automaton A such that forces in K Moshier and Rounds consider a version in which forcing is always</context>
</contexts>
<marker>[MR87]</marker>
<rawString>M. Drew Moshier and William C. Rounds. A logic for partially specified data structures. In ACM Symposium on the Principles of Programming Languages, pages 156-167, ACM, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fernando C N Pereira</author>
</authors>
<title>Grammars and logics of partial information.</title>
<date>1987</date>
<booktitle>Proceedings of the 4th International Conference on Logic Programming,</booktitle>
<pages>989--1013</pages>
<editor>In Jean-Louis Lasses, editor,</editor>
<contexts>
<context position="4649" citStr="[Per87]" startWordPosition="708" endWordPosition="708">tion of Functional Unification Grammar [Kay79] that includes conditionals. Kasper&apos;s semantics is classical, but his unification procedure uses notions similar to those of three-valued logic&apos;. One aspect of the classical approach is that the property of upward-closure under subsumption is lost. Thus the evaluation of negation may not be freely interleaved with unification 2. In [Kas88], Kasper localized the effects of negation by disallowing path expressions within the scope of a negation. This restriction may not be linguistically warranted as can be seen by the following example from Pereira [Per87] which expresses the semantic constraint that the subject and object of a clause cannot be coreferential unless the object is a reflexive pronoun: obj :type : reflexive V —1(subj : ref 7z obj : ref) Moshier and Rounds [MR87] proposed an intuitionistic interpretation of negation that preserves upward-closure. They replace the notion of satisfaction with one of modeltheoretic forcing as described in Fitting [Fit69]. They also provide a complete proof system for their logic. The satisfiability problem for this logic was shown to be PS PACEcomplete. 1.3 Outline of this Paper In the following secti</context>
</contexts>
<marker>[Per87]</marker>
<rawString>Fernando C. N. Pereira. Grammars and logics of partial information. In Jean-Louis Lasses, editor, Proceedings of the 4th International Conference on Logic Programming, pages 989-1013, May 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>William C Rounds</author>
<author>Robert T Kasper</author>
</authors>
<title>A complete logical calculus for record structures representing linguistic information.</title>
<date>1986</date>
<booktitle>In IEEE Symposium on Logic in Computer Science,</booktitle>
<pages>34--43</pages>
<publisher>IEEE Computer Society,</publisher>
<contexts>
<context position="1356" citStr="[KR86, RK86]" startWordPosition="191" endWordPosition="192">ular, the semantics of the negation and implication operators are examined. Various proposed interpretations of negation and implication are compared within the suggested framework. One particular interpretation of the description language with a negation operator is described and its computational aspects studied. 1 Introduction and Background A number of linguistic theories and computational approaches to parsing natural language have employed the notion of associating informational elements, called feature structures, consisting of features and their values, with phrases. Rounds and Kasper [KR86, RK86] developed a logical calculus that serves as a description language for these structures. Several researchers have expressed a need for extending this logic to include the operators of negation and implication. Various interpretations have been suggested that define a semantics for these operators (see Section 1.2), but none has gained universal acceptance. In [Feral, Pereira set forth certain properties that any such interpretation should satisfy. In this paper we present an extended logical calculus, with a semantics in three-valued logic (based on Kleene&apos;s three-valued logic [K1e52]), that </context>
<context position="2798" citStr="[RK86]" startWordPosition="411" endWordPosition="411">of the proposed definitions of negation and implication. It therefore makes it possible to compare these different approaches. 1.1 Rounds-Kasper Logic In [Kas87] and [RK86], Rounds and Kasper introduced a logical formalism to describe feature structures with disjunctive specification. The language is a form of modal propositional logic (with modal operator &amp;quot;:&amp;quot;). In order to define the semantics of this language, feature structures are formally defined in terms of acyclic finite automata. These are finite-state automata whose transition graphs are acyclic. The formal definition may be found in [RK86]. A fundamental property of the semantics is that the set of automata satisfying a given formula is upward-closed under the operation of subsumption. This is important, because we consider a formula to be only a partial description of a feature structure. The property is stated in the following theorem [RK86]: Theorem 1.1 A C B if and only if for every formula, 0, if A 4) then B 1.2 The Problem of Adding Negation Several researchers in the area have suggested that the logic described above should be extended to include negation and implication. Karttunen [Kar841 provides examples of feature st</context>
<context position="22288" citStr="[KR86, RK86]" startWordPosition="3903" endWordPosition="3904">em is NP-complete, which is not surprising considering that the problem is NP-complete for the logic not involving negation (Rounds-Kasper logic). The NP-hardness of this problem is trivially shown if we observe that for any formula, 0, without negation, Tset(0) is exactly the set of automata that satisfy 0 according to the definition of satisfaction given by Rounds 10It is not clear whether falsification is equivalent to incompatibility or only essential incompatibility, but from the examples involving case and agreement, we believe that only essential incompatibility is intended. and Kasper [KR86, RK86] in their original logic. Since the satisfiability problem in that logic is NP-complete, the given problem is NP-hard. In order to see that the given problem is in NP, we observe that a simple nondeterministic algorithm&amp;quot; can be given that is linear in the length of the input formula 0 and that returns a minimal automaton which satisfies cb , provided it is satisfiable. To see this, note that the size (in terms of the number of states) of a minimal automaton satisfying 0 is linear in the length of 0 and verifying whether a given automaton satisfies 0 is a problem linear in the length of 0 and t</context>
</contexts>
<marker>[RK86]</marker>
<rawString>William C. Rounds and Robert T. Kasper. A complete logical calculus for record structures representing linguistic information. In IEEE Symposium on Logic in Computer Science, pages 34-43, IEEE Computer Society, June 1986.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>