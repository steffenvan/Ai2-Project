<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000022">
<title confidence="0.983353">
Using answer set programming to answer complex queries
</title>
<author confidence="0.992394">
Chitta Baral
</author>
<affiliation confidence="0.9960495">
Dept. of Computer Sc. &amp; Eng.
Arizona State University
</affiliation>
<address confidence="0.888056">
Tempe, AZ 85287
</address>
<email confidence="0.998941">
chitta@asu.edu
</email>
<author confidence="0.99621">
Michael Gelfond
</author>
<affiliation confidence="0.9915335">
Dept. of Computer Sc.
Texas Tech University
</affiliation>
<address confidence="0.911651">
Lubbock, TX 79409
</address>
<email confidence="0.999287">
mgelfond@cs.ttu.edu
</email>
<author confidence="0.993697">
Richard Scherl
</author>
<affiliation confidence="0.861709666666667">
Computer Science Dept.
Monmouth University
West Long Branch, NJ 07764
</affiliation>
<email confidence="0.998492">
rscherl@monmouth.edu
</email>
<sectionHeader confidence="0.995653" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9992713">
In this paper we discuss the applicability of the
knowledge representation and reasoning lan-
guage AnsProlog for the design and implemen-
tation of query answering systems. We con-
sider a motivating example, and illustrate how
AnsProlog can be used to represent defaults,
causal relations, and other types of common-
sense knowledge needed to properly answer
non-trivial questions about the example’s do-
main.
</bodyText>
<sectionHeader confidence="0.98711" genericHeader="categories and subject descriptors">
1 Introduction and Motivation
</sectionHeader>
<bodyText confidence="0.985328372093023">
Let us envision a query answering system (QAS) con-
sisting of a search engine which searches diverse sources
for information relevant to the given query, Q; a natural
language processing module (NLPM), which translates
this information (including the query) into a theory, F,
of some knowledge representation language G; a gen-
eral knowledge base, KB, containing common-senses
and expert knowledge about various domains; and an in-
ference engine which takes F and KB as an input and
returns an answer to Q. Even though the choice of the
KR language G is irrelevant for the first component of
the system it plays an increasingly important role in the
design of its other components. In this paper we hypothe-
size that AnsProlog - a language of logic programs under
the answer set semantics (Gelfond and Lifschitz, 1988;
Gelfond and Lifschitz, 1991) - is a good candidate for the
KR language of QAS. This is especially true if answer-
ing a query Q requires sophisticated kinds of reasoning
including default, causal, and counterfactual reasoning,
reasoning about narratives, etc.
The list of attractive properties of AnsProlog include
its simplicity and expressive power, ability to reason
with incomplete information, existence of a well devel-
oped mathematical theory and programming methodol-
ogy (Baral, 2003), and the availability of rather efficient
reasoning systems such as SMODELS(Niemela and Si-
mons, 1997) and others as well(Eiter et al., 1997; Yu and
Maratea, 2004). AnsProlog allows its users to encode de-
faults, causal relations, inheritance hierarchies, and other
types of knowledge not readily available in other KR lan-
guages. In addition it supports construction of elabora-
tion tolerant knowledge bases, i.e., ability to accommo-
date new knowledge without doing large scale surgery.
The main drawback of the language is the inability of its
current inference engines to effectively deal with num-
bers and numerical computations1.
In this paper we illustrate the use of AnsProlog for query
answering via a simple example. Of course substantially
more work is needed to to prove (or disprove) our main
hypothesis.
Consider an analyst who would like to use his QAS to
answer simple queries Q1 and Q2 about two people, John
and Bob:
</bodyText>
<listItem confidence="0.994153">
• Q1 – Was John in the Middle East in mid-
December?
• Q2 – If so, did he meet Bob in the Middle East in
mid-December?
</listItem>
<bodyText confidence="0.7856885">
Let us assume that the search engine of QAS extracted
the following simple text relevant to Q1 and Q2:
</bodyText>
<footnote confidence="0.9154556">
1The current answer set solvers start their computation with
grounding the program, i.e. replacing its variables by possible
ground instantiations. The grounding algorithms are smart and
capable of eliminating many useless rules; answer sets can be
effectively computed even if the resulting program consists of
hundreds of thousands of rules. However, if several integer vari-
ables are used by the program rules, the size of the grounded
program becomes unmanageable. We hope however that this
problem will be remedied by the development of new reasoning
algorithms and systems.
</footnote>
<bodyText confidence="0.999638888888889">
John spent Dec 10 in Paris and took a plane to
Baghdad the next morning. He was planning to
meet Bob who was waiting for him there.
We will also assume that the NLP module of the QAS re-
alizes that to answer our queries it needs general knowl-
edge of geography, calendar, and human activities in-
cluding travel, meetings, and plans. In the next section
we outline how such knowledge can be represented in
AnsProlog.
</bodyText>
<sectionHeader confidence="0.950191" genericHeader="method">
2 Representing general knowledge
</sectionHeader>
<subsectionHeader confidence="0.986221">
2.1 The “geography” module M1
</subsectionHeader>
<bodyText confidence="0.983211714285714">
The geography module M1 will contain a list
is(baghdad,city).
is(iraq,country).
...
of places and the definition of relation
in(P1, P2) - “P1 is located in P2”
The definition is given by a collection of facts:
in(baghdad, iraq).
in(iraq,middle_east).
in(paris,france).
in(france,western_europe).
in(western_europe,europe).
...
and the rule
</bodyText>
<equation confidence="0.8970515">
in(P1,P3) :- in(P1,P2),
in(P2,P3).
</equation>
<bodyText confidence="0.9997125">
For simplicity we assume that our information about re-
lation in is complete, i.e., if in(p1, p2) is not known to be
true then it is false. This statement can be expressed by
the rule
</bodyText>
<equation confidence="0.974385">
-in(P1,P2) :- not in(P1,P2)
</equation>
<bodyText confidence="0.9921934375">
often referred to as the CWA- Closed World Assumption
(Reiter, 1978) (for in). Here −p stands for “p is false”
while not p says that “there is no reason to belief p”.
Similar assumption can be written for is. The program
has unique answer set containing in(iraq, middle east),
-in(iraq, europe), etc. This answer set, (or its relevant
parts) can be computed by answer set solvers. Some-
times this will require small additions to the program. For
instance SMODELS, which require typing of variables,
will not be able to compile this program. This problem
can be remedied by adding a rule
position(P) :- is(P,C).
defining the type position and a statement
#domain position(P;P1;P2;P3)
declaring the type of the corresponding variables. Now
SMODELS will be able complete the computation.
</bodyText>
<subsectionHeader confidence="0.817237">
2.2 The “travelling” module M2
</subsectionHeader>
<bodyText confidence="0.979447951219512">
This module describes the effects of a person travelling
from one place to another. We are mainly interested in
locations of people and in various travelling events which
change these locations. Construction of M2 is based on
the theory of dynamic systems () which views the world
as a transition diagram whose states are labelled by flu-
ents (propositions whose values depend on time) and arcs
are labelled by actions. For instance, states of the di-
agram, D, can contain locations of different people; a
transition (σ0, {a1, a2}, σ1) E D iff σ1 is apossible state
of the domain after the concurrent execution of actions
a1 and a2 in σ0. There is a well developed methodol-
ogy of representing dynamic domain in AnsProlog (Baral
and Gelfond, 2000; Turner, 1997) which, in its simplified
form, will be used in the construction of M2.
The language of M2 will contain time-steps from [0, n],
fluent loc(P, X, T) - “place P is a location of person X
at step T”. Various types of travelling events - fly, drive,
etc., will be recorded by the list:
instance_of(fly,travel).
instance_of(drive,travel).
...
Description of an event type will contain the event’s name
and attributes. The following is a generic description of
John flying to Baghdad.
event(a1).
type(a1,fly).
actor(a1,john).
destination(a1,baghdad).
An actual event of this type will be recorded by a state-
ment
occurs(a1, i).
(where i is a time-step in the history of the world) pos-
sibly accompanied by the actual time of i. In addition,
M2 will import relation in(P1, P2) from the geography
module M1.
The transition diagram, D, of M2 will be described by ??
groups of axioms.
•. The first group consists of state constraints establish-
ing the relationship between the domain fluents. In our
case it is sufficient to have the rules:
</bodyText>
<equation confidence="0.967929571428572">
loc(P2,X,T) :- loc(P1,X,T),
in(P2,P1).
disjoint(P1,P2) :- -in(P1,P2),
-in(P2,P1),
neq(P1,P2).
-loc(P2,X,T) :- loc(P1,X,T),
disjoint(P1,P2).
</equation>
<bodyText confidence="0.995729714285714">
Here neq stands for the inequality. The first rule allows
us to conclude that if at step T of the domain history X
is in Iraq then he is also in the Middle East. The second
two rules guarantee that X is not in Europe.
•. The second group contains causal laws describing di-
rect effects of actions. For our example it suffices to have
the rules
</bodyText>
<equation confidence="0.705088142857143">
loc(P,X,T+1) :- occurs(E,T),
type(E,travel),
actor(E,X),
destination(E,P),
-interference(E,T).
-interference(E,T) :-
not interference(E,T).
</equation>
<bodyText confidence="0.9997055">
The first rule says that, in the absence of interference, a
traveller will arrive at his destination. The second - the
CWA for interference - states that the interference is
an unusual event which normally does not happen.
•. The third group consists of executability conditions for
actions, which have the form
</bodyText>
<equation confidence="0.742924">
-occurs(E,T) :- cond(T).
</equation>
<bodyText confidence="0.999844">
which says that it is impossible for an event E occur at
time step T if at that time step the domain is in a state
satisfying condition cond.
Causal laws and state constraints determine changes
caused by execution of an action. To complete the def-
inition of the transition diagram of the domain we need
to specify what fluents do not change as the results of ac-
tions. This is a famous Frame Problem from (McCarthy
and Hayes, 1969) where the authors suggested to solve it
by formalizing the Inertia Axiom which says that “things
tend to stay as they are”. This is a typical default which
can be easily represented in AnsProlog. In our particular
case it will have a form:
</bodyText>
<equation confidence="0.9586475">
loc(P,X,T+1) :- loc(P,X,T),
not -loc(P,X,T+1).
-loc(P,X,T+1) :- -loc(P,X,T),
not loc(P,X,T+1).
</equation>
<bodyText confidence="0.978245642857143">
The above representation is a slightly simplified version
of AnsProlog theory of dynamic domains which gives no-
tation for causal relations of the domain, includes general
(fluent independent) formulation of the inertia, explains
how the set of causal relations define the corresponding
transition diagram, etc. We used this version to simple
save space. Given the following history of the domain
loc(paris,john,0).
loc(baghdad,bob,0).
occurs(a1,0).
information contained in M1 and M2 is sufficient to
conclude loc(baghdad, john, 1), loc(baghdad, bob, 1),
loc(middle east, john, 1), -loc(paris, john, 1), etc. To
answer the original queries we now need to deal with tim-
ing our actions. Let us assume, for instance, that the tim-
ing of John’s departure from Paris is recorded by state-
ments:
time(0,day,11).
time(0,month,12).
time(0,year,03).
Here day, month, and year are the basic time measuring
units.
Finally we may need to specify typical durations of ac-
tions, e.g.
time(T+1,day,D) :- occurs(E,T),
type(E,fly),
time(T,day,D),
not -time(T+1,day,D).
where 1 &lt; D &lt; 31.
To reason about the time relation we need to include a
new module, M3, which will allow us to change granu-
larity of our time measure.
2.3 M3 - measuring time
The module contains types for basic measuring units, e.g.
day(1..31).
month(1..12).
part(start).
part(end).
part(middle).
...
and rules translating from one granularity measure to an-
other, e.g.
</bodyText>
<equation confidence="0.9837765">
time(T,part,middle) :- time(T,d,D),
10 &lt; D &lt; 20.
time(T,season,summer):- time(T,month,M),
5 &lt; M &lt; 9.
</equation>
<bodyText confidence="0.9503872">
...
M3 presented in this paper is deliberately short. It
includes very little knowledge beyond that needed to
answer our query. Ideally it should be much bigger
and include a formalization of the calendar. Among
other things the module should allow us to prove state-
ments like next(date(10,12, 03), date(11,12, 03) and
next(date(31, 12, 03), date(1,1, 04).
Now let us assume that NLP module of our QAS trans-
lated
</bodyText>
<listItem confidence="0.3649855">
(a) information about John’s flight to Baghdad by a his-
tory
</listItem>
<equation confidence="0.461872166666667">
loc(paris,john,0).
loc(baghdad,bob,0).
occurs(a1,0).
time(0,day,11).
time(0,month,12).
(b) the query Q1 by
</equation>
<bodyText confidence="0.8891336">
? loc(middle_east,john,T),
time(T,month,12),
time(T,part,middle).
Modules M1, M2 and M3 have enough information to
correctly answer Q1.
</bodyText>
<subsectionHeader confidence="0.995221">
2.4 Planning the meeting - M4
</subsectionHeader>
<bodyText confidence="0.996879181818182">
To answer the second question we need an additional
module about the event meet. The event type for meet
will be similar to the previously discussed flying event
a1. It may look like:
event(a2).
type(a2,meet).
actor(a2,john).
actor(a2,bob).
place(a2,baghdad).
Notice however that the story contains no information
about actual occurrence of this event. All we know is
that a2 is planned to occur at time step one. We encode
this by simply stating:
planned(a2,1).
Note that to give a positive answer to the question
Q2 –”Did John meet Bob in the Middle East in mid-
December? “ we need to reason about planned events. It
seems that our positive answer to this question is obtain
by using a default: “people normally follow their plans”.
Again this is a typical default statement which, according
to the general knowledge representation methodology of
AnsProlog could be expressed by the rule:
</bodyText>
<equation confidence="0.6932835">
occurs(E,T) :- planned(E,T),
not -occurs(E).
</equation>
<bodyText confidence="0.99988175">
In a slightly more complex situation we may need to as-
sume that people take their plans seriously – they persist
with their plans until the planned event actually happen.
This is encoded as follows:
</bodyText>
<equation confidence="0.732455">
planned(E,T+1) :- planned(E,T),
-occurs(E,T).
</equation>
<bodyText confidence="0.999159970588235">
Unlike traveling, the meeting event does not seem to have
any obvious causal effects. It, however, has the following
executability condition relevant to our story.
-occurs(E,T) :- type(E,meet),
actor(E,X),
place(E,P),
-loc(P,X,T).
Now we have enough information to answer our second
query, which can be encoded as
? occurs(E,T),
type(E,meet),
actor(E,john),
actor(E,bob),
loc(middle_east,john,T),
time(T,month,12),
time(T,part,middle).
As expected the answer will be positive. There are sev-
eral ways to obtain this answer. It can of course be ex-
tracted from the unique answer set of our program. With
small additions of types and declaration of variables sim-
ilar to that we used to define position in M1 this answer
set can be found by SMODELS or any other answer set
solver. This method however may not scale. The problem
is caused the calendar. Its integer variables for months,
days, etc, in conjunction with a longer history (and there-
fore a larger number of time steps) may cause an unman-
ageable increase in the number of ground rules of the pro-
gram. It seems however that in many interesting cases
(including ours), the computation can be made substan-
tially more efficient by properly combining answer set
finding algorithms with the traditional resolution of Pro-
log. The way of doing this will be illustrated in the full
paper. We also plan to expand our modules especially
those dealing with time and reasoning about plans.
</bodyText>
<sectionHeader confidence="0.978916" genericHeader="method">
3 FrameNet and Events
</sectionHeader>
<bodyText confidence="0.999970313725491">
Our vision of the NLPM is that it will translate both our
short text and also the queries into AnsProlog sentences.
There is a body of literature on translating or parsing
English sentences into a semantic representation such as
First Order Logic. See (Blackburn and Bos, 2003) for a
recent survey of such techniques. The semantic represen-
tation makes use of symbols based upon the lexicon of
English.
The success of our endeavor requires that there be an
axiomatization of the relationship between the symbols
representing functions and predicate symbols in our vari-
ous AnsProlog theories (e.g., M1 – M4) and the symbols
(based upon the lexicon of English) used in the seman-
tic representation of the English queries and the narrative
texts. The online lexical database, FrameNet(Baker et al.,
1998) provides such a connection, especially for events.
This is done through the notion of frame semantics that
underlies FrameNet.
Frame semantics assumes that lexical items draw their
meaning from conceptual structures or frames that pro-
vide an abstract or scematic description of particular
types of events. The frames are structured into an inheri-
tance hierarchy. Each frame includes a number offrame
elements (FEs) or roles that make up the conceptual struc-
ture.
For example, our “travelling” module M2 closely corre-
sponds to the related FrameNet frames Travel, Move,
and Ride Vehicle. The frames relate the various frame
elements of Area (where the travelling takes place), Goal
(where the travellers end up), Path (route of the travel),
Source (starting point of the trip), and the Traveller (the
living being which travels).
Consider the phrase took a plane used to express the trav-
elling activity. The verb take is associated with the frame
Ride Vehicle. This information allows the connection
with the axiomatization of flying events in M2. On the
other hand FrameNet does not have entries for the verb
spend as in spent Dec 10. But WordNet(Fellbaum, 1998)
has 3 senses for the verb spend. Sense 1 is “pass – (pass
(time) in a specific way. ‘How are you spending your
summer vacation?’). ” Unfortunately, neither pass nor
time allows us to index a useful frame for just being in a
place. The coverage of FrameNet is not sufficient. It will
be necessary to augment our use of FrameNet with other
online sources such as WordNet and to also increase the
number of frames within FrameNet.
There has been some related work on using the frame of
FrameNet for reasoning (Chang et al., 2002) and also on
the automatic annotation of English texts with regard to
the relevant frames (Gildea and Jurafsky, 2000) and frame
elements.
</bodyText>
<sectionHeader confidence="0.9823" genericHeader="evaluation">
4 Syntax and Semantics of AnsProlog
</sectionHeader>
<bodyText confidence="0.993392">
An AnsProlog knowledge base consists of rules of the
form:
</bodyText>
<equation confidence="0.778432">
l0 — l1,... , l,,,, not l,,,+1, ... , not lam, (4.1)
</equation>
<bodyText confidence="0.999969">
where each of the lis is a literal, i.e. an atom, a, or its clas-
sical negation, -a and not is a logical connective called
negation as failure or default negation. While -a states
that a is false, an expression not l says that there is no
reason to believe in l.
The answer set semantics of a logic program 11 assigns to
11 a collection of answer sets – consistent sets of ground
literals corresponding to beliefs which can be built by a
rational reasoner on the basis of rules of 11. In the con-
struction of these beliefs the reasoner is guided by the
following informal principles:
</bodyText>
<listItem confidence="0.856062">
• He should satisfy the rules of 11, understood as con-
straints of the form: If one believes in the body of a
rule one must belief in its head.
• He should adhere to the rationality principle which
says that one shall not believe anything he is not
forced to believe.
</listItem>
<bodyText confidence="0.96475475">
The precise definition of answer sets is first given for pro-
grams whose rules do not contain default negation. Let 11
be such a program and X a consistent set of ground liter-
als. Set X is closed under 11 if, for every rule (4.1) of 11,
</bodyText>
<equation confidence="0.839359666666667">
l0 E X whenever for every 1 &lt; i &lt; m, li E X and for
every m + 1 &lt; j &lt; n, lj E� X.
Definition 1 (Answer set –part one)
</equation>
<bodyText confidence="0.999615666666667">
A state X of u(11) is an answer set for 11 if X is minimal
(in the sense of set-theoretic inclusion) among the sets
closed under 11.
To extend this definition to arbitrary programs, take any
program 11, and consistent set X of ground literals. The
reduct, 11X, of 11 relative to X is the set of rules
</bodyText>
<equation confidence="0.987561">
l0 — l1,...,l,,,
</equation>
<bodyText confidence="0.954581666666667">
for all rules (4.1) in 11 such that l,,,+1, ... , lam, E� X. Thus
11X is a program without default negation.
Definition 2 (Answer set –part two)
X is an answer set for 11 if X is an answer set for 11X.
Definition 3 (Entailment)
A program 11 entails a literal l (11 �= l) if l belongs to all
answer sets of 11.
The 11’s answer to a query l is yes if 11 �= l, no if 11 �= l,
and unknown otherwise.
</bodyText>
<sectionHeader confidence="0.999351" genericHeader="conclusions">
5 Summary
</sectionHeader>
<bodyText confidence="0.9995036">
In conclusion, we feel that the features of AnsProlog are
well suited to form the foundations for an inference en-
gine supporting a QAS. Our future work will develop the
support tools and implementation needed to demonstrate
this hypothesis.
</bodyText>
<sectionHeader confidence="0.996377" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999818115384616">
C. Baker, C. Fillmore, and J. Lowe. The Berkeley
FrameNet project. In Proceedings of the COLING-
ACL, Montreal, Canada, 1998.
C. Baral. Knowledge representation, reasoning and
declarative problem solving. Cambridge University
Press, 2003.
C. Baral and M. Gelfond. Reasoning agents in dynamic
domains. In J Minker, editor, Logic Based AI. pp. 257–
279, Kluwer, 2000.
P. Blackburn and J. Bos. Computational Semantics.
Theoria, 18(1), pages 365–387, 2003.
N. Chang, S. Narayanan, R. Miriam, and L. Petruck.
From frames to inference. In Proceedings of the First
International Workshop on Scalable Natural Language
Understanding, Heidelberg, Germany, 2002.
C. Fellbaum (ed). WordNet: An Electronic Lexical
Database. MIT Press, 1998.
M. Gelfond and V. Lifschitz. The stable model semantics
for logic programming. In R. Kowalski and K. Bowen,
editors, Logic Programming: Proc. of the Fifth Int’l
Conf. and Symp., pages 1070–1080. MIT Press, 1988.
M. Gelfond and V. Lifschitz. Classical negation in logic
programs and disjunctive databases. New Generation
Computing, pages 365–387, 1991.
D. Gildea and D. Jurafsky. Automatic Labeling of Se-
mantic Roles. In Proceedings of ACL 2000, Hong
Kong, China, 2000.
Lierler Yu., and Maratea M. Cmodels-2: SAT-based An-
swer Sets Solver Enhanced to Non-tight Programs, In
Proc. ofLPNMR-7, pp. 346, 2004.
J. McCarthy and P. Hayes. Some philosophical prob-
lems from the standpoint of artificial intelligence. In
B. Meltzer and D. Michie, editors, Machine Intelli-
gence, volume 4, pages 463–502. Edinburgh Univer-
sity Press, Edinburgh, 1969.
T. Eiter, N. Leone, C. Mateis., G. Pfeifer and F. Scar-
cello. A deductive system for nonmonotonic rea-
soning, Proceedings of the 4rd Logic Programming
and Non-Monotonic Reasoning Conference – LPNMR
’97, LNAI 1265, Springer-Verlag, Dagstuhl, Germa-
nia, Luglio 1997, pp. 363–374.
I. Niemela and P. Simons. Smodels – an implementa-
tion of the stable model and well-founded semantics
for normal logic programs. In Proc. 4th international
conference on Logic programming and non-monotonic
reasoning, pages 420–429, 1997.
R. Reiter. On closed world data bases. In H. Gallaire
and J. Minker, editors, Logic and Data Bases, pages
119–140. Plenum Press, New York, 1978.
H. Turner. Representing actions in logic programs and
default theories. Journal ofLogic Programming, 31(1-
3):245–298, May 1997.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.172160">
<title confidence="0.999543">Using answer set programming to answer complex queries</title>
<author confidence="0.915175">Chitta</author>
<affiliation confidence="0.983519">Dept. of Computer Sc. &amp; Arizona State</affiliation>
<address confidence="0.842852">Tempe, AZ</address>
<email confidence="0.999097">chitta@asu.edu</email>
<author confidence="0.96316">Michael</author>
<affiliation confidence="0.930622333333333">Dept. of Computer Texas Tech Lubbock, TX</affiliation>
<email confidence="0.998679">mgelfond@cs.ttu.edu</email>
<author confidence="0.982781">Richard</author>
<affiliation confidence="0.999784">Computer Science</affiliation>
<address confidence="0.6157055">Monmouth West Long Branch, NJ</address>
<email confidence="0.999457">rscherl@monmouth.edu</email>
<abstract confidence="0.989768636363636">In this paper we discuss the applicability of the knowledge representation and reasoning language AnsProlog for the design and implementation of query answering systems. We consider a motivating example, and illustrate how AnsProlog can be used to represent defaults, causal relations, and other types of commonsense knowledge needed to properly answer non-trivial questions about the example’s domain.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>C Baker</author>
<author>C Fillmore</author>
<author>J Lowe</author>
</authors>
<title>The Berkeley FrameNet project.</title>
<date>1998</date>
<booktitle>In Proceedings of the COLINGACL,</booktitle>
<location>Montreal, Canada,</location>
<contexts>
<context position="14919" citStr="Baker et al., 1998" startWordPosition="2392" endWordPosition="2395">sentences into a semantic representation such as First Order Logic. See (Blackburn and Bos, 2003) for a recent survey of such techniques. The semantic representation makes use of symbols based upon the lexicon of English. The success of our endeavor requires that there be an axiomatization of the relationship between the symbols representing functions and predicate symbols in our various AnsProlog theories (e.g., M1 – M4) and the symbols (based upon the lexicon of English) used in the semantic representation of the English queries and the narrative texts. The online lexical database, FrameNet(Baker et al., 1998) provides such a connection, especially for events. This is done through the notion of frame semantics that underlies FrameNet. Frame semantics assumes that lexical items draw their meaning from conceptual structures or frames that provide an abstract or scematic description of particular types of events. The frames are structured into an inheritance hierarchy. Each frame includes a number offrame elements (FEs) or roles that make up the conceptual structure. For example, our “travelling” module M2 closely corresponds to the related FrameNet frames Travel, Move, and Ride Vehicle. The frames re</context>
</contexts>
<marker>Baker, Fillmore, Lowe, 1998</marker>
<rawString>C. Baker, C. Fillmore, and J. Lowe. The Berkeley FrameNet project. In Proceedings of the COLINGACL, Montreal, Canada, 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Baral</author>
</authors>
<title>Knowledge representation, reasoning and declarative problem solving.</title>
<date>2003</date>
<publisher>Cambridge University Press,</publisher>
<contexts>
<context position="2102" citStr="Baral, 2003" startWordPosition="323" endWordPosition="324">r we hypothesize that AnsProlog - a language of logic programs under the answer set semantics (Gelfond and Lifschitz, 1988; Gelfond and Lifschitz, 1991) - is a good candidate for the KR language of QAS. This is especially true if answering a query Q requires sophisticated kinds of reasoning including default, causal, and counterfactual reasoning, reasoning about narratives, etc. The list of attractive properties of AnsProlog include its simplicity and expressive power, ability to reason with incomplete information, existence of a well developed mathematical theory and programming methodology (Baral, 2003), and the availability of rather efficient reasoning systems such as SMODELS(Niemela and Simons, 1997) and others as well(Eiter et al., 1997; Yu and Maratea, 2004). AnsProlog allows its users to encode defaults, causal relations, inheritance hierarchies, and other types of knowledge not readily available in other KR languages. In addition it supports construction of elaboration tolerant knowledge bases, i.e., ability to accommodate new knowledge without doing large scale surgery. The main drawback of the language is the inability of its current inference engines to effectively deal with number</context>
</contexts>
<marker>Baral, 2003</marker>
<rawString>C. Baral. Knowledge representation, reasoning and declarative problem solving. Cambridge University Press, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Baral</author>
<author>M Gelfond</author>
</authors>
<title>Reasoning agents in dynamic domains. In</title>
<date>2000</date>
<booktitle>Logic Based AI.</booktitle>
<pages>257--279</pages>
<editor>J Minker, editor,</editor>
<publisher>Kluwer,</publisher>
<contexts>
<context position="6451" citStr="Baral and Gelfond, 2000" startWordPosition="1040" endWordPosition="1043">s of people and in various travelling events which change these locations. Construction of M2 is based on the theory of dynamic systems () which views the world as a transition diagram whose states are labelled by fluents (propositions whose values depend on time) and arcs are labelled by actions. For instance, states of the diagram, D, can contain locations of different people; a transition (σ0, {a1, a2}, σ1) E D iff σ1 is apossible state of the domain after the concurrent execution of actions a1 and a2 in σ0. There is a well developed methodology of representing dynamic domain in AnsProlog (Baral and Gelfond, 2000; Turner, 1997) which, in its simplified form, will be used in the construction of M2. The language of M2 will contain time-steps from [0, n], fluent loc(P, X, T) - “place P is a location of person X at step T”. Various types of travelling events - fly, drive, etc., will be recorded by the list: instance_of(fly,travel). instance_of(drive,travel). ... Description of an event type will contain the event’s name and attributes. The following is a generic description of John flying to Baghdad. event(a1). type(a1,fly). actor(a1,john). destination(a1,baghdad). An actual event of this type will be rec</context>
</contexts>
<marker>Baral, Gelfond, 2000</marker>
<rawString>C. Baral and M. Gelfond. Reasoning agents in dynamic domains. In J Minker, editor, Logic Based AI. pp. 257– 279, Kluwer, 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Blackburn</author>
<author>J Bos</author>
</authors>
<title>Computational Semantics.</title>
<date>2003</date>
<journal>Theoria,</journal>
<volume>18</volume>
<issue>1</issue>
<pages>365--387</pages>
<contexts>
<context position="14397" citStr="Blackburn and Bos, 2003" startWordPosition="2308" endWordPosition="2311">cluding ours), the computation can be made substantially more efficient by properly combining answer set finding algorithms with the traditional resolution of Prolog. The way of doing this will be illustrated in the full paper. We also plan to expand our modules especially those dealing with time and reasoning about plans. 3 FrameNet and Events Our vision of the NLPM is that it will translate both our short text and also the queries into AnsProlog sentences. There is a body of literature on translating or parsing English sentences into a semantic representation such as First Order Logic. See (Blackburn and Bos, 2003) for a recent survey of such techniques. The semantic representation makes use of symbols based upon the lexicon of English. The success of our endeavor requires that there be an axiomatization of the relationship between the symbols representing functions and predicate symbols in our various AnsProlog theories (e.g., M1 – M4) and the symbols (based upon the lexicon of English) used in the semantic representation of the English queries and the narrative texts. The online lexical database, FrameNet(Baker et al., 1998) provides such a connection, especially for events. This is done through the n</context>
</contexts>
<marker>Blackburn, Bos, 2003</marker>
<rawString>P. Blackburn and J. Bos. Computational Semantics. Theoria, 18(1), pages 365–387, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>N Chang</author>
<author>S Narayanan</author>
<author>R Miriam</author>
<author>L Petruck</author>
</authors>
<title>From frames to inference.</title>
<date>2002</date>
<booktitle>In Proceedings of the First International Workshop on Scalable Natural Language Understanding,</booktitle>
<location>Heidelberg, Germany,</location>
<contexts>
<context position="16608" citStr="Chang et al., 2002" startWordPosition="2675" endWordPosition="2678">Net does not have entries for the verb spend as in spent Dec 10. But WordNet(Fellbaum, 1998) has 3 senses for the verb spend. Sense 1 is “pass – (pass (time) in a specific way. ‘How are you spending your summer vacation?’). ” Unfortunately, neither pass nor time allows us to index a useful frame for just being in a place. The coverage of FrameNet is not sufficient. It will be necessary to augment our use of FrameNet with other online sources such as WordNet and to also increase the number of frames within FrameNet. There has been some related work on using the frame of FrameNet for reasoning (Chang et al., 2002) and also on the automatic annotation of English texts with regard to the relevant frames (Gildea and Jurafsky, 2000) and frame elements. 4 Syntax and Semantics of AnsProlog An AnsProlog knowledge base consists of rules of the form: l0 — l1,... , l,,,, not l,,,+1, ... , not lam, (4.1) where each of the lis is a literal, i.e. an atom, a, or its classical negation, -a and not is a logical connective called negation as failure or default negation. While -a states that a is false, an expression not l says that there is no reason to believe in l. The answer set semantics of a logic program 11 assig</context>
</contexts>
<marker>Chang, Narayanan, Miriam, Petruck, 2002</marker>
<rawString>N. Chang, S. Narayanan, R. Miriam, and L. Petruck. From frames to inference. In Proceedings of the First International Workshop on Scalable Natural Language Understanding, Heidelberg, Germany, 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Fellbaum</author>
</authors>
<title>WordNet: An Electronic Lexical Database.</title>
<date>1998</date>
<publisher>MIT Press,</publisher>
<contexts>
<context position="16081" citStr="Fellbaum, 1998" startWordPosition="2581" endWordPosition="2582"> frames Travel, Move, and Ride Vehicle. The frames relate the various frame elements of Area (where the travelling takes place), Goal (where the travellers end up), Path (route of the travel), Source (starting point of the trip), and the Traveller (the living being which travels). Consider the phrase took a plane used to express the travelling activity. The verb take is associated with the frame Ride Vehicle. This information allows the connection with the axiomatization of flying events in M2. On the other hand FrameNet does not have entries for the verb spend as in spent Dec 10. But WordNet(Fellbaum, 1998) has 3 senses for the verb spend. Sense 1 is “pass – (pass (time) in a specific way. ‘How are you spending your summer vacation?’). ” Unfortunately, neither pass nor time allows us to index a useful frame for just being in a place. The coverage of FrameNet is not sufficient. It will be necessary to augment our use of FrameNet with other online sources such as WordNet and to also increase the number of frames within FrameNet. There has been some related work on using the frame of FrameNet for reasoning (Chang et al., 2002) and also on the automatic annotation of English texts with regard to the</context>
</contexts>
<marker>Fellbaum, 1998</marker>
<rawString>C. Fellbaum (ed). WordNet: An Electronic Lexical Database. MIT Press, 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Gelfond</author>
<author>V Lifschitz</author>
</authors>
<title>The stable model semantics for logic programming.</title>
<date>1988</date>
<booktitle>Logic Programming: Proc. of the Fifth Int’l Conf. and Symp.,</booktitle>
<pages>1070--1080</pages>
<editor>In R. Kowalski and K. Bowen, editors,</editor>
<publisher>MIT Press,</publisher>
<contexts>
<context position="1612" citStr="Gelfond and Lifschitz, 1988" startWordPosition="248" endWordPosition="251">module (NLPM), which translates this information (including the query) into a theory, F, of some knowledge representation language G; a general knowledge base, KB, containing common-senses and expert knowledge about various domains; and an inference engine which takes F and KB as an input and returns an answer to Q. Even though the choice of the KR language G is irrelevant for the first component of the system it plays an increasingly important role in the design of its other components. In this paper we hypothesize that AnsProlog - a language of logic programs under the answer set semantics (Gelfond and Lifschitz, 1988; Gelfond and Lifschitz, 1991) - is a good candidate for the KR language of QAS. This is especially true if answering a query Q requires sophisticated kinds of reasoning including default, causal, and counterfactual reasoning, reasoning about narratives, etc. The list of attractive properties of AnsProlog include its simplicity and expressive power, ability to reason with incomplete information, existence of a well developed mathematical theory and programming methodology (Baral, 2003), and the availability of rather efficient reasoning systems such as SMODELS(Niemela and Simons, 1997) and oth</context>
</contexts>
<marker>Gelfond, Lifschitz, 1988</marker>
<rawString>M. Gelfond and V. Lifschitz. The stable model semantics for logic programming. In R. Kowalski and K. Bowen, editors, Logic Programming: Proc. of the Fifth Int’l Conf. and Symp., pages 1070–1080. MIT Press, 1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Gelfond</author>
<author>V Lifschitz</author>
</authors>
<title>Classical negation in logic programs and disjunctive databases.</title>
<date>1991</date>
<journal>New Generation Computing,</journal>
<pages>365--387</pages>
<contexts>
<context position="1642" citStr="Gelfond and Lifschitz, 1991" startWordPosition="252" endWordPosition="255">es this information (including the query) into a theory, F, of some knowledge representation language G; a general knowledge base, KB, containing common-senses and expert knowledge about various domains; and an inference engine which takes F and KB as an input and returns an answer to Q. Even though the choice of the KR language G is irrelevant for the first component of the system it plays an increasingly important role in the design of its other components. In this paper we hypothesize that AnsProlog - a language of logic programs under the answer set semantics (Gelfond and Lifschitz, 1988; Gelfond and Lifschitz, 1991) - is a good candidate for the KR language of QAS. This is especially true if answering a query Q requires sophisticated kinds of reasoning including default, causal, and counterfactual reasoning, reasoning about narratives, etc. The list of attractive properties of AnsProlog include its simplicity and expressive power, ability to reason with incomplete information, existence of a well developed mathematical theory and programming methodology (Baral, 2003), and the availability of rather efficient reasoning systems such as SMODELS(Niemela and Simons, 1997) and others as well(Eiter et al., 1997</context>
</contexts>
<marker>Gelfond, Lifschitz, 1991</marker>
<rawString>M. Gelfond and V. Lifschitz. Classical negation in logic programs and disjunctive databases. New Generation Computing, pages 365–387, 1991.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Gildea</author>
<author>D Jurafsky</author>
</authors>
<title>Automatic Labeling of Semantic Roles.</title>
<date>2000</date>
<booktitle>In Proceedings of ACL 2000,</booktitle>
<location>Hong Kong, China,</location>
<contexts>
<context position="16725" citStr="Gildea and Jurafsky, 2000" startWordPosition="2694" endWordPosition="2697">the verb spend. Sense 1 is “pass – (pass (time) in a specific way. ‘How are you spending your summer vacation?’). ” Unfortunately, neither pass nor time allows us to index a useful frame for just being in a place. The coverage of FrameNet is not sufficient. It will be necessary to augment our use of FrameNet with other online sources such as WordNet and to also increase the number of frames within FrameNet. There has been some related work on using the frame of FrameNet for reasoning (Chang et al., 2002) and also on the automatic annotation of English texts with regard to the relevant frames (Gildea and Jurafsky, 2000) and frame elements. 4 Syntax and Semantics of AnsProlog An AnsProlog knowledge base consists of rules of the form: l0 — l1,... , l,,,, not l,,,+1, ... , not lam, (4.1) where each of the lis is a literal, i.e. an atom, a, or its classical negation, -a and not is a logical connective called negation as failure or default negation. While -a states that a is false, an expression not l says that there is no reason to believe in l. The answer set semantics of a logic program 11 assigns to 11 a collection of answer sets – consistent sets of ground literals corresponding to beliefs which can be built</context>
</contexts>
<marker>Gildea, Jurafsky, 2000</marker>
<rawString>D. Gildea and D. Jurafsky. Automatic Labeling of Semantic Roles. In Proceedings of ACL 2000, Hong Kong, China, 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lierler Yu</author>
<author>M Maratea</author>
</authors>
<title>Cmodels-2: SAT-based Answer Sets Solver Enhanced to Non-tight Programs,</title>
<date>2004</date>
<booktitle>In Proc. ofLPNMR-7,</booktitle>
<pages>346</pages>
<contexts>
<context position="2265" citStr="Yu and Maratea, 2004" startWordPosition="347" endWordPosition="350"> is a good candidate for the KR language of QAS. This is especially true if answering a query Q requires sophisticated kinds of reasoning including default, causal, and counterfactual reasoning, reasoning about narratives, etc. The list of attractive properties of AnsProlog include its simplicity and expressive power, ability to reason with incomplete information, existence of a well developed mathematical theory and programming methodology (Baral, 2003), and the availability of rather efficient reasoning systems such as SMODELS(Niemela and Simons, 1997) and others as well(Eiter et al., 1997; Yu and Maratea, 2004). AnsProlog allows its users to encode defaults, causal relations, inheritance hierarchies, and other types of knowledge not readily available in other KR languages. In addition it supports construction of elaboration tolerant knowledge bases, i.e., ability to accommodate new knowledge without doing large scale surgery. The main drawback of the language is the inability of its current inference engines to effectively deal with numbers and numerical computations1. In this paper we illustrate the use of AnsProlog for query answering via a simple example. Of course substantially more work is need</context>
</contexts>
<marker>Yu, Maratea, 2004</marker>
<rawString>Lierler Yu., and Maratea M. Cmodels-2: SAT-based Answer Sets Solver Enhanced to Non-tight Programs, In Proc. ofLPNMR-7, pp. 346, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J McCarthy</author>
<author>P Hayes</author>
</authors>
<title>Some philosophical problems from the standpoint of artificial intelligence.</title>
<date>1969</date>
<journal>Machine Intelligence,</journal>
<volume>4</volume>
<pages>463--502</pages>
<editor>In B. Meltzer and D. Michie, editors,</editor>
<publisher>Edinburgh University Press,</publisher>
<location>Edinburgh,</location>
<contexts>
<context position="8884" citStr="McCarthy and Hayes, 1969" startWordPosition="1440" endWordPosition="1443">states that the interference is an unusual event which normally does not happen. •. The third group consists of executability conditions for actions, which have the form -occurs(E,T) :- cond(T). which says that it is impossible for an event E occur at time step T if at that time step the domain is in a state satisfying condition cond. Causal laws and state constraints determine changes caused by execution of an action. To complete the definition of the transition diagram of the domain we need to specify what fluents do not change as the results of actions. This is a famous Frame Problem from (McCarthy and Hayes, 1969) where the authors suggested to solve it by formalizing the Inertia Axiom which says that “things tend to stay as they are”. This is a typical default which can be easily represented in AnsProlog. In our particular case it will have a form: loc(P,X,T+1) :- loc(P,X,T), not -loc(P,X,T+1). -loc(P,X,T+1) :- -loc(P,X,T), not loc(P,X,T+1). The above representation is a slightly simplified version of AnsProlog theory of dynamic domains which gives notation for causal relations of the domain, includes general (fluent independent) formulation of the inertia, explains how the set of causal relations def</context>
</contexts>
<marker>McCarthy, Hayes, 1969</marker>
<rawString>J. McCarthy and P. Hayes. Some philosophical problems from the standpoint of artificial intelligence. In B. Meltzer and D. Michie, editors, Machine Intelligence, volume 4, pages 463–502. Edinburgh University Press, Edinburgh, 1969.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Eiter</author>
<author>N Leone</author>
<author>C Mateis</author>
<author>G Pfeifer</author>
<author>F Scarcello</author>
</authors>
<title>A deductive system for nonmonotonic reasoning,</title>
<date>1997</date>
<booktitle>Proceedings of the 4rd Logic Programming and Non-Monotonic Reasoning Conference – LPNMR ’97, LNAI 1265, Springer-Verlag,</booktitle>
<pages>363--374</pages>
<location>Dagstuhl, Germania, Luglio</location>
<contexts>
<context position="2242" citStr="Eiter et al., 1997" startWordPosition="343" endWordPosition="346">d Lifschitz, 1991) - is a good candidate for the KR language of QAS. This is especially true if answering a query Q requires sophisticated kinds of reasoning including default, causal, and counterfactual reasoning, reasoning about narratives, etc. The list of attractive properties of AnsProlog include its simplicity and expressive power, ability to reason with incomplete information, existence of a well developed mathematical theory and programming methodology (Baral, 2003), and the availability of rather efficient reasoning systems such as SMODELS(Niemela and Simons, 1997) and others as well(Eiter et al., 1997; Yu and Maratea, 2004). AnsProlog allows its users to encode defaults, causal relations, inheritance hierarchies, and other types of knowledge not readily available in other KR languages. In addition it supports construction of elaboration tolerant knowledge bases, i.e., ability to accommodate new knowledge without doing large scale surgery. The main drawback of the language is the inability of its current inference engines to effectively deal with numbers and numerical computations1. In this paper we illustrate the use of AnsProlog for query answering via a simple example. Of course substant</context>
</contexts>
<marker>Eiter, Leone, Mateis, Pfeifer, Scarcello, 1997</marker>
<rawString>T. Eiter, N. Leone, C. Mateis., G. Pfeifer and F. Scarcello. A deductive system for nonmonotonic reasoning, Proceedings of the 4rd Logic Programming and Non-Monotonic Reasoning Conference – LPNMR ’97, LNAI 1265, Springer-Verlag, Dagstuhl, Germania, Luglio 1997, pp. 363–374.</rawString>
</citation>
<citation valid="true">
<authors>
<author>I Niemela</author>
<author>P Simons</author>
</authors>
<title>Smodels – an implementation of the stable model and well-founded semantics for normal logic programs.</title>
<date>1997</date>
<booktitle>In Proc. 4th international conference on Logic programming and non-monotonic reasoning,</booktitle>
<pages>420--429</pages>
<contexts>
<context position="2204" citStr="Niemela and Simons, 1997" startWordPosition="335" endWordPosition="339">tics (Gelfond and Lifschitz, 1988; Gelfond and Lifschitz, 1991) - is a good candidate for the KR language of QAS. This is especially true if answering a query Q requires sophisticated kinds of reasoning including default, causal, and counterfactual reasoning, reasoning about narratives, etc. The list of attractive properties of AnsProlog include its simplicity and expressive power, ability to reason with incomplete information, existence of a well developed mathematical theory and programming methodology (Baral, 2003), and the availability of rather efficient reasoning systems such as SMODELS(Niemela and Simons, 1997) and others as well(Eiter et al., 1997; Yu and Maratea, 2004). AnsProlog allows its users to encode defaults, causal relations, inheritance hierarchies, and other types of knowledge not readily available in other KR languages. In addition it supports construction of elaboration tolerant knowledge bases, i.e., ability to accommodate new knowledge without doing large scale surgery. The main drawback of the language is the inability of its current inference engines to effectively deal with numbers and numerical computations1. In this paper we illustrate the use of AnsProlog for query answering vi</context>
</contexts>
<marker>Niemela, Simons, 1997</marker>
<rawString>I. Niemela and P. Simons. Smodels – an implementation of the stable model and well-founded semantics for normal logic programs. In Proc. 4th international conference on Logic programming and non-monotonic reasoning, pages 420–429, 1997.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Reiter</author>
</authors>
<title>On closed world data bases.</title>
<date>1978</date>
<booktitle>Logic and Data Bases,</booktitle>
<pages>119--140</pages>
<editor>In H. Gallaire and J. Minker, editors,</editor>
<publisher>Plenum Press,</publisher>
<location>New York,</location>
<contexts>
<context position="4961" citStr="Reiter, 1978" startWordPosition="792" endWordPosition="793">st is(baghdad,city). is(iraq,country). ... of places and the definition of relation in(P1, P2) - “P1 is located in P2” The definition is given by a collection of facts: in(baghdad, iraq). in(iraq,middle_east). in(paris,france). in(france,western_europe). in(western_europe,europe). ... and the rule in(P1,P3) :- in(P1,P2), in(P2,P3). For simplicity we assume that our information about relation in is complete, i.e., if in(p1, p2) is not known to be true then it is false. This statement can be expressed by the rule -in(P1,P2) :- not in(P1,P2) often referred to as the CWA- Closed World Assumption (Reiter, 1978) (for in). Here −p stands for “p is false” while not p says that “there is no reason to belief p”. Similar assumption can be written for is. The program has unique answer set containing in(iraq, middle east), -in(iraq, europe), etc. This answer set, (or its relevant parts) can be computed by answer set solvers. Sometimes this will require small additions to the program. For instance SMODELS, which require typing of variables, will not be able to compile this program. This problem can be remedied by adding a rule position(P) :- is(P,C). defining the type position and a statement #domain positio</context>
</contexts>
<marker>Reiter, 1978</marker>
<rawString>R. Reiter. On closed world data bases. In H. Gallaire and J. Minker, editors, Logic and Data Bases, pages 119–140. Plenum Press, New York, 1978.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Turner</author>
</authors>
<title>Representing actions in logic programs and default theories.</title>
<date>1997</date>
<booktitle>Journal ofLogic Programming,</booktitle>
<pages>31--1</pages>
<contexts>
<context position="6466" citStr="Turner, 1997" startWordPosition="1044" endWordPosition="1045">s travelling events which change these locations. Construction of M2 is based on the theory of dynamic systems () which views the world as a transition diagram whose states are labelled by fluents (propositions whose values depend on time) and arcs are labelled by actions. For instance, states of the diagram, D, can contain locations of different people; a transition (σ0, {a1, a2}, σ1) E D iff σ1 is apossible state of the domain after the concurrent execution of actions a1 and a2 in σ0. There is a well developed methodology of representing dynamic domain in AnsProlog (Baral and Gelfond, 2000; Turner, 1997) which, in its simplified form, will be used in the construction of M2. The language of M2 will contain time-steps from [0, n], fluent loc(P, X, T) - “place P is a location of person X at step T”. Various types of travelling events - fly, drive, etc., will be recorded by the list: instance_of(fly,travel). instance_of(drive,travel). ... Description of an event type will contain the event’s name and attributes. The following is a generic description of John flying to Baghdad. event(a1). type(a1,fly). actor(a1,john). destination(a1,baghdad). An actual event of this type will be recorded by a stat</context>
</contexts>
<marker>Turner, 1997</marker>
<rawString>H. Turner. Representing actions in logic programs and default theories. Journal ofLogic Programming, 31(1-3):245–298, May 1997.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>