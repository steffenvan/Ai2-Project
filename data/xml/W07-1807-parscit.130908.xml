<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.009407">
<title confidence="0.999321">
A Development Environment
for Building Grammar-Based Speech-Enabled Applications
</title>
<author confidence="0.994568">
Elisabeth Kron&apos;, Manny Rayner&apos; 2, Marianne Santaholma&apos;, Pierrette Bouillon&apos;
</author>
<affiliation confidence="0.868316">
2 Powerset, Inc.
</affiliation>
<address confidence="0.978106">
475 Brannan Street
San Francisco, CA 94107
</address>
<email confidence="0.995482">
manny@powerset.com
</email>
<note confidence="0.644335666666667">
&apos; University of Geneva, TIM/ISSCO
40 bvd du Pont-d’Arve
CH-1211 Geneva 4, Switzerland
</note>
<email confidence="0.98178">
elisabethkron@yahoo.co.uk
Marianne.Santaholma@eti.unige.ch
Pierrette.Bouillon@issco.unige.ch
</email>
<sectionHeader confidence="0.993569" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.998418923076923">
We present a development environment for
Regulus, a toolkit for building unification
grammar-based speech-enabled systems, fo-
cussing on new functionality added over the
last year. In particular, we will show an
initial version of a GUI-based top-level for
the development environment, a tool that
supports graphical debugging of unification
grammars by cutting and pasting of deriva-
tion trees, and various functionalities that
support systematic development of speech
translation and spoken dialogue applications
built using Regulus.
</bodyText>
<sectionHeader confidence="0.975057" genericHeader="method">
1 The Regulus platform
</sectionHeader>
<bodyText confidence="0.99995152">
The Regulus platform is a comprehensive toolkit
for developing grammar-based speech-enabled sys-
tems that can be run on the commercially avail-
able Nuance recognition environment. The plat-
form has been developed by an Open Source con-
sortium, the main partners of which have been
NASA Ames Research Center and Geneva Uni-
versity, and is freely available for download from
the SourceForge website1. Regulus has been used
to build several large systems, including Geneva
University’s MedSLT medical speech translator
(Bouillon et al., 2005) and NASA’s Clarissa proce-
dure browser (Rayner et al., 2005b)2.
Regulus is described at length in
(Rayner et al., 2006), the first half of which consists
of an extended tutorial introduction. The release
also includes extensive online documentation,
including several example applications.
The core functionality offered by Regulus is com-
pilation of typed unification grammars into parsers,
generators, and Nuance-formatted CFG language
models, and hence also into Nuance recognition
packages. Small unification grammars can be com-
piled directly into executable forms. The central
idea of Regulus, however, is to base as much of
the development work as possible on large, domain-
independent resource grammars. A resource gram-
mar for English is available from the Regulus web-
site; similar grammars for several other languages
have been developed under the MedSLT project at
Geneva University, and can be downloaded from the
MedSLT SourceForge website3.
Large resource grammars of this kind are over-
general as they stand, and it is not possible to com-
pile them directly into efficient recognisers or gener-
ators. The platform, however, provides tools, driven
by small corpora of examples, that can be used to
create specialised versions of these general gram-
mars using the Explanation Based Learning (EBL)
algorithm. We have shown in a series of exper-
iments that suitably specialised grammars can be
compiled into efficient executable forms. In particu-
lar, recognisers built in this way are very competitive
with ones created using statistical training methods
(Rayner et al., 2005a).
The Regulus platform also supplies a framework
for using the compiled resources — parsers, gen-
erators and recognisers — to build speech transla-
tion and spoken dialogue applications. The envi-
ronment currently supports 75 different commands,
</bodyText>
<footnote confidence="0.999844">
1http://sourceforge.net/projects/regulus/
2http://ic.arc.nasa.gov/projects/clarissa/ 3http://sourceforge.net/projects/medslt
</footnote>
<page confidence="0.990818">
49
</page>
<affiliation confidence="0.28571">
Proceedings of SPEECHGRAM 2007, pages 49–52,
Prague, Czech Republic, June 2007. c�2007 Association for Computational Linguistics
</affiliation>
<bodyText confidence="0.99985694117647">
which can be used to carry out a range of func-
tions including compilation of grammars into var-
ious forms, debugging of grammars and compiled
resources, and testing of applications. The environ-
ment exists in two forms. The simpler one, which
has been available from the start of the project, is a
command-line interface embedded within the SICS-
tus Prolog top-level. The focus will however be on
a new GUI-based environment, which has been un-
der development since late 2006, and which offers
a more user-friendly graphical/menu-based view of
the underlying functionality.
In the rest of the paper, we outline how Regulus
supports development both at the level of grammars
(Section 2), and at the level of the applications that
can be built using the executable forms derived from
them (Section 3).
</bodyText>
<sectionHeader confidence="0.852714" genericHeader="method">
2 Developing unification grammars
</sectionHeader>
<bodyText confidence="0.999972407894737">
The Regulus grammar development toolset borrows
ideas from several other systems, in particular the
SRI Core Language Engine (CLE) and the Xerox
Language Engine (XLE). The basic functionalities
required are uncontroversial. As usual, the Regulus
environment lets the user parse example sentences
to create derivation trees and logical forms; in the
other direction, if the grammar has also been com-
piled into a generator, the user can take a logical
form and use it to generate a surface string and an-
other derivation tree. Once a derivation tree has been
created, either through parsing or through genera-
tion, it is possible to examine individual nodes to
view the information associated with each one. Cur-
rently, this information consists of the syntactic fea-
tures, the piece of logical form built up at the node,
and the grammar rule or lexical entry used to create
it.
The Regulus environment also provides a more
elaborate debugging tool, which extends the ear-
lier “grammar stepper” implemented under the CLE
project. Typically, a grammar development problem
has the following form. The user finds a bad sen-
tence B which fails to get a correct parse; however,
there are several apparently similar or related sen-
tences G1...Gn which do get correct parses. In most
cases, the explanation is that some rule which would
appear in the intended parse for B has an incorrect
feature-assignment.
A simple strategy for investigating problems of
this kind is just to examine the structures of B and
G1...Gn by eye, and attempt to determine what the
crucial difference is. An experienced developer,
who is closely familiar with the structure of the
grammar, will quite often be able to solve the prob-
lem in this way, at least in simple cases. “Solving
by inspection” is not, however, very systematic, and
with complex rule bugs it can be hard even for ex-
perts to find the offending feature assignment. The
larger the grammar becomes, especially in terms of
the average number of features per category, the
more challenging the ad hoc debugging approach
becomes.
A more systematic strategy was pioneered in the
CLE grammar stepper. The developer begins by
looking at the working examples G1...Gn, to de-
termine what the intended correct structure would
be for B. They then build up the corresponding
structure for the bad example, starting at the bot-
tom with the lexical items and manually selecting
the rules used to combine them. At some point, a
unification will fail, and this will normally reveal the
bad feature assignment. The problem is that manual
bottom-up construction of the derivation tree is very
time-consuming, since even quite simple trees will
usually have at least a dozen nodes.
The improved strategy used in the Regulus gram-
mar stepper relies on the fact that the G1...Gn can
usually be constructed to include all the individual
pieces of the intended derivation tree for B, since in
most cases the feature mis-match arises when com-
bining two subtrees which are each internally con-
sistent. We exploit this fact by allowing the devel-
oper to build up the tree for B by cutting up the trees
for G1...Gn into smaller pieces, and then attempting
to recombine them. Most often, it is enough to take
two of the Gi, cut an appropriate subtree out of each
one, and try to unify them together; this means that
the developer can construct the tree for B with only
five operations (two parses, two cuts, and a join),
rather than requiring one operation for each node in
B, as in the bottom-up approach.
A common pattern is that B and G1 are identical,
except for one noun-phrase constituent NP, and G2
consists of NP on its own. To take an example from
the MedSLT domain, B could be “does the morning
</bodyText>
<page confidence="0.996974">
50
</page>
<figureCaption confidence="0.997713">
Figure 1: Example of using the grammar stepper to discover a feature mismatch. The window on the
</figureCaption>
<bodyText confidence="0.933643363636364">
right headed “Stepper” presents the list of available trees, together with the controls. The windows headed
“Tree 1” and “Tree 4” present the trees for item 1 (“does red wine give you headaches”) and item 4 (“the
morning”). The popup window on the lower right presents the feature mismatch information.
give you headaches?”, G1 the similar sentence “does
red wine give you headaches?” and G2 the single
NP “the morning”. We cut out the first NP subtree
from G1 to produce what is in effect a tree with an
NP “slash category”, that can be rendered as “does
NP give you headaches?”; call this G′1. We then cut
out the single NP subtree (this accounts for most,
but not all, of the derivation) from G2, to produce
G′2. By attempting to unify G′2 with the NP “hole”
left in G′1, we can determine the exact nature of the
feature mismatch. We discover that the problem is
in the sortal features: the value of the sortal feature
on G′2 is time, but the corresponding feature-value
in the NP “hole” is action\/cause.
Figure 1 contains a screenshot of the development
environment in the example above, showing the state
when the feature mismatch is revealed. A detailed
example, including screenshots for each step, is in-
cluded in the online Regulus GUI tutorial4.
</bodyText>
<footnote confidence="0.9879755">
4Available in the file doc/RegulusGUITutorial.pdf from the
SourceForge Regulus website
</footnote>
<sectionHeader confidence="0.927114" genericHeader="method">
3 Developing applications
</sectionHeader>
<bodyText confidence="0.9997148">
The Regulus platform contains support for both
speech translation and spoken dialogue applications.
In each case, it is possible to run the development
top-loop in a mode appropriate to the type of appli-
cation, including carrying out systematic regression
testing using both text and speech input. For both
types of application, the platform assumes a uniform
architecture with pre-specified levels of representa-
tion.
Due to shortage of space, and because it is the
better-developed of the two, we focus on speech
translation. The framework is interlingua-based,
and also permits simple context-based translation
involving resolution of ellipsis5. Processing goes
through the following sequence of representations:
</bodyText>
<listItem confidence="0.786409">
1. Spoken utterance in source language.
2. Recognised words in source language.
</listItem>
<footnote confidence="0.99716">
5Although it is often possible to translate ellipsis as ellipsis
in closely related language pairs, this is usually not correct in
more widely separated ones.
</footnote>
<page confidence="0.997243">
51
</page>
<listItem confidence="0.969968764705882">
3. Source logical form. Source logical form and
all other levels of representation are (almost)
flat lists of attribute/value pairs.
4. “Source discourse representation”. A regu-
larised version of the source logical form, suit-
able for carrying out ellipsis resolution.
5. “Resolved source discourse representation”.
The output resulting from carrying out any nec-
essary ellipsis processing on the source dis-
course representation. Typically this will add
material from the preceding context represen-
tation to create a representation of a complete
clause.
6. Interlingua. A language-independent version
of the representation.
7. Target logical form.
8. Surface words in target language.
</listItem>
<bodyText confidence="0.99996455">
The transformations from source logical form
to source discourse representation, from resolved
source discourse representation to interlingua, and
from interlinga to target logical form are defined
using translation rules which map lists of at-
tribute/value pairs to lists of attribute/value pairs.
The translation trace includes all the levels of rep-
resentation listed above, the translation rules used at
each stage, and other information omitted here. The
“translation mode” window provided by the devel-
opment environment makes all these fields available
in a structured form which allows the user to select
for display only those that are currently of interest.
The framework for spoken dialogue systems is simi-
lar, except that in the last three steps “Interlingua” is
replaced by “Dialogue move”, “Target logical form”
by “Abstract response”, and “Surface words in target
language” by “Concrete response”.
The platform contains tools for performing sys-
tematic regression testing of both speech translation
and spoken dialogue applications, using both text
and speech input. Input in the required modality is
taken from a specified file and passed through all
stages of processing, with the output being written
to another file. The user is able to annotate the re-
sults with respect to correctness (the GUI presents
a simple menu-based interface for doing this) and
save the judgements permanently, so that they can
be reused for future runs.
The most interesting aspects of the framework
involve development of spoken dialogue systems.
With many other spoken dialogue systems, the ef-
fect of a dialogue move is distributed throughout the
program state, and true regression testing is very dif-
ficult. Here, our side-effect free approach to dia-
logue management means that the DM can be tested
straightforwardly as an isolated component, since
the context is fully encapsulated as an object. The
theoretical issues involved are explored further in
(Rayner and Hockey, 2004).
</bodyText>
<sectionHeader confidence="0.99941" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999637032258064">
[Bouillon et al.2005] P. Bouillon, M. Rayner,
N. Chatzichrisafis, B.A. Hockey, M. Santaholma,
M. Starlander, Y. Nakao, K. Kanzaki, and H. Isahara.
2005. A generic multi-lingual open source platform
for limited-domain medical speech translation. In
Proceedings of the 10th Conference of the European
Association for Machine Translation (EAMT), pages
50–58, Budapest, Hungary.
[Rayner and Hockey2004] M. Rayner and B.A. Hockey.
2004. Side effect free dialogue management in a voice
enabled procedure browser. In Proceedings of the 8th
International Conference on Spoken Language Pro-
cessing (ICSLP), Jeju Island, Korea.
[Rayner et al.2005a] M. Rayner, P. Bouillon,
N. Chatzichrisafis, B.A. Hockey, M. Santaholma,
M. Starlander, H. Isahara, K. Kanzaki, and Y. Nakao.
2005a. Methodology for comparing grammar-based
and robust approaches to speech understanding. In
Proceedings of the 9th International Conference
on Spoken Language Processing (ICSLP), pages
1103–1107, Lisboa, Portugal.
[Rayner et al.2005b] M. Rayner, B.A. Hockey, J.M. Ren-
ders, N. Chatzichrisafis, and K. Farrell. 2005b. A
voice enabled procedure browser for the international
space station. In Proceedings of the 43rd Annual
Meeting ofthe Association for Computational Linguis-
tics (interactive poster and demo track), Ann Arbor,
[Rayner et al.2006] M. Rayner, B.A. Hockey, and
P. Bouillon. 2006. Putting Linguistics into Speech
Recognition: The Regulus Grammar Compiler. CSLI
Press, Chicago.
</reference>
<page confidence="0.99884">
52
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.034573">
<title confidence="0.999625">A Development Environment for Building Grammar-Based Speech-Enabled Applications</title>
<author confidence="0.998717">Manny Marianne Pierrette</author>
<email confidence="0.438796">2Powerset,</email>
<address confidence="0.92732">475 Brannan San Francisco, CA</address>
<email confidence="0.995325">manny@powerset.com</email>
<affiliation confidence="0.889619">of Geneva,</affiliation>
<address confidence="0.760313">40 bvd du</address>
<affiliation confidence="0.537045">CH-1211 Geneva 4,</affiliation>
<email confidence="0.492916">Pierrette.Bouillon@issco.unige.ch</email>
<abstract confidence="0.989153821428571">We present a development environment for Regulus, a toolkit for building unification grammar-based speech-enabled systems, focussing on new functionality added over the last year. In particular, we will show an initial version of a GUI-based top-level for the development environment, a tool that supports graphical debugging of unification grammars by cutting and pasting of derivation trees, and various functionalities that support systematic development of speech translation and spoken dialogue applications built using Regulus. 1 The Regulus platform The Regulus platform is a comprehensive toolkit for developing grammar-based speech-enabled systems that can be run on the commercially available Nuance recognition environment. The platform has been developed by an Open Source consortium, the main partners of which have been NASA Ames Research Center and Geneva University, and is freely available for download from SourceForge Regulus has been used to build several large systems, including Geneva University’s MedSLT medical speech translator (Bouillon et al., 2005) and NASA’s Clarissa procebrowser (Rayner et al.,</abstract>
<note confidence="0.6000305">Regulus is described at length in (Rayner et al., 2006), the first half of which consists</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>P Bouillon</author>
<author>M Rayner</author>
<author>N Chatzichrisafis</author>
<author>B A Hockey</author>
<author>M Santaholma</author>
<author>M Starlander</author>
<author>Y Nakao</author>
<author>K Kanzaki</author>
<author>H Isahara</author>
</authors>
<title>A generic multi-lingual open source platform for limited-domain medical speech translation.</title>
<date>2005</date>
<booktitle>In Proceedings of the 10th Conference of the European Association for Machine Translation (EAMT),</booktitle>
<pages>50--58</pages>
<location>Budapest, Hungary.</location>
<marker>[Bouillon et al.2005]</marker>
<rawString>P. Bouillon, M. Rayner, N. Chatzichrisafis, B.A. Hockey, M. Santaholma, M. Starlander, Y. Nakao, K. Kanzaki, and H. Isahara. 2005. A generic multi-lingual open source platform for limited-domain medical speech translation. In Proceedings of the 10th Conference of the European Association for Machine Translation (EAMT), pages 50–58, Budapest, Hungary.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Rayner</author>
<author>B A Hockey</author>
</authors>
<title>Side effect free dialogue management in a voice enabled procedure browser.</title>
<date>2004</date>
<booktitle>In Proceedings of the 8th International Conference on Spoken Language Processing (ICSLP), Jeju Island,</booktitle>
<marker>[Rayner and Hockey2004]</marker>
<rawString>M. Rayner and B.A. Hockey. 2004. Side effect free dialogue management in a voice enabled procedure browser. In Proceedings of the 8th International Conference on Spoken Language Processing (ICSLP), Jeju Island, Korea.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Rayner</author>
<author>P Bouillon</author>
<author>N Chatzichrisafis</author>
<author>B A Hockey</author>
<author>M Santaholma</author>
<author>M Starlander</author>
<author>H Isahara</author>
<author>K Kanzaki</author>
<author>Y Nakao</author>
</authors>
<title>Methodology for comparing grammar-based and robust approaches to speech understanding.</title>
<date>2005</date>
<booktitle>In Proceedings of the 9th International Conference on Spoken Language Processing (ICSLP),</booktitle>
<pages>1103--1107</pages>
<location>Lisboa, Portugal.</location>
<marker>[Rayner et al.2005a]</marker>
<rawString>M. Rayner, P. Bouillon, N. Chatzichrisafis, B.A. Hockey, M. Santaholma, M. Starlander, H. Isahara, K. Kanzaki, and Y. Nakao. 2005a. Methodology for comparing grammar-based and robust approaches to speech understanding. In Proceedings of the 9th International Conference on Spoken Language Processing (ICSLP), pages 1103–1107, Lisboa, Portugal.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Rayner</author>
<author>B A Hockey</author>
<author>J M Renders</author>
<author>N Chatzichrisafis</author>
<author>K Farrell</author>
</authors>
<title>A voice enabled procedure browser for the international space station.</title>
<date>2005</date>
<booktitle>In Proceedings of the 43rd Annual Meeting ofthe Association for Computational Linguistics</booktitle>
<location>Ann Arbor,</location>
<marker>[Rayner et al.2005b]</marker>
<rawString>M. Rayner, B.A. Hockey, J.M. Renders, N. Chatzichrisafis, and K. Farrell. 2005b. A voice enabled procedure browser for the international space station. In Proceedings of the 43rd Annual Meeting ofthe Association for Computational Linguistics (interactive poster and demo track), Ann Arbor,</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Rayner</author>
<author>B A Hockey</author>
<author>P Bouillon</author>
</authors>
<title>Putting Linguistics into Speech Recognition: The Regulus Grammar Compiler.</title>
<date>2006</date>
<publisher>CSLI Press,</publisher>
<location>Chicago.</location>
<marker>[Rayner et al.2006]</marker>
<rawString>M. Rayner, B.A. Hockey, and P. Bouillon. 2006. Putting Linguistics into Speech Recognition: The Regulus Grammar Compiler. CSLI Press, Chicago.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>