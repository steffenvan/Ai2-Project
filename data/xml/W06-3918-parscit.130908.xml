<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.070901">
<title confidence="0.995576">
The ALLIGATOR Theorem Prover for
Dependent Type Systems: Description and
Proof Sample
</title>
<author confidence="0.999243">
Paul Piwek
</author>
<affiliation confidence="0.99789">
Centre for Research in Computing
The Open University, Milton Keynes, UK
</affiliation>
<email confidence="0.931976">
p.piwek@open.ac.uk
</email>
<sectionHeader confidence="0.984638" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9996098">
This paper introduces the ALLIGATOR theorem prover for Dependent Type Systems (DTs).
We start with highlighting a number of properties of DTs that make them specifically suited
for computational semantics. We then briefly introduce DTs and our implementation. The
paper concludes with an example of a DTs proof that illustrates the suitability of DTs for
modelling anaphora resolution.
</bodyText>
<sectionHeader confidence="0.998989" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.914157714285714">
Automated symbolic inference requires a formal language as the substratum for
reasoning. Blackburn and Bos ([7]) make a good case for the use of First Order
Predicate Logic (FOPL) in computational semantics, citing both practical (availabil-
ity of high performance theorem provers and to a lesser extent model builders) and
theoretical reasons (they discuss a range of interesting phenomena which can be
dealt with in FOPL).
We agree with the idea that FOPL is a good starting point, but also think that for
computational semantics to develop further as a field, extensions going beyond FOPL
should be actively explored. In this paper, a research tool is described that takes
such explorations in one particular direction. The tool – ALLIGATOR – is a theorem
prover for Dependent Type Systems (DTs) [4,5]. The Sicstus Prolog source code
of this prover is available, free of charge, for research purposes ([18]). DTs are an
attractive option for computational semantics for a number of reasons:
(i) DYNAMIC POTENTIAL (cf. [15]): The notion of a context that is built up incre-
mentally is inherent to DTs.
(ii) FLEXIBILITY: By varying a limited number of parameters, it is possible to
switch from, for example, propositional to predicate logic, or first order to
higher order logics. Additionally, although the basic underlying logic is con-
structive, DTs allows for the flexible use of axioms to regain full classical
logic, or more fine-grained alternatives. For example, it is possible to specify
for individual predicates whether they are bivalent.
</bodyText>
<listItem confidence="0.6201035">
(iii) EXTENsIBILITY: A DTs-context includes what is known as the signature in FOPL.
Consequently, the signature can be extended incrementally, making it possible
to model the acquisition of new concepts by language users.
(iv) PROOF-OBJECTs: In DTs, Gentzen-style natural deduction proofs are first-class
</listItem>
<bodyText confidence="0.98614403030303">
citizens. This gives us the following advantages: (a) Reliability: It allows us
to heed the de Bruijn criterion for reliable proof systems: “A proof assistant
satisfies the de Bruijn criterion if it generates ‘proof-objects’ (of some form)
that can be checked by an easy algorithm.” (cited from [5]) (b) Naturalness:
DTs proofs correspond with natural deduction proofs. This is of interest if one
is concerned with models of human reasoning in natural language understand-
ing. In psychology, some schools of thought argue that natural deduction is a
good approximation of human reasoning (see, e.g., [21]). (c) Relevance: Proof
objects can help to identify proofs which are valid but spurious in the sense
that they do not really consume their premises (see [14]). (d) Justification of
behaviour: Explicit proof objects provide direct access to the justifications
that an agent has for the conclusions and the interpretations that it constructs.
This is particularly useful for dialogue agents that need to respond to utter-
ances of other agents. Such responses can themselves again be queried, for
example, through clarificatory questions (cf. [22]) and why questions (A:p, B:
no, ¬p, A: Why ¬p?). In order to respond appropriately, the agent needs to ac-
cess its own background knowledge and how it was used to draw conclusions.
DTs proof objects provide a compact representation of this information.
(v) APPLICATIONs: DTs-style analyses exist for a wide range of linguistic phe-
nomena including donkey sentences ([23]), anaphoric expressions and tem-
poral reference ([20]), belief revision ([8]), bridging anaphora ([19]), clar-
ification ellipsis ([10]), metonymy ([9]), inter-agent communication, knowl-
edge and observation ([1]), ontological reasoning for feedback dialogues ([6]),
and human-machine dialogue ([2]). Additionally, there is research on relating
DTs proof-theoretic natural language semantics to model-theoretic approaches
([12]), and there are studies employing the related formalism of labelled de-
duction to natural language semantics ([16]). In 2005, the 2nd Workshop on
Lambda-Calculus, Type Theory, and Natural Language took place at King’s
College London ([11]).
We concede that none of the properties we have listed is on its own unique to DTs.
However, to the best of our knowledge, no extant logical calculus combines all
these properties in a single system with well-understood meta-mathematical prop-
erties (DTs play a central role in theoretical computer science, see [4]).
</bodyText>
<sectionHeader confidence="0.938658" genericHeader="method">
2 Dependent Type Systems
</sectionHeader>
<bodyText confidence="0.989665588235294">
DTs come in a wide variety of flavours and variations. All these systems share,
however, two features: a typing system and a notion of dependency. Firstly, DTs are
type systems. That is, given a set of assumptions P, also known as the context, they
provide rules for determining whether a particular object, say a, belongs to a given
type, say t. We write P F- a : t, if, given the context P, a is of type t, i.e., a inhabits
type t. The objects that are classified using type systems are (normalizing) terms
of the λ-calculus. P is a sequence of statements x1 : t1, ... , xn : tn (with n &gt; 0).
Dependency is the second feature of DTs, and it comes in two forms. First, there
is dependency between statements in the context: in order to use a type tk to classify
an object xk, this type tk needs to have been introduced in that part of the context
that precedes it or tk has to be a sort. In other words, tk can only be used if (1) it
itself inhabits a type or can be constructed from other types that are available in the
context preceding it, or (2) it belongs to a fixed and usually small set of designated
types that are called sorts. Because sorts need no preceding context, they make it
possible to keep contexts finite.
Second, there is a variety of dependency that occurs inside types. Since type
systems are used to classify terms of the λ-calculus, they can also deal with func-
tions. A function f from objects of type t1 to objects of type t2 inhabits the function
type t1 —* t2. Dependent function types are a generalization of function types: a
dependent function type is a function type where the range of the function changes
depending on the object to which the function is applied. The notation for depen-
dent function types is IIx : A.B (we also use our own alternative ‘arrow notation’:
[x : A] =* B). If we apply an inhabitant of this function type, say f, to an object of
type A, then the resulting object fa (f applied to a) is of type B, but with all free
occurrences of x in B substituted with a (that is, the type of fa is B[x := a]).
One way to make the leap from type systems to logic is as follows. From a log-
ical point of view, we are interested in propositions as the constituents of deductive
arguments. In classical logic, one focuses on judgements of the following form:
the truth of proposition q follows/can be derived from the truth of the propositions
p1, ... , pn. We reason from the truth of the premises to the truth of the conclu-
sion. To do logic in a DTs, we move from truth to proof: we, now, reason from the
proofs that we (assume to) have for the premises to a proof for the conclusion. In
other words, we are interested in judgements of the following form: a is proof of
proposition q follows/can be derived assuming that a1 is a proof of p1, a2 is a proof
of p2, ..., and an is a proof pn. Such a judgement can be formalized in a DTs as
a1 : p1, ... , an : pn F- a : p. Thus, we read a : p as ‘a is a proof for p’. Thus, we
model proofs as (λ-calculus) terms and propositions as (a certain class of) types in
DTs. This is known as the Curry-Howard-de Bruijn embedding.
The embedding is grounded in the Brouwer-Heyting-Kolmogorov interpreta-
tion of proofs as constructions; e.g., a proof for a conditional p —* q is identified
with a method that transforms a proof of p into a proof for q. In a DTs, this is for-
malized by modelling the proof f for a type p —* q as a function from objects of
type p to objects of type q, such that if a is a proof of p, then f applied to a is a
proof of q (i.e., fa : q). Universal quantification is dealt with along the same lines.
In a DTs, the counterpart for universal quantification is the dependent function type.
In particular, bx E A : P(x) becomes (IIx : A.Px). A proof for this type is a
function f which, given any object a : A, returns the proof fa for Pa.
PURE TYPE SYsTEMs (PTs; [4]) are of particular interest, because of their gen-
erality. With a small number of parameters, PTs can be tailored to match a wide
variety of DTs. ALLIGATOR implements an extension of PTs with Σ types. Σ types
are also known as dependent product types and can be used to model ∧ and ∃.
</bodyText>
<sectionHeader confidence="0.977829" genericHeader="method">
3 System Architecture, Implementation and Proof Sample
</sectionHeader>
<bodyText confidence="0.999827222222222">
There is no room for a detailed description of the system here, for that we refer to
the documentation and code available at [18]. What we can offer is, firstly, a list of
differences between ALLIGATOR and other DTs provers: (a) ALLIGATOR directly con-
structs proof objects for natural deduction proofs. Other provers for DTs typically
work with internal representations that are only at the end of the reasoning process
translated to natural deduction proof objects. For example, COCKTAIL ([13]) uses
tableaux and translates these, whereas TPs ([3]) is based on the mating method.
The handbook chapter by Barendregt and Geuvers on proof assistants for DTs ([5])
lists a number of further automated theorem provers, none of which works directly
with proof objects. (b) ALLIGATOR was not developed with mathematical/program
specification reasoning in mind, but rather for inferences in language interpretation.
As a consequence, it has been streamlined to link up with notation and function-
ality relevant to computational semantics (specifically, allowing for notation which
is close to [15] and omission of inductive types). (3) To the best of our knowl-
edge, ALLIGATOR is the only automated theorem prover which directly conforms to
the specification of Pure Type Systems ([4]), the most general and flexible kind of
DTs (most DTs can be emulated in PTs; see [17] for an overview of DTs and their
counterparts in PTs).
ALLIGATOR 1.0 has been implemented in Sicstus PROLOG and been tested with
version 3.12.2 of Sicstus. An overview of the architecture is presented in Figure
1.a. Note that the system applies both forward and backward inferencing. Most
of the forward inferencing takes place before backward inferencing (though some
backward inferencing rules do also have forward inferencing component). Reduc-
tion of terms is also carried out mainly before backward inferencing. Inferencing
is done with a flattened representations of DTs terms (the arrow notation). Proofs
are checked at the end of the inferencing process for their correctness (the code for
proof checking is separate from the theorem proving code).
Currently, ALLIGATOR has the status of an experimental research tool. It is in-
tended for testing computational solutions to theoretically challenging problems in
computational semantics. Scalability has, so far, not been given much attention,
though it will obviously need to be addressed if the system is to be used in large-
scale practical applications. Currently, the system is merely intended as a baseline
and starting point for implementing efficient and effective proof search heuristics.
We now conclude with an example of the use of ALLIGATOR.
The discourse ‘The barn contains a chain saw or a power drill. It ...’ (p. 205 of
[15]) poses a problem for the structural approach to anaphora resolution proposed in
</bodyText>
<figureCaption confidence="0.9831985">
Fig. 1. Overview of ALLIGATOR 1.0 Architecture (a) and graphical representation of a
proof-object (b)
</figureCaption>
<bodyText confidence="0.989239318181818">
[15]: the first sentence does not directly introduce an accessible discourse referent
that can bind the pronoun ‘It’. Rather, an object (something that is either a power
drill or a chain saw) needs to be inferred from a disjunction. An inferential account
of anaphora resolution that can deal with such cases is presented in [19]. In a
nutshell, the idea is that an anaphoric expression triggers a proof goal that needs to
be filled with a proof from the context.
ALLIGATOR can construct an antecedent for ‘It’ from the context (for lack of
space, our formalization is in propositional logic). Firstly, the relevant proposi-
tions need to be available: false:prop (false is a proposition), p:prop (there is a
chain saw is a proposition), q:prop (there is a power drill is a proposition), u:prop
(there is something is a proposition). Given these propositions, we can now in-
troduce background information such as a1:p→u (roughly, chain saws are things)
and a2:q→u (power drills are things). Although DTs are constructive, we can en-
gage in classical reasoning by including the double negation rule in our background
knowledge: dn pr:([P:prop]⇒(((P→false)→false)→P)). It involves higher or-
der quantification over all propositions P. Finally, assume that the context has
been updated with the information expressed by the sentence ‘The barn contains
a chain saw or a power drill’, with disjunction modelled using implication and
negation: a3:(p→false)→q. Given this information, ALLIGATOR can generate the
proof/antecedent for ‘It’ (modelled here as u) given in Figure 1.b.
Acknowledgements We would like to thank the anonymous reviewers of ICoS-5 for their
helpful comments and suggestions.
</bodyText>
<sectionHeader confidence="0.984932" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999966836734694">
[1] Ahn, R., “Agents, Objects and Events: A computational approach to knowledge, observation
and communication,” Ph.D. thesis, Eindhoven University of Technology (2001).
[2] Ahn, R., R. Beun, T. Borghuis, H. Bunt and C. van Overveld, The DenK-architecture: a
fundamental approach to user-interfaces, Artificial Intelligence Review Journal 8 (1994),
pp. 431–445.
[3] Andrews, P., M. Bishop, S. Issar, D. Nesmith, F. Pfennig and H. Xi, TPS: A Theorem-Proving
System for Classical Type Theory, Journal of Automated Reasoning 16 (1996), pp. 321–353.
[4] Barendregt, H., Lambda Calculi with Types, in: Handbook of Logic in Computer Science, 2,
Clarendon Press, Oxford, 1992 .
[5] Barendregt, H. and H. Geuvers, Proof-assistants using Dependent Type Systems, in: Handbook
ofAutomated Reasoning, Elsevier, 2001.
[6] Beun, R., R. van Eijk and H. Pr¨ust, Ontological Feedback in Multiagent Systems, in:
N. Jennings, C. Sierra, L. Sonenberg and M. Tambe, editors, International Joint Conference
on Autonomous Agents and Multiagent Systems (2004), pp. 110–117.
[7] Blackburn, P. and J. Bos, Computational Semantics, Theoria 18 (2003), pp. 27–45.
[8] Borghuis, T. and R. Nederpelt, Belief Revision with Explicit Justifications: An Exploration in
Type Theory, CS-Report 00-17, Eindhoven University of Technology (2000).
[9] Bunt, H. and L. Kievit, Agent-dependent metonymy in a context-change model of
communication, in: Computing Meaning II, Studies in Linguistics and Philosophy 77, Kluwer
Academic Publishers, Dordrecht, 2001 pp. 75–95.
[10] Cooper, R. and J. Ginzburg, Clarification ellipsis in dependent type theory, in: J. Bos
and C. Matheson, editors, Proceedings of Edilog,the 6th Workshop on the Semantics and
Pragmatics ofDialogue, University of Edinburgh, 2002.
[11] Fern´andez, M., S. Lappin and C. Fox, editors, “Procs. of Lambda Calculus, Type Theory and
Natural Language Workshop,” King’s College, London, 2005.
[12] Fernando, T., A type reduction from proof-conditional to dynamic semantics, Journal of
Philosophical Logic (2001), pp. 121–153.
[13] Franssen, M. and H. de Swart, Cocktail: A Toolfor Deriving Correct Programs, Rev. R. Acad.
Cien. Serie A. Mat. 98 (2004), pp. 95–111.
[14] Helman, G., “Restrictions on Lambda Abstraction and the Interpretation of Some Non-
Classical Logics,” Ph.D. thesis, University of Pittsburgh (1977).
[15] Kamp, H. and U. Reyle, “From Discourse to Logic,” Kluwer Academic Publishers, Dordrecht,
1993.
[16] Kempson, R., W. Meyer-Viol and D. Gabbay, Syntactic Computation as Labelled Deduction:
WHa case study, in: R. Borsley and I. Roberts, editors, Syntactic Categories, Academic Press,
2000.
[17] Laan, T., “The Evolution of Type Theory in Logic and Mathematics,” Ph.D. thesis, Eindhoven
University of Technology (1997).
[18] Piwek, P., ALLIGATOR Theorem Prover Home Page, mcs.open.ac.uk/pp2464/alligator (2006).
[19] Piwek, P. and E. Krahmer, Presuppositions in Context: Constructing Bridges, in: P. Bonzon,
M. Cavalcanti and R. Nossum, editors, Formal Aspects of Context, Applied Logic Series 20,
Kluwer Academic Publishers, Dordrecht, 2000.
[20] Ranta, A., “Type-Theoretical Grammar,” Clarendon Press, 1994.
[21] Rips, L., “The Psychology of Proof: Deductive Reasoning in Human Thinking,” The MIT
Press, Cambridge, Massachusetts, 1994.
[22] Stone, M., Specifying Generation ofReferring Expressions by Example, in: Procs AAAI Spring
Symposium on Natural Language Generation in Spoken and Written Dialogue, Stanford, 2003.
[23] Sundholm, G., Proof Theory and Meaning, in: Handbook of Philosophical Logic III, D.
Reidel, 1986 pp. 471–506.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.767069">
<title confidence="0.988426333333333">The ALLIGATOR Theorem Prover for Dependent Type Systems: Description and Proof Sample</title>
<author confidence="0.999035">Paul Piwek</author>
<affiliation confidence="0.8852885">Centre for Research in The Open University, Milton Keynes,</affiliation>
<email confidence="0.996435">p.piwek@open.ac.uk</email>
<abstract confidence="0.999096666666667">paper introduces the prover for Dependent Type Systems start with highlighting a number of properties of make them specifically suited computational semantics. We then briefly introduce our implementation. The concludes with an example of a that illustrates the suitability of modelling anaphora resolution.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>R Ahn</author>
<author>“Agents</author>
</authors>
<title>Objects and Events: A computational approach to knowledge, observation and communication,”</title>
<date>2001</date>
<tech>Ph.D. thesis,</tech>
<institution>Eindhoven University of Technology</institution>
<contexts>
<context position="4176" citStr="[1]" startWordPosition="642" endWordPosition="642">atory questions (cf. [22]) and why questions (A:p, B: no, ¬p, A: Why ¬p?). In order to respond appropriately, the agent needs to access its own background knowledge and how it was used to draw conclusions. DTs proof objects provide a compact representation of this information. (v) APPLICATIONs: DTs-style analyses exist for a wide range of linguistic phenomena including donkey sentences ([23]), anaphoric expressions and temporal reference ([20]), belief revision ([8]), bridging anaphora ([19]), clarification ellipsis ([10]), metonymy ([9]), inter-agent communication, knowledge and observation ([1]), ontological reasoning for feedback dialogues ([6]), and human-machine dialogue ([2]). Additionally, there is research on relating DTs proof-theoretic natural language semantics to model-theoretic approaches ([12]), and there are studies employing the related formalism of labelled deduction to natural language semantics ([16]). In 2005, the 2nd Workshop on Lambda-Calculus, Type Theory, and Natural Language took place at King’s College London ([11]). We concede that none of the properties we have listed is on its own unique to DTs. However, to the best of our knowledge, no extant logical calc</context>
</contexts>
<marker>[1]</marker>
<rawString>Ahn, R., “Agents, Objects and Events: A computational approach to knowledge, observation and communication,” Ph.D. thesis, Eindhoven University of Technology (2001).</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Ahn</author>
<author>R Beun</author>
<author>T Borghuis</author>
<author>H Bunt</author>
<author>C van Overveld</author>
</authors>
<title>The DenK-architecture: a fundamental approach to user-interfaces,</title>
<date>1994</date>
<journal>Artificial Intelligence Review Journal</journal>
<volume>8</volume>
<pages>431--445</pages>
<contexts>
<context position="4262" citStr="[2]" startWordPosition="652" endWordPosition="652"> respond appropriately, the agent needs to access its own background knowledge and how it was used to draw conclusions. DTs proof objects provide a compact representation of this information. (v) APPLICATIONs: DTs-style analyses exist for a wide range of linguistic phenomena including donkey sentences ([23]), anaphoric expressions and temporal reference ([20]), belief revision ([8]), bridging anaphora ([19]), clarification ellipsis ([10]), metonymy ([9]), inter-agent communication, knowledge and observation ([1]), ontological reasoning for feedback dialogues ([6]), and human-machine dialogue ([2]). Additionally, there is research on relating DTs proof-theoretic natural language semantics to model-theoretic approaches ([12]), and there are studies employing the related formalism of labelled deduction to natural language semantics ([16]). In 2005, the 2nd Workshop on Lambda-Calculus, Type Theory, and Natural Language took place at King’s College London ([11]). We concede that none of the properties we have listed is on its own unique to DTs. However, to the best of our knowledge, no extant logical calculus combines all these properties in a single system with well-understood meta-mathem</context>
</contexts>
<marker>[2]</marker>
<rawString>Ahn, R., R. Beun, T. Borghuis, H. Bunt and C. van Overveld, The DenK-architecture: a fundamental approach to user-interfaces, Artificial Intelligence Review Journal 8 (1994), pp. 431–445.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Andrews</author>
<author>M Bishop</author>
<author>S Issar</author>
<author>D Nesmith</author>
<author>F Pfennig</author>
<author>H Xi</author>
</authors>
<title>TPS: A Theorem-Proving System for Classical Type Theory,</title>
<date>1996</date>
<journal>Journal of Automated Reasoning</journal>
<volume>16</volume>
<pages>321--353</pages>
<contexts>
<context position="9733" citStr="[3]" startWordPosition="1663" endWordPosition="1663">3 System Architecture, Implementation and Proof Sample There is no room for a detailed description of the system here, for that we refer to the documentation and code available at [18]. What we can offer is, firstly, a list of differences between ALLIGATOR and other DTs provers: (a) ALLIGATOR directly constructs proof objects for natural deduction proofs. Other provers for DTs typically work with internal representations that are only at the end of the reasoning process translated to natural deduction proof objects. For example, COCKTAIL ([13]) uses tableaux and translates these, whereas TPs ([3]) is based on the mating method. The handbook chapter by Barendregt and Geuvers on proof assistants for DTs ([5]) lists a number of further automated theorem provers, none of which works directly with proof objects. (b) ALLIGATOR was not developed with mathematical/program specification reasoning in mind, but rather for inferences in language interpretation. As a consequence, it has been streamlined to link up with notation and functionality relevant to computational semantics (specifically, allowing for notation which is close to [15] and omission of inductive types). (3) To the best of our k</context>
</contexts>
<marker>[3]</marker>
<rawString>Andrews, P., M. Bishop, S. Issar, D. Nesmith, F. Pfennig and H. Xi, TPS: A Theorem-Proving System for Classical Type Theory, Journal of Automated Reasoning 16 (1996), pp. 321–353.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Barendregt</author>
</authors>
<title>Lambda Calculi with Types, in:</title>
<date>1992</date>
<journal>Handbook of Logic in Computer Science,</journal>
<volume>2</volume>
<pages>.</pages>
<publisher>Press,</publisher>
<location>Clarendon</location>
<contexts>
<context position="1401" citStr="[4,5]" startWordPosition="216" endWordPosition="216">emantics, citing both practical (availability of high performance theorem provers and to a lesser extent model builders) and theoretical reasons (they discuss a range of interesting phenomena which can be dealt with in FOPL). We agree with the idea that FOPL is a good starting point, but also think that for computational semantics to develop further as a field, extensions going beyond FOPL should be actively explored. In this paper, a research tool is described that takes such explorations in one particular direction. The tool – ALLIGATOR – is a theorem prover for Dependent Type Systems (DTs) [4,5]. The Sicstus Prolog source code of this prover is available, free of charge, for research purposes ([18]). DTs are an attractive option for computational semantics for a number of reasons: (i) DYNAMIC POTENTIAL (cf. [15]): The notion of a context that is built up incrementally is inherent to DTs. (ii) FLEXIBILITY: By varying a limited number of parameters, it is possible to switch from, for example, propositional to predicate logic, or first order to higher order logics. Additionally, although the basic underlying logic is constructive, DTs allows for the flexible use of axioms to regain full</context>
<context position="4945" citStr="[4]" startWordPosition="755" endWordPosition="755">age semantics to model-theoretic approaches ([12]), and there are studies employing the related formalism of labelled deduction to natural language semantics ([16]). In 2005, the 2nd Workshop on Lambda-Calculus, Type Theory, and Natural Language took place at King’s College London ([11]). We concede that none of the properties we have listed is on its own unique to DTs. However, to the best of our knowledge, no extant logical calculus combines all these properties in a single system with well-understood meta-mathematical properties (DTs play a central role in theoretical computer science, see [4]). 2 Dependent Type Systems DTs come in a wide variety of flavours and variations. All these systems share, however, two features: a typing system and a notion of dependency. Firstly, DTs are type systems. That is, given a set of assumptions P, also known as the context, they provide rules for determining whether a particular object, say a, belongs to a given type, say t. We write P F- a : t, if, given the context P, a is of type t, i.e., a inhabits type t. The objects that are classified using type systems are (normalizing) terms of the λ-calculus. P is a sequence of statements x1 : t1, ... ,</context>
<context position="8845" citStr="[4]" startWordPosition="1515" endWordPosition="1515"> with a method that transforms a proof of p into a proof for q. In a DTs, this is formalized by modelling the proof f for a type p —* q as a function from objects of type p to objects of type q, such that if a is a proof of p, then f applied to a is a proof of q (i.e., fa : q). Universal quantification is dealt with along the same lines. In a DTs, the counterpart for universal quantification is the dependent function type. In particular, bx E A : P(x) becomes (IIx : A.Px). A proof for this type is a function f which, given any object a : A, returns the proof fa for Pa. PURE TYPE SYsTEMs (PTs; [4]) are of particular interest, because of their generality. With a small number of parameters, PTs can be tailored to match a wide variety of DTs. ALLIGATOR implements an extension of PTs with Σ types. Σ types are also known as dependent product types and can be used to model ∧ and ∃. 3 System Architecture, Implementation and Proof Sample There is no room for a detailed description of the system here, for that we refer to the documentation and code available at [18]. What we can offer is, firstly, a list of differences between ALLIGATOR and other DTs provers: (a) ALLIGATOR directly constructs p</context>
<context position="10460" citStr="[4]" startWordPosition="1775" endWordPosition="1775">mber of further automated theorem provers, none of which works directly with proof objects. (b) ALLIGATOR was not developed with mathematical/program specification reasoning in mind, but rather for inferences in language interpretation. As a consequence, it has been streamlined to link up with notation and functionality relevant to computational semantics (specifically, allowing for notation which is close to [15] and omission of inductive types). (3) To the best of our knowledge, ALLIGATOR is the only automated theorem prover which directly conforms to the specification of Pure Type Systems ([4]), the most general and flexible kind of DTs (most DTs can be emulated in PTs; see [17] for an overview of DTs and their counterparts in PTs). ALLIGATOR 1.0 has been implemented in Sicstus PROLOG and been tested with version 3.12.2 of Sicstus. An overview of the architecture is presented in Figure 1.a. Note that the system applies both forward and backward inferencing. Most of the forward inferencing takes place before backward inferencing (though some backward inferencing rules do also have forward inferencing component). Reduction of terms is also carried out mainly before backward inferenci</context>
</contexts>
<marker>[4]</marker>
<rawString>Barendregt, H., Lambda Calculi with Types, in: Handbook of Logic in Computer Science, 2, Clarendon Press, Oxford, 1992 .</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Barendregt</author>
<author>H Geuvers</author>
</authors>
<title>Proof-assistants using Dependent Type Systems, in:</title>
<date>2001</date>
<booktitle>Handbook ofAutomated Reasoning, Elsevier,</booktitle>
<contexts>
<context position="1401" citStr="[4,5]" startWordPosition="216" endWordPosition="216">emantics, citing both practical (availability of high performance theorem provers and to a lesser extent model builders) and theoretical reasons (they discuss a range of interesting phenomena which can be dealt with in FOPL). We agree with the idea that FOPL is a good starting point, but also think that for computational semantics to develop further as a field, extensions going beyond FOPL should be actively explored. In this paper, a research tool is described that takes such explorations in one particular direction. The tool – ALLIGATOR – is a theorem prover for Dependent Type Systems (DTs) [4,5]. The Sicstus Prolog source code of this prover is available, free of charge, for research purposes ([18]). DTs are an attractive option for computational semantics for a number of reasons: (i) DYNAMIC POTENTIAL (cf. [15]): The notion of a context that is built up incrementally is inherent to DTs. (ii) FLEXIBILITY: By varying a limited number of parameters, it is possible to switch from, for example, propositional to predicate logic, or first order to higher order logics. Additionally, although the basic underlying logic is constructive, DTs allows for the flexible use of axioms to regain full</context>
<context position="2749" citStr="[5]" startWordPosition="425" endWordPosition="425">(iii) EXTENsIBILITY: A DTs-context includes what is known as the signature in FOPL. Consequently, the signature can be extended incrementally, making it possible to model the acquisition of new concepts by language users. (iv) PROOF-OBJECTs: In DTs, Gentzen-style natural deduction proofs are first-class citizens. This gives us the following advantages: (a) Reliability: It allows us to heed the de Bruijn criterion for reliable proof systems: “A proof assistant satisfies the de Bruijn criterion if it generates ‘proof-objects’ (of some form) that can be checked by an easy algorithm.” (cited from [5]) (b) Naturalness: DTs proofs correspond with natural deduction proofs. This is of interest if one is concerned with models of human reasoning in natural language understanding. In psychology, some schools of thought argue that natural deduction is a good approximation of human reasoning (see, e.g., [21]). (c) Relevance: Proof objects can help to identify proofs which are valid but spurious in the sense that they do not really consume their premises (see [14]). (d) Justification of behaviour: Explicit proof objects provide direct access to the justifications that an agent has for the conclusio</context>
<context position="9845" citStr="[5]" startWordPosition="1682" endWordPosition="1682"> here, for that we refer to the documentation and code available at [18]. What we can offer is, firstly, a list of differences between ALLIGATOR and other DTs provers: (a) ALLIGATOR directly constructs proof objects for natural deduction proofs. Other provers for DTs typically work with internal representations that are only at the end of the reasoning process translated to natural deduction proof objects. For example, COCKTAIL ([13]) uses tableaux and translates these, whereas TPs ([3]) is based on the mating method. The handbook chapter by Barendregt and Geuvers on proof assistants for DTs ([5]) lists a number of further automated theorem provers, none of which works directly with proof objects. (b) ALLIGATOR was not developed with mathematical/program specification reasoning in mind, but rather for inferences in language interpretation. As a consequence, it has been streamlined to link up with notation and functionality relevant to computational semantics (specifically, allowing for notation which is close to [15] and omission of inductive types). (3) To the best of our knowledge, ALLIGATOR is the only automated theorem prover which directly conforms to the specification of Pure Ty</context>
</contexts>
<marker>[5]</marker>
<rawString>Barendregt, H. and H. Geuvers, Proof-assistants using Dependent Type Systems, in: Handbook ofAutomated Reasoning, Elsevier, 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Beun</author>
<author>R van Eijk</author>
<author>H Pr¨ust</author>
</authors>
<title>Ontological Feedback in Multiagent Systems,</title>
<date>2004</date>
<booktitle>International Joint Conference on Autonomous Agents and Multiagent Systems</booktitle>
<pages>110--117</pages>
<editor>in: N. Jennings, C. Sierra, L. Sonenberg and M. Tambe, editors,</editor>
<contexts>
<context position="4228" citStr="[6]" startWordPosition="648" endWordPosition="648">: no, ¬p, A: Why ¬p?). In order to respond appropriately, the agent needs to access its own background knowledge and how it was used to draw conclusions. DTs proof objects provide a compact representation of this information. (v) APPLICATIONs: DTs-style analyses exist for a wide range of linguistic phenomena including donkey sentences ([23]), anaphoric expressions and temporal reference ([20]), belief revision ([8]), bridging anaphora ([19]), clarification ellipsis ([10]), metonymy ([9]), inter-agent communication, knowledge and observation ([1]), ontological reasoning for feedback dialogues ([6]), and human-machine dialogue ([2]). Additionally, there is research on relating DTs proof-theoretic natural language semantics to model-theoretic approaches ([12]), and there are studies employing the related formalism of labelled deduction to natural language semantics ([16]). In 2005, the 2nd Workshop on Lambda-Calculus, Type Theory, and Natural Language took place at King’s College London ([11]). We concede that none of the properties we have listed is on its own unique to DTs. However, to the best of our knowledge, no extant logical calculus combines all these properties in a single syste</context>
</contexts>
<marker>[6]</marker>
<rawString>Beun, R., R. van Eijk and H. Pr¨ust, Ontological Feedback in Multiagent Systems, in: N. Jennings, C. Sierra, L. Sonenberg and M. Tambe, editors, International Joint Conference on Autonomous Agents and Multiagent Systems (2004), pp. 110–117.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Blackburn</author>
<author>J Bos</author>
</authors>
<date>2003</date>
<journal>Computational Semantics, Theoria</journal>
<volume>18</volume>
<pages>27--45</pages>
<contexts>
<context position="709" citStr="[7]" startWordPosition="102" endWordPosition="102">r Research in Computing The Open University, Milton Keynes, UK p.piwek@open.ac.uk Abstract This paper introduces the ALLIGATOR theorem prover for Dependent Type Systems (DTs). We start with highlighting a number of properties of DTs that make them specifically suited for computational semantics. We then briefly introduce DTs and our implementation. The paper concludes with an example of a DTs proof that illustrates the suitability of DTs for modelling anaphora resolution. 1 Introduction Automated symbolic inference requires a formal language as the substratum for reasoning. Blackburn and Bos ([7]) make a good case for the use of First Order Predicate Logic (FOPL) in computational semantics, citing both practical (availability of high performance theorem provers and to a lesser extent model builders) and theoretical reasons (they discuss a range of interesting phenomena which can be dealt with in FOPL). We agree with the idea that FOPL is a good starting point, but also think that for computational semantics to develop further as a field, extensions going beyond FOPL should be actively explored. In this paper, a research tool is described that takes such explorations in one particular </context>
</contexts>
<marker>[7]</marker>
<rawString>Blackburn, P. and J. Bos, Computational Semantics, Theoria 18 (2003), pp. 27–45.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Borghuis</author>
<author>R Nederpelt</author>
</authors>
<title>Belief Revision with Explicit Justifications: An Exploration in Type Theory, CS-Report 00-17,</title>
<date>2000</date>
<institution>Eindhoven University of Technology</institution>
<contexts>
<context position="4043" citStr="[8]" startWordPosition="626" endWordPosition="626">nts that need to respond to utterances of other agents. Such responses can themselves again be queried, for example, through clarificatory questions (cf. [22]) and why questions (A:p, B: no, ¬p, A: Why ¬p?). In order to respond appropriately, the agent needs to access its own background knowledge and how it was used to draw conclusions. DTs proof objects provide a compact representation of this information. (v) APPLICATIONs: DTs-style analyses exist for a wide range of linguistic phenomena including donkey sentences ([23]), anaphoric expressions and temporal reference ([20]), belief revision ([8]), bridging anaphora ([19]), clarification ellipsis ([10]), metonymy ([9]), inter-agent communication, knowledge and observation ([1]), ontological reasoning for feedback dialogues ([6]), and human-machine dialogue ([2]). Additionally, there is research on relating DTs proof-theoretic natural language semantics to model-theoretic approaches ([12]), and there are studies employing the related formalism of labelled deduction to natural language semantics ([16]). In 2005, the 2nd Workshop on Lambda-Calculus, Type Theory, and Natural Language took place at King’s College London ([11]). We concede </context>
</contexts>
<marker>[8]</marker>
<rawString>Borghuis, T. and R. Nederpelt, Belief Revision with Explicit Justifications: An Exploration in Type Theory, CS-Report 00-17, Eindhoven University of Technology (2000).</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Bunt</author>
<author>L Kievit</author>
</authors>
<title>Agent-dependent metonymy in a context-change model of communication, in:</title>
<date>2001</date>
<booktitle>Computing Meaning II, Studies in Linguistics and Philosophy 77,</booktitle>
<pages>75--95</pages>
<publisher>Kluwer Academic Publishers,</publisher>
<location>Dordrecht,</location>
<contexts>
<context position="4116" citStr="[9]" startWordPosition="635" endWordPosition="635">n themselves again be queried, for example, through clarificatory questions (cf. [22]) and why questions (A:p, B: no, ¬p, A: Why ¬p?). In order to respond appropriately, the agent needs to access its own background knowledge and how it was used to draw conclusions. DTs proof objects provide a compact representation of this information. (v) APPLICATIONs: DTs-style analyses exist for a wide range of linguistic phenomena including donkey sentences ([23]), anaphoric expressions and temporal reference ([20]), belief revision ([8]), bridging anaphora ([19]), clarification ellipsis ([10]), metonymy ([9]), inter-agent communication, knowledge and observation ([1]), ontological reasoning for feedback dialogues ([6]), and human-machine dialogue ([2]). Additionally, there is research on relating DTs proof-theoretic natural language semantics to model-theoretic approaches ([12]), and there are studies employing the related formalism of labelled deduction to natural language semantics ([16]). In 2005, the 2nd Workshop on Lambda-Calculus, Type Theory, and Natural Language took place at King’s College London ([11]). We concede that none of the properties we have listed is on its own unique to DTs. H</context>
</contexts>
<marker>[9]</marker>
<rawString>Bunt, H. and L. Kievit, Agent-dependent metonymy in a context-change model of communication, in: Computing Meaning II, Studies in Linguistics and Philosophy 77, Kluwer Academic Publishers, Dordrecht, 2001 pp. 75–95.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Cooper</author>
<author>J Ginzburg</author>
</authors>
<title>Clarification ellipsis in dependent type theory,</title>
<date>2002</date>
<booktitle>Proceedings of Edilog,the 6th Workshop on the Semantics and Pragmatics ofDialogue, University of Edinburgh,</booktitle>
<editor>in: J. Bos and C. Matheson, editors,</editor>
<contexts>
<context position="4100" citStr="[10]" startWordPosition="633" endWordPosition="633">Such responses can themselves again be queried, for example, through clarificatory questions (cf. [22]) and why questions (A:p, B: no, ¬p, A: Why ¬p?). In order to respond appropriately, the agent needs to access its own background knowledge and how it was used to draw conclusions. DTs proof objects provide a compact representation of this information. (v) APPLICATIONs: DTs-style analyses exist for a wide range of linguistic phenomena including donkey sentences ([23]), anaphoric expressions and temporal reference ([20]), belief revision ([8]), bridging anaphora ([19]), clarification ellipsis ([10]), metonymy ([9]), inter-agent communication, knowledge and observation ([1]), ontological reasoning for feedback dialogues ([6]), and human-machine dialogue ([2]). Additionally, there is research on relating DTs proof-theoretic natural language semantics to model-theoretic approaches ([12]), and there are studies employing the related formalism of labelled deduction to natural language semantics ([16]). In 2005, the 2nd Workshop on Lambda-Calculus, Type Theory, and Natural Language took place at King’s College London ([11]). We concede that none of the properties we have listed is on its own </context>
</contexts>
<marker>[10]</marker>
<rawString>Cooper, R. and J. Ginzburg, Clarification ellipsis in dependent type theory, in: J. Bos and C. Matheson, editors, Proceedings of Edilog,the 6th Workshop on the Semantics and Pragmatics ofDialogue, University of Edinburgh, 2002.</rawString>
</citation>
<citation valid="true">
<date>2005</date>
<booktitle>Procs. of Lambda Calculus, Type Theory and Natural Language Workshop,”</booktitle>
<editor>Fern´andez, M., S. Lappin and C. Fox, editors,</editor>
<location>King’s College, London,</location>
<contexts>
<context position="4629" citStr="[11]" startWordPosition="703" endWordPosition="703">lief revision ([8]), bridging anaphora ([19]), clarification ellipsis ([10]), metonymy ([9]), inter-agent communication, knowledge and observation ([1]), ontological reasoning for feedback dialogues ([6]), and human-machine dialogue ([2]). Additionally, there is research on relating DTs proof-theoretic natural language semantics to model-theoretic approaches ([12]), and there are studies employing the related formalism of labelled deduction to natural language semantics ([16]). In 2005, the 2nd Workshop on Lambda-Calculus, Type Theory, and Natural Language took place at King’s College London ([11]). We concede that none of the properties we have listed is on its own unique to DTs. However, to the best of our knowledge, no extant logical calculus combines all these properties in a single system with well-understood meta-mathematical properties (DTs play a central role in theoretical computer science, see [4]). 2 Dependent Type Systems DTs come in a wide variety of flavours and variations. All these systems share, however, two features: a typing system and a notion of dependency. Firstly, DTs are type systems. That is, given a set of assumptions P, also known as the context, they provide</context>
</contexts>
<marker>[11]</marker>
<rawString>Fern´andez, M., S. Lappin and C. Fox, editors, “Procs. of Lambda Calculus, Type Theory and Natural Language Workshop,” King’s College, London, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Fernando</author>
</authors>
<title>A type reduction from proof-conditional to dynamic semantics,</title>
<date>2001</date>
<journal>Journal of Philosophical Logic</journal>
<pages>121--153</pages>
<contexts>
<context position="4391" citStr="[12]" startWordPosition="667" endWordPosition="667">f objects provide a compact representation of this information. (v) APPLICATIONs: DTs-style analyses exist for a wide range of linguistic phenomena including donkey sentences ([23]), anaphoric expressions and temporal reference ([20]), belief revision ([8]), bridging anaphora ([19]), clarification ellipsis ([10]), metonymy ([9]), inter-agent communication, knowledge and observation ([1]), ontological reasoning for feedback dialogues ([6]), and human-machine dialogue ([2]). Additionally, there is research on relating DTs proof-theoretic natural language semantics to model-theoretic approaches ([12]), and there are studies employing the related formalism of labelled deduction to natural language semantics ([16]). In 2005, the 2nd Workshop on Lambda-Calculus, Type Theory, and Natural Language took place at King’s College London ([11]). We concede that none of the properties we have listed is on its own unique to DTs. However, to the best of our knowledge, no extant logical calculus combines all these properties in a single system with well-understood meta-mathematical properties (DTs play a central role in theoretical computer science, see [4]). 2 Dependent Type Systems DTs come in a wide</context>
</contexts>
<marker>[12]</marker>
<rawString>Fernando, T., A type reduction from proof-conditional to dynamic semantics, Journal of Philosophical Logic (2001), pp. 121–153.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Franssen</author>
<author>H de Swart</author>
</authors>
<title>Cocktail: A Toolfor Deriving Correct Programs,</title>
<date>2004</date>
<journal>Rev. R. Acad. Cien. Serie A. Mat.</journal>
<volume>98</volume>
<pages>95--111</pages>
<contexts>
<context position="9679" citStr="[13]" startWordPosition="1655" endWordPosition="1655">endent product types and can be used to model ∧ and ∃. 3 System Architecture, Implementation and Proof Sample There is no room for a detailed description of the system here, for that we refer to the documentation and code available at [18]. What we can offer is, firstly, a list of differences between ALLIGATOR and other DTs provers: (a) ALLIGATOR directly constructs proof objects for natural deduction proofs. Other provers for DTs typically work with internal representations that are only at the end of the reasoning process translated to natural deduction proof objects. For example, COCKTAIL ([13]) uses tableaux and translates these, whereas TPs ([3]) is based on the mating method. The handbook chapter by Barendregt and Geuvers on proof assistants for DTs ([5]) lists a number of further automated theorem provers, none of which works directly with proof objects. (b) ALLIGATOR was not developed with mathematical/program specification reasoning in mind, but rather for inferences in language interpretation. As a consequence, it has been streamlined to link up with notation and functionality relevant to computational semantics (specifically, allowing for notation which is close to [15] and </context>
</contexts>
<marker>[13]</marker>
<rawString>Franssen, M. and H. de Swart, Cocktail: A Toolfor Deriving Correct Programs, Rev. R. Acad. Cien. Serie A. Mat. 98 (2004), pp. 95–111.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Helman</author>
</authors>
<title>Restrictions on Lambda Abstraction and the Interpretation of Some NonClassical Logics,” Ph.D. thesis,</title>
<date>1977</date>
<institution>University of Pittsburgh</institution>
<contexts>
<context position="3212" citStr="[14]" startWordPosition="499" endWordPosition="499">t satisfies the de Bruijn criterion if it generates ‘proof-objects’ (of some form) that can be checked by an easy algorithm.” (cited from [5]) (b) Naturalness: DTs proofs correspond with natural deduction proofs. This is of interest if one is concerned with models of human reasoning in natural language understanding. In psychology, some schools of thought argue that natural deduction is a good approximation of human reasoning (see, e.g., [21]). (c) Relevance: Proof objects can help to identify proofs which are valid but spurious in the sense that they do not really consume their premises (see [14]). (d) Justification of behaviour: Explicit proof objects provide direct access to the justifications that an agent has for the conclusions and the interpretations that it constructs. This is particularly useful for dialogue agents that need to respond to utterances of other agents. Such responses can themselves again be queried, for example, through clarificatory questions (cf. [22]) and why questions (A:p, B: no, ¬p, A: Why ¬p?). In order to respond appropriately, the agent needs to access its own background knowledge and how it was used to draw conclusions. DTs proof objects provide a compa</context>
</contexts>
<marker>[14]</marker>
<rawString>Helman, G., “Restrictions on Lambda Abstraction and the Interpretation of Some NonClassical Logics,” Ph.D. thesis, University of Pittsburgh (1977).</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Kamp</author>
<author>U Reyle</author>
</authors>
<date>1993</date>
<booktitle>From Discourse to Logic,”</booktitle>
<publisher>Kluwer Academic Publishers,</publisher>
<location>Dordrecht,</location>
<contexts>
<context position="1622" citStr="[15]" startWordPosition="251" endWordPosition="251">L). We agree with the idea that FOPL is a good starting point, but also think that for computational semantics to develop further as a field, extensions going beyond FOPL should be actively explored. In this paper, a research tool is described that takes such explorations in one particular direction. The tool – ALLIGATOR – is a theorem prover for Dependent Type Systems (DTs) [4,5]. The Sicstus Prolog source code of this prover is available, free of charge, for research purposes ([18]). DTs are an attractive option for computational semantics for a number of reasons: (i) DYNAMIC POTENTIAL (cf. [15]): The notion of a context that is built up incrementally is inherent to DTs. (ii) FLEXIBILITY: By varying a limited number of parameters, it is possible to switch from, for example, propositional to predicate logic, or first order to higher order logics. Additionally, although the basic underlying logic is constructive, DTs allows for the flexible use of axioms to regain full classical logic, or more fine-grained alternatives. For example, it is possible to specify for individual predicates whether they are bivalent. (iii) EXTENsIBILITY: A DTs-context includes what is known as the signature i</context>
<context position="10274" citStr="[15]" startWordPosition="1744" endWordPosition="1744">AIL ([13]) uses tableaux and translates these, whereas TPs ([3]) is based on the mating method. The handbook chapter by Barendregt and Geuvers on proof assistants for DTs ([5]) lists a number of further automated theorem provers, none of which works directly with proof objects. (b) ALLIGATOR was not developed with mathematical/program specification reasoning in mind, but rather for inferences in language interpretation. As a consequence, it has been streamlined to link up with notation and functionality relevant to computational semantics (specifically, allowing for notation which is close to [15] and omission of inductive types). (3) To the best of our knowledge, ALLIGATOR is the only automated theorem prover which directly conforms to the specification of Pure Type Systems ([4]), the most general and flexible kind of DTs (most DTs can be emulated in PTs; see [17] for an overview of DTs and their counterparts in PTs). ALLIGATOR 1.0 has been implemented in Sicstus PROLOG and been tested with version 3.12.2 of Sicstus. An overview of the architecture is presented in Figure 1.a. Note that the system applies both forward and backward inferencing. Most of the forward inferencing takes plac</context>
<context position="11942" citStr="[15]" startWordPosition="2012" endWordPosition="2012">s of an experimental research tool. It is intended for testing computational solutions to theoretically challenging problems in computational semantics. Scalability has, so far, not been given much attention, though it will obviously need to be addressed if the system is to be used in largescale practical applications. Currently, the system is merely intended as a baseline and starting point for implementing efficient and effective proof search heuristics. We now conclude with an example of the use of ALLIGATOR. The discourse ‘The barn contains a chain saw or a power drill. It ...’ (p. 205 of [15]) poses a problem for the structural approach to anaphora resolution proposed in Fig. 1. Overview of ALLIGATOR 1.0 Architecture (a) and graphical representation of a proof-object (b) [15]: the first sentence does not directly introduce an accessible discourse referent that can bind the pronoun ‘It’. Rather, an object (something that is either a power drill or a chain saw) needs to be inferred from a disjunction. An inferential account of anaphora resolution that can deal with such cases is presented in [19]. In a nutshell, the idea is that an anaphoric expression triggers a proof goal that nee</context>
</contexts>
<marker>[15]</marker>
<rawString>Kamp, H. and U. Reyle, “From Discourse to Logic,” Kluwer Academic Publishers, Dordrecht, 1993.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Kempson</author>
<author>W Meyer-Viol</author>
<author>D Gabbay</author>
</authors>
<title>Syntactic Computation as Labelled Deduction: WHa case study,</title>
<date>2000</date>
<editor>in: R. Borsley and I. Roberts, editors, Syntactic Categories,</editor>
<publisher>Academic Press,</publisher>
<contexts>
<context position="4505" citStr="[16]" startWordPosition="684" endWordPosition="684">ide range of linguistic phenomena including donkey sentences ([23]), anaphoric expressions and temporal reference ([20]), belief revision ([8]), bridging anaphora ([19]), clarification ellipsis ([10]), metonymy ([9]), inter-agent communication, knowledge and observation ([1]), ontological reasoning for feedback dialogues ([6]), and human-machine dialogue ([2]). Additionally, there is research on relating DTs proof-theoretic natural language semantics to model-theoretic approaches ([12]), and there are studies employing the related formalism of labelled deduction to natural language semantics ([16]). In 2005, the 2nd Workshop on Lambda-Calculus, Type Theory, and Natural Language took place at King’s College London ([11]). We concede that none of the properties we have listed is on its own unique to DTs. However, to the best of our knowledge, no extant logical calculus combines all these properties in a single system with well-understood meta-mathematical properties (DTs play a central role in theoretical computer science, see [4]). 2 Dependent Type Systems DTs come in a wide variety of flavours and variations. All these systems share, however, two features: a typing system and a notion </context>
</contexts>
<marker>[16]</marker>
<rawString>Kempson, R., W. Meyer-Viol and D. Gabbay, Syntactic Computation as Labelled Deduction: WHa case study, in: R. Borsley and I. Roberts, editors, Syntactic Categories, Academic Press, 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Laan</author>
</authors>
<title>The Evolution of Type Theory</title>
<date>1997</date>
<booktitle>in Logic and Mathematics,” Ph.D. thesis,</booktitle>
<institution>Eindhoven University of Technology</institution>
<contexts>
<context position="10547" citStr="[17]" startWordPosition="1792" endWordPosition="1792">ects. (b) ALLIGATOR was not developed with mathematical/program specification reasoning in mind, but rather for inferences in language interpretation. As a consequence, it has been streamlined to link up with notation and functionality relevant to computational semantics (specifically, allowing for notation which is close to [15] and omission of inductive types). (3) To the best of our knowledge, ALLIGATOR is the only automated theorem prover which directly conforms to the specification of Pure Type Systems ([4]), the most general and flexible kind of DTs (most DTs can be emulated in PTs; see [17] for an overview of DTs and their counterparts in PTs). ALLIGATOR 1.0 has been implemented in Sicstus PROLOG and been tested with version 3.12.2 of Sicstus. An overview of the architecture is presented in Figure 1.a. Note that the system applies both forward and backward inferencing. Most of the forward inferencing takes place before backward inferencing (though some backward inferencing rules do also have forward inferencing component). Reduction of terms is also carried out mainly before backward inferencing. Inferencing is done with a flattened representations of DTs terms (the arrow notati</context>
</contexts>
<marker>[17]</marker>
<rawString>Laan, T., “The Evolution of Type Theory in Logic and Mathematics,” Ph.D. thesis, Eindhoven University of Technology (1997).</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Piwek</author>
</authors>
<title>ALLIGATOR Theorem Prover Home Page,</title>
<date></date>
<contexts>
<context position="1506" citStr="[18]" startWordPosition="233" endWordPosition="233">odel builders) and theoretical reasons (they discuss a range of interesting phenomena which can be dealt with in FOPL). We agree with the idea that FOPL is a good starting point, but also think that for computational semantics to develop further as a field, extensions going beyond FOPL should be actively explored. In this paper, a research tool is described that takes such explorations in one particular direction. The tool – ALLIGATOR – is a theorem prover for Dependent Type Systems (DTs) [4,5]. The Sicstus Prolog source code of this prover is available, free of charge, for research purposes ([18]). DTs are an attractive option for computational semantics for a number of reasons: (i) DYNAMIC POTENTIAL (cf. [15]): The notion of a context that is built up incrementally is inherent to DTs. (ii) FLEXIBILITY: By varying a limited number of parameters, it is possible to switch from, for example, propositional to predicate logic, or first order to higher order logics. Additionally, although the basic underlying logic is constructive, DTs allows for the flexible use of axioms to regain full classical logic, or more fine-grained alternatives. For example, it is possible to specify for individua</context>
<context position="9314" citStr="[18]" startWordPosition="1599" endWordPosition="1599"> : A.Px). A proof for this type is a function f which, given any object a : A, returns the proof fa for Pa. PURE TYPE SYsTEMs (PTs; [4]) are of particular interest, because of their generality. With a small number of parameters, PTs can be tailored to match a wide variety of DTs. ALLIGATOR implements an extension of PTs with Σ types. Σ types are also known as dependent product types and can be used to model ∧ and ∃. 3 System Architecture, Implementation and Proof Sample There is no room for a detailed description of the system here, for that we refer to the documentation and code available at [18]. What we can offer is, firstly, a list of differences between ALLIGATOR and other DTs provers: (a) ALLIGATOR directly constructs proof objects for natural deduction proofs. Other provers for DTs typically work with internal representations that are only at the end of the reasoning process translated to natural deduction proof objects. For example, COCKTAIL ([13]) uses tableaux and translates these, whereas TPs ([3]) is based on the mating method. The handbook chapter by Barendregt and Geuvers on proof assistants for DTs ([5]) lists a number of further automated theorem provers, none of which </context>
</contexts>
<marker>[18]</marker>
<rawString>Piwek, P., ALLIGATOR Theorem Prover Home Page, mcs.open.ac.uk/pp2464/alligator (2006).</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Piwek</author>
<author>E Krahmer</author>
</authors>
<title>Presuppositions in Context: Constructing Bridges,</title>
<date>2000</date>
<booktitle>Formal Aspects of Context, Applied Logic Series 20,</booktitle>
<editor>in: P. Bonzon, M. Cavalcanti and R. Nossum, editors,</editor>
<publisher>Kluwer Academic Publishers,</publisher>
<location>Dordrecht,</location>
<contexts>
<context position="4069" citStr="[19]" startWordPosition="629" endWordPosition="629">to utterances of other agents. Such responses can themselves again be queried, for example, through clarificatory questions (cf. [22]) and why questions (A:p, B: no, ¬p, A: Why ¬p?). In order to respond appropriately, the agent needs to access its own background knowledge and how it was used to draw conclusions. DTs proof objects provide a compact representation of this information. (v) APPLICATIONs: DTs-style analyses exist for a wide range of linguistic phenomena including donkey sentences ([23]), anaphoric expressions and temporal reference ([20]), belief revision ([8]), bridging anaphora ([19]), clarification ellipsis ([10]), metonymy ([9]), inter-agent communication, knowledge and observation ([1]), ontological reasoning for feedback dialogues ([6]), and human-machine dialogue ([2]). Additionally, there is research on relating DTs proof-theoretic natural language semantics to model-theoretic approaches ([12]), and there are studies employing the related formalism of labelled deduction to natural language semantics ([16]). In 2005, the 2nd Workshop on Lambda-Calculus, Type Theory, and Natural Language took place at King’s College London ([11]). We concede that none of the propertie</context>
<context position="12454" citStr="[19]" startWordPosition="2094" endWordPosition="2094">ATOR. The discourse ‘The barn contains a chain saw or a power drill. It ...’ (p. 205 of [15]) poses a problem for the structural approach to anaphora resolution proposed in Fig. 1. Overview of ALLIGATOR 1.0 Architecture (a) and graphical representation of a proof-object (b) [15]: the first sentence does not directly introduce an accessible discourse referent that can bind the pronoun ‘It’. Rather, an object (something that is either a power drill or a chain saw) needs to be inferred from a disjunction. An inferential account of anaphora resolution that can deal with such cases is presented in [19]. In a nutshell, the idea is that an anaphoric expression triggers a proof goal that needs to be filled with a proof from the context. ALLIGATOR can construct an antecedent for ‘It’ from the context (for lack of space, our formalization is in propositional logic). Firstly, the relevant propositions need to be available: false:prop (false is a proposition), p:prop (there is a chain saw is a proposition), q:prop (there is a power drill is a proposition), u:prop (there is something is a proposition). Given these propositions, we can now introduce background information such as a1:p→u (roughly, ch</context>
</contexts>
<marker>[19]</marker>
<rawString>Piwek, P. and E. Krahmer, Presuppositions in Context: Constructing Bridges, in: P. Bonzon, M. Cavalcanti and R. Nossum, editors, Formal Aspects of Context, Applied Logic Series 20, Kluwer Academic Publishers, Dordrecht, 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Ranta</author>
</authors>
<title>Type-Theoretical Grammar,”</title>
<date>1994</date>
<publisher>Clarendon Press,</publisher>
<contexts>
<context position="4020" citStr="[20]" startWordPosition="623" endWordPosition="623"> useful for dialogue agents that need to respond to utterances of other agents. Such responses can themselves again be queried, for example, through clarificatory questions (cf. [22]) and why questions (A:p, B: no, ¬p, A: Why ¬p?). In order to respond appropriately, the agent needs to access its own background knowledge and how it was used to draw conclusions. DTs proof objects provide a compact representation of this information. (v) APPLICATIONs: DTs-style analyses exist for a wide range of linguistic phenomena including donkey sentences ([23]), anaphoric expressions and temporal reference ([20]), belief revision ([8]), bridging anaphora ([19]), clarification ellipsis ([10]), metonymy ([9]), inter-agent communication, knowledge and observation ([1]), ontological reasoning for feedback dialogues ([6]), and human-machine dialogue ([2]). Additionally, there is research on relating DTs proof-theoretic natural language semantics to model-theoretic approaches ([12]), and there are studies employing the related formalism of labelled deduction to natural language semantics ([16]). In 2005, the 2nd Workshop on Lambda-Calculus, Type Theory, and Natural Language took place at King’s College Lon</context>
</contexts>
<marker>[20]</marker>
<rawString>Ranta, A., “Type-Theoretical Grammar,” Clarendon Press, 1994.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Rips</author>
</authors>
<title>The Psychology of Proof: Deductive Reasoning in Human Thinking,”</title>
<date>1994</date>
<publisher>The MIT Press,</publisher>
<location>Cambridge, Massachusetts,</location>
<contexts>
<context position="3054" citStr="[21]" startWordPosition="472" endWordPosition="472"> citizens. This gives us the following advantages: (a) Reliability: It allows us to heed the de Bruijn criterion for reliable proof systems: “A proof assistant satisfies the de Bruijn criterion if it generates ‘proof-objects’ (of some form) that can be checked by an easy algorithm.” (cited from [5]) (b) Naturalness: DTs proofs correspond with natural deduction proofs. This is of interest if one is concerned with models of human reasoning in natural language understanding. In psychology, some schools of thought argue that natural deduction is a good approximation of human reasoning (see, e.g., [21]). (c) Relevance: Proof objects can help to identify proofs which are valid but spurious in the sense that they do not really consume their premises (see [14]). (d) Justification of behaviour: Explicit proof objects provide direct access to the justifications that an agent has for the conclusions and the interpretations that it constructs. This is particularly useful for dialogue agents that need to respond to utterances of other agents. Such responses can themselves again be queried, for example, through clarificatory questions (cf. [22]) and why questions (A:p, B: no, ¬p, A: Why ¬p?). In ord</context>
</contexts>
<marker>[21]</marker>
<rawString>Rips, L., “The Psychology of Proof: Deductive Reasoning in Human Thinking,” The MIT Press, Cambridge, Massachusetts, 1994.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Stone</author>
</authors>
<title>Specifying Generation ofReferring Expressions by Example, in:</title>
<date>2003</date>
<booktitle>Procs AAAI Spring Symposium on Natural Language Generation in Spoken and Written Dialogue,</booktitle>
<location>Stanford,</location>
<contexts>
<context position="3598" citStr="[22]" startWordPosition="556" endWordPosition="556"> is a good approximation of human reasoning (see, e.g., [21]). (c) Relevance: Proof objects can help to identify proofs which are valid but spurious in the sense that they do not really consume their premises (see [14]). (d) Justification of behaviour: Explicit proof objects provide direct access to the justifications that an agent has for the conclusions and the interpretations that it constructs. This is particularly useful for dialogue agents that need to respond to utterances of other agents. Such responses can themselves again be queried, for example, through clarificatory questions (cf. [22]) and why questions (A:p, B: no, ¬p, A: Why ¬p?). In order to respond appropriately, the agent needs to access its own background knowledge and how it was used to draw conclusions. DTs proof objects provide a compact representation of this information. (v) APPLICATIONs: DTs-style analyses exist for a wide range of linguistic phenomena including donkey sentences ([23]), anaphoric expressions and temporal reference ([20]), belief revision ([8]), bridging anaphora ([19]), clarification ellipsis ([10]), metonymy ([9]), inter-agent communication, knowledge and observation ([1]), ontological reasoni</context>
</contexts>
<marker>[22]</marker>
<rawString>Stone, M., Specifying Generation ofReferring Expressions by Example, in: Procs AAAI Spring Symposium on Natural Language Generation in Spoken and Written Dialogue, Stanford, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Sundholm</author>
</authors>
<title>Proof Theory and Meaning, in:</title>
<date>1986</date>
<booktitle>Handbook of Philosophical Logic III, D. Reidel,</booktitle>
<pages>471--506</pages>
<contexts>
<context position="3967" citStr="[23]" startWordPosition="616" endWordPosition="616">erpretations that it constructs. This is particularly useful for dialogue agents that need to respond to utterances of other agents. Such responses can themselves again be queried, for example, through clarificatory questions (cf. [22]) and why questions (A:p, B: no, ¬p, A: Why ¬p?). In order to respond appropriately, the agent needs to access its own background knowledge and how it was used to draw conclusions. DTs proof objects provide a compact representation of this information. (v) APPLICATIONs: DTs-style analyses exist for a wide range of linguistic phenomena including donkey sentences ([23]), anaphoric expressions and temporal reference ([20]), belief revision ([8]), bridging anaphora ([19]), clarification ellipsis ([10]), metonymy ([9]), inter-agent communication, knowledge and observation ([1]), ontological reasoning for feedback dialogues ([6]), and human-machine dialogue ([2]). Additionally, there is research on relating DTs proof-theoretic natural language semantics to model-theoretic approaches ([12]), and there are studies employing the related formalism of labelled deduction to natural language semantics ([16]). In 2005, the 2nd Workshop on Lambda-Calculus, Type Theory, </context>
</contexts>
<marker>[23]</marker>
<rawString>Sundholm, G., Proof Theory and Meaning, in: Handbook of Philosophical Logic III, D. Reidel, 1986 pp. 471–506.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>