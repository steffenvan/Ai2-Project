<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000002">
<title confidence="0.993928">
Enriching Partially-Specified Representations for Text Realization
Using an Attribute Grammar *
</title>
<author confidence="0.68692">
Songsak Channarukul Susan W. McRoy Syed S. Ali
</author>
<email confidence="0.705111">
{songsak, mcroy, syah} @cs.uwm.edu
</email>
<author confidence="0.567056">
Natural,f,anpage..and,Knowledge:Representation_ftesearch Group.
</author>
<affiliation confidence="0.770028333333333">
http://tiggencs.uwiri.edufhlkrrg
Electrical Engineering and Computer Science Department
University of Wisconsin-Milwaukee
</affiliation>
<sectionHeader confidence="0.909685" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999813192307692">
We present a new approach to enriching under-
specified representations of content to be realized
as text. Our approach uses an attribute gram-
mar to propagate missing information where needed
in a tree that represents the text to be realized.
This declaratively-specified grammar mediates be-
tween application-produced output and the input to
a generation system and, as a consequence, can eas-
ily augment an existing generation system. End-
applications that use this approach can produce high
quality text without a fine-grained specification of
the text to be realized, thereby reducing the bur-
den to the application. Additionally, representations
used by the generator are compact, because values
that can be constructed from the constraints en-
coded by the grammar will be propagated where nec-
essary. This approach is more flexible than default-
ing or making a statistically good choice because it
can deal with long-distance dependencies (such as
gaps and reflexive pronouns). Our approach differs
from other approaches that use attribute grammars
in that we use the grammar to enrich the represen-
tations of the content to be realized, rather than
to generate the text itself. We illustrate the ap-
proach with examples from our template-based text-
realizer, YAG.
</bodyText>
<sectionHeader confidence="0.996403" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999099333333333">
Typically, a text realization system requires a great
deal of syntactic information from an application
in order to generate a high quality text; however,
an application might not have this information (un-
less it has been built with text generation in mind).
This problem has been referred to as the Genera-
tion Gap (Meteer, 1990). Meteer first identified the
generation gap problem as arising at the text plan-
ning stage. A text planner must decide what content
needs to be expressed and creates a corresponding
text plan for generating it. A sentence planner is
then used to select an appropriate syntactic si ruc-
</bodyText>
<footnote confidence="0.584512666666667">
°This work was supported by.a gift from .Intel Corporation;
and by the National Science Foundation. under grants IRI-
9701617 and 1RJ-9523666.
</footnote>
<bodyText confidence="0.999929181818182">
ture for a given plan. Typically, neither a text plan-
ner nor a sentence planner is concerned with fine-
grained syntactic issues, such as whether the subject
of the sentence is a singular or plural noun. Thus,
it becomes the responsibility of a text realizer to in-
fer the missing information and to generate the best
possible text from a given input.
Most generation systems (such as FUF/SURGE
(Elhadad, 1992), Penman (Mann, 1983), Real-
Pro (Lavoie and Rambow, 1997), TG/2 (Busemarm,
1996), and YAG (Channarukul, 1999; McRoy et al.,
1999)) alleviate this problem by using defaulting,
in which a grammar writer specifies a default for
each syntactic constraint. This approach is inflexi-
ble and prone to errors, because there might not be
one default that suits all applications or situations.
Another approach that has been proposed is to fill
in the missing information on the basis of word co-
occurrence data collected from a large corpus of text
(see Nitrogen (Knight and Hatzivassiloglou, 1995)).
However, statistical approaches have difficulty when
there are long-distance dependencies among con-
stituents in a text.
In this paper, we present a new approach to re-
solving the so-called generation gap that uses an At-
tribute Grammar (Knuth, 1968) to enrich partially-
specified inputs to a realization system to pro-
duce high quality texts. Attribute Grammars are a
declarative formalism for defining rules for attribute
propagation (see Section 3). They have been used
primarily for specifying the ,semantics of program-
ming languages, although a few researchers have also
used them to drive a text generator (see (Levison
and Lessard, 1990), for example). The main advan-
tage of our approach is that it allows a generator
to enjoy the computational efficiency of a template-
based realization system, while reducing the linguis-
tic burden on an application and increasing the qual-
ity of the generated texts.
Our work differs from previous uses of attribute
grammars in natural language generation. which
are similar to Levison and Lessard (Levison and
Lessard, 1990) in that they apply attribute gram-
mars directly to text realization. For example, Lev-
</bodyText>
<page confidence="0.997014">
163
</page>
<figure confidence="0.968259166666667">
((template CLAUSE)
(process-type MENTAL)
(process &amp;quot;vent&amp;quot;)
(processor ((template NOUN-PHRASE)
(head ((template CONJUNCTION)
(first ((template NOUN-PHRASE)
(head &amp;quot;Jack&amp;quot;)
(np-type PROPER)
—(gender MASCULINE)
(definite NOART)))
(second ((template PRONOUN)) )))
(person SECOND)
(number PLURAL)) )
(phenomenon ((template NOUN-PHRASE)
(head &amp;quot;dog&amp;quot;)
(definite NOART)
(possessor ((template NOUN-PHRASE)
(head &amp;quot;sister&amp;quot;)
(gender FEMININE)
(definite NOART)
(possessor ((template NOUN-PHRASE)
(head &amp;quot;Jack&amp;quot;)
(np-type PROPER)
(gender MASCULINE)
(pronominal YES)
(definite NOART)) )))))
(rear-circum ((template CLAUSE)
(mood TO-INFINITIVE)
(process-type MATERIAL)
(process &amp;quot;swim&amp;quot;)) ) )
</figure>
<figureCaption confidence="0.999931">
Figure 1: A Feature Structure for the Sentence &amp;quot;Jack and I want his sister&apos;s dog to swim.&amp;quot;.
</figureCaption>
<bodyText confidence="0.999880538461538">
ison and Lessard extend a context-free grammar
with attributes arid semantic rules similar to classi-
cal attribute grammars presented by Knuth (Knuth,
1968). Attributes in their system assist the realiza-
tion by propagating information down a tree that
specifies the complete syntactic structure of the out-
put text. By contrast, our work employs attribute
grammars, not to realize a text, but to perform a
generation gap analysis prior to actual realization.
We use both inherited and synthesized attributes
(i.e., propagating information both down and up a
tree) to share information and to determine appro-
priate values for any missing features.
</bodyText>
<sectionHeader confidence="0.75969" genericHeader="introduction">
2 An Overview of YAG
</sectionHeader>
<bodyText confidence="0.992852594594594">
YAG (Yet Another Generator) (Channarukul, 1999;
McRoy et al., 1999) is a template-based text-
realization system that generates text in real-time.
YAG uses templates to express text structures corre-
sponding to fragments of the target language. Tem-
plates in YAG are declarative and modular. Com-
plex texts can be generated by embedding templates
inside other templates.
Values for the templates are provided by an appli-
cation: inputs can include either a conceptual repre-
sentation of content, or a feature structure, When an
input is only partially specified, defaults defined in a
template will be applied. Figure 1 shows an example
of YAG&apos;s feature-structure based input; YAG would
realize this example as &amp;quot;Jack and I want his sister&apos;s
dog to swim.&amp;quot;. This input is partially specified, and
thus is more compact and easier for an application
to specify, than a complete specification. Figure 2
shows the features that have been omitted and the
defaults used by YAG to realize the sentence from
the input.
Although the input is already more compact than
a full specification, further simplification of the in-
put provided from an application would have been
possible, if certain inferences could be made. For ex-
ample, Figure 3 shows an input structure that could
replace the one given in Figure 1. In Figure 3, it was
not necessary for the application to specify that the
conjunction of two noun phrases is a plural noun
phrase, nor that component noun phrases (proper
nouns. pronouns, and possessives) should not con-
tain an article, in the case of conjunctions, there is
no default that would provide the correct outputs in
all cases, because the same conjunction template is
used to conjoin adjectives and clauses_ Instead, our
approach uses an attribute grammar to make the
appropriate inferences and enrich the feature struc-
</bodyText>
<page confidence="0.994499">
164
</page>
<table confidence="0.9993900625">
Template Name . Template Slot Default TAHowed‘rOues
CLAUSE sentence YES YES, NO
mood DECLARATIVE DECLARATIVE, YES-NO, WH, IMPERATIVE,
process-type ASCRIPTIVE TO-INFINITIVE
mode mil ASCRIPTIVE, MENTAL, MATERIAL,
tense &apos; &apos;PRESENT COMPOSITE, POSSESSIVE, LOCATIVE,
future NO TEMPORAL, VERBAL, EXISTENTIAL
progressive NO ATTRIBUTIVB, JEQUATIVE, CAUSATIVE
perfective NO PRESENT, PAST
voice ACTIVE YES, NO
quality POSITIVE YES, NO
YES, NO
ACTIVE, PASSIVE
POSITIVE, NEGATIVE
NOUN-PHRASE np-type COMMON COMMON, PROPER
person THIRD FIRST, SECOND, THIRD
number SINGULAR SINGULAR, PLURAL
gender NEUTRAL NEUTRAL, MASCULINE, FEMININE
definite NO YES, NO, NOART
regular-noun YES YES, NO
countable YES YES, NO
inflected YES YES, NO
pronominal NO YES, NO
POSSESSOR pronominal YES YES, NO
PRONOUN type PERSONAL PERSONAL, OBJECTIVE, REFLEXIVE,
person FIRST POSSESSIVE-PRONOUN,
number SINGULAR POSSESSIVE-DETERMINER,
gender NEUTRAL RELATIVE, DEMONSTRATIVE
FIRST, SECOND, THIRD
SINGULAR, PLURAL
NEUTRAL, MASCULINE, FEMININE
CONJUNCTION sentence NO YES, NO
</table>
<figureCaption confidence="0.99417">
Figure 2: Some Defaults from YAG&apos;s Syntactic Templates.
</figureCaption>
<figure confidence="0.995955565217391">
((template CLAUSE)
(process-type MENTAL)
(process &amp;quot;want&amp;quot;)
(processor ((template CONJUNCTION)
(first ((template NOUN-PHRASE)
(head &amp;quot;Jack&amp;quot;)
(np-type PROPER)
(gender MASCULINE) ))
(second ((template PRONOUN)) )))
(phenomenon ((template NOUN-PHRASE)
(head &amp;quot;dog&amp;quot;)
(possessor ((template NOUN-PHRASE)
(head &amp;quot;sister&amp;quot;)
(gender FEMININE)
- (possessor-((template NOUN-PHRASE)
(head &amp;quot;Jack&amp;quot;)
(np-type PROPER)
(gender MASCULINE)
(pronominal YES)) )))))
(rear-circum ((template CLAUSE)
(mood TO-INFINITIVE)
(process-type MATERIAL)
(process &amp;quot;swim&amp;quot;)) ) )
</figure>
<figureCaption confidence="0.999716">
Figure 3: A (shorter) Feature Structure of the Sentence &amp;quot;Jack and I want his sister&apos;s dog to swim.&amp;quot;.
</figureCaption>
<page confidence="0.991783">
165
</page>
<bodyText confidence="0.925016333333333">
ture input so that neither the application, nor the
templates need to be altered to handle dependencies,
like conjunctions, correctly.
</bodyText>
<sectionHeader confidence="0.959777" genericHeader="method">
3 Attribute Grammars
</sectionHeader>
<bodyText confidence="0.960759555555555">
An attribute grammar consists of a context-free
grammar, a finite set of attributes, and a set of se-
mantic rules. The ._Context-Eree -.Grammar- (CFG)
specifies the syntax of a language by expressing how
to construct a syntax tree from non-terminal and ter-
minal symbols defined in a language. The Attributes
and Semantic Rules specify the semantics. A finite
set of attributes is associated with each non-terminal
symbol. Each of these sets is divided into two dis-
joint subsets, namely Inherited Attributes and Syn-
thesized Attributes. Inherited attributes propagate
down a syntax tree whereas synthesized attributes
propagate upward. A semantic rule specifies how to
compute the value of an attribute from others. This
specification implicitly defines dependencies among
attributes in an attribute grammar, locally (within a
production) and globally (among productions). At-
tribute Evaluation is the process of computing values
for every attribute instance in the tree according to
the semantic rules defined for each production.
An example of an attribute grammar and its com-
ponents is given in Figure 4 (adapted from (Alblas,
1991)). This attribute grammar consists of two non-
terminals, two terminals, and three production rules.
The inherited attributes of the non-terminal A are a
and b. Its synthesized attributes are x and y. No
attributes are assigned to the non-terminal S.
</bodyText>
<figureCaption confidence="0.379387">
nontermivals: S, A.
terminals: s, t.
start symbol: S.
description of attributes:
a, b: integer, inh of A;
x, y: integer, syn of A;
productions and semantic rules:
</figureCaption>
<equation confidence="0.788074">
1) S -&gt; A.
A.a := A.x
2) AO -&gt; Al s.
Al.a := AO.a; Al.h := Al.y;
AO.x := Al.x; AO.y := 1
3) A -&gt; t.
A.y := A.a; Ax := A.b
</equation>
<figureCaption confidence="0.927976714285714">
Figure 4: An Example Attribute Grammar.
As mentioned earlier, semantic rules define depen-
dencies among attributes. Figure 5 shows depen-
dency graphs corresponding to the semantic rules of
Figure 4. In the graphs. a dotted line represents a
derivation of a production rule,• while an arrow de-
notes an attribute dependency. Thus. .4 B means
</figureCaption>
<figure confidence="0.6104085">
abAxy
(1) (2) (3)
</figure>
<figureCaption confidence="0.996771">
Figure 5: Dependency Graphs.
</figureCaption>
<bodyText confidence="0.599713333333333">
B is dependent on A, but not the other way around.
In other words, we cannot know B before we know
A.
</bodyText>
<sectionHeader confidence="0.8207725" genericHeader="method">
4 Extending a Grammar to Enable
Generation Gap Analysis
</sectionHeader>
<bodyText confidence="0.986984">
To make a generation gap analysis possible, a gram-
mar writer must first extend the grammar of his
or her existing generator to capture the propaga-
tion semantics of a target language. This extension
involves defining attributes (synthesized and inher-
ited) and associated semantic rules. Next, a small
program must be built to construct a tree from
a given input and retrieve semantic rules and at-
tributes from associated grammar units.
Attribute evaluation begins by instantiating each
inherited attribute with values from the input and
then the remaining attributes are evaluated. This
process is incremental in the sense that new infor-
mation gained from previous evaluations might lead
to the discovery of additional information. When
all attributes remain unchanged, or there is a con-
flict detected in the input, the process terminates.
The generator then passes the enriched input to the
realization component.
Consider the following fragment of input from
Figure 3 that uses the CONJUNCTION template to
join a noun phrase and a pronoun.
</bodyText>
<equation confidence="0.7214145">
((template CONJUNCTION)
(first ((template NOUN-PHRASE)
(head &amp;quot;Jack&amp;quot;)
(np-type PROPER)
(gender MASCULINE) ))
(second ((template PRONOUN)) ))
</equation>
<bodyText confidence="0.946950307692308">
This fragment. is the subject of the sentence, there-
fore features such as person and number would be
required to enforce the subject-verb agreement of En-
glish. Figure 6 shows a dependency graph&apos; for this
The notation used in the dependency graph is the
low
The oval represents a template slot that k bound to an atomic
value. The rectangle denotes a slot that is bound to another
feature structure. The top text in a rectangle specifies a slot
name, and the bottom text is the name of a template assigned
IC this slot. A value with an underline means a default of the
above slot. The bold font represents a value yielded from
attribute evaluations.
</bodyText>
<page confidence="0.98723">
166
</page>
<figure confidence="0.697176">
NJUNCTION
</figure>
<figureCaption confidence="0.989905">
Figure 6: A Dependency Graph of the CONJUNCTION Template corresponding to the text &amp;quot;Jack and I&amp;quot;.
</figureCaption>
<figure confidence="0.998014476190476">
second
sentence person number gender definite sentence
I t
- - ...NOART
error
person number gender definite sentence
NO
seCT-tte pnce
NO
person numtter gender sentence
NO
Itirst
NOUN-PHRASE
defintte
PRONOUN
peC;opn nunC7Dber
&apos;Jade THIRD SINGULAR MASCULINE
dennrt7D C tYPe Comm) C;endet7)
NOART PERSONAL FIRST SINGULAR NEUTRAL
E.P-t&apos;ttlx
PROPER
</figure>
<bodyText confidence="0.949649730769231">
fragment. The dependencies are based on the se-
mantic rules given in Figure 7 (Section 6 describes
syntax of these rules.).
The semantic rules in Figure 7 give constraint
information for the CONJUNCTION template, the
NOUN-PHRASE template, and the PRONOUN template.
For the CONJUNCTION template, the grammar will:
a Use the sentence feature of the current tem-
plate (which is NO by default).
o Pass up the person feature found by compar-
ing the person features associated with the two
conjuncts (i.e., pass up second person whenever
the conjuncts combine either first person and
second or third person, or they combine second
person and third person; pass up third person if
both conjuncts use third person; otherwise pass
up nii);
a Constrain the number feature to be PLURAL,
the gender feature to be NEUTRAL, the definite
feature to be NOART, and the sentence feature
to the same as the sentence feature of the con-
juncts_
For the NOUN-PHRASE template, the grammar will
a Require this template to enforce the inherited
values of the definite, number, and np-type
feat ures.
</bodyText>
<listItem confidence="0.964355">
o Require the (embedded) DETERMINER template
enforce the number feature of the current tem-
plate.
• Pass up four features (definite, number, per-
</listItem>
<bodyText confidence="0.972448771428571">
son, and np-type) to any templates that use
this noun phrase. where the following con-
straints apply:
The definiteness feature that is passed is
YES whenever the current template has in-
herited YES for this value or there is a pos-
sessor or a determiner and one or them
passes up YES for this feature. (If there is
neither possessor nor determiner then the
grammar considers the np-type: if it is
COMMON, it uses NO (for indefinite) and if it
is PROPER, it uses NOART
The number feature passed is the value
passed from the determiner, if there is one,
or the value from the current template.
The person feature passed is the one from
the current template.
The up-type feature passed is COMMON if the
value of definite is NO and PROPER if the
value is NOART.
For the PRONOUN template, the grammar will:
G Pass up the person, number, and gender val-
ues from the current template (possibly using
default values), along with the constraint that
the string realized for it not be a sentence and
not be preceded by an article.
In-the example shown in Figure 6, inherited at-
tributes&apos; have been initialized to the associated val-
ues given in an input. If the input does not specify a
value for an inherited attribute, then the value nil
is used.
The attribute evaluation is depth-first, and re-
quires multiple traversals. Here, the NOUN-PHRASE
sub-tree is evaluated twice, as we discover that the
definite feature must be NOART. Since the PRONOUN
</bodyText>
<footnote confidence="0.7455975">
2 Inherited attributes are placed on the left side of each
node, Synthesized attributes are on the right.
</footnote>
<page confidence="0.980386">
167
</page>
<table confidence="0.999904289473684">
Template Name 1 Semantic Rules
CONJUNCTION ((this sentence) (this inh sentence))
((this syn person) (CASE (UNION (first syn person)
(second syn person)) OF
((first nil)
(second nil)
((first second) second)
((first third) second)
((second third) second)
(third third)) ))
((this syn number) PLURAL)
((this syn gender) NEUTRAL)
((this syn definite) NOART)
((this syn sentence) (UNION (first syn sentence) (second syn sentence)))
NOUN-PHRASE ((this definite) (this inh definite))
((this number) (this inh number))
((this np-type) (this inh np-type))
((determiner inh number) (this inh number))
((this syn definite) (IF (AND (NULL (this possessor))
(NULL (this determiner))) THEN
(UNION (this definite)
(CASE (this np-type) OF
((common NO)
(proper NOART))) )
ELSE
(UNION (this definite)
(possessor syn definite)
(determiner syn definite)) ))
((this syn number) (UNION (determiner syn number) (this number)) )
((this syn person) (this person))
((this syn np-type) (CASE (this definite) OF
((NO COMMON)
(NOART PROPER)) )) .
PRONOUN ((this syn person) (this person))
((this syn number) (this number))
((this syn gender) (this gender))
((this syn sentence) NO)
((this syn definite) NOART)
</table>
<figureCaption confidence="0.997735">
Figure 7: Semantic Rules of the CONJUNCTION, NOUN-PHRASE, and PRONOUN template.
</figureCaption>
<bodyText confidence="0.898627947368421">
template has no inherited attributes, a single evalua-
tion would he sufficient. The CONJUNCTION sub-tree
is also traversed twice because the sentence feature
is re-assigned once (from nil to NO).
Figure 8 shows the tree and dependencies, for the
fragment, &amp;quot;his sister&apos;s dog&amp;quot;. It shows how the defi-
niteness of a noun phrase is dependent on the ex-
istence of a. possessor. For example, if a posses-
sor (such as &amp;quot;his&amp;quot; or &amp;quot;Jack&apos;s&amp;quot;) is specified, a noun
phrase will not need an article.
Note that this feature structure can be generated
differently as &amp;quot;Jack&apos;s sister&apos;s dog&amp;quot;. her dog&amp;quot;. &amp;quot;the
dog of Jack&apos;s sister&amp;quot;. the dog of his sister&amp;quot;. and
&apos;the dog of hers&amp;quot;. While sonic of these variations
require further investigation to determine how to
transform a tree so that it reflects a new ordering
of constituents, some can be implemented using se-
mantic rules. For example,. -to-avoid-an -awkward
construction such as &amp;quot;Jack&apos;s sister&apos;s dog&amp;quot; in the son-
</bodyText>
<equation confidence="0.614063">
r
NP
cle,A4e . delirme
Crip-Eoe-) heact De■soft-&apos;) (e.orcte-r-) (.1-ael,rme-) LJTIn3minm
PPLOPEE NIA() SINCIL IL AFL MASCULINE !NO 1141&apos; YES
</equation>
<figureCaption confidence="0.780038">
Figure 8: A Dependency Graph of the NOUN-PHRASE
Template corresponding to the text -&amp;quot;his sister&apos;s
dog&amp;quot;.
</figureCaption>
<figure confidence="0.5705775">
// (defiride C-Ijorlde) prOnorNii-)
NOART FaimNE NO
p ossesay
NP
</figure>
<page confidence="0.990166">
168
</page>
<bodyText confidence="0.859217857142857">
tence &amp;quot;Jack and I want Jack&apos;s sister&apos;s dog to sunin.&amp;quot;,
in favor of his sister&apos;s dog&amp;quot;, without the application
having to request a pronoun explicitly, as in the ex-
ample shown above, we could add a rule to force
the pronominal feature of the inner most posses-
sor to be YES, whenever a (repeated) noun phrase is
a possessor of a possessor of the primary noun.
</bodyText>
<sectionHeader confidence="0.904186333333333" genericHeader="method">
5 The Use of the Generation Cap
Analysis to Resolve Conflicting
Information
</sectionHeader>
<bodyText confidence="0.988127818181818">
One side benefit of the use of attribute grammars
is that they can help resolve inconsistencies in the
input provided from an application. Previously, a
generation system might not be able to recognize
such conflicts, and therefore might generate a text
that is ungrammatical, or it might simply fail to
produce an output at all.
The following is an example input that has a
conflict; the values of the number feature in the
NOUN-PHRASE and PRONOUN templates are inconsis-
tent.
</bodyText>
<figure confidence="0.989128571428571">
((template NOUN-PHRASE)
(head &amp;quot;book&amp;quot;)
(number PLURAL)
(determiner ((template PRONOUN)
(type DEMONSTRATIVE)
(distance NEAR)
(number SINGULAR)) )
</figure>
<bodyText confidence="0.707636">
Executed literally, a generator would produce
the phrase &amp;quot;this books&amp;quot;, rather than &amp;quot;this book&amp;quot; or
&amp;quot;these books&amp;quot;. Figure 9 shows a dependency graph
corresponding to the above input.
</bodyText>
<figureCaption confidence="0.595595">
Figure 9: A Dependency Graph corresponding to
the text &amp;quot;this book- or &amp;quot;these books&amp;quot;.
</figureCaption>
<bodyText confidence="0.996705375">
With the use of an appropriate attribute gram-
mar, an anal■,-sis of this struc.oire would detect a con-
flict when the value SINGULAR -of-the-number fea-
ture propagates upward and conflicts %vith the value
PLURAL of the number feature of the NOUN-PHRASE
template. In this case, a generator can choose to
override one of the conflicting features and generate
a text from the revised input.
</bodyText>
<sectionHeader confidence="0.997395" genericHeader="method">
6 Implementation
</sectionHeader>
<bodyText confidence="0.998575764705883">
„Grammars._ in..a. .template-based. system _ differ suf-
ficiently from phrase-based systems so that tradi-
tional attribute grammars specifications cannot be
used without changes. In particular, grammars in
a template-based system are not restricted to syn-
tactic text structure as they are in phrase-based
systems, but may include either syntactic specifica-
tions, semantic specifications, or a mixture of both.
Therefore template-based grammars do not restrict
derivations on the right side of a production to some
specific non-terminals, as they would be in a phrase-
based grammar.
In our approach, a template is equivalent to the
non-terminal on the left side of a production. Tem-
plate slots are equivalent to terminals and non-
terminals on the right side depending on their value
at the time of generation. Slots that are bound to
a simple value are considered terminals, while those
that are bound to a feature structure are considered
non-terminals. The evaluation function of terminals
is actually a constant function whose return value is
the value to which the terminal has been bound.
We have defined a small language sufficient to
specify attribute grammars in a template as given
in Figure 10. Additional keywords are also defined.
The keyword this refers to the current template.
The keywords inh and syn indicate an inherited at-
tribute and a synthesized attribute, respectively.
We have implemented an attribute grammar-
based propagation analysis program in Lisp as
an extension to YAG. Some templates have been
augmented with semantic propagation rules. It
was not, necessary to define attributes for YAG&apos;s
template-based grammar because template slots al-
ready served as attributes. The program has been
able to identify missing information (using the de-
fined semantic propagation rules) and to reject in-
puts that have a conflict.
Other generation systems that intend to use an at-
tribute gramMar approach to enrich their partially
-
specified input will need to analyze the character-
istics of their grammar formalism. Basically. one
needs to identify the smallest unit of a grammar
(e.g., a category (cat) in FUF/SURGE), and then
define semantic rules similar to those presented in
this paper for each grammar unit. From a given
input, a generator should he able to pick semantic
rules associated with information provided in an in-
put. An -attribute .evaluation &apos;is then executed as
described.
</bodyText>
<figure confidence="0.906334555555555">
number number error
, •
lead
&amp;quot;back&amp;quot;
number
PRONOUN
number error
i-ILETr&apos;-robei
PLURAL
DEMONSTRATIVE NEAR
number&apos;)
SINGULAR
169
AttributeGrammar EvalRules
EvalRules &amp;quot;(&amp;quot; EvalRule EvalRules &amp;quot;)&amp;quot; I nil
EvalRule &amp;quot;(&amp;quot; Attribute Stmt &amp;quot;)&amp;quot;
Stmt Expr I CaseStmt I IfStmt
Expr ::- Attribute I constant I
</figure>
<reference confidence="0.950093066666667">
&amp;quot;0&amp;quot; &amp;quot;UNION&amp;quot; Stmt Stmt &amp;quot;)&amp;quot; I
&amp;quot;(&amp;quot; &amp;quot;TUrERSECTIBN&amp;quot;-Stmt &apos;Stmt
Attribute ::- inherited I synthesized
CaseStmt &amp;quot;(&amp;quot; &amp;quot;CASE&amp;quot; Expr &amp;quot;OF&amp;quot; Alters
Alters ::- &amp;quot;(&amp;quot; Alter Alters &amp;quot;)&amp;quot; 1 nil
Alter ::- &amp;quot;(&amp;quot; value result &amp;quot;)&amp;quot;
result ::- Expr
IfStmt &amp;quot;(&amp;quot; &amp;quot;IF&amp;quot; Cond &amp;quot;THEN&amp;quot; Stmt
&amp;quot;(&amp;quot; &amp;quot;IF&amp;quot; Cond &amp;quot;THEN&amp;quot; Stmt
&amp;quot;ELSE&amp;quot; Stmt &amp;quot;)&amp;quot;
Cond &amp;quot;(&amp;quot; &amp;quot;NULL&amp;quot; Expr &amp;quot;)&amp;quot; f
&amp;quot;(&amp;quot; &amp;quot;EQUAL&amp;quot; Expr Expr &amp;quot;)&amp;quot; I
&amp;quot;(&amp;quot; &amp;quot;NOT&amp;quot; Cond &amp;quot;)&amp;quot; I
&amp;quot;(&amp;quot; &amp;quot;AND&amp;quot; Cond Cond &amp;quot;)&amp;quot; I
&amp;quot;C&amp;quot; &amp;quot;OR&amp;quot; Cond Cond &amp;quot;)&amp;quot;
</reference>
<figureCaption confidence="0.9546695">
Figure 10: The Syntax of YAG&apos;s Attribute Gram-
mars Specification.
</figureCaption>
<sectionHeader confidence="0.989416" genericHeader="conclusions">
7 Conclusion
</sectionHeader>
<bodyText confidence="0.999988">
We have presented a new approach to enriching
under-specified representations of content to be
realized as text using attribute grammars with
semantic propagation rules. Our approach is not
intended to replace defaulting mechanisms used in
the current generation systems. Instead it improves
the quality of input to the generator for better
realization. Defaults are still used if the analysis
fails to discover useful information.
</bodyText>
<sectionHeader confidence="0.977191" genericHeader="acknowledgments">
Acknowledgement
</sectionHeader>
<bodyText confidence="0.9999415">
The authors are indebted to John T. Boyland for
his helpful comments and suggestions_
</bodyText>
<sectionHeader confidence="0.998384" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999527218181818">
Henk Alblas. 1991. Introduction to attribute gram-
mars. In Hulk Alblas and I3ofivoj Melichar, edi-
tors, Attribute Grammars, Applications and Sys-
tems, volume 545 of Lecture Notes in Computer
Science, pages 1-15. Springer-Verlag, New York--
Heidelberg-Berlin. June. Prague.
Stephan Busemann. 1996. Best-first surface realiza-
tion. In Donia Scott., editor. Proceedings of the
Eighth International Workshop an Natural Lan-
guage Generation. pages 101-110.
Songsak Channaruktd. 1999. NAG: A- Natural Lan-
guage Generator for Real-Time Systems. Mas-
ter&apos;s thesis, University of Wisconsin-Milwaukee,
December.
Michael Elhadad. 1992. Using argumentation to
control lexical choice: A functional unification-
based approach. Ph.D. thesis, Computer Science
Department, Columbia University.
Keven Knight and Vasileios Hatzivassiloglou. 1995.
TvvoAevel, many-paths generation. In.,Proceedings.
of ACL.
Donald E. Knuth. 1968. Semantics of context-
free languages. Mathematical Systems Theory,
2(2):127-145, June. Correction: Mathematical
Systems Theory 5, 1, pp. 95-96 (March 1971).
Benoit Lavoie and Owen Rambow. 1997. A fast
and portable realizer for text generation systems.
In Proceedings of the Fifth Conference on Ap-
plied Natural Language Processing, pages 263-268,
Washington.
Michael Levison and Gregory Lessard. 1990. Ap-
plication of attribute grammars to natural lan-
guage sentence generation. In Pierre Deransart
and Martin Jourdan, editors, Attribute Gram-
mars and their Applications (WA GA), volume
461 of Lecture Notes in Computer Science, pages
298-312. Springer-Verlag, New York-Heidelberg-
Berlin, September. Paris.
William C. Mann. 1983. An overview of the
Penman text generation system. In Proceedings
of the Third National Conference on Artificial
Intelligence (A A A 1-83,1, pages 261-265, Wash-
ington, DC, August 22-26,. Also appears as
USC/Information Sciences Institute Tech Report
RR-83-114.
Susan W. McRoy, Songsak Channarukul, and
Syed S. Ali. 1999. A Natural Language Gener-
ation Component for Dialog Systems. In Working
Notes of the AAAI Workshop on Mixed-Initiative
Intelligence, at the 1999 Meeting of the American
Association for Artificial Intelligence. Orlando,
FL,
Marie W. Meteer. 1990. The &amp;quot;Generation Gap- The
Problem of Expressibility in Text Planning. Phi&amp;quot;
thesis. University of Massachusetts.
</reference>
<page confidence="0.997445">
170
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.433820">
<title confidence="0.9995325">Enriching Partially-Specified Representations for Text Realization Using an Attribute Grammar *</title>
<author confidence="0.998962">Songsak Channarukul Susan W McRoy Syed S Ali</author>
<affiliation confidence="0.936903333333333">Natural,f,anpage..and,Knowledge:Representation_ftesearch Electrical Engineering and Computer Science University of Wisconsin-Milwaukee</affiliation>
<abstract confidence="0.982520111111111">We present a new approach to enriching underspecified representations of content to be realized as text. Our approach uses an attribute grammar to propagate missing information where needed in a tree that represents the text to be realized. This declaratively-specified grammar mediates between application-produced output and the input to a generation system and, as a consequence, can easily augment an existing generation system. Endapplications that use this approach can produce high quality text without a fine-grained specification of the text to be realized, thereby reducing the burden to the application. Additionally, representations used by the generator are compact, because values that can be constructed from the constraints encoded by the grammar will be propagated where necessary. This approach is more flexible than defaulting or making a statistically good choice because it can deal with long-distance dependencies (such as gaps and reflexive pronouns). Our approach differs from other approaches that use attribute grammars in that we use the grammar to enrich the representations of the content to be realized, rather than to generate the text itself. We illustrate the approach with examples from our template-based textrealizer, YAG.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<title>0&amp;quot; &amp;quot;UNION&amp;quot; Stmt Stmt &amp;quot;)&amp;quot; I &amp;quot;(&amp;quot; &amp;quot;TUrERSECTIBN&amp;quot;-Stmt &apos;Stmt Attribute ::- inherited I synthesized CaseStmt &amp;quot;(&amp;quot; &amp;quot;CASE&amp;quot; Expr &amp;quot;OF&amp;quot; Alters Alters ::- &amp;quot;(&amp;quot; Alter Alters &amp;quot;)&amp;quot; 1 nil Alter ::- &amp;quot;(&amp;quot; value result &amp;quot;)&amp;quot; result ::- Expr IfStmt &amp;quot;(&amp;quot; &amp;quot;IF&amp;quot; Cond &amp;quot;THEN&amp;quot;</title>
<publisher>Stmt</publisher>
<marker></marker>
<rawString>&amp;quot;0&amp;quot; &amp;quot;UNION&amp;quot; Stmt Stmt &amp;quot;)&amp;quot; I &amp;quot;(&amp;quot; &amp;quot;TUrERSECTIBN&amp;quot;-Stmt &apos;Stmt Attribute ::- inherited I synthesized CaseStmt &amp;quot;(&amp;quot; &amp;quot;CASE&amp;quot; Expr &amp;quot;OF&amp;quot; Alters Alters ::- &amp;quot;(&amp;quot; Alter Alters &amp;quot;)&amp;quot; 1 nil Alter ::- &amp;quot;(&amp;quot; value result &amp;quot;)&amp;quot; result ::- Expr IfStmt &amp;quot;(&amp;quot; &amp;quot;IF&amp;quot; Cond &amp;quot;THEN&amp;quot; Stmt</rawString>
</citation>
<citation valid="false">
<title>(&amp;quot; &amp;quot;IF&amp;quot; Cond &amp;quot;THEN&amp;quot; Stmt &amp;quot;ELSE&amp;quot; Stmt &amp;quot;)&amp;quot; Cond &amp;quot;(&amp;quot; &amp;quot;NULL&amp;quot; Expr &amp;quot;)&amp;quot; f &amp;quot;(&amp;quot; &amp;quot;EQUAL&amp;quot; Expr Expr &amp;quot;)&amp;quot; I &amp;quot;(&amp;quot; &amp;quot;NOT&amp;quot; Cond &amp;quot;)&amp;quot; I &amp;quot;(&amp;quot; &amp;quot;AND&amp;quot; Cond Cond &amp;quot;)&amp;quot; I &amp;quot;C&amp;quot; &amp;quot;OR&amp;quot; Cond Cond &amp;quot;)&amp;quot;</title>
<marker></marker>
<rawString>&amp;quot;(&amp;quot; &amp;quot;IF&amp;quot; Cond &amp;quot;THEN&amp;quot; Stmt &amp;quot;ELSE&amp;quot; Stmt &amp;quot;)&amp;quot; Cond &amp;quot;(&amp;quot; &amp;quot;NULL&amp;quot; Expr &amp;quot;)&amp;quot; f &amp;quot;(&amp;quot; &amp;quot;EQUAL&amp;quot; Expr Expr &amp;quot;)&amp;quot; I &amp;quot;(&amp;quot; &amp;quot;NOT&amp;quot; Cond &amp;quot;)&amp;quot; I &amp;quot;(&amp;quot; &amp;quot;AND&amp;quot; Cond Cond &amp;quot;)&amp;quot; I &amp;quot;C&amp;quot; &amp;quot;OR&amp;quot; Cond Cond &amp;quot;)&amp;quot;</rawString>
</citation>
<citation valid="true">
<authors>
<author>Henk Alblas</author>
</authors>
<title>Introduction to attribute grammars.</title>
<date>1991</date>
<booktitle>In Hulk Alblas and I3ofivoj Melichar, editors, Attribute Grammars, Applications and Systems,</booktitle>
<volume>545</volume>
<pages>1--15</pages>
<publisher>Springer-Verlag,</publisher>
<location>New York--Heidelberg-Berlin. June. Prague.</location>
<contexts>
<context position="10822" citStr="Alblas, 1991" startWordPosition="1616" endWordPosition="1617">zed Attributes. Inherited attributes propagate down a syntax tree whereas synthesized attributes propagate upward. A semantic rule specifies how to compute the value of an attribute from others. This specification implicitly defines dependencies among attributes in an attribute grammar, locally (within a production) and globally (among productions). Attribute Evaluation is the process of computing values for every attribute instance in the tree according to the semantic rules defined for each production. An example of an attribute grammar and its components is given in Figure 4 (adapted from (Alblas, 1991)). This attribute grammar consists of two nonterminals, two terminals, and three production rules. The inherited attributes of the non-terminal A are a and b. Its synthesized attributes are x and y. No attributes are assigned to the non-terminal S. nontermivals: S, A. terminals: s, t. start symbol: S. description of attributes: a, b: integer, inh of A; x, y: integer, syn of A; productions and semantic rules: 1) S -&gt; A. A.a := A.x 2) AO -&gt; Al s. Al.a := AO.a; Al.h := Al.y; AO.x := Al.x; AO.y := 1 3) A -&gt; t. A.y := A.a; Ax := A.b Figure 4: An Example Attribute Grammar. As mentioned earlier, sema</context>
</contexts>
<marker>Alblas, 1991</marker>
<rawString>Henk Alblas. 1991. Introduction to attribute grammars. In Hulk Alblas and I3ofivoj Melichar, editors, Attribute Grammars, Applications and Systems, volume 545 of Lecture Notes in Computer Science, pages 1-15. Springer-Verlag, New York--Heidelberg-Berlin. June. Prague.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stephan Busemann</author>
</authors>
<title>Best-first surface realization.</title>
<date>1996</date>
<booktitle>Proceedings of the Eighth International Workshop an Natural Language Generation.</booktitle>
<pages>101--110</pages>
<editor>In Donia Scott., editor.</editor>
<marker>Busemann, 1996</marker>
<rawString>Stephan Busemann. 1996. Best-first surface realization. In Donia Scott., editor. Proceedings of the Eighth International Workshop an Natural Language Generation. pages 101-110.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Songsak Channaruktd</author>
</authors>
<title>NAG: A- Natural Language Generator for Real-Time Systems. Master&apos;s thesis,</title>
<date>1999</date>
<institution>University of Wisconsin-Milwaukee,</institution>
<marker>Channaruktd, 1999</marker>
<rawString>Songsak Channaruktd. 1999. NAG: A- Natural Language Generator for Real-Time Systems. Master&apos;s thesis, University of Wisconsin-Milwaukee, December.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Elhadad</author>
</authors>
<title>Using argumentation to control lexical choice: A functional unificationbased approach.</title>
<date>1992</date>
<tech>Ph.D. thesis,</tech>
<institution>Computer Science Department, Columbia University.</institution>
<contexts>
<context position="2808" citStr="Elhadad, 1992" startWordPosition="428" endWordPosition="429">nce planner is then used to select an appropriate syntactic si ruc°This work was supported by.a gift from .Intel Corporation; and by the National Science Foundation. under grants IRI9701617 and 1RJ-9523666. ture for a given plan. Typically, neither a text planner nor a sentence planner is concerned with finegrained syntactic issues, such as whether the subject of the sentence is a singular or plural noun. Thus, it becomes the responsibility of a text realizer to infer the missing information and to generate the best possible text from a given input. Most generation systems (such as FUF/SURGE (Elhadad, 1992), Penman (Mann, 1983), RealPro (Lavoie and Rambow, 1997), TG/2 (Busemarm, 1996), and YAG (Channarukul, 1999; McRoy et al., 1999)) alleviate this problem by using defaulting, in which a grammar writer specifies a default for each syntactic constraint. This approach is inflexible and prone to errors, because there might not be one default that suits all applications or situations. Another approach that has been proposed is to fill in the missing information on the basis of word cooccurrence data collected from a large corpus of text (see Nitrogen (Knight and Hatzivassiloglou, 1995)). However, st</context>
</contexts>
<marker>Elhadad, 1992</marker>
<rawString>Michael Elhadad. 1992. Using argumentation to control lexical choice: A functional unificationbased approach. Ph.D. thesis, Computer Science Department, Columbia University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Keven Knight</author>
<author>Vasileios Hatzivassiloglou</author>
</authors>
<title>TvvoAevel, many-paths generation.</title>
<date>1995</date>
<journal>In.,Proceedings. of ACL.</journal>
<contexts>
<context position="3394" citStr="Knight and Hatzivassiloglou, 1995" startWordPosition="520" endWordPosition="523">ation systems (such as FUF/SURGE (Elhadad, 1992), Penman (Mann, 1983), RealPro (Lavoie and Rambow, 1997), TG/2 (Busemarm, 1996), and YAG (Channarukul, 1999; McRoy et al., 1999)) alleviate this problem by using defaulting, in which a grammar writer specifies a default for each syntactic constraint. This approach is inflexible and prone to errors, because there might not be one default that suits all applications or situations. Another approach that has been proposed is to fill in the missing information on the basis of word cooccurrence data collected from a large corpus of text (see Nitrogen (Knight and Hatzivassiloglou, 1995)). However, statistical approaches have difficulty when there are long-distance dependencies among constituents in a text. In this paper, we present a new approach to resolving the so-called generation gap that uses an Attribute Grammar (Knuth, 1968) to enrich partiallyspecified inputs to a realization system to produce high quality texts. Attribute Grammars are a declarative formalism for defining rules for attribute propagation (see Section 3). They have been used primarily for specifying the ,semantics of programming languages, although a few researchers have also used them to drive a text </context>
</contexts>
<marker>Knight, Hatzivassiloglou, 1995</marker>
<rawString>Keven Knight and Vasileios Hatzivassiloglou. 1995. TvvoAevel, many-paths generation. In.,Proceedings. of ACL.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Donald E Knuth</author>
</authors>
<title>Semantics of contextfree languages.</title>
<date>1968</date>
<journal>Correction: Mathematical Systems Theory</journal>
<booktitle>Mathematical Systems Theory,</booktitle>
<volume>5</volume>
<pages>2--2</pages>
<contexts>
<context position="3644" citStr="Knuth, 1968" startWordPosition="561" endWordPosition="562">each syntactic constraint. This approach is inflexible and prone to errors, because there might not be one default that suits all applications or situations. Another approach that has been proposed is to fill in the missing information on the basis of word cooccurrence data collected from a large corpus of text (see Nitrogen (Knight and Hatzivassiloglou, 1995)). However, statistical approaches have difficulty when there are long-distance dependencies among constituents in a text. In this paper, we present a new approach to resolving the so-called generation gap that uses an Attribute Grammar (Knuth, 1968) to enrich partiallyspecified inputs to a realization system to produce high quality texts. Attribute Grammars are a declarative formalism for defining rules for attribute propagation (see Section 3). They have been used primarily for specifying the ,semantics of programming languages, although a few researchers have also used them to drive a text generator (see (Levison and Lessard, 1990), for example). The main advantage of our approach is that it allows a generator to enjoy the computational efficiency of a templatebased realization system, while reducing the linguistic burden on an applica</context>
<context position="5463" citStr="Knuth, 1968" startWordPosition="818" endWordPosition="819">((template NOUN-PHRASE) (head &amp;quot;dog&amp;quot;) (definite NOART) (possessor ((template NOUN-PHRASE) (head &amp;quot;sister&amp;quot;) (gender FEMININE) (definite NOART) (possessor ((template NOUN-PHRASE) (head &amp;quot;Jack&amp;quot;) (np-type PROPER) (gender MASCULINE) (pronominal YES) (definite NOART)) ))))) (rear-circum ((template CLAUSE) (mood TO-INFINITIVE) (process-type MATERIAL) (process &amp;quot;swim&amp;quot;)) ) ) Figure 1: A Feature Structure for the Sentence &amp;quot;Jack and I want his sister&apos;s dog to swim.&amp;quot;. ison and Lessard extend a context-free grammar with attributes arid semantic rules similar to classical attribute grammars presented by Knuth (Knuth, 1968). Attributes in their system assist the realization by propagating information down a tree that specifies the complete syntactic structure of the output text. By contrast, our work employs attribute grammars, not to realize a text, but to perform a generation gap analysis prior to actual realization. We use both inherited and synthesized attributes (i.e., propagating information both down and up a tree) to share information and to determine appropriate values for any missing features. 2 An Overview of YAG YAG (Yet Another Generator) (Channarukul, 1999; McRoy et al., 1999) is a template-based t</context>
</contexts>
<marker>Knuth, 1968</marker>
<rawString>Donald E. Knuth. 1968. Semantics of contextfree languages. Mathematical Systems Theory, 2(2):127-145, June. Correction: Mathematical Systems Theory 5, 1, pp. 95-96 (March 1971).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Benoit Lavoie</author>
<author>Owen Rambow</author>
</authors>
<title>A fast and portable realizer for text generation systems.</title>
<date>1997</date>
<booktitle>In Proceedings of the Fifth Conference on Applied Natural Language Processing,</booktitle>
<pages>263--268</pages>
<location>Washington.</location>
<contexts>
<context position="2864" citStr="Lavoie and Rambow, 1997" startWordPosition="435" endWordPosition="438">ate syntactic si ruc°This work was supported by.a gift from .Intel Corporation; and by the National Science Foundation. under grants IRI9701617 and 1RJ-9523666. ture for a given plan. Typically, neither a text planner nor a sentence planner is concerned with finegrained syntactic issues, such as whether the subject of the sentence is a singular or plural noun. Thus, it becomes the responsibility of a text realizer to infer the missing information and to generate the best possible text from a given input. Most generation systems (such as FUF/SURGE (Elhadad, 1992), Penman (Mann, 1983), RealPro (Lavoie and Rambow, 1997), TG/2 (Busemarm, 1996), and YAG (Channarukul, 1999; McRoy et al., 1999)) alleviate this problem by using defaulting, in which a grammar writer specifies a default for each syntactic constraint. This approach is inflexible and prone to errors, because there might not be one default that suits all applications or situations. Another approach that has been proposed is to fill in the missing information on the basis of word cooccurrence data collected from a large corpus of text (see Nitrogen (Knight and Hatzivassiloglou, 1995)). However, statistical approaches have difficulty when there are long</context>
</contexts>
<marker>Lavoie, Rambow, 1997</marker>
<rawString>Benoit Lavoie and Owen Rambow. 1997. A fast and portable realizer for text generation systems. In Proceedings of the Fifth Conference on Applied Natural Language Processing, pages 263-268, Washington.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Levison</author>
<author>Gregory Lessard</author>
</authors>
<title>Application of attribute grammars to natural language sentence generation.</title>
<date>1990</date>
<booktitle>In Pierre Deransart and</booktitle>
<volume>461</volume>
<pages>298--312</pages>
<editor>Martin Jourdan, editors,</editor>
<publisher>Springer-Verlag,</publisher>
<location>New York-HeidelbergBerlin, September. Paris.</location>
<contexts>
<context position="4036" citStr="Levison and Lessard, 1990" startWordPosition="620" endWordPosition="623">istical approaches have difficulty when there are long-distance dependencies among constituents in a text. In this paper, we present a new approach to resolving the so-called generation gap that uses an Attribute Grammar (Knuth, 1968) to enrich partiallyspecified inputs to a realization system to produce high quality texts. Attribute Grammars are a declarative formalism for defining rules for attribute propagation (see Section 3). They have been used primarily for specifying the ,semantics of programming languages, although a few researchers have also used them to drive a text generator (see (Levison and Lessard, 1990), for example). The main advantage of our approach is that it allows a generator to enjoy the computational efficiency of a templatebased realization system, while reducing the linguistic burden on an application and increasing the quality of the generated texts. Our work differs from previous uses of attribute grammars in natural language generation. which are similar to Levison and Lessard (Levison and Lessard, 1990) in that they apply attribute grammars directly to text realization. For example, Lev163 ((template CLAUSE) (process-type MENTAL) (process &amp;quot;vent&amp;quot;) (processor ((template NOUN-PHRA</context>
</contexts>
<marker>Levison, Lessard, 1990</marker>
<rawString>Michael Levison and Gregory Lessard. 1990. Application of attribute grammars to natural language sentence generation. In Pierre Deransart and Martin Jourdan, editors, Attribute Grammars and their Applications (WA GA), volume 461 of Lecture Notes in Computer Science, pages 298-312. Springer-Verlag, New York-HeidelbergBerlin, September. Paris.</rawString>
</citation>
<citation valid="true">
<authors>
<author>William C Mann</author>
</authors>
<title>An overview of the Penman text generation system.</title>
<date>1983</date>
<booktitle>In Proceedings of the Third National Conference on Artificial Intelligence (A A A 1-83,1,</booktitle>
<tech>Tech Report RR-83-114.</tech>
<pages>261--265</pages>
<location>Washington, DC,</location>
<contexts>
<context position="2829" citStr="Mann, 1983" startWordPosition="431" endWordPosition="432"> to select an appropriate syntactic si ruc°This work was supported by.a gift from .Intel Corporation; and by the National Science Foundation. under grants IRI9701617 and 1RJ-9523666. ture for a given plan. Typically, neither a text planner nor a sentence planner is concerned with finegrained syntactic issues, such as whether the subject of the sentence is a singular or plural noun. Thus, it becomes the responsibility of a text realizer to infer the missing information and to generate the best possible text from a given input. Most generation systems (such as FUF/SURGE (Elhadad, 1992), Penman (Mann, 1983), RealPro (Lavoie and Rambow, 1997), TG/2 (Busemarm, 1996), and YAG (Channarukul, 1999; McRoy et al., 1999)) alleviate this problem by using defaulting, in which a grammar writer specifies a default for each syntactic constraint. This approach is inflexible and prone to errors, because there might not be one default that suits all applications or situations. Another approach that has been proposed is to fill in the missing information on the basis of word cooccurrence data collected from a large corpus of text (see Nitrogen (Knight and Hatzivassiloglou, 1995)). However, statistical approaches </context>
</contexts>
<marker>Mann, 1983</marker>
<rawString>William C. Mann. 1983. An overview of the Penman text generation system. In Proceedings of the Third National Conference on Artificial Intelligence (A A A 1-83,1, pages 261-265, Washington, DC, August 22-26,. Also appears as USC/Information Sciences Institute Tech Report RR-83-114.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Susan W McRoy</author>
<author>Songsak Channarukul</author>
<author>Syed S Ali</author>
</authors>
<title>A Natural Language Generation Component for Dialog Systems.</title>
<date>1999</date>
<booktitle>In Working Notes of the AAAI Workshop on Mixed-Initiative Intelligence, at the</booktitle>
<location>Orlando, FL,</location>
<contexts>
<context position="2936" citStr="McRoy et al., 1999" startWordPosition="446" endWordPosition="449">n; and by the National Science Foundation. under grants IRI9701617 and 1RJ-9523666. ture for a given plan. Typically, neither a text planner nor a sentence planner is concerned with finegrained syntactic issues, such as whether the subject of the sentence is a singular or plural noun. Thus, it becomes the responsibility of a text realizer to infer the missing information and to generate the best possible text from a given input. Most generation systems (such as FUF/SURGE (Elhadad, 1992), Penman (Mann, 1983), RealPro (Lavoie and Rambow, 1997), TG/2 (Busemarm, 1996), and YAG (Channarukul, 1999; McRoy et al., 1999)) alleviate this problem by using defaulting, in which a grammar writer specifies a default for each syntactic constraint. This approach is inflexible and prone to errors, because there might not be one default that suits all applications or situations. Another approach that has been proposed is to fill in the missing information on the basis of word cooccurrence data collected from a large corpus of text (see Nitrogen (Knight and Hatzivassiloglou, 1995)). However, statistical approaches have difficulty when there are long-distance dependencies among constituents in a text. In this paper, we p</context>
<context position="6041" citStr="McRoy et al., 1999" startWordPosition="908" endWordPosition="911">grammars presented by Knuth (Knuth, 1968). Attributes in their system assist the realization by propagating information down a tree that specifies the complete syntactic structure of the output text. By contrast, our work employs attribute grammars, not to realize a text, but to perform a generation gap analysis prior to actual realization. We use both inherited and synthesized attributes (i.e., propagating information both down and up a tree) to share information and to determine appropriate values for any missing features. 2 An Overview of YAG YAG (Yet Another Generator) (Channarukul, 1999; McRoy et al., 1999) is a template-based textrealization system that generates text in real-time. YAG uses templates to express text structures corresponding to fragments of the target language. Templates in YAG are declarative and modular. Complex texts can be generated by embedding templates inside other templates. Values for the templates are provided by an application: inputs can include either a conceptual representation of content, or a feature structure, When an input is only partially specified, defaults defined in a template will be applied. Figure 1 shows an example of YAG&apos;s feature-structure based inpu</context>
</contexts>
<marker>McRoy, Channarukul, Ali, 1999</marker>
<rawString>Susan W. McRoy, Songsak Channarukul, and Syed S. Ali. 1999. A Natural Language Generation Component for Dialog Systems. In Working Notes of the AAAI Workshop on Mixed-Initiative Intelligence, at the 1999 Meeting of the American Association for Artificial Intelligence. Orlando, FL,</rawString>
</citation>
<citation valid="true">
<authors>
<author>Marie W Meteer</author>
</authors>
<title>The &amp;quot;Generation Gap- The Problem of Expressibility in Text Planning. Phi&amp;quot; thesis.</title>
<date>1990</date>
<institution>University of Massachusetts.</institution>
<contexts>
<context position="1976" citStr="Meteer, 1990" startWordPosition="289" endWordPosition="290">ffers from other approaches that use attribute grammars in that we use the grammar to enrich the representations of the content to be realized, rather than to generate the text itself. We illustrate the approach with examples from our template-based textrealizer, YAG. 1 Introduction Typically, a text realization system requires a great deal of syntactic information from an application in order to generate a high quality text; however, an application might not have this information (unless it has been built with text generation in mind). This problem has been referred to as the Generation Gap (Meteer, 1990). Meteer first identified the generation gap problem as arising at the text planning stage. A text planner must decide what content needs to be expressed and creates a corresponding text plan for generating it. A sentence planner is then used to select an appropriate syntactic si ruc°This work was supported by.a gift from .Intel Corporation; and by the National Science Foundation. under grants IRI9701617 and 1RJ-9523666. ture for a given plan. Typically, neither a text planner nor a sentence planner is concerned with finegrained syntactic issues, such as whether the subject of the sentence is </context>
</contexts>
<marker>Meteer, 1990</marker>
<rawString>Marie W. Meteer. 1990. The &amp;quot;Generation Gap- The Problem of Expressibility in Text Planning. Phi&amp;quot; thesis. University of Massachusetts.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>