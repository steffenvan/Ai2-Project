<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000008">
<title confidence="0.860429">
Parametric Types for Typed Attribute-Value Logic
</title>
<author confidence="0.790141">
Gerald Penn
</author>
<affiliation confidence="0.601139">
Universitat Tubingen
</affiliation>
<address confidence="0.754843666666667">
1{1. Wilhelmstr. 113
72074 Tuebingen
Germany
</address>
<email confidence="0.990289">
gpenn@sfs.nphil.uni-tuebingen.de
</email>
<sectionHeader confidence="0.994509" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999778739130435">
Parametric polymorphism has been combined
with inclusional polymorphism to provide nat-
ural type systems for Prolog (DH88), HiLog
(YFS92), and constraint resolution languages
(Smo89), and, in linguistics, by HPSG-like
grammars to classify lists and sets of linguistic
objects (PS94), and by phonologists in represen-
tations of hierarchical structure (Kle91). This
paper summarizes the incorporation of para-
metric types into the typed attribute-value logic
of (Car92), thus providing a natural extension
to the type system for ALE (CP96). Following
(Car92), the concern here is not with models of
feature terms themselves, but with how to com-
pute with parametric types, and what different
kinds of information one can represent relative
to a signature with parametric types, than rel-
ative to a signature without them. This en-
quiry has yielded a more flexible interpretation
of parametric types with several specific proper-
ties necessary to conform to their current usage
by linguists and implementors who work with
feature-based formalisms.
</bodyText>
<sectionHeader confidence="0.984601" genericHeader="keywords">
1 Motivation
</sectionHeader>
<bodyText confidence="0.999925913043478">
Linguists who avail themselves of attribute-
value logic normally choose whether to encode
information with subtypes or features on the
aesthetic basis of what seems intuitively to
capture their generalizations better. Linguists
working in LFG typically use one implicit type
for objects that bear features, and other types
(atoms) for only featureless objects. In HPSG,
the situation is less clear, both historically (se-
mantic relations, for example, used to be val-
ues of a RELN attribute, and are now sub-
types of a more general semantic type), and
synchronically (verbs, for example, are identi-
fied as (un)inverted and (non-)auxiliaries by two
boolean-valued features, AUX and INV, whereas
their form, e.g., finite, infinitive, gerund, is iden-
tified by a subtype of a single vforrn type). That
it makes, or at least should make, no difference
from a formal or implementational point of view
which encoding is used has been argued else-
where (Mos96; Pen-f).
HPSG&apos;s type system also includes parametric
types, e.g., Figure 1, from (PS94). In contrast
</bodyText>
<figure confidence="0.962459">
word phrase çlist nelistql,
HEAD:A
TAIL: list(X)
szg )t(X)
1
</figure>
<figureCaption confidence="0.996651">
Figure 1: A fragment of the HPSG type signa-
ture.
</figureCaption>
<bodyText confidence="0.975713227272727">
to the relative expressive potential of normal
typing and features, the expressive potential of
parametric types is not at all understood. In
fact, parametric types have never been formal-
ized in a feature logic or in a manner general
enough to capture their use in HPSG parsing so
that a comparison could even be drawn. This
paper summarizes such a formalization,1 based
on the typed attribute-value logic of (Car92).
This logic is distinguished by its strong inter-
pretation of appropriateness, a set of condi-
tions that tell us which features an object of
a given type can have, and which types a fea-
ture&apos;s value can have. Its interpretation, total
well-typedness, says that every feature structure
must have an appropriate value for all and only
the appropriate features of its type. Previous
approaches have required that every parameter
of a subtype should be a parameter of all of its
supertypes, and vice versa; thus, it would not be
&apos;The full version of this paper presents a denotational
semantics of the logic described here.
</bodyText>
<page confidence="0.994223">
1027
</page>
<bodyText confidence="0.999966652173913">
possible to encode Figure 1 because I. E /ist(X),
and if .1 were parametric, then all other types
would be.2 The present one eliminates this re-
striction (Section 2) by requiring the existence
of a simple most general type (which (Car92)&apos;s
logic requires anyway), which is then used dur-
ing type-checking and inferencing to interpret
new parameters. All previous approaches deal
only with fixed-arity terms; and none but one
uses a feature logic, with the one, CUF (Dor92),
being an implementation that permits paramet-
ric lists only as a special case. The present ap-
proach (Section 4) provides a generalization of
appropriateness that permits both unrestricted
parametricity and incremental feature introduc-
tion.
In contrast to the other encoding trade-
off, the use of parametric types in HPSG lin-
guistics exhibits almost no variation. They
are used almost exclusively for encoding lists
(and, unconvincingly, sets), either with type
arguments as they are posited in (PS94), or
with general description-level arguments, e.g.,
/ist(LocAL:cAT:HEAD:verb), the latter possibly
arising out of the erroneous belief that para-
metric types are just &amp;quot;macro&amp;quot; descriptions for
lists. Even in the former case, however, para-
metric types have as wide of a range of poten-
tial application to HPSG as simple types and
features do; and there is no reason why they
cannot be used as prolifically once they are un-
derstood. To use an earlier example, auxiliary,
inverted, and verb_forin could all be parameters
of a parametric type, verb. In fact, parametri-
cally typed encodings yield more compact spec-
ifications than simply typed encodings because
they can encode products of information in their
parameters, like features. Unlike features, how-
ever, they can lend their parameters to appro-
priateness restrictions, thus refining the feature
structures generated by the signature to a closer
approximation of what is actually required in
the grammar theory itself.
It is possible, however, to regard paramet-
ric type signatures3 as a shorthand for non-
parametric signatures. The interpretation of
</bodyText>
<footnote confidence="0.9159192">
2In this paper, the most general type will be called
1.
3By &amp;quot;signature,&amp;quot; I refer to a partial order of types plus
feature appropriateness declarations. The partial order
itself, I shall refer to as a &amp;quot;type (inheritance) hierarchy.&amp;quot;
</footnote>
<bodyText confidence="0.999841">
parametric type hierarchies is introduced in Sec-
tion 3 by way of establishing equivalent, infinite
non-parametric counterparts. Section 5 consid-
ers whether there are any finite counterparts,
i.e., whether in actual practice parametric sig-
natures are only as expressive as non-parametric
ones, and gives a qualified &amp;quot;yes.&amp;quot;
In spite of this qualification, there is an easy
way to compute with parametric types directly
in an implementation, as described in Section 6.
The two most common previous approaches
have been to use the most general instance of a
parametric type, e.g. nelist(±) without its ap-
propriateness, or manually to &amp;quot;unfold&amp;quot; a para-
metric type into a non-parametric sub-hierarchy
that suffices for a fixed grammar (e.g. Figure 2).
The former does not suffice even for fixed gram-
</bodyText>
<equation confidence="0.555293333333333">
eli ne ist_syn m nelis _qua ts neli-t_phon
list_syn elist
list
</equation>
<figureCaption confidence="0.996692">
Figure 2: A manually unfolded sub-hierarchy.
</figureCaption>
<bodyText confidence="0.9838994">
mars because it simply disables type checking
on feature values. The latter is error-prone, a
nuisance, and subject to change with the gram-
mar. As it happens, there is an automatic way
to perform this unfolding.
</bodyText>
<sectionHeader confidence="0.843538" genericHeader="introduction">
2 Parametric Type Hierarchies
</sectionHeader>
<bodyText confidence="0.985065095238095">
Parametric types are not types. They are func-
tions that provide access or a means of reference
to a set of types (their image) by means of ar-
gument types, or &amp;quot;parameters&amp;quot; (their domain).
Figure 1 has only unary functions; but in gen-
eral, parametric types can be n-ary functions
over n-tuples of types.4 This means that hier-
4In this paper, &amp;quot;parametric type&amp;quot; will refer to such a
function, written as the name of the function, followed
by the appropriate number of &amp;quot;type variables,&amp;quot; variables
that range over some set of types, in parentheses, e.g.
list(X). &amp;quot;Type&amp;quot; will refer to both &amp;quot;simple types,&amp;quot; such as
1 or elist; and &amp;quot;ground instances&amp;quot; of parametric types,
i.e. types in the image of a parametric type function,
written as the name of the function followed by the ap-
propriate number of actual type parameters in paren-
theses, such as list(1), set(psoa) or list(set(J_)). I will
use letters t, u, and v to indicate types; capital letters
to indicate type variables; capitalized words to indicate
feature names; p, q, and r for names of parametric types;
and g to indicate ground instances of parametric types,
</bodyText>
<page confidence="0.973585">
1028
</page>
<bodyText confidence="0.99935075">
archies that use parametric types are not &amp;quot;type&amp;quot;
hierarchies, since they express a relationship be-
tween functions (we can regard simple types as
nullary parametric types):
</bodyText>
<listItem confidence="0.957703583333333">
Definition 1: A parametric (type) hierarchy is
a finite meet semilattice, (P,Cp), plus a partial
argument assignment function, ap :PxPx
Nat —+ Nat U {0}, in which:
• P consists of (simple and) parametric
types, (i.e. no ground instances of para-
metric types), including the simple most
general type, 1,
• For p,q E P, ap(p,q,i), written a(i), is
defined if p Ep q and 1 &lt; i &lt; arity(p),
and
• 0 &lt; al,(i) &lt;m, when it exists.
</listItem>
<bodyText confidence="0.999506769230769">
Meet semilatticehood, a requirement of
(Car92)&apos;s logic as well, allows us to talk about
unification, because we have a unique most-
general unifier for every unifiable pair of types.
The argument assignment function encodes the
identification of parameters between a paramet-
ric type and its parametric subtype. The num-
ber, n, refers to the nth parameter of a paramet-
ric type, with 0 referring to a parameter that
has been dropped. In practice, this is normally
expressed by the names given to type variables.
In the parametric type hierarchy of Figure 1,
list and nelist share the same variable, X, be-
</bodyText>
<equation confidence="0.659852625">
cause aneust(1) is 1. If an.eust(1) = 0, then nelist
list tut
would use a different variable name. As a more
complicated example, in Figure 3, 4(1) = 1,
d(X Y Z)
,,,,&amp;quot;-.‹..
b (X, 44...2.1,1..e
1
</equation>
<figureCaption confidence="0.9874425">
Figure 3: A subtype that inherits type variables
from more than one supertype.
</figureCaption>
<bodyText confidence="0.9244435">
41(2) = 3, ag(2) = 2, ag(1) = 0, and al and ae
are undefined (f) for any pair in P x Nat.
</bodyText>
<sectionHeader confidence="0.992597" genericHeader="method">
3 Induced Type Hierarchies
</sectionHeader>
<bodyText confidence="0.980115133333333">
The relationship expressed between two func-
tions by Cp, informally, is one between their im-
age sets under their domains,5 while each image
where the arguments do not need to be expressed.
50ne can restrict these domains with &amp;quot;parametric re-
strictions,&amp;quot; a parallel to appropriateness restrictions on
set internally preserves the subsumption order-
ing of its domain. It is, thus, possible to think
of a parametric type hierarchy as &amp;quot;inducing&amp;quot; a
non-parametric type hierarchy, populated with
the ground instances of its parametric types,
that obeys both of these relationships.
Definition 2: Given parametric type hier-
archy, (P, gp, a), the induced (type) hierarchy,
(I(P), g/), is defined such that:
</bodyText>
<listItem confidence="0.924314">
• I(P) is the smallest set, I, such that, for
every parametric type, p(Xi, • • . , Xn) E
P, and for every tuple, (t1...tn)E.In,
Atl, • • • , tn)EI.
• p(ti, • • • ,tn) _C/ q(Ui, • • . , Um) iff p Cp q,
and, for all 1&lt;i&lt;n, either a(i) = 0 or ti gi
u4(.0.
</listItem>
<bodyText confidence="0.999872428571429">
It can easily be shown that (I(P), gr) is a par-
tial order with a least element, namely 1, the
least element of P. Note that /(P) also contains
all of the simple types of P. In the case where
giandg2 are simple, gi gi g, if gi cp g2.
Figure 4 shows a fragment of the type hierar-
chy induced by Figure 1. If list and nelist had
</bodyText>
<equation confidence="0.979504375">
nelist(woczk„peli t(phrase)
Inelis (sign
.,,neilist(list(1))
nel st(1) . .
(nelist4))
list( rd (phrase) list(list(.1)). . .
list sign,L,
list(L)
</equation>
<figureCaption confidence="0.993498">
Figure 4: Fragment induced by Figure 1.
</figureCaption>
<bodyText confidence="0.999640333333333">
not shared the same type variable (aZiti8t(1) =
0), then it would have induced the type hier-
archy in Figure 5. In the hierarchy induced
</bodyText>
<equation confidence="0.998112">
nelist(wornelist(phrase) :
nelist(sigRL,nelist(list(iL))
list word)\,list(Mrase) .
list(&apos;siglist(list(1))
list(1)
</equation>
<figureCaption confidence="0.997909">
Figure 5: Another possible induced hierarchy.
</figureCaption>
<bodyText confidence="0.75605325">
feature values. This abstract assumes that these domains
are always the set of all types in the signature. This is
the most expressive case of parametric types, and the
worst case, computationally.
</bodyText>
<page confidence="0.989718">
1029
</page>
<bodyText confidence="0.998512892857143">
by Figure 3, b(e,e) subsumes types d(e,Y,e),
for any type Y, for example d(e,c(e,e),e),
or d(e,b(1,e),e), but not d(c(_L,e),e,e), since
egic(1, e). Also, for any types, W, X, and Z,
c(W,e) subsumes d(X,e,Z).
The present approach permits parametric
types in the type signature, but only ground
instances in a grammar relative to that signa-
ture. If one must refer to &amp;quot;some list&amp;quot; or &amp;quot;every
list&amp;quot; within a grammar, for instance, one may
use list(±), while still retaining groundedness.
An alternative to this approach would be to at-
tempt to cope with type variable parameters
directly within descriptions. From a process-
ing perspective, this is problematic when clos-
ing such descriptions under total well-typing,
as observed in (Car92). The most general sat-
isfier of the description, /ist(X)A(HEAD:HEAD
= TAIL:HEAD), for example, is an infinite fea-
ture structure of the infinitely parametric type,
nelist(nelist(... because X must be bound to
nelist(X).
For which P does it make sense to talk about
unification in I(P), that is, when is I(P) a meet
semilattice? We can generalize the usual notion
of coherence from programming languages, so
that a subtype can add, and in certain cases
drop, parameters with respect to a supertype:
</bodyText>
<construct confidence="0.724479666666667">
Definition 3: (P,Cp,ap) is semi-coherent if,
for all p,q E P such that p Cp q, all 1 &lt; i &lt;
arity(p), 1 &lt; j arity(q):
</construct>
<listItem confidence="0.9492985">
• a( i)
• either a(i) = 0 or for every chain, p
</listItem>
<equation confidence="0.792713666666667">
P1 EP P2 P • • • EP pn = q, a(i) =
aPn (aPn-1( aP2(i) )) and
pn-i Pn-2 • &amp;quot; pi • • • ,
</equation>
<listItem confidence="0.9973494">
• If pUpq,j., then for all i and j for which there
is a k &gt; 1 such that af,uPq(i) = aVPq(j)
k, the set, {rip Up q Cp r and (4(i) = 0 or
a(j) = 0)} is empty or has a least element
(with respect to Ep).
</listItem>
<equation confidence="0.935520888888889">
Theorem 1: If (P,Cp,ap) is semi-coherent,
then (I(P),CI) is a meet semilattice. In
particular, p(ti, • • • , tn) ur q(ui, • • • ,um) =
r (vi, , vs), where p Up q = r, and, for all
1&lt;k&lt;s,
ti Ul ui if there exist i and j such that
(i) = k and a(j) = k
vk = ti if such an i, but no such j
ui if such a j, but no such i
</equation>
<bodyText confidence="0.996850666666667">
if no such i or j.
So p(ti, , tn) q(ui, , un,)t if p Up qt, or
there exist i, j, and k &gt; 1 such that 0) =
a(j) = k, but ti U/ u3t.6
In the induced hierarchy of Figure 3, for ex-
ample, b(e, _L) U/ b(_L, e) = b(e, e); b(e, e) Ur
c(1) = d(e, _L, e); and b(e, e) and b(c(_L), e) are
not unifiable, as e and c(I) are not unifiable.
The first two conditions of semi-coherence en-
sure that ap, taken as a relation between pairs
of pairs of types and natural numbers, is an or-
der induced by the order, Ep, where it is not,
taken as a function, zero. The third ensures that
joins are preserved even when a parameter is
dropped (ap = 0). Note that joins in an induced
hierarchy do not always correspond to joins in
a parametric hierarchy. In those places where
ap = 0, types can unify without a correspond-
ing unification in their parameters. Such is the
case in Figure 5, where every instance of list(X)
ultimately subsumes nelist(±). One may also
note that induced hierarchies can have not only
deep infinity, where there exist infinitely long
subsumption chains, but broad infinity, where
certain types can have infinite supertype (but
never subtype) branching factors, as in the case
of nelist(1) or, in Figure 1, elist.
</bodyText>
<sectionHeader confidence="0.996138" genericHeader="method">
4 Appropriateness
</sectionHeader>
<bodyText confidence="0.902753555555555">
So far, we have formally considered only type
hierarchies, and no appropriateness. Appropri-
ateness constitutes an integral part of a para-
metric type signature&apos;s expressive power, be-
cause the scope of its type variables extends to
include it.
Definition 4: A parametric (type) signature is
a parametric hierarchy, (P,Cp,ap), along with
finite set of features, Featp, and a partial (para-
</bodyText>
<equation confidence="0.4607562">
metric) appropriateness function, Appropp :
Featp x P —&gt; Q, where Q = UnE NatQn, and
each Qn is the smallest set satisfying the equa-
tion, Qn = {1,... ,n} U ,qk)lp E P ar-
ity k, E Qn}, such that:
</equation>
<footnote confidence="0.932763">
6The proofs of these theorems can be found in the full
version of this paper.
</footnote>
<page confidence="0.988371">
1030
</page>
<listItem confidence="0.962876733333333">
1. (Feature Introduction) For every feature
I E Featp, there is a most general
parametric type Intro(f) E P such that
Appropp(f, , Intro(f)) is defined
2. (Upward Closure / Right Monotonicity)
For any p, q E F, if Appropp(f,p) is de-
fined and p Cp q, then Appropp(f,q)
is also defined and Appropp(f,p) CQ
Appropp(f, , q), where EQ is defined as
EI(P) with natural numbers interpreted
as universally quantified variables (e.g.
a(1) b(1) iff Vx E I(P).a(x) Ci(p) b(x))
3. (Parameter Binding) For every p E P of ar-
ity n, for every f E Featp, if Appropp(f,p)
is defined, then Appropp(f,p) E Q.
</listItem>
<bodyText confidence="0.999715511111111">
Appropp maps a feature and the parametric
type for which it is appropriate to its value re-
striction on that parametric type. The first two
conditions are the usual conditions on (Car92)&apos;s
appropriateness. The third says that the nat-
ural numbers in its image refer, by position,
to the parametric variables of the appropriate
parametric type — we can use one of these
parameters wherever we would normally use a
type. Notice that ground instances of para-
metric types are permitted as value restrictions,
as are instances of parametric types whose pa-
rameters are bound to these parametric vari-
ables, as are the parametric variables them-
selves. The first is used in HPSG for fea-
tures such as SUBCAT, whose value must be
list(synsem); whereas the second and third
are used in the appropriateness specification for
nelist(X) in Figure 1. The use of parameters
in appropriateness restrictions is what conveys
the impression that ground instances of lists or
other parametric types are more related to their
parameter types than just in name.
It is also what prevents us from treating in-
stances of parametric types in descriptions as
instantiations of macro descriptions. These pu-
tative &amp;quot;macros&amp;quot; would be, in many cases, equiv-
alent only to infinite descriptions without such
macros, and thus would extend the power of
the description language beyond the limits of
HPSG&apos;s own logic and model theory. Lists in
HPSG would be one such case, moreover, as
they place typing requirements on every element
of lists of unbounded length. Ground instances
of parametric types are also routinely used in
appropriate value restrictions, whose extension
to arbitrary descriptions would substantially ex-
tend the power of appropriateness as well. This
alternative is considered further in the full ver-
sion of this paper.
A parametric signature induces a type hier-
archy as defined above, along with the appro-
priateness conditions on its ground instances,
determined by the substitution of actual param-
eters for natural numbers. Thus:
</bodyText>
<listItem confidence="0.431515">
Theorem 2: If Appropp satisfies properties
(1)-(3) in Definition 4, then Appropf(p) satisfies
properties (1) and (2).
</listItem>
<sectionHeader confidence="0.948477" genericHeader="method">
5 Signature Subsumption
</sectionHeader>
<bodyText confidence="0.986034805555556">
Now that parametric type signatures have been
formalized, one can ask whether parametric
types really add something to the expressive
power of typed attribute-value logic. There are
at least two ways in which to formalize that
question:
Definition 5: Two type signatures, P and Q,
are equivalent (P s Q) if there exists an order-
isomorphism (w.r.t. subsumption) between the
abstract totally well-typed feature structures of
P and those of Q.
Abstract totally well-typed feature structures
are the &amp;quot;information states&amp;quot; generated by sig-
natures. Formally, as (Car92) shows, they can
either be thought of as equivalence classes of
feature structures modulo alphabetic variants,
or as pairs of a type assignment function on
feature paths and a path equivalence relation.
In either case, they are effectively feature struc-
tures without their &amp;quot;nodes,&amp;quot; which only bear in-
formation insofar as they have a type and serve
as the focus of potential instances of structure
sharing among feature path, where the traversal
of two different paths from the same node leads
to the same feature structure.
If, for every parametric signature P, there is
a finite non-parametric N such that P g N,
then parametric signatures add no expressive
power at all — their feature structures are
just those of some non-parametric signatures
painted a different color. This is still an open
question. There is, however, a weaker but still
relevant reading:
Definition 6: Type signature, P, subsumes
signature Q (P Cs Q) if there exists an injec-
tion, f, from the abstract totally well-typed fea-
</bodyText>
<page confidence="0.988396">
1031
</page>
<bodyText confidence="0.987193">
ture structures of P to those of Q, such that:
</bodyText>
<listItem confidence="0.859510333333333">
• if F1 UAT(p) F2f, then f (FOUAT(Q) f(F2)t,
• otherwise, both exist and f (FiLJ AT(p)F2) =
f (F1) UAT(Q) f (F2)•
</listItem>
<bodyText confidence="0.961245918367347">
If for every parametric P, there is a finite
non-parametric N such that P Cs N, then it
is possible to embed problems (specifically, uni-
fications) that we wish to solve from P into N,
solve them, and then map the answers back to
P. In this reading, linguist users who want to
think about their grammars with P must accept
no non-parametric imitations because N may
not have exactly the same structure of informa-
tion states; but an implementor of a feature-
based NLP system, for example, could secretly
perform all of the work for those grammars in
N, and no one would ever notice.
Under this reading, many parametrically
typed encodings add no extra expressive power:
Definition 7: Parametric type hierarchy,
(P,Cp,ap) is persistent if ap never attains zero.
Theorem 3: For any persistent parametric
signature, P, there is a finite non-parametric
signature, N, such that PCs N.
If elist in Figure 1 retained /ist(X)&apos;s parame-
ter, then HPSG&apos;s type hierarchy (without sets)
would be persistent. This is not an unreason-
able change to make. The encoding, however,
requires the use of junk slots, attributes with
no empirical significance whose values serve as
workspace to store intermediate results.
There are at least some non-persistent P, in-
cluding the portion of HPSG&apos;s type hierarchy
explicitly introduced in (PS94) (without sets),
that subsume a finite non-parametric N; but
the encodings are far worse. It can be proven,
for example, that for any such P, some of its
acyclic feature structures must be encoded by
cyclic feature structures in N; and the encoding
cannot be injective on the equivalence classes
induced by the types of P, i.e. some type in
N must encode the feature structures of more
than one type from P. While parametric types
may not be necessary for the grammar pre-
sented in (PS94) in the strict sense, their use in
that grammar does roughly correspond to cases
for which the alternative would be quite unap-
pealing. Of course, parametric types are not
the only extension that would ameliorate these
encodings. The addition of relational expres-
sions, functional uncertainty, or more power-
ful appropriateness restrictions can completely
change the picture.
</bodyText>
<sectionHeader confidence="0.997874" genericHeader="method">
6 Finiteness
</sectionHeader>
<bodyText confidence="0.9819701">
It would be ideal if, for the purposes of feature-
based NLP, one could simply forget the encod-
ings, unfold any parametric type signature into
its induced signature at compile-time and then
proceed as usual. This is not possible for sys-
tems that pre-compute all of their type opera-
tions, as the induced signature of any paramet-
ric signature with at least one non-simple type
contains infinitely many types.7 On the other
hand, at least some pre-compilation of type in-
formation has proven to be an empirical neces-
sity for efficient processing.8 Given that one will
only see finitely many ground instances of para-
metric types in any fixed theory, however, it is
sufficient to perform some pre-compilation spe-
cific to those instances, which will involve some
amount of unfolding. What is needed is a way
of determining, given a signature and a gram-
mar, what part of the induced hierarchy could
be needed at run-time, so that type operations
can be compiled only on that part.
One way to identify this part is to identify
some set of ground instances (a generator set)
that are necessary for computation, and close
that set under U (p):
Theorem 4: If G C 1(P), is finite, then the
sub-algebra of I(P) generated by G, I(G), is
finite.
1/(G)I is exponential in ClI in the worst case;
but if the maximum parametric depth of G can
be bounded (thus bounding IGI), then it is poly-
nomial in IPI, although still exponential in the
maximum arity of P:
Definition 8: Given a parametric hierar-
chy, P, the parametric depth of a type, t =
p(ti,...,tn) E 1(P), 6(t), is 0 if n = 0, and
1 + maxi&lt;i&lt;n 6(4) if n &gt; 0.
So, for example, 5(list (list (list (.1)))). 3.
In practice, the maximum parametric depth
should be quite low,8 as should the maximum
</bodyText>
<footnote confidence="0.875141571428571">
&apos;With parametric restrictions (fn. 5), this is not nec-
essarily the case.
8Even in LFG, a sensible implementation will use de
facto feature co-occurrence constraints to achieve much
of the same effect.
9With lists, so far as I am aware, the potential de-
mand has only reached 6 = 2 (MSI98) in the HPSG
</footnote>
<page confidence="0.995735">
1032
</page>
<bodyText confidence="0.99928832">
arity. A standard closure algorithm can be used,
although it should account for the commutativ-
ity and associativity of unification. One could
also perform the closure lazily during process-
ing to avoid a potentially exponential delay at
compile-time. All of the work, however, can be
performed at compile-time. One can easily con-
struct a generator set: simply collect all ground
instances of types attested in the grammar, or
collect them and add all of the simple types, or
add the simple types along with some extra set
of types distinguished by the user at compile-
time. The partial unfoldings like Figure 2 are
essentially manual computations of 1(G).
Some alternatives to this approach are dis-
cussed in the full version of this paper. The
benefit of this one is that, by definition, 1(G)
is always closed under U/(p). In fact, /(G)
is the least set of types that is adequate
for unification-based processing with the given
grammar. Clearly, this method of sub-signature
extraction can be used even in the absence of
parametric types, and is a useful, general tool
for large-scale grammar design and grammar re-
use.
</bodyText>
<sectionHeader confidence="0.998859" genericHeader="conclusions">
7 Conclusion
</sectionHeader>
<bodyText confidence="0.98845812">
This paper presents a formal definition of para-
metric type hierarchies and signatures, ex-
tending (Car92)&apos;s logic to the parametric case
through equivalent induced non-parametric sig-
natures. It also extends appropriateness to the
common practice of giving the binding of para-
metric type variables scope over appropriate
value restrictions.
Two formalizations of the notion of expressive
equivalence for typed feature structures are also
provided. While the question of P.-1s-equivalence
remains to be solved, a weaker notion can be
used to establish a practical result for under-
standing what parametric types actually con-
tribute to the case of HPSG&apos;s type signature. A
general method for generating sub-signatures is
outlined, which, in the case of parametric type
signatures, can be used to process with signa-
tures that even have infinite equivalent induced
signatures, avoiding equivalent encoding prob-
lems altogether.
Parametric type compilation is currently be-
ing implemented for ALE using the method
literature to date.
given in Section 6.
</bodyText>
<sectionHeader confidence="0.957604" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999912428571429">
(Car92) Carpenter, B., 1992. The Logic of
Typed Feature Structures. Cambridge Univer-
sity Press.
(CP96) Carpenter, B., and Penn, G., 1996. Ef-
ficient Parsing of Compiled Typed Attribute
Value Logic Grammars. In H. Bunt and M.
Tomita, eds., Recent Advances in Parsing
Technology, pp. 145-168. Kluwer.
(DH88) Dietrich, R. and Hagl, F., 1988. A Poly-
morphic Type System with Subtypes for Pro-
log. Proceedings of the 2nd European Sympo-
sium on Programming, pp. 79-93. Springer
LNCS 300.
(Dor92) Dorna, M., 1992. Erweiterung der
Constraint-Logiksprache CUF um em n Typsys-
tern. Diplomarbeit, Universitat Stuttgart.
(Kle91) Klein, E., 1991. Phonological Data
Types. In S. Bird, ed., Declarative Perspec-
tives on Phonology, pp. 127-138. Edinburgh
Working Papers in Cognitive Science, 7.
(MSI98) Manning, C., Sag, I., and Iida,
M., 1998. The Lexical Integrity of Japanese
Causatives. To appear in G. Green and R.
Levine eds., Studies in Contemporary Phrase
Structure Grammar. Cambridge.
(Mos96) Moshier, M. A., 1995. Featureless
HPSG. In P. Blackburn and M. de Rijke, eds.,
Specifying Syntactic Structures. CSLI Publi-
cations.
(Pen-f) Penn, G., forthcoming. Ph.D. Disserta-
tion, Carnegie Mellon University.
(PS94) Pollard, C. and Sag, I., 1994. Head-
Driven Phrase Structure Grammar. Univer-
sity of Chicago Press.
(Smo89) Smollca, G., 1989. Logic Program-
ming over Polymorphically Order-Sorted
Types. Ph.D. Dissertation, Universitat
Kaiserslautern.
(YFS92) Yardeni, E., Friiwirth, T. and Shapiro,
E., 1992. Polymorphically Typed Logic Pro-
grams. In F. Pfenning, ed., Types in Logic
Programming, pp. 63-90. MIT Press.
</reference>
<page confidence="0.978908">
1033
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.389699">
<title confidence="0.999787">Parametric Types for Typed Attribute-Value Logic</title>
<author confidence="0.999815">Gerald Penn</author>
<affiliation confidence="0.999803">Universitat Tubingen</affiliation>
<address confidence="0.983929666666667">1{1. Wilhelmstr. 113 72074 Tuebingen Germany</address>
<email confidence="0.999529">gpenn@sfs.nphil.uni-tuebingen.de</email>
<abstract confidence="0.99879130726257">Parametric polymorphism has been combined with inclusional polymorphism to provide natural type systems for Prolog (DH88), HiLog (YFS92), and constraint resolution languages (Smo89), and, in linguistics, by HPSG-like grammars to classify lists and sets of linguistic objects (PS94), and by phonologists in representations of hierarchical structure (Kle91). This paper summarizes the incorporation of parametric types into the typed attribute-value logic of (Car92), thus providing a natural extension to the type system for ALE (CP96). Following (Car92), the concern here is not with models of feature terms themselves, but with how to compute with parametric types, and what different kinds of information one can represent relative to a signature with parametric types, than relative to a signature without them. This enquiry has yielded a more flexible interpretation of parametric types with several specific properties necessary to conform to their current usage by linguists and implementors who work with feature-based formalisms. 1 Motivation Linguists who avail themselves of attributevalue logic normally choose whether to encode information with subtypes or features on the aesthetic basis of what seems intuitively to capture their generalizations better. Linguists working in LFG typically use one implicit type for objects that bear features, and other types (atoms) for only featureless objects. In HPSG, the situation is less clear, both historically (semantic relations, for example, used to be valof a and are now subtypes of a more general semantic type), and synchronically (verbs, for example, are identified as (un)inverted and (non-)auxiliaries by two features, their form, e.g., finite, infinitive, gerund, is idenby a subtype of a single That it makes, or at least should make, no difference from a formal or implementational point of view which encoding is used has been argued elsewhere (Mos96; Pen-f). HPSG&apos;s type system also includes parametric types, e.g., Figure 1, from (PS94). In contrast çlist nelistql, HEAD:A 1 Figure 1: A fragment of the HPSG type signature. relative expressive potential of normal typing and features, the expressive potential of parametric types is not at all understood. In fact, parametric types have never been formalized in a feature logic or in a manner general enough to capture their use in HPSG parsing so that a comparison could even be drawn. This summarizes such a based on the typed attribute-value logic of (Car92). This logic is distinguished by its strong interof set of conditions that tell us which features an object of a given type can have, and which types a feavalue can have. Its interpretation, that every feature structure must have an appropriate value for all and only the appropriate features of its type. Previous approaches have required that every parameter of a subtype should be a parameter of all of its and versa; would not be &apos;The full version of this paper presents a denotational semantics of the logic described here. 1027 to encode Figure 1 because I. E and if .1 were parametric, then all other types The present one eliminates this re- 2) by requiring the existence of a simple most general type (which (Car92)&apos;s logic requires anyway), which is then used during type-checking and inferencing to interpret new parameters. All previous approaches deal only with fixed-arity terms; and none but one uses a feature logic, with the one, CUF (Dor92), being an implementation that permits parametric lists only as a special case. The present approach (Section 4) provides a generalization of appropriateness that permits both unrestricted parametricity and incremental feature introduction. In contrast to the other encoding tradeoff, the use of parametric types in HPSG linguistics exhibits almost no variation. They are used almost exclusively for encoding lists (and, unconvincingly, sets), either with type arguments as they are posited in (PS94), or with general description-level arguments, e.g., /ist(LocAL:cAT:HEAD:verb), the latter possibly arising out of the erroneous belief that parametric types are just &amp;quot;macro&amp;quot; descriptions for Even in the former however, parametric types have as wide of a range of potential application to HPSG as simple types and features do; and there is no reason why they cannot be used as prolifically once they are un- To use an earlier example, all be parameters of a parametric type, verb. In fact, parametrically typed encodings yield more compact specifications than simply typed encodings because they can encode products of information in their parameters, like features. Unlike features, however, they can lend their parameters to appropriateness restrictions, thus refining the feature structures generated by the signature to a closer approximation of what is actually required in the grammar theory itself. It is possible, however, to regard paramettype as a shorthand for noninterpretation of this paper, the most general type will be called 1. &amp;quot;signature,&amp;quot; I refer to a partial order of types plus feature appropriateness declarations. The partial order itself, I shall refer to as a &amp;quot;type (inheritance) hierarchy.&amp;quot; parametric type hierarchies is introduced in Section 3 by way of establishing equivalent, infinite counterparts. Section 5 considers whether there are any finite counterparts, i.e., whether in actual practice parametric signatures are only as expressive as non-parametric ones, and gives a qualified &amp;quot;yes.&amp;quot; In spite of this qualification, there is an easy way to compute with parametric types directly in an implementation, as described in Section 6. The two most common previous approaches have been to use the most general instance of a type, e.g. its appropriateness, or manually to &amp;quot;unfold&amp;quot; a parametric type into a non-parametric sub-hierarchy that suffices for a fixed grammar (e.g. Figure 2). former does not suffice even for fixed grameli ne ist_syn m nelis _qua ts neli-t_phon list_syn elist list Figure 2: A manually unfolded sub-hierarchy. mars because it simply disables type checking on feature values. The latter is error-prone, a nuisance, and subject to change with the grammar. As it happens, there is an automatic way to perform this unfolding. 2 Parametric Type Hierarchies Parametric types are not types. They are functions that provide access or a means of reference to a set of types (their image) by means of argument types, or &amp;quot;parameters&amp;quot; (their domain). Figure 1 has only unary functions; but in general, parametric types can be n-ary functions n-tuples of This means that hierthis paper, &amp;quot;parametric type&amp;quot; will refer to such a function, written as the name of the function, followed by the appropriate number of &amp;quot;type variables,&amp;quot; variables that range over some set of types, in parentheses, e.g. will refer to both &amp;quot;simple types,&amp;quot; such as or &amp;quot;ground instances&amp;quot; of parametric types, i.e. types in the image of a parametric type function, written as the name of the function followed by the appropriate number of actual type parameters in parensuch as set(psoa) will letters and v to indicate types; capital letters to indicate type variables; capitalized words to indicate names; p, r for names of parametric types; indicate ground instances of parametric types, 1028 archies that use parametric types are not &amp;quot;type&amp;quot; hierarchies, since they express a relationship between functions (we can regard simple types as nullary parametric types): 1: (type) hierarchy finite meet semilattice, a partial argument assignment function, ap :PxPx —+ U {0}, in which: P of (simple and) parametric types, (i.e. no ground instances of parametric types), including the simple most general type, 1, For ap(p,q,i), a(i), is if &lt; &lt; and • 0 &lt; al,(i) &lt;m, when it exists. Meet semilatticehood, a requirement of (Car92)&apos;s logic as well, allows us to talk about unification, because we have a unique mostgeneral unifier for every unifiable pair of types. The argument assignment function encodes the identification of parameters between a parametric type and its parametric subtype. The number, n, refers to the nth parameter of a parametric type, with 0 referring to a parameter that has been dropped. In practice, this is normally expressed by the names given to type variables. the parametric type hierarchy of Figure the same variable, beis = 0, then list tut would use a different variable name. As a more example, in Figure 3, 4(1) = d(X Y Z) ,,,,&amp;quot;-.‹.. (X, 1 Figure 3: A subtype that inherits type variables from more than one supertype. = 3, ag(2) = 2, ag(1) = 0, and al and undefined (f) for any pair in x Nat. 3 Induced Type Hierarchies The relationship expressed between two functions by Cp, informally, is one between their imsets under their while each image where the arguments do not need to be expressed. can restrict these domains with &amp;quot;parametric restrictions,&amp;quot; a parallel to appropriateness restrictions on set internally preserves the subsumption ordering of its domain. It is, thus, possible to think of a parametric type hierarchy as &amp;quot;inducing&amp;quot; a non-parametric type hierarchy, populated with the ground instances of its parametric types, that obeys both of these relationships. 2: parametric type hiera), the (type) hierarchy, is defined such that: I(P) the smallest set, that, for parametric type, • • . , E for every tuple, • • • , p(ti, • • • ,tn) q(Ui, • • . , Cp q, for all 1&lt;i&lt;n, either 0 or ti gi can easily be shown that is a partial order with a least element, namely 1, the element of that contains of the simple types of the case where are gi gi gi cp g2. Figure 4 shows a fragment of the type hierarinduced by Figure nelist(woczk„peli t(phrase) Inelis (sign nel st(1) . . (nelist4)) list( rd (phrase) list(list(.1)). . . list(L) 4: Fragment induced by Figure shared the same type variable = 0), then it would have induced the type hierarchy in Figure 5. In the hierarchy induced nelist(sigRL,nelist(list(iL)) list(&apos;siglist(list(1)) list(1) Figure 5: Another possible induced hierarchy. feature values. This abstract assumes that these domains are always the set of all types in the signature. This is the most expressive case of parametric types, and the worst case, computationally. 1029 Figure 3, types any type Y, for example not e). Also, for any types, W, The present approach permits parametric types in the type signature, but only ground instances in a grammar relative to that signature. If one must refer to &amp;quot;some list&amp;quot; or &amp;quot;every list&amp;quot; within a grammar, for instance, one may still retaining groundedness. An alternative to this approach would be to attempt to cope with type variable parameters directly within descriptions. From a processing perspective, this is problematic when closing such descriptions under total well-typing, as observed in (Car92). The most general satisfier of the description, /ist(X)A(HEAD:HEAD TAIL:HEAD), example, is an infinite feature structure of the infinitely parametric type, be bound to nelist(X). which it make sense to talk about in is, when is meet semilattice? We can generalize the usual notion programming languages, so that a subtype can add, and in certain cases drop, parameters with respect to a supertype: 3: semi-coherent all E P that p 1 &lt; i &lt; arity(p), 1 &lt; j arity(q): • a( i) either 0 or for every chain, P • • = = )) and pn-i Pn-2 • &amp;quot; pi • • • , If pUpq,j., then for all i and which there a &gt; such that set, {rip q and (4(i) = 0 or = is empty or has a least element respect to 1: If semi-coherent, a meet semilattice. In • • • , tn) ur q(ui, • • • = (vi, , Up q = and, for all 1&lt;k&lt;s, Ul ui if there exist i and that = = if such an i, but no such such a no such no such i or p(ti, , , if or exist i, &gt; such that = k, ti U/ In the induced hierarchy of Figure 3, for ex- U/ e) = b(e, b(e, e) Ur = e); and e) b(c(_L), e) are not unifiable, as e and c(I) are not unifiable. The first two conditions of semi-coherence enthat as a relation between pairs of pairs of types and natural numbers, is an order induced by the order, Ep, where it is not, taken as a function, zero. The third ensures that joins are preserved even when a parameter is 0). Note that joins in an induced hierarchy do not always correspond to joins in a parametric hierarchy. In those places where 0, types can unify without a corresponding unification in their parameters. Such is the in Figure 5, where every instance of subsumes may also note that induced hierarchies can have not only deep infinity, where there exist infinitely long subsumption chains, but broad infinity, where certain types can have infinite supertype (but never subtype) branching factors, as in the case in Figure 4 Appropriateness So far, we have formally considered only type hierarchies, and no appropriateness. Appropriateness constitutes an integral part of a parametric type signature&apos;s expressive power, because the scope of its type variables extends to include it. 4: (type) signature parametric hierarchy, with set of features, a partial (parametric) appropriateness function, Appropp : —&gt; Q, = is the smallest set satisfying the equa- = {1,... ,n} that: proofs of these theorems can be found in the full version of this paper.</abstract>
<intro confidence="0.60128">1030</intro>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>B Carpenter</author>
</authors>
<title>The Logic of Typed Feature Structures.</title>
<date>1992</date>
<publisher>Cambridge University Press.</publisher>
<contexts>
<context position="633" citStr="(Car92)" startWordPosition="82" endWordPosition="82"> Attribute-Value Logic Gerald Penn Universitat Tubingen 1{1. Wilhelmstr. 113 72074 Tuebingen Germany gpenn@sfs.nphil.uni-tuebingen.de Abstract Parametric polymorphism has been combined with inclusional polymorphism to provide natural type systems for Prolog (DH88), HiLog (YFS92), and constraint resolution languages (Smo89), and, in linguistics, by HPSG-like grammars to classify lists and sets of linguistic objects (PS94), and by phonologists in representations of hierarchical structure (Kle91). This paper summarizes the incorporation of parametric types into the typed attribute-value logic of (Car92), thus providing a natural extension to the type system for ALE (CP96). Following (Car92), the concern here is not with models of feature terms themselves, but with how to compute with parametric types, and what different kinds of information one can represent relative to a signature with parametric types, than relative to a signature without them. This enquiry has yielded a more flexible interpretation of parametric types with several specific properties necessary to conform to their current usage by linguists and implementors who work with feature-based formalisms. 1 Motivation Linguists who</context>
<context position="2794" citStr="(Car92)" startWordPosition="431" endWordPosition="431"> system also includes parametric types, e.g., Figure 1, from (PS94). In contrast word phrase çlist nelistql, HEAD:A TAIL: list(X) szg )t(X) 1 Figure 1: A fragment of the HPSG type signature. to the relative expressive potential of normal typing and features, the expressive potential of parametric types is not at all understood. In fact, parametric types have never been formalized in a feature logic or in a manner general enough to capture their use in HPSG parsing so that a comparison could even be drawn. This paper summarizes such a formalization,1 based on the typed attribute-value logic of (Car92). This logic is distinguished by its strong interpretation of appropriateness, a set of conditions that tell us which features an object of a given type can have, and which types a feature&apos;s value can have. Its interpretation, total well-typedness, says that every feature structure must have an appropriate value for all and only the appropriate features of its type. Previous approaches have required that every parameter of a subtype should be a parameter of all of its supertypes, and vice versa; thus, it would not be &apos;The full version of this paper presents a denotational semantics of the logi</context>
<context position="8617" citStr="(Car92)" startWordPosition="1384" endWordPosition="1384"> are not &amp;quot;type&amp;quot; hierarchies, since they express a relationship between functions (we can regard simple types as nullary parametric types): Definition 1: A parametric (type) hierarchy is a finite meet semilattice, (P,Cp), plus a partial argument assignment function, ap :PxPx Nat —+ Nat U {0}, in which: • P consists of (simple and) parametric types, (i.e. no ground instances of parametric types), including the simple most general type, 1, • For p,q E P, ap(p,q,i), written a(i), is defined if p Ep q and 1 &lt; i &lt; arity(p), and • 0 &lt; al,(i) &lt;m, when it exists. Meet semilatticehood, a requirement of (Car92)&apos;s logic as well, allows us to talk about unification, because we have a unique mostgeneral unifier for every unifiable pair of types. The argument assignment function encodes the identification of parameters between a parametric type and its parametric subtype. The number, n, refers to the nth parameter of a parametric type, with 0 referring to a parameter that has been dropped. In practice, this is normally expressed by the names given to type variables. In the parametric type hierarchy of Figure 1, list and nelist share the same variable, X, because aneust(1) is 1. If an.eust(1) = 0, then n</context>
<context position="12250" citStr="(Car92)" startWordPosition="2010" endWordPosition="2010">e,e), since egic(1, e). Also, for any types, W, X, and Z, c(W,e) subsumes d(X,e,Z). The present approach permits parametric types in the type signature, but only ground instances in a grammar relative to that signature. If one must refer to &amp;quot;some list&amp;quot; or &amp;quot;every list&amp;quot; within a grammar, for instance, one may use list(±), while still retaining groundedness. An alternative to this approach would be to attempt to cope with type variable parameters directly within descriptions. From a processing perspective, this is problematic when closing such descriptions under total well-typing, as observed in (Car92). The most general satisfier of the description, /ist(X)A(HEAD:HEAD = TAIL:HEAD), for example, is an infinite feature structure of the infinitely parametric type, nelist(nelist(... because X must be bound to nelist(X). For which P does it make sense to talk about unification in I(P), that is, when is I(P) a meet semilattice? We can generalize the usual notion of coherence from programming languages, so that a subtype can add, and in certain cases drop, parameters with respect to a supertype: Definition 3: (P,Cp,ap) is semi-coherent if, for all p,q E P such that p Cp q, all 1 &lt; i &lt; arity(p), 1 </context>
<context position="16181" citStr="(Car92)" startWordPosition="2774" endWordPosition="2774">ure / Right Monotonicity) For any p, q E F, if Appropp(f,p) is defined and p Cp q, then Appropp(f,q) is also defined and Appropp(f,p) CQ Appropp(f, , q), where EQ is defined as EI(P) with natural numbers interpreted as universally quantified variables (e.g. a(1) b(1) iff Vx E I(P).a(x) Ci(p) b(x)) 3. (Parameter Binding) For every p E P of arity n, for every f E Featp, if Appropp(f,p) is defined, then Appropp(f,p) E Q. Appropp maps a feature and the parametric type for which it is appropriate to its value restriction on that parametric type. The first two conditions are the usual conditions on (Car92)&apos;s appropriateness. The third says that the natural numbers in its image refer, by position, to the parametric variables of the appropriate parametric type — we can use one of these parameters wherever we would normally use a type. Notice that ground instances of parametric types are permitted as value restrictions, as are instances of parametric types whose parameters are bound to these parametric variables, as are the parametric variables themselves. The first is used in HPSG for features such as SUBCAT, whose value must be list(synsem); whereas the second and third are used in the appropria</context>
<context position="18710" citStr="(Car92)" startWordPosition="3175" endWordPosition="3175">perties (1) and (2). 5 Signature Subsumption Now that parametric type signatures have been formalized, one can ask whether parametric types really add something to the expressive power of typed attribute-value logic. There are at least two ways in which to formalize that question: Definition 5: Two type signatures, P and Q, are equivalent (P s Q) if there exists an orderisomorphism (w.r.t. subsumption) between the abstract totally well-typed feature structures of P and those of Q. Abstract totally well-typed feature structures are the &amp;quot;information states&amp;quot; generated by signatures. Formally, as (Car92) shows, they can either be thought of as equivalence classes of feature structures modulo alphabetic variants, or as pairs of a type assignment function on feature paths and a path equivalence relation. In either case, they are effectively feature structures without their &amp;quot;nodes,&amp;quot; which only bear information insofar as they have a type and serve as the focus of potential instances of structure sharing among feature path, where the traversal of two different paths from the same node leads to the same feature structure. If, for every parametric signature P, there is a finite non-parametric N suc</context>
<context position="25331" citStr="(Car92)" startWordPosition="4310" endWordPosition="4310">nual computations of 1(G). Some alternatives to this approach are discussed in the full version of this paper. The benefit of this one is that, by definition, 1(G) is always closed under U/(p). In fact, /(G) is the least set of types that is adequate for unification-based processing with the given grammar. Clearly, this method of sub-signature extraction can be used even in the absence of parametric types, and is a useful, general tool for large-scale grammar design and grammar reuse. 7 Conclusion This paper presents a formal definition of parametric type hierarchies and signatures, extending (Car92)&apos;s logic to the parametric case through equivalent induced non-parametric signatures. It also extends appropriateness to the common practice of giving the binding of parametric type variables scope over appropriate value restrictions. Two formalizations of the notion of expressive equivalence for typed feature structures are also provided. While the question of P.-1s-equivalence remains to be solved, a weaker notion can be used to establish a practical result for understanding what parametric types actually contribute to the case of HPSG&apos;s type signature. A general method for generating sub-si</context>
</contexts>
<marker>(Car92)</marker>
<rawString>Carpenter, B., 1992. The Logic of Typed Feature Structures. Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Carpenter</author>
<author>G Penn</author>
</authors>
<title>Efficient Parsing of Compiled Typed Attribute Value Logic Grammars.</title>
<date>1996</date>
<booktitle>Recent Advances in Parsing Technology,</booktitle>
<pages>145--168</pages>
<editor>In H. Bunt and M. Tomita, eds.,</editor>
<publisher>Kluwer.</publisher>
<contexts>
<context position="703" citStr="(CP96)" startWordPosition="94" endWordPosition="94">. 113 72074 Tuebingen Germany gpenn@sfs.nphil.uni-tuebingen.de Abstract Parametric polymorphism has been combined with inclusional polymorphism to provide natural type systems for Prolog (DH88), HiLog (YFS92), and constraint resolution languages (Smo89), and, in linguistics, by HPSG-like grammars to classify lists and sets of linguistic objects (PS94), and by phonologists in representations of hierarchical structure (Kle91). This paper summarizes the incorporation of parametric types into the typed attribute-value logic of (Car92), thus providing a natural extension to the type system for ALE (CP96). Following (Car92), the concern here is not with models of feature terms themselves, but with how to compute with parametric types, and what different kinds of information one can represent relative to a signature with parametric types, than relative to a signature without them. This enquiry has yielded a more flexible interpretation of parametric types with several specific properties necessary to conform to their current usage by linguists and implementors who work with feature-based formalisms. 1 Motivation Linguists who avail themselves of attributevalue logic normally choose whether to e</context>
</contexts>
<marker>(CP96)</marker>
<rawString>Carpenter, B., and Penn, G., 1996. Efficient Parsing of Compiled Typed Attribute Value Logic Grammars. In H. Bunt and M. Tomita, eds., Recent Advances in Parsing Technology, pp. 145-168. Kluwer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Dietrich</author>
<author>F Hagl</author>
</authors>
<title>A Polymorphic Type System with Subtypes for Prolog.</title>
<date>1988</date>
<booktitle>Proceedings of the 2nd European Symposium on Programming,</booktitle>
<tech>LNCS 300.</tech>
<pages>79--93</pages>
<publisher>Springer</publisher>
<marker>(DH88)</marker>
<rawString>Dietrich, R. and Hagl, F., 1988. A Polymorphic Type System with Subtypes for Prolog. Proceedings of the 2nd European Symposium on Programming, pp. 79-93. Springer LNCS 300.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Dorna</author>
</authors>
<title>Erweiterung der Constraint-Logiksprache CUF um em n Typsystern.</title>
<date>1992</date>
<tech>Diplomarbeit,</tech>
<institution>Universitat Stuttgart.</institution>
<contexts>
<context position="3887" citStr="(Dor92)" startWordPosition="614" endWordPosition="614">nd vice versa; thus, it would not be &apos;The full version of this paper presents a denotational semantics of the logic described here. 1027 possible to encode Figure 1 because I. E /ist(X), and if .1 were parametric, then all other types would be.2 The present one eliminates this restriction (Section 2) by requiring the existence of a simple most general type (which (Car92)&apos;s logic requires anyway), which is then used during type-checking and inferencing to interpret new parameters. All previous approaches deal only with fixed-arity terms; and none but one uses a feature logic, with the one, CUF (Dor92), being an implementation that permits parametric lists only as a special case. The present approach (Section 4) provides a generalization of appropriateness that permits both unrestricted parametricity and incremental feature introduction. In contrast to the other encoding tradeoff, the use of parametric types in HPSG linguistics exhibits almost no variation. They are used almost exclusively for encoding lists (and, unconvincingly, sets), either with type arguments as they are posited in (PS94), or with general description-level arguments, e.g., /ist(LocAL:cAT:HEAD:verb), the latter possibly </context>
</contexts>
<marker>(Dor92)</marker>
<rawString>Dorna, M., 1992. Erweiterung der Constraint-Logiksprache CUF um em n Typsystern. Diplomarbeit, Universitat Stuttgart.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Klein</author>
</authors>
<title>Phonological Data Types.</title>
<date>1991</date>
<booktitle>Declarative Perspectives on Phonology,</booktitle>
<pages>127--138</pages>
<editor>In S. Bird, ed.,</editor>
<marker>(Kle91)</marker>
<rawString>Klein, E., 1991. Phonological Data Types. In S. Bird, ed., Declarative Perspectives on Phonology, pp. 127-138. Edinburgh Working Papers in Cognitive Science, 7.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Manning</author>
<author>I Sag</author>
<author>M Iida</author>
</authors>
<title>The Lexical Integrity of Japanese Causatives.</title>
<date>1998</date>
<booktitle>Studies in Contemporary Phrase Structure Grammar.</booktitle>
<editor>in G. Green and R. Levine eds.,</editor>
<location>Cambridge.</location>
<note>To appear</note>
<contexts>
<context position="24079" citStr="(MSI98)" startWordPosition="4101" endWordPosition="4101">l in the maximum arity of P: Definition 8: Given a parametric hierarchy, P, the parametric depth of a type, t = p(ti,...,tn) E 1(P), 6(t), is 0 if n = 0, and 1 + maxi&lt;i&lt;n 6(4) if n &gt; 0. So, for example, 5(list (list (list (.1)))). 3. In practice, the maximum parametric depth should be quite low,8 as should the maximum &apos;With parametric restrictions (fn. 5), this is not necessarily the case. 8Even in LFG, a sensible implementation will use de facto feature co-occurrence constraints to achieve much of the same effect. 9With lists, so far as I am aware, the potential demand has only reached 6 = 2 (MSI98) in the HPSG 1032 arity. A standard closure algorithm can be used, although it should account for the commutativity and associativity of unification. One could also perform the closure lazily during processing to avoid a potentially exponential delay at compile-time. All of the work, however, can be performed at compile-time. One can easily construct a generator set: simply collect all ground instances of types attested in the grammar, or collect them and add all of the simple types, or add the simple types along with some extra set of types distinguished by the user at compiletime. The partia</context>
</contexts>
<marker>(MSI98)</marker>
<rawString>Manning, C., Sag, I., and Iida, M., 1998. The Lexical Integrity of Japanese Causatives. To appear in G. Green and R. Levine eds., Studies in Contemporary Phrase Structure Grammar. Cambridge.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M A Moshier</author>
</authors>
<title>Featureless HPSG.</title>
<date>1995</date>
<editor>In P. Blackburn and M. de Rijke, eds.,</editor>
<publisher>CSLI Publications.</publisher>
<contexts>
<context position="2174" citStr="(Mos96; Pen-f)" startWordPosition="327" endWordPosition="328">eatureless objects. In HPSG, the situation is less clear, both historically (semantic relations, for example, used to be values of a RELN attribute, and are now subtypes of a more general semantic type), and synchronically (verbs, for example, are identified as (un)inverted and (non-)auxiliaries by two boolean-valued features, AUX and INV, whereas their form, e.g., finite, infinitive, gerund, is identified by a subtype of a single vforrn type). That it makes, or at least should make, no difference from a formal or implementational point of view which encoding is used has been argued elsewhere (Mos96; Pen-f). HPSG&apos;s type system also includes parametric types, e.g., Figure 1, from (PS94). In contrast word phrase çlist nelistql, HEAD:A TAIL: list(X) szg )t(X) 1 Figure 1: A fragment of the HPSG type signature. to the relative expressive potential of normal typing and features, the expressive potential of parametric types is not at all understood. In fact, parametric types have never been formalized in a feature logic or in a manner general enough to capture their use in HPSG parsing so that a comparison could even be drawn. This paper summarizes such a formalization,1 based on the typed attribute-va</context>
</contexts>
<marker>(Mos96)</marker>
<rawString>Moshier, M. A., 1995. Featureless HPSG. In P. Blackburn and M. de Rijke, eds., Specifying Syntactic Structures. CSLI Publications.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Ph D Dissertation</author>
</authors>
<institution>Carnegie Mellon University.</institution>
<contexts>
<context position="2174" citStr="(Mos96; Pen-f)" startWordPosition="327" endWordPosition="328">eatureless objects. In HPSG, the situation is less clear, both historically (semantic relations, for example, used to be values of a RELN attribute, and are now subtypes of a more general semantic type), and synchronically (verbs, for example, are identified as (un)inverted and (non-)auxiliaries by two boolean-valued features, AUX and INV, whereas their form, e.g., finite, infinitive, gerund, is identified by a subtype of a single vforrn type). That it makes, or at least should make, no difference from a formal or implementational point of view which encoding is used has been argued elsewhere (Mos96; Pen-f). HPSG&apos;s type system also includes parametric types, e.g., Figure 1, from (PS94). In contrast word phrase çlist nelistql, HEAD:A TAIL: list(X) szg )t(X) 1 Figure 1: A fragment of the HPSG type signature. to the relative expressive potential of normal typing and features, the expressive potential of parametric types is not at all understood. In fact, parametric types have never been formalized in a feature logic or in a manner general enough to capture their use in HPSG parsing so that a comparison could even be drawn. This paper summarizes such a formalization,1 based on the typed attribute-va</context>
</contexts>
<marker>(Pen-f)</marker>
<rawString>Penn, G., forthcoming. Ph.D. Dissertation, Carnegie Mellon University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Pollard</author>
<author>I Sag</author>
</authors>
<title>HeadDriven Phrase Structure Grammar.</title>
<date>1994</date>
<publisher>University of Chicago Press.</publisher>
<contexts>
<context position="2254" citStr="(PS94)" startWordPosition="340" endWordPosition="340">lations, for example, used to be values of a RELN attribute, and are now subtypes of a more general semantic type), and synchronically (verbs, for example, are identified as (un)inverted and (non-)auxiliaries by two boolean-valued features, AUX and INV, whereas their form, e.g., finite, infinitive, gerund, is identified by a subtype of a single vforrn type). That it makes, or at least should make, no difference from a formal or implementational point of view which encoding is used has been argued elsewhere (Mos96; Pen-f). HPSG&apos;s type system also includes parametric types, e.g., Figure 1, from (PS94). In contrast word phrase çlist nelistql, HEAD:A TAIL: list(X) szg )t(X) 1 Figure 1: A fragment of the HPSG type signature. to the relative expressive potential of normal typing and features, the expressive potential of parametric types is not at all understood. In fact, parametric types have never been formalized in a feature logic or in a manner general enough to capture their use in HPSG parsing so that a comparison could even be drawn. This paper summarizes such a formalization,1 based on the typed attribute-value logic of (Car92). This logic is distinguished by its strong interpretation o</context>
<context position="4387" citStr="(PS94)" startWordPosition="690" endWordPosition="690">roaches deal only with fixed-arity terms; and none but one uses a feature logic, with the one, CUF (Dor92), being an implementation that permits parametric lists only as a special case. The present approach (Section 4) provides a generalization of appropriateness that permits both unrestricted parametricity and incremental feature introduction. In contrast to the other encoding tradeoff, the use of parametric types in HPSG linguistics exhibits almost no variation. They are used almost exclusively for encoding lists (and, unconvincingly, sets), either with type arguments as they are posited in (PS94), or with general description-level arguments, e.g., /ist(LocAL:cAT:HEAD:verb), the latter possibly arising out of the erroneous belief that parametric types are just &amp;quot;macro&amp;quot; descriptions for lists. Even in the former case, however, parametric types have as wide of a range of potential application to HPSG as simple types and features do; and there is no reason why they cannot be used as prolifically once they are understood. To use an earlier example, auxiliary, inverted, and verb_forin could all be parameters of a parametric type, verb. In fact, parametrically typed encodings yield more compa</context>
<context position="21190" citStr="(PS94)" startWordPosition="3594" endWordPosition="3594">P,Cp,ap) is persistent if ap never attains zero. Theorem 3: For any persistent parametric signature, P, there is a finite non-parametric signature, N, such that PCs N. If elist in Figure 1 retained /ist(X)&apos;s parameter, then HPSG&apos;s type hierarchy (without sets) would be persistent. This is not an unreasonable change to make. The encoding, however, requires the use of junk slots, attributes with no empirical significance whose values serve as workspace to store intermediate results. There are at least some non-persistent P, including the portion of HPSG&apos;s type hierarchy explicitly introduced in (PS94) (without sets), that subsume a finite non-parametric N; but the encodings are far worse. It can be proven, for example, that for any such P, some of its acyclic feature structures must be encoded by cyclic feature structures in N; and the encoding cannot be injective on the equivalence classes induced by the types of P, i.e. some type in N must encode the feature structures of more than one type from P. While parametric types may not be necessary for the grammar presented in (PS94) in the strict sense, their use in that grammar does roughly correspond to cases for which the alternative would </context>
</contexts>
<marker>(PS94)</marker>
<rawString>Pollard, C. and Sag, I., 1994. HeadDriven Phrase Structure Grammar. University of Chicago Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Smollca</author>
</authors>
<title>Logic Programming over Polymorphically Order-Sorted Types.</title>
<date>1989</date>
<tech>Ph.D. Dissertation,</tech>
<institution>Universitat Kaiserslautern.</institution>
<marker>(Smo89)</marker>
<rawString>Smollca, G., 1989. Logic Programming over Polymorphically Order-Sorted Types. Ph.D. Dissertation, Universitat Kaiserslautern.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Yardeni</author>
<author>T Friiwirth</author>
<author>E Shapiro</author>
</authors>
<title>Polymorphically Typed Logic Programs. In</title>
<date>1992</date>
<booktitle>Types in Logic Programming,</booktitle>
<pages>63--90</pages>
<editor>F. Pfenning, ed.,</editor>
<publisher>MIT Press.</publisher>
<marker>(YFS92)</marker>
<rawString>Yardeni, E., Friiwirth, T. and Shapiro, E., 1992. Polymorphically Typed Logic Programs. In F. Pfenning, ed., Types in Logic Programming, pp. 63-90. MIT Press.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>