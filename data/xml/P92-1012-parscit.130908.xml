<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000065">
<title confidence="0.5763585">
RECOGNITION OF
LINEAR CONTEXT-FREE REWRITING SYSTEMS*
</title>
<author confidence="0.956616">
Giorgio Satta
</author>
<affiliation confidence="0.903774666666667">
Institute for Research in Cognitive Science
University of Pennsylvania
Philadelphia, PA 19104-6228, USA
</affiliation>
<email confidence="0.839999">
gsattaalinc.cis.upenn.edu
</email>
<sectionHeader confidence="0.994662" genericHeader="abstract">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.999698133333333">
The class of linear context-free rewriting sys-
tems has been introduced as a generalization of
a class of grammar formalisms known as mildly
context-sensitive. The recognition problem for lin-
ear context-free rewriting languages is studied at
length here, presenting evidence that, even in some
restricted cases, it cannot be solved efficiently. This
entails the existence of a gap between, for exam-
ple, tree adjoining languages and the subclass of lin-
ear context-free rewriting languages that generalizes
the former class; such a gap is attributed to &amp;quot;cross-
ing configurations&amp;quot;. A few other interesting conse-
quences of the main result are discussed, that con-
cern the recognition problem for linear context-free
rewriting languages.
</bodyText>
<sectionHeader confidence="0.999566" genericHeader="introduction">
1 INTRODUCTION
</sectionHeader>
<bodyText confidence="0.999590583333333">
Beginning with the late 70&apos;s, there has been a consid-
erable interest within the computational linguistics
field for rewriting systems that enlarge the gener-
ative power of context-free grammars (CFG) both
from the weak and the strong perspective, still re-
maining far below the power of the class of context-
sensitive grammars (CSG). The denomination of
mildly context-sensitive (MCS) has been proposed
for the class of the studied systems (see [Joshi et
al., 1991] for discussion). The rather surprising fact
that many of these systems have been shown to be
weakly equivalent has led researchers to generalize
</bodyText>
<footnote confidence="0.8538485">
*I am indebted to Anuj Dawar, Shyam Kapur and Owen
Rainbow for technical discussion on this work. I am also
grateful to Aravincl Joshi for his support in this research.
None of these people is responsible for any error in this work.
This research was partially funded by the following grants:
ARO grant DAAL 03-89-C-0031, DARPA grant N00014-90-
J-1863, NSF grant IRI 90-16592 and Ben Franklin grant
91 S.3078C-1 .
</footnote>
<bodyText confidence="0.999925833333333">
the elementary operations involved in only appar-
ently different formalisms, with the aim of captur-
ing the underlying similarities. The most remark-
able attempts in such a direction are found in [Vijay-
Shanker et at., 1987] and [Weir, 1988] with the in-
troduction of linear context-free rewriting systems
(LCFRS) and in [Kasami et al., 19871 and [Seki et
al., 1989] with the definition of multiple context-free
grammars (MCFG); both these classes have been in-
spired by the much more powerful class of gener-
alized context-free grammars (GCFG; see [Pollard,
1984)). In the definition of these classes, the gener-
alization goal has been combined with few theoret-
ically motivated constraints, among which the re-
quirement of efficient parsability; this paper is con-
cerned with such a requirement. We show that from
the perpective of efficient parsability, a gap is still
found between MCS and some subclasses of LCFRS.
More precisely, the class of LCFRS is carefully
studied along two interesting dimensions, to be pre-
cisely defined in the following: a) the fan-out of
the grammar and b) the production length. From
previous work (see [Vijay-Shanker et al., 19871) we
know that the recognition problem for LCFRS is in P
when both dimensions are bounded.&apos; We complete
the picture by observing NP-hardness for all the
three remaining cases. If PONP, our result reveals
an undesired dissimilarity between well known for-
malisms like TAG, HG, LIG and others for which the
recognition problem is known to be in P (see [Vijay-
Shanker, 1987] and [Vijay-Shanker and Weir, 1992])
and the subclass of LCFRS that is intended to gener-
alize these formalisms. We investigate the source of
the suspected additional complexity and derive some
other practical consequences from the obtained re-
sults.
</bodyText>
<footnote confidence="0.971495333333333">
IP is the class of all languages decidable in deterministic
polynomial time; NP is the class of all languages decidable in
nondeterministic polynomial time.
</footnote>
<page confidence="0.999851">
89
</page>
<sectionHeader confidence="0.997856" genericHeader="method">
2 TECHNICAL RESULTS
</sectionHeader>
<bodyText confidence="0.997927625">
This section presents two technical results that are
. the most important in this paper. A full discussion
of some interesting implications for recognition and
parsing is deferred to Section 3. Due to the scope
of the paper, proofs of Theorems 1 and 2 below are
not carried out in all their details: we only present
formal specifications for the studied reductions and
discuss the intuitive ideas behind them.
</bodyText>
<subsectionHeader confidence="0.726579">
2.1 PRELIMINARIES
</subsectionHeader>
<bodyText confidence="0.977249083333333">
Different formalisms in which rewriting is applied
independently of the context have been proposed in
computational linguistics for the treatment of Nat-
ural Language, where the definition of elementary
rewriting operation varies from system to system.
The class of linear context-free rewriting systems
(LCFRS) has been defined in [Vijay-Shanker et al.,
1987] with the intention of capturing through a gen-
eralization common properties that are shared by all
these formalisms.
The basic idea underlying the definition of LCFRS
is to impose two major restrictions on rewriting.
First of all, rewriting operations are applied in the
derivation of a string in a way that is independent of
the context. As a second restriction, rewriting op-
erations are generalized by means of abstract com-
position operations that are linear and nonerasing.
In a LCFR system, both restrictions are realized by
defining an underlying context-free grammar where
each production is associated with a function that
encodes a composition operation having the above
properties. The following definition is essentially the
same as the one proposed in [Vijay-Shanker et al.,
1987].
</bodyText>
<construct confidence="0.948993842105263">
Definition 1 A rewriting system G = (VN, VT,
P,5) is a linear context-free rewriting system if:
(i) VN is a finite set of nonterminal symbols, VT is
a finite set of terminal symbols, S E VN is the
start symbol; every symbol A E VN is associated
with an integer yo(A) &gt; 0, called the fan-out of
A;
(ii) P is a finite set of productions of the form A
f (B1) B2, • • Br), r &gt; 0, A, Bi E VN, 1 &lt; i &lt;
r, with the following restrictions:
(a) f is a function in CD, where D = (Vit)1&apos; ,
IP is the sum of the fan-out of all B1 &apos;s and
C = (V4)`P(A) ;
(b) f (X1,1) • • 121,4)030) • • • ,Zr,4p(Br))
= (Y1) • • • Mp(A)) is defined by some
grouping into (p(A) sequences of all
and only the elements in the sequence
&gt; 0, where
E VT, 1 &lt; &lt; cr.
</construct>
<bodyText confidence="0.99117845">
The languages generated by LCFR systems are
called LCFR languages. We assume that the start-
ing symbol has unitary fan-out. Every LCFR sys-
tem G is naturally associated with an underlying
context-free grammar G. The usual context-free
derivation relation, written •G., , will be used in
the following to denote underlying derivations in G.
We will also use the reflexive and transitive closure
of such a relation, written G. . As a convention,
whenever the evaluation of all functions involved in
an underlying derivation starting with A results in
a so(A)-tuple w of terminal strings, we will say that
A derives w and write A &apos;.•G w. Given a nonter-
minal A E VN, the language L(A) is the set of all
(p(A)-tuples w such that A t,G w. The language
generated by G, L(G), is the set L(S). Finally, we
will call LCFRS(k) the class of all LCFRS&apos;s with
fan-out bounded by k, k &gt; 0 and r-LCFRS the class
of all LCFRS&apos;s whose productions have right-hand
side length bounded by r, r &gt; 0.
</bodyText>
<subsectionHeader confidence="0.819558">
2.2 HARDNESS FOR NP
</subsectionHeader>
<bodyText confidence="0.987742454545455">
The membership problem for the class of linear
context-free rewriting systems is represented by
means of a formal language LRM as follows. Let
G be a grammar in LCFRS and w be a string in
for some alphabet I/4 ; the pair (G, w) belongs
to LRM if and only if w E L(G). Set LRM naturally
represents the problem of the recognition of a linear
context-free rewriting language when we take into
account both the grammar and the string as input
variables. In the following we will also study the de-
cision problems LRM(k) and r-LRM, defined in the
obvious way. The next statement is a characteriza-
tion of r-LRM.
Theorem 1 3SAT &lt;p 1-LRM.
Outline of the proof. Let (U, C) be an arbitrary in-
stance of the 3SAT problem, where U = {ul, , up}
is a set of variables and C = {ci, cu} is a set
of clauses; each clause in C is represented by a
string of length three over the alphabet of all lit-
erals, Lu = • • • ,up,irp}. The main idea in
the following reduction is to use the derivations of
the grammar to guess truth assignments for U and to
</bodyText>
<page confidence="0.988825">
90
</page>
<bodyText confidence="0.9997724">
use the fan-out of the nonterminal symbols to work
out the dependencies among different clauses in C.
For every 1 &lt; k &lt; p, let Ak = {C1 j uk is a
substring of ci} and let Ak = {ci IIlk is a substring
of c7}; let also w = c1c2 cn. We define a linear
context-free rewriting system G = (VN, C, P, S) such
that VN = {Ti,Fi ii &lt; i &lt; p 1} U {S}, every
nonterminal (but S) has fan-out n and P contains
the following productions (f/ denotes the identity
function on (C*)&amp;quot;):
</bodyText>
<equation confidence="0.747913">
(i) S --+ fo(Ti),
S fo(F1),
</equation>
<bodyText confidence="0.782787">
where fo(xi, • • • , xn) = xi • • • xn;
(ii) for every 1 &lt; k &lt;p and for every ci E Ak:
</bodyText>
<construct confidence="0.708882666666667">
Tk f(71),
Tk fl(Tk-I-1),
Tk fl(Fk-1-1),
</construct>
<bodyText confidence="0.7581525">
where fli)(xi , .,x) = (21, , zjci , ,x,);
(iii) for every 1 &lt;k &lt;p and for every ci E Ak:
</bodyText>
<construct confidence="0.8490646">
5)
Fk k 1,
Fk -4 fl(Tk+1))
Fk fl(Fk4.1),
&amp;quot;-CO/
</construct>
<bodyText confidence="0.988669">
where fk xn) = • •
</bodyText>
<equation confidence="0.5905455">
(iv) • 19+10,
F9+1 -419+10,
</equation>
<bodyText confidence="0.99838903508772">
where f+&apos;0 = (e, .,&amp;).
From the definition of G it directly follows that w E
L(G) implies the existence of a truth-assignment
that satisfies C. The converse fact can be shown
starting from a truth assignment that satisfies C and
constructing a derivation for w using (finite) induc-
tion on the size of U. The fact that (C, w) can be
constructed in polynomial deterministic time is also
(.)
straightforward (note that each function fk). or fk
in G can be specified by an integer j, 1 &lt; j &lt; n).
The next result is a characterization of LRM(k)
for every k &gt; 2.
Theorem 2 3SAT &lt;p LRM(2).
Outline of the proof Let (U, C) be a generic in-
stance of the 3SAT problem, U = {ul, , up} and
C = {c1, , cm} being defined as in the proof of
Theorem 1. The idea in the studied reduction is
the following. We define a rather complex string
w(1)w(2) w(P)w, where wc is a representation of
the set C and w(1) controls the truth assignment for
the variable ui, 1 &lt; i &lt; p. Then we construct a
grammar G such that tv(&apos;) can be derived by G only
in two possible ways and only by using the first string
components of a set of nonterminals MO of fan-out
two. In this way the derivation of the substring
w(l)w(2) w(P) by nonterminals NW, ,N(P) cor-
responds to a guess of a truth assignment for U.
Most important, the right string components of non-
terminals in N(1) derive the symbols within to, that
are compatible with the truth-assignment chosen for
u. In the following we specify the instance (G, w)
of LRM(2) that is associated to (U, C) by our reduc-
tion.
For every 1 &lt; i&lt; p, let Ai = {ci J ui is in-
cluded in ci} and Ai = Tti is included in ci};
let also mi = I A I + lAi I. Let Q = {a1, b1 I 1 &lt;
i &lt; p} be an alphabet of not already used sym-
bols; for every 1 &lt; i &lt; p, let w(i) denote a se-
quence of raj + 1 alternating symbols ai and b, i.e.
w(i) E (aibi)+ U(aibi)*ai. Let G = (VN,QUC, P, S);
we define VN = IS) U {4) I 1 &lt; i &lt; p, 1 &lt;
j &lt; Ind and w = w(l)w(2) w(P)cic2 cm. In
order to specify the productions in P, we need to
introduce further notation. We define a function
a such that, for every 1 &lt; i &lt; p, the clauses
ca(0),ca(0), ca(,,pisi) are all the clauses in .41
and the clauses ca(ciA,1+1), ...ca(i,„20 are all the
clauses in Ai. For every 1 &lt; i &lt;p, let 7(i,1) = ail);
and let 7(1, h) = ai (resp. bi) if h is even (resp. odd),
2 &lt; h &lt; TN; let also -7(i, h) = a (resp. bi) if h is odd
(resp. even), 1 &lt; h &lt; mi —1, and let.7(i, TN) = aibi
(resp. biai) if m, is odd (resp. even). Finally, let
z = EL, mi. The following productions define set
P (the example in Figure 1 shows the two possible
ways of deriving by means of P the substring w(1)
and the corresponding part of c1 • cri).
</bodyText>
<figure confidence="0.935815125">
(i) for every 1 5_ i
(a) for 1 &lt;h
(i)
Ah
(b) for +
A(1)
A(hi)
(ii) S f (A(11) ,
</figure>
<page confidence="0.783821">
91
</page>
<figureCaption confidence="0.97690375">
Figure 1: Let .4; = {ci,,ci,} and Ai = {ci,,ci,}. String w(i) can be derived in only two possible ways in G,
corresponding to the choice ui = true&apos; false. This forces the grammar to guess a subset of the clauses contained in
Ail Ai, in such a way that all of the clauses in C are derived only once if and only if there exists a truth-assignment
that satisfies C.
</figureCaption>
<figure confidence="0.903714333333333">
• • •
Ch C12 . . . Cj3 . . . Cj4 . . .
IAA
A1 A2 A3 A4
C,3, E
Cj4, E
</figure>
<bodyText confidence="0.9827645">
where f is a function of 2z string variables de-
fined as
</bodyText>
<equation confidence="0.864875">
.f(0(1&amp;quot;, Yi&amp;quot;, • • • 41!
xi X2 • • • rrni • • • rrn,Y1Y2 • • • tin
</equation>
<bodyText confidence="0.999125272727273">
and for every 1 &lt; i &lt; n, yi is any sequence of
all variables Vhi) such that ct(i,h)= j.
It is easy to see that I G I and 1w I are polynorni-
ally related to I UI and IC I. From a derivation of
w E L(G), we can exhibit a truth assignment that
satisfies C simply by reading the derivation of the
prefix string wWw(2) w(P). Conversely, starting
from a truth assignment that satisfies C we can prove
w E L(G) by means of (finite) induction on 1U1: this
part requires a careful inspection of all items in the
definition of G. 0
</bodyText>
<subsectionHeader confidence="0.637066">
2.3 COMPLETENESS FOR NP
</subsectionHeader>
<bodyText confidence="0.997200346938776">
The previous results entail NP-hardness for the de-
cision problem represented by language LRM; here
we are concerned with the issue of NP-completeness.
Although in the general case membership of LRM
in NP remains an open question, we discuss in the
following a normal form for the class LCFRS that
enforces completeness for NP (i.e. the proposed nor-
mal form does not affect the hardness result dis-
cussed above). The result entails NP-completeness
for problems r-LRM (r &gt; 1) and LRM(k) (k &gt; 2).
We start with some definitions. In a lin-
ear context-free rewriting system G, a derivation
w such that w is a tuple of null strings is
called a null derivation. A cyclic derivation has the
underlying form A G. otAft, where both a and )9
derive tuples of empty strings and the overall ef-
fect of the evaluation of the functions involved in
the derivation is a bare permutation of the string
components of tuples in L(A) (no recombination of
components is admitted). A cyclic derivation is min-
imal if it is not composed of other cyclic deriva-
tions. Because of null derivations in G, a deriva-
tion A w can have length not bounded by any
polynomial in I G I; this peculiarity is inherited from
context-free languages (see for example [Sippu and
Soisalon-Soininen, 1980. The same effect on the
length of a derivation can be caused by the use of
cyclic subderivations: in fact there exist permuta-
tions of k elements whose period is not bounded by
any polynomial in k. Let .11. and C be the set of all
nonterrninals that can start a null or a cyclic deriva-
tion respectively; it can be shown that both these
sets can be constructed in deterministic polynomial
time by using standard algorithms for the computa-
tion of graph closure.
For every A E C, let C(A) be the set of all permu-
tations associated with minimal cyclic productions
starting with A. We define a normal form for the
class LCFRS by imposing some bound on the length
of minimal cyclic derivations: this does not alter the
weak generative power of the formalism, the only
consequence being the one of imposing some canon-
ical base for (underlying) cyclic derivations. On the
basis of such a restriction, representations for sets
C(A) can be constructed in deterministic polynomial
time, again by graph closure computation.
Under the above assumption, we outline here a
proof of LRMENP. Given an instance (G, w) of the
LRM problem, a nondeterministic Turing machine
</bodyText>
<page confidence="0.990037">
92
</page>
<bodyText confidence="0.970847">
M can decide whether w E L(G) in time polynomial
in I (G, w) I as follows. M guesses a &amp;quot;compressed&amp;quot;
representation p for a derivation S 4G w such that:
</bodyText>
<listItem confidence="0.9392955">
(i) null subderivations within p&apos; are represented by
just one step in p, and
(ii) cyclic derivations within p&apos; are represented in
p by just one step that is associated with a
guessed permutation of the string components
of the involved tuple.
</listItem>
<bodyText confidence="0.999905111111111">
We can show that p is size bounded by a polynomial
in I (G,w) I. Furthermore, we can verify in determin-
istic polynomial time whether p is a valid derivation
of w in G. The not obvious part is verifying the
permutation guessed in (ii) above. This requires a
test for membership in the group generated by per-
mutations in C(A): such a problem can be solved
in deterministic polynomial time (see [Furst et al.,
1980]).
</bodyText>
<sectionHeader confidence="0.999951" genericHeader="method">
3 IMPLICATIONS
</sectionHeader>
<bodyText confidence="0.999926818181818">
In the previous section we have presented general
results regarding the membership problem for two
subclasses of the class LCFRS. Here we want to
discuss the interesting status of &amp;quot;crossing depen-
dencies&amp;quot; within formal languages, on the base of
the above results. Furthermore, we will also derive
some observations concerning the existence of highly
efficient algorithms for the recognition of fan-out
and production-length bounded LCFR languages, a
problem which is already known to be in the class
P.
</bodyText>
<sectionHeader confidence="0.9154045" genericHeader="method">
3.1 CROSSING
CONFIGURATIONS
</sectionHeader>
<bodyText confidence="0.999971803921569">
As seen in Section 2, LCFRS(2) is the class of all
LCFRS of fan-out bounded by two, and the mem-
bership problem for the corresponding class of lan-
guages is NP-complete. Since LCFRS(1) = CFG
and the membership problem for context-free lan-
guages is in P, we want to know what is added to
the definition of LCFRS(2) that accounts for the dif-
ference (assuming that a difference exists between P
and NP). We show in the following how a binary
relation on (sub)strings derived by a grammar in
LCFRS(2) is defined in a natural way and, by dis-
cussing the previous result, we will argue that the
additional complexity that is perhaps found within
LCFRS(2) is due to the lack of constraints on the
way pairs of strings in the defined relation can be
composed within these systems.
Let G E LCFRS(2); in the general case, any non-
terminal in G having fan-out two derives a set of
pair of strings; these sets define a binary relation
that is called here co-occurrence. Given two pairs
(wi, wl) and (w2, wD of strings in the co-occurrence
relation, there are basically two ways of composing
their string components within a rule of G: either
by nesting (wrapping) one pair within the other,
e.g. wi w2/401, or by creating a crossing configu-
ration, e.g. wi w2wc .14; note how in a crossing con-
figuration the co-occurrence dependencies between
the substrings are &amp;quot;crossed&amp;quot;. A close inspection
of the construction exhibited by Theorem 2 shows
that grammars containing an unbounded number of
crossing configurations can be computationally com-
plex if no restriction is provided on the way these
configurations are mutually composed. An intuitive
idea of why such a lack of restriction can lead to the
definition of complex systems is given in the follow-
ing.
In [Seki et al., 1989] a tabular method has been
presented for the recognition of general LCFR lan-
guages as a generalization of the well known CYK
algorithm for the recognition of CFG&apos;s (see for in-
stance [Younger, 1967] and [Aho and Ullman, 1972]).
In the following we will apply such a general method
to the recognition of LCFRS(2), with the aim of hav-
ing an intuitive understanding of why it might be dif-
ficult to parse unrestricted crossing configurations.
Let w be an input string of length n. In Figure 2,
the case of a production pi : A -4. f(Bi, B2, . , Br)
is depicted in which a number r of crossing con-
figurations are composed in a way that is easy to
recognize; in fact the right-hand side of pi can be
recognized step by step. For a symbol X, assume
</bodyText>
<figure confidence="0.364797">
B2
</figure>
<figureCaption confidence="0.909763">
Figure 2: Adjacent crossing configurations defining
</figureCaption>
<bodyText confidence="0.973167">
a production pi : A f (B , B2, . , Br) where each
of the right-hand side nonterminals has fan-out two.
that the sequence X, (ii, i2), , (iq_i, ig) means X
derives the substrings of w that matches the po-
sitions (i1,12), , (19_1, ig) within w; assume also
that AM denotes the result of the t-th step in the
recognition of pi&apos;s right-hand side, 1 &lt;t &lt;r. Then
each elementary step in the recognition of pi can
</bodyText>
<page confidence="0.997215">
93
</page>
<bodyText confidence="0.9969965">
be schematically represented as an inference rule as
follows:
</bodyText>
<equation confidence="0.922742666666667">
A[t], it+1),
Bt+1, (it+1 4+2)) (.it-1-1. it-I-2) (1)
A[i (ii 14+2)) (71.)it+2)
</equation>
<bodyText confidence="0.981436333333333">
The computation in (1) involves six indices ranging
over {1..n}; therefore in the recognition process such
step will be computed no more than 0(n6) times.
</bodyText>
<figureCaption confidence="0.994116">
Figure 3: Sparse crossing configurations defining a
</figureCaption>
<bodyText confidence="0.996725866666667">
production p2 : A -0 f(Bi, B2, , B,.); every non-
terminal Bi has fan-out two.
On the contrary, Figure 3 presents a production P2
defined in such a way that its recognition is consider-
ably more complex. Note that the co-occurrence of
the two strings derived by B1 is crossed once, the co-
occurrence of the two strings derived by B2 is crossed
twice, and so on; in fact crossing dependencies in p2
are sparse in the sense that the adjacency property
found in production pi is lost. This forces a tabular
method as the one discussed above to keep track of
the distribution of the co-occurrences recognized so
far, by using an unbounded number of index pairs.
Few among the first steps in the recognition of p2&apos;s
right-hand side are as follows:
</bodyText>
<equation confidence="0.912369888888889">
A[2], (i1, i4), i6)
B3, (i4, i3), (i8, i3)
A[3], (i1, is), (i8, is)
A[3], (i1, i6), (i8, i6)
B41 (1.6, 1&apos;7)) (ill
A[4], (i1) i7), (i8) i9)) (ill )42)
A[4], (i1)4), (i8, is), (i11, in)
B5, (i7, i8), (i13, i14) (2)
A[5], (i1,4), (i11, i12), i14)
</equation>
<bodyText confidence="0.999950347826087">
From Figure 3 we can see that a different order in
the recognition of A by means of production p2 will
not improve the computation.
Our argument about crossing configurations
shows why it might be that recognition/parsing of
LCFRS(2) cannot be done efficiently. If this is true,
we have a gap between LCFR systems and well
known mildly context-sensitive formalisms whose
membership problem is known to have polynomial
solutions. We conclude that, in the general case, the
addition of restrictions on crossing configurations
should be seriously considered for the class LCFRS.
As a final remark, we derive from Theorem 2 a
weak generative result. An open question about
LCFRS(k) is the existence of a canonical bilinear
form: up to our knowledge no construction is known
that, given a grammar G E LCFRS(k) returns
a weakly equivalent grammar G&apos; E 2-LCFRS(k).
Since we know that the membership problem for
2-LCFRS(k) is in P, Theorem 2 entails that the
construction under investigation cannot take poly-
nomial time, unless P=NP. The reader can easily
work out the details.
</bodyText>
<subsectionHeader confidence="0.93785">
3.2 RECOGNITION OF r-LCFRS(k)
</subsectionHeader>
<bodyText confidence="0.999868222222222">
Recall from Section 2 that the class r-LCFRS(k) is
defined by the simultaneous imposition to the class
LCFRS of bounds k and r on the fan-out and on the
length of production&apos;s right-hand side respectively.
These classes have been discussed in [Vijay-Shanker
et al., 19871, where the membership problem for the
corresponding languages has been shown to be in
P, for every fixed k and p. By introducing the no-
tion of degree of a grammar in LCFRS, actual poly-
nomial upper-bounds have been derived in [Seki et
al., 1989]: this work entails the existence of an inte-
ger function u(r, k) such that the membership prob-
lem for r-LCFRS(k) can be solved in (deterministic)
time 0(1011w1ufr&apos;k)). Since we know that the mem-
bership problems for r-LCFRS and LCFRS(k) are
NP-hard, the fact that u(r, k) is a (strictly increas-
ing) non-asymptotic function is quite expected.
With the aim of finding efficient parsing al-
gorithms, in the following we want to know to
which extent the polynomial upper-bounds men-
tioned above can be improved. Let us consider for
the moment the class 2-LCFRS(k); if we restrict our-
selves to the normal form discussed in Section 2.3,
we know that the recognition problem for this class
is NP-complete. Assume that we have found an op-
timal recognizer for this class that runs in worst case
time 1(G, w, k); therefore function 1 determines the
best lower-bound for our problem. Two cases then
arises. In a first case we have that 1 is not bounded
by any polynomial p in I G 1 and 1w I: we can eas-
ily derive that PONP. In fact if the converse is true,
then there exists a Turing machine M that is able to
recognize 2-LCFRS in deterministic time I (0, w)Ig ,
for some q. For every k &gt; 0, construct a Turing
machine M(k) in the following way. Given (0, w) as
input, M(k) tests whether G E2-LCFRS(k) (which
</bodyText>
<page confidence="0.997831">
94
</page>
<bodyText confidence="0.9998965">
is trivial); if the test fails, M(k) rejects, otherwise
it simulates M on input (G, w). We see that M(k)
is a recognizer for the class 2-LCFRS(k) that runs
in deterministic time I (G, w) Iq•Now select I such
that, fora worst case input w E E* and G E 2-
LCFRS(k), we have 1 (G , w &gt; I (G , w) lq : we have
a contradiction, because M(k) will be a recognizer
for 2-LCFRS(k) that runs in less than the lower-
bound claimed for this class. In the second case, on
the other hand, we have that 1 is bounded by some
polynomial p in I G I and I w I; a similar argument
applies, exhibiting a proof that P=NP.
From the previous argument we see that finding
the &amp;quot;best&amp;quot; recognizer for 2-LCFRS(k) is as difficult
as solving the P vs. NP question, an extremely dif-
ficult problem. The argument applies as well to r-
LCFRS(k) in general; we have then evidence that
considerable improvement of the known recognition
techniques for r-LCFRS(k) can be a very difficult
task.
</bodyText>
<sectionHeader confidence="0.999995" genericHeader="conclusions">
4 CONCLUSIONS
</sectionHeader>
<bodyText confidence="0.999922785714286">
We have studied the class LCFRS along two dimen-
sions: the fan-out and the maximum right-hand side
length. The recognition (membership) problem for
LCFRS has been investigated, showing NP-hardness
in all three cases in which at least one of the two di-
mensions above is unbounded. Some consequences
of the main result have been discussed, among which
the interesting relation between crossing configura-
tions and parsing efficiency: it has been suggested
that the addition of restrictions on these configu-
rations should be seriously considered for the class
LCFRS. Finally, the issue of the existence of effi-
cient algorithms for the class r-LCFRS(k) has been
addressed.
</bodyText>
<sectionHeader confidence="0.999204" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.99388826">
[Aho and Ullman, 1972] A. V. Aho and J. D. Ull-
man. The Theory of Parsing, Translation and
Compiling, volume 1. Prentice-Hall, Englewood
Cliffs, NJ, 1972.
[Furst et al., 1980] M. Furst, J. Hoperoft, and
E. Luks. Polynomial-time algorithms for permu-
tation groups. In Proceedings of the 21 th IEEE
Annual Symposium on the Foundations of Com-
puter Science, 1980.
[Joshi et al., 1991] A. Joshi, K. Vijay-Shanker, and
D. Weir. The convergence of mildly context-
sensitive grammatical formalisms. In P. Sells,
S. Shieber, and T. Wasow, editors, Foundational
Issues in Natual Language Processing. MIT Press,
Cambridge MA, 1991.
[Kasami et al., 1987] T. Kasami, H. Seki, and
M. Fujii. Generalized context-free grammars, mul-
tiple context-free grammars and head grammars.
Technical report, Osaka University, 1987.
[Pollard, 1984] C. Pollard. Generalized Phrase
Structure Grammars, Head Grammars and Nat-
ural Language. PhD thesis, Stanford University,
1984.
[Seki et al., 1989] H. Seki, T. Matsumura, M. Fujii,
and T. Kasami. On multiple context-free gram-
mars. Draft, 1989.
[Sippu and Soisalon-Soininen, 1988] S. Sippu and
E. Soisalon-Soininen. Parsing Theory: Languages
and Parsing, volume 1. Springer-Verlag, Berlin,
Germany, 1988.
[Vijay-Shanker and Weir, 1992]
K. Vijay-Shanker and D. J. Weir. Parsing con-
strained grammar formalisms, 1992. To appear in
Computational Linguistics.
[Vijay-Shanker et aL, 1987] K. Vijay-Shanker, D. J.
Weir, and A. K. Joshi. Characterizing structural
descriptions produced by various grammatical for-
malisms. In 25&amp;quot; Meeting of the Association for
Computational Linguistics (ACL &apos;87), 1987.
[Vijay-Shanker, 1987] K. Vijay-Shanker. A Study of
Tree Adjoining Grammars. PhD thesis, Depart-
ment of Computer and Information Science, Uni-
versity of Pennsylvania, 1987.
[Weir, 1988] D. J. Weir. Characterizing Mildly
Context-Sensitive Grammar Formalisms. PhD
thesis, Department of Computer and Information
Science, University of Pennsylvania, 1988.
[Younger, 1967] D. H. Younger. Recognition and
parsing of context-free languages in time n3. In-
formation and Control, 10:189-208, 1967.
</reference>
<page confidence="0.999019">
95
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.969023">
<title confidence="0.990232">RECOGNITION OF LINEAR CONTEXT-FREE REWRITING SYSTEMS*</title>
<author confidence="0.999877">Giorgio Satta</author>
<affiliation confidence="0.9998335">Institute for Research in Cognitive Science University of Pennsylvania</affiliation>
<address confidence="0.999228">Philadelphia, PA 19104-6228, USA</address>
<email confidence="0.999835">gsattaalinc.cis.upenn.edu</email>
<abstract confidence="0.99925">The class of linear context-free rewriting systems has been introduced as a generalization of a class of grammar formalisms known as mildly context-sensitive. The recognition problem for linear context-free rewriting languages is studied at length here, presenting evidence that, even in some restricted cases, it cannot be solved efficiently. This entails the existence of a gap between, for example, tree adjoining languages and the subclass of linear context-free rewriting languages that generalizes the former class; such a gap is attributed to &amp;quot;crossing configurations&amp;quot;. A few other interesting consequences of the main result are discussed, that concern the recognition problem for linear context-free rewriting languages.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>A V Aho</author>
<author>J D Ullman</author>
</authors>
<title>The Theory of Parsing,</title>
<date>1972</date>
<journal>Translation and Compiling,</journal>
<volume>1</volume>
<publisher>Prentice-Hall,</publisher>
<location>Englewood Cliffs, NJ,</location>
<marker>[Aho and Ullman, 1972]</marker>
<rawString>A. V. Aho and J. D. Ullman. The Theory of Parsing, Translation and Compiling, volume 1. Prentice-Hall, Englewood Cliffs, NJ, 1972.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Furst</author>
<author>J Hoperoft</author>
<author>E Luks</author>
</authors>
<title>Polynomial-time algorithms for permutation groups.</title>
<date>1980</date>
<booktitle>In Proceedings of the 21 th IEEE Annual Symposium on the Foundations of Computer Science,</booktitle>
<marker>[Furst et al., 1980]</marker>
<rawString>M. Furst, J. Hoperoft, and E. Luks. Polynomial-time algorithms for permutation groups. In Proceedings of the 21 th IEEE Annual Symposium on the Foundations of Computer Science, 1980.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Joshi</author>
<author>K Vijay-Shanker</author>
<author>D Weir</author>
</authors>
<title>The convergence of mildly contextsensitive grammatical formalisms. In</title>
<date>1991</date>
<booktitle>Foundational Issues in Natual Language Processing.</booktitle>
<editor>P. Sells, S. Shieber, and T. Wasow, editors,</editor>
<publisher>MIT Press,</publisher>
<location>Cambridge MA,</location>
<marker>[Joshi et al., 1991]</marker>
<rawString>A. Joshi, K. Vijay-Shanker, and D. Weir. The convergence of mildly contextsensitive grammatical formalisms. In P. Sells, S. Shieber, and T. Wasow, editors, Foundational Issues in Natual Language Processing. MIT Press, Cambridge MA, 1991.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Kasami</author>
<author>H Seki</author>
<author>M Fujii</author>
</authors>
<title>Generalized context-free grammars, multiple context-free grammars and head grammars.</title>
<date>1987</date>
<tech>Technical report,</tech>
<institution>Osaka University,</institution>
<marker>[Kasami et al., 1987]</marker>
<rawString>T. Kasami, H. Seki, and M. Fujii. Generalized context-free grammars, multiple context-free grammars and head grammars. Technical report, Osaka University, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Pollard</author>
</authors>
<title>Generalized Phrase Structure Grammars, Head Grammars and Natural Language. PhD thesis,</title>
<date>1984</date>
<institution>Stanford University,</institution>
<marker>[Pollard, 1984]</marker>
<rawString>C. Pollard. Generalized Phrase Structure Grammars, Head Grammars and Natural Language. PhD thesis, Stanford University, 1984.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Seki</author>
<author>T Matsumura</author>
<author>M Fujii</author>
<author>T Kasami</author>
</authors>
<title>On multiple context-free grammars.</title>
<date>1989</date>
<location>Draft,</location>
<marker>[Seki et al., 1989]</marker>
<rawString>H. Seki, T. Matsumura, M. Fujii, and T. Kasami. On multiple context-free grammars. Draft, 1989.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Sippu</author>
<author>E Soisalon-Soininen</author>
</authors>
<title>Parsing Theory: Languages and Parsing,</title>
<date>1988</date>
<volume>1</volume>
<publisher>Springer-Verlag,</publisher>
<location>Berlin, Germany,</location>
<marker>[Sippu and Soisalon-Soininen, 1988]</marker>
<rawString>S. Sippu and E. Soisalon-Soininen. Parsing Theory: Languages and Parsing, volume 1. Springer-Verlag, Berlin, Germany, 1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shanker</author>
<author>D J Weir</author>
</authors>
<title>Parsing constrained grammar formalisms,</title>
<date>1992</date>
<note>To appear in Computational Linguistics.</note>
<marker>[Vijay-Shanker and Weir, 1992]</marker>
<rawString> K. Vijay-Shanker and D. J. Weir. Parsing constrained grammar formalisms, 1992. To appear in Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shanker</author>
<author>D J Weir</author>
<author>A K Joshi</author>
</authors>
<title>Characterizing structural descriptions produced by various grammatical formalisms.</title>
<date>1987</date>
<booktitle>In 25&amp;quot; Meeting of the Association for Computational Linguistics (ACL &apos;87),</booktitle>
<marker>[Vijay-Shanker et aL, 1987]</marker>
<rawString>K. Vijay-Shanker, D. J. Weir, and A. K. Joshi. Characterizing structural descriptions produced by various grammatical formalisms. In 25&amp;quot; Meeting of the Association for Computational Linguistics (ACL &apos;87), 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shanker</author>
</authors>
<title>A Study of Tree Adjoining Grammars.</title>
<date>1987</date>
<tech>PhD thesis,</tech>
<institution>Department of Computer and Information Science, University of Pennsylvania,</institution>
<marker>[Vijay-Shanker, 1987]</marker>
<rawString>K. Vijay-Shanker. A Study of Tree Adjoining Grammars. PhD thesis, Department of Computer and Information Science, University of Pennsylvania, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D J Weir</author>
</authors>
<title>Characterizing Mildly Context-Sensitive Grammar Formalisms.</title>
<date>1988</date>
<tech>PhD thesis,</tech>
<institution>Department of Computer and Information Science, University of Pennsylvania,</institution>
<marker>[Weir, 1988]</marker>
<rawString>D. J. Weir. Characterizing Mildly Context-Sensitive Grammar Formalisms. PhD thesis, Department of Computer and Information Science, University of Pennsylvania, 1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D H Younger</author>
</authors>
<title>Recognition and parsing of context-free languages</title>
<date>1967</date>
<booktitle>in time n3. Information and Control,</booktitle>
<pages>10--189</pages>
<marker>[Younger, 1967]</marker>
<rawString>D. H. Younger. Recognition and parsing of context-free languages in time n3. Information and Control, 10:189-208, 1967.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>