<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.016213">
<title confidence="0.740151">
XML in a Web-based Grammar Development Environment
</title>
<author confidence="0.743345">
Eugene Koontz
</author>
<note confidence="0.778896333333333">
151 Calderon Ave Apt #125
Mountain View CA 94041
ekoontz©hiro-tan.org
</note>
<sectionHeader confidence="0.989815" genericHeader="abstract">
1 Introduction
</sectionHeader>
<bodyText confidence="0.995921941176471">
Example-based Development of Grammars
(EDG) is a natural language parsing and gram-
matical knowledge representation system, im-
plemented in Common Lisp, that uses XML to
display its output. The system parses sentences
and allows querying and editing of its linguis-
tic knowledge base. The system&apos;s response to
user input is in XML, which is then transformed
by an XSLT processor to form HTML, which
is then displayed by the user&apos;s browser. The
XML dialect used by the system to represent
linguistic structure is described, together with
details of how the XSLT stylesheet transforms
it into HTML. Further information about the
system, including an interactive demonstration
of the system, may be found on the Web at
http://edg.sf.net
</bodyText>
<subsectionHeader confidence="0.9664">
1.1 Background
</subsectionHeader>
<bodyText confidence="0.9995635625">
EDG is an implementation of Head Driven
Phrase Structure Grammar (HPSG) as de-
scribed in (Pollard and Sag, 1994). HPSG
posits a uniform representation of syntactic
structure and semantics using feature struc-
tures, which are sets of feature-value pairs. Fea-
ture structures are used to represent all linguis-
tic knowledge, both lexical and grammatical,
and these structures are organized hierarchi-
cally in a type hierarchy. Typed feature struc-
tures and the type hierarchy obey certain math-
ematical constraints (Carpenter, 1992). Below
we discuss how these data structures are repre-
sented in XML form, and how the XML rep-
resentations are transformed into HTML via
XSLT.
</bodyText>
<subsectionHeader confidence="0.711472">
1.2 User Interface
</subsectionHeader>
<bodyText confidence="0.9972265">
A web-based client-server grammar develop-
ment model has a number of attractive features:
</bodyText>
<listItem confidence="0.994271181818182">
• It is cross-platform; ideally any client able
to run a web browser should be able to use
to the system.
• It allows multiple users to connect to
the system simultaneously. Existing http
mechanisms such as cookies can be used to
save user state and allow multiple users to
edit a single grammar and lexicon concur-
rently.
• HTML (in particular, the &lt;table&gt; tag) is
well suited for representing complex data
</listItem>
<bodyText confidence="0.850454333333333">
structures such as parse trees and typed
feature structures. XSLT allows a straight-
forward mapping between the linguistic
data (grammar, lexicon, etc) in XML, and
their graphical representation in HTML. In
section 4 we discuss this mapping in detail.
</bodyText>
<sectionHeader confidence="0.889189" genericHeader="categories and subject descriptors">
2 System Architecture
</sectionHeader>
<bodyText confidence="0.99866145">
Figure 1 shows the flow of information through
the system, sequentially ordered as follows. Us-
ing a web browser, a user sends information
via http to a web server. The web server then
invokes a CGI (Common Gateway Interface)
script that translates the http request to a Lisp
s-expression. This expression is passed over a
socket to the core of the EDG system, the Lin-
guistic Engine (LE), which is a Lisp program
that does all linguistic processing. After re-
ceiving the s-expression from the web server&apos;s
CGI script, the LE evaluates the expression ac-
cording to its lexicon and grammar. The s-
expression could be a request to parse a sen-
tence, a query on the lexicon/grammar, or a
command to update the lexicon/grammar, as
described in detail in Section 5. The LE re-
turns its evaluation in the form of an XML
document to the CGI script, which then trans-
forms this XML document according to an
</bodyText>
<figure confidence="0.999786123287671">
HTTP
POST/GET
web
browser
HTML
language engine
s−expression
XML
web server/
XSL transformer
HEADED-COMP-PHRASE-2
MARKING-PRINCIPLE-3
1 T822
T823
1 T822
T800
VP-3 2 VP-1
VP-2 2 VP-1
about this demo
LINEAR-ORDER-1
vp-2
SYNSEM t798
t796
t204
QUANTS quantifier-list
sleep-relation
LOCAL t308
CONTENT 1 PERSON third-person
NUCLEUS SLEEPER 2
NUMBER singular
GENDER masc
RELN sleep-rel
RETRIEVED quantifier-list
QSTORE quantifier-set
PHON &amp;quot;hiro sleeps &amp;quot;
sleeps
t314
t312
LOCAL
t310
RESTR psoa-eset
t241
t239
SYNSEM
CONTENT 1
LOCAL
CONTENT
INDEX 2
RETRIEVED quantifier-list
QSTORE quantifier-set
hiro
SYNSEM
RETRIEVED quantifier-list
QSTORE quantifier-set
PHON &amp;quot;hiro&amp;quot;
6
PHON &amp;quot;sleeps&amp;quot;
&lt;xsl:template match=&amp;quot;object&amp;quot;›
&lt;xsl:when
test=&amp;quot;feature[Oname=&apos;DAUGHTERS&apos;]&amp;quot;›
&lt;/xsl:when&gt;
&lt;xsl:otherwise&gt;
&lt;table border=&amp;quot;1&amp;quot;›
&lt;tr&gt;
&lt;td&gt;
&lt;xsl:value-of select=&amp;quot;Qtype&amp;quot;/&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;xsl:apply-templates
select=&amp;quot;feature&amp;quot;/&gt;
&lt;/table&gt;
&lt;/xsl:otherwise&gt;
&lt;/xsl:template&gt;
</figure>
<figureCaption confidence="0.974656">
Figure 7: XSLT template for the object ele-
ment
</figureCaption>
<bodyText confidence="0.986474041666667">
call each other to recursively output the HTML
for the feature structure.
First, consider the object template. (For
now, ignore the test at the beginning; this will
be discussed below in section 4.2.) This tem-
plate (within the xs1: otherwise element) first
creates a HTML table, and then writes out,
as the table&apos;s first row, the type of the object.
Next, it applies the feature template to every
feature element in the object.
Now we turn to the feature template. Note
that every feature element is wrapped in a &lt;tr&gt;
(table row) HTML element. This corresponds
to a separate table row within the &lt;table&gt; of
the object in which this feature is contained.
Each table row contains two cells : the first
is the feature name; the second is the feature
value. The second cell is populated by call-
ing the object template on the object ele-
ment within this feature. For feature values
that are atomic (not containing features them-
selves), there are separate templates not shown
here. Also omitted for brevity are the rendering
of index tags.
</bodyText>
<subsectionHeader confidence="0.962069">
4.2 Parse Trees
</subsectionHeader>
<bodyText confidence="0.997808833333333">
As mentioned above, HPSG uses a feature called
DAUGHTERS to represent syntactic structure
within feature structures, which is faithfully re-
produced in the XML that the LE generates.
The stylesheet is responsible for treating the
DAUGHTERS feature specially so that a parse
</bodyText>
<figure confidence="0.998227909090909">
&lt;xsl:template match=&amp;quot;feature&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;xsl:value-of select=&amp;quot;Oname&amp;quot;/&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;xsl:apply-templates
select=&amp;quot;object&amp;quot;/&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/xsl:template&gt;
</figure>
<figureCaption confidence="0.9788525">
Figure 8: XSLT template for the feature ele-
ment
</figureCaption>
<bodyText confidence="0.9937">
tree is rendered in HTML tables. Figure 9
shows the processing of the DAUGHTERS fea-
ture within the object template, done by the
xs1: when test that we ignored in the above sec-
tion.
A parse tree is rendered as a table with two
rows. The top row consists of a single cell con-
taining the parse tree&apos;s mother. This row con-
tains a single cell that spans (using the colspan
HTML element) all of the cells in the bot-
tom row. The bottom row contains the parse
tree&apos;s daughters, one daughter per cell. The
XSLT count 0 function is called to determine
the number of daughters, and thus the needed
colspan value for the mother&apos;s cell.
</bodyText>
<subsectionHeader confidence="0.999863">
4.3 Hiding Excessive Data
</subsectionHeader>
<bodyText confidence="0.99997905">
One useful aspect of XSLT is that parameters
can be passed to the XSLT transformation en-
gine at run-time. This allows control over what
aspects of the underlying XML should be dis-
played. This is important when the XML docu-
ments become so large as to be difficult to view
as a single HTML page. A single AVM can
contain so much information that its XML rep-
resentation, when transformed into HTML be-
comes too large to conveniently view on a single
web page : the user must scroll excessively to
view the entire AVM. We compensate for this
by providing a parameters to the stylesheet that
specify names of AVM features to hide from the
HTML output. The user can select which fea-
tures to show or hide with a web form. Groups
of related features, such as all features encod-
ing semantic information can be grouped for the
user&apos;s convenience and referred to as &amp;quot;seman-
tics&amp;quot; on the user&apos;s web form.
</bodyText>
<figure confidence="0.9979644">
&lt;xsl:template match=&amp;quot;object&amp;quot;›
&lt;xsl:when
test &amp;quot;feature
[Oname=&apos;DAUGHTERS&apos;]&amp;quot;&gt;
&lt;table border=&amp;quot;1&amp;quot;›
&lt;tr&gt;
&lt;td align=&amp;quot;centern&gt;
&lt;xsl:attribute name=&amp;quot;colspae&gt;
&lt;xsl:value-of
select=&amp;quot;
count(feature[Oname=&apos;DAUGHTERS&apos;]/
object//
feature[Oname=&apos;FIRST&apos;])&amp;quot;/&gt;
&lt;/xsl:attribute&gt;
&lt;xsl:value-of select=&amp;quot;Qtype&amp;quot;/&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;xsl:apply-templates
select=
&amp;quot;feature[Oname=&apos;DAUGHTERS&apos;]&amp;quot;/&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/xsl:when&gt;
&lt;/xsl:template&gt;
</figure>
<figureCaption confidence="0.944882666666667">
Figure 9: XSLT template for the object ele-
ment, showing section for handling objects that
are phrases.
</figureCaption>
<bodyText confidence="0.9930418">
The LE need not know about the details of
the user&apos;s display preferences, however, and this
enforces modularity by separating the underly-
ing XML generation from its presentation to the
user.
</bodyText>
<sectionHeader confidence="0.997141" genericHeader="general terms">
5 Input/Output Specification
</sectionHeader>
<bodyText confidence="0.999928545454545">
As mentioned before, the LE is a program writ-
ten in Lisp that listens on a TCP port and re-
ceives s-expressions. It then processes the ex-
pression and returns an XML document to the
client. More details of the format of these input
and output expressions are given in this section.
Each input s-expression is a function that the
LE evaluates. The possible functions are given
in the following table.
There are three input expressions that can be
passed to the LE:
</bodyText>
<listItem confidence="0.797471">
• (parse quoted string). This causes the
LE to parse the given quoted string and
returns the resulting agenda (completely
parsed constituents) and the chart (par-
tially parsed constituents).
• (sub-hier upper-bound lowerbound).
</listItem>
<bodyText confidence="0.6906485">
The LE returns the set of types that is
both more specific than the given upper-
bound and more general than the given
lower-bound.
</bodyText>
<listItem confidence="0.682604">
• (declare-type new-type supertypes sub-
</listItem>
<bodyText confidence="0.959535142857143">
types). The LE updates the type hierar-
chy by creating a new type with the given
name and situated in the type hierarchy
according to the supplied supertypes and
subtypes.
The following table summarizes the input-
output relationships described in this section.
</bodyText>
<sectionHeader confidence="0.998019" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.994185785714286">
Bob Carpenter. 1992. The Logic of Typed
Feature Structures with Applications to
Unification-based Grammars, Logic Program-
ming and Constraint Resolution, volume 32
of Cambridge Tracts in Theoretical Computer
Science. Cambridge University Press, New
York.
Chris Manning. 1992. Docu-
mentation for avm.sty. http:
//www.essex.ac.uk/linguistics/
clmt/latex4ling/avms/.
Carl J. Pollard and Ivan A. Sag. 1994. Head-
Driven Phrase Structure Grammar. Univer-
sity of Chicago Press, Chicago.
</reference>
<figure confidence="0.990746875">
input s-exp.
(parse expr)
(show-hier type-name)
(declare-type type-name)
output elem.
&lt;parse&gt;
&lt;sub-hier&gt;
&lt;sub-hier&gt;
</figure>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.327114">
<title confidence="0.95417">XML in a Web-based Grammar Development Environment</title>
<author confidence="0.512264">Eugene</author>
<address confidence="0.8869325">151 Calderon Ave Apt Mountain View CA</address>
<email confidence="0.798326">ekoontz©hiro-tan.org</email>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Bob Carpenter</author>
</authors>
<title>The Logic of Typed Feature Structures with Applications to Unification-based Grammars, Logic Programming and Constraint Resolution,</title>
<date>1992</date>
<volume>32</volume>
<publisher>Cambridge University Press,</publisher>
<location>New York.</location>
<contexts>
<context position="1419" citStr="Carpenter, 1992" startWordPosition="217" endWordPosition="218">ive demonstration of the system, may be found on the Web at http://edg.sf.net 1.1 Background EDG is an implementation of Head Driven Phrase Structure Grammar (HPSG) as described in (Pollard and Sag, 1994). HPSG posits a uniform representation of syntactic structure and semantics using feature structures, which are sets of feature-value pairs. Feature structures are used to represent all linguistic knowledge, both lexical and grammatical, and these structures are organized hierarchically in a type hierarchy. Typed feature structures and the type hierarchy obey certain mathematical constraints (Carpenter, 1992). Below we discuss how these data structures are represented in XML form, and how the XML representations are transformed into HTML via XSLT. 1.2 User Interface A web-based client-server grammar development model has a number of attractive features: • It is cross-platform; ideally any client able to run a web browser should be able to use to the system. • It allows multiple users to connect to the system simultaneously. Existing http mechanisms such as cookies can be used to save user state and allow multiple users to edit a single grammar and lexicon concurrently. • HTML (in particular, the &lt;</context>
</contexts>
<marker>Carpenter, 1992</marker>
<rawString>Bob Carpenter. 1992. The Logic of Typed Feature Structures with Applications to Unification-based Grammars, Logic Programming and Constraint Resolution, volume 32 of Cambridge Tracts in Theoretical Computer Science. Cambridge University Press, New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Chris Manning</author>
</authors>
<title>Documentation for avm.sty. http: //www.essex.ac.uk/linguistics/ clmt/latex4ling/avms/.</title>
<date>1992</date>
<marker>Manning, 1992</marker>
<rawString>Chris Manning. 1992. Documentation for avm.sty. http: //www.essex.ac.uk/linguistics/ clmt/latex4ling/avms/.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Carl J Pollard</author>
<author>Ivan A Sag</author>
</authors>
<title>HeadDriven Phrase Structure Grammar.</title>
<date>1994</date>
<publisher>University of Chicago Press,</publisher>
<location>Chicago.</location>
<contexts>
<context position="1007" citStr="Pollard and Sag, 1994" startWordPosition="154" endWordPosition="157"> and editing of its linguistic knowledge base. The system&apos;s response to user input is in XML, which is then transformed by an XSLT processor to form HTML, which is then displayed by the user&apos;s browser. The XML dialect used by the system to represent linguistic structure is described, together with details of how the XSLT stylesheet transforms it into HTML. Further information about the system, including an interactive demonstration of the system, may be found on the Web at http://edg.sf.net 1.1 Background EDG is an implementation of Head Driven Phrase Structure Grammar (HPSG) as described in (Pollard and Sag, 1994). HPSG posits a uniform representation of syntactic structure and semantics using feature structures, which are sets of feature-value pairs. Feature structures are used to represent all linguistic knowledge, both lexical and grammatical, and these structures are organized hierarchically in a type hierarchy. Typed feature structures and the type hierarchy obey certain mathematical constraints (Carpenter, 1992). Below we discuss how these data structures are represented in XML form, and how the XML representations are transformed into HTML via XSLT. 1.2 User Interface A web-based client-server g</context>
</contexts>
<marker>Pollard, Sag, 1994</marker>
<rawString>Carl J. Pollard and Ivan A. Sag. 1994. HeadDriven Phrase Structure Grammar. University of Chicago Press, Chicago.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>