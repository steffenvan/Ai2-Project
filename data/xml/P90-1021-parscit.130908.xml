<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<sectionHeader confidence="0.592772" genericHeader="abstract">
DEFAULTS IN UNIFICATION GRAMMAR
</sectionHeader>
<note confidence="0.894817333333333">
Gosse Bouma
Research Institute for Knowledge Systems
Postbus 463, 6200 AL Maastricht. The Netherlands
</note>
<sectionHeader confidence="0.660686" genericHeader="categories and subject descriptors">
e-mail: gosseeriksauucp
ABSTRACT
</sectionHeader>
<bodyText confidence="0.999707416666667">
Incorporation of defaults in grammar
formalisms is important for reasons of
linguistic adequacy and grammar
organization. In this paper we present an
algorithm for handling default information in
unification grammar. The algorithm specifies
a logical operation on feature structures,
merging with the non-default structure only
those parts of the default feature structure
which are not constrained by the non-default
structure. We present various linguistic
applications of default unification.
</bodyText>
<sectionHeader confidence="0.997662" genericHeader="introduction">
INTRODUCTION
</sectionHeader>
<bodyText confidence="0.992643476744186">
Mcn7vAnoN. There a two, not quite unrelated.
reasons for incorporating defaults
mechanisms into a linguistic formalism. First,
linguists have often argued that certain
phenomena are described most naturally with
the use of rules or other formal devices that
make use of a notion of default (see, for
instance, Gazdar 1987). The second reason is
that the use of defaults simplifies the
development of large and complex grammars,
In particular, the development of lexicons for
such grammars (Evans &amp; Gazdar 1988). The
latter suggests that the use of defaults is of
particular relevance for those brands of
Unification Grammar (UG) that are lexicalist,
that is, in which the lexicon is the main source
of grammatical information (such as
Categorial Unification Grammar (Uskoreit
1986. Calder et al. 1988) and Head-driven
Phrase Structure Grammar (Pollard &amp; Sag
1987)).
We propose a method for incorporating
defaults into UG, in such a way that it both
extends the linguistic adequacy of UG and
supports the formulation of rules, templates
and lexical entries for many unification-based
theories. In the next section, we define default
unification. a logical operation on feature
structures. It is defined for a language. FML*,
which is in many respects identical to the
language FML as defined in Kasper &amp; Rounds
(1986). Next, we come to linguistic
applications of default unification. A linguistic
notation is introduced, which can be used to
describe a number of linguistically interesting
phenomena, such as feature percolation.
coordination, and many aspects of inflectional
morphology. Furthermore, it can be used in the
sense of Flickinger et al. (1985) to define
exceptions to rules, non-monotonic
specialization of templates or irregular lexical
entries.
BACKGROUND. There are several proposals
which hint at the possibility of adding default
mechanisms to the linguistic formalisms and
theories just mentioned. The fact that GPSG
(Gazdar et al.. 1985) makes heavy use of
defaults, has led to some research concerning
the compatibility of GPSG with a formalism
such PATR-II (Shieber 1986a) and concerning
the logical nature of the mechanisms used in
GPSG (Evans 1987). Shieber (1986a) proposes
an operation add conservatively. which adds
Information of a feature structure A to a
feature structure B, in as far as this
information is not in conflict with information
in B. Suggestions for similar operations can be
found in Shieber (1986b:59-61) (the overwrite
option of PATR-II) and Kaplan (1987) (priority
union). Flickinger et al. (1985) argue for the
incorporation of default inheritance
mechanisms in UG as an alternative for the
template system of PATR-II.
A major problem with attempts to define an
operation such as default unification for
complex feature structures, is that there are at
feast two ways to think about this operation. It
can be defined as an operation which is like
ordinary unification, with the exception that in
case of a unification failure, the value of the
non-default feature structure takes
precedence (Kaplan 1987. Shieber 1986a).
Another option is not to rely on unification
failure, but to remove default information
about a feature f already if the non-default
feature structure constrains the contents off
in some way. This view underlies most of the
default mechanisms used in GPSG1. The
1 Actually, in GPSG both notions of
default unification are used. In Shieber&apos;s
(1986a) formulation of the of the Foot Feature
Principle. for example, the operation add
conservatively (which normally relies on
unification failure) is restricted to features
that are free (i.e. uninstantiated and not
covarying with some other feature).
</bodyText>
<page confidence="0.998028">
165
</page>
<bodyText confidence="0.999646814814815">
distinction between the two approaches is
especially relevant for reentrant feature
values.
of the form &lt;p&gt; : a (where a is atomic or NIL or
TOP).
The definition presented in the next section is
defined as an operation on arbitrary feature
structures, and thus it is more general than the
operations add conservatively or overwrite, in
which only one sentence at a time (say, &lt;X0
head&gt; &lt;X1 head&gt; or &lt;subject case&gt;
nominative) is added to a feature description.
An obvious advantage of our approach is that
overwriting a structure F with r is equivalent
to adding F as default information to r. Default
unification, as defined below, follows the
approach in which default information is
removed if it is constrained in the non-default
structure. This decision is to a certain extent
linguistically motivated (see section 3), but
perhaps more important is the fact that we
wanted to avoid the following problem. For
arbitrary feature structures, there is not
always a unique way to resolve a unification
conflict, nor is it necessarily the case that one
solution subsumes other solutions. Consider
for instance the examples in (1).
</bodyText>
<figure confidence="0.9626422">
(1) default non-default
a &apos;&apos;&apos;a &lt;g&gt;
&lt;g&gt;= b
b. &lt;f&gt; &lt;g&gt; &lt;f&gt; = a
.e.g›= b
</figure>
<bodyText confidence="0.993844363636364">
To resolve the conflict, in (a), either one of the
equations could be removed. In (b), either the
fact that &lt;g&gt; = b or the reentrancy could be
removed (in both cases, this would remove the
inplicit fact that &lt;f› h). An approach which
only tries to remove the sources of a
unification conflict, will thus be forced to make
arbitrary decisions about the outcome of the
default unification procedure. At least for the
purposes of grammar development, this seems
to be an undesirable situationl.
</bodyText>
<sectionHeader confidence="0.996429" genericHeader="method">
2. DESCRIPTION OF THE ALGORITHM
</sectionHeader>
<bodyText confidence="0.991685142857143">
THE LANGUAGE FML. Default unification is
defined in terms of a formal language for
feature structures, based on Kasper St Rounds&apos;
(1986) language FML. FML* does not contain
disjunction, however, and furthermore,
equations of the form 1 f (where 4) is an
arbitrary formula) are replaced by equations
</bodyText>
<sectionHeader confidence="0.279315" genericHeader="method">
1 However, in Evans&apos; (1987) version of
</sectionHeader>
<bodyText confidence="0.651746666666667">
Feature Specification Defaults, it is simply
allowed that a category description has more
than one &apos;stable expansion&apos;.
</bodyText>
<listItem confidence="0.51436">
(2) SnerAx or FML*
</listItem>
<sectionHeader confidence="0.380877" genericHeader="method">
NIL
TOP
</sectionHeader>
<subsectionHeader confidence="0.2635">
a a e A (the set of atoms)
</subsectionHeader>
<bodyText confidence="0.860373666666666">
p e (L the set of labels)
and a€ Au rIDP,NIL)
kP 1&gt;s-eV/IA each pi e Le
We assume that feature structures are
represented as directed acyclic graphs (dogs).
The denotation D(41) of a formula • is the
minimal element w.r.t. subsumption2 in the
set of dags that satisfy it. The conditions under
which a dag D satisfies a formula of FML*
(where D/rp&gt; is the dag that is found if we
follow the path p through the dag D) are as
follows:
</bodyText>
<figure confidence="0.845715428571429">
(3) Szttrurrios OF FM*
a. DI=NIL always
b. D TOP never
C. D a If D = a
d D &lt;p&gt;: a if D/&lt;p&gt; is defined3 and
D/&lt;p&gt;
e. D 1=41AX if D 4, and D X
</figure>
<bodyText confidence="0.9585584375">
D Irvi&gt;,...&lt;pn&gt;] if the values of all
pi (1 i 5 n) are equivalent.
NORMAL FORM REQUIREMENTS. Default
unification should be a semantically well-
behaved operation, that is, the result of this
operation should depend only on the
denotation of the formula&apos;s involved. Since
default unification is a non-monotonic
operation, however, in which parts of the
default information may disappear, and since
there are in general many formulae denoting
the same dag, establishing this is not
completely trivial. In particular, we must make
sure that the formula which provides the
default information is in the following normal
form:
</bodyText>
<sectionHeader confidence="0.577001" genericHeader="method">
2 A dag D subsumes a dag D&apos; if the set of
</sectionHeader>
<bodyText confidence="0.841446666666667">
formulae satisfying D&apos; contains the set of
formulae satisfying D (Eisele &amp; Diirre. 1988:
287).
3 D/.4› is defined tiff e Dom(D).
D/r1p&gt; is defined iff DRI&gt; and D&apos;/&lt;p&gt; are
defined, where D&apos;=
</bodyText>
<page confidence="0.988299">
166
</page>
<figure confidence="0.973661285714286">
(4) F1111.! Normal Form
A formula 4,1sinFMLNFffl:
a VE &lt;P1P2&gt; : a in,:
&lt;pp C E Vp3E E : rp3p2&gt; : a in
b. VE1.E2 in.:
c.p/p2&gt; E E2, c-pp. e E1—&apos;
Nips E El : rp3p2&gt; E E2
</figure>
<listItem confidence="0.8083918">
c. E in 0, there is no rp&gt; E E,
such that &lt;pi&gt; is realized in O.
d. V E in O. there is no &lt;p&gt; C E such that
&lt;p&gt;. : a (a E A) is in O.
(5) REAMED
</listItem>
<bodyText confidence="0.973921545454545">
A path &lt;p1&gt; is realized in Ito iff &lt;pl&apos;› is
defined in D(0) E L) (cf. Eisele &amp; DOrre,
1988: 288).
For every formula O in FML*, there is a formula
0&apos; in FML&amp;quot; NF. which is equivalent to it w.r.t
unification, that is, for which the following
holds:
A default formula has to be in FMI..* NF for two
reasons. First, all information which is
Implicit in a formula, should be represented
explicitly, so we can check easily which parts
of a formula need to be removed to avoid
potential unification conflicts with the non-
default formula. . This is guaranteed by (4a.b).
Second, all reentrant paths should have NIL as
value. This is guaranteed by (4c,d) and makes
It possible to replace an equivalence class by
a weaker set of equations, in which arbitrary
long extensions of the old pathnames may
occur (if some path would have a value other
than NIL, certain extensions could lead to
inconsistent results).
LAWS FOR DEFAULT UNIFICATION. Default
unification is an operation which takes two
formulas as arguments, representing default
and non-default information respectively. The
dag denoted by the resultant formula is
subsumed by that of the non-default
argument. but not necessarily by that of the
default argument
The laws for default unification (defined as
Default 0 Non-default = Result. where Default
Is in FML-NF) are listed below.
</bodyText>
<listItem confidence="0.656435">
(6) Vx e FML*: 4, Ax * TOP ea qf AX # TOP (9) DEFAULT UNIFICATION:
</listItem>
<bodyText confidence="0.974189">
Note that this does not imply that 4, and O&apos;
have the same denotation. The two formulae
below, for example. are equivalent w.r.t.
unification, yet denote different dags :
</bodyText>
<listItem confidence="0.988742">
(7) a cf&gt; : a n
b. &lt;I&gt; : a n (g). : a
</listItem>
<bodyText confidence="0.6486758">
For conditions (4a,b), it is easy to see that (6)
holds (it follows, for instance, from the
equivalence laws (21) and (22) in Kasper &amp;
Rounds, 1986: 261). Condition (4c) can be met
by replacing every occurence of an
equivalence class frpi&gt;,....4pn&gt;lin a formula 4,
by a conjunction of equivalences
(&lt;P/1›,...‹Pn1&gt;/ for every epil&gt; (1 5l n) realized
In D(4). For example, if L (f,g), (8b) is the NF of
Via).
</bodyText>
<construct confidence="0.949242533333333">
(8) a. [d).cp] A •cfra : ML
b. kff&gt;,&lt;gf&gt;1 A [cfg&gt;or.gg:&gt;] A &lt;ff&gt; : NIL
Condition (4d) can be met by eliminating
equivalence classes of paths leading to an
atomic value. Thus. (7b) is the NF of (7a). Note
that the effect of (4c,d) is that the value of
every path which is member of some
equivalence class is NIL
a 0 • NIL =4$
43 TOP = TOP
NIL 0 0 =
TOP ED =4&apos;
b. a ED O .4)
e a = a
C. &lt;p&gt;: O =4,,
</construct>
<bodyText confidence="0.888194142857143">
p&apos; apreflxofp,a€A.
= If D(0) I=&lt;pp&apos;). :a.
=14, If 3p&apos; e E: D(0)1= E and p&apos;
Is a prefix of p,
&lt;p&gt;: a AO, otherwise.
d. E 041
where E&apos; is ( rp&gt;e E I D(0) E&apos; and p&apos; e El
</bodyText>
<construct confidence="0.768816">
&lt;p&gt;€ El D(4,) &lt;P.&gt; : a) (p&apos; a prefix of
p, a e A) and Z is (‹p&apos;&gt;. I D(0) I= &lt;P135 :a.
and p e E).
e. (41 A Z) ED = ifwAx=TOP,
= (w 0) A (x 4), otherwise.
</construct>
<page confidence="0.993059">
167
</page>
<bodyText confidence="0.994865">
This definition of default unification removes
all default information which might lead to a
unification conflict. Furthermore. It is
designed in such a way that the order in which
information is removed is irrelevant (note that
otherwise the second case in (9e) would be
invalid). The first two cases of (9c) are needed
to remove all sentences rp&gt; : a, which refer to
a path which is blocked or which cannot
receive an atomic value in 45. The third case in
(9c) is needed for situations such as (10).
</bodyText>
<equation confidence="0.631769">
(10) (cfp• : a A .r.h g&gt; : b) kf&gt;,
</equation>
<bodyText confidence="0.9935974">
In (9d), we first remove from an equivalence
class all paths which have a prefix that is
already in an equivalence class or which has
an atomic value. The result of this step is E-E.
Next, we modify the equivalence class, so that
it allows exceptions (i.e. the possibility of non-
unifiable values) for all paths which are
extensions of paths in E-E&apos; and are defined in
O. We can think of modified equivalence
classes as abbreviations for a set of
(unmodified) equivalence classes:
, where is the
conjunction of all equivalence classes
I&lt;P1Pb,•..&lt;1:0nPl&gt;1. such that pits not
defined in 2, but pl&apos; is in 2, for some 1,1&apos; E
An example should make this clearer:
(12) [cf.&gt;, &lt;g&gt;,&lt;Iii&gt;] (&lt;g.: a A cf g&gt; : b) =
The result of default unification in this case is
that one element ( &lt;g&gt;) is removed from the
default equivalence class since it is
constrained in by the non-default information.
Furthermore, the equivalence is modified, so
that it allows for exceptions for the paths &lt;f g&gt;
and &lt;h g&gt;. Applying the rule in (11). and
assuming that L = (f,g,h1, we conclude that
</bodyText>
<equation confidence="0.6409915">
(13) (&lt;15.&lt;h&gt; I /ficg&gt;)
kth.&lt;hEIA (4 h&gt;, e.h
</equation>
<bodyText confidence="0.999941">
Note that the replacement of modified
equivalence classes by ordinary equivalence
classes is always possible, and thus the result
of (9c1) is equivalent to a formula in FML*.
Finally. (9e) says that, given a consistent
default formula, the order in which default
information is added to the non-default
formula is unimportant.&apos; (This does not hold
for inconsistent default formulae, however,
since default unification with the individual
conjuncts might filter out enough information
to make the resultant formula a consistent
extension of the non-default formula. whereas
</bodyText>
<note confidence="0.49631">
TOP # 44.
</note>
<bodyText confidence="0.877871333333333">
The monotonicity properties of default
unification are listed below (where s is
subsumption):
</bodyText>
<equation confidence="0.474114666666667">
(14) a oszA4)
(but not x x A(p )
b. X (Z A 0) (X&apos; A 0)
</equation>
<bodyText confidence="0.990990352941177">
(but not 5 O&apos; (Z A (p) (Z A
(14a) says that default unification is montonic
addition of information to the non-default
Information. (14b) says that the function as a
whole is monotonic only w.r.t. the default
argument: adding more default information
leads to extensions of the result. Adding non-
default information is non-monotonic,
however, as this might cause more of the
default information to get removed or
overwritten.
The laws in (9) prove that formulae containing
the 0-operator can always be reduced to
standard formulae of FML*. This implies that
formulae using the 0-operator can still be
interpreted as denoting dags. Furthermore, it
follows that addition of default unification to a
unification-based formalism should be seen
only as a way to increase the expressive
power of tools used in defining the grammar
(and thus, according to Done et al. (1990)
default unification would be an &apos;off line&apos;
extension of the formalism, that is, its effects
can be computed at compile time).
A NOTE ON IMPLEMENTATION. We have
implemented default unification in Prolog,
Feature structures are represented by open
ended lists (containing elements of the form
Iabel=Value ), atoms and variables to
represent complex feature structures, atomic
values and reentrancies respectively (see
Gazdar &amp; Mellish, 1989). This implementation
has the advantage that it is corresponds to
FML* NF.
</bodyText>
<footnote confidence="0.409193">
1 This should not be confused with the
</footnote>
<bodyText confidence="0.471102">
(invalid) statement that 4/ e (x 001=x0 (41
e 0).
</bodyText>
<page confidence="0.974848">
168
</page>
<figure confidence="0.98131375">
(15) a If= X, gr.X I _Y1
b. [f=a,pa I _Y)
C. [f=.[Ir=a1X11.g=rh=a1X111 _YI
ff=fh=a1X1.g=th=_Z I X11 1_Y1
</figure>
<bodyText confidence="0.9997645">
If we unify (15a) with (fmcilyil, we get (15b), in
which the value of g has been updated as well
Thus, the requirements of (4a,b) are always
met, and furthermore, the reentrancy as such
between f and g is no longer visible (condition
4c). If we unify (15a) with (f=th=a I _X.21 I_Y31.
we get (15c), in which the variable X has been
replaced by XL which can be interpreted as
ranging over all paths that are realized but not
defined tmderf (condition (4d)). Note also that
this representation has the advantage that we
can define a reentrancy for all realized
features, without having to specify the set of
possible features or expanding the value of f
into a list containing all these features. If we
default unify (15a) with tf=fh=a I _X211 _XV as
non-default information, for instance, the
result is representable as (15d). The
reentrancy for all undefined features under (is
represented by X/. The constant NIL of FML*
is represented as a Prolog variable ( _Z in this
case). Thus, the seemingly space consuming
procedure of bringing a formula into FML* NF
and transforming the output of (9d) into FML*
is avoided completely. The actual default
unification procedure is a modified version of
the merge operation defined in D8rre &amp; Eisele
(1986).
</bodyText>
<sectionHeader confidence="0.994884" genericHeader="method">
3. LINGUISTIC APPLICATIONS
</sectionHeader>
<bodyText confidence="0.999268333333333">
Default unification can be used to extend the
standard PATR-II (Shieber et al., 1983)
methods for defining feature structures. In the
examples. we freely combine default and non-
default information (prefixed by I&apos;) in template
definitions.
</bodyText>
<figure confidence="0.946365666666667">
(16) a. DET : ( 1&lt;cat arg&gt; =N
&apos;&lt;cat val&gt; NP
&lt;cat dir&gt; ..right
&lt;cat arg&gt; = &lt;cat val&gt;
&lt;cat val num&gt; Sg
&lt;cat val case&gt; =nom
b. NP ( &lt;cab = noun
&lt;bar&gt; =2 ).
c. N : ( &lt;cat&gt; =noun
</figure>
<figureCaption confidence="0.619711">
&lt;bar&gt; =1 ).
</figureCaption>
<bodyText confidence="0.9968666">
(16) describes a fragment of Categorial
Unification Grammar (Uszkoreit, 1986, Calder
et al. 1988. Houma, 1988). The corresponding
feature structure for a definition such as (16a)
is determined as follows: first, all default
Information and all non-default information is
unified separately, which results in two
feature-structures (17a,b). The resulting two
feature structures are merged by means of
default unification (17c).
</bodyText>
<figure confidence="0.967731785714286">
[val = &lt;1›[ case num = sq 1
= nom j
[val = [ cat : rj Ti
b. cat = bar : n1]
arg = cat
[ [bar
c.
[
c at. n
b a r . 2
val (1)1 sq = sg
case = nom
dir = right
c a t n -
</figure>
<figureCaption confidence="0.300089">
bar.. 1
</figureCaption>
<bodyText confidence="0.984587033333333">
arg {1)I num = sq
case = nom-
In (17c) the equivalence &lt;cat val, = &lt;cat arg&gt;
had to be replaced by a weaker set of
equivalences, which holds for all features
under val or arg, except cat and bar. We
represent this by using 11-bracketed indices,
instead of &lt;&gt; and by marking the attributes
which are exceptions in bald italic..
Two things are worth noticing. First of all, the
unification of non-default information prior to
merging it with the non-default information,
guarantees that all default information must
be unifiable, and thus it eliminates the
possibility of inheritance conflicts inside
template definitions. Second, the distinction
between default and non-default information
is relevant only in definitions, not in the
corresponding feature structures. This makes
the use of the 1-operator completely local: if a
definition contains a template. we can replace
this template by the corresponding feature
structure and we do not need to won&apos;,&apos; about
the fact that this template might contain the
&apos;1-operator.
The notation Just introduced increases the
expressive power of standard methods for the
description of feature structures and can be
used for an elegant treatment or several
linguistic phenomena.
</bodyText>
<equation confidence="0.9752032">
dir = right
arg = &lt;1).
WM* •■■
cat =
■■■ ■■■
</equation>
<page confidence="0.996692">
169
</page>
<note confidence="0.744137">
NON-MONOTONIC INHERITANCE or INFORMATION IN
</note>
<bodyText confidence="0.998772833333333">
TEMPLATES. The use of default unification
enables us to use templates even in those
cases where not all the information in the
template is compatible with the information
already present in the definition.
German transitive verbs normally take an
accusative NP as argument, but there are some
verbs which take a dative or genitive NP as
argument. This is easily accounted for by
defining the case of the argument of these
verbs and inheriting all other information
from the template IV.
</bodyText>
<listItem confidence="0.862329">
(18) a. TV: ( &lt;cat val&gt; = VP
&lt;cat arg&gt; NP
&lt;cat arg case&gt; = ace).
</listItem>
<figure confidence="0.290482666666667">
b. helfen ftotaelp) :
( TV
1 &lt;cat arg case&gt; = dat I.
gedenken (to commemorate.)
( TV
I &lt;cat arg case&gt; = gen
</figure>
<subsectionHeader confidence="0.688092">
SPECIALIZATION OF REENTRANCIES. An important
</subsectionHeader>
<bodyText confidence="0.954883129032258">
function of default unification is that it allows
us to define exceptions to the fact that two
reentrant feature structures always have to
denote exactly the same feature structures.
There is a wide class of linguistic
constructions which seems to require such
mechanisms.
Specifiers in CUG can be defined as functors
which take a constituent of category C as
argument, and return a constituent of category
C, with the exception that one or more specific
feature values are changed (see Bach, 1983.
Bouma, 1988). Examples of such categories
are determiners (see (16a)), complementizers
and auxiliaries.
(19) a. that : ( &lt;cat val&gt; = &lt;cat arg&gt;
&lt;cat arg&gt; = 5
&lt;cat arg vform&gt; fin
kcat arg comp&gt; = none
kcat val comp&gt; = that ).
b. wffi : ( &lt;cat val&gt; &lt;cat arg&gt;
&lt;cat arg&gt; = VP
&lt;cat val&gt; = VP
t&lt;cat arg vform&gt; = bee
kcat val vform&gt; fin ).
Note that the equation &lt;cat vat&gt; = &lt;cat arg&gt;
will cause all additional features on the
argument which are not explicitly mentioned
in the non-default part of the definition to
percolate up to the value.
Next, consider coordination of NPs.
</bodyText>
<equation confidence="0.827639">
(20) x0--&gt; x1x2X3
( &lt;X2 cat&gt; = conj
&lt;X0&gt; = &lt;Xi&gt;
&lt;X0&gt; = &lt;X3&gt;
eXci cab. = np
&lt;X2 wform&gt; = and
i&lt;X0 num&gt; = plu
i&lt;X1 num&gt; =NIL
I &lt;X2 num&gt; = NIL).
</equation>
<bodyText confidence="0.999527923076923">
(20) could be used as a rule for conjunction of
NPs in UG. It requires identity between the
mother and the two coordinated elements.
However, requiring that the three nodes be
unifiable would be to strict. The number of a
conjoined NP is always plural and does not
depend on the number of the coordinated NPs.
Furthermore, the number of two coordinated
elements need not be identical. The non-
default information in (20) takes care of this.
The effect of this statement is that adding the
default information &lt;X0&gt; = &lt;X1&gt; and &lt;X0&gt;
&lt;X3&gt; will result in a feature structure in which
X0. Xi and X3 are unified, except for their
values for &lt;num&gt;. We are not interested in the
num-values of the conjuncts, so they are set to
NIL (which should be interpreted as in section
2) . The num -value of the result is always piu.
Iivrt.EcrioNAL MORPHOLOGY. When seen from a
CUG perspective, the categories of inflectional
affixes are comparable to those of specifiers.
The plural suffix -s for forming plural nouns
can, for instance, be encoded as a function
from (regular) singular nouns into identical,
but plural, nouns. Thus, we get the following
categorization:
</bodyText>
<equation confidence="0.641088">
C21) -s : ( &lt;cat val&gt; = &lt;cat arg&gt;
</equation>
<bodyText confidence="0.998130333333333">
&lt;cat arg cat&gt; = noun
&lt;cat arg class&gt; = regular
1&lt;cat arg num&gt; = sg
kcat val num&gt; = plu ).
Again, all additional information present on
the argument which is not mentioned in the
non-default part of the definition, is
percolated up to the value automatically.
LEXICAL DErAuLrs. The lexical feature
specification defaults of GPSG can also be
Incorporated. Certain information holds for
most lexical items of a certain category, but
not for phrases of this category. A
uniflciation-based grammar that includes a
morphological component (see, for instance.
Calder, 1989 and Evans &amp; Gazdar, 1989), would
probably list only (regular) root forms as
lexical items. For regular nouns, for instance,
</bodyText>
<page confidence="0.987064">
170
</page>
<bodyText confidence="0.98989925">
only the singular form would be listed in the
lexicon. Such information can be added to
lexicon definitions by means of a lexical
default nile:
</bodyText>
<figure confidence="0.937149">
(22) a N ==&gt; ( 3SG &lt;class&gt; = regular)
b. cow = N.
sheep = (
&lt;num&gt; =NIL
&lt;class&gt; = irregular).
</figure>
<bodyText confidence="0.999447235294118">
The interpretation of A ==&gt; B is as follows: If
the definition D of a lexical item is unifiable
with A. than extend D to B 49 D. Thus, the
lexical entry cow would be extended with all
the information in the default rule above,
whereas the lexical entry for sheep would only
be extended with the information that
&lt;person&gt; = 3. Note that adding the default
information to the template for N directly. and
then overwriting it in the irregular cases is not
a feasible alternative, as this would force us to
distinguish between the template N if used to
describe nouns and the template N if used in
complex categories such as NP/N or N/N (i.e.
for determiners or adjectives it is not typically
the case that they combine only with regular
and singular nouns).
</bodyText>
<sectionHeader confidence="0.986966" genericHeader="conclusions">
CONCLUSIONS
</sectionHeader>
<bodyText confidence="0.870197821428571">
We have presented a general definition for
default unification. The fact that it does not
focus one the resolution of feature conflicts
alone, makes it possible to define default
unification as an operation on feature
structures, rather than as an operation adding
one equation at a time to a given feature
description. This generalization makes it
possible to give a uniform treatment of such
things as adding default information to a
template, overwriting of feature values and
lexical default rules. We believe that the
examples in section 3 demonstrate that this is
a useful extension of UG, as it supports the
definition of exceptions, the formulation more
adequate theories of feature percolation, and
the extension of UG with a morphological
component.
Evans. Roger &amp; Gazdar, Gerald 1989 Inference
in DATR. Proceedings of the fourth
Conference of the European Chpater of
the ACL. University of Manchester.
Institute of Science and Technology, 66-
71.
Flickinger, Daniel; Pollard, Carl &amp; Wasow.
Thomas 1985 Structure-Sharing in Lexical
Representation. Proceedings of the 23rd
Annual Meeting of the Association for
</bodyText>
<sectionHeader confidence="0.847717" genericHeader="references">
REFERENCES
</sectionHeader>
<bodyText confidence="0.805992684210526">
Bach. Emmon 1983 Generalized Categorial
Grammars and the English Auxiliary. In
F.Heny and B.Richards (eds.) Linguistic
Categories, Vol II, Dordrecht, Reidel.
Botuna, Gosse 1988 Modifiers and Specifiers
In Categorial Unification Grammar.
Linguistics, vol 26. 21-46.
Calder, Jonathan 1989 Paradigmatic
Morphology. Proceedings of the fourth
Conference of the European Chapter of
the ACL. University of Manchester,
Institute of Science and Technology. 58-
65.
Calder, Jo; Klein, Ewan &amp; Zeevat. Henk 1988
Unification Categorial Grammar: a
concise, extendable grammar for natural
language processing. Proceedings of
Coling 1988, Hungarian Academy of
Sciences, Budapest, 83-86.
</bodyText>
<figureCaption confidence="0.871355181818182">
DOrre, Jochen; Eisele, Andreas; Wedekind,
Jurgen; Calder, Jo; Reape, Mike 1990 A
Survey of Lingustically Motivated
extensions to Unification-Based
Formalisms. ESPRIT Basic Research
Action 3175, Deliverable R3.1.A.
Eisele, Andreas &amp; DOrre. Jochen1986 A
Lexical-Functional Grammar System in
Prolog. Proceedings of COLING 86,
Institut fur angewandte KommunikaUons-
und Sprachforschung, Bonn, 551-553.
</figureCaption>
<bodyText confidence="0.923019615384615">
Eisele, Andreas &amp; DOrre, Jochen 1988
Unification of Disjunctive Feature
Descriptions. Proceedings of the 26th
Annual Meeting of the Association for
Computational Linguistics. State
University of New York, Buffalo. NY. 286-
294.
Evans, Roger 1987 Towards a Formal
specification of Defaults in GPSG. In E.
Klein &amp; J. van Benthem (eds.), Categories,
Polymorphism and Unification. University
of Edinburgh, Edinburgh/ University of
Amsterdam, Amsterdam, 73-93.
</bodyText>
<page confidence="0.997924">
171
</page>
<reference confidence="0.999671648148148">
Computational Linguistics, University of
Chicago, Chicago, Illinois, 262-267,
Gazdar, Gerald 1987 Linguistic Applications of
Default Inheritance Mechanisms. In P.
Whitelock, H. Somers. P. Bennett, R,
Johnson, and M. McGee Wood (eds.).
Linguistic Theory and Computer
Applications. Academic Press, London,
37-68.
Gazdar. Gerald; Klein, Ewan; Pullurn, Geoffry;
Sag, Ivan 1985 Generalized Phrase
Structure Grammar. Blackwell, London.
Gazdar, Gerald &amp; Mellish. Chris 1989 Natural
Language Processing in Prolog. An
introduction to Computational
Linguistics. Addison-Wesley, Reading. MA.
Kaplan, Ronald 1987 Three seductions of
Computational Psycholinguistics. In P.
Whitelock, H. Somers, P. Bennett, R,
Johnson, and M. McGee Wood (eds.),
Linguistic theory and Computer
Applications. Academic Press, London,
149-188.
Kasper, Robert &amp; Rounds, William1986 A
Logical Semantics for Feature Structures.
Proceedings of the 26th Annual Meeting of
the Association for Computational
Linguistics, Columbia University. New
York, NY, 257-266.
Pollard, Carl &amp; Sag, Ivan 1987 Information-
Based Syntax and Semantics, vol 1 :
Fundamentals, CSLI Lecture Notes 13,
University of Chicago Press. Chicago.
Shieber, Stuart; Uszkoreit, Hans; Pereira,
Fernando; Robinson, Jane; &amp; Tyson,
Mabry 1983 The Formalism and
Implementation of PAT-Il. In B. Grosz &amp;
M. Stickel (eds.) Research on Interactive
Acquisition and Use of Knowledge. SRI
International, Menlo Park. Ca.
Shieber, Stuart 1986a A Simple
Reconstruction of GPSG. Proceedings of
COLING 1986. Institut Mr angewandte
Kommunikations- und Sprachforschung,
Bonn, 211-215.
Shieber, Stuart 1986b An Introduction to
Unification-based Approaches to
Grammar. CSLI Lecture Notes 4.
University of Chicago Press, Chicago.
Uszkoreit, Hans 1986 Categorial Unification
Grammars. Proceedings of COLING 1986.
Institut fur angewandte
Kommunikations- und Sprachforschung.
Bonn, 187-194.
</reference>
<page confidence="0.997881">
172
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.947395">
<title confidence="0.993237">DEFAULTS IN UNIFICATION GRAMMAR</title>
<author confidence="0.976682">Gosse Bouma</author>
<affiliation confidence="0.962278">Research Institute for Knowledge Systems</affiliation>
<address confidence="0.984014">Postbus 463, 6200 AL Maastricht. The Netherlands</address>
<email confidence="0.998551">e-mail:gosseeriksauucp</email>
<abstract confidence="0.999709923076923">Incorporation of defaults in grammar formalisms is important for reasons of linguistic adequacy and grammar organization. In this paper we present an algorithm for handling default information in unification grammar. The algorithm specifies a logical operation on feature structures, merging with the non-default structure only those parts of the default feature structure which are not constrained by the non-default structure. We present various linguistic applications of default unification.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<pages>262--267</pages>
<institution>Computational Linguistics, University of Chicago,</institution>
<location>Chicago, Illinois,</location>
<marker></marker>
<rawString>Computational Linguistics, University of Chicago, Chicago, Illinois, 262-267,</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gerald Gazdar</author>
</authors>
<title>Linguistic Applications of Default Inheritance Mechanisms. In</title>
<date>1987</date>
<booktitle>Linguistic Theory and Computer Applications.</booktitle>
<pages>37--68</pages>
<editor>P. Whitelock, H. Somers. P. Bennett, R, Johnson, and M. McGee Wood (eds.).</editor>
<publisher>Academic Press,</publisher>
<location>London,</location>
<contexts>
<context position="998" citStr="Gazdar 1987" startWordPosition="138" endWordPosition="139">e algorithm specifies a logical operation on feature structures, merging with the non-default structure only those parts of the default feature structure which are not constrained by the non-default structure. We present various linguistic applications of default unification. INTRODUCTION Mcn7vAnoN. There a two, not quite unrelated. reasons for incorporating defaults mechanisms into a linguistic formalism. First, linguists have often argued that certain phenomena are described most naturally with the use of rules or other formal devices that make use of a notion of default (see, for instance, Gazdar 1987). The second reason is that the use of defaults simplifies the development of large and complex grammars, In particular, the development of lexicons for such grammars (Evans &amp; Gazdar 1988). The latter suggests that the use of defaults is of particular relevance for those brands of Unification Grammar (UG) that are lexicalist, that is, in which the lexicon is the main source of grammatical information (such as Categorial Unification Grammar (Uskoreit 1986. Calder et al. 1988) and Head-driven Phrase Structure Grammar (Pollard &amp; Sag 1987)). We propose a method for incorporating defaults into UG, </context>
</contexts>
<marker>Gazdar, 1987</marker>
<rawString>Gazdar, Gerald 1987 Linguistic Applications of Default Inheritance Mechanisms. In P. Whitelock, H. Somers. P. Bennett, R, Johnson, and M. McGee Wood (eds.). Linguistic Theory and Computer Applications. Academic Press, London, 37-68.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Klein Gerald</author>
<author>Pullurn Ewan</author>
<author>Sag Geoffry</author>
</authors>
<title>Generalized Phrase Structure Grammar.</title>
<date>1985</date>
<publisher>Blackwell,</publisher>
<location>Ivan</location>
<marker>Gerald, Ewan, Geoffry, 1985</marker>
<rawString>Gazdar. Gerald; Klein, Ewan; Pullurn, Geoffry; Sag, Ivan 1985 Generalized Phrase Structure Grammar. Blackwell, London.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Chris</author>
</authors>
<title>Natural Language Processing in Prolog. An introduction to Computational Linguistics.</title>
<date>1989</date>
<publisher>Addison-Wesley,</publisher>
<location>Reading. MA.</location>
<marker>Chris, 1989</marker>
<rawString>Gazdar, Gerald &amp; Mellish. Chris 1989 Natural Language Processing in Prolog. An introduction to Computational Linguistics. Addison-Wesley, Reading. MA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ronald Kaplan</author>
</authors>
<title>Three seductions of Computational Psycholinguistics.</title>
<date>1987</date>
<booktitle>Linguistic theory and Computer Applications.</booktitle>
<pages>149--188</pages>
<editor>In P. Whitelock, H. Somers, P. Bennett, R, Johnson, and M. McGee Wood (eds.),</editor>
<publisher>Academic Press,</publisher>
<location>London,</location>
<contexts>
<context position="3178" citStr="Kaplan (1987)" startWordPosition="477" endWordPosition="478">nd theories just mentioned. The fact that GPSG (Gazdar et al.. 1985) makes heavy use of defaults, has led to some research concerning the compatibility of GPSG with a formalism such PATR-II (Shieber 1986a) and concerning the logical nature of the mechanisms used in GPSG (Evans 1987). Shieber (1986a) proposes an operation add conservatively. which adds Information of a feature structure A to a feature structure B, in as far as this information is not in conflict with information in B. Suggestions for similar operations can be found in Shieber (1986b:59-61) (the overwrite option of PATR-II) and Kaplan (1987) (priority union). Flickinger et al. (1985) argue for the incorporation of default inheritance mechanisms in UG as an alternative for the template system of PATR-II. A major problem with attempts to define an operation such as default unification for complex feature structures, is that there are at feast two ways to think about this operation. It can be defined as an operation which is like ordinary unification, with the exception that in case of a unification failure, the value of the non-default feature structure takes precedence (Kaplan 1987. Shieber 1986a). Another option is not to rely on</context>
</contexts>
<marker>Kaplan, 1987</marker>
<rawString>Kaplan, Ronald 1987 Three seductions of Computational Psycholinguistics. In P. Whitelock, H. Somers, P. Bennett, R, Johnson, and M. McGee Wood (eds.), Linguistic theory and Computer Applications. Academic Press, London, 149-188.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Robert Kasper</author>
<author>Rounds</author>
</authors>
<title>William1986 A Logical Semantics for Feature Structures.</title>
<booktitle>Proceedings of the 26th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>257--266</pages>
<location>Columbia University. New York, NY,</location>
<marker>Kasper, Rounds, </marker>
<rawString>Kasper, Robert &amp; Rounds, William1986 A Logical Semantics for Feature Structures. Proceedings of the 26th Annual Meeting of the Association for Computational Linguistics, Columbia University. New York, NY, 257-266.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Carl Pollard</author>
<author>Ivan Sag</author>
</authors>
<date>1987</date>
<journal>InformationBased Syntax and Semantics,</journal>
<volume>1</volume>
<publisher>Press. Chicago.</publisher>
<institution>University of Chicago</institution>
<contexts>
<context position="1539" citStr="Pollard &amp; Sag 1987" startWordPosition="221" endWordPosition="224"> devices that make use of a notion of default (see, for instance, Gazdar 1987). The second reason is that the use of defaults simplifies the development of large and complex grammars, In particular, the development of lexicons for such grammars (Evans &amp; Gazdar 1988). The latter suggests that the use of defaults is of particular relevance for those brands of Unification Grammar (UG) that are lexicalist, that is, in which the lexicon is the main source of grammatical information (such as Categorial Unification Grammar (Uskoreit 1986. Calder et al. 1988) and Head-driven Phrase Structure Grammar (Pollard &amp; Sag 1987)). We propose a method for incorporating defaults into UG, in such a way that it both extends the linguistic adequacy of UG and supports the formulation of rules, templates and lexical entries for many unification-based theories. In the next section, we define default unification. a logical operation on feature structures. It is defined for a language. FML*, which is in many respects identical to the language FML as defined in Kasper &amp; Rounds (1986). Next, we come to linguistic applications of default unification. A linguistic notation is introduced, which can be used to describe a number of l</context>
</contexts>
<marker>Pollard, Sag, 1987</marker>
<rawString>Pollard, Carl &amp; Sag, Ivan 1987 InformationBased Syntax and Semantics, vol 1 : Fundamentals, CSLI Lecture Notes 13, University of Chicago Press. Chicago.</rawString>
</citation>
<citation valid="true">
<title>The Formalism and Implementation of PAT-Il.</title>
<date>1983</date>
<booktitle>Research on Interactive Acquisition and Use of Knowledge. SRI International, Menlo Park. Ca.</booktitle>
<editor>Shieber, Stuart; Uszkoreit, Hans; Pereira, Fernando; Robinson, Jane; &amp; Tyson,</editor>
<location>Mabry</location>
<marker>1983</marker>
<rawString>Shieber, Stuart; Uszkoreit, Hans; Pereira, Fernando; Robinson, Jane; &amp; Tyson, Mabry 1983 The Formalism and Implementation of PAT-Il. In B. Grosz &amp; M. Stickel (eds.) Research on Interactive Acquisition and Use of Knowledge. SRI International, Menlo Park. Ca.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Stuart Shieber</author>
</authors>
<title>1986a A Simple Reconstruction of GPSG.</title>
<booktitle>Proceedings of COLING 1986. Institut Mr angewandte Kommunikations- und Sprachforschung,</booktitle>
<pages>211--215</pages>
<location>Bonn,</location>
<marker>Shieber, </marker>
<rawString>Shieber, Stuart 1986a A Simple Reconstruction of GPSG. Proceedings of COLING 1986. Institut Mr angewandte Kommunikations- und Sprachforschung, Bonn, 211-215.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Stuart Shieber</author>
</authors>
<title>1986b An Introduction to Unification-based Approaches to Grammar.</title>
<journal>CSLI Lecture Notes</journal>
<volume>4</volume>
<publisher>University of Chicago Press,</publisher>
<location>Chicago.</location>
<marker>Shieber, </marker>
<rawString>Shieber, Stuart 1986b An Introduction to Unification-based Approaches to Grammar. CSLI Lecture Notes 4. University of Chicago Press, Chicago.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hans Uszkoreit</author>
</authors>
<title>Categorial Unification Grammars.</title>
<date>1986</date>
<booktitle>Proceedings of COLING 1986. Institut fur angewandte Kommunikations- und Sprachforschung.</booktitle>
<pages>187--194</pages>
<location>Bonn,</location>
<contexts>
<context position="16795" citStr="Uszkoreit, 1986" startWordPosition="2890" endWordPosition="2891">ocedure is a modified version of the merge operation defined in D8rre &amp; Eisele (1986). 3. LINGUISTIC APPLICATIONS Default unification can be used to extend the standard PATR-II (Shieber et al., 1983) methods for defining feature structures. In the examples. we freely combine default and nondefault information (prefixed by I&apos;) in template definitions. (16) a. DET : ( 1&lt;cat arg&gt; =N &apos;&lt;cat val&gt; NP &lt;cat dir&gt; ..right &lt;cat arg&gt; = &lt;cat val&gt; &lt;cat val num&gt; Sg &lt;cat val case&gt; =nom b. NP ( &lt;cab = noun &lt;bar&gt; =2 ). c. N : ( &lt;cat&gt; =noun &lt;bar&gt; =1 ). (16) describes a fragment of Categorial Unification Grammar (Uszkoreit, 1986, Calder et al. 1988. Houma, 1988). The corresponding feature structure for a definition such as (16a) is determined as follows: first, all default Information and all non-default information is unified separately, which results in two feature-structures (17a,b). The resulting two feature structures are merged by means of default unification (17c). [val = &lt;1›[ case num = sq 1 = nom j [val = [ cat : rj Ti b. cat = bar : n1] arg = cat [ [bar c. [ c at. n b a r . 2 val (1)1 sq = sg case = nom dir = right c a t n - bar.. 1 arg {1)I num = sq case = nomIn (17c) the equivalence &lt;cat val, = &lt;cat arg&gt; </context>
</contexts>
<marker>Uszkoreit, 1986</marker>
<rawString>Uszkoreit, Hans 1986 Categorial Unification Grammars. Proceedings of COLING 1986. Institut fur angewandte Kommunikations- und Sprachforschung. Bonn, 187-194.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>