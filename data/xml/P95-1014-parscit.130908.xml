<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.98461">
Memoization of Coroutined Constraints
</title>
<author confidence="0.990858">
Mark Johnson
</author>
<affiliation confidence="0.964863">
Cognitive and Linguistic Sciences, Box 1978
Brown University
</affiliation>
<address confidence="0.60542">
Providence, RI 02912, USA
</address>
<email confidence="0.981775">
Mark_Johnson@Brown.edu
</email>
<author confidence="0.78817">
Jochen Dorre*
</author>
<affiliation confidence="0.4517385">
Institut fiir maschinelle Sprachverarbeitung
Universitat Stuttgart
D-70174 Stuttgart, Germany
Jochen.Doerreeims.uni—stuttgart.de
</affiliation>
<sectionHeader confidence="0.988465" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.99991">
Some linguistic constraints cannot be effec-
tively resolved during parsing at the loca-
tion in which they are most naturally intro-
duced. This paper shows how constraints
can be propagated in a memoizing parser
(such as a chart parser) in much the same
way that variable bindings are, providing a
general treatment of constraint coroutining
in memoization. Prolog code for a sim-
ple application of our technique to Bouma
and van Noord&apos;s (1994) categorial gram-
mar analysis of Dutch is provided.
</bodyText>
<sectionHeader confidence="0.999394" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999297195121951">
As the examples discussed below show, some lin-
guistic constraints cannot be effectively resolved du-
ring parsing at the location in which they are most
naturally introduced. In a backtracking parser, a
natural way of dealing with such constraints is to
coroutine them with the other parsing processes, re-
ducing them only when the parse tree is sufficiently
instantiated so that they can be deterministically
resolved. Such parsers are particularly easy to im-
plement in extended versions of Prolog (such as Pro-
logII, SICStus Prolog and Eclipse) which have such
coroutining facilities built-in. Like all backtracking
parsers, they can exhibit non-termination and expo-
nential parse times in situations where memoizing
parsers (such as chart parsers) can terminate in po-
lynomial time. Unfortunately, the coroutining ap-
proach, which requires that constraints share varia-
bles in order to communicate, seems to be incompa-
tible with standard memoization techniques, which
&apos;This research was largely conducted at the Institut
fiir maschinelle Sprachverarbeitung in Stuttgart. We
would like to thank Andreas Eisele, Pascal van Hen-
tenryck, Martin Kay, Fernando Pereira, Edward Stabler
and our colleagues at the Institut fiir maschinelle Sprach-
verarbeitung for helpful comments and suggestions. All
remaining errors are our own. The Prolog code presen-
ted in this paper is available via anonymous ftp from
lx.cog.brown.edu as ipubilemma.tar.Z
require systematic variable-renaming (i.e., copying)
in order to avoid spurious variable binding.
For generality, conciseness and precision, we for-
malize our approach to memoization and constraints
within Holifeld and Smolka&apos;s (1988) general theory
of Constraint Logic Programming (CLP), but we
discuss how our method can be applied to more stan-
dard chart parsing as well. This paper extends our
previous work reported in Dorm (1993) and John-
son (1993) by generalizing those methods to arbi-
trary constraint systems (including feature-structure
constraints), even though for reasons of space such
systems are not discussed here.
</bodyText>
<sectionHeader confidence="0.9911745" genericHeader="method">
2 Lexical rules in Categorial
Grammar
</sectionHeader>
<bodyText confidence="0.999754">
This section reviews Bouma and van Noord&apos;s (1994)
(BN henceforth) constraint-based categorial gram-
mar analysis of modification in Dutch, which we use
as our primary example in this paper. However,
the memoizing CLP interpreter presented below has
also been applied to GB and HPSG parsing, both of
which benefit from constraint coroutining in parsing.
BN can explain a number of puzzling scope phe-
nomena by proposing that heads (specifically, verbs)
subcategorize for adjuncts as well as arguments (rat-
her than allowing adjuncts to subcategorize for the
arguments they modify, as is standard in Categorial
Grammar). For example, the first reading of the
Dutch sentence
</bodyText>
<listItem confidence="0.658151">
(1) Frits opzettelijk Marie lijkt te ontwijken
</listItem>
<bodyText confidence="0.984461363636364">
deliberately seems avoid
&apos;Fritz deliberately seems to avoid Marie&apos;
&apos;Fritz seems to deliberately avoid Marie&apos;
is obtained by the analysis depicted in Figure 1. The
other reading of this sentence is produced by a de-
rivation in which the adjunct addition rule &apos;A&apos; adds
an adjunct to lijki te, and applies vacuously to oni-
wijken.
It is easy to formalize this kind of grammar in pure
Prolog. In order to simplify the presentation of the
proof procedure interpreter below, we write clauses
</bodyText>
<page confidence="0.902707">
100
</page>
<figure confidence="0.886805777777778">
lijkt te
VP1/VP1 A ontwijken
VP1/VP1 D VP1 NP2 A
Marie (VP, \ADV\NP2)/o(VP, \ADV\NP2) D(VP,\ADV\NP2)
VP, \ADV\NP2
VP, \ADV
Frits ADV
opzettelijk NP2
NP, VP,
</figure>
<figureCaption confidence="0.915924">
Figure 1: The BN analysis of (1). In this derivation &apos;VP,&apos; abbreviates `S\ NP,&apos;, &apos;A&apos; is a lexical rule which
adds adjuncts to verbs, &apos;D&apos; is a lexical &apos;division&apos; rule which enables a control or raising verb to combine with
arguments of higher arity, and `o&apos; is a unary modal operator which diacritically marks infinitival verbs.
</figureCaption>
<bodyText confidence="0.998159619047619">
as : B&apos; where H is an atom (the head) and B
is a list of atoms (the negative literals).
The atom x(Cat, Left, Right) is true if the sub-
string between the two string positions Left and
Right can be analyzed as belonging to category Cat.
(As is standard, we use suffixes of the input string
for string positions).
The modal operator 13&apos; is used to diacritically
mark untensed verbs (e.g., ontwijken), and prevent
them from combining with their arguments. Thus
untensed verbs must combine with other verbs which
subcategorize for them (e.g., lijkt te), forcing all
verbs to appear in a &apos;verb cluster&apos; at the end of a
clause.
For simplicity we have not provided a semantics
here, but it is easy to add a &apos;semantic interpretation&apos;
as a fourth argument in the usual manner. The for-
ward and backward application rules are specified as
clauses of x/3. Note that the application rules are
left-recursive, so a top-down parser will in general
fail to terminate with such a grammar.
</bodyText>
<equation confidence="0.911674666666667">
op(990, xfx, ). % Clause operator
op(400, yfx, \ ). % Backward combinator
op(300, fy, # ). % Modal operator ID&apos;
</equation>
<construct confidence="0.448702">
x(X, Left, Right) ::-C % Forward application
x(X/Y, Left, Mid),
x(Y, Mid, Right) 3.
x(X, Left, Right) ::- [ % Backward application
x(Y, Left, Mid),
x(X\Y, Mid, Right) 3.
x(X, Nord1Words3, Words) : C
lex(Word, X) 3.
</construct>
<bodyText confidence="0.998259">
Lexical entries are formalized using a two place re-
lation lex( Word, Cat), which is true if Cat is a ca-
tegory that the lexicon assigns to Word.
</bodyText>
<equation confidence="0.92435925">
lex(&apos;Frits&apos;, np) 0.
lex(&apos;Marie&apos;, np)
lex(opzettelijk, adv) 0.
lex(ontvijken, *I )
add_adjuncts(s\np\ap, I ) 3.
lex(lijkt_te, I / *Y )
add_adjuncts((s\np)/(s\up), I0),
division(I0, X/Y ) 3.
</equation>
<bodyText confidence="0.996336333333333">
The add_adjuncts/2 and division/2 predicates
formalize the lexical rules &apos;A&apos; (which adds adjuncts
to verbs) and &apos;EY (the division rule).
</bodyText>
<equation confidence="0.653869">
add_adjuncts(s, s) 0.
add_adjuncts(I, Y\adv)
add_adjuncts(I, Y) 3.
add_adjuncts(X\l, T\A) [
add_adjuncts(X, Y) 3.
add_adjuncts(X/k, T/A)
add_adjuncts(X, T) 3.
division(X, I) ::- 0.
division(IO/YO, (1\2)/(Y\Z)) [
division(IO/YO, X/Y) 3.
</equation>
<bodyText confidence="0.999952333333333">
Note that the definitions of add_adjuncts/2 and
division/2 are recursive, and have an infinite num-
ber of solutions when only their first arguments are
instantiated. This is necessary because the num-
ber of adjuncts that can be associated with any
given verb is unbounded. Thus it is infeasible
to enumerate all of the categories that could be
associated with a verb when it is retrieved from
the lexicon, so following BN, we treat the predica-
tes add_adjuncts/2 and division/2 as coroutined
constraints which are only resolved when their se-
cond arguments become sufficiently instantiated.
As noted above, this kind of constraint corouti-
ning is built-in to a number of Prolog implemen-
tations. Unfortunately, the left recursion inherent
in the combinatory rules mentioned earlier dooms
any standard backtracking top-down parser to non-
termination, no matter how coroutining is applied to
</bodyText>
<page confidence="0.998123">
101
</page>
<bodyText confidence="0.98766">
the lexical constraints. As is well-known, memoizing
parsers do not suffer from this deficiency, and we
present a memoizing interpreter below which does
terminate.
</bodyText>
<sectionHeader confidence="0.981525" genericHeader="method">
3 The Lemma Table proof procedure
</sectionHeader>
<bodyText confidence="0.951008">
This section presents a coroutining, memoizing CLP
proof procedure. The basic intuition behind our ap-
proach is quite natural in a CLP setting like the one
of Hafeld and Smolka, which we sketch now.
A program is a set of definite clauses of the form
</bodyText>
<equation confidence="0.827193">
p(X) qi(Xi) A ... A qn(X) A
</equation>
<bodyText confidence="0.9998388">
where the Xi are vectors of variables, p(X) and
qi(Xi) are relational atoms and 0 is a basic cons-
traint coming from a basic constraint language C.
will typically refer to some (or all) of the variables
mentioned. The language of basic constraints is clo-
sed under conjunction and comes with (computable)
notions of consistency (of a constraint) and entail-
ment (411 =c 462) which have to be invariant under
variable renaming.&apos; Given a program P and a goal
G, which is a conjunction of relational atoms and
constraints, a P-answer of G is defined as a consi-
stent basic constraint 4, such that G is valid in
every model of P. SLD-resolution is generalized in
this setting by performing resolution only on rela-
tional atoms and simplifying (conjunctions of) basic
constraints thus collected in the goal list. When fi-
nally only a consistent basic constraint remains, this
is an answer constraint 0. Observe that this use of
basic constraints generalizes the use of substitutions
in ordinary logic programming and the (simplifica-
tion of a) conjunction of constraints generalizes uni-
fication. Actually, pure Prolog can be viewed as a
syntactically sugared variant of such a CLP language
with equality constraints as basic constraints, where
a standard Prolog clause
</bodyText>
<equation confidence="0.749801">
p(T) 4— qi (Ti ), • • • , (Tn )
</equation>
<bodyText confidence="0.995192666666667">
is seen as an abbreviation for a clause in which
the equality constraints have been made explicit by
means of new variables and new equalities
</bodyText>
<equation confidence="0.985881">
P(X) 4— X = T, Xi = • • • , Xn = Tn
</equation>
<bodyText confidence="0.994921150943396">
Here the Xi are vectors of variables and the Ti are
vectors of terms.
Now consider a standard memoizing proof proce-
dure such as Earley Deduction (Pereira and War-
ren 1983) or the memoizing procedures described
by Tamaki and Sato (1986), Vieille (1989) or War-
ren (1992) from this perspective. Each memoized
goal is associated with a set of bindings for its ar-
guments; so in CLP terms each memoized goal is a
&apos;This essentially means that basic constraints can be
recast as first-order predicates.
conjunction of a single relational atom and zero or
more equality constraints. A completed (i.e., ato-
mic) clause p(T) with an instantiated argument T
abbreviates the non-atomic clause p(X) 4-- X = T,
where the equality constraint makes the instantia-
tion specific. Such equality constraints are &apos;inheri-
ted&apos; via resolution by any clause that resolves with
the completed clause.
In the CLP perspective, variable-binding or equa-
lity constraints have no special status; informally,
all constraints can be treated in the same way that
pure Prolog treats equality constraints. This is the
central insight behind the Lemma Table proof proce-
dure: general constraints are permitted to propagate
into and out of subcomputations in the same way
that Earley Deduction propagates variable bindings.
Thus the Lemma Table proof procedure generalizes
Earley Deduction in the following ways:
1. Memoized goals are in general conjunctions of
relational atoms and constraints. This allows
constraints to be passed into a memoized sub-
computation.
We do not use this capability in the categorial
grammar example (except to pass in variable
bindings), but it is important in GB and HPSG
parsing applications. For example, memoized
goals in our GB parser consist of conjunctions
of X&apos; and ECP constraints. Because the X&apos;
phrase-structure rules freely permit empty ca-
tegories every string has infinitely many well-
formed analyses that satisfy the X&apos; constraints,
but the conjoined ECP constraint rules out all
but a very few of these empty nodes.
2. Completed clauses can contain arbitrary ne-
gative literals (rather than just equality cons-
traints, as in Earley Deduction). This allows
constraints to be passed out of a memoized sub-
computation.
In the categorial grammar example, the
add_adjuncts/2 and division/2 associated
with a lexical entry cannot be finitely resolved,
as noted above, so e.g., a clause
</bodyText>
<equation confidence="0.952634">
x(ttx, rontvijkan3 , 0) :
C add_adjuncts(s\np\np, X ) 3.
</equation>
<bodyText confidence="0.82804">
is classified as a completed clause; the
add_adjuncts/2 constraint in its body is inhe-
rited by any clause which uses this lemma.
</bodyText>
<listItem confidence="0.85902725">
3. Subgoals can be selected in any order (Earley
Deduction always selects goals in left-to-right
order). This allows constraint coroutining wi-
thin a memoized subcomputation.
</listItem>
<bodyText confidence="0.9995494">
In the categorial grammar example, a cate-
gory becomes more instantiated when it com-
bines with arguments, allowing eventually the
add_adjuncts/2 and division/2 to be deter-
ministically resolved. Thus we use the flexibility
</bodyText>
<page confidence="0.995309">
102
</page>
<bodyText confidence="0.996023298969072">
in the selection of goals to run constraints whe-
never their arguments are sufficiently instantia-
ted, and delay them otherwise.
4. Memoization can be selectively applied (Earley
Deduction memoizes every computational step).
This can significantly improve overall efficiency.
In the categorial grammar example only x/3
goals are memoized (and thus only these goals
incur the cost of table management).
The &apos;abstraction&apos; step, which is used in most me-
moizing systems (including complex feature gram-
mar chart parsers where it is somewhat confusingly
called &apos;restriction&apos;, as in Shieber 1985), receives an
elegant treatment in a CLP approach; an &apos;abstrac-
ted&apos; goal is merely one in which not all of the equality
constraints associated with the variables appearing
in the goal are selected with that goal.2
For example, because of the backward application
rule and the left-to-right evaluation our parser uses,
eventually it will search at every left string position
for an uninstantiated category (the variable Y in the
clause), we might as well abstract all memoized goals
of the form x(C, L, R) to x(_, L,_), i.e., goals in which
the category and right string position are uninstan-
tiated. Making the equality constraints explicit, we
see that the abstracted goal is obtained by merely
selecting the underlined subset of these below:
x(Xi, X2, Xz), Xi 7-- C, X2 = L, X3 = R.
While our formal presentation does not discuss ab-
straction (since it can be implemented in terms of
constraint selection as just described), because our
implementation uses the underlying Prolog&apos;s unifi-
cation mechanism to solve equality constraints over
terms, it provides an explicit abstraction operation.
Now we turn to the specification of the algorithm
itself, beginning with the basic computational enti-
ties it uses.
Definition 1 A (generalized) goal is a multiset of
relational atoms and constraints. A (generalized)
clause Ho BO is an ordered pair of generalized
goals, where Ho contains at least one relational
atom. A relational interpretation A (see Holifeld
and Smolka 1988 for definition) satisfies a goal G if
A satisfies each element of G, and it satisfies a clause
Ho 4- Bo if either A fails to satisfy some element of
Bo or A satisfies each element of Ho.
2After this paper was accepted, we discovered that a
more general formulation of abstraction is required for
systems using a hierarchy of types, such as typed feature
structure constraints (Carpenter 1992). In applications
of the Lemma Table Proof Procedure to such systems it
may be desirable to abstract from a &apos;strong&apos; type cons-
traint in the body of a clause to a logically &apos;weaker&apos; type
constraint in the memoized goal. Such a form of ab-
straction cannot be implemented using the selection rule
alone.
This generalizes the standard notion of clause by
allowing the head Ho to consist of more than one
atom. The head Ho is interpreted conjunctively; i.e.,
if each element of Bo is true, then so is each element
of Ho. The standard definition of resolution extends
unproblematically to such clauses.
Definition 2 We say that a clause co = Ho Bo
resolves with a clause c1 = H1 B1 on a non-empty
set of literals C C Bo if there is a variant c1&apos; of c1 of
the form C Bl&apos; such that V(co)OV(B11) c V(C)
(i.e., the variables common to co and Bl&apos; also appear
in C, so there is no accidental variable sharing).
If co resolves with ci on C, then the clause
Ho 4— (Bo — C) U Bl&apos; is called a resolvent of c0 with
ci on C.
Now we define items, which are the basic computa-
tional units that appear on the agenda and in the
lemma tables, which record memoized subcomputa-
tions.
Definition 3 An item is a pair (I, c) where c is a
clause and t is a tag, i.e., one of program, solution or
table(B) for some goal B. A lemma table for a goal
G is a pair (G, LG) where L0 is a finite list of items.
The algorithm manipulates a set T of lemma tables
which has the property that the first components of
any two distinct members of T are distinct. This
justifies speaking of the (unique) lemma table in T
for a goal G.
Tags are associated with clauses by a user-
specified control rule, as described below. The tag
associated with a clause in an item identifies the ope-
ration that should be performed on that clause. The
solution tag labels &apos;completed&apos; clauses, the program
tag directs the proof procedure to perform a non-
memoizing resolution of one of the clause&apos;s negative
literals with program clauses (the particular nega-
tive literal is chosen by a user-specified selection rule,
as in standard SLD resolution), and the table(B) tag
indicates that a subcomputation with root goal B
(which is always a subset of the clause&apos;s negative
literals) should be started.
</bodyText>
<subsectionHeader confidence="0.687112">
Definition 4 A control rule is a function from clau-
</subsectionHeader>
<bodyText confidence="0.9217085">
ses G B to one of program, solution or table(C) for
some goal C C B. A selection rule is a function from
clauses G B where B contains at least one rela-
tional atom to relational atoms a, where a appears
in B.
Because program steps do not require memoization
and given the constraints on the control rule just
mentioned, the list L0 associated with a lemma
table (G, LG) will only contain items of the form
(t,G B) where t is either solution or table(C) for
some goal C C B.
Definition 5 To add an item an item e =
(t, H B) to its table means to replace the table
(H, L) in T with (H,[elL]).
</bodyText>
<page confidence="0.996851">
103
</page>
<figure confidence="0.691635111111111">
Input A non-empty goal G, a program P, a selection rule S, and a control rule R.
Output A set of goals G&apos; for which R(G&apos;) = solution and P G 4— G&apos;.
Global Data Structures A set T of lemma tables and a set A of items called the agenda.
Algorithm Set T := {(G,0)} and A := {(program,G G)}.
Until A is empty, do:
Remove an item e = (t, c) from A.
Case t of
program For each clause p E P such that c resolves with p on S(c), choose a corresponding resolvent
c&apos; and add (R(c&apos;), c&apos;) to A.
table(B) Add e to its table.3
If T contains a table (B&apos;, L) where B&apos; is a variant of B then for each item (solution, ci) E L such
that c resolves with c&apos; on B choose a corresponding resolvent c&amp;quot; and add (R(c&amp;quot;), c&amp;quot;) to A.
Otherwise, add a new table (B4O) to T, and add (program, B B) to the agenda.
solution Add e to its table.
Let c = H B. Then for each item of the form (table(H&apos;), ci) in any table in T where H&apos; is a
variant of H and c&apos; resolves with c on H&apos;, choose a corresponding resolvent c&amp;quot; and add (R(c&amp;quot;), c&amp;quot;)
to A.
Set r {B : (solution, G B) E L, (G, L) E T}.
</figure>
<figureCaption confidence="0.999853">
Figure 2: The Lemma Table algorithm
</figureCaption>
<bodyText confidence="0.999974230769231">
The formal description of the Lemma Table proof
procedure is given in Figure 2. We prove the so-
undness and completeness of the proof procedure in
Done and Johnson (in preparation). In fact, so-
undness is easy to show, since all of the operations
are resolution steps. Completeness follows from the
fact that Lemma Table proofs can be `unfolded&apos; into
standard SLD search trees (this unfolding is well-
founded because the first step of every table-initiated
subcomputation is required to be a program reso-
lution), so completeness follows from Hafeld and
Smolka&apos;s completeness theorem for SLD resolution
in CLP.
</bodyText>
<sectionHeader confidence="0.994544" genericHeader="method">
4 A worked example
</sectionHeader>
<bodyText confidence="0.948048934782609">
Returning to the categorial grammar example above,
the control rule and selection rule are specified by
the Prolog code below, which can be informally
described as follows. All x/3 literals are classi-
fied as `memo&apos; literals, and add_adjuncts/2 and
division/2 whose second arguments are not suf-
ficiently instantiated are classified as &apos;delay&apos; literals.
If the clause contains a memo literal G, then the con-
trol rule returns table([G]). Otherwise, if the clause
contains any non-delay literals, then the control rule
&apos;In order to handle the more general form of abstrac-
tion discussed in footnote 2 which may be useful with ty-
ped feature structure constraints, replace B with a(B)
in this step, where a(B) is the result of applying the
abstraction operation to B.
The abstraction operation should have the property
that a(B) is exactly the same as B, except that zero or
more constraints in B are replaced with logically weaker
constraints.
returns program and the selection rule chooses the
left-most such literal. If none of the above apply,
the control rule returns solution. To simplify the in-
terpreter code, the Prolog code for the selection rule
and table(G) output of the control rule also return
the remaining literals along with chosen goal.
ensure_loaded(library(lists)).
op(990, fx, [delay, memo]).
delay division(_. X/Y) var(X), var(Y).
delay add_adjuncts(_, X/Y) var(X), var(Y).
memo
control(Gs0, Control) :-
memo(G), select(G, Gs0, Gs)
-&gt; Control = table([G], Gs)
member(G, Gs0), \+ delay(G)
-&gt; Control = program ;
Control = solution.
selection(Gs0, G, Gs) :-
select(G1, Gs0, Gal), delay(G1)
-&gt; G = Cl, Gs = Gal.
Because we do not represent variable binding as ex-
plicit constraints, we cannot implement &apos;abstraction&apos;
by means of the control rule and require an explicit
abstraction operation. The abstraction operation
here unbinds the first and third arguments of x/3
goals, as discussed above.
abstraction( a (_ sLeft,_)] , ,Lett ,_)3 ) .
</bodyText>
<page confidence="0.963263">
104
</page>
<figure confidence="0.997625789473684">
0.1[0] P
0.2[1] T
0.3[1] T
0.4[1] P
0.5[4] S
0.6[2,5] T
1.7[6] P
1.8[7] T
1.9[7] T
1.10[7] P
1.11[10] S
O.12[6,11] S
0.13[2,12] T
2.14[13] P
2.15[14] T
2.16[14] T
0.17[3,12] T
1.18[9,11] T
0.19[3,5] T
</figure>
<bodyText confidence="0.764822684210526">
x(A, [Lt, o], B) x(A, [Lt, o], B).
x(A, [Lt, o], B) x(A/C, [Lt, o], D), x(C, D, B).
x(A, [Lt, o], B) x(C, [1-t, o], D), x(A C, D, B).
x(A, [Lt, o], [O]) lex(Lt, A).
x(A/#B, [Lt, [o]) 4-- add(s \ npAs \ np), C), div(C, A/B).
x(A, [Lt, B) add(s \ np/(s \ np), C), div(C, A/D), x(#D, [o], B).
x(A, [o], B) x(A, [o], B).
x(A, [o], B) 4— x(A/C, [o], D), x(C, D, B).
x(A, [o], 13) 4-- x(C, [o], D), x(A C, D, B).
x(A, [o], 0) lex(o, A).
x(#A, [o], 0) 4-- add(s\np\np, A).
x(A, [Lt, o], 0) 4— add(s\np \np, B), add(s\np/(s\np), C), div(C, A/B).
x(A, [Lt, o], B) add(s \ np \ np, C), add(s \np/(s \ np), D), div(D, A/E/C), x(E, 0,B).
x(A, 0, B) 4-&amp;quot; x(A, 0, B).
x(A, 0, B) x(A/C, 0, D), x(C, D, B).
x(A, 0,B) x(C,(],D), x(A\C,D,B).
x(A, [Lt, 01, B) add(s \np \ np, C), add(s \np/(s\np), D), div(D, E/C), x(A \E, [],B).
x(A,[o],B) 4— add(s\np\np,C), x(A\#C, 0,B).
x(A, [Lt, o], B) add(s\np/(s\ np), C), div(C, DIE), x(AVD/#E), [o], B).
</bodyText>
<figureCaption confidence="0.661820166666667">
Figure 3: The items produced during the proof of x(C,Clijkt_te,ontwijkenJ,_) using the control and
selection rules specified in the text. The prefix tn[a] T identifies the table t to which this item belongs,
assigns this item a unique identifying number n, provides the number(s) of the item(s) a which caused this
item to be created, and displays its tag T (P for &apos;program&apos;, T for &apos;table&apos; and S for `solution&apos;). The selected
literal(s) are shown underlined. To save space, `add_adjuncts&apos; is abbreviated by &apos;add&apos;, &apos;division&apos; by &apos;div&apos;,
`lijkt_te&apos; by `le, and `ontwijken&apos; by &apos;o&apos;.
</figureCaption>
<bodyText confidence="0.99650185">
Figure 3 depicts the proof of a parse of the verb clu-
ster in (1). Item 1 is generated by the initial goal;
its sole negative literal is selected for program reso-
lution, producing items 2-4 corresponding to three
program clauses for x/3. Because items 2 and 3 con-
tain &apos;memo&apos; literals, the control rule tags them table;
there already is a table for a variant of these goals
(after abstraction). Item 4 is tagged program bec-
ause it contains a negative literal that is not &apos;memo&apos;
or &apos;delay&apos;; the resolution of this literal with the pro-
gram clauses for lex/3 produces item 5 containing
the constraint literals associated with lijkt te. Both
of these are classified as &apos;delay&apos; literals, so item 5 is
tagged solution, and both are &apos;inherited&apos; when item 5
resolves with the table-tagged items 2 and 3, produ-
cing items 6 (corresponding to a right application
analysis with Izjkt le as functor) and item 19 (cor-
responding to a left application analysis with ont-
wijken as functor) respectively. Item 6 is tagged
table, since it contains a x/3 literal; because this
goal&apos;s second argument (i.e., the left string position)
differs from that of the goal associated with table 0,
a new table (table 1) is constructed, with item 7 as
its first item.
The three program clauses for x/3 are used to re-
solve the selected literal in item 7, just as in item 1,
yielding items 8-10. The lex/3 literal in item 10 is
resolved with the appropriate program clause, pro-
ducing item 11. Just as in item 5, the second argu-
ment of the single literal in item 11 is not sufficiently
instantiated, so item 11 is tagged solution, and the
unresolved literal is &apos;inherited&apos; by item 12. Item 12
contains the partially resolved analysis of the verb
complex. Items 13-16 analyze the empty string;
notice that there are no solution items for table 2.
Items 17-19 represent partial alternative analyses of
the verb cluster where the two verbs combine using
other rules than forward application; again, these
yield no solution items, so item 12 is the sole analy-
sis of the verb cluster.
</bodyText>
<sectionHeader confidence="0.993598" genericHeader="method">
5 A simple interpreter
</sectionHeader>
<bodyText confidence="0.999907714285714">
This section describes an implementation of the
Lemma Table proof procedure in Prolog, designed
for simplicity rather than efficiency. Tables are
stored in the Prolog database, and no explicit agenda
is used. The dynamic predicate goal_table(G, I)
records the initial goals G for each table subcompu-
tation and that table&apos;s identifying index I (a number
assigned to each table when it is created). The dy-
namic predicate table-solution(i, S) records all of
the solution items generated for table I so far, and
table_parent(I, T) records the table items T, called
&apos;parent items&apos; below, which are &apos;waiting&apos; for additio-
nal solution items from table I.
The &apos;top level&apos; goal is prove(G,Cs), where G is
</bodyText>
<page confidence="0.997618">
105
</page>
<bodyText confidence="0.9929474">
a single atom (the goal to be proven), and Cs is
a list of (unresolved) solution constraints (different
solutions are enumerated through backtracking).
prove/2 starts by retracting the tables associa-
ted with previous computations, asserting the table
entry associated with the initial goal, and then calls
take_action/ 2 to perform a program resolution on
the initial goal. After all succeeding steps are com-
plete, prove/2 returns the solutions associated with
table 0.
</bodyText>
<reference confidence="0.4607783">
prove(Goal, _Constraints) :-
retractall(goal_table(_,_)),
retractall(table_solution(_,_))
retractall(table_parent(_, _)),
retractall(counter(i),
assert(goal_table([Goal], 0)),
take_action(program, [Goal]::-[Goal], 0),
fail.
prove(Goal, Constraints) :-
table_solution(0, [Goal]::-Constraints).
</reference>
<bodyText confidence="0.9985475">
The predicate take_action(L, C, I) processes items.
L is the item&apos;s label, C its clause and I is the in-
dex of the table it belongs to. The first clause
calls complete/2 to resolve the solution clause with
any parent items the table may have, and the third
clause constructs a parent item term (which enco-
des both the clause, the tabled goal, and the in-
dex of the table the item belongs to) and calls
insert_into_table/2 to insert it into the appro-
priate table.
</bodyText>
<reference confidence="0.90485656">
take_action(solution, Clause, Index) :-
assert(table_solution(Index, Clause)),
findall(P, table_parent(Index, P),
ParentItems),
member(ParentItem, ParentItems),
complete(ParentItem, Clause).
take_action(program, Head::-Goal, Index) :-
selection(Goal, Selected, Body1),
Selected ::- Body0,
append(Body0, Body1, Body),
control(Body, Action),
take_action(Action, Head::-Body, Index).
take_action(table(Goal,Other), Bead: :-_Body,
Index) :-
insert_into_table(Goal,
tableItem(Head, Goal, Other, Index)).
complete/2 takes an item labeled table and a clause,
resolves the head of the clause with the item, and
calls control/2 and take_action/3 to process the
resulting item.
complete(tableItem(Head, Goal, Body1, Index),
Goal::-Body0) :-
append(Body0, Body1, Body),
control(Body, Action),
take_action(Action, Head::-Body, Index).
</reference>
<bodyText confidence="0.968470833333333">
The first clause ins ert_into_table/2 checks to see
if a table for the goal to be tabled has already been
constructed (numbervars/3 is used to ground a copy
of the term). If an appropriate table does not exist,
the second clause calls create_table/3 to construct
one.
</bodyText>
<reference confidence="0.88543768">
insert_into_table(Goal, ParentItem) :-
copy_term(Goal, GoalCopy),
numbervars(GoalCopy, 0, _),
goal_table(GoalCopy, Index),
!,
assert(table_parent(Index, ParentItem)),
findall(Sol, table_solution(Index, Sol),
Solutions), !,
member(Solution, Solutions),
complete(ParentItem, Solution).
insert_into_table(Goa10, ParentItem) :-
abstraction(Goa10, Goal), !,
create_table(Goal, ParentItem, Index),
take_action(program, Goal:: -Goal, Index).
create_table/3 performs the necessary database
manipulations to construct a new table for the goal,
assigning a new index for the table, and adding ap-
propriate entries to the indices.
create_table(Goal, ParentItem, Index) :-
(retract(counter(Index0)) -&gt; true
; Index0=0),
Index is Index0+1,
assert(counter(Index)),
assert(goal_table(Goal, Index)),
assert(table_parent(Index, ParentItem)).
</reference>
<sectionHeader confidence="0.996945" genericHeader="conclusions">
6 Conclusion
</sectionHeader>
<bodyText confidence="0.999986142857143">
This paper has presented a general framework which
allows both constraint coroutining and memoiza-
tion. To achieve maximum generality we stated
the Lemma Table proof procedure in Hohfeld and
Smolka&apos;s (1988) CLP framework, but the basic
idea—that arbitrary constraints can be allowed to
propagate in essentially the same way that variable
bindings do—can be applied in most approaches to
complex feature based parsing. For example, the
technique can be used in chart parsing: in such a
system an edge consists not only of a dotted rule
and associated variable bindings (i.e., instantiated
feature terms), but also contains zero or more as
yet unresolved constraints that are propagated (and
simplified if sufficiently instantiated) during applica-
tion of the fundamental rule.
At a more abstract level, the identical propagation
of both variable bindings and more general cons-
traints leads us to question whether there is any
principled difference between them. While still preli-
minary, our research suggests that it is often possible
</bodyText>
<page confidence="0.994178">
106
</page>
<bodyText confidence="0.9935585">
to reexpress complex feature based grammars more
succinctly by using more general constraints.
</bodyText>
<sectionHeader confidence="0.996282" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999801666666667">
G. Bouma and G. van Noord. Constraint-Based Ca-
tegorial Grammar. In Proceedings of the 32nd An-
nual Meeting of the ACL, New Mexico Stale Uni-
versity, Las Cruces, New Mexico, 1994.
B. Carpenter. The Logic of Typed Feature Structu-
res. Cambridge Tracts in Theoretical Computer
Science 32. Cambridge University Press. 1992.
J. DOrre. Generalizing Earley deduction for
constraint-based grammars. In J. DOrre
(ed.), Computational Aspects of Constraint-Based
Linguistic Description I, DYA NA-2 deliverable
R1.2.A. ESPRIT, Basic Research Project 6852,
July 1993.
J. DOrre and M. Johnson. Memoization and co-
routined constraints. ms. Institut fiir maschinelle
Sprachverarbeitung, Universitat Stuttgart.
M. Hohfeld and G. Smolka. Definite Relations over
Constraint Languages. LILOG Report 53, IWBS,
IBM Deutschland, Postfach 80 08 80, 7000 Stutt-
gart 80, W. Germany, October 1988. (available
on-line by anonymous ftp from /duck.dfki.uni—
sb.delpub/papers)
M. Johnson. Memoization in Constraint Logic
Programming. Presented at First Workshop on
Principles and Practice of Constraint Program-
ming, April 28-30 1993, Newport, Rhode Island.
F. C. Pereira and D. H. Warren. Parsing as Deduc-
tion. In Proceedings of the 21st Annual Meeting of
the ACL, Massachusetts Institute of Technology,
pp. 137-144, Cambridge, Mass., 1983.
S. M. Shieber. Using Restriction to Extend Par-
sing Algorithms for Complex-Feature-Based For-
malisms. In Proceedings of the 23rd Annual Mee-
ting of the Association for Computational Lingui-
stics, pp. 145-152, 1985.
Tamaki, H. and T. Sato. &amp;quot;OLDT resolution with
tabulation&amp;quot;, in Proceedings of Third Internatio-
nal Conference on Logic Programming, Springer-
Verlag, Berlin, pages 84-98. 1986.
Vieille, L. &amp;quot;Recursive query processing: the power of
logic&amp;quot;, Theoretical Computer Science 69, pages 1-
53. 1989.
Warren, D. S. &amp;quot;Memoing for logic programs&amp;quot;, in
Communications of the ACM 35:3, pages 94-111.
1992.
</reference>
<page confidence="0.998698">
107
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.358927">
<title confidence="0.999809">Memoization of Coroutined Constraints</title>
<author confidence="0.999989">Mark Johnson</author>
<pubnum confidence="0.594865">Cognitive and Linguistic Sciences, Box 1978</pubnum>
<affiliation confidence="0.999972">Brown University</affiliation>
<address confidence="0.999175">Providence, RI 02912, USA</address>
<email confidence="0.994618">Mark_Johnson@Brown.edu</email>
<author confidence="0.653761">Jochen Dorre</author>
<affiliation confidence="0.997798">Institut fiir maschinelle Sprachverarbeitung Universitat Stuttgart</affiliation>
<address confidence="0.999811">D-70174 Stuttgart, Germany</address>
<email confidence="0.989982">Jochen.Doerreeims.uni—stuttgart.de</email>
<abstract confidence="0.995315153846154">Some linguistic constraints cannot be effectively resolved during parsing at the location in which they are most naturally introduced. This paper shows how constraints can be propagated in a memoizing parser (such as a chart parser) in much the same way that variable bindings are, providing a general treatment of constraint coroutining in memoization. Prolog code for a simple application of our technique to Bouma and van Noord&apos;s (1994) categorial grammar analysis of Dutch is provided.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<authors>
<author>prove</author>
</authors>
<title>retractall(goal_table(_,_)), retractall(table_solution(_,_)) retractall(table_parent(_, _)), retractall(counter(i), assert(goal_table([Goal], 0)), take_action(program,</title>
<journal>[Goal]::-[Goal],</journal>
<volume>0</volume>
<pages>fail.</pages>
<marker>prove, </marker>
<rawString>prove(Goal, _Constraints) :-retractall(goal_table(_,_)), retractall(table_solution(_,_)) retractall(table_parent(_, _)), retractall(counter(i), assert(goal_table([Goal], 0)), take_action(program, [Goal]::-[Goal], 0), fail.</rawString>
</citation>
<citation valid="false">
<authors>
<author>prove</author>
</authors>
<tech>Constraints) :-table_solution(0, [Goal]::-Constraints).</tech>
<marker>prove, </marker>
<rawString>prove(Goal, Constraints) :-table_solution(0, [Goal]::-Constraints).</rawString>
</citation>
<citation valid="false">
<authors>
<author>takeaction</author>
</authors>
<title>Index) :-assert(table_solution(Index,</title>
<location>Clause)), findall(P, table_parent(Index, P), ParentItems), member(ParentItem, ParentItems), complete(ParentItem, Clause).</location>
<marker>takeaction, </marker>
<rawString>take_action(solution, Clause, Index) :-assert(table_solution(Index, Clause)), findall(P, table_parent(Index, P), ParentItems), member(ParentItem, ParentItems), complete(ParentItem, Clause).</rawString>
</citation>
<citation valid="false">
<authors>
<author>takeaction</author>
</authors>
<title>Index) :-selection(Goal,</title>
<location>Selected, Body1), Selected ::- Body0, append(Body0, Body1, Body), control(Body, Action),</location>
<marker>takeaction, </marker>
<rawString>take_action(program, Head::-Goal, Index) :-selection(Goal, Selected, Body1), Selected ::- Body0, append(Body0, Body1, Body), control(Body, Action),</rawString>
</citation>
<citation valid="false">
<authors>
<author>takeaction takeaction</author>
</authors>
<title>Bead: :-_Body, Index) :-insert_into_table(Goal, tableItem(Head, Goal, Other, Index)). complete/2 takes an item labeled table and a clause, resolves the head of the clause with the item, and calls control/2 and take_action/3 to process the resulting item.</title>
<marker>takeaction, </marker>
<rawString>take_action(Action, Head::-Body, Index). take_action(table(Goal,Other), Bead: :-_Body, Index) :-insert_into_table(Goal, tableItem(Head, Goal, Other, Index)). complete/2 takes an item labeled table and a clause, resolves the head of the clause with the item, and calls control/2 and take_action/3 to process the resulting item.</rawString>
</citation>
<citation valid="false">
<authors>
<author>complete</author>
</authors>
<location>Body1, Index), Goal::-Body0) :-append(Body0, Body1, Body), control(Body, Action), take_action(Action, Head::-Body, Index).</location>
<marker>complete, </marker>
<rawString>complete(tableItem(Head, Goal, Body1, Index), Goal::-Body0) :-append(Body0, Body1, Body), control(Body, Action), take_action(Action, Head::-Body, Index).</rawString>
</citation>
<citation valid="false">
<authors>
<author>insertintotable -copyterm</author>
</authors>
<volume>0</volume>
<location>goal_table(GoalCopy, Index), !,</location>
<marker>-copyterm, </marker>
<rawString>insert_into_table(Goal, ParentItem) :-copy_term(Goal, GoalCopy), numbervars(GoalCopy, 0, _), goal_table(GoalCopy, Index), !,</rawString>
</citation>
<citation valid="false">
<authors>
<author>findall</author>
</authors>
<location>Solutions), !, member(Solution, Solutions), complete(ParentItem, Solution).</location>
<marker>findall, </marker>
<rawString>assert(table_parent(Index, ParentItem)), findall(Sol, table_solution(Index, Sol), Solutions), !, member(Solution, Solutions), complete(ParentItem, Solution).</rawString>
</citation>
<citation valid="false">
<authors>
<author>insertintotable -abstraction</author>
</authors>
<title>Index), take_action(program, Goal:: -Goal, Index). create_table/3 performs the necessary database manipulations to construct a new table for the goal, assigning a new index for the table, and adding appropriate entries to the indices.</title>
<marker>-abstraction, </marker>
<rawString>insert_into_table(Goa10, ParentItem) :-abstraction(Goa10, Goal), !, create_table(Goal, ParentItem, Index), take_action(program, Goal:: -Goal, Index). create_table/3 performs the necessary database manipulations to construct a new table for the goal, assigning a new index for the table, and adding appropriate entries to the indices.</rawString>
</citation>
<citation valid="false">
<authors>
<author>createtable</author>
</authors>
<booktitle>Index) :-(retract(counter(Index0)) -&gt; true ; Index0=0),</booktitle>
<marker>createtable, </marker>
<rawString>create_table(Goal, ParentItem, Index) :-(retract(counter(Index0)) -&gt; true ; Index0=0),</rawString>
</citation>
<citation valid="false">
<booktitle>Index is Index0+1, assert(counter(Index)), assert(goal_table(Goal, Index)), assert(table_parent(Index, ParentItem)).</booktitle>
<marker></marker>
<rawString>Index is Index0+1, assert(counter(Index)), assert(goal_table(Goal, Index)), assert(table_parent(Index, ParentItem)).</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Bouma</author>
<author>G van Noord</author>
</authors>
<title>Constraint-Based Categorial Grammar.</title>
<date>1994</date>
<booktitle>In Proceedings of the 32nd Annual Meeting of the ACL,</booktitle>
<institution>Mexico Stale University, Las Cruces,</institution>
<location>New</location>
<marker>Bouma, van Noord, 1994</marker>
<rawString>G. Bouma and G. van Noord. Constraint-Based Categorial Grammar. In Proceedings of the 32nd Annual Meeting of the ACL, New Mexico Stale University, Las Cruces, New Mexico, 1994.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Carpenter</author>
</authors>
<title>The Logic of Typed Feature Structures. Cambridge Tracts in Theoretical Computer Science 32.</title>
<date>1992</date>
<publisher>Cambridge University Press.</publisher>
<contexts>
<context position="14845" citStr="Carpenter 1992" startWordPosition="2381" endWordPosition="2382">ultiset of relational atoms and constraints. A (generalized) clause Ho BO is an ordered pair of generalized goals, where Ho contains at least one relational atom. A relational interpretation A (see Holifeld and Smolka 1988 for definition) satisfies a goal G if A satisfies each element of G, and it satisfies a clause Ho 4- Bo if either A fails to satisfy some element of Bo or A satisfies each element of Ho. 2After this paper was accepted, we discovered that a more general formulation of abstraction is required for systems using a hierarchy of types, such as typed feature structure constraints (Carpenter 1992). In applications of the Lemma Table Proof Procedure to such systems it may be desirable to abstract from a &apos;strong&apos; type constraint in the body of a clause to a logically &apos;weaker&apos; type constraint in the memoized goal. Such a form of abstraction cannot be implemented using the selection rule alone. This generalizes the standard notion of clause by allowing the head Ho to consist of more than one atom. The head Ho is interpreted conjunctively; i.e., if each element of Bo is true, then so is each element of Ho. The standard definition of resolution extends unproblematically to such clauses. Defi</context>
</contexts>
<marker>Carpenter, 1992</marker>
<rawString>B. Carpenter. The Logic of Typed Feature Structures. Cambridge Tracts in Theoretical Computer Science 32. Cambridge University Press. 1992.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J DOrre</author>
</authors>
<title>Generalizing Earley deduction for constraint-based grammars.</title>
<date>1993</date>
<booktitle>Computational Aspects of Constraint-Based Linguistic Description I, DYA NA-2 deliverable R1.2.A. ESPRIT, Basic Research Project 6852,</booktitle>
<editor>In J. DOrre (ed.),</editor>
<marker>DOrre, 1993</marker>
<rawString>J. DOrre. Generalizing Earley deduction for constraint-based grammars. In J. DOrre (ed.), Computational Aspects of Constraint-Based Linguistic Description I, DYA NA-2 deliverable R1.2.A. ESPRIT, Basic Research Project 6852, July 1993.</rawString>
</citation>
<citation valid="false">
<authors>
<author>J DOrre</author>
<author>M Johnson</author>
</authors>
<title>Memoization and coroutined constraints. ms. Institut fiir maschinelle Sprachverarbeitung,</title>
<location>Universitat Stuttgart.</location>
<marker>DOrre, Johnson, </marker>
<rawString>J. DOrre and M. Johnson. Memoization and coroutined constraints. ms. Institut fiir maschinelle Sprachverarbeitung, Universitat Stuttgart.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Hohfeld</author>
<author>G Smolka</author>
</authors>
<title>Definite Relations over Constraint Languages.</title>
<date>1988</date>
<journal>LILOG Report 53, IWBS, IBM Deutschland, Postfach</journal>
<volume>80</volume>
<pages>7000</pages>
<location>Stuttgart 80, W. Germany,</location>
<marker>Hohfeld, Smolka, 1988</marker>
<rawString>M. Hohfeld and G. Smolka. Definite Relations over Constraint Languages. LILOG Report 53, IWBS, IBM Deutschland, Postfach 80 08 80, 7000 Stuttgart 80, W. Germany, October 1988. (available on-line by anonymous ftp from /duck.dfki.uni— sb.delpub/papers)</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Johnson</author>
</authors>
<title>Memoization in Constraint Logic Programming. Presented at</title>
<date>1993</date>
<booktitle>First Workshop on Principles and Practice of Constraint Programming,</booktitle>
<location>Newport, Rhode Island.</location>
<contexts>
<context position="2699" citStr="Johnson (1993)" startWordPosition="396" endWordPosition="398">d suggestions. All remaining errors are our own. The Prolog code presented in this paper is available via anonymous ftp from lx.cog.brown.edu as ipubilemma.tar.Z require systematic variable-renaming (i.e., copying) in order to avoid spurious variable binding. For generality, conciseness and precision, we formalize our approach to memoization and constraints within Holifeld and Smolka&apos;s (1988) general theory of Constraint Logic Programming (CLP), but we discuss how our method can be applied to more standard chart parsing as well. This paper extends our previous work reported in Dorm (1993) and Johnson (1993) by generalizing those methods to arbitrary constraint systems (including feature-structure constraints), even though for reasons of space such systems are not discussed here. 2 Lexical rules in Categorial Grammar This section reviews Bouma and van Noord&apos;s (1994) (BN henceforth) constraint-based categorial grammar analysis of modification in Dutch, which we use as our primary example in this paper. However, the memoizing CLP interpreter presented below has also been applied to GB and HPSG parsing, both of which benefit from constraint coroutining in parsing. BN can explain a number of puzzling</context>
</contexts>
<marker>Johnson, 1993</marker>
<rawString>M. Johnson. Memoization in Constraint Logic Programming. Presented at First Workshop on Principles and Practice of Constraint Programming, April 28-30 1993, Newport, Rhode Island.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F C Pereira</author>
<author>D H Warren</author>
</authors>
<title>Parsing as Deduction.</title>
<date>1983</date>
<booktitle>In Proceedings of the 21st Annual Meeting of the ACL, Massachusetts Institute of Technology,</booktitle>
<pages>137--144</pages>
<location>Cambridge, Mass.,</location>
<contexts>
<context position="9606" citStr="Pereira and Warren 1983" startWordPosition="1542" endWordPosition="1546">plification of a) conjunction of constraints generalizes unification. Actually, pure Prolog can be viewed as a syntactically sugared variant of such a CLP language with equality constraints as basic constraints, where a standard Prolog clause p(T) 4— qi (Ti ), • • • , (Tn ) is seen as an abbreviation for a clause in which the equality constraints have been made explicit by means of new variables and new equalities P(X) 4— X = T, Xi = • • • , Xn = Tn Here the Xi are vectors of variables and the Ti are vectors of terms. Now consider a standard memoizing proof procedure such as Earley Deduction (Pereira and Warren 1983) or the memoizing procedures described by Tamaki and Sato (1986), Vieille (1989) or Warren (1992) from this perspective. Each memoized goal is associated with a set of bindings for its arguments; so in CLP terms each memoized goal is a &apos;This essentially means that basic constraints can be recast as first-order predicates. conjunction of a single relational atom and zero or more equality constraints. A completed (i.e., atomic) clause p(T) with an instantiated argument T abbreviates the non-atomic clause p(X) 4-- X = T, where the equality constraint makes the instantiation specific. Such equalit</context>
</contexts>
<marker>Pereira, Warren, 1983</marker>
<rawString>F. C. Pereira and D. H. Warren. Parsing as Deduction. In Proceedings of the 21st Annual Meeting of the ACL, Massachusetts Institute of Technology, pp. 137-144, Cambridge, Mass., 1983.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S M Shieber</author>
</authors>
<title>Using Restriction to Extend Parsing Algorithms for Complex-Feature-Based Formalisms.</title>
<date>1985</date>
<booktitle>In Proceedings of the 23rd Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>145--152</pages>
<contexts>
<context position="12984" citStr="Shieber 1985" startWordPosition="2073" endWordPosition="2074">e use the flexibility 102 in the selection of goals to run constraints whenever their arguments are sufficiently instantiated, and delay them otherwise. 4. Memoization can be selectively applied (Earley Deduction memoizes every computational step). This can significantly improve overall efficiency. In the categorial grammar example only x/3 goals are memoized (and thus only these goals incur the cost of table management). The &apos;abstraction&apos; step, which is used in most memoizing systems (including complex feature grammar chart parsers where it is somewhat confusingly called &apos;restriction&apos;, as in Shieber 1985), receives an elegant treatment in a CLP approach; an &apos;abstracted&apos; goal is merely one in which not all of the equality constraints associated with the variables appearing in the goal are selected with that goal.2 For example, because of the backward application rule and the left-to-right evaluation our parser uses, eventually it will search at every left string position for an uninstantiated category (the variable Y in the clause), we might as well abstract all memoized goals of the form x(C, L, R) to x(_, L,_), i.e., goals in which the category and right string position are uninstantiated. Ma</context>
</contexts>
<marker>Shieber, 1985</marker>
<rawString>S. M. Shieber. Using Restriction to Extend Parsing Algorithms for Complex-Feature-Based Formalisms. In Proceedings of the 23rd Annual Meeting of the Association for Computational Linguistics, pp. 145-152, 1985.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Tamaki</author>
<author>T Sato</author>
</authors>
<title>OLDT resolution with tabulation&amp;quot;,</title>
<date>1986</date>
<booktitle>in Proceedings of Third International Conference on Logic Programming,</booktitle>
<pages>84--98</pages>
<publisher>SpringerVerlag,</publisher>
<location>Berlin,</location>
<contexts>
<context position="9670" citStr="Tamaki and Sato (1986)" startWordPosition="1553" endWordPosition="1556">on. Actually, pure Prolog can be viewed as a syntactically sugared variant of such a CLP language with equality constraints as basic constraints, where a standard Prolog clause p(T) 4— qi (Ti ), • • • , (Tn ) is seen as an abbreviation for a clause in which the equality constraints have been made explicit by means of new variables and new equalities P(X) 4— X = T, Xi = • • • , Xn = Tn Here the Xi are vectors of variables and the Ti are vectors of terms. Now consider a standard memoizing proof procedure such as Earley Deduction (Pereira and Warren 1983) or the memoizing procedures described by Tamaki and Sato (1986), Vieille (1989) or Warren (1992) from this perspective. Each memoized goal is associated with a set of bindings for its arguments; so in CLP terms each memoized goal is a &apos;This essentially means that basic constraints can be recast as first-order predicates. conjunction of a single relational atom and zero or more equality constraints. A completed (i.e., atomic) clause p(T) with an instantiated argument T abbreviates the non-atomic clause p(X) 4-- X = T, where the equality constraint makes the instantiation specific. Such equality constraints are &apos;inherited&apos; via resolution by any clause that </context>
</contexts>
<marker>Tamaki, Sato, 1986</marker>
<rawString>Tamaki, H. and T. Sato. &amp;quot;OLDT resolution with tabulation&amp;quot;, in Proceedings of Third International Conference on Logic Programming, SpringerVerlag, Berlin, pages 84-98. 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Vieille</author>
</authors>
<title>Recursive query processing: the power of logic&amp;quot;,</title>
<date>1989</date>
<journal>Theoretical Computer Science</journal>
<volume>69</volume>
<pages>1--53</pages>
<contexts>
<context position="9686" citStr="Vieille (1989)" startWordPosition="1557" endWordPosition="1558">g can be viewed as a syntactically sugared variant of such a CLP language with equality constraints as basic constraints, where a standard Prolog clause p(T) 4— qi (Ti ), • • • , (Tn ) is seen as an abbreviation for a clause in which the equality constraints have been made explicit by means of new variables and new equalities P(X) 4— X = T, Xi = • • • , Xn = Tn Here the Xi are vectors of variables and the Ti are vectors of terms. Now consider a standard memoizing proof procedure such as Earley Deduction (Pereira and Warren 1983) or the memoizing procedures described by Tamaki and Sato (1986), Vieille (1989) or Warren (1992) from this perspective. Each memoized goal is associated with a set of bindings for its arguments; so in CLP terms each memoized goal is a &apos;This essentially means that basic constraints can be recast as first-order predicates. conjunction of a single relational atom and zero or more equality constraints. A completed (i.e., atomic) clause p(T) with an instantiated argument T abbreviates the non-atomic clause p(X) 4-- X = T, where the equality constraint makes the instantiation specific. Such equality constraints are &apos;inherited&apos; via resolution by any clause that resolves with th</context>
</contexts>
<marker>Vieille, 1989</marker>
<rawString>Vieille, L. &amp;quot;Recursive query processing: the power of logic&amp;quot;, Theoretical Computer Science 69, pages 1-53. 1989.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D S Warren</author>
</authors>
<title>Memoing for logic programs&amp;quot;,</title>
<date>1992</date>
<journal>in Communications of the ACM</journal>
<volume>35</volume>
<pages>94--111</pages>
<contexts>
<context position="9703" citStr="Warren (1992)" startWordPosition="1560" endWordPosition="1562"> a syntactically sugared variant of such a CLP language with equality constraints as basic constraints, where a standard Prolog clause p(T) 4— qi (Ti ), • • • , (Tn ) is seen as an abbreviation for a clause in which the equality constraints have been made explicit by means of new variables and new equalities P(X) 4— X = T, Xi = • • • , Xn = Tn Here the Xi are vectors of variables and the Ti are vectors of terms. Now consider a standard memoizing proof procedure such as Earley Deduction (Pereira and Warren 1983) or the memoizing procedures described by Tamaki and Sato (1986), Vieille (1989) or Warren (1992) from this perspective. Each memoized goal is associated with a set of bindings for its arguments; so in CLP terms each memoized goal is a &apos;This essentially means that basic constraints can be recast as first-order predicates. conjunction of a single relational atom and zero or more equality constraints. A completed (i.e., atomic) clause p(T) with an instantiated argument T abbreviates the non-atomic clause p(X) 4-- X = T, where the equality constraint makes the instantiation specific. Such equality constraints are &apos;inherited&apos; via resolution by any clause that resolves with the completed claus</context>
</contexts>
<marker>Warren, 1992</marker>
<rawString>Warren, D. S. &amp;quot;Memoing for logic programs&amp;quot;, in Communications of the ACM 35:3, pages 94-111. 1992.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>