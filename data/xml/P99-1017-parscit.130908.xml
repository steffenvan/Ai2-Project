<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000716">
<title confidence="0.9990565">
Using aggregation for selecting content
when generating referring expressions
</title>
<author confidence="0.958242">
John A. Bateman
</author>
<affiliation confidence="0.831908666666667">
Sprach- und Literaturwissenschaften
University of Bremen
Bremen, Germany
</affiliation>
<email confidence="0.971119">
e-mail: batemaauni-bremen .de
</email>
<sectionHeader confidence="0.981918" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999875444444444">
Previous algorithms for the generation of re-
ferring expressions have been developed specif-
ically for this purpose. Here we introduce an
alternative approach based on a fully generic ag-
gregation method also motivated for other gen-
eration tasks. We argue that the alternative
contributes to a more integrated and uniform
approach to content determination in the con-
text of complete noun phrase generation.
</bodyText>
<sectionHeader confidence="0.995508" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999956666666667">
When generating referring expressions (RE), it
is generally considered necessary to provide suf-
ficient information so that the reader/hearer is
able to identify the intended referent. A num-
ber of broadly related referring expression al-
gorithms have been developed over the past
decade based on the natural metaphor of &apos;ruling
out distractors&apos; (Reiter, 1990; Dale and Had-
dock, 1991; Dale, 1992; Dale and Reiter, 1995;
Horacek, 1995). These special purpose algo-
rithms constitute the &apos;standard&apos; approach to
determining content for RE-generation at this
time; they have been developed solely for this
purpose and have evolved to meet some spe-
cialized problems. In particular, it was found
early on that the most ambitious RE goal—
that of always providing the maximally concise
referring expression necessary for the context
brevity&apos;)—is NP-hard; subsequent work
on RE-generation has therefore attempted to
steer a course between computational tractabil-
ity and coverage. One common feature of the
favored algorithmic simplifications is their in-
crementality: potential descriptions are succes-
sively refined (usually non-destructively) to pro-
duce the final RE, which therefore may or may
not be minimal. This is also often motivated on
grounds of psychological plausibility.
In this paper, we introduce a completely
different metaphor for determining RE-content
that may be considered in contrast to, or in
combination with, previous approaches. The
main difference lies in an orientation to the
organization of a data set as a whole rather
than to individual components as revealed dur-
ing incremental search. Certain opportunities
for concise expression that may otherwise be
missed are then effectively isolated. The ap-
proach applies results from the previously unre-
lated generation task of &apos;aggregation&apos;, which is
concerned with the grouping together of struc-
turally related information.
</bodyText>
<sectionHeader confidence="0.524902" genericHeader="method">
2 The aggregation-based metaphor
</sectionHeader>
<bodyText confidence="0.990346791666667">
Aggregation in generation has hitherto gener-
ally consisted of lists of more or less ad hoc, or
case-specific rules that group together particu-
lar pre-specified configurations (cf. Dalianis and
Hovy (1996) and Shaw (1998)); however Bate-
man et al. (1998) provide a more rigorous and
generic foundation for aggregation by applying
results from data-summarization originally de-
veloped for multimedia information presenta-
tion (Kamps, 1997). Bateman et al. set out
a general purpose method for constructing ag-
gregation lattices which succinctly represent
all possible structural aggregations for any given
data set.1 The application of the aggregation-
based metaphor to RE-content determination
is motivated by the observation that if some-
thing is a &apos;potential distractor&apos; for some in-
tended referent, then it is equally, under ap-
propriate conditions, a candidate for aggrega-
tion together with the intended referent. That
&amp;quot;Structural&apos; aggregation refers to opportunities for
grouping inherent in the structure of the data and ignor-
ing additional opportunities for grouping that might be
found by modifying the data inferentially.
</bodyText>
<page confidence="0.995198">
127
</page>
<bodyText confidence="0.951551083333333">
is, what makes something a distractor is pre-
cisely the same as that which makes it a poten-
tial co-member of some single grouping created
by structural aggregation. To see this, consider
the following simple example discussed by Dale
and Reiter (1995) consisting of three objects
with various properties (re-represented here in
a simple association list format):2
(ol (type dog)(size small)(color black))
(o2 (type dog)(size large)(color white))
(o3 (type cat)(size small)(color black))
To successfully refer to the first object o1, suf-
ficient information must be given so as to &apos;rule
out&apos; the possible distractors: therefore, type
alone is not sufficient, since this fails to rule out
o2, nor is any combination of size or color suffi-
cient, since these fail to rule out o3. Successful
RE&apos;s are &apos;the small dog&apos; or &apos;the black dog&apos; and
not &apos;the small one&apos;, &apos;the dog&apos;, or &apos;the black one&apos;.
Considering the data set from the aggrega-
tion perspective, we ask instead how to refer
most succinctly to all of the objects 01, o2, o3.
There are two basic alternatives, indicated by
bracketing in the following:3
</bodyText>
<listItem confidence="0.9949835">
1. (A (small black and a large white) dog) and
(a small black cat).
2. (A small black (dog and cat)) and (a large
white dog).
</listItem>
<bodyText confidence="0.999655666666667">
The former groups together o1 and o2 on the
basis of their shared type, while the latter
groups together o1 and o3 on the basis of their
shared size and color properties. Significantly,
these are just the possible sources of distraction
that Dale and Reiter discuss.
The set of possible aggregations can be deter-
mined from an aggregation lattice correspond-
ing to the data set. We construct the lattice us-
ing methods developed in Formal Concept Anal-
ysis (FCA) (Wille, 1982). For the example at
hand, the aggregation lattice is built up as fol-
lows. The set of objects is considered as a rela-
tion table where the columns represent the ob-
ject attributes and their values, and the rows
</bodyText>
<footnote confidence="0.991144428571428">
2This style of presentation is not particularly perspic-
uous but space precludes providing intelligible graphics,
especially for the more complex situations used as exam-
ples below. In case of difficulties, we recommend quickly
sketching the portrayed situation as a memory aid.
3The exact rendering of these variants in English or
any other language is not at issue here.
</footnote>
<bodyText confidence="0.966818363636364">
represent the individual objects. Since the at-
tributes (e.g., &apos;color&apos;, &apos;size&apos;, etc.) can take mul-
tiple values (e.g., &apos;large&apos;, `small&apos;), this represen-
tation of the data is called a multivalued con-
text. This is then converted into a one-valued
context by comparing all rows of the table pair-
wise and, for each attribute (i.e., each column
in the table) entering one distinguished value
(e.g., T or 1) if the corresponding values of the
attributes compared are identical, and another
distinguished value (nil or 0) if they are not.
The one-valued context for the objects o1-o3 is
thus:
object pairs type size color
o1-o2 1 0
o1-o3 1 1
o2-o3 0
This indicates that objects o1 and o2 have
equal values for their type attribute but other-
wise not, while ol and o3 have equal values for
both their size and color attributes but not for
their type attributes. The one-valued context
readily supports the derivation of formal con-
cepts. A formal concept is defined in FCA as
an extension-intension pair (A, B), where the
extension is a subset A of the set of objects
and the intension is a subset B of the set of
attributes. For any given concept, each element
of the extension must accept all attributes of the
intension. Visually, this corresponds to permut-
ing any rows and columns of the one-valued con-
text and noting all the maximally &apos;filled&apos; (i.e.,
containing l&apos;s or T&apos;s) rectangles. A csubcon-
</bodyText>
<equation confidence="0.809164">
`&lt;FCA7)
cept&apos; relation, is defined over the set of
formal concepts thus:
(A, B) &lt;FCA (A* , B*) if A C A* &lt;=&gt; B* C B
</equation>
<bodyText confidence="0.987582307692308">
The main theorem of FCA then shows that
&lt;FCA induces a complete lattice structure over
the set of formal concepts. The resulting lattice
for the present example is shown in Figure 1.
Each node is shown labeled with two pieces of
information: the intension and the extension.
The intensions consist simply of the sets of prop-
erties involved. The representations of the ex-
tensions emphasize the function of the nodes in
the lattice—i.e., that the indicated objects (e.g.,
ol and o2 for the leftmost node) are equal with
respect to all the attributes contained in the in-
tension (e.g., type for the leftmost node).
</bodyText>
<page confidence="0.943529">
128
</page>
<equation confidence="0.694938">
(TYPE){COLOR, SIZE)
m(ol)=m(o2) m(ol)=m(o3)
</equation>
<figureCaption confidence="0.995671">
Figure 1: Simple aggregation lattice
</figureCaption>
<bodyText confidence="0.999977867924529">
This lattice may be construed as an aggre-
gation lattice because the functional redun-
dancies that are captured are precisely those
redundances that indicate opportunities for
structurally-induced aggregation. The leftmost
node shows that the attribute type may be ag-
gregated if we describe ol together with 02, and
the right-most node shows that {color, size}
may be aggregated when describing ol and o3.
Now, given the equivalence between aggrega-
tion possibilities and `distractors&apos;, we can also
use the lattice to drive RE-content determina-
tion. Assume again that we wish to refer to ob-
ject ol. In essence, a combination of attributes
must be selected that is not subject to aggre-
gation; any combination susceptible to aggre-
gation will necessarily &apos;confuse&apos; the objects for
which the aggregation holds when only one of
the objects, or co-aggregates, is mentioned.
For example, the rightmost node shows that an
RE with the content size&amp;color(o1), e.g., &apos;the
small black thing&apos;, confuses ol and o3. To se-
lect attributes that are appropriate, we first ex-
amine the minimal nodes of the lattice to see
if any of these do not &apos;impinge&apos; (i.e., have no
aggregation consequences: we make this more
precise below) on the intended referent. In this
case, however, all these nodes do mention ol
and so no strong preference for the RE-content
is delivered by the data set itself. This appears
to us to be the correct characterization of the
reference situation: precisely which attributes
are selected should now be determined by fac-
tors not attributable to &apos;distraction&apos; but rather
by more general communicative goals involving
discourse and the requirements of the particular
language. The resulting attribute combinations
are then checked against the aggregation lat-
tice for their referential effectiveness in a man-
ner reminiscent of the incremental approach of
previous algorithms. Selection of type is not
sufficient but the addition of either color or
size is (type&amp;color = 1 and type&amp;size=1).
The reference situation is quite different when
we wish to refer to either o2 or o3. For
both of these cases there exists a non-impinging
node (the right and leftmost nodes respec-
tively). This establishes immediate attribute
preferences based on the organizational proper-
ties of the data. Content-determination for o2
should include at least size or color (`the white
thing&apos;, &apos;the large thing&apos;) and for o3 at least type
(`the cat&apos;). These RE&apos;s are minimal.
</bodyText>
<sectionHeader confidence="0.865546" genericHeader="method">
3 Examples of aggregation-driven
RE-content determination
</sectionHeader>
<bodyText confidence="0.999975666666667">
In this section, we briefly summarize some more
significant examples of RE-content determina-
tion using aggregation. Length limitations will
require some shortcuts to be taken in the dis-
cussion and we will not follow up all of the al-
ternative RE&apos;s that can be motivated.
</bodyText>
<subsectionHeader confidence="0.998989">
3.1 Minimal descriptions
</subsectionHeader>
<bodyText confidence="0.999968857142857">
Dale and Reiter (1995) consider a number of
variant algorithms that deviate from full brevity
in order to achieve more attractive computa-
tional behavior. The first variant they consider
relies on a &apos;Greedy Heuristic&apos; (Dale, 1989; John-
son, 1974); they illustrate that this algorithm
sacrifices minimality by constructing an RE for
object ol in the context of the following prop-
erties concerning a set of seven cups of varying
size (large, small), color (red, green, blue) and
material (paper, plastic):
The greedy algorithm produces &apos;the large red
plastic cup&apos; although the true minimum descrip-
tion is &apos;the large red cup&apos;.
The aggregation-based approach to the same
data set provides an interesting contrast in re-
sult. The aggregation lattice for the data is
given in Figure 2. The lattice is constructed
as before: first by converting the multivalued
context of the original data set to a one-valued
context and then by imposing the subconcept
</bodyText>
<figure confidence="0.60089580952381">
(ol (size large)(color red)(material plastic))
(o2 (size small)(color red)(material plastic))
(o3 (size small)(color red)(material paper))
(o4 (size medium)(color red)(material paper))
(o5 (size large)(color green)(material paper))
(o6 (size large)(color blue)(material paper))
(o7 (size large)(color blue)(material plastic))
129
(SIZE)
m(o1)=m(o5)=
m(o6)=m(o7)
m(o1)=m(o7)
m(o5)=m(o6)
(COLOR) 2
m(o1)=m(o2).
m(o3)=m(o4)
m(o1)=m(o2)
m(o3)=m(o4)
m(o2)=m(o3)
m(o6)=m(o7)- „ • &apos;
,
</figure>
<bodyText confidence="0.98981125">
tells us that the set of possible co-aggregates
for o1 with respect to the properties {size &amp;
color} is empty, which is equivalent to stating
that there are no objects in the data set which
might be confused with (ol if size&amp;color(ol)
forms the RE-content. Thus, &apos;the large red cup&apos;
may be directly selected, and this is precisely
the true minimal RE for this data set.
</bodyText>
<figureCaption confidence="0.9396915">
Figure 2: Aggregation lattice for the &apos;seven
cups&apos; example
</figureCaption>
<bodyText confidence="0.999914571428571">
relation over the complete set of formal con-
cepts. The nodes of the lattice are also labeled
as before, although we rely here on the formal
properties of the lattice to avoid redundant la-
beling. For example, the two sets of attribute
equalities given for node 1 (one relating o2 and
o3, the other relating o6 and o7) apply to both
color (inherited from node 2) and size (inher-
ited from node 4); we do not, therefore, repeat
the labeling of properties for node 1. Similarly,
and due to the bidirectionality inherent in the
subconcept definition, the attribute equalities
of node 1 are also &apos;inherited&apos; upwards both to
node 2 and to node 4. The attribute equalities
of node 4 therefore include contributions from
both node 1 and node 6. We will generally in-
dicate in the labeling only the additional infor-
mation arising from the structure of the lattice,
and even then only when it is relevant to the
discussion. So for node 4 we indicate that ol,
o5, o6 and o7 now form a single attribute equal-
ity set made up of three contributions: one from
node 1 (o6 and o7) and two from node 6. Their
combination in a single set is only possible at
node 4 because node 4 is a superconcept of both
node 1 and node 6. The other attribute equality
set for node 1 (o2 and o3) does not add further
information at node 4 and so is left implicit in
</bodyText>
<listItem confidence="0.813342">
• node 4&apos;s labeling. The labeling or non-labeling
of redundant information has of course no for-
mal consequences for the information contained
in the lattice.
</listItem>
<bodyText confidence="0.9999294">
To determine RE-content appropriate for re-
ferring to object 01, we again look for minimal
(i.e., nearest the bottom) concepts, or aggrega-
tion sets, that do not &apos;impinge&apos; on o1. The only
node satisfying this requirement is node 1. This
</bodyText>
<subsectionHeader confidence="0.69783">
3.2 Relational descriptions: restricting
recursion
</subsectionHeader>
<bodyText confidence="0.999995829268293">
One early extension of the original RE-
algorithms was the treatment of data sets in-
volving relations (Dale and Haddock, 1991).
Subsequently, Horacek (1995) has argued that
the extension proposed possesses several deficits
involving both the extent of coverage and its be-
havior. In particular, Horacek notes that &amp;quot;it is
not always necessary that each entity directly
or indirectly related to the intended referent
and included in the description be identified
uniquely&amp;quot; (p49). Partially to handle such sit-
uations, Horacek provides a further related al-
gorithm that is intended to improve on the orig-
inal and which he illustrates in action with ref-
erence to a rather more complex situation in-
volving two tables with a variety of cups and
bottles on them. One table (ti) has two bottles
and a cup on it, another (t2) has only a cup. In-
formation is also given concerning the relative
positions of the cups and bottles.
The situation that Horacek identifies as prob-
lematic occurs when the reference task is to re-
fer to the table ti and the the RE-algorithm
has decided to include the bottles that are on
this table as part of its description. This is an
appropriate decision since the presence of these
bottles is the one distinguishing feature of the
selected table. But it is sufficient for the identi-
fication of t1 for bottles to be mentioned at all:
there is no need for either or both of the bot-
tles to be distinguished more specifically. An
RE-algorithm should therefore avoid attempt-
ing this additional, unnecessary reference task.
To form an aggregation lattice for this fact
set, we extend our data representation to deal
with relations as well as attributes. This is
limited to &apos;reifying&apos; the relations and label-
ing them with &apos;instance variables&apos; as commonly
done in input expressions for generation sys-
tems (Kasper, 1989). For convenience, we also
at this point fold in the type information di-
</bodyText>
<page confidence="0.980206">
130
</page>
<figure confidence="0.9808135">
(g7 (pred on)(argl b1)(arg1type bottle)(arg2 t1)(arg2type table))
(g8 (pred on)(argl b2)(arg1type bottle)(arg2 t1)(arg2type table))
(g9 (pred on)(argl c1)(argltype cup)(arg2 t1)(arg2type table))
(g10 (pred on)(argl c2)(arg1type cup)(arg2 t2)(arg2type table))
(g11 (pred left-of)(argl bl)(arg1type bottle)(arg2 cl)(arg2type cup))
(g12 (pred left-of)(arg1 cl)(argltype cup)(arg2 b2)(arg2type bottle))
</figure>
<figureCaption confidence="0.995404">
Figure 3: Aggregation lattice for example from Horacek (1995)
</figureCaption>
<figure confidence="0.984904916666667">
(ARGITYPE)
m(g8)=m(g11)
m(g10)=m(g12)
(ARGI)
m(g7)=m(g11)
m(g9)=m(g12)
m(g7)=m(g8)=m(g10)
{ARG2TYPE}
m(g9)=m(g10)
(ARG2)
m(97)=m(0)=m(99
m(g7)=m(g8)
</figure>
<bodyText confidence="0.975317418181818">
rectly as would be normal for a typed semantic
representation. This gives the set of facts g7-
g12 shown at the top of Figure 3.4 Once the
data set is in this form, aggregation lattice con-
struction may proceed as described above; the
result is also shown in Figure 3. This lattice re-
flects the more complex reference situation rep-
resented by the data set and its possible ag-
gregations: for example, node 7 shows that the
facts {g7, g8, g9, g10} may be aggregated with
respect to both arg2type (gable&apos;: node 5) and
pred (&apos;on&apos;: node 6). Node 3, in contrast, shows
that the two distinct sets {g9, g10} and {g7,
g8} (again inherited upwards from node 2) may
both individually (but not collectively) also be
aggregated with pred, arg2type, and addition-
ally with argltype (&apos;cup&apos;: node 4).
We first consider the reference task described
by Horacek, i.e., identifying the object t1. Now
that we are dealing with relations, the ob-
jects to be referred to generally occur as values
of &apos;attributes&apos;—that is, as entries in the data
table—rather than as entire rows. In order to
construct an appropriate RE we need to find re-
lations that describe the intended referent and
which do not allow aggregation with other rela-
4Note that this is then isomorphic to a set of
SPL specifications of the form (g7 / on :argl (bl /
bottle) :arg2 (ti / table)), etc.
tions describing other conflicting referents. We
also need to indicate explicitly that the RE-
content should not avail itself of the literal in-
stance variables: these are to remain internal
to the lattice and to RE-construction so that
individuals remain distinct. We therefore dis-
tinguish been &apos;public&apos; and &apos;private&apos; attributes:
public attributes are available for driving lin-
guistic expression, private attributes are not. If
we were not to impose this distinction, then re-
ferring expressions such as `the table ti&apos; would
be seen as appropriate and probably minimal
descriptions!5 An aggregation set that does not
involve a private attribute will be called a pub-
lic concept.
The first step in constructing an RE is now
to identify the relations/events in which the in-
tended referent is involved—here {g7, g8, g9}—
and to specify the positions (both private and
public) that the referent holds in these. We
call the set of potentially relevant relations,
the reference information source set (Riss).
In the present case, the same argument po-
sition is held by the intended referent ti for
all RISS-members, i.e., privately arg2 and pub-
licly arg2type. Next, we proceed as before to
</bodyText>
<footnote confidence="0.989974666666667">
5Note that this might well be appropriate behavior
in some context—in which case the variables would be
declared public.
</footnote>
<page confidence="0.998188">
131
</page>
<bodyText confidence="0.999921095238095">
find a non-impinging, minimal aggregate set.
However, we can now define &apos;non-impinging&apos;
more accurately. A non-impinging node is one
for which there is at least one public supercon-
cept fulfilling the following condition: the re-
quired superconcept may not bring any RISS-
non-member together as co-aggregate with any
RISS-member drawn from the originating aggre-
gation set with respect to the specified public at-
tribute of the intended referent.
By these definitions both the minimal nodes
of the lattice are non-impinging. However, node
2 is more supportive of minimal RE&apos;s and we
will only follow this path here; formal indica-
tions of minimality are given by the depth and
number of paths leading from the node used for
aggregation to the top of the aggregation lattice
(since any resulting description then combines
discriminatory power from each of its chains of
superconcepts) and the number of additional
facts that are taken over and above the original
RISS-members. Node 2 is therefore the &apos;default&apos;
choice simply given a requirement of brevity, al-
though the generation process is free to ignore
this if other communicative goals so decide.
There are two public superconcepts for node
2: both of nodes 7 and 3 inherit arg2type from
node 5 but do not themselves contain a pri-
vate attribute. Of these only node 7 brings
one of the originating mss-members (i.e., g7
and g8 from node 2) into an aggregation set
with a RISS non-member (g10). Node 2 is there-
fore non-impinging via node 3. The attributes
that may be aggregated at node 2 are arg2
(node 2 &lt;FCA 8), arg2type (2 &lt;FCA 5), pred
(2 &lt;FcA 6) and arg1type (2 &lt;FCA 4). Since
this includes arg2, the private position of the in-
tended referent, we know that the data set does
not support aggregation for g7 and g8 with re-
spect to any other distracting value for arg2,
and so g7 and g8, both collectively and individ-
ually, are appropriate and sufficient RE&apos;s for t1.
</bodyText>
<listItem confidence="0.927413">
• Rendering these in English would give us:
</listItem>
<bodyText confidence="0.997108">
g7 or g8 &apos;the table with a bottle on it&apos;
g7 plus g8 &apos;the table with some bottles on it&apos;
The precise rendering of the bottles depends
on other generator decisions; important here is
only the fact that it is known that we do not
need to uniquely identify which bottles are in
question. More identifying information for argl
</bodyText>
<figure confidence="0.812355">
(g8&apos; (pred on)(argl b2)(argltype bottle)
(arg2 t2)(arg2type table))
(g12&apos; (pred left-of)(argl c2)(argitype cup)
(arg2 b2)(arg2type bottle))
</figure>
<figureCaption confidence="0.9935645">
Figure 4: Aggregation lattice for modified ex-
ample situation from Horacek
</figureCaption>
<bodyText confidence="0.998991222222222">
(the bottles bl and b2) would be necessary only
if an aggregation with other arg2&apos;s (e.g., other
tables) were possible, but it is not, and so the
type information is already sufficient to produce
an RE with no unwanted aggregation possibili-
ties. The aggregation-based approach will not,
therefore, go on to consider further facts unless
there is an explicit communicative intention to
do so.
</bodyText>
<subsectionHeader confidence="0.9667425">
3.3 Relational descriptions: when
further information is necessary
</subsectionHeader>
<bodyText confidence="0.998798894736842">
In this final example we show that the behav-
ior above does not preclude information being
added when it is in fact necessary. We show this
by adapting Horacek&apos;s set of facts slightly to
create a different aggregation lattice; we move
one of the bottles (b2) over to the other table t2,
placing it to the right of the cup. We show the
modified facts and the new aggregation lattice
in Figure 4. Here a few concepts have moved
in response to the revised reference situation:
for example, arg2type (node 3) is now a direct
subconcept of pred indicating that in the re-
vised data set there is a functional relationship
between the two attributes: all co-aggregates
with respect to arg2type are necessarily also
co-aggregates with respect to pred. In the pre-
vious example this did not hold because there
were also facts with shared pred and non-shared
arg2type (facts OA and g12: node 6).
</bodyText>
<figure confidence="0.998507111111111">
PREP
m(g11)=m(g12&apos;)
ARG1TYPE
rg=?:=1
ARG1
m(g7)=m(911)
m(g10)=m(g12&apos;)
ARG2TYPE
m(981=m(g9)
n(g7)=(g1 0)
ARG2
m(g81=m(g10),&apos;
97)=m(99),&apos;
•
s,
,
m(97)=m(g8l
m(g9)=m(g1 0)
</figure>
<page confidence="0.990802">
132
</page>
<bodyText confidence="0.998321954545455">
We will again attempt to refer to the table t 1
to compare the results with those of the previ-
ous subsection. To begin, we have a RISS of {g7,
g9} with the intended referent in arg2 (private)
and arg2type (public) as before. We then look
for non-impinging, most-specific nodes. Here,
nodes 4 and 5 are both impinging. Node 4 is
impinging in its own right since it sanctions ag-
gregation of both the RISS-members it mentions
with non-members with respect to arg2type
(node 3) and arg1type (node 6); this deficit
is then inherited upwards. Node 5 is impinging
by virtue of its first and only available public
superconcept, node 3, which sanctions as co-
aggregates {g7, g8&apos;, g9, g10} with respect to
arg2type. Neither node 4 nor node 5 can there-
fore support appropriate RE&apos;s. Only node 2 is
non-impinging, since it does not sanction aggre-
gation involving arg2type or arg2, and is the
only available basis for an effective RE with the
revised data set.
To construct the RE we take the RISS-member
of node 2 (i.e., g7) and consider it and the aggre-
gations it sanctions as candidate material. Node
2 indicates that g7 may be aggregated with g11
with respect to argitype; such an aggregation
is guaranteed not to invoke a false referent for
arg1 because it is non-impinging. Moreover, we
can infer that g7 alone is insufficient since nodes
3 and 4 indicate that g7 is a co-aggregate with
facts with non-equal argl values (e.g., g8&apos;), and
so aggregation is in fact necessary. The RE then
combines:
(g7 (pred on)(argl bl)(argltype bottle)
(arg2 t1)(arg2type table))
(g11 (pred left-of)(argl bl)(argltype bottle)
(arg2 cl)(arg2type cup))
to produce &apos;the table on which a bottle is to the
left of a cup&apos;. This is the only RE that will iden-
tify the required table in this highly symmetri-
cal context. No further information is sought
because there are no further aggregations pos-
sible with respect to arg2 and so the reference
is unique; it is also minimal.
</bodyText>
<sectionHeader confidence="0.998053" genericHeader="conclusions">
4 Discussion and Conclusion
</sectionHeader>
<bodyText confidence="0.999931519230769">
One important feature of the proposed ap-
proach is its open-nature with respect to the
rest of the generation process. The mechanisms
described attempt only to factor out one recur-
rent problem of generation, namely organizing
instantial data to reveal the patterns of con-
trast and similarity. In this way, RE-generation
is re-assimilated and seen in a somewhat more
general light than previously.
In terms of the implementation and complex-
ity of the approach, it is clear that it cuts
the cake rather differently from previous algo-
rithms/approaches. Some cases of efficient ref-
erence may be read-off directly from the lat-
tice; others may require explicit construction
and trial of RE-content more reminiscent of the
previous algorithms. In fact, the aggregation
lattice may in such cases be usefully considered
in combination with those algorithms, providing
an alternative method for checking the consis-
tency of intermediate steps. Here one impor-
tant difference between the current approach
and previous attempts at maintaining consis-
tency is the re-orientation from an incremental
procedure to a more static &apos;overview&apos; of the re-
lationships present, thus providing a promising
avenue for the exploration of referring strategies
with a wider &apos;domain of locality&apos;.
This re-orientation is also reflected in the
differing computational complexity of the ap-
proaches: the run-time behavior of the previ-
ous algorithms is highly dependent on the fi-
nal result (number of properties known true of
the referent, number of attributes mentioned
in the RE), whereas the run-time of the cur-
rent approach is more closely tied to the data
set as a whole, particularly to the number of
facts (nd) and the number of attributes (na).
Test runs involving lattice construction for ran-
dom data sets ranging from 10 to 120 objects,
with a number of attributes ranging from 5 to
15 (each with 5-7 possible values) showed that
a simple experimental algorithm constructed
for uncovering the formal concepts constitut-
ing the aggregation lattices had a typical run-
time approximately proportional to nani. Al-
though worst-case behavior for both this and
the lattice construction component is substan-
tially slower, there are now efficient standard
algorithms and implementations available that
mitigate the problem even when manipulating
quite sizeable data sets.6 For the sizes of data
</bodyText>
<footnote confidence="0.952282">
6A useful summary and collection of pointers to com-
plexity results and efficient algorithms is given by Vogt
</footnote>
<page confidence="0.998378">
133
</page>
<bodyText confidence="0.99988352173913">
sets that occur when considering a RE, time-
complexity is not likely to present a problem.
Nevertheless, for larger data sets the ap-
proach given here is undoubtedly considerably
slower than the simplified algorithms reported
both by Dale and Reiter and by Horacek. How-
ever, in contrast to those approaches, it re-
lies only on generic, non-RE specific methods.
The approach also, as suggested above, appears
under certain conditions to effectively deliver
maximally concise RE&apos;s; just what these con-
ditions are and whether they can be systemat-
ically exploited remain for future research. Fi-
nally, since the use of aggregation lattices has
been argued for other generation tasks (Bate-
man et al., 1998), some of the &apos;cost&apos; of deploy-
ment may in fact turn out to be shared, making
a direct comparison solely with the RE-task in
any case inappropriate. Other generation con-
straints might then also naturally contribute to
restricting the overall size of the data sets to be
considered—perhaps even to within acceptable
practical limits.
</bodyText>
<sectionHeader confidence="0.996536" genericHeader="acknowledgments">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.9998228">
This paper was improved by the anonymous
comments of reviewers for both the ACL and
the European Natural Language Generation
Workshop (1999). Remaining errors and obscu-
rities are my own.
</bodyText>
<sectionHeader confidence="0.997206" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.938904913043478">
John Bateman, Thomas Kamps, Ji5rg Kleinz,
and Klaus Reichenberger. 1998. Commu-
nicative goal-driven NL generation and data-
driven graphics generation: an architectural
synthesis for multimedia page generation. In
Proceedings of the 1998 International Work-
shop on Natural Language Generation, pages
8-17. Niagara-on-the-Lake, Canada.
Robert Dale and Nicholas Haddock. 1991. Gen-
erating referring expressions involving rela-
tions. In Proceedings of the 1991 Meeting
of the European Chapter of the Association
for Computational Linguistics, pages 161-
166, Berlin.
Robert Dale and Ehud Reiter. 1995. Compu-
tational interpretations of the Gricean max-
(1996). Formal techniques for minimizing the size of the
data set that is used for further processing are also given.
ims in the generation of referring expressions.
Cognitive Science, 19:233-263.
Robert Dale. 1989. Cooking up referring ex-
pressions. In Proceedings of the Twenty-
Seventh Annual Meeting of the Association
for Computational Linguistics, Vancouver,
British Columbia.
Robert Dale. 1992. Generating referring ex-
pressions: constructing descriptions in a
domain of objects and processes. Brad-
ford Books, MIT Press, Cambridge, Mas-
sachusetts.
Hercules Dalianis and Eduard Hovy. 1996. Ag-
gregation in natural language generation. In
Giovanni Adorni and Michael Zock, editors,
Trends in natural language generation: an ar-
tificial intelligence perspective, pages 88-105.
Springer-Verlag.
Helmut Horacek. 1995. More on generating
referring expressions. In Proceedings of the
Fifth European Workshop on Natural Lan-
guage Generation, pages 43-58, Leiden, The
Netherlands.
D. Johnson. 1974. Approximate algorithms
for combinatorial problems. Journal of Com-
puter and Systems Sciences, 9.
Thomas Kamps. 1997. A constructive theory
for diagram design and its algorithmic imple-
mentation. Ph.D. thesis, Darmstadt Univer-
sity of Technology, Germany.
Robert T. Kasper. 1989. A flexible interface
for linking applications to PENMAN&apos;S sentence
generator. In Proceedings of the DARPA
Workshop on Speech and Natural Language.
Ehud Reiter. 1990. Generating descriptions
that exploit a user&apos;s domain knowledge. In
R. Dale, C. Mellish, and M. Zock, editors,
Current Research in Natural Language Gen-
eration. Academic Press, London.
James Shaw. 1998. Clause aggregation us-
ing linguistic knowledge. In Proceedings of
the 1998 International Workshop on Nat-
ural Language Generation, pages 138-147.
Niagara-on-the-Lake, Canada.
Frank Vogt. 1996. Formale Begriffsanalyse
mit C++. Datenstrukturen und Algorithmen.
Springer-Verlag.
R. Wille. 1982. Restructuring lattice theory: an
approach based on hierarchies of concept. In
I. Rival, editor, Ordered Sets, pages 445-470.
Reidel, Dordecht/Boston.
</reference>
<page confidence="0.998629">
134
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.783204">
<title confidence="0.9959865">Using aggregation for selecting content when generating referring expressions</title>
<author confidence="0.999966">John A Bateman</author>
<affiliation confidence="0.913816">Sprachund Literaturwissenschaften University of Bremen</affiliation>
<address confidence="0.995181">Bremen, Germany</address>
<email confidence="0.998279">.de</email>
<abstract confidence="0.9958567">Previous algorithms for the generation of referring expressions have been developed specifically for this purpose. Here we introduce an alternative approach based on a fully generic aggregation method also motivated for other generation tasks. We argue that the alternative contributes to a more integrated and uniform approach to content determination in the context of complete noun phrase generation.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>John Bateman</author>
<author>Thomas Kamps</author>
<author>Ji5rg Kleinz</author>
<author>Klaus Reichenberger</author>
</authors>
<title>Communicative goal-driven NL generation and datadriven graphics generation: an architectural synthesis for multimedia page generation.</title>
<date>1998</date>
<booktitle>In Proceedings of the 1998 International Workshop on Natural Language Generation,</booktitle>
<pages>8--17</pages>
<location>Niagara-on-the-Lake, Canada.</location>
<contexts>
<context position="2795" citStr="Bateman et al. (1998)" startWordPosition="411" endWordPosition="415">dual components as revealed during incremental search. Certain opportunities for concise expression that may otherwise be missed are then effectively isolated. The approach applies results from the previously unrelated generation task of &apos;aggregation&apos;, which is concerned with the grouping together of structurally related information. 2 The aggregation-based metaphor Aggregation in generation has hitherto generally consisted of lists of more or less ad hoc, or case-specific rules that group together particular pre-specified configurations (cf. Dalianis and Hovy (1996) and Shaw (1998)); however Bateman et al. (1998) provide a more rigorous and generic foundation for aggregation by applying results from data-summarization originally developed for multimedia information presentation (Kamps, 1997). Bateman et al. set out a general purpose method for constructing aggregation lattices which succinctly represent all possible structural aggregations for any given data set.1 The application of the aggregationbased metaphor to RE-content determination is motivated by the observation that if something is a &apos;potential distractor&apos; for some intended referent, then it is equally, under appropriate conditions, a candid</context>
</contexts>
<marker>Bateman, Kamps, Kleinz, Reichenberger, 1998</marker>
<rawString>John Bateman, Thomas Kamps, Ji5rg Kleinz, and Klaus Reichenberger. 1998. Communicative goal-driven NL generation and datadriven graphics generation: an architectural synthesis for multimedia page generation. In Proceedings of the 1998 International Workshop on Natural Language Generation, pages 8-17. Niagara-on-the-Lake, Canada.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert Dale</author>
<author>Nicholas Haddock</author>
</authors>
<title>Generating referring expressions involving relations.</title>
<date>1991</date>
<booktitle>In Proceedings of the 1991 Meeting of the European Chapter of the Association for Computational Linguistics,</booktitle>
<pages>161--166</pages>
<location>Berlin.</location>
<contexts>
<context position="1005" citStr="Dale and Haddock, 1991" startWordPosition="143" endWordPosition="147">eric aggregation method also motivated for other generation tasks. We argue that the alternative contributes to a more integrated and uniform approach to content determination in the context of complete noun phrase generation. 1 Introduction When generating referring expressions (RE), it is generally considered necessary to provide sufficient information so that the reader/hearer is able to identify the intended referent. A number of broadly related referring expression algorithms have been developed over the past decade based on the natural metaphor of &apos;ruling out distractors&apos; (Reiter, 1990; Dale and Haddock, 1991; Dale, 1992; Dale and Reiter, 1995; Horacek, 1995). These special purpose algorithms constitute the &apos;standard&apos; approach to determining content for RE-generation at this time; they have been developed solely for this purpose and have evolved to meet some specialized problems. In particular, it was found early on that the most ambitious RE goal— that of always providing the maximally concise referring expression necessary for the context brevity&apos;)—is NP-hard; subsequent work on RE-generation has therefore attempted to steer a course between computational tractability and coverage. One common fe</context>
<context position="14691" citStr="Dale and Haddock, 1991" startWordPosition="2373" endWordPosition="2376">rther information at node 4 and so is left implicit in • node 4&apos;s labeling. The labeling or non-labeling of redundant information has of course no formal consequences for the information contained in the lattice. To determine RE-content appropriate for referring to object 01, we again look for minimal (i.e., nearest the bottom) concepts, or aggregation sets, that do not &apos;impinge&apos; on o1. The only node satisfying this requirement is node 1. This 3.2 Relational descriptions: restricting recursion One early extension of the original REalgorithms was the treatment of data sets involving relations (Dale and Haddock, 1991). Subsequently, Horacek (1995) has argued that the extension proposed possesses several deficits involving both the extent of coverage and its behavior. In particular, Horacek notes that &amp;quot;it is not always necessary that each entity directly or indirectly related to the intended referent and included in the description be identified uniquely&amp;quot; (p49). Partially to handle such situations, Horacek provides a further related algorithm that is intended to improve on the original and which he illustrates in action with reference to a rather more complex situation involving two tables with a variety of</context>
</contexts>
<marker>Dale, Haddock, 1991</marker>
<rawString>Robert Dale and Nicholas Haddock. 1991. Generating referring expressions involving relations. In Proceedings of the 1991 Meeting of the European Chapter of the Association for Computational Linguistics, pages 161-166, Berlin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert Dale</author>
<author>Ehud Reiter</author>
</authors>
<title>Computational interpretations of the Gricean max(1996). Formal techniques for minimizing the size of the data set that is used for further processing are also given. ims in the generation of referring expressions.</title>
<date>1995</date>
<journal>Cognitive Science,</journal>
<pages>19--233</pages>
<contexts>
<context position="1040" citStr="Dale and Reiter, 1995" startWordPosition="150" endWordPosition="153">ed for other generation tasks. We argue that the alternative contributes to a more integrated and uniform approach to content determination in the context of complete noun phrase generation. 1 Introduction When generating referring expressions (RE), it is generally considered necessary to provide sufficient information so that the reader/hearer is able to identify the intended referent. A number of broadly related referring expression algorithms have been developed over the past decade based on the natural metaphor of &apos;ruling out distractors&apos; (Reiter, 1990; Dale and Haddock, 1991; Dale, 1992; Dale and Reiter, 1995; Horacek, 1995). These special purpose algorithms constitute the &apos;standard&apos; approach to determining content for RE-generation at this time; they have been developed solely for this purpose and have evolved to meet some specialized problems. In particular, it was found early on that the most ambitious RE goal— that of always providing the maximally concise referring expression necessary for the context brevity&apos;)—is NP-hard; subsequent work on RE-generation has therefore attempted to steer a course between computational tractability and coverage. One common feature of the favored algorithmic si</context>
<context position="3919" citStr="Dale and Reiter (1995)" startWordPosition="582" endWordPosition="585">distractor&apos; for some intended referent, then it is equally, under appropriate conditions, a candidate for aggregation together with the intended referent. That &amp;quot;Structural&apos; aggregation refers to opportunities for grouping inherent in the structure of the data and ignoring additional opportunities for grouping that might be found by modifying the data inferentially. 127 is, what makes something a distractor is precisely the same as that which makes it a potential co-member of some single grouping created by structural aggregation. To see this, consider the following simple example discussed by Dale and Reiter (1995) consisting of three objects with various properties (re-represented here in a simple association list format):2 (ol (type dog)(size small)(color black)) (o2 (type dog)(size large)(color white)) (o3 (type cat)(size small)(color black)) To successfully refer to the first object o1, sufficient information must be given so as to &apos;rule out&apos; the possible distractors: therefore, type alone is not sufficient, since this fails to rule out o2, nor is any combination of size or color sufficient, since these fail to rule out o3. Successful RE&apos;s are &apos;the small dog&apos; or &apos;the black dog&apos; and not &apos;the small on</context>
<context position="10965" citStr="Dale and Reiter (1995)" startWordPosition="1757" endWordPosition="1760">iate attribute preferences based on the organizational properties of the data. Content-determination for o2 should include at least size or color (`the white thing&apos;, &apos;the large thing&apos;) and for o3 at least type (`the cat&apos;). These RE&apos;s are minimal. 3 Examples of aggregation-driven RE-content determination In this section, we briefly summarize some more significant examples of RE-content determination using aggregation. Length limitations will require some shortcuts to be taken in the discussion and we will not follow up all of the alternative RE&apos;s that can be motivated. 3.1 Minimal descriptions Dale and Reiter (1995) consider a number of variant algorithms that deviate from full brevity in order to achieve more attractive computational behavior. The first variant they consider relies on a &apos;Greedy Heuristic&apos; (Dale, 1989; Johnson, 1974); they illustrate that this algorithm sacrifices minimality by constructing an RE for object ol in the context of the following properties concerning a set of seven cups of varying size (large, small), color (red, green, blue) and material (paper, plastic): The greedy algorithm produces &apos;the large red plastic cup&apos; although the true minimum description is &apos;the large red cup&apos;. </context>
</contexts>
<marker>Dale, Reiter, 1995</marker>
<rawString>Robert Dale and Ehud Reiter. 1995. Computational interpretations of the Gricean max(1996). Formal techniques for minimizing the size of the data set that is used for further processing are also given. ims in the generation of referring expressions. Cognitive Science, 19:233-263.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert Dale</author>
</authors>
<title>Cooking up referring expressions.</title>
<date>1989</date>
<booktitle>In Proceedings of the TwentySeventh Annual Meeting of the Association for Computational Linguistics,</booktitle>
<location>Vancouver, British Columbia.</location>
<contexts>
<context position="11171" citStr="Dale, 1989" startWordPosition="1791" endWordPosition="1792">t&apos;). These RE&apos;s are minimal. 3 Examples of aggregation-driven RE-content determination In this section, we briefly summarize some more significant examples of RE-content determination using aggregation. Length limitations will require some shortcuts to be taken in the discussion and we will not follow up all of the alternative RE&apos;s that can be motivated. 3.1 Minimal descriptions Dale and Reiter (1995) consider a number of variant algorithms that deviate from full brevity in order to achieve more attractive computational behavior. The first variant they consider relies on a &apos;Greedy Heuristic&apos; (Dale, 1989; Johnson, 1974); they illustrate that this algorithm sacrifices minimality by constructing an RE for object ol in the context of the following properties concerning a set of seven cups of varying size (large, small), color (red, green, blue) and material (paper, plastic): The greedy algorithm produces &apos;the large red plastic cup&apos; although the true minimum description is &apos;the large red cup&apos;. The aggregation-based approach to the same data set provides an interesting contrast in result. The aggregation lattice for the data is given in Figure 2. The lattice is constructed as before: first by conv</context>
</contexts>
<marker>Dale, 1989</marker>
<rawString>Robert Dale. 1989. Cooking up referring expressions. In Proceedings of the TwentySeventh Annual Meeting of the Association for Computational Linguistics, Vancouver, British Columbia.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert Dale</author>
</authors>
<title>Generating referring expressions: constructing descriptions in a domain of objects and processes.</title>
<date>1992</date>
<publisher>Bradford Books, MIT Press,</publisher>
<location>Cambridge, Massachusetts.</location>
<contexts>
<context position="1017" citStr="Dale, 1992" startWordPosition="148" endWordPosition="149">also motivated for other generation tasks. We argue that the alternative contributes to a more integrated and uniform approach to content determination in the context of complete noun phrase generation. 1 Introduction When generating referring expressions (RE), it is generally considered necessary to provide sufficient information so that the reader/hearer is able to identify the intended referent. A number of broadly related referring expression algorithms have been developed over the past decade based on the natural metaphor of &apos;ruling out distractors&apos; (Reiter, 1990; Dale and Haddock, 1991; Dale, 1992; Dale and Reiter, 1995; Horacek, 1995). These special purpose algorithms constitute the &apos;standard&apos; approach to determining content for RE-generation at this time; they have been developed solely for this purpose and have evolved to meet some specialized problems. In particular, it was found early on that the most ambitious RE goal— that of always providing the maximally concise referring expression necessary for the context brevity&apos;)—is NP-hard; subsequent work on RE-generation has therefore attempted to steer a course between computational tractability and coverage. One common feature of the</context>
</contexts>
<marker>Dale, 1992</marker>
<rawString>Robert Dale. 1992. Generating referring expressions: constructing descriptions in a domain of objects and processes. Bradford Books, MIT Press, Cambridge, Massachusetts.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hercules Dalianis</author>
<author>Eduard Hovy</author>
</authors>
<title>Aggregation in natural language generation.</title>
<date>1996</date>
<booktitle>In Giovanni Adorni and Michael Zock, editors, Trends in natural language generation: an artificial intelligence perspective,</booktitle>
<pages>88--105</pages>
<publisher>Springer-Verlag.</publisher>
<contexts>
<context position="2747" citStr="Dalianis and Hovy (1996)" startWordPosition="403" endWordPosition="406">tion of a data set as a whole rather than to individual components as revealed during incremental search. Certain opportunities for concise expression that may otherwise be missed are then effectively isolated. The approach applies results from the previously unrelated generation task of &apos;aggregation&apos;, which is concerned with the grouping together of structurally related information. 2 The aggregation-based metaphor Aggregation in generation has hitherto generally consisted of lists of more or less ad hoc, or case-specific rules that group together particular pre-specified configurations (cf. Dalianis and Hovy (1996) and Shaw (1998)); however Bateman et al. (1998) provide a more rigorous and generic foundation for aggregation by applying results from data-summarization originally developed for multimedia information presentation (Kamps, 1997). Bateman et al. set out a general purpose method for constructing aggregation lattices which succinctly represent all possible structural aggregations for any given data set.1 The application of the aggregationbased metaphor to RE-content determination is motivated by the observation that if something is a &apos;potential distractor&apos; for some intended referent, then it is</context>
</contexts>
<marker>Dalianis, Hovy, 1996</marker>
<rawString>Hercules Dalianis and Eduard Hovy. 1996. Aggregation in natural language generation. In Giovanni Adorni and Michael Zock, editors, Trends in natural language generation: an artificial intelligence perspective, pages 88-105. Springer-Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Helmut Horacek</author>
</authors>
<title>More on generating referring expressions.</title>
<date>1995</date>
<booktitle>In Proceedings of the Fifth European Workshop on Natural Language Generation,</booktitle>
<pages>43--58</pages>
<location>Leiden, The Netherlands.</location>
<contexts>
<context position="1056" citStr="Horacek, 1995" startWordPosition="154" endWordPosition="155"> tasks. We argue that the alternative contributes to a more integrated and uniform approach to content determination in the context of complete noun phrase generation. 1 Introduction When generating referring expressions (RE), it is generally considered necessary to provide sufficient information so that the reader/hearer is able to identify the intended referent. A number of broadly related referring expression algorithms have been developed over the past decade based on the natural metaphor of &apos;ruling out distractors&apos; (Reiter, 1990; Dale and Haddock, 1991; Dale, 1992; Dale and Reiter, 1995; Horacek, 1995). These special purpose algorithms constitute the &apos;standard&apos; approach to determining content for RE-generation at this time; they have been developed solely for this purpose and have evolved to meet some specialized problems. In particular, it was found early on that the most ambitious RE goal— that of always providing the maximally concise referring expression necessary for the context brevity&apos;)—is NP-hard; subsequent work on RE-generation has therefore attempted to steer a course between computational tractability and coverage. One common feature of the favored algorithmic simplifications is</context>
<context position="14721" citStr="Horacek (1995)" startWordPosition="2378" endWordPosition="2379">eft implicit in • node 4&apos;s labeling. The labeling or non-labeling of redundant information has of course no formal consequences for the information contained in the lattice. To determine RE-content appropriate for referring to object 01, we again look for minimal (i.e., nearest the bottom) concepts, or aggregation sets, that do not &apos;impinge&apos; on o1. The only node satisfying this requirement is node 1. This 3.2 Relational descriptions: restricting recursion One early extension of the original REalgorithms was the treatment of data sets involving relations (Dale and Haddock, 1991). Subsequently, Horacek (1995) has argued that the extension proposed possesses several deficits involving both the extent of coverage and its behavior. In particular, Horacek notes that &amp;quot;it is not always necessary that each entity directly or indirectly related to the intended referent and included in the description be identified uniquely&amp;quot; (p49). Partially to handle such situations, Horacek provides a further related algorithm that is intended to improve on the original and which he illustrates in action with reference to a rather more complex situation involving two tables with a variety of cups and bottles on them. One</context>
<context position="16928" citStr="Horacek (1995)" startWordPosition="2728" endWordPosition="2729">s&apos; as commonly done in input expressions for generation systems (Kasper, 1989). For convenience, we also at this point fold in the type information di130 (g7 (pred on)(argl b1)(arg1type bottle)(arg2 t1)(arg2type table)) (g8 (pred on)(argl b2)(arg1type bottle)(arg2 t1)(arg2type table)) (g9 (pred on)(argl c1)(argltype cup)(arg2 t1)(arg2type table)) (g10 (pred on)(argl c2)(arg1type cup)(arg2 t2)(arg2type table)) (g11 (pred left-of)(argl bl)(arg1type bottle)(arg2 cl)(arg2type cup)) (g12 (pred left-of)(arg1 cl)(argltype cup)(arg2 b2)(arg2type bottle)) Figure 3: Aggregation lattice for example from Horacek (1995) (ARGITYPE) m(g8)=m(g11) m(g10)=m(g12) (ARGI) m(g7)=m(g11) m(g9)=m(g12) m(g7)=m(g8)=m(g10) {ARG2TYPE} m(g9)=m(g10) (ARG2) m(97)=m(0)=m(99 m(g7)=m(g8) rectly as would be normal for a typed semantic representation. This gives the set of facts g7- g12 shown at the top of Figure 3.4 Once the data set is in this form, aggregation lattice construction may proceed as described above; the result is also shown in Figure 3. This lattice reflects the more complex reference situation represented by the data set and its possible aggregations: for example, node 7 shows that the facts {g7, g8, g9, g10} may b</context>
</contexts>
<marker>Horacek, 1995</marker>
<rawString>Helmut Horacek. 1995. More on generating referring expressions. In Proceedings of the Fifth European Workshop on Natural Language Generation, pages 43-58, Leiden, The Netherlands.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Johnson</author>
</authors>
<title>Approximate algorithms for combinatorial problems.</title>
<date>1974</date>
<journal>Journal of Computer and Systems Sciences,</journal>
<volume>9</volume>
<contexts>
<context position="11187" citStr="Johnson, 1974" startWordPosition="1793" endWordPosition="1795">E&apos;s are minimal. 3 Examples of aggregation-driven RE-content determination In this section, we briefly summarize some more significant examples of RE-content determination using aggregation. Length limitations will require some shortcuts to be taken in the discussion and we will not follow up all of the alternative RE&apos;s that can be motivated. 3.1 Minimal descriptions Dale and Reiter (1995) consider a number of variant algorithms that deviate from full brevity in order to achieve more attractive computational behavior. The first variant they consider relies on a &apos;Greedy Heuristic&apos; (Dale, 1989; Johnson, 1974); they illustrate that this algorithm sacrifices minimality by constructing an RE for object ol in the context of the following properties concerning a set of seven cups of varying size (large, small), color (red, green, blue) and material (paper, plastic): The greedy algorithm produces &apos;the large red plastic cup&apos; although the true minimum description is &apos;the large red cup&apos;. The aggregation-based approach to the same data set provides an interesting contrast in result. The aggregation lattice for the data is given in Figure 2. The lattice is constructed as before: first by converting the multi</context>
</contexts>
<marker>Johnson, 1974</marker>
<rawString>D. Johnson. 1974. Approximate algorithms for combinatorial problems. Journal of Computer and Systems Sciences, 9.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Thomas Kamps</author>
</authors>
<title>A constructive theory for diagram design and its algorithmic implementation.</title>
<date>1997</date>
<tech>Ph.D. thesis,</tech>
<institution>Darmstadt University of Technology,</institution>
<contexts>
<context position="2977" citStr="Kamps, 1997" startWordPosition="438" endWordPosition="439">om the previously unrelated generation task of &apos;aggregation&apos;, which is concerned with the grouping together of structurally related information. 2 The aggregation-based metaphor Aggregation in generation has hitherto generally consisted of lists of more or less ad hoc, or case-specific rules that group together particular pre-specified configurations (cf. Dalianis and Hovy (1996) and Shaw (1998)); however Bateman et al. (1998) provide a more rigorous and generic foundation for aggregation by applying results from data-summarization originally developed for multimedia information presentation (Kamps, 1997). Bateman et al. set out a general purpose method for constructing aggregation lattices which succinctly represent all possible structural aggregations for any given data set.1 The application of the aggregationbased metaphor to RE-content determination is motivated by the observation that if something is a &apos;potential distractor&apos; for some intended referent, then it is equally, under appropriate conditions, a candidate for aggregation together with the intended referent. That &amp;quot;Structural&apos; aggregation refers to opportunities for grouping inherent in the structure of the data and ignoring additio</context>
</contexts>
<marker>Kamps, 1997</marker>
<rawString>Thomas Kamps. 1997. A constructive theory for diagram design and its algorithmic implementation. Ph.D. thesis, Darmstadt University of Technology, Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert T Kasper</author>
</authors>
<title>A flexible interface for linking applications to PENMAN&apos;S sentence generator.</title>
<date>1989</date>
<booktitle>In Proceedings of the DARPA Workshop on Speech and Natural Language.</booktitle>
<contexts>
<context position="16392" citStr="Kasper, 1989" startWordPosition="2663" endWordPosition="2664">ne distinguishing feature of the selected table. But it is sufficient for the identification of t1 for bottles to be mentioned at all: there is no need for either or both of the bottles to be distinguished more specifically. An RE-algorithm should therefore avoid attempting this additional, unnecessary reference task. To form an aggregation lattice for this fact set, we extend our data representation to deal with relations as well as attributes. This is limited to &apos;reifying&apos; the relations and labeling them with &apos;instance variables&apos; as commonly done in input expressions for generation systems (Kasper, 1989). For convenience, we also at this point fold in the type information di130 (g7 (pred on)(argl b1)(arg1type bottle)(arg2 t1)(arg2type table)) (g8 (pred on)(argl b2)(arg1type bottle)(arg2 t1)(arg2type table)) (g9 (pred on)(argl c1)(argltype cup)(arg2 t1)(arg2type table)) (g10 (pred on)(argl c2)(arg1type cup)(arg2 t2)(arg2type table)) (g11 (pred left-of)(argl bl)(arg1type bottle)(arg2 cl)(arg2type cup)) (g12 (pred left-of)(arg1 cl)(argltype cup)(arg2 b2)(arg2type bottle)) Figure 3: Aggregation lattice for example from Horacek (1995) (ARGITYPE) m(g8)=m(g11) m(g10)=m(g12) (ARGI) m(g7)=m(g11) m(g9)</context>
</contexts>
<marker>Kasper, 1989</marker>
<rawString>Robert T. Kasper. 1989. A flexible interface for linking applications to PENMAN&apos;S sentence generator. In Proceedings of the DARPA Workshop on Speech and Natural Language.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ehud Reiter</author>
</authors>
<title>Generating descriptions that exploit a user&apos;s domain knowledge. In</title>
<date>1990</date>
<booktitle>Current Research in Natural Language Generation.</booktitle>
<editor>R. Dale, C. Mellish, and M. Zock, editors,</editor>
<publisher>Academic Press,</publisher>
<location>London.</location>
<contexts>
<context position="981" citStr="Reiter, 1990" startWordPosition="141" endWordPosition="142">on a fully generic aggregation method also motivated for other generation tasks. We argue that the alternative contributes to a more integrated and uniform approach to content determination in the context of complete noun phrase generation. 1 Introduction When generating referring expressions (RE), it is generally considered necessary to provide sufficient information so that the reader/hearer is able to identify the intended referent. A number of broadly related referring expression algorithms have been developed over the past decade based on the natural metaphor of &apos;ruling out distractors&apos; (Reiter, 1990; Dale and Haddock, 1991; Dale, 1992; Dale and Reiter, 1995; Horacek, 1995). These special purpose algorithms constitute the &apos;standard&apos; approach to determining content for RE-generation at this time; they have been developed solely for this purpose and have evolved to meet some specialized problems. In particular, it was found early on that the most ambitious RE goal— that of always providing the maximally concise referring expression necessary for the context brevity&apos;)—is NP-hard; subsequent work on RE-generation has therefore attempted to steer a course between computational tractability and</context>
</contexts>
<marker>Reiter, 1990</marker>
<rawString>Ehud Reiter. 1990. Generating descriptions that exploit a user&apos;s domain knowledge. In R. Dale, C. Mellish, and M. Zock, editors, Current Research in Natural Language Generation. Academic Press, London.</rawString>
</citation>
<citation valid="true">
<authors>
<author>James Shaw</author>
</authors>
<title>Clause aggregation using linguistic knowledge.</title>
<date>1998</date>
<booktitle>In Proceedings of the 1998 International Workshop on Natural Language Generation,</booktitle>
<pages>138--147</pages>
<location>Niagara-on-the-Lake, Canada.</location>
<contexts>
<context position="2763" citStr="Shaw (1998)" startWordPosition="408" endWordPosition="409"> rather than to individual components as revealed during incremental search. Certain opportunities for concise expression that may otherwise be missed are then effectively isolated. The approach applies results from the previously unrelated generation task of &apos;aggregation&apos;, which is concerned with the grouping together of structurally related information. 2 The aggregation-based metaphor Aggregation in generation has hitherto generally consisted of lists of more or less ad hoc, or case-specific rules that group together particular pre-specified configurations (cf. Dalianis and Hovy (1996) and Shaw (1998)); however Bateman et al. (1998) provide a more rigorous and generic foundation for aggregation by applying results from data-summarization originally developed for multimedia information presentation (Kamps, 1997). Bateman et al. set out a general purpose method for constructing aggregation lattices which succinctly represent all possible structural aggregations for any given data set.1 The application of the aggregationbased metaphor to RE-content determination is motivated by the observation that if something is a &apos;potential distractor&apos; for some intended referent, then it is equally, under </context>
</contexts>
<marker>Shaw, 1998</marker>
<rawString>James Shaw. 1998. Clause aggregation using linguistic knowledge. In Proceedings of the 1998 International Workshop on Natural Language Generation, pages 138-147. Niagara-on-the-Lake, Canada.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Frank Vogt</author>
</authors>
<title>Formale Begriffsanalyse mit C++. Datenstrukturen und Algorithmen.</title>
<date>1996</date>
<publisher>Springer-Verlag.</publisher>
<marker>Vogt, 1996</marker>
<rawString>Frank Vogt. 1996. Formale Begriffsanalyse mit C++. Datenstrukturen und Algorithmen. Springer-Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Wille</author>
</authors>
<title>Restructuring lattice theory: an approach based on hierarchies of concept. In</title>
<date>1982</date>
<booktitle>Ordered Sets,</booktitle>
<pages>445--470</pages>
<editor>I. Rival, editor,</editor>
<location>Reidel, Dordecht/Boston.</location>
<contexts>
<context position="5366" citStr="Wille, 1982" startWordPosition="830" endWordPosition="831">e following:3 1. (A (small black and a large white) dog) and (a small black cat). 2. (A small black (dog and cat)) and (a large white dog). The former groups together o1 and o2 on the basis of their shared type, while the latter groups together o1 and o3 on the basis of their shared size and color properties. Significantly, these are just the possible sources of distraction that Dale and Reiter discuss. The set of possible aggregations can be determined from an aggregation lattice corresponding to the data set. We construct the lattice using methods developed in Formal Concept Analysis (FCA) (Wille, 1982). For the example at hand, the aggregation lattice is built up as follows. The set of objects is considered as a relation table where the columns represent the object attributes and their values, and the rows 2This style of presentation is not particularly perspicuous but space precludes providing intelligible graphics, especially for the more complex situations used as examples below. In case of difficulties, we recommend quickly sketching the portrayed situation as a memory aid. 3The exact rendering of these variants in English or any other language is not at issue here. represent the indivi</context>
</contexts>
<marker>Wille, 1982</marker>
<rawString>R. Wille. 1982. Restructuring lattice theory: an approach based on hierarchies of concept. In I. Rival, editor, Ordered Sets, pages 445-470. Reidel, Dordecht/Boston.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>