<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.68274775">
Unification of Disjunctive Feature Descriptions
Andreas Eisele, Jochen DOrre
Institut ffir Maschinelle Sprachverarbeitung
Universitat Stuttgart
</title>
<note confidence="0.817933">
Keplerstr. 17, 7000 Stuttgart 1, West Germany
</note>
<email confidence="0.820626">
Netmail: ims@rusvx2.rus.uni-stuttgart.dbp.de
</email>
<sectionHeader confidence="0.994905" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999983083333333">
The paper describes a new implementation of
feature structures containing disjunctive values,
which can be characterized by the following main
points: Local representation of embedded dis-
junctions, avoidance of expansion to disjunctive
normal form and of repeated test-unifications for
checking consistence. The method is based on a
modification of Kasper and Rounds&apos; calculus of
feature descriptions and its correctness therefore
is easy to see. It can handle cyclic structures and
has been incorporated successfully into an envi-
ronment for grammar development.
</bodyText>
<sectionHeader confidence="0.991464" genericHeader="keywords">
1 Motivation
</sectionHeader>
<bodyText confidence="0.99216270212766">
In current research in computational linguistics
but also in extralinguistic fields unification has
turned out to be a central operation in the mod-
elling of data types or knowledge in general.
Among linguistic formalisms and theories which
are based on the unification paradigm are such
different theories as FUG [Kay 79,Kay 85], LFG
[Kaplan/Bresnan 82], GSPG [Gazdar et al. 85],
CUG [Uszkoreit 86]. However, research in unifi-
cation is also relevant for fields like logic program-
ming, theorem proving, knowledge representation
(see [Smolka/Ait-Kaci 87] for multiple inheritance
hierarchies using unification), programming lan-
guage design [Alt-Kaci/Nasr 86] and others.
The version of unification our work is based on
is graph unification, which is an extension of term
unification. In graph unification the number of
arguments is free and arguments are selected by
attribute labels rather than by position. The al-
gorithm described here may easily be modified to
apply to term unification.
The structures we are dealing with are rooted
directed graphs where arcs starting in one node
must carry distinct labels. Terminal nodes may
also be labelled. These structures are referred to
by various names in the literature: feature struc-
tures, functional structures, functional descrip-
tions, types, categories. We will call them feature
structures1 throughout this paper.
In applications, other than toy applications, the
efficient processing of indefinite information which
is represented by disjunctive specifications be-
comes a relevant factor. A strategy of multiplying-
out disjunction by exploiting (nearly) any combi-
nation of disjuncts through backtracking, as it is
done, e.g., in the case of a simple DCG parser,
quickly runs into efficiency problems. On the other
hand the descriptional power of disjunction often
helps to state highly ambiguous linguistic knowl-
edge clearly and concisely (see Fig. 1 for a disjunc-
tive description of morphological features for the
six readings of the german noun `Koffer&apos;).
Koffer:
r num: sg 1
L.pers: 3 j
masc
{nom dat acc
</bodyText>
<sectionHeader confidence="0.495133" genericHeader="introduction">
morph:
</sectionHeader>
<keyword confidence="0.361678">
rnum:
pers:
</keyword>
<sectionHeader confidence="0.56998" genericHeader="method">
MaSC
</sectionHeader>
<bodyText confidence="0.376423">
{nom gen acc
r rel: Koffer&apos; 1
I arg: [ ]
</bodyText>
<figureCaption confidence="0.971214">
Figure 1: Using disjunction in the description of
linguistic structures
</figureCaption>
<bodyText confidence="0.999779375">
Kasper and Rounds [86] motivated the distinc-
tion between feature structures and formulae of a
logical calculus that are used to describe feature
structures. Disjunction can be used within such
a formula to describe sets of feature structures.
With this separation the underlying mathematical
framework which is used to define the semantics
of the descriptions can be kept simple.
</bodyText>
<footnote confidence="0.651337">
1We do not, as is frequently done, restrict ourselves to
acyclic structures.
</footnote>
<figure confidence="0.979610222222222">
sem:
agr:
gend:
case:
agr:
gend:
case:
131 1
3
</figure>
<page confidence="0.997295">
286
</page>
<sectionHeader confidence="0.9903165" genericHeader="method">
2 Disjunctive Feature De-
scriptions
</sectionHeader>
<bodyText confidence="0.9985842">
We use a slightly modified version of the formula
language FML of Kasper and Rounds [86] to de-
scribe our feature structures. Fig. 2 gives the syn-
tax of FML&apos;, where A is the set of atoms and L the
set of labels.
</bodyText>
<figure confidence="0.645250875">
FML&apos; contains:
NIL
TOP
a where a E A
1 : 4) where IE L, E FMV
4) A 4, where 4), E FML&apos;
&lt;I) V 4/ where 4), E FMI2
(p) where p E Lt
</figure>
<figureCaption confidence="0.999494">
Figure 2: Syntax of FML&apos;
</figureCaption>
<bodyText confidence="0.999869">
In contrast to Kasper and Rounds [86] we do
not use the syntactic construct of path equivalence
classes. Instead, path equivalences are expressed
using non-local path expressions (called pointers
in the sequel). This choice is motivated by the
fact that we use these pointers for an efficient rep-
resentation below, and we want to keep FML&apos; as
simple as possible.
The intuitive semantics of F1(I2 is as follows (see
[Kasper/Rounds 86] for formal definitions):
</bodyText>
<listItem confidence="0.976431571428572">
1. NIL is satisfied by any feature structure.
2. TOP is never satisfied.
3. a is satisfied by the feature structure consisting
only of a single node labelled a.
4. 1 : (I) requires a (sub-)structure under arc 1 to
satisfy 4).
5. 4) A 4f is satisfied by a feature structure that
satisfies 4) and satisfies AP.
6. 4) V is satisfied by a feature structure that
satisfies 4) or satisfies
7. (p) requires a path equivalence (two paths lead-
ing to the same node) between the path (p)
and the actual path relative to the top-level
structure.2
</listItem>
<bodyText confidence="0.993687333333333">
The denotation of a formula cI) is usually defined
as the set of minimal elements of SAT(4) with
respect to subsumption3, where SAT(0) is the set
2 This construct is context-sensitive in the sense that the
denotation of (p) may only be computed with respect to the
whole structure that the formula describes.
3 The subsumption relation C is a partial ordering on
feature structures inducing a semi-lattice. It may be de-
fined as: FS1 C FS2 if the set of formulae satisfied by FS2
includes the set of formulae satisfied by FS1.
of feature structures which satisfy &lt;D.
Example: The formula
</bodyText>
<equation confidence="0.707509">
(l■ = sub j : agr : (agr) A case: (nom V acc)
</equation>
<bodyText confidence="0.99543996969697">
denotes the two graphs
case
acc
The unification problem for disjunctive feature de-
scriptions can be stated as follows:
Given two formulae that describe feature
structures, find the set of feature struc-
tures that satisfy both formulae, if it is
nonempty, else announce `fail&apos;.
The simplest way to deal with disjunction is
to rewrite any description into disjunctive nor-
mal form (DNF). This transformation requires
time and space exponential with the number
of disjuncts in the initial formula in the worst
case. Although the problem of unifying disjunc-
tive descriptions is known to be NP-complete (see
[Kasper 87a]), methods which avoid this transfor-
mation may perform well in most practical cases.
The key idea is to keep disjunction local and con-
sider combinations of disjuncts only when they re-
fer to the very same substructure. This strategy,
however, is complicated by the fact that feature
structures may be graphs with path equivalences
and not only trees. Fig. 3 shows an example where
unifying a disjunction with a structure containing
reentrancy causes parts of the disjunction to be
linked to other parts of the structure. The dis-
junction is exported via this reentrancy. Hence,
the value of attribute d cannot be represented
uniquely. It may be + or -, depending on which
disjunct in attribute a is chosen. To represent this
information without extra formal devices we have
to lift the disjunction one level up.4
</bodyText>
<footnote confidence="0.69603875">
4 In this special case we still could keep the disjunction
in the attribute a by inverting the pointer. A pointer (a b)
underneath label d would allow us to specify the value of d
dependent on the disjunction under a.
</footnote>
<figure confidence="0.983661260869565">
3 The Problem
nom
subj agr
Ise and subj agr
287
a: a: b: (d)
[{ d: C
b: (d) 11
b: (d) 11
1
a:
d:
a:
d:
A) Restricted syntax of ENF:
NIL
TOP
a where a E A
: A • • A In : (1). where (1); E ENF\{TOP},
/i E L, li lj for i j
ID V %If where 4), P E ENF\{TOP}
(P) where p E L.
B) Additional condition C,,,,„:
</figure>
<figureCaption confidence="0.8162844">
If an instance 4, of a formula contains a pointer
(p), then the path p must be realized in 4,.
Figure 4: A normal form to describe feature struc-
tures efficiently
Figure 3: Lifting of disjunction due to reentrancy
</figureCaption>
<sectionHeader confidence="0.89072" genericHeader="method">
4 From Description to Effi-
cient Representation
</sectionHeader>
<bodyText confidence="0.982040634615385">
It is interesting to investigate whether FE: is suit-
able as an encoding of feature structures, i.e. if it
can be used for computational purposes.
However, this is clearly not the case for the un-
restricted set of formulae of F141!, since a given
feature structure can be represented by infinitely
many different formulae of arbitrary complexity
and — even worse — because it is also not pos-
sible to ascertain whether a given formula repre-
sents any feature structure at all without extensive
computation.
On the other hand, the formulae of FML&apos; have
some properties that are quite attractive for repre-
senting feature structures, such as embedded and
general disjunction and the possibility to make use
of the law of distributivity for disjunctions.
Therefore we have developed an efficiency-
oriented normal form ENF, which is suitable as an
efficient representation for sets of feature struc-
tures.
The formulae are built according to a restricted
syntax (Fig. 4, Part A) and have to satisfy condi-
tion GEN, (Part B). The syntax restricts the use of
conjunction and TOP in order to disallow contra-
dictory information in a formula other than TOP.
However, even in a formula of the syntax of Part A
inconsistence can be introduced by a pointer to a
location that is `blocked&apos; by an atomic value on a
higher level. For example in the formula a: (b c)
A b:d the path (b c) is blocked since it would
require the value of attribute b to be complex in
conflict to the atomic value d, thus rendering the
formula non-satisfiable. With the additional con-
dition CE„ such inconsistencies are excluded. Its
explanation in the next section is somewhat tech-
nical and is not prerequisite for the overall under-
standing of our method.
Condition C„,
First we have to introduce some terminology.
Instance: When every disjunction in a formula
is replaced by one of its disjuncts, the result is
called an instance of that formula.
Realized: A recursive definition of what we call
a realized path in an instance d, is given in Fig. 5.
The intuitive idea behind this notion is to restrict
is realized in 0, if 4, 0 TOP
is realized in II : 4,1. A • .Al:4,,, (even
if / • • • In })
is realized in • • • A I : 4, A •• if p is
realized in
is realized in (p&apos;), if p&apos;p is realized in
the top-level formula
</bodyText>
<figureCaption confidence="0.997095">
Figure 5: Definition of realized paths
</figureCaption>
<bodyText confidence="0.9999396">
pointers in such a way that the path to their des-
tination may not be blocked by the introduction
of an atomic value on a prefix of this path. Note
that by virtue of the second line of the definition,
the last label of the path does not have to actually
occur in the formula, if there are other labels.
Example: In a: (b c) only the path e and each
path of length 1 is realized. Any longer path may
be blocked by the introduction of an atomic value
at level 1. Thus, the formula violates C„ .
</bodyText>
<page confidence="0.984812">
288
</page>
<bodyText confidence="0.9905705">
a:(b d) A b:(c) A c: (d:x V b:y), on the
other hand, is a well-formed ENF formula, since it
contains only pointers with realized destinations
in every disjunct.
The easiest way to satisfy the condition is to in-
troduce for each pointer the value NIL at its des-
tination when building up a formula. With this
strategy we actually never have to check this con-
dition, since it is maintained by the unification
algorithm described below.
</bodyText>
<subsectionHeader confidence="0.991497">
Properties of ENF
</subsectionHeader>
<bodyText confidence="0.9952965">
The most important properties of formulae in ENF
are:
</bodyText>
<listItem confidence="0.969104166666667">
• For each formula of FML&apos; an equivalent formula
in ENF can be found.
• Each instance of a formula in ENF (besides
TOP) denotes exactly one feature structure.
• This feature structure can be computed in lin-
ear time.
</listItem>
<bodyText confidence="0.997852382352941">
The first property can be established by virtue of
the unification algorithm given in the next section,
which can be used to construct an equivalent ENF-
formula for an arbitrary formula in FML&apos;.
The next point says: It doesn&apos;t matter which
disjunct in one disjunction you choose — you can-
not get a contradiction. Disjunctions in ENF are
mutually independent. This also implies that TOP
is the only formula in ENF that is not satisfiable.
To see why this property holds, first consider for-
mulae without pointers. Contradictory informa-
tion (besides TOP) can only be stated using con-
junction. But since we only allow conjunctions of
different attributes, inconsistent information can-
not be stated in formulae without pointers.
Pointers could introduce two sorts of incon-
sistencies: Since a pointer links two paths, one
might assume that inconsistent information could
be specified for them. But since conjunction with
a pointer is not allowed, only the destination path
can carry additional information, thus excluding
this kind of inconsistency. On the other hand,
pointers imply the existence of the paths they refer
to. The condition C„, ensures that no informs-
tion in the formula contradicts the introduction of
these implied paths. We can conclude that even
formulae containing pointers are consistent.
The condition C„, additionally requires that
no extension of a formula, gained by unification
with another formula, may contain such contra-
dicting information. A unification algorithm thus
can introduce an atomic value into a formula with-
out having to check if it would block the destina-
tion path of some pointer.
</bodyText>
<sectionHeader confidence="0.966336" genericHeader="method">
5 The Unification Procedure
</sectionHeader>
<bodyText confidence="0.888107323529412">
Figure 6 shows an algorithm that takes as in-
put two terms representing formulae in ENF and
computes an ENF-representation of their unifica-
tion. The representation of the formulae is given
by a 1-to-l-mapping between formulae and data-
structures, so that we can abstract from the data-
structures and write formulae instead. In this
sense, the logical connectives A, V,: are used as
term-constructors that build more complex data-
structures from simpler ones. In addition, we use
the operator • to express concatenation of labels
or label sequences and write (p) to express the
pointer to the location specified by the label se-
quence p. p : 0 is an abbreviation for a formula
where the subformula 0 is embedded on path p.
The auxiliary function unity_aux performs the
essential work of the unification. It traverses both
formulae in parallel and builds all encountered
subformulae into the output formula. The follow-
ing cases have to be considered:
• If one of the input formulae specifies a sub-
formula at a location where the other input
provides no information or if both inputs con-
tain the same subformuls. at a certain location,
this subformula is built into the output with-
out modification.
• The next statement handles the case where one
input contains a pointer whereas the other con-
tains a different subformula. Since we regard
the destination of the pointer as the represen-
tative of the equivalence class of paths, the sub-
formula has to be moved to that place. This
case requires additional discussion, so we have
moved it to the procedure move_tormula.
</bodyText>
<listItem confidence="0.9384924">
• In case of two conjunctions the formulae have
to be traversed recursively and all resulting at-
tribute - value pairs have to be built into the
output structure. For clarity, this part of the
algorithm has been moved to the procedure
linify_complex.
• The case where one of the input formulae
is a disjunction is handled in the procedure
unity_disj that is described in Section 5.2.
• If none of the previous cases matches (e.g. if
</listItem>
<bodyText confidence="0.505629">
the inputs are different atoms or an atom and
a complex formula), a failure of the unification
has to be announced which is done in the last
</bodyText>
<page confidence="0.984942">
289
</page>
<figure confidence="0.97315153125">
unify(X,Y) 14 formula
repeat
(X,T) := unify_aux(X,Y,e)
until Y = NIL or Y = TOP
return(X)
unify _aux(Ae.Al.Pa) (formula,formula)
it Ao = AI then
return (A1 NIL)
else it Ai = NIL than
return (Al-,,NIL)
else it si is the pointer &lt;Pi.&gt; then
return move_formula(ki-i ,Pa ,Pto
else it both Ai are conjunctions than
return unity_complex(Ao.A1,Pa)
else if Ai is the disjunction (B V O)
than
return unify_disj(Al_i,B,C,Pa)
else return (TOP,TOP)
unify_complex(Ao.Al.P6)
(formula) formula)
L :=A 1:v, where 1:v occurs in one Ai
and 1 does not occur in
G := NIL
for all 1 that appear in both Ai do
let Vo,V1 be the values of 1 in Ao.A1
(V,GV) := unify_aux(V0,VI,Paa)
it V = TOP or GV = TOP then
return (TOP,TOP)
else L := L A 1:V
G := unify(G,GV)
if G = TOP then return (TOP,TOP)
return (L,G)
</figure>
<figureCaption confidence="0.9931365">
Figure 6: The unification procedure
statement.
</figureCaption>
<bodyText confidence="0.999738423076923">
The most interesting case is the treatment of
a pointer. The functional organization of the al-
gorithm does not allow for side effects on remote
parts of the top-level formula (nor would this be
good programming style), so we had to find a dif-
ferent way to move a subformula to the destination
of the pointer. For that reason, we have defined
our procedures so that they return two results: a
local result that has to be built into the output for-
mula at the current location (i.e. the path both in-
put formulae are embedded on) and a global result
that is used to express &apos;side effects&apos; of the uni-
fication. This global result represents a formula
that has to be unified with the top-level result in
order to find a formula covering all information
contained in the input.
This global result is normally set to NIL, but the
procedure move_formula must of course produce
something different. For the time being, we can as-
sume the preliminary definition of move_formula
in Figure 7, which will be modified in the next
subsection. Here, the local result is the pointer
(since we want to keep the information about the
path equivalence), whereas the global result is a
formula containing the subformula to be moved
embedded at its new location.
</bodyText>
<figure confidence="0.90553">
move_formula(F.Ppv...,Pio)
(f ormula,formula)
return (&lt;Pto&gt;,Pio:F)
</figure>
<figureCaption confidence="0.950895">
Figure 7: Movement of a Subformula — Prelimi-
nary Version
</figureCaption>
<bodyText confidence="0.999657227272727">
The function unify_complex unifies conjunc-
tions of label-value-pairs by calling unify_aux re-
cursively and placing the local results of these uni-
fications at the appropriate locations. Labels that
appear only in one argument are built into the out-
put without modification. If any of the recursive
unifications fail, a failure has to be announced.
The global results from recursive unifications are
collected by top-level unification&apos;. The third ar-
gument of unify_aux and unify_complex contains
the sequence of labels to the actual location. It is
not used in this version but is included in prepara-
tion of the more sophisticated treatment of point-
ers described below.
To perform a top-level unification of two formu-
lae, the call to unify_aux is repeated in order to
unify the local and global results until either the
unification fails or the global result is NIL.
Before extending the algorithm to handle dis-
junction, we will first concentrate on the question
how the termination of this repeat-loop can be
guaranteed.
</bodyText>
<subsectionHeader confidence="0.998883">
5.1 Avoiding Infinite Loops
</subsectionHeader>
<bodyText confidence="0.966134875">
There are cases where the algorithm in Figure 6
will not terminate if the movement of subformulae
is defined as in Figure 7. Consider the unification
of a: (b) A b: (a) with Here, the formula (I)
51f we allow the global result to be a list of formulae, this
recursion could be replaced by list-concatenation. However,
this would imply modifications in the top-level loop and
would slightly complicate the treatment of disjunction.
</bodyText>
<page confidence="0.987634">
290
</page>
<bodyText confidence="0.907561025641025">
will be moved along the pointers infinitely often
and the repeat-loop in unity will never terminate.
An algorithm that terminates for arbitrary input
must include precautions to avoid the introduction
of cyclic pointer chains or it has to recognize such
cycles and handle them in a special way.
When working with pointers, the standard tech-
nique to avoid cycles is to follow pointer chains
to their end and to install a new pointer only to
a location that does not yet contain an outgoing
pointer. For different reasons, dereferencing is not
the method of choice in the context of our treat-
ment of disjunction (see [Eisele 87] for details).
However, there are different ways to avoid cyclic
movements. A total order `&lt;i,&apos; on all possible lo-
cations (i.e. all paths) can be defined such that, if
we allow movements only from greater to smaller
locations, cycles can be avoided. A pointer from a
greater to a smaller location in this order will be
called a positive pointer, a pointer from a smaller
to a greater location will be called negative. But
we have to be careful about chosing the right or-
der; not any order will prevent the algorithm from
an infinite loop.
For instance, it would not be adequate to move
a formula along a pointer from a location p to
its extension p q, since the pointer itself would
block the way to its destination. (The equivalence
class contains (p), (p q) , (p q . . . and it makes
no sense to choose the last one as a representative).
Since cyclic feature structures can be introduced
inadvertently and should not lead to an infinite
loop in the unification, the first condition the order
`&lt;p &apos; has to fulfill is:
p &lt;p pq if q e
The order must be defined in a way that positive
pointers can not lead to even indirect cycles.
This is guaranteed if the condition
p &lt;p q rps &lt;p rqs
</bodyText>
<subsectionHeader confidence="0.683448">
holds for arbitrary paths p, q, r and s.
</subsectionHeader>
<bodyText confidence="0.999908625">
We get an order with the required properties if
we compare, in the first place, the length of the
paths and use a lexicographic order &lt;, for paths
of the same length. A formal statement of this
definition is given in Figure 8.
Note that positive pointers can turn into neg-
ative ones when the structure containing them is
moved, as the following example shows:
</bodyText>
<construct confidence="0.389298714285714">
a:b:c:d: (a b e) U a : b : c : (f)
pos. pos.
a : b : c : (i) A : d : (a b e)
pos. neg.
p &lt;p q if iPi &lt; iqi
or if IA = lql, p = rljs, q = r/2t,
r, 8, t E L. , 4 E L, 11&lt;112
</construct>
<figureCaption confidence="0.985773">
Figure 8: An Order on Locations in a Formula
</figureCaption>
<bodyText confidence="0.9903002">
However, we can be pragmatic about this point;
the purpose of ordering is the avoidance of cyclic
movements. Towards this end, we only have to
avoid using negative pointers, not writing them
down.
To avoid movement along a negative pointer,
we now make use of the actual location that is
provided by the third argument of unify_aux and
unity_complex and as the second argument of
move_formula.
</bodyText>
<figure confidence="0.839844857142857">
move_formula(F,Pf,,,,, ,Pt.)
(formula,formula)
if Pto &lt;p Pfrom then
return (&lt;Fto&gt;,Pie:F)
else if Pi. = Pfro,„ then
return(F,NIL)
else return (F,Pto: &lt;Pf rom &gt;)
</figure>
<figureCaption confidence="0.9991768">
Figure 9: Movement of a Subformula — Correct
Version
The definition of move_formula given in Fig-
ure 7 has to be replaced by the version given in
Figure 9. We distinguish three cases:
</figureCaption>
<listItem confidence="0.94331975">
• If the pointer is positive we proceed as usual.
• If it points to the actual location, it can be
ignored (i.e. treated as NIL). This case occurs,
when the same path equivalence is stated more
than once in the input.
• If the pointer is negative, it is inverted by in-
stalling at its destination a pointer to the ac-
tual position.
</listItem>
<subsectionHeader confidence="0.999579">
5.2 Incorporating Disjunction
</subsectionHeader>
<bodyText confidence="0.999695857142857">
The procedure unity_disj in Figure 10 has four
arguments: the formula to unify with the disjunc-
tion (which also can be a disjunction), both dis-
juncts, and the actual location. In the first two
statements, the unifications of the formula A with
the disjuncts B and C are performed indepen-
dently. We can distinguish three main cases:
</bodyText>
<listItem confidence="0.98619625">
• If one of the unifications fails, the result of the
other is returned without modification.
• If both unifications have no global effect or if
the global effects happen to result in the same
</listItem>
<page confidence="0.96077">
291
</page>
<equation confidence="0.78986725">
unify_disj (A , B ,C,Fa)
, (formula,formula)
(1.11G1) := unify-aux(A,B,P4)
(L2A2) := unify-aux(A,C,P4)
it LI = TOP or G1 = TOP then
return (L21O2)
else it Ly = TOP or G2 = TOP then
return (LI,G1)
else if GI = G2 then
return (L1VL2.G1)
else return (NIL,pack(unity(P.:14,GOV
unify(P0:L2,G2)))
</equation>
<figureCaption confidence="0.743949">
Figure 10: Unification with a Disjunction
</figureCaption>
<bodyText confidence="0.9991544">
formula, a disjunction is returned as local re-
sult and the common global result of both dis-
juncts is taken as the global result for the dis-
junction.
• If both unifications have different global re-
sults, we can not return a disjunction as local
result, since remote parts of the resulting for-
mula depend on the choice of the disjunct at
the actual location. This case arrives if one or
both disjuncts have outgoing pointers and if
one of these pointers has been actually used to
move a subformula to its destination.
The last point describes exactly the case where
the scope of a disjunction has to be extended to
a higher level due to the interaction between dis-
junction and path equivalence, as was shown in
Figure 3. A simple treatment of such effects would
be to return a disjunction as global result where
the disjuncts are the global results unified with the
corresponding local result embedded at the actual
position. However, it is not always necessary to
return a top-level disjunction in such a situation.
If the global effect of a disjunction concerns only
locations &apos;close&apos; to the location of the disjunction,
we get two global results that differ only in an em-
bedded substructure. To minimize the &apos;lifting&apos; of
the disjunction, we can assume a procedure pack
that takes two formulae X and Y and returns a
formula equivalent to X V Y where the disjunction
is embedded at the lowest possible level.
Although the procedure pack can be defined in a
straightforward manner, we refrain from a formal
specification, since the discussion in the next sec-
tion will show how the same effect can be achieved
in a different way.
</bodyText>
<sectionHeader confidence="0.993432" genericHeader="method">
6 Implementation
</sectionHeader>
<bodyText confidence="0.999984666666667">
We now have given a complete specification of a
unification algorithm for formulae in ENF. How-
ever, there are a couple of modifications that can
be applied to it in order to improve its efficiency.
The improvements described in this section are all
part of our actual implementation.
</bodyText>
<subsectionHeader confidence="0.954189">
Unification of Two Pointers
</subsectionHeader>
<bodyText confidence="0.9928226">
If both arguments are pointers, the algorithm in
Figure 6 treats one of them in the same way as
an arbitrary formula and tries to move it to the
destination of the other pointer. Although this
treatment is correct, some of the necessary com-
putations can be avoided if this case is treated in
a special way. Both pointer destinations and the
actual location should be compared and pointers
to the smallest of these three paths should be in-
stalled at the other locations.
</bodyText>
<subsectionHeader confidence="0.990113">
Special Treatment of Atomic Formulae
</subsectionHeader>
<bodyText confidence="0.999991571428572">
In most applications, we do not care about the
equivalence of two paths if they lead to the same
atom. Under this assumption, when moving an
atomic formula along a pointer, the pointer itself
can be replaced by the atom without loss of infor-
mation. This helps to reduce the amount of global
information that has to be handled.
</bodyText>
<subsectionHeader confidence="0.957299">
Ordering Labels
</subsectionHeader>
<bodyText confidence="0.999785631578948">
The unification of conjunctions that contain many
labels can be accelerated by keeping the labels
sorted according to some order (e.g. &lt;/). This
avoids searching one formula for each label that
occurs in the other.
Organisation of the Global Results on a
Stack
In the algorithm described so far, the global re-
sult of a unification is collected, but is - apart
from disjunction - not used before the traversal
of the input formulae is finished. When formulae
containing many pointers are unified, the repeated
traversal of the top-level formula slows down the
unification, and may lead to the construction of
many intermediate results that are discarded later
(after having been copied partially).
To improve this aspect of the algorithm, we have
chosen a better representation of the global result.
Instead of one formula, we represent it as a stack of
</bodyText>
<page confidence="0.98821">
292
</page>
<bodyText confidence="0.999989434782609">
formulae where the first element holds information
for the actual location and the last element holds
information for the top-level formula. Each time
a formula has to be moved along a pointer, its
destination is compared with the actual location
and the common prefix of the paths is discarded.
From the remaining part of the actual location
we can determine the first element on the stack
where this information can be stored. The rest of
the destination path indicates how the information
has to be represented at that location.
When returning from the recursion, the first el-
ement on the stack can be popped and the infor-
mation in it can be used immediately.
This does not only improve efficiency, but has
also an effect on the treatment of disjunction. In-
stead of trying to push down a top-level disjunc-
tion to the lowest possible level, we climb up the
stacks returned by the recursive unifications and
collect the subformulae until the rests of the stacks
are identical. In this way, &apos;lifting&apos; disjunctions can
be limited to the necessary amount without using
a function like pack.
</bodyText>
<subsectionHeader confidence="0.944129">
Practical Experiences
</subsectionHeader>
<bodyText confidence="0.9999930625">
In order to be compatible with existing software,
the algorithm has been implemented in PROLOG.
It has been extended to the treatment of unifica-
tion in an LFG framework where indirectly speci-
fied labels (e.g in the equation (1 (1pcase)) = 1 ),
set values and various sorte of constraints have to
be considered.
This version has been incorporated into an
existing grammar development facility for LFGs
[Eisele/D8rre 86,Eisele/Schimpf 87] and has not
only improved efficiency compared to the former
treatment of disjunction by backtracking, but also
helps to survey a large number of similar results
when the grammar being developed contains (too)
much disjunction. One version of this system runs
on PCs with reasonable performance.
</bodyText>
<sectionHeader confidence="0.9994895" genericHeader="method">
7 Comparison with Other
Approaches
</sectionHeader>
<subsectionHeader confidence="0.999593">
7.1 Asymptotical Complexity
</subsectionHeader>
<bodyText confidence="0.9999226875">
Candidates for a comparison with our algorithm
are the naive multiplying-out to DNF, Kasper&apos;s
representation of general disjunction [Kasper 87b],
and Karttunen&apos;s treatment of value disjunction
[Karttunen 84], also the improved version in
[Bear 87]. Since satisfiability of formulae in FML is
known to be an NP-complete problem, we cannot
expect better than exponential time complexity in
the worst case. Nevertheless it might be interest-
ing to find cases where the asymptotic behaviour
of the algorithms differ. The following statements
— although somewhat vague — may give an im-
pression of strong and weak points of the differ-
ent methods. For each given statement we have
specific examples, but their presentation or proofs
would be beyond the scope of this paper.
</bodyText>
<subsectionHeader confidence="0.367455">
7.1.1 Space Complexity (Compactness of
the Representation)
</subsectionHeader>
<listItem confidence="0.8854236">
• When many disjunctions concern different
substructures and do not depend on each
other, our representation uses exponentially
less space than expansion to DNF.
• There are cases where Kasper&apos;s representation
uses exponentially less space than our repre-
sentation. This happens when disjunctions in-
teract strongly, but an exponential amount of
consistent combinations remain.
• Since Karttunen&apos;s method enumerates all con-
sistent combinations when several disjunctions
concern the same substructure, but allows
for local representation in all other cases, his
method seems to have a similar space complex-
ity than ours.
</listItem>
<subsubsectionHeader confidence="0.787949">
7.1.2 Time Complexity
</subsubsectionHeader>
<bodyText confidence="0.9817178">
• There are cases where Kasper&apos;s method uses
exponentially more time than ours. This hap-
pens when disjunctions interact so strongly,
that only few consistent combinations remain,
but none of the disjunctions can be resolved.
• When disjunctions interact strongly, but an ex-
ponential amount of consistent combinations
remains, our method needs exponential time.
An algorithm using Kasper&apos;s representation
could do better in some of these cases, since
it could find out in polynomial time that each
of the disjuncts is used in a consistent com-
bination. However, the actual organisation of
Kasper&apos;s full consistency check introduces ex-
ponential time complexity for different reasons.
</bodyText>
<subsectionHeader confidence="0.7505375">
7.2 Average Complexity and Con-
clusion
</subsectionHeader>
<bodyText confidence="0.9972865">
It is difficult to find clear results when comparing
the average complexity of the different methods,
</bodyText>
<page confidence="0.993087">
293
</page>
<bodyText confidence="0.99994475">
since anything depends on the choice of the exam-
ples. However, we can make the following general
observation:
Al! methods have to multiply out disjunctions
that are not mutually independent in order to find
inconsistencies.
Kasper&apos;s and Karttunen&apos;s methods discard the
results of such computations, whereas our algo-
rithm keeps anything that is computed until a con-
tradiction appears. Thus, our method tends to use
more space than the others. On the other hand,
since Kasper&apos;s and Karttunen&apos;s methods &apos;forget&apos;
intermediate results, they are sometimes forced to
perform identical computations repeatedly.
As conclusion we can say that our algorithm
sacrifies space in order to save time.
</bodyText>
<sectionHeader confidence="0.999873" genericHeader="conclusions">
8 Further Work
</sectionHeader>
<bodyText confidence="0.999208">
The algorithm or the underlying representation
can still be improved or extended in various re-
spects:
</bodyText>
<subsectionHeader confidence="0.6734">
General Disjunction
</subsectionHeader>
<bodyText confidence="0.999932714285714">
For the time being, when a formula is unified with
a disjunction, the information contained in it has
to be distributed over all disjuncts. This may
involve some unnecessary copying of label-value-
pairs in cases where the disjunction does not in-
teract with the information in the formula. (Note,
however, that in such cases only the first level of
the formula has to be copied.) It seems worthwhile
to define a relaxed ENF, where a formula (AVB)AC
is allowed under certain circumstances (e.g. when
(A V B) and C do not contain common labels)
and to investigate whether a unification algorithm
based on this relaxed normal form can help to save
unnecessary computations.
</bodyText>
<subsectionHeader confidence="0.943683">
Functional Uncertainty
</subsectionHeader>
<bodyText confidence="0.999957142857143">
The algorithm for unifying formulae with regular
path expressions given by Johnson [Johnson 86]
gives as a result of a unification a finite disjunction
of cases. The algorithm presented here seems to
be a good base for an efficient implementation of
Johnson&apos;s method. The details still have to be
worked out.
</bodyText>
<sectionHeader confidence="0.999089" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.996638071428571">
The research reported in this paper was supported by the
EUROTRA-D accompanying project (BMFT grant No.
101 3207 0), the ESPRIT project ACORD (P393) and the
project LILOG (supported by IBM Deutschland). Much of
the inspiration for this work originated from a course about
extensions to unification (induding the work of Kasper and
Rounds) which Hans Uszkoreit held at the University of
Stuttgart in spring 1987. We had fruitful discussions with
Lauri Karttunen about an early version of this algorithm.
Thanks also go to Jurgen Wedekind, Hank Zeevat, Inge
Bethke, and Roland Seiffert for helpful discussions and im-
portant counterexamples, and to Fiona McKinnon, Stefan
Momma, Gert Smollca, and Carin Specht for polishing up
our argumentation.
</bodyText>
<sectionHeader confidence="0.999358" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999855854166667">
(Alt-Kaci/Naar 86] ATt-Kaci, H. and R. Naar (1986). LO-
GIN: A Logic Programming Language with Built-In In-
heritance. The Journal of Logic Programming, 1986(3).
[Bear 87] Bear, J. (1987). FeaturaValue Unification with
Disjunctions. Ms. SRI International, Stanford, CA.
[Eisele 87] Eisele, A. (1987). Eine Implementierung relcur-
siver MerkmaLstrukturen mit disjunktiven Angaben.
Diplomarbeit. Institut f. Informatik, Stuttgart.
[Eisele/Dane 86] Eisele, A. and J. Dorre (1986). A Lexical
Functional Grammar System in Prolog. In: Proceedings
of COLING 1986, Bonn.
[Eisele/Schimpf 87] Eisele, A. and S. Schimpf (1987). Eine
benutzerfreundliche Softwareumgebung zur Entwick-
lung von LFGen. Studienarbeit. IfI, Stuttgart.
[Gazdar et al. 85] Gander, G., E. Klein, G. Pullum and I.
Sag (1985). Generalized Phrase Structure Grammar. Lon-
don: Blackwell.
[Johnson 86] Johnsen, M. (1986). Computing with Regular
Path Formulas. Ms. CSLI, Stanford, California.
[Kaplan/Braman 82] Kaplan, R. und J. Bresnan (1982).
Lexical Functional Grammar: A Formal System for
Grammatical Representation. In: J. Bresnan (ed.), The
Mental Representation of Grammatical Relations. MIT Press,
Cambridge, Massachusetts.
[Karttunen 84] Karttunen, L. (1984). Features and Values.
In: Proceedings of COLING 1984, Stanfeed, CA.
[Kasper 87a] Kasper, R.T. (1987). Feature Structures: A
Logical Theory with Application to Language Analysis.
Ph.D. Thesis. University of Michigan.
[Kasper 87b] Kasper, R.T. (1987). A Unification Method
for Disjunctive Feature Descriptions. In: Proceedings of
the 25th Annual Meeting of the ACL. Stanford, CA.
[Kasper/Rounds 86] Kasper, R.T. and W. Rounds (1986).
A Logical Semantics for Feature Structures. In: Pro-
ceedings of the 21th Annual Meeting of the ACL. Columbia
University, New York, NY.
[Kay 79] Kay, M. (1979). Functional Grammar. In: C.
Chiarello et al. (eds.) Proceedings of the 5th Annual Meeting
of the Berkeley Linguistic Society.
[Kay 85] Kay, M. (1985). Parsing in Functional Unification
Grammar. In: D. Dowty, L. Karttunen, and A. Zwicky
(eds.) Nature/ Language Parsing, Cambridge, England.
[Smolka/Alt-Kaci 87] &amp;nonce, G. and H. AU-Kaci (1987).
Inheritance Hierarchies: Semantics and Unification.
MCC Tech. Rep. No AI-057-87. To appear in: Journal
of Symbolic Logic, Special Issue on Unification, 1988.
[Uszkoreit 86] Uszlcoreit, H. (1986). Categorial Unification
Grammars. In: Proceedings of COLING 1996, Bonn.
</reference>
<page confidence="0.998398">
294
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.052544">
<title confidence="0.999833">Unification of Disjunctive Feature Descriptions</title>
<author confidence="0.999732">Andreas Eisele</author>
<author confidence="0.999732">Jochen DOrre</author>
<affiliation confidence="0.9926485">Institut ffir Maschinelle Sprachverarbeitung Universitat Stuttgart</affiliation>
<address confidence="0.997471">Keplerstr. 17, 7000 Stuttgart 1, West Germany</address>
<email confidence="0.880911">Netmail:ims@rusvx2.rus.uni-stuttgart.dbp.de</email>
<abstract confidence="0.966908057471264">The paper describes a new implementation of feature structures containing disjunctive values, which can be characterized by the following main points: Local representation of embedded disjunctions, avoidance of expansion to disjunctive normal form and of repeated test-unifications for checking consistence. The method is based on a modification of Kasper and Rounds&apos; calculus of feature descriptions and its correctness therefore see. It can handle cyclic structures and has been incorporated successfully into an environment for grammar development. 1 Motivation In current research in computational linguistics but also in extralinguistic fields unification has turned out to be a central operation in the modelling of data types or knowledge in general. Among linguistic formalisms and theories which are based on the unification paradigm are such different theories as FUG [Kay 79,Kay 85], LFG [Kaplan/Bresnan 82], GSPG [Gazdar et al. 85], CUG [Uszkoreit 86]. However, research in unification is also relevant for fields like logic programming, theorem proving, knowledge representation (see [Smolka/Ait-Kaci 87] for multiple inheritance hierarchies using unification), programming language design [Alt-Kaci/Nasr 86] and others. The version of unification our work is based on which is an extension of term unification. In graph unification the number of arguments is free and arguments are selected by attribute labels rather than by position. The algorithm described here may easily be modified to apply to term unification. The structures we are dealing with are rooted directed graphs where arcs starting in one node must carry distinct labels. Terminal nodes may also be labelled. These structures are referred to by various names in the literature: feature structures, functional structures, functional descriptions, types, categories. We will call them feature throughout this paper. In applications, other than toy applications, the processing of information represented by specifications becomes a relevant factor. A strategy of multiplyingout disjunction by exploiting (nearly) any combination of disjuncts through backtracking, as it is done, e.g., in the case of a simple DCG parser, quickly runs into efficiency problems. On the other hand the descriptional power of disjunction often helps to state highly ambiguous linguistic knowledge clearly and concisely (see Fig. 1 for a disjunctive description of morphological features for the six readings of the german noun `Koffer&apos;). Koffer: rnum: sg 1 L.pers: 3 j masc {nom dat acc morph: pers: MaSC {nom gen acc rrel: Koffer&apos; 1 I arg: [ ] Figure 1: Using disjunction in the description of linguistic structures Kasper and Rounds [86] motivated the distinction between feature structures and formulae of a logical calculus that are used to describe feature be used within such formula to describe feature structures. With this separation the underlying mathematical framework which is used to define the semantics of the descriptions can be kept simple. do not, frequently done, restrict ourselves to acyclic structures. sem: agr: gend: case: agr: gend: case: 1 3 286 2 Disjunctive Feature Descriptions We use a slightly modified version of the formula Kasper and Rounds [86] to describe our feature structures. Fig. 2 gives the synof the atoms and set of labels. FML&apos; contains: NIL TOP E : FMV A where 4), E FML&apos; &lt;I) V 4/ where 4), E FMI2 where Figure 2: Syntax of FML&apos; In contrast to Kasper and Rounds [86] we do not use the syntactic construct of path equivalence classes. Instead, path equivalences are expressed using non-local path expressions (called pointers the sequel). This choice is motivated the fact that we use these pointers for an efficient representation below, and we want to keep FML&apos; as simple as possible. intuitive semantics of is as follows [Kasper/Rounds 86] for formal definitions): 1. NIL is satisfied by any feature structure. 2. TOP is never satisfied. 3. a is satisfied by the feature structure consisting of a single node labelled 1 : (I) a (sub-)structure under arc satisfy 4). 5. 4) A 4f is satisfied by a feature structure that 4) satisfies AP. 6. 4) V is satisfied by a feature structure that satisfies 4) or satisfies 7. (p) requires a path equivalence (two paths leading to the same node) between the path (p) and the actual path relative to the top-level The denotation of a formula cI) is usually defined as the set of minimal elements of SAT(4) with to where SAT(0) is the set 2This construct is context-sensitive in the sense that the denotation of (p) may only be computed with respect to the whole structure that the formula describes. 3The subsumption relation C is a partial ordering on feature structures inducing a semi-lattice. It may be defined as: FS1 C FS2 if the set of formulae satisfied by FS2 includes the set of formulae satisfied by FS1. of feature structures which satisfy &lt;D. Example: The formula = j : : (agr) (nom denotes the two graphs case acc The unification problem for disjunctive feature descriptions can be stated as follows: Given two formulae that describe feature structures, find the set of feature structures that satisfy both formulae, if it is nonempty, else announce `fail&apos;. The simplest way to deal with disjunction is to rewrite any description into disjunctive normal form (DNF). This transformation requires time and space exponential with the number of disjuncts in the initial formula in the worst case. Although the problem of unifying disjunctive descriptions is known to be NP-complete (see [Kasper 87a]), methods which avoid this transformation may perform well in most practical cases. The key idea is to keep disjunction local and consider combinations of disjuncts only when they refer to the very same substructure. This strategy, however, is complicated by the fact that feature structures may be graphs with path equivalences and not only trees. Fig. 3 shows an example where unifying a disjunction with a structure containing reentrancy causes parts of the disjunction to be linked to other parts of the structure. The disis this reentrancy. Hence, value of attribute be represented uniquely. It may be + or -, depending on which disjunct in attribute a is chosen. To represent this information without extra formal devices we have lift the disjunction one level 4In this special case we still could keep the disjunction the attribute a by inverting the pointer. A pointer label allow us to specify the value of dependent on the disjunction under a. 3 The Problem nom subj agr and subj agr 287 a: a: b: (d) [{ d: C b: (d) 11 b: (d) 11 1 a: d: a: d: A) Restricted syntax of ENF: NIL TOP where a E A • • A : (1). where E ENF\{TOP}, E li lj j V %If 4), P E ENF\{TOP} where p E B) Additional condition C,,,,„: If an instance 4, of a formula contains a pointer then the path p must be in Figure 4: A normal form to describe feature structures efficiently Figure 3: Lifting of disjunction due to reentrancy 4 From Description to Efficient Representation is interesting to investigate whether suitable as an encoding of feature structures, i.e. if it can be used for computational purposes. However, this is clearly not the case for the unset of formulae of a given feature structure can be represented by infinitely many different formulae of arbitrary complexity and — even worse — because it is also not possible to ascertain whether a given formula represents any feature structure at all without extensive computation. the other hand, the formulae of some properties that are quite attractive for representing feature structures, such as embedded and general disjunction and the possibility to make use of the law of distributivity for disjunctions. Therefore we have developed an efficiencyoriented normal form ENF, which is suitable as an efficient representation for sets of feature structures. The formulae are built according to a restricted syntax (Fig. 4, Part A) and have to satisfy condi- (Part B). The syntax restricts the use of conjunction and TOP in order to disallow contradictory information in a formula other than TOP. However, even in a formula of the syntax of Part A inconsistence can be introduced by a pointer to a location that is `blocked&apos; by an atomic value on a level. For example in the formula (b c) A b:d the path (b c) is blocked since it would the value of attribute be complex in conflict to the atomic value d, thus rendering the formula non-satisfiable. With the additional consuch inconsistencies are excluded. Its explanation in the next section is somewhat technical and is not prerequisite for the overall understanding of our method. First we have to introduce some terminology. every disjunction in a formula is replaced by one of its disjuncts, the result is called an instance of that formula. Realized: A recursive definition of what we call in an instance d, is given in Fig. 5. The intuitive idea behind this notion is to restrict realized in 4, 0 TOP realized in II : 4,1. A • if / • • • In }) realized in • • • A : A •• if p is realized in is realized in (p&apos;), if p&apos;p is realized in the top-level formula Figure 5: Definition of realized paths pointers in such a way that the path to their des-</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<title>LOGIN: A Logic Programming Language with Built-In Inheritance.</title>
<date>1986</date>
<journal>The Journal of Logic Programming,</journal>
<volume>1986</volume>
<issue>3</issue>
<marker>1986</marker>
<rawString> (Alt-Kaci/Naar 86] ATt-Kaci, H. and R. Naar (1986). LOGIN: A Logic Programming Language with Built-In Inheritance. The Journal of Logic Programming, 1986(3).</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Bear</author>
</authors>
<title>FeaturaValue Unification with Disjunctions. Ms.</title>
<date>1987</date>
<publisher>SRI International,</publisher>
<location>Stanford, CA.</location>
<marker>[Bear 87]</marker>
<rawString>Bear, J. (1987). FeaturaValue Unification with Disjunctions. Ms. SRI International, Stanford, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Eisele</author>
</authors>
<date>1987</date>
<booktitle>Eine Implementierung relcursiver MerkmaLstrukturen mit disjunktiven Angaben. Diplomarbeit. Institut f. Informatik,</booktitle>
<location>Stuttgart.</location>
<marker>[Eisele 87]</marker>
<rawString>Eisele, A. (1987). Eine Implementierung relcursiver MerkmaLstrukturen mit disjunktiven Angaben. Diplomarbeit. Institut f. Informatik, Stuttgart.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Eisele</author>
<author>J Dorre</author>
</authors>
<title>A Lexical Functional Grammar System in Prolog. In:</title>
<date>1986</date>
<booktitle>Proceedings of COLING 1986,</booktitle>
<location>Bonn.</location>
<marker>[Eisele/Dane 86]</marker>
<rawString>Eisele, A. and J. Dorre (1986). A Lexical Functional Grammar System in Prolog. In: Proceedings of COLING 1986, Bonn.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Eisele</author>
<author>S Schimpf</author>
</authors>
<date>1987</date>
<booktitle>Eine benutzerfreundliche Softwareumgebung zur Entwicklung von LFGen. Studienarbeit. IfI,</booktitle>
<location>Stuttgart.</location>
<marker>[Eisele/Schimpf 87]</marker>
<rawString>Eisele, A. and S. Schimpf (1987). Eine benutzerfreundliche Softwareumgebung zur Entwicklung von LFGen. Studienarbeit. IfI, Stuttgart.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Gander</author>
<author>E Klein</author>
<author>G Pullum</author>
<author>I Sag</author>
</authors>
<date>1985</date>
<booktitle>Generalized Phrase Structure Grammar.</booktitle>
<publisher>Blackwell.</publisher>
<location>London:</location>
<marker>[Gazdar et al. 85]</marker>
<rawString>Gander, G., E. Klein, G. Pullum and I. Sag (1985). Generalized Phrase Structure Grammar. London: Blackwell.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Johnsen</author>
</authors>
<title>Computing with Regular Path Formulas.</title>
<date>1986</date>
<location>Ms. CSLI, Stanford, California.</location>
<marker>[Johnson 86]</marker>
<rawString>Johnsen, M. (1986). Computing with Regular Path Formulas. Ms. CSLI, Stanford, California.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R und J Bresnan Kaplan</author>
</authors>
<title>Lexical Functional Grammar: A Formal System for Grammatical Representation.</title>
<date>1982</date>
<editor>In: J. Bresnan (ed.),</editor>
<publisher>MIT Press,</publisher>
<location>Cambridge, Massachusetts.</location>
<marker>[Kaplan/Braman 82]</marker>
<rawString>Kaplan, R. und J. Bresnan (1982). Lexical Functional Grammar: A Formal System for Grammatical Representation. In: J. Bresnan (ed.), The Mental Representation of Grammatical Relations. MIT Press, Cambridge, Massachusetts.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Karttunen</author>
</authors>
<title>Features and Values. In:</title>
<date>1984</date>
<booktitle>Proceedings of COLING</booktitle>
<location>Stanfeed, CA.</location>
<marker>[Karttunen 84]</marker>
<rawString>Karttunen, L. (1984). Features and Values. In: Proceedings of COLING 1984, Stanfeed, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R T Kasper</author>
</authors>
<title>Feature Structures: A Logical Theory with Application to Language Analysis.</title>
<date>1987</date>
<tech>Ph.D. Thesis.</tech>
<institution>University of Michigan.</institution>
<marker>[Kasper 87a]</marker>
<rawString>Kasper, R.T. (1987). Feature Structures: A Logical Theory with Application to Language Analysis. Ph.D. Thesis. University of Michigan.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R T Kasper</author>
</authors>
<title>A Unification Method for Disjunctive Feature Descriptions. In:</title>
<date>1987</date>
<booktitle>Proceedings of the 25th Annual Meeting of the ACL.</booktitle>
<location>Stanford, CA.</location>
<marker>[Kasper 87b]</marker>
<rawString>Kasper, R.T. (1987). A Unification Method for Disjunctive Feature Descriptions. In: Proceedings of the 25th Annual Meeting of the ACL. Stanford, CA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R T Kasper</author>
<author>W Rounds</author>
</authors>
<title>A Logical Semantics for Feature Structures. In:</title>
<date>1986</date>
<booktitle>Proceedings of the 21th Annual Meeting of the ACL.</booktitle>
<institution>Columbia University,</institution>
<location>New York, NY.</location>
<marker>[Kasper/Rounds 86]</marker>
<rawString>Kasper, R.T. and W. Rounds (1986). A Logical Semantics for Feature Structures. In: Proceedings of the 21th Annual Meeting of the ACL. Columbia University, New York, NY.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Kay</author>
</authors>
<title>Functional Grammar. In:</title>
<date>1979</date>
<booktitle>Proceedings of the 5th Annual Meeting of the Berkeley Linguistic Society.</booktitle>
<editor>C. Chiarello et al. (eds.)</editor>
<marker>[Kay 79]</marker>
<rawString>Kay, M. (1979). Functional Grammar. In: C. Chiarello et al. (eds.) Proceedings of the 5th Annual Meeting of the Berkeley Linguistic Society.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Kay</author>
</authors>
<title>Parsing in Functional Unification Grammar. In:</title>
<date>1985</date>
<booktitle>Nature/ Language Parsing,</booktitle>
<editor>D. Dowty, L. Karttunen, and A. Zwicky (eds.)</editor>
<location>Cambridge, England.</location>
<marker>[Kay 85]</marker>
<rawString>Kay, M. (1985). Parsing in Functional Unification Grammar. In: D. Dowty, L. Karttunen, and A. Zwicky (eds.) Nature/ Language Parsing, Cambridge, England.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G &amp;nonce</author>
<author>H AU-Kaci</author>
</authors>
<title>Inheritance Hierarchies: Semantics and Unification.</title>
<date>1987</date>
<journal>Journal of Symbolic Logic, Special Issue on Unification,</journal>
<tech>MCC Tech. Rep. No AI-057-87.</tech>
<note>To appear in:</note>
<marker>[Smolka/Alt-Kaci 87]</marker>
<rawString>&amp;nonce, G. and H. AU-Kaci (1987). Inheritance Hierarchies: Semantics and Unification. MCC Tech. Rep. No AI-057-87. To appear in: Journal of Symbolic Logic, Special Issue on Unification, 1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Uszlcoreit</author>
</authors>
<title>Categorial Unification Grammars. In:</title>
<date>1986</date>
<booktitle>Proceedings of COLING 1996,</booktitle>
<location>Bonn.</location>
<marker>[Uszkoreit 86]</marker>
<rawString>Uszlcoreit, H. (1986). Categorial Unification Grammars. In: Proceedings of COLING 1996, Bonn.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>