<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.996103">
Efficient Stacked Dependency Parsing by Forest Reranking
</title>
<author confidence="0.988043">
Katsuhiko Hayashi and Shuhei Kondo and Yuji Matsumoto
</author>
<affiliation confidence="0.987779">
Graduate School of Information Science Nara Institute of Science and Technology
</affiliation>
<address confidence="0.605632">
8916-5, Takayama, Ikoma, Nara 630-0192, Japan
</address>
<email confidence="0.999281">
{katsuhiko-h,shuhei-k,matsu}@is.naist.jp
</email>
<sectionHeader confidence="0.998602" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9999223125">
This paper proposes a discriminative for-
est reranking algorithm for dependency pars-
ing that can be seen as a form of efficient
stacked parsing. A dynamic programming
shift-reduce parser produces a packed deriva-
tion forest which is then scored by a discrim-
inative reranker, using the 1-best tree output
by the shift-reduce parser as guide features in
addition to third-order graph-based features.
To improve efficiency and accuracy, this pa-
per also proposes a novel shift-reduce parser
that eliminates the spurious ambiguity of arc-
standard transition systems. Testing on the
English Penn Treebank data, forest reranking
gave a state-of-the-art unlabeled dependency
accuracy of 93.12.
</bodyText>
<sectionHeader confidence="0.999517" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999894452380953">
There are two main approaches of data-driven de-
pendency parsing – one is graph-based and the other
is transition-based.
In the graph-based approach, global optimiza-
tion algorithms find the highest-scoring tree with
locally factored models (McDonald et al., 2005).
While third-order graph-based models achieve state-
of-the-art accuracy, it has O(n4) time complexity
for a sentence of length n. Recently, some prun-
ing techniques have been proposed to improve the
efficiency of third-order models (Rush and Petrov,
2012; Zhang and McDonald, 2012).
The transition-based approach usually employs
the shift-reduce parsing algorithm with linear-time
complexity (Nivre, 2008). It greedily chooses the
transition with the highest score and the result-
ing transition sequence is not always globally op-
timal. The beam search algorithm improves pars-
ing flexibility in deterministic parsing (Zhang and
Clark, 2008; Zhang and Nivre, 2011), and dy-
namic programming makes beam search more effi-
cient (Huang and Sagae, 2010).
There is also an alternative approach that in-
tegrates graph-based and transition-based models
(Sagae and Lavie, 2006; Zhang and Clark, 2008;
Nivre and McDonald, 2008; Martins et al., 2008).
Martins et al. (2008) formulated their approach as
stacking of parsers where the output of the first-stage
parser is provided to the second as guide features. In
particular, they used a transition-based parser for the
first stage and a graph-based parser for the second
stage. The main drawback of this approach is that
the efficiency of the transition-based parser is sacri-
ficed because the second-stage employs full parsing.
This paper proposes an efficient stacked pars-
ing method through discriminative reranking with
higher-order graph-based features, which works on
the forests output by the first-stage dynamic pro-
gramming shift-reduce parser and integrates non-
local features efficiently with cube-pruning (Huang
and Chiang, 2007). The advantages of our method
are as follows:
</bodyText>
<listItem confidence="0.998362833333333">
• Unlike the conventional stacking approach, the
first-stage shift-reduce parser prunes the search
space of the second-stage graph-based parser.
• In addition to guide features, the second-stage
graph-based parser can employ the scores of
the first-stage parser which cannot be incorpo-
</listItem>
<page confidence="0.986855">
139
</page>
<bodyText confidence="0.3436485">
Transactions of the Association for Computational Linguistics, 1 (2013) 139–150. Action Editor: Joakim Nivre.
Submitted 12/2012; Revised 3/2013; Published 5/2013. c�2013 Association for Computational Linguistics.
</bodyText>
<equation confidence="0.99802425">
axiom(c0) : 0 : (0, 1, w0) : 0
goal(c2n) : 2n : (0, n, s0) : 0
state p
� � 1
ℓ :( ,j, sd|sd−1 |... |s1|s0) :
ℓ + 1 : (j, j + 1, sd−1|sd−2 |... |s0|wj) : (p) i &lt; n
reduce↶ :
reduce↷ :
</equation>
<figureCaption confidence="0.9909585">
Figure 1: The arc-standard transition-based dependency parsing system with dynamic programming: means “take
anything”. a↷b denotes that a tree b is attached to a tree a.
</figureCaption>
<figure confidence="0.428699277777778">
shift :
state p
� � 1
: (i, j, s′d|s′d−1 |... |s′ 1|s′0) : π′
state q
� � 1
ℓ : (j, k, sd|sd−1 |... |s1|s0) : π
s′ 0.h.w =� w0 n p E π
ℓ + 1 : (i, k, s′ d|s′ d−1 |. . . |s′ 1|s′ 0↶s0) : π′
state p
� � 1
: (i,j, s′d|s′d−1 |... |s′1|s′0) : π′
state q
� � 1
ℓ : (j, k, sd|sd−1 |... |s1|s0) : π
+ 1 : i k s′ s′ _ s&apos; s′ ↷s π′ p E
(&gt; , dI d-1 I lI 0 0)
rated in standard graph-based models.
</figure>
<listItem confidence="0.658156">
• In contrast to joint transition-based/graph-
</listItem>
<bodyText confidence="0.93049925">
based approaches (Zhang and Clark, 2008;
Bohnet and Kuhn, 2012) which require a large
beam size and make dynamic programming im-
practical, our two-stage approach can integrate
both models with little loss of efficiency.
In addition, the elimination of spurious ambiguity
from the arc-standard shift-reduce parser improves
the efficiency and accuracy of our approach.
</bodyText>
<sectionHeader confidence="0.988944" genericHeader="introduction">
2 Arc-Standard Shift-Reduce Parsing
</sectionHeader>
<bodyText confidence="0.99900375">
We use a beam search shift-reduce parser with dy-
namic programming as our baseline system. Fig-
ure 1 shows it as a deductive system (Shieber et al.,
1995). A state is defined as the following:
</bodyText>
<equation confidence="0.577678">
ℓ : (i, j, sd|sd−1 |... |s1|s0) : π
</equation>
<bodyText confidence="0.996013555555555">
where ℓ is the step size, [i, j] is the span of the top-
most stack element s0, and sd|sd−1 |... |s1 shows
a stack with d elements at the top, where d is the
window size used for defining features. The ax-
iom is initialized with an input sentence of length n,
x = w0 ... wn where w0 is a special root symbol $0.
The system takes 2n steps for a complete analysis.
π is a set of pointers to the predictor states, each of
which is the state just before shifting the root word
</bodyText>
<equation confidence="0.762186333333333">
s0.h.t o s0.lc.t o s0.lc2.t s0.h.t o s0.rc.t o s0.rc2.t
s1.h.t o s1.lc.t o s1.lc2.t s1.h.t o s1.rc.t o s1.rc2.t
s0.h.t o s0.lc.t o s0.lc2.t o q0.t
s0.h.t o s0.rc.t o s0.rc2.t o q0.t
s0.h.t o s1.h.t o q0.t o q1.t
s0.h.w o s1.h.t o q0.t o q1.t
</equation>
<tableCaption confidence="0.770148">
Table 1: Additional feature templates for shift-reduce
</tableCaption>
<bodyText confidence="0.941495">
parsers: q denotes input queue. h, lc and rc are head, left-
most child and rightmost child of a stack element s. lc2
and rc2 denote the second leftmost and rightmost chil-
dren. t and w are a part-of-speech (POS) tag and a word.
of s0 into stack1. Dynamic programming merges
equivalent states in the same step if they have the
same feature values. We add the feature templates
shown in Table 1 to Huang and Sagae (2010)’s fea-
ture templates.
Dynamic programming not only makes the shift-
reduce parser with beam search more efficient but
also produces a packed forest that encodes an expo-
nential number of dependency trees. A packed de-
pendency forest can be represented by a weighted
(directed) hypergraph. A weighted hypergraph is a
pair H = (V, E), where V is the set of vertices and
E is the set of hyperedges. Each hyperedge e E E
is a tuple e = (T(e), h(e), fe), where h(e) E V is
</bodyText>
<footnote confidence="0.985127333333333">
1Huang and Sagae (2010)’s dynamic programming is based
on a notion of a push computation (Kuhlmann et al., 2011). The
details are out of scope here and readers may refer to the paper.
</footnote>
<page confidence="0.989446">
140
</page>
<figure confidence="0.505844">
X($)saw0, 7
</figure>
<figureCaption confidence="0.983647">
Figure 2: An example of packed dependency (derivation) forest: each vertex has information about the topmost stack
element of the corresponding state to it.
</figureCaption>
<figure confidence="0.927989526315789">
Xman(with)4, 7
IXher,with(saw)1, 7
IXher(saw)1, 7
IX(saw)1, 3
X(her)3, 4
X(with)4, 5
aX(man)5, 7
X(I)1, 2
I
X(a)5, 6
a
X(saw)2, 3
saw
X(man)6, 7
man
her
with
Xwith(her)3, 7
IXher(saw)1, 4
</figure>
<bodyText confidence="0.999931857142857">
its head vertex, T (e) E V + is an ordered list of tail
vertices, and fe is a weight for e.
Figure 2 shows an example of a packed forest.
Each binary hyperedge corresponds to a reduce ac-
tion, and each leaf vertex corresponds to a shift ac-
tion. Each vertex also corresponds to a state, and
parse histories on the states can be encoded into the
vertices. In the example, information about the top-
most stack element is attached to the corresponding
vertex marked with a non-terminal symbol X.
Weights are omitted in the example. In practice,
we attach each reduction weight to the correspond-
ing hyperedge, and add the shift weight to the reduc-
tion weight when a shifted word is reduced.
</bodyText>
<sectionHeader confidence="0.888801" genericHeader="method">
3 Arc-Standard Shift-Reduce Parsing
without Spurious Ambiguity
</sectionHeader>
<bodyText confidence="0.998947206896551">
One solution to remove spurious ambiguity in the
arc-standard transition system is to give priority to
the construction of left arcs over that of right arcs
(or vice versa) like Eisner (1997). For example, an
Earley dependency parser (Hayashi et al., 2012) at-
taches all left dependents to a word before right de-
pendents. The parser uses a scan action to stop the
construction of left arcs.
We apply this idea to the arc-standard transition
system and show the resulting transition system in
Figure 3. We introduce the * symbol to indicate that
the root node of the topmost element on the stack
has not been scanned yet. The shift and reduce↷ ac-
tions can be used only when the root of the topmost
element on the stack has already been scanned, and
all left arcs are always attached to the head before
the head is scanned.
The arc-standard shift-reduce parser without spu-
rious ambiguity takes 3n steps to finish parsing, and
the additional n scan actions add surplus vertices
and (unary) hyperedges to a packed forest. How-
ever, it is easy to remove them from the packed for-
est because the consequent state of a scan action has
a unique antecedent state and all the hyperedges go-
ing out from a vertex corresponding to the conse-
quent state can be attached to the vertex correspond-
ing to the antecedent state. The scan weight of the
removed unary hyperedge is added to each weight of
the hyperedges attached to the antecedent.
</bodyText>
<sectionHeader confidence="0.879914" genericHeader="method">
4 Experiments (Spurious Ambiguity vs.
Non-Spurious Ambiguity)
</sectionHeader>
<bodyText confidence="0.999700142857143">
We conducted experiments on the English Penn
Treebank (PTB) data to compare spurious and non-
spurious shift-reduce parsers. We split the WSJ
part of PTB into sections 02-21 for training, sec-
tion 22 for development, and section 23 for test. We
used the head rules (Yamada and Matsumoto, 2003)
to convert phrase structure to dependency structure.
</bodyText>
<page confidence="0.913325">
141
</page>
<equation confidence="0.9995332">
axiom(c0) : 0 : (0, 1, w0) : 0
goal(c3,,) : 3n : (0, n, s0) : 0
state p
z } |{
ℓ :( , j, sd|sd−1 |... |s1|s0) :
ℓ + 1 : (j,j + 1,sd−1|sd−2 |... |s0|w∗j) : (p) j&lt; n
ℓ : (i, j, sd|sd−1 |... |s1|s∗0) : π
ℓ + 1 : (i, j, sd|sd−1 |... |s1|s0) : π
reduce↶ :
reduce↷ :
</equation>
<figureCaption confidence="0.9887535">
Figure 3: The dynamic programming arc-standard transition-based deductive system without spurious ambiguity: the
symbol represents that the root node of the topmost element on the stack has not been scanned yet.
</figureCaption>
<table confidence="0.684549111111111">
8 16 32 64 128
UAS (w/o punc.) 92.5 (93.5) 92.7 (93.6) 92.6 (93.6) 92.6 (93.6) 92.6 (93.6)
spurious sec. (per sent.) 0.01 0.017 0.03 0.06 0.13
dev. UAS (w/o punc.) 92.5 (93.6) 92.6 (93.6) 92.6 (93.6) 92.6 (93.6) 92.6 (93.6)
non-sp. sec. (per sent.) 0.01 0.018 0.03 0.07 0.13
UAS (w/o punc.) 92.7 (93.3) 92.7 (93.3) 92.7 (93.3) 92.8 (93.3) 92.8 (93.3)
spurious sec. (per sent.) 0.01 0.017 0.03 0.06 0.13
test UAS (w/o punc.) 92.8 (93.4) 92.9 (93.5) 92.9 (93.5) 92.9 (93.5) 92.9 (93.5)
non-sp. sec. (per sent.) 0.01 0.018 0.03 0.06 0.13
</table>
<tableCaption confidence="0.976344">
Table 2: Unlabeled accuracy scores (UAS) and parsing times (+forest dumping times, second per sentence) for parsing
development (WSJ22) and test (WSJ23) data with spurious shift-reduce and proposed shift-reduce parser (non-sp.)
using several beam sizes.
</tableCaption>
<equation confidence="0.988909222222222">
shift :
scan :
state p
z } |{
:(i, j, s′d|s′d−1 |... |s′ 0|s′0) : π′
state q
z } |{
ℓ : (j, k, sd|sd−1 |... |s1|s∗0) : π
s′ 0.h.w =� w0 n p E π
ℓ + 1 : (i, k, s′ d|s′ d−1 |... |s′ 1|s′ 0↶s∗ 0) : π′
state p
z } |{
: (i,j, s′d|s′d−1 |... |s′1|s′0) : π′
state q
z } |{
ℓ : (j, k, sd|sd−1 |... |s1|s0) : π
p E π
ℓ + 1 : (i, k, s′ d|s′ d−1 |. . . |s′ 1|s′ 0↷s0) : π′
</equation>
<bodyText confidence="0.999939785714286">
We used an early update version of the averaged per-
ceptron algorithm (Collins and Roark, 2004; Huang
et al., 2012) to train two shift-reduce dependency
parsers with beam size of 12.
Table 2 shows experimental results of parsing the
development and test datasets with each of the spu-
rious and non-spurious shift-reduce parsers using
several beam sizes. Parsing accuracies were eval-
uated by unlabeled accuracy scores (UAS) with and
without punctuations. The parsing times were mea-
sured on an Intel Core i7 2.8GHz. The average cpu
time (per sentence) includes that of dumping packed
forests. This result indicates that the non-spurious
parser achieves better accuracies than the spurious
</bodyText>
<table confidence="0.7978866">
beam size 8 32 128
% of distinct trees (10) 93.5 94.8 95.0
% of distinct trees (100) 81.8 84.9 87.2
% of distinct trees (1000) 70.6 73.1 77.6
% of distinct trees (10000) 62.1 64.3 65.6
</table>
<tableCaption confidence="0.957228666666667">
Table 3: The percentages of distinct dependency trees in
10, 100, 1000 and 10000 best trees extracted from spuri-
ous forests with several beam sizes.
</tableCaption>
<bodyText confidence="0.9825458">
parser without loss of efficiency.
Figure 4 shows oracle unlabeled accuracies of
spurious k-best lists, non-spurious k-best lists, spu-
rious forests, and non-spurious forests. We extract
an oracle tree from each packed forest using the for-
</bodyText>
<page confidence="0.97602">
142
</page>
<figure confidence="0.9154515">
0 500 1000 1500 2000 2500 3000
ave. # of hyperedges
</figure>
<figureCaption confidence="0.98322625">
Figure 4: Each plot shows oracle unlabeled accuracies of
spurious k-best lists, spurious forests, and non-spurious
forests. The oracle accuracies are evaluated using UAS
with punctuations.
</figureCaption>
<bodyText confidence="0.99997075">
est oracle algorithm (Huang, 2008). Both forests
produce much better results than the k-best lists, and
non-spurious forests have almost the same oracle ac-
curacies as spurious forests.
However, as shown in Table 3, spurious forests
encode a number of non-unique dependency trees
while all dependency trees in non-spurious forests
are distinct from each other.
</bodyText>
<sectionHeader confidence="0.990647" genericHeader="method">
5 Forest Reranking
</sectionHeader>
<subsectionHeader confidence="0.993858">
5.1 Discriminative Reranking Model
</subsectionHeader>
<bodyText confidence="0.999977">
We define a reranking model based on the graph-
based features as the following:
</bodyText>
<equation confidence="0.974797">
y� = argmax α · fg(x, y) (1)
yEH
</equation>
<bodyText confidence="0.999897833333333">
where α is a weight vector, fg is a feature vector (g
indicates “graph-based”), x is the input sentence, y
is a dependency tree and H is a dependency for-
est. This model assumes a hyperedge factorization
which induces a decomposition of the feature vector
as the following:
</bodyText>
<equation confidence="0.8583165">
α · fg(x, y) = ∑ α · fg,e(e). (2)
eEy
</equation>
<bodyText confidence="0.99976425">
The search problem can be solved by simply using
the (generalized) Viterbi algorithm (Klein and Man-
ning, 2001). When using non-local features, the hy-
peredge factorization is redefined to the following:
</bodyText>
<equation confidence="0.765389">
α · fg(x, y) = ∑ α · fg,e(e) + α · fg,e,N(e) (3)
eEy
</equation>
<bodyText confidence="0.999981285714286">
where fg,e,N is a non-local feature vector. Though
the cube-pruning algorithm (Huang and Chiang,
2007) is an approximate decoding technique based
on a k-best Viterbi algorithm, it can calculate the
non-local scores efficiently.
The baseline score can be taken into the reranker
as a linear interpolation:
</bodyText>
<equation confidence="0.9862035">
y� = argmax 0 · sctr(x, y) + α · fg(x, y) (4)
yEH
</equation>
<bodyText confidence="0.999685">
where sctr is the score from the baseline parser (tr in-
dicates “transition-based”), and 0 is a scaling factor.
</bodyText>
<subsectionHeader confidence="0.845851">
5.2 Features for Discriminative Model
5.2.1 Local Features
</subsectionHeader>
<bodyText confidence="0.999965647058824">
While the inference algorithm is a simple Viterbi
algorithm, the discriminative model can use all tri-
sibling features and some grand-sibling features2
(Koo and Collins, 2010) as a local scoring factor in
addition to the first- and sibling second-order graph-
based features. This is because the first stage shift-
reduce parser uses features described in Section 2
and this information can be encoded into vertices of
a hypergraph.
The reranking model also uses guide features ex-
tracted from the 1-best tree predicted by the first
stage shift-reduce parser. We define the guide fea-
tures as first-order relations like those used in Nivre
and McDonald (2008) though our parser handles
only unlabeled and projective dependency struc-
tures. We summarize the features for discriminative
reranking model as the following:
</bodyText>
<listItem confidence="0.977499555555556">
• First- and second-order features: these features
are the same as those used in MST parser3.
• Grand-child features: we define tri-gram POS
features with POS tags of grand parent, parent,
and rightmost or leftmost child.
• Tri-sibling features: we define tri-gram features
with three POS-tags of child, sibling, and tri-
sibling. We also define tri-gram features with
one word and two POS tags of the above.
</listItem>
<footnote confidence="0.5434145">
2The grand-child and grand-sibling features can be used
only when interacting with the leftmost or rightmost child and
sibling. In case of local reranking, we did not use grand-sibling
features because in our experiments, they were not effective.
3http://www.seas.upenn.edu/˜strctlrn/
MSTParser/MSTParser.html
</footnote>
<figure confidence="0.996700933333333">
beam 16
beam 64
beam 64
&amp;quot;kbest&amp;quot;
&amp;quot;forest&amp;quot;
&amp;quot;non-sp-kbest&amp;quot;
&amp;quot;non-sp-forest&amp;quot;
oracle unlabeled accuracy 0.995
0.99
0.985
0.98
0.975
0.97
0.965
0.96
</figure>
<page confidence="0.979142">
143
</page>
<listItem confidence="0.942630111111111">
• Guide feaures: we define a feature indicating
whether an arc from a child to its parent is
present in the 1-best tree predicted by the first-
stage shift-reduce parser, conjoined with the
POS tags of the parent and child.
• PP-Attachment features: when a parent word is
a preposition, we define tri-gram features with
the parent word and POS tags of grand parent
and the rightmost child.
</listItem>
<subsubsectionHeader confidence="0.911875">
5.2.2 Non-local Features
</subsubsectionHeader>
<bodyText confidence="0.999903666666667">
To define richer features as a non-local factor, we
extend a local reranking algorithm by augmenting
each k-best item with all child vertices of its head
vertex4. Information about all children enables the
reranker to calculate the following features when re-
ducing the head vertex:
</bodyText>
<listItem confidence="0.929132833333333">
• Grand-child features: we define tri-gram fea-
tures with one word and two POS tags of grand
parent, parent, and child.
• Grand-sibling features: we define 4-gram POS
features with POS tags of grand parent, parent,
child and sibling. We also define coordination
features with POS tags of grand parent, parent
and child when the sibling word is a coordinate
conjunction.
• Valency features: we define a feature indicat-
ing the number of children of ahead, conjoined
with each of its word and POS tag.
</listItem>
<bodyText confidence="0.9689085">
When using non-local features, we removed the lo-
cal grand-child features from the model.
</bodyText>
<subsectionHeader confidence="0.918888">
5.3 Oracle for Discriminative Training
</subsectionHeader>
<bodyText confidence="0.999667888888889">
A discriminative reranking model is trained on
packed forests by using their oracle trees as the cor-
rect parse. More accurate oracles are essential to
train a discriminative reranking model well.
While large size forests have much more accurate
oracles than small size forests, large forests have too
many hyperedges to train a discriminative model on
them, as shown in Figure 4. The usual forest rerank-
ing algorithms (Huang, 2008; Hayashi et al., 2011)
</bodyText>
<footnote confidence="0.840311">
4If each item is augmented with richer information, even
features based on the entire subtree can be defined.
</footnote>
<bodyText confidence="0.982496">
remove low quality hyperedges from large forests by
using inside-outside forest pruning.
However, producing large forests and pruning
them is computationally very expensive. Instead, we
propose a simpler method to produce small forests
which have more accurate oracles by forcing the
beam search shift-reduce parser to keep the correct
state in the beam buffer. As a result, the correct tree
will always be encoded in a packed forest.
</bodyText>
<sectionHeader confidence="0.998452" genericHeader="method">
6 Experiments (Discriminative Reranking)
</sectionHeader>
<subsectionHeader confidence="0.990959">
6.1 Experimental Setting
</subsectionHeader>
<bodyText confidence="0.99988672">
Following (Huang, 2008), the training set (WSJ02-
21) is split into 20 folds, and each fold is parsed by
each of the spurious and non-spurious shift-reduce
parsers using beam size 12 with the model trained
on sentences from the remaining 19 folds, dumping
the outputs as packed forests.
The reranker is modeled by either equation (1) or
(4). By our preliminary experiments using develop-
ment data (WSJ22), we modeled the reranker with
equation (1) when training, and with equation (4)
when testing5 (i.e., the scores of the first-stage parser
are not considered during training of the reranking
model). This prevents the discriminative reranking
features from under-training (Sutton et al., 2006;
Hollingshead and Roark, 2008).
A discriminative reranking model is trained on
the packed forests by using the averaged percep-
tron algorithm with 5 iterations. When training non-
local reranking models, we set k-best size of cube-
pruning to 5.
For dumping packed forests for test data, spurious
and non-spurious shift-reduce parsers are trained by
the averaged perceptron algorithm. In all experi-
ments on English data, we fixed beam size to 12 for
training both parsers.
</bodyText>
<subsectionHeader confidence="0.999982">
6.2 Test with Gold POS tags
</subsectionHeader>
<bodyText confidence="0.992796">
We show the comparison of dumped spurious and
non-spurious packed forests for training data in Ta-
ble 4. Both oracle accuracies are 100.0 due to the
5The scaling factor 0 was tuned by minimum error rate
training (MERT) algorithm (Och, 2003) using development
data. The MERT algorithm is suited to tune low-dimensional
parameters. The 0 was set to about 1.2 in case of local rerank-
ing, and to about 1.5 in case of non-local reranking.
</bodyText>
<page confidence="0.986384">
144
</page>
<table confidence="0.999935533333333">
system w/ rerank. sec. (per sent.) UAS (w/o punc.)
sr (12) – 0.011 92.8 (93.3)
(8) w/ local 0.009 + 0.0056 93.03 (93.69)
(12) w/ local 0.011 + 0.0079 93.03 (93.68)
(32) w/ local 0.03 + 0.019 93.07 (93.67)
(64) w/ local 0.06 + 0.039 93.0 (93.61)
(12, k=3) w/ non-local 0.011 + 0.0085 93.17 (93.78)
(64, k=3) w/ non-local 0.06 + 0.046 93.19 (93.78)
non-sp sr (12) – 0.012 92.9 (93.5)
(8) w/ local 0.01 + 0.005 93.05 (93.73)
(12) w/ local 0.012 + 0.0074 93.21 (93.87)
(32) w/ local 0.031 + 0.0184 93.22 (93.84)
(64) w/ local 0.061 + 0.0375 93.23 (93.83)
(12, k=3) w/ non-local 0.012 + 0.0083 93.28 (93.9)
(64, k=3) w/ non-local 0.061 + 0.045 93.39 (93.96)
</table>
<tableCaption confidence="0.938293">
Table 7: Unlabeled accuracy scores and cpu times per sentence (parsing+reranking) when parsing and reranking test
data (WSJ23) with gold POS tags: shift-reduce parser is denoted as sr (beam size, k: k-best size of cube pruning).
</tableCaption>
<figureCaption confidence="0.8467378">
ave. # of hyperedges
ave. # of vertices
ave. % of distinct trees
1-best UAS w/ punc.
oracle UAS w/ punc.
</figureCaption>
<tableCaption confidence="0.53028975">
Table 4: Comparison of spurious (sp.) and non-spurious
(non-sp.) forests: each forest is produced by baseline
and proposed shift-reduce parsers using beam size 12 for
39832 training sentences with gold POS tags.
</tableCaption>
<bodyText confidence="0.999751166666667">
method described in Section 5.3. The 1-best accu-
racy of the non-spurious forests is higher than that
of the spurious forests. As we expected, the results
show that there are many non-unique dependency
trees in the spurious forests. The spurious forests
also get larger than the non-spurious forests.
Table 5 shows how long the training on spurious
and non-spurious forests took on an Opteron 8356
2.3GHz. It is clear from the results that training on
non-spurious forests is more efficient than that on
spurious forests.
Table 6 shows the statistics of spurious and non-
spurious packed forests dumped by shift-reduce
parsers using beam size 12 for test data. The trends
are similar to those for training data shown in Ta-
ble 4. We show the results of the forest rerank-
ing algorithms for test data in Table 7. Each spu-
rious and non-spurious shift-reduce parser produces
</bodyText>
<table confidence="0.5610286">
reranker pre-comp. training
spurious 16.4 min. 34.9 min.
non-spurious 15.5 min. 32.9 min.
spurious non-local 17.3 min. 64.3 min.
non-spurious non-local 16.2 min. 60.3 min.
</table>
<tableCaption confidence="0.782159">
Table 5: Training times on both spurious and non-
spurious packed forests (beam 12): pre-comp. denotes
cpu time for feature extraction and attaching features to
</tableCaption>
<figureCaption confidence="0.674366666666667">
all hyperedges. The non-local models were trained set-
ting k-best size of cube-pruning to 5, and non-local fea-
tures were calculated on-the-fly while training.
</figureCaption>
<bodyText confidence="0.99918275">
packed forests using four beam sizes 8, 12, 32, and
64. The reranking on non-spurious forests achieves
better accuracies and is slightly faster than that on
spurious forests consistently.
</bodyText>
<subsectionHeader confidence="0.999988">
6.3 Test with Automatic POS tags
</subsectionHeader>
<bodyText confidence="0.986992111111111">
To compare the proposed reranking system with
other systems, we evaluate its parsing accuracy on
test data with automatic POS tags. We used the Stan-
ford POS tagger6 with a model trained on sections
02-21 to tag development and test data, and used
10-way jackknifing to tag training data. The tagging
accuracies on training, development, and test data
were 97.1, 97.2, and 97.5.
Table 8 lists the accuracy and parsing speed of
</bodyText>
<footnote confidence="0.7411105">
6http://nlp.stanford.edu/software/
tagger.shtml
</footnote>
<figure confidence="0.997144833333333">
sp. non-sp.
141.9 133.3
199.1 187.6
82.5 100.0
92.5 92.6
100.0 100.0
</figure>
<page confidence="0.950711">
145
</page>
<bodyText confidence="0.6526428">
ave. # of hyperedges
ave. # of vertices
ave. % of distinct trees
1-best UAS w/ punc.
oracle UAS w/ punc.
</bodyText>
<tableCaption confidence="0.775581">
Table 6: Comparison of spurious (sp.) and non-spurious
(non-sp.) forests: each forest is produced by baseline and
proposed shift-reduce parsers using beam size 12 for test
data (WSJ23) with gold POS tags.
</tableCaption>
<table confidence="0.999816555555556">
system tok./sec. UAS w/o punc.
sr (12) 2130 92.5
w/ local (12) 1290 92.8
non-sp sr (12) 1950 92.6
w/ local (12) 1300 92.98
w/ non-local (12, k=1) 1280 93.1
w/ non-local (12, k=3) 1180 93.12
w/ non-local (12, k=12) 1060 93.12
Huang10 sr (8) 782 92.1
Rush12 sr (16) 4780 92.5
Rush12 sr (64) 1280 92.7
Koo10 – 93.04
Rush12 third 20 93.3
Rush12 vine 4400 93.1
H-Zhang12 third 50 92.81
H-Zhang12 (label) 220 93.06
Y-Zhang11 (64, label) 680 92.9
Bohnet12 (80, label) 120 93.39
</table>
<tableCaption confidence="0.983158">
Table 8: Comparison with other systems: the results were
evaluated on testing data (WSJ23) with automatic POS
tags: label means labeled dependency parsing and the cpu
times of our systems were taken on Intel Core i7 2.8GHz.
</tableCaption>
<bodyText confidence="0.9998875">
our proposed systems together with results from re-
lated work. The parsing times are reported in to-
kens/second for comparison. Note that, however,
the difference of the parsing time does not represent
the efficiency of the algorithm directly because each
system was implemented in different programming
language and the times were measured on different
environments.
The accuracy of local reranking on non-spurious
forests is the best among unlabeled shift-reduce
parsers, but slightly behind the third-order graph-
based systems (Koo and Collins, 2010; Zhang and
McDonald, 2012; Rush and Petrov, 2012). It is
likely that the difference comes from the fact that
our local reranking model can define only some of
the grand-child related features.
</bodyText>
<table confidence="0.998020538461538">
w/ guide. w/o guide.
UAS 92.98 92.86
feature
Linear (first) 89,330 89,215
CorePos (first) 1,047,948 1,053,796
TwoObs (first) 1,303,911 1,325,990
Sibling (second) 290,291 292,849
Trip (second) 19,333 19,267
Grand-child 16,975 16,951
Guide 4,934 –
Tri-sibling 277,770 279,720
PP-Attachment 32,695 32,993
total 3,083,187 3,110,781
</table>
<tableCaption confidence="0.9888365">
Table 9: Accuracy and the number of non-zero weighted
features of the local reranking models with and without
guide features: the first- and second-order features are
named for MSTParser.
</tableCaption>
<bodyText confidence="0.999521571428571">
To define all grand-child features and other non-
local features, we also experimented with the non-
local reranking algorithm on non-spurious packed
forests. It achieved almost the same accuracy as the
previous third-order graph-based algorithms. More-
over, the computational overhead is very small when
setting k-best size of cube-pruning small.
</bodyText>
<subsectionHeader confidence="0.999069">
6.4 Analysis
</subsectionHeader>
<bodyText confidence="0.999948818181818">
One advantage of our reranking approach is that
guide features can be defined as in stacked parsing.
To analyze the effect of the guide features on parsing
accuracy, we remove the guide features from base-
line reranking models with and without non-local
features used in Section 6.3. The results are shown
in Table 9 and 10. The parsing accuracies of the
baseline reranking models are better than those of
the models without guide features though the num-
ber of guide features is not large. Additionally, each
model with guide features is smaller than that with-
out guide features. This indicates that stacking has a
good effect on training the models.
To further investigate the effects of guide features,
we tried to define unlabeled versions of the second-
order guide features used in (Martins et al., 2008;
McClosky et al., 2012). However, these features did
not produce good results, and investigation to find
the cause is an important future work.
We also examined parsing errors in more de-
tail. Table 11 shows root and sentence complete
rates of three systems, the non-spurious shift-reduce
</bodyText>
<figure confidence="0.992657166666667">
sp. non-sp.
127.0 119.1
178.6 168.5
82.4 100.0
92.8 92.9
97.0 97.0
</figure>
<page confidence="0.996135">
146
</page>
<tableCaption confidence="0.7705985">
Table 10: Accuracy and the number of non-zero weighted
features of the non-local reranking models with and with-
out guide features: the first- and second-order features are
named for MSTParser.
</tableCaption>
<table confidence="0.996868571428572">
w/ guide. w/o guide.
UAS 93.12 93.04
feature
Linear (first) 88,634 88,934
CorePos (first) 1,035,897 1,045,242
TwoObs (first) 1,274,834 1,301,103
Sibling (second) 284,341 288,796
Trip (second) 19,201 19,219
Guide 4,916 –
Tri-sibling 272,418 276,025
PP-Attachment 32,085 32,577
Grand-child 718,064 730,663
Grand-sibling 72,865 73,103
Valency 49,262 49,677
total 3,852,517 3,905,339
non-sp sr local non-local
head correct
recall
precision
F-measure
comp.
</table>
<tableCaption confidence="0.988828333333333">
Table 12: Head correct rate, recall, precision, F-measure,
and complete rate of coordination strutures: these are
measured on test data (WSJ23).
</tableCaption>
<figure confidence="0.4017375">
system recall precision F-measure
non-sp sr
92.45
non-local
</figure>
<tableCaption confidence="0.98511">
Table 13: Recall, precision, and F-measure of grand-child
structures whose grand parent is an artificial root symbol:
these are measured on test data (WSJ23).
</tableCaption>
<table confidence="0.841476294117647">
87.73 88.97 88.83
82.38 84.35 84.11
83.07 84.57 83.98
82.72 84.46
62.92 64.52
84.05
65.18
local
91.58 92.5
91.96 92.95
92.44 93.07
92.04
92.75
system UAS root comp.
non-sp sr
local
non-local
</table>
<tableCaption confidence="0.539324333333333">
Table 11: Unlabeled accuracy, root correct rate, and sen-
tence complete rate: these scores are measured on test
data (WSJ23) without punctuations.
</tableCaption>
<bodyText confidence="0.99997478125">
parser, local reranking, and non-local reranking.
The two reranking systems outperform the shift-
reduce parser significantly, and the non-local rerank-
ing system is the best among them.
Part of the difference between the shift-reduce
parser and reranking systems comes from the correc-
tion of coordination errors. Table 12 shows the head
correct rate, recall, precision, F-measure and com-
plete rate of coordination structures, by which we
mean the head and siblings of a token whose POS
tag is CC. The head correct rate denotes how cor-
rect a head of the CC token is. The recall, precision,
F-measure are measured by counting arcs between
the head and siblings. When the head of the CC to-
ken is incorrect, all arcs of the coordination structure
are counted as incorrect. Therefore, the recall, preci-
sion, F-measure are greatly affected by the head cor-
rect rate, and though the complete rate of non-local
reranking is higher than that of local reranking, the
results of the first three measures are lower.
We assume that the improvements of non-local
reranking over the others can be mainly attributed
to the better prediction of the structures around the
sentence root because most of the non-local features
are useful for predicting these structures. Table 13
shows the recall, precision and F-measure of grand-
child structures whose grand parent is a sentence
root symbol $. The results support the above as-
sumption. The root correct rate directly influences
on prediction of the overall structures of a sentence,
and it is likely that the reduction of root prediction
errors brings better results.
</bodyText>
<subsectionHeader confidence="0.997587">
6.5 Experiments on Chinese
</subsectionHeader>
<bodyText confidence="0.999431928571429">
We also experiment on the Penn Chinese Treebank
(CTB5). Following Huang and Sagae (2010), we
split it into training (secs 001-815 and 1001-1136),
development (secs 886-931 and 1148-1151), and
test (secs 816-885 and 1137-1147) sets, and use the
head rules of Zhang and Clark (2008). The training
set is split into 10 folds to dump packed forests for
training of reranking models.
We set the beam size of both spurious and non-
spurious parsers to 12, and the number of perceptron
training iterations to 25 for the parsers and to 8 for
both rerankers. Table 14 shows the results for the
test sets. As we expected, reranking on non-spurious
forests outperforms that on spurious forests.
</bodyText>
<table confidence="0.962296333333333">
92.6 95.8 45.6
92.98 96.1 48.1
93.12 96.3 48.2
147
system UAS root comp.
sr (12) 85.3 78.6 33.4
w/ non-local (12, k=3) 85.8 79.4 34.2
non-sp sr (12) 85.3 78.4 33.7
w/ non-local (12, k=3) 85.9 79.6 34.3
</table>
<tableCaption confidence="0.9996825">
Table 14: Results on Chinese Treebank data (CTB5):
evaluations are performed without punctuations.
</tableCaption>
<sectionHeader confidence="0.999886" genericHeader="method">
7 Related Works
</sectionHeader>
<subsectionHeader confidence="0.998667">
7.1 How to Handle Spurious Ambiguity
</subsectionHeader>
<bodyText confidence="0.999980263157895">
The graph-based approach employs Eisner and Satta
(1999)’s algorithm where spurious ambiguities are
eliminated by the notion of split head automaton
grammars (Alshawi, 1996).
However, the arc-standard transition-based parser
has the spurious ambiguity problem. Cohen et al.
(2012) proposed a method to eliminate the spurious
ambiguity of shift-reduce transition systems. Their
method covers existing systems such as the arc-
standard and non-projective transition-based parsers
(Attardi, 2006). Our system copes only with the pro-
jective case, but is simpler than theirs and we show
its efficacy empirically through some experiments.
The arc-eager shift-reduce parser also has a spuri-
ous ambiguity problem. Goldberg and Nivre (2012)
addressed this problem by not only training with a
canonical transition sequence but also with alternate
optimal transitions that are calculated dynamically
for a current state.
</bodyText>
<subsectionHeader confidence="0.994183">
7.2 Methods to Improve Dependency Parsing
</subsectionHeader>
<bodyText confidence="0.999988545454545">
Higher-order features like third-order dependency
relations are essential to improve dependency pars-
ing accuracy (Koo and Collins, 2010; Rush and
Petrov, 2012; Zhang and McDonald, 2012). A
reranking approach is one effective solution to intro-
duce rich features to a parser model in the context of
constituency parsing (Charniak and Johnson, 2005;
Huang, 2008).
Hall (2007) applied a k-best maximum spanning
tree algorithm to non-projective dependency analy-
sis, and showed that k-best discriminative rerank-
ing improves parsing accuracy in several languages.
Sangati et al. (2009) proposed a k-best dependency
reranking algorithm using a third-order generative
model, and Hayashi et al. (2011) extended it to a
forest algorithm. Though forest reranking requires
some approximations such as cube-pruning to inte-
grate non-local features, it can explore larger search
space than k-best reranking.
The stacking approach (Nivre and McDonald,
2008; Martins et al., 2008) uses the output of one
dependency parser to provide guide features for an-
other. Stacking improves the parsing accuracy of
second stage parsers on various language datasets.
The joint graph-based and transition-based approach
(Zhang and Clark, 2008; Bohnet and Kuhn, 2012)
uses an arc-eager shift-reduce parser with a joint
graph-based and transition-based model. Though
it improves parsing accuracy significantly, the large
beam size of the shift-reduce parser harms its effi-
ciency. Sagae and Lavie (2006) showed that com-
bining the outputs of graph-based and transition-
based parsers can improve parsing accuracies.
</bodyText>
<sectionHeader confidence="0.999263" genericHeader="conclusions">
8 Conclusion
</sectionHeader>
<bodyText confidence="0.99997952173913">
We have presented a discriminative forest reranking
algorithm for dependency parsing. This can be seen
as a kind of joint transition-based and graph-based
approach because the first-stage parser is a shift-
reduce parser and the second-stage reranker uses a
graph-based model.
Additionally, we have proposed a dynamic pro-
gramming arc-standard transition-based dependency
parser without spurious ambiguity, along with a
heuristic that encodes the correct tree in the output
packed forest for reranker training, and shown that
forest reranking works well on packed forests pro-
duced by the proposed parser.
To improve the accuracy of reranking, we will en-
gage in feature engineering. We need to further in-
vestigate effective higher-order guide and non-local
features. It also seems promising to extend the un-
labeled reranker to a labeled one because labeled in-
formation often improves unlabeled accuracy.
In this paper, we adopt a reranking approach, but
a rescoring approach is more promising to improve
efficiency because it does not have the overhead of
dumping packed forests.
</bodyText>
<sectionHeader confidence="0.998812" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.999717">
We would like to thank the anonymous reviewers
for their valuable comments. This work was partly
</bodyText>
<page confidence="0.993877">
148
</page>
<bodyText confidence="0.517219666666667">
supported by Grant-in-Aid for Japan Society for the
Promotion of Science (JSPS) Research Fellowship
for Young Scientists.
</bodyText>
<sectionHeader confidence="0.984565" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999621811881188">
H. Alshawi. 1996. Head automata for speech translation.
In Proc. the ICSLP.
G. Attardi. 2006. Experiments with a multilanguage
non-projective dependency parser. In Proc. of the 10th
Conference on Natural Language Learning, pages
166–170.
B. Bohnet and J. Kuhn. 2012. The best of bothworlds –
a graph-based completion model for transition-based
parsers. In Proceedings of the 13th Conference of
the European Chapter of the Association for Compu-
tational Linguistics, pages 77–87.
E. Charniak and M. Johnson. 2005. Coarse-to-fine n-
best parsing and maxent discriminative reranking. In
Proceedings of the 43rd Annual Meeting of the Associ-
ation for Computational Linguistics, pages 173–180.
S. B. Cohen, C. G´omez-Rodr´ıguez, and G. Satta. 2012.
Elimination of spurious ambiguity in transition-based
dependency parsing. Technical report.
M. Collins and B. Roark. 2004. Incremental parsing with
the perceptron algorithm. In Proceedings of the 42nd
Annual Meeting of the Association for Computational
Linguistics (ACL’04).
J. M. Eisner and G. Satta. 1999. Efficient parsing for
bilexical context-free grammars and head automaton
grammars. In Proceedings of the 37th Annual Meet-
ing of the Association for Computational Linguistics,
pages 457–464.
J. Eisner. 1997. Bilexical grammars and a cubic-time
probabilistic parser. In Proceedings of the 5th Inter-
national Workshop on Parsing Technologies (IWPT),
pages 54–65.
Y. Goldberg and J. Nivre. 2012. A dynamic oracle for
arc-eager dependency parsing. In Proceedings of the
24rd International Conference on Computational Lin-
guistics (Coling 2012).
K. Hall. 2007. K-best spanning tree parsing. In Proceed-
ings of the 45th Annual Meeting of the Association of
Computational Linguistics, pages 392–399.
K. Hayashi, T. Watanabe, M. Asahara, and Y. Mat-
sumoto. 2011. The third-order variational reranking
on packed-shared dependency forests. In Proceedings
of the 2011 Conference on Empirical Methods in Nat-
ural Language Processing, pages 1479–1488.
K. Hayashi, T. Watanabe, M. Asahara, and Y. Mat-
sumoto. 2012. Head-driven transition-based parsing
with top-down prediction. In Proceedings of the 50th
Annual Meeting of the Association for Computational
Linguistics, pages 657–665.
K. Hollingshead and B. Roark. 2008. Reranking with
baseline system scores and ranks as features. In
CSLU-08-001, Center for Spoken Language Under-
standing, Oregon Health and Science University.
L. Huang and D. Chiang. 2007. Forest rescoring: Faster
decoding with integrated language models. In Pro-
ceedings of the 45th Annual Meeting of the Association
of Computational Linguistics, pages 144–151.
L. Huang and K. Sagae. 2010. Dynamic programming
for linear-time incremental parsing. In Proceedings of
the 48th Annual Meeting of the Association for Com-
putational Linguistics (ACL’10), pages 1077–1086.
L. Huang, S. Fayong, and Y. Guo. 2012. Structured per-
ceptron with inexact search. In Proceedings of the
2012 Conference of the North American Chapter of
the Association for Computational Linguistics: Hu-
man Language Technologies, pages 142–151.
L. Huang. 2008. Forest reranking: Discriminative pars-
ing with non-local features. In Proceedings of the 46th
Annual Meeting of the Association for Computational
Linguistics, pages 586–594.
D. Klein and C. D. Manning. 2001. Parsing and hyper-
graphs. In Proceedings of the 7th International Work-
shop on Parsing Technologies.
T. Koo and M. Collins. 2010. Efficient third-order de-
pendency parsers. In Proceedings of the 48th Annual
Meeting of the Association for Computational Linguis-
tics (ACL’10), pages 1–11.
M. Kuhlmann, C. G´omez-Rodr´ıguez, and G. Satta. 2011.
Dynamic programming algorithms for transition-
based dependency parsers. In Proceedings of the 49th
Annual Meeting of the Association for Computational
Linguistics, pages 673–682.
Andr´e F. T. Martins, D. Das, N. A. Smith, and E. P. Xing.
2008. Stacking dependency parsers. In Proceedings of
the 2008 Conference on Empirical Methods in Natural
Language Processing, pages 157–166.
D. McClosky, W. Che, M. Recasens, M. Wang, R. Socher,
and C. D. Manning. 2012. Stanfords system for pars-
ing the english web. In Proceedings of First Work-
shop on Syntactic Analysis of Non-Canonical Lan-
guage (SANCL) at NAACL 2012.
R. McDonald, K. Crammer, and F. Pereira. 2005. On-
line large-margin training of dependency parsers. In
Proceedings of the 43rd Annual Meeting of the Asso-
ciation for Computational Linguistics (ACL’05), pages
91–98.
J. Nivre and R. McDonald. 2008. Integrating graph-
based and transition-based dependency parsers. In
Proceedings of ACL-08: HLT, pages 950–958.
J. Nivre. 2008. Algorithms for deterministic incremen-
tal dependency parsing. Computational Linguistics,
34:513–553.
</reference>
<page confidence="0.989559">
149
</page>
<reference confidence="0.999460975609756">
F. J. Och. 2003. Minimum error rate training in statisti-
cal machine translation. In Proc. the 41st ACL, pages
160–167.
A. Rush and S. Petrov. 2012. Vine pruning for effi-
cient multi-pass dependency parsing. In Proceedings
of the 2012 Conference of the North American Chap-
ter of the Association for Computational Linguistics:
Human Language Technologies, pages 498–507.
K. Sagae and A. Lavie. 2006. Parser combination by
reparsing. In Proc. HLT, pages 129–132.
F. Sangati, W. Zuidema, and R. Bod. 2009. A generative
re-ranking model for dependency parsing. In Proceed-
ings of the 11th International Conference on Parsing
Technologies (IWPT’09), pages 238–241.
S. M. Shieber, Y. Schabes, and F. C. N. Pereira. 1995.
Principles and implementation of deductive parsing. J.
Log. Program., 24(1&amp;2):3–36.
C. Sutton, M. Sindelar, and A. McCallum. 2006. Reduc-
ing weight undertraining in structured discriminative
learning. In Conference on Human Language Tech-
nology and North American Association for Computa-
tional Linguistics (HLT-NAACL).
H. Yamada and Y. Matsumoto. 2003. Statistical depen-
dency analysis with support vector machines. In Pro-
ceedings of the 10th International Conference on Pars-
ing Technologies (IWPT’03), pages 195–206.
Y. Zhang and S. Clark. 2008. A tale of two parsers: In-
vestigating and combining graph-based and transition-
based dependency parsing using beam-search. In Pro-
ceedings of the 2008 Conference on Empirical Meth-
ods in Natural Language Processing, pages 562–571.
H. Zhang and R. McDonald. 2012. Generalized higher-
order dependency parsing with cube pruning. In Pro-
ceedings of the 2012 Joint Conference on Empirical
Methods in Natural Language Processing and Compu-
tational Natural Language Learning, pages 320–331.
Y. Zhang and J. Nivre. 2011. Transition-based depen-
dency parsing with rich non-local features. In Pro-
ceedings of the 49th Annual Meeting of the Associa-
tion for Computational Linguistics: Human Language
Technologies, pages 188–193.
</reference>
<page confidence="0.998313">
150
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.655742">
<title confidence="0.999535">Efficient Stacked Dependency Parsing by Forest Reranking</title>
<author confidence="0.992822">Katsuhiko Hayashi</author>
<author confidence="0.992822">Shuhei Kondo</author>
<author confidence="0.992822">Yuji</author>
<affiliation confidence="0.997444">Graduate School of Information Science Nara Institute of Science and</affiliation>
<address confidence="0.911723">8916-5, Takayama, Ikoma, Nara 630-0192,</address>
<abstract confidence="0.997984125">This paper proposes a discriminative forest reranking algorithm for dependency parsing that can be seen as a form of efficient stacked parsing. A dynamic programming shift-reduce parser produces a packed derivation forest which is then scored by a discriminative reranker, using the 1-best tree output by the shift-reduce parser as guide features in addition to third-order graph-based features. To improve efficiency and accuracy, this paper also proposes a novel shift-reduce parser that eliminates the spurious ambiguity of arcstandard transition systems. Testing on the English Penn Treebank data, forest reranking gave a state-of-the-art unlabeled dependency</abstract>
<intro confidence="0.744782">of</intro>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>H Alshawi</author>
</authors>
<title>Head automata for speech translation.</title>
<date>1996</date>
<booktitle>In Proc. the ICSLP.</booktitle>
<contexts>
<context position="31366" citStr="Alshawi, 1996" startWordPosition="5233" endWordPosition="5234">s we expected, reranking on non-spurious forests outperforms that on spurious forests. 92.6 95.8 45.6 92.98 96.1 48.1 93.12 96.3 48.2 147 system UAS root comp. sr (12) 85.3 78.6 33.4 w/ non-local (12, k=3) 85.8 79.4 34.2 non-sp sr (12) 85.3 78.4 33.7 w/ non-local (12, k=3) 85.9 79.6 34.3 Table 14: Results on Chinese Treebank data (CTB5): evaluations are performed without punctuations. 7 Related Works 7.1 How to Handle Spurious Ambiguity The graph-based approach employs Eisner and Satta (1999)’s algorithm where spurious ambiguities are eliminated by the notion of split head automaton grammars (Alshawi, 1996). However, the arc-standard transition-based parser has the spurious ambiguity problem. Cohen et al. (2012) proposed a method to eliminate the spurious ambiguity of shift-reduce transition systems. Their method covers existing systems such as the arcstandard and non-projective transition-based parsers (Attardi, 2006). Our system copes only with the projective case, but is simpler than theirs and we show its efficacy empirically through some experiments. The arc-eager shift-reduce parser also has a spurious ambiguity problem. Goldberg and Nivre (2012) addressed this problem by not only training</context>
</contexts>
<marker>Alshawi, 1996</marker>
<rawString>H. Alshawi. 1996. Head automata for speech translation. In Proc. the ICSLP.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Attardi</author>
</authors>
<title>Experiments with a multilanguage non-projective dependency parser.</title>
<date>2006</date>
<booktitle>In Proc. of the 10th Conference on Natural Language Learning,</booktitle>
<pages>166--170</pages>
<contexts>
<context position="31684" citStr="Attardi, 2006" startWordPosition="5275" endWordPosition="5276">Treebank data (CTB5): evaluations are performed without punctuations. 7 Related Works 7.1 How to Handle Spurious Ambiguity The graph-based approach employs Eisner and Satta (1999)’s algorithm where spurious ambiguities are eliminated by the notion of split head automaton grammars (Alshawi, 1996). However, the arc-standard transition-based parser has the spurious ambiguity problem. Cohen et al. (2012) proposed a method to eliminate the spurious ambiguity of shift-reduce transition systems. Their method covers existing systems such as the arcstandard and non-projective transition-based parsers (Attardi, 2006). Our system copes only with the projective case, but is simpler than theirs and we show its efficacy empirically through some experiments. The arc-eager shift-reduce parser also has a spurious ambiguity problem. Goldberg and Nivre (2012) addressed this problem by not only training with a canonical transition sequence but also with alternate optimal transitions that are calculated dynamically for a current state. 7.2 Methods to Improve Dependency Parsing Higher-order features like third-order dependency relations are essential to improve dependency parsing accuracy (Koo and Collins, 2010; Rush</context>
</contexts>
<marker>Attardi, 2006</marker>
<rawString>G. Attardi. 2006. Experiments with a multilanguage non-projective dependency parser. In Proc. of the 10th Conference on Natural Language Learning, pages 166–170.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Bohnet</author>
<author>J Kuhn</author>
</authors>
<title>The best of bothworlds – a graph-based completion model for transition-based parsers.</title>
<date>2012</date>
<booktitle>In Proceedings of the 13th Conference of the European Chapter of the Association for Computational Linguistics,</booktitle>
<pages>77--87</pages>
<contexts>
<context position="4312" citStr="Bohnet and Kuhn, 2012" startWordPosition="698" endWordPosition="701">ed dependency parsing system with dynamic programming: means “take anything”. a↷b denotes that a tree b is attached to a tree a. shift : state p � � 1 : (i, j, s′d|s′d−1 |... |s′ 1|s′0) : π′ state q � � 1 ℓ : (j, k, sd|sd−1 |... |s1|s0) : π s′ 0.h.w =� w0 n p E π ℓ + 1 : (i, k, s′ d|s′ d−1 |. . . |s′ 1|s′ 0↶s0) : π′ state p � � 1 : (i,j, s′d|s′d−1 |... |s′1|s′0) : π′ state q � � 1 ℓ : (j, k, sd|sd−1 |... |s1|s0) : π + 1 : i k s′ s′ _ s&apos; s′ ↷s π′ p E (&gt; , dI d-1 I lI 0 0) rated in standard graph-based models. • In contrast to joint transition-based/graphbased approaches (Zhang and Clark, 2008; Bohnet and Kuhn, 2012) which require a large beam size and make dynamic programming impractical, our two-stage approach can integrate both models with little loss of efficiency. In addition, the elimination of spurious ambiguity from the arc-standard shift-reduce parser improves the efficiency and accuracy of our approach. 2 Arc-Standard Shift-Reduce Parsing We use a beam search shift-reduce parser with dynamic programming as our baseline system. Figure 1 shows it as a deductive system (Shieber et al., 1995). A state is defined as the following: ℓ : (i, j, sd|sd−1 |... |s1|s0) : π where ℓ is the step size, [i, j] i</context>
<context position="33377" citStr="Bohnet and Kuhn, 2012" startWordPosition="5525" endWordPosition="5528">nking algorithm using a third-order generative model, and Hayashi et al. (2011) extended it to a forest algorithm. Though forest reranking requires some approximations such as cube-pruning to integrate non-local features, it can explore larger search space than k-best reranking. The stacking approach (Nivre and McDonald, 2008; Martins et al., 2008) uses the output of one dependency parser to provide guide features for another. Stacking improves the parsing accuracy of second stage parsers on various language datasets. The joint graph-based and transition-based approach (Zhang and Clark, 2008; Bohnet and Kuhn, 2012) uses an arc-eager shift-reduce parser with a joint graph-based and transition-based model. Though it improves parsing accuracy significantly, the large beam size of the shift-reduce parser harms its efficiency. Sagae and Lavie (2006) showed that combining the outputs of graph-based and transitionbased parsers can improve parsing accuracies. 8 Conclusion We have presented a discriminative forest reranking algorithm for dependency parsing. This can be seen as a kind of joint transition-based and graph-based approach because the first-stage parser is a shiftreduce parser and the second-stage rer</context>
</contexts>
<marker>Bohnet, Kuhn, 2012</marker>
<rawString>B. Bohnet and J. Kuhn. 2012. The best of bothworlds – a graph-based completion model for transition-based parsers. In Proceedings of the 13th Conference of the European Chapter of the Association for Computational Linguistics, pages 77–87.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Charniak</author>
<author>M Johnson</author>
</authors>
<title>Coarse-to-fine nbest parsing and maxent discriminative reranking.</title>
<date>2005</date>
<booktitle>In Proceedings of the 43rd Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>173--180</pages>
<contexts>
<context position="32488" citStr="Charniak and Johnson, 2005" startWordPosition="5395" endWordPosition="5398"> has a spurious ambiguity problem. Goldberg and Nivre (2012) addressed this problem by not only training with a canonical transition sequence but also with alternate optimal transitions that are calculated dynamically for a current state. 7.2 Methods to Improve Dependency Parsing Higher-order features like third-order dependency relations are essential to improve dependency parsing accuracy (Koo and Collins, 2010; Rush and Petrov, 2012; Zhang and McDonald, 2012). A reranking approach is one effective solution to introduce rich features to a parser model in the context of constituency parsing (Charniak and Johnson, 2005; Huang, 2008). Hall (2007) applied a k-best maximum spanning tree algorithm to non-projective dependency analysis, and showed that k-best discriminative reranking improves parsing accuracy in several languages. Sangati et al. (2009) proposed a k-best dependency reranking algorithm using a third-order generative model, and Hayashi et al. (2011) extended it to a forest algorithm. Though forest reranking requires some approximations such as cube-pruning to integrate non-local features, it can explore larger search space than k-best reranking. The stacking approach (Nivre and McDonald, 2008; Mart</context>
</contexts>
<marker>Charniak, Johnson, 2005</marker>
<rawString>E. Charniak and M. Johnson. 2005. Coarse-to-fine nbest parsing and maxent discriminative reranking. In Proceedings of the 43rd Annual Meeting of the Association for Computational Linguistics, pages 173–180.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S B Cohen</author>
<author>C G´omez-Rodr´ıguez</author>
<author>G Satta</author>
</authors>
<title>Elimination of spurious ambiguity in transition-based dependency parsing.</title>
<date>2012</date>
<tech>Technical report.</tech>
<marker>Cohen, G´omez-Rodr´ıguez, Satta, 2012</marker>
<rawString>S. B. Cohen, C. G´omez-Rodr´ıguez, and G. Satta. 2012. Elimination of spurious ambiguity in transition-based dependency parsing. Technical report.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Collins</author>
<author>B Roark</author>
</authors>
<title>Incremental parsing with the perceptron algorithm.</title>
<date>2004</date>
<booktitle>In Proceedings of the 42nd Annual Meeting of the Association for Computational Linguistics (ACL’04).</booktitle>
<contexts>
<context position="11366" citStr="Collins and Roark, 2004" startWordPosition="1992" endWordPosition="1995">ond per sentence) for parsing development (WSJ22) and test (WSJ23) data with spurious shift-reduce and proposed shift-reduce parser (non-sp.) using several beam sizes. shift : scan : state p z } |{ :(i, j, s′d|s′d−1 |... |s′ 0|s′0) : π′ state q z } |{ ℓ : (j, k, sd|sd−1 |... |s1|s∗0) : π s′ 0.h.w =� w0 n p E π ℓ + 1 : (i, k, s′ d|s′ d−1 |... |s′ 1|s′ 0↶s∗ 0) : π′ state p z } |{ : (i,j, s′d|s′d−1 |... |s′1|s′0) : π′ state q z } |{ ℓ : (j, k, sd|sd−1 |... |s1|s0) : π p E π ℓ + 1 : (i, k, s′ d|s′ d−1 |. . . |s′ 1|s′ 0↷s0) : π′ We used an early update version of the averaged perceptron algorithm (Collins and Roark, 2004; Huang et al., 2012) to train two shift-reduce dependency parsers with beam size of 12. Table 2 shows experimental results of parsing the development and test datasets with each of the spurious and non-spurious shift-reduce parsers using several beam sizes. Parsing accuracies were evaluated by unlabeled accuracy scores (UAS) with and without punctuations. The parsing times were measured on an Intel Core i7 2.8GHz. The average cpu time (per sentence) includes that of dumping packed forests. This result indicates that the non-spurious parser achieves better accuracies than the spurious beam siz</context>
</contexts>
<marker>Collins, Roark, 2004</marker>
<rawString>M. Collins and B. Roark. 2004. Incremental parsing with the perceptron algorithm. In Proceedings of the 42nd Annual Meeting of the Association for Computational Linguistics (ACL’04).</rawString>
</citation>
<citation valid="true">
<authors>
<author>J M Eisner</author>
<author>G Satta</author>
</authors>
<title>Efficient parsing for bilexical context-free grammars and head automaton grammars.</title>
<date>1999</date>
<booktitle>In Proceedings of the 37th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>457--464</pages>
<contexts>
<context position="31249" citStr="Eisner and Satta (1999)" startWordPosition="5215" endWordPosition="5218">ceptron training iterations to 25 for the parsers and to 8 for both rerankers. Table 14 shows the results for the test sets. As we expected, reranking on non-spurious forests outperforms that on spurious forests. 92.6 95.8 45.6 92.98 96.1 48.1 93.12 96.3 48.2 147 system UAS root comp. sr (12) 85.3 78.6 33.4 w/ non-local (12, k=3) 85.8 79.4 34.2 non-sp sr (12) 85.3 78.4 33.7 w/ non-local (12, k=3) 85.9 79.6 34.3 Table 14: Results on Chinese Treebank data (CTB5): evaluations are performed without punctuations. 7 Related Works 7.1 How to Handle Spurious Ambiguity The graph-based approach employs Eisner and Satta (1999)’s algorithm where spurious ambiguities are eliminated by the notion of split head automaton grammars (Alshawi, 1996). However, the arc-standard transition-based parser has the spurious ambiguity problem. Cohen et al. (2012) proposed a method to eliminate the spurious ambiguity of shift-reduce transition systems. Their method covers existing systems such as the arcstandard and non-projective transition-based parsers (Attardi, 2006). Our system copes only with the projective case, but is simpler than theirs and we show its efficacy empirically through some experiments. The arc-eager shift-reduc</context>
</contexts>
<marker>Eisner, Satta, 1999</marker>
<rawString>J. M. Eisner and G. Satta. 1999. Efficient parsing for bilexical context-free grammars and head automaton grammars. In Proceedings of the 37th Annual Meeting of the Association for Computational Linguistics, pages 457–464.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Eisner</author>
</authors>
<title>Bilexical grammars and a cubic-time probabilistic parser.</title>
<date>1997</date>
<booktitle>In Proceedings of the 5th International Workshop on Parsing Technologies (IWPT),</booktitle>
<pages>54--65</pages>
<contexts>
<context position="8008" citStr="Eisner (1997)" startWordPosition="1365" endWordPosition="1366"> encoded into the vertices. In the example, information about the topmost stack element is attached to the corresponding vertex marked with a non-terminal symbol X. Weights are omitted in the example. In practice, we attach each reduction weight to the corresponding hyperedge, and add the shift weight to the reduction weight when a shifted word is reduced. 3 Arc-Standard Shift-Reduce Parsing without Spurious Ambiguity One solution to remove spurious ambiguity in the arc-standard transition system is to give priority to the construction of left arcs over that of right arcs (or vice versa) like Eisner (1997). For example, an Earley dependency parser (Hayashi et al., 2012) attaches all left dependents to a word before right dependents. The parser uses a scan action to stop the construction of left arcs. We apply this idea to the arc-standard transition system and show the resulting transition system in Figure 3. We introduce the * symbol to indicate that the root node of the topmost element on the stack has not been scanned yet. The shift and reduce↷ actions can be used only when the root of the topmost element on the stack has already been scanned, and all left arcs are always attached to the hea</context>
</contexts>
<marker>Eisner, 1997</marker>
<rawString>J. Eisner. 1997. Bilexical grammars and a cubic-time probabilistic parser. In Proceedings of the 5th International Workshop on Parsing Technologies (IWPT), pages 54–65.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Goldberg</author>
<author>J Nivre</author>
</authors>
<title>A dynamic oracle for arc-eager dependency parsing.</title>
<date>2012</date>
<booktitle>In Proceedings of the 24rd International Conference on Computational Linguistics (Coling</booktitle>
<contexts>
<context position="31922" citStr="Goldberg and Nivre (2012)" startWordPosition="5311" endWordPosition="5314">inated by the notion of split head automaton grammars (Alshawi, 1996). However, the arc-standard transition-based parser has the spurious ambiguity problem. Cohen et al. (2012) proposed a method to eliminate the spurious ambiguity of shift-reduce transition systems. Their method covers existing systems such as the arcstandard and non-projective transition-based parsers (Attardi, 2006). Our system copes only with the projective case, but is simpler than theirs and we show its efficacy empirically through some experiments. The arc-eager shift-reduce parser also has a spurious ambiguity problem. Goldberg and Nivre (2012) addressed this problem by not only training with a canonical transition sequence but also with alternate optimal transitions that are calculated dynamically for a current state. 7.2 Methods to Improve Dependency Parsing Higher-order features like third-order dependency relations are essential to improve dependency parsing accuracy (Koo and Collins, 2010; Rush and Petrov, 2012; Zhang and McDonald, 2012). A reranking approach is one effective solution to introduce rich features to a parser model in the context of constituency parsing (Charniak and Johnson, 2005; Huang, 2008). Hall (2007) applie</context>
</contexts>
<marker>Goldberg, Nivre, 2012</marker>
<rawString>Y. Goldberg and J. Nivre. 2012. A dynamic oracle for arc-eager dependency parsing. In Proceedings of the 24rd International Conference on Computational Linguistics (Coling 2012).</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Hall</author>
</authors>
<title>K-best spanning tree parsing.</title>
<date>2007</date>
<booktitle>In Proceedings of the 45th Annual Meeting of the Association of Computational Linguistics,</booktitle>
<pages>392--399</pages>
<contexts>
<context position="32515" citStr="Hall (2007)" startWordPosition="5401" endWordPosition="5402">g and Nivre (2012) addressed this problem by not only training with a canonical transition sequence but also with alternate optimal transitions that are calculated dynamically for a current state. 7.2 Methods to Improve Dependency Parsing Higher-order features like third-order dependency relations are essential to improve dependency parsing accuracy (Koo and Collins, 2010; Rush and Petrov, 2012; Zhang and McDonald, 2012). A reranking approach is one effective solution to introduce rich features to a parser model in the context of constituency parsing (Charniak and Johnson, 2005; Huang, 2008). Hall (2007) applied a k-best maximum spanning tree algorithm to non-projective dependency analysis, and showed that k-best discriminative reranking improves parsing accuracy in several languages. Sangati et al. (2009) proposed a k-best dependency reranking algorithm using a third-order generative model, and Hayashi et al. (2011) extended it to a forest algorithm. Though forest reranking requires some approximations such as cube-pruning to integrate non-local features, it can explore larger search space than k-best reranking. The stacking approach (Nivre and McDonald, 2008; Martins et al., 2008) uses the </context>
</contexts>
<marker>Hall, 2007</marker>
<rawString>K. Hall. 2007. K-best spanning tree parsing. In Proceedings of the 45th Annual Meeting of the Association of Computational Linguistics, pages 392–399.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Hayashi</author>
<author>T Watanabe</author>
<author>M Asahara</author>
<author>Y Matsumoto</author>
</authors>
<title>The third-order variational reranking on packed-shared dependency forests.</title>
<date>2011</date>
<booktitle>In Proceedings of the 2011 Conference on Empirical Methods in Natural Language Processing,</booktitle>
<pages>1479--1488</pages>
<contexts>
<context position="17840" citStr="Hayashi et al., 2011" startWordPosition="3047" endWordPosition="3050">ined with each of its word and POS tag. When using non-local features, we removed the local grand-child features from the model. 5.3 Oracle for Discriminative Training A discriminative reranking model is trained on packed forests by using their oracle trees as the correct parse. More accurate oracles are essential to train a discriminative reranking model well. While large size forests have much more accurate oracles than small size forests, large forests have too many hyperedges to train a discriminative model on them, as shown in Figure 4. The usual forest reranking algorithms (Huang, 2008; Hayashi et al., 2011) 4If each item is augmented with richer information, even features based on the entire subtree can be defined. remove low quality hyperedges from large forests by using inside-outside forest pruning. However, producing large forests and pruning them is computationally very expensive. Instead, we propose a simpler method to produce small forests which have more accurate oracles by forcing the beam search shift-reduce parser to keep the correct state in the beam buffer. As a result, the correct tree will always be encoded in a packed forest. 6 Experiments (Discriminative Reranking) 6.1 Experimen</context>
<context position="32834" citStr="Hayashi et al. (2011)" startWordPosition="5444" endWordPosition="5447">ial to improve dependency parsing accuracy (Koo and Collins, 2010; Rush and Petrov, 2012; Zhang and McDonald, 2012). A reranking approach is one effective solution to introduce rich features to a parser model in the context of constituency parsing (Charniak and Johnson, 2005; Huang, 2008). Hall (2007) applied a k-best maximum spanning tree algorithm to non-projective dependency analysis, and showed that k-best discriminative reranking improves parsing accuracy in several languages. Sangati et al. (2009) proposed a k-best dependency reranking algorithm using a third-order generative model, and Hayashi et al. (2011) extended it to a forest algorithm. Though forest reranking requires some approximations such as cube-pruning to integrate non-local features, it can explore larger search space than k-best reranking. The stacking approach (Nivre and McDonald, 2008; Martins et al., 2008) uses the output of one dependency parser to provide guide features for another. Stacking improves the parsing accuracy of second stage parsers on various language datasets. The joint graph-based and transition-based approach (Zhang and Clark, 2008; Bohnet and Kuhn, 2012) uses an arc-eager shift-reduce parser with a joint graph</context>
</contexts>
<marker>Hayashi, Watanabe, Asahara, Matsumoto, 2011</marker>
<rawString>K. Hayashi, T. Watanabe, M. Asahara, and Y. Matsumoto. 2011. The third-order variational reranking on packed-shared dependency forests. In Proceedings of the 2011 Conference on Empirical Methods in Natural Language Processing, pages 1479–1488.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Hayashi</author>
<author>T Watanabe</author>
<author>M Asahara</author>
<author>Y Matsumoto</author>
</authors>
<title>Head-driven transition-based parsing with top-down prediction.</title>
<date>2012</date>
<booktitle>In Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>657--665</pages>
<contexts>
<context position="8073" citStr="Hayashi et al., 2012" startWordPosition="1373" endWordPosition="1376">bout the topmost stack element is attached to the corresponding vertex marked with a non-terminal symbol X. Weights are omitted in the example. In practice, we attach each reduction weight to the corresponding hyperedge, and add the shift weight to the reduction weight when a shifted word is reduced. 3 Arc-Standard Shift-Reduce Parsing without Spurious Ambiguity One solution to remove spurious ambiguity in the arc-standard transition system is to give priority to the construction of left arcs over that of right arcs (or vice versa) like Eisner (1997). For example, an Earley dependency parser (Hayashi et al., 2012) attaches all left dependents to a word before right dependents. The parser uses a scan action to stop the construction of left arcs. We apply this idea to the arc-standard transition system and show the resulting transition system in Figure 3. We introduce the * symbol to indicate that the root node of the topmost element on the stack has not been scanned yet. The shift and reduce↷ actions can be used only when the root of the topmost element on the stack has already been scanned, and all left arcs are always attached to the head before the head is scanned. The arc-standard shift-reduce parse</context>
</contexts>
<marker>Hayashi, Watanabe, Asahara, Matsumoto, 2012</marker>
<rawString>K. Hayashi, T. Watanabe, M. Asahara, and Y. Matsumoto. 2012. Head-driven transition-based parsing with top-down prediction. In Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics, pages 657–665.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Hollingshead</author>
<author>B Roark</author>
</authors>
<title>Reranking with baseline system scores and ranks as features.</title>
<date>2008</date>
<booktitle>In CSLU-08-001,</booktitle>
<institution>Center for Spoken Language Understanding, Oregon Health and Science University.</institution>
<contexts>
<context position="19177" citStr="Hollingshead and Roark, 2008" startWordPosition="3254" endWordPosition="3257">arsed by each of the spurious and non-spurious shift-reduce parsers using beam size 12 with the model trained on sentences from the remaining 19 folds, dumping the outputs as packed forests. The reranker is modeled by either equation (1) or (4). By our preliminary experiments using development data (WSJ22), we modeled the reranker with equation (1) when training, and with equation (4) when testing5 (i.e., the scores of the first-stage parser are not considered during training of the reranking model). This prevents the discriminative reranking features from under-training (Sutton et al., 2006; Hollingshead and Roark, 2008). A discriminative reranking model is trained on the packed forests by using the averaged perceptron algorithm with 5 iterations. When training nonlocal reranking models, we set k-best size of cubepruning to 5. For dumping packed forests for test data, spurious and non-spurious shift-reduce parsers are trained by the averaged perceptron algorithm. In all experiments on English data, we fixed beam size to 12 for training both parsers. 6.2 Test with Gold POS tags We show the comparison of dumped spurious and non-spurious packed forests for training data in Table 4. Both oracle accuracies are 100</context>
</contexts>
<marker>Hollingshead, Roark, 2008</marker>
<rawString>K. Hollingshead and B. Roark. 2008. Reranking with baseline system scores and ranks as features. In CSLU-08-001, Center for Spoken Language Understanding, Oregon Health and Science University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Huang</author>
<author>D Chiang</author>
</authors>
<title>Forest rescoring: Faster decoding with integrated language models.</title>
<date>2007</date>
<booktitle>In Proceedings of the 45th Annual Meeting of the Association of Computational Linguistics,</booktitle>
<pages>144--151</pages>
<contexts>
<context position="2917" citStr="Huang and Chiang, 2007" startWordPosition="423" endWordPosition="426"> is provided to the second as guide features. In particular, they used a transition-based parser for the first stage and a graph-based parser for the second stage. The main drawback of this approach is that the efficiency of the transition-based parser is sacrificed because the second-stage employs full parsing. This paper proposes an efficient stacked parsing method through discriminative reranking with higher-order graph-based features, which works on the forests output by the first-stage dynamic programming shift-reduce parser and integrates nonlocal features efficiently with cube-pruning (Huang and Chiang, 2007). The advantages of our method are as follows: • Unlike the conventional stacking approach, the first-stage shift-reduce parser prunes the search space of the second-stage graph-based parser. • In addition to guide features, the second-stage graph-based parser can employ the scores of the first-stage parser which cannot be incorpo139 Transactions of the Association for Computational Linguistics, 1 (2013) 139–150. Action Editor: Joakim Nivre. Submitted 12/2012; Revised 3/2013; Published 5/2013. c�2013 Association for Computational Linguistics. axiom(c0) : 0 : (0, 1, w0) : 0 goal(c2n) : 2n : (0,</context>
<context position="13969" citStr="Huang and Chiang, 2007" startWordPosition="2425" endWordPosition="2428">ector (g indicates “graph-based”), x is the input sentence, y is a dependency tree and H is a dependency forest. This model assumes a hyperedge factorization which induces a decomposition of the feature vector as the following: α · fg(x, y) = ∑ α · fg,e(e). (2) eEy The search problem can be solved by simply using the (generalized) Viterbi algorithm (Klein and Manning, 2001). When using non-local features, the hyperedge factorization is redefined to the following: α · fg(x, y) = ∑ α · fg,e(e) + α · fg,e,N(e) (3) eEy where fg,e,N is a non-local feature vector. Though the cube-pruning algorithm (Huang and Chiang, 2007) is an approximate decoding technique based on a k-best Viterbi algorithm, it can calculate the non-local scores efficiently. The baseline score can be taken into the reranker as a linear interpolation: y� = argmax 0 · sctr(x, y) + α · fg(x, y) (4) yEH where sctr is the score from the baseline parser (tr indicates “transition-based”), and 0 is a scaling factor. 5.2 Features for Discriminative Model 5.2.1 Local Features While the inference algorithm is a simple Viterbi algorithm, the discriminative model can use all trisibling features and some grand-sibling features2 (Koo and Collins, 2010) as</context>
</contexts>
<marker>Huang, Chiang, 2007</marker>
<rawString>L. Huang and D. Chiang. 2007. Forest rescoring: Faster decoding with integrated language models. In Proceedings of the 45th Annual Meeting of the Association of Computational Linguistics, pages 144–151.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Huang</author>
<author>K Sagae</author>
</authors>
<title>Dynamic programming for linear-time incremental parsing.</title>
<date>2010</date>
<booktitle>In Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics (ACL’10),</booktitle>
<pages>1077--1086</pages>
<contexts>
<context position="1989" citStr="Huang and Sagae, 2010" startWordPosition="284" endWordPosition="287">length n. Recently, some pruning techniques have been proposed to improve the efficiency of third-order models (Rush and Petrov, 2012; Zhang and McDonald, 2012). The transition-based approach usually employs the shift-reduce parsing algorithm with linear-time complexity (Nivre, 2008). It greedily chooses the transition with the highest score and the resulting transition sequence is not always globally optimal. The beam search algorithm improves parsing flexibility in deterministic parsing (Zhang and Clark, 2008; Zhang and Nivre, 2011), and dynamic programming makes beam search more efficient (Huang and Sagae, 2010). There is also an alternative approach that integrates graph-based and transition-based models (Sagae and Lavie, 2006; Zhang and Clark, 2008; Nivre and McDonald, 2008; Martins et al., 2008). Martins et al. (2008) formulated their approach as stacking of parsers where the output of the first-stage parser is provided to the second as guide features. In particular, they used a transition-based parser for the first stage and a graph-based parser for the second stage. The main drawback of this approach is that the efficiency of the transition-based parser is sacrificed because the second-stage emp</context>
<context position="6061" citStr="Huang and Sagae (2010)" startWordPosition="1020" endWordPosition="1023">o s1.rc.t o s1.rc2.t s0.h.t o s0.lc.t o s0.lc2.t o q0.t s0.h.t o s0.rc.t o s0.rc2.t o q0.t s0.h.t o s1.h.t o q0.t o q1.t s0.h.w o s1.h.t o q0.t o q1.t Table 1: Additional feature templates for shift-reduce parsers: q denotes input queue. h, lc and rc are head, leftmost child and rightmost child of a stack element s. lc2 and rc2 denote the second leftmost and rightmost children. t and w are a part-of-speech (POS) tag and a word. of s0 into stack1. Dynamic programming merges equivalent states in the same step if they have the same feature values. We add the feature templates shown in Table 1 to Huang and Sagae (2010)’s feature templates. Dynamic programming not only makes the shiftreduce parser with beam search more efficient but also produces a packed forest that encodes an exponential number of dependency trees. A packed dependency forest can be represented by a weighted (directed) hypergraph. A weighted hypergraph is a pair H = (V, E), where V is the set of vertices and E is the set of hyperedges. Each hyperedge e E E is a tuple e = (T(e), h(e), fe), where h(e) E V is 1Huang and Sagae (2010)’s dynamic programming is based on a notion of a push computation (Kuhlmann et al., 2011). The details are out of</context>
<context position="30245" citStr="Huang and Sagae (2010)" startWordPosition="5045" endWordPosition="5048">ributed to the better prediction of the structures around the sentence root because most of the non-local features are useful for predicting these structures. Table 13 shows the recall, precision and F-measure of grandchild structures whose grand parent is a sentence root symbol $. The results support the above assumption. The root correct rate directly influences on prediction of the overall structures of a sentence, and it is likely that the reduction of root prediction errors brings better results. 6.5 Experiments on Chinese We also experiment on the Penn Chinese Treebank (CTB5). Following Huang and Sagae (2010), we split it into training (secs 001-815 and 1001-1136), development (secs 886-931 and 1148-1151), and test (secs 816-885 and 1137-1147) sets, and use the head rules of Zhang and Clark (2008). The training set is split into 10 folds to dump packed forests for training of reranking models. We set the beam size of both spurious and nonspurious parsers to 12, and the number of perceptron training iterations to 25 for the parsers and to 8 for both rerankers. Table 14 shows the results for the test sets. As we expected, reranking on non-spurious forests outperforms that on spurious forests. 92.6 9</context>
</contexts>
<marker>Huang, Sagae, 2010</marker>
<rawString>L. Huang and K. Sagae. 2010. Dynamic programming for linear-time incremental parsing. In Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics (ACL’10), pages 1077–1086.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Huang</author>
<author>S Fayong</author>
<author>Y Guo</author>
</authors>
<title>Structured perceptron with inexact search.</title>
<date>2012</date>
<booktitle>In Proceedings of the 2012 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies,</booktitle>
<pages>142--151</pages>
<contexts>
<context position="11387" citStr="Huang et al., 2012" startWordPosition="1996" endWordPosition="1999">sing development (WSJ22) and test (WSJ23) data with spurious shift-reduce and proposed shift-reduce parser (non-sp.) using several beam sizes. shift : scan : state p z } |{ :(i, j, s′d|s′d−1 |... |s′ 0|s′0) : π′ state q z } |{ ℓ : (j, k, sd|sd−1 |... |s1|s∗0) : π s′ 0.h.w =� w0 n p E π ℓ + 1 : (i, k, s′ d|s′ d−1 |... |s′ 1|s′ 0↶s∗ 0) : π′ state p z } |{ : (i,j, s′d|s′d−1 |... |s′1|s′0) : π′ state q z } |{ ℓ : (j, k, sd|sd−1 |... |s1|s0) : π p E π ℓ + 1 : (i, k, s′ d|s′ d−1 |. . . |s′ 1|s′ 0↷s0) : π′ We used an early update version of the averaged perceptron algorithm (Collins and Roark, 2004; Huang et al., 2012) to train two shift-reduce dependency parsers with beam size of 12. Table 2 shows experimental results of parsing the development and test datasets with each of the spurious and non-spurious shift-reduce parsers using several beam sizes. Parsing accuracies were evaluated by unlabeled accuracy scores (UAS) with and without punctuations. The parsing times were measured on an Intel Core i7 2.8GHz. The average cpu time (per sentence) includes that of dumping packed forests. This result indicates that the non-spurious parser achieves better accuracies than the spurious beam size 8 32 128 % of disti</context>
</contexts>
<marker>Huang, Fayong, Guo, 2012</marker>
<rawString>L. Huang, S. Fayong, and Y. Guo. 2012. Structured perceptron with inexact search. In Proceedings of the 2012 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, pages 142–151.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Huang</author>
</authors>
<title>Forest reranking: Discriminative parsing with non-local features.</title>
<date>2008</date>
<booktitle>In Proceedings of the 46th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>586--594</pages>
<contexts>
<context position="12809" citStr="Huang, 2008" startWordPosition="2227" endWordPosition="2228">in 10, 100, 1000 and 10000 best trees extracted from spurious forests with several beam sizes. parser without loss of efficiency. Figure 4 shows oracle unlabeled accuracies of spurious k-best lists, non-spurious k-best lists, spurious forests, and non-spurious forests. We extract an oracle tree from each packed forest using the for142 0 500 1000 1500 2000 2500 3000 ave. # of hyperedges Figure 4: Each plot shows oracle unlabeled accuracies of spurious k-best lists, spurious forests, and non-spurious forests. The oracle accuracies are evaluated using UAS with punctuations. est oracle algorithm (Huang, 2008). Both forests produce much better results than the k-best lists, and non-spurious forests have almost the same oracle accuracies as spurious forests. However, as shown in Table 3, spurious forests encode a number of non-unique dependency trees while all dependency trees in non-spurious forests are distinct from each other. 5 Forest Reranking 5.1 Discriminative Reranking Model We define a reranking model based on the graphbased features as the following: y� = argmax α · fg(x, y) (1) yEH where α is a weight vector, fg is a feature vector (g indicates “graph-based”), x is the input sentence, y i</context>
<context position="17817" citStr="Huang, 2008" startWordPosition="3045" endWordPosition="3046"> ahead, conjoined with each of its word and POS tag. When using non-local features, we removed the local grand-child features from the model. 5.3 Oracle for Discriminative Training A discriminative reranking model is trained on packed forests by using their oracle trees as the correct parse. More accurate oracles are essential to train a discriminative reranking model well. While large size forests have much more accurate oracles than small size forests, large forests have too many hyperedges to train a discriminative model on them, as shown in Figure 4. The usual forest reranking algorithms (Huang, 2008; Hayashi et al., 2011) 4If each item is augmented with richer information, even features based on the entire subtree can be defined. remove low quality hyperedges from large forests by using inside-outside forest pruning. However, producing large forests and pruning them is computationally very expensive. Instead, we propose a simpler method to produce small forests which have more accurate oracles by forcing the beam search shift-reduce parser to keep the correct state in the beam buffer. As a result, the correct tree will always be encoded in a packed forest. 6 Experiments (Discriminative R</context>
<context position="32502" citStr="Huang, 2008" startWordPosition="5399" endWordPosition="5400">oblem. Goldberg and Nivre (2012) addressed this problem by not only training with a canonical transition sequence but also with alternate optimal transitions that are calculated dynamically for a current state. 7.2 Methods to Improve Dependency Parsing Higher-order features like third-order dependency relations are essential to improve dependency parsing accuracy (Koo and Collins, 2010; Rush and Petrov, 2012; Zhang and McDonald, 2012). A reranking approach is one effective solution to introduce rich features to a parser model in the context of constituency parsing (Charniak and Johnson, 2005; Huang, 2008). Hall (2007) applied a k-best maximum spanning tree algorithm to non-projective dependency analysis, and showed that k-best discriminative reranking improves parsing accuracy in several languages. Sangati et al. (2009) proposed a k-best dependency reranking algorithm using a third-order generative model, and Hayashi et al. (2011) extended it to a forest algorithm. Though forest reranking requires some approximations such as cube-pruning to integrate non-local features, it can explore larger search space than k-best reranking. The stacking approach (Nivre and McDonald, 2008; Martins et al., 20</context>
</contexts>
<marker>Huang, 2008</marker>
<rawString>L. Huang. 2008. Forest reranking: Discriminative parsing with non-local features. In Proceedings of the 46th Annual Meeting of the Association for Computational Linguistics, pages 586–594.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Klein</author>
<author>C D Manning</author>
</authors>
<title>Parsing and hypergraphs.</title>
<date>2001</date>
<booktitle>In Proceedings of the 7th International Workshop on Parsing Technologies.</booktitle>
<contexts>
<context position="13722" citStr="Klein and Manning, 2001" startWordPosition="2381" endWordPosition="2385">orests are distinct from each other. 5 Forest Reranking 5.1 Discriminative Reranking Model We define a reranking model based on the graphbased features as the following: y� = argmax α · fg(x, y) (1) yEH where α is a weight vector, fg is a feature vector (g indicates “graph-based”), x is the input sentence, y is a dependency tree and H is a dependency forest. This model assumes a hyperedge factorization which induces a decomposition of the feature vector as the following: α · fg(x, y) = ∑ α · fg,e(e). (2) eEy The search problem can be solved by simply using the (generalized) Viterbi algorithm (Klein and Manning, 2001). When using non-local features, the hyperedge factorization is redefined to the following: α · fg(x, y) = ∑ α · fg,e(e) + α · fg,e,N(e) (3) eEy where fg,e,N is a non-local feature vector. Though the cube-pruning algorithm (Huang and Chiang, 2007) is an approximate decoding technique based on a k-best Viterbi algorithm, it can calculate the non-local scores efficiently. The baseline score can be taken into the reranker as a linear interpolation: y� = argmax 0 · sctr(x, y) + α · fg(x, y) (4) yEH where sctr is the score from the baseline parser (tr indicates “transition-based”), and 0 is a scali</context>
</contexts>
<marker>Klein, Manning, 2001</marker>
<rawString>D. Klein and C. D. Manning. 2001. Parsing and hypergraphs. In Proceedings of the 7th International Workshop on Parsing Technologies.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Koo</author>
<author>M Collins</author>
</authors>
<title>Efficient third-order dependency parsers.</title>
<date>2010</date>
<booktitle>In Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics (ACL’10),</booktitle>
<pages>1--11</pages>
<contexts>
<context position="14566" citStr="Koo and Collins, 2010" startWordPosition="2523" endWordPosition="2526"> (Huang and Chiang, 2007) is an approximate decoding technique based on a k-best Viterbi algorithm, it can calculate the non-local scores efficiently. The baseline score can be taken into the reranker as a linear interpolation: y� = argmax 0 · sctr(x, y) + α · fg(x, y) (4) yEH where sctr is the score from the baseline parser (tr indicates “transition-based”), and 0 is a scaling factor. 5.2 Features for Discriminative Model 5.2.1 Local Features While the inference algorithm is a simple Viterbi algorithm, the discriminative model can use all trisibling features and some grand-sibling features2 (Koo and Collins, 2010) as a local scoring factor in addition to the first- and sibling second-order graphbased features. This is because the first stage shiftreduce parser uses features described in Section 2 and this information can be encoded into vertices of a hypergraph. The reranking model also uses guide features extracted from the 1-best tree predicted by the first stage shift-reduce parser. We define the guide features as first-order relations like those used in Nivre and McDonald (2008) though our parser handles only unlabeled and projective dependency structures. We summarize the features for discriminati</context>
<context position="24957" citStr="Koo and Collins, 2010" startWordPosition="4218" endWordPosition="4221">ng and the cpu times of our systems were taken on Intel Core i7 2.8GHz. our proposed systems together with results from related work. The parsing times are reported in tokens/second for comparison. Note that, however, the difference of the parsing time does not represent the efficiency of the algorithm directly because each system was implemented in different programming language and the times were measured on different environments. The accuracy of local reranking on non-spurious forests is the best among unlabeled shift-reduce parsers, but slightly behind the third-order graphbased systems (Koo and Collins, 2010; Zhang and McDonald, 2012; Rush and Petrov, 2012). It is likely that the difference comes from the fact that our local reranking model can define only some of the grand-child related features. w/ guide. w/o guide. UAS 92.98 92.86 feature Linear (first) 89,330 89,215 CorePos (first) 1,047,948 1,053,796 TwoObs (first) 1,303,911 1,325,990 Sibling (second) 290,291 292,849 Trip (second) 19,333 19,267 Grand-child 16,975 16,951 Guide 4,934 – Tri-sibling 277,770 279,720 PP-Attachment 32,695 32,993 total 3,083,187 3,110,781 Table 9: Accuracy and the number of non-zero weighted features of the local re</context>
<context position="32278" citStr="Koo and Collins, 2010" startWordPosition="5361" endWordPosition="5364">sed parsers (Attardi, 2006). Our system copes only with the projective case, but is simpler than theirs and we show its efficacy empirically through some experiments. The arc-eager shift-reduce parser also has a spurious ambiguity problem. Goldberg and Nivre (2012) addressed this problem by not only training with a canonical transition sequence but also with alternate optimal transitions that are calculated dynamically for a current state. 7.2 Methods to Improve Dependency Parsing Higher-order features like third-order dependency relations are essential to improve dependency parsing accuracy (Koo and Collins, 2010; Rush and Petrov, 2012; Zhang and McDonald, 2012). A reranking approach is one effective solution to introduce rich features to a parser model in the context of constituency parsing (Charniak and Johnson, 2005; Huang, 2008). Hall (2007) applied a k-best maximum spanning tree algorithm to non-projective dependency analysis, and showed that k-best discriminative reranking improves parsing accuracy in several languages. Sangati et al. (2009) proposed a k-best dependency reranking algorithm using a third-order generative model, and Hayashi et al. (2011) extended it to a forest algorithm. Though f</context>
</contexts>
<marker>Koo, Collins, 2010</marker>
<rawString>T. Koo and M. Collins. 2010. Efficient third-order dependency parsers. In Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics (ACL’10), pages 1–11.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Kuhlmann</author>
<author>C G´omez-Rodr´ıguez</author>
<author>G Satta</author>
</authors>
<title>Dynamic programming algorithms for transitionbased dependency parsers.</title>
<date>2011</date>
<booktitle>In Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>673--682</pages>
<marker>Kuhlmann, G´omez-Rodr´ıguez, Satta, 2011</marker>
<rawString>M. Kuhlmann, C. G´omez-Rodr´ıguez, and G. Satta. 2011. Dynamic programming algorithms for transitionbased dependency parsers. In Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics, pages 673–682.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andr´e F T Martins</author>
<author>D Das</author>
<author>N A Smith</author>
<author>E P Xing</author>
</authors>
<title>Stacking dependency parsers.</title>
<date>2008</date>
<booktitle>In Proceedings of the 2008 Conference on Empirical Methods in Natural Language Processing,</booktitle>
<pages>157--166</pages>
<contexts>
<context position="2179" citStr="Martins et al., 2008" startWordPosition="313" endWordPosition="316"> usually employs the shift-reduce parsing algorithm with linear-time complexity (Nivre, 2008). It greedily chooses the transition with the highest score and the resulting transition sequence is not always globally optimal. The beam search algorithm improves parsing flexibility in deterministic parsing (Zhang and Clark, 2008; Zhang and Nivre, 2011), and dynamic programming makes beam search more efficient (Huang and Sagae, 2010). There is also an alternative approach that integrates graph-based and transition-based models (Sagae and Lavie, 2006; Zhang and Clark, 2008; Nivre and McDonald, 2008; Martins et al., 2008). Martins et al. (2008) formulated their approach as stacking of parsers where the output of the first-stage parser is provided to the second as guide features. In particular, they used a transition-based parser for the first stage and a graph-based parser for the second stage. The main drawback of this approach is that the efficiency of the transition-based parser is sacrificed because the second-stage employs full parsing. This paper proposes an efficient stacked parsing method through discriminative reranking with higher-order graph-based features, which works on the forests output by the f</context>
<context position="26828" citStr="Martins et al., 2008" startWordPosition="4510" endWordPosition="4513"> features from baseline reranking models with and without non-local features used in Section 6.3. The results are shown in Table 9 and 10. The parsing accuracies of the baseline reranking models are better than those of the models without guide features though the number of guide features is not large. Additionally, each model with guide features is smaller than that without guide features. This indicates that stacking has a good effect on training the models. To further investigate the effects of guide features, we tried to define unlabeled versions of the secondorder guide features used in (Martins et al., 2008; McClosky et al., 2012). However, these features did not produce good results, and investigation to find the cause is an important future work. We also examined parsing errors in more detail. Table 11 shows root and sentence complete rates of three systems, the non-spurious shift-reduce sp. non-sp. 127.0 119.1 178.6 168.5 82.4 100.0 92.8 92.9 97.0 97.0 146 Table 10: Accuracy and the number of non-zero weighted features of the non-local reranking models with and without guide features: the first- and second-order features are named for MSTParser. w/ guide. w/o guide. UAS 93.12 93.04 feature Li</context>
<context position="33105" citStr="Martins et al., 2008" startWordPosition="5484" endWordPosition="5487">2005; Huang, 2008). Hall (2007) applied a k-best maximum spanning tree algorithm to non-projective dependency analysis, and showed that k-best discriminative reranking improves parsing accuracy in several languages. Sangati et al. (2009) proposed a k-best dependency reranking algorithm using a third-order generative model, and Hayashi et al. (2011) extended it to a forest algorithm. Though forest reranking requires some approximations such as cube-pruning to integrate non-local features, it can explore larger search space than k-best reranking. The stacking approach (Nivre and McDonald, 2008; Martins et al., 2008) uses the output of one dependency parser to provide guide features for another. Stacking improves the parsing accuracy of second stage parsers on various language datasets. The joint graph-based and transition-based approach (Zhang and Clark, 2008; Bohnet and Kuhn, 2012) uses an arc-eager shift-reduce parser with a joint graph-based and transition-based model. Though it improves parsing accuracy significantly, the large beam size of the shift-reduce parser harms its efficiency. Sagae and Lavie (2006) showed that combining the outputs of graph-based and transitionbased parsers can improve pars</context>
</contexts>
<marker>Martins, Das, Smith, Xing, 2008</marker>
<rawString>Andr´e F. T. Martins, D. Das, N. A. Smith, and E. P. Xing. 2008. Stacking dependency parsers. In Proceedings of the 2008 Conference on Empirical Methods in Natural Language Processing, pages 157–166.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D McClosky</author>
<author>W Che</author>
<author>M Recasens</author>
<author>M Wang</author>
<author>R Socher</author>
<author>C D Manning</author>
</authors>
<title>Stanfords system for parsing the english web.</title>
<date>2012</date>
<booktitle>In Proceedings of First Workshop on Syntactic Analysis of Non-Canonical Language (SANCL) at NAACL</booktitle>
<contexts>
<context position="26852" citStr="McClosky et al., 2012" startWordPosition="4514" endWordPosition="4517">e reranking models with and without non-local features used in Section 6.3. The results are shown in Table 9 and 10. The parsing accuracies of the baseline reranking models are better than those of the models without guide features though the number of guide features is not large. Additionally, each model with guide features is smaller than that without guide features. This indicates that stacking has a good effect on training the models. To further investigate the effects of guide features, we tried to define unlabeled versions of the secondorder guide features used in (Martins et al., 2008; McClosky et al., 2012). However, these features did not produce good results, and investigation to find the cause is an important future work. We also examined parsing errors in more detail. Table 11 shows root and sentence complete rates of three systems, the non-spurious shift-reduce sp. non-sp. 127.0 119.1 178.6 168.5 82.4 100.0 92.8 92.9 97.0 97.0 146 Table 10: Accuracy and the number of non-zero weighted features of the non-local reranking models with and without guide features: the first- and second-order features are named for MSTParser. w/ guide. w/o guide. UAS 93.12 93.04 feature Linear (first) 88,634 88,9</context>
</contexts>
<marker>McClosky, Che, Recasens, Wang, Socher, Manning, 2012</marker>
<rawString>D. McClosky, W. Che, M. Recasens, M. Wang, R. Socher, and C. D. Manning. 2012. Stanfords system for parsing the english web. In Proceedings of First Workshop on Syntactic Analysis of Non-Canonical Language (SANCL) at NAACL 2012.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R McDonald</author>
<author>K Crammer</author>
<author>F Pereira</author>
</authors>
<title>Online large-margin training of dependency parsers.</title>
<date>2005</date>
<booktitle>In Proceedings of the 43rd Annual Meeting of the Association for Computational Linguistics (ACL’05),</booktitle>
<pages>91--98</pages>
<contexts>
<context position="1247" citStr="McDonald et al., 2005" startWordPosition="174" endWordPosition="177">features in addition to third-order graph-based features. To improve efficiency and accuracy, this paper also proposes a novel shift-reduce parser that eliminates the spurious ambiguity of arcstandard transition systems. Testing on the English Penn Treebank data, forest reranking gave a state-of-the-art unlabeled dependency accuracy of 93.12. 1 Introduction There are two main approaches of data-driven dependency parsing – one is graph-based and the other is transition-based. In the graph-based approach, global optimization algorithms find the highest-scoring tree with locally factored models (McDonald et al., 2005). While third-order graph-based models achieve stateof-the-art accuracy, it has O(n4) time complexity for a sentence of length n. Recently, some pruning techniques have been proposed to improve the efficiency of third-order models (Rush and Petrov, 2012; Zhang and McDonald, 2012). The transition-based approach usually employs the shift-reduce parsing algorithm with linear-time complexity (Nivre, 2008). It greedily chooses the transition with the highest score and the resulting transition sequence is not always globally optimal. The beam search algorithm improves parsing flexibility in determin</context>
</contexts>
<marker>McDonald, Crammer, Pereira, 2005</marker>
<rawString>R. McDonald, K. Crammer, and F. Pereira. 2005. Online large-margin training of dependency parsers. In Proceedings of the 43rd Annual Meeting of the Association for Computational Linguistics (ACL’05), pages 91–98.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Nivre</author>
<author>R McDonald</author>
</authors>
<title>Integrating graphbased and transition-based dependency parsers.</title>
<date>2008</date>
<booktitle>In Proceedings of ACL-08: HLT,</booktitle>
<pages>950--958</pages>
<contexts>
<context position="2156" citStr="Nivre and McDonald, 2008" startWordPosition="309" endWordPosition="312"> transition-based approach usually employs the shift-reduce parsing algorithm with linear-time complexity (Nivre, 2008). It greedily chooses the transition with the highest score and the resulting transition sequence is not always globally optimal. The beam search algorithm improves parsing flexibility in deterministic parsing (Zhang and Clark, 2008; Zhang and Nivre, 2011), and dynamic programming makes beam search more efficient (Huang and Sagae, 2010). There is also an alternative approach that integrates graph-based and transition-based models (Sagae and Lavie, 2006; Zhang and Clark, 2008; Nivre and McDonald, 2008; Martins et al., 2008). Martins et al. (2008) formulated their approach as stacking of parsers where the output of the first-stage parser is provided to the second as guide features. In particular, they used a transition-based parser for the first stage and a graph-based parser for the second stage. The main drawback of this approach is that the efficiency of the transition-based parser is sacrificed because the second-stage employs full parsing. This paper proposes an efficient stacked parsing method through discriminative reranking with higher-order graph-based features, which works on the </context>
<context position="15044" citStr="Nivre and McDonald (2008)" startWordPosition="2602" endWordPosition="2605">hm is a simple Viterbi algorithm, the discriminative model can use all trisibling features and some grand-sibling features2 (Koo and Collins, 2010) as a local scoring factor in addition to the first- and sibling second-order graphbased features. This is because the first stage shiftreduce parser uses features described in Section 2 and this information can be encoded into vertices of a hypergraph. The reranking model also uses guide features extracted from the 1-best tree predicted by the first stage shift-reduce parser. We define the guide features as first-order relations like those used in Nivre and McDonald (2008) though our parser handles only unlabeled and projective dependency structures. We summarize the features for discriminative reranking model as the following: • First- and second-order features: these features are the same as those used in MST parser3. • Grand-child features: we define tri-gram POS features with POS tags of grand parent, parent, and rightmost or leftmost child. • Tri-sibling features: we define tri-gram features with three POS-tags of child, sibling, and trisibling. We also define tri-gram features with one word and two POS tags of the above. 2The grand-child and grand-sibling</context>
<context position="33082" citStr="Nivre and McDonald, 2008" startWordPosition="5480" endWordPosition="5483">ng (Charniak and Johnson, 2005; Huang, 2008). Hall (2007) applied a k-best maximum spanning tree algorithm to non-projective dependency analysis, and showed that k-best discriminative reranking improves parsing accuracy in several languages. Sangati et al. (2009) proposed a k-best dependency reranking algorithm using a third-order generative model, and Hayashi et al. (2011) extended it to a forest algorithm. Though forest reranking requires some approximations such as cube-pruning to integrate non-local features, it can explore larger search space than k-best reranking. The stacking approach (Nivre and McDonald, 2008; Martins et al., 2008) uses the output of one dependency parser to provide guide features for another. Stacking improves the parsing accuracy of second stage parsers on various language datasets. The joint graph-based and transition-based approach (Zhang and Clark, 2008; Bohnet and Kuhn, 2012) uses an arc-eager shift-reduce parser with a joint graph-based and transition-based model. Though it improves parsing accuracy significantly, the large beam size of the shift-reduce parser harms its efficiency. Sagae and Lavie (2006) showed that combining the outputs of graph-based and transitionbased p</context>
</contexts>
<marker>Nivre, McDonald, 2008</marker>
<rawString>J. Nivre and R. McDonald. 2008. Integrating graphbased and transition-based dependency parsers. In Proceedings of ACL-08: HLT, pages 950–958.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Nivre</author>
</authors>
<title>Algorithms for deterministic incremental dependency parsing.</title>
<date>2008</date>
<journal>Computational Linguistics,</journal>
<pages>34--513</pages>
<contexts>
<context position="1651" citStr="Nivre, 2008" startWordPosition="232" endWordPosition="233">y parsing – one is graph-based and the other is transition-based. In the graph-based approach, global optimization algorithms find the highest-scoring tree with locally factored models (McDonald et al., 2005). While third-order graph-based models achieve stateof-the-art accuracy, it has O(n4) time complexity for a sentence of length n. Recently, some pruning techniques have been proposed to improve the efficiency of third-order models (Rush and Petrov, 2012; Zhang and McDonald, 2012). The transition-based approach usually employs the shift-reduce parsing algorithm with linear-time complexity (Nivre, 2008). It greedily chooses the transition with the highest score and the resulting transition sequence is not always globally optimal. The beam search algorithm improves parsing flexibility in deterministic parsing (Zhang and Clark, 2008; Zhang and Nivre, 2011), and dynamic programming makes beam search more efficient (Huang and Sagae, 2010). There is also an alternative approach that integrates graph-based and transition-based models (Sagae and Lavie, 2006; Zhang and Clark, 2008; Nivre and McDonald, 2008; Martins et al., 2008). Martins et al. (2008) formulated their approach as stacking of parsers</context>
</contexts>
<marker>Nivre, 2008</marker>
<rawString>J. Nivre. 2008. Algorithms for deterministic incremental dependency parsing. Computational Linguistics, 34:513–553.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F J Och</author>
</authors>
<title>Minimum error rate training in statistical machine translation.</title>
<date>2003</date>
<booktitle>In Proc. the 41st ACL,</booktitle>
<pages>160--167</pages>
<contexts>
<context position="19882" citStr="Och, 2003" startWordPosition="3374" endWordPosition="3375">ptron algorithm with 5 iterations. When training nonlocal reranking models, we set k-best size of cubepruning to 5. For dumping packed forests for test data, spurious and non-spurious shift-reduce parsers are trained by the averaged perceptron algorithm. In all experiments on English data, we fixed beam size to 12 for training both parsers. 6.2 Test with Gold POS tags We show the comparison of dumped spurious and non-spurious packed forests for training data in Table 4. Both oracle accuracies are 100.0 due to the 5The scaling factor 0 was tuned by minimum error rate training (MERT) algorithm (Och, 2003) using development data. The MERT algorithm is suited to tune low-dimensional parameters. The 0 was set to about 1.2 in case of local reranking, and to about 1.5 in case of non-local reranking. 144 system w/ rerank. sec. (per sent.) UAS (w/o punc.) sr (12) – 0.011 92.8 (93.3) (8) w/ local 0.009 + 0.0056 93.03 (93.69) (12) w/ local 0.011 + 0.0079 93.03 (93.68) (32) w/ local 0.03 + 0.019 93.07 (93.67) (64) w/ local 0.06 + 0.039 93.0 (93.61) (12, k=3) w/ non-local 0.011 + 0.0085 93.17 (93.78) (64, k=3) w/ non-local 0.06 + 0.046 93.19 (93.78) non-sp sr (12) – 0.012 92.9 (93.5) (8) w/ local 0.01 + </context>
</contexts>
<marker>Och, 2003</marker>
<rawString>F. J. Och. 2003. Minimum error rate training in statistical machine translation. In Proc. the 41st ACL, pages 160–167.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Rush</author>
<author>S Petrov</author>
</authors>
<title>Vine pruning for efficient multi-pass dependency parsing.</title>
<date>2012</date>
<booktitle>In Proceedings of the 2012 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies,</booktitle>
<pages>498--507</pages>
<contexts>
<context position="1500" citStr="Rush and Petrov, 2012" startWordPosition="212" endWordPosition="215">ank data, forest reranking gave a state-of-the-art unlabeled dependency accuracy of 93.12. 1 Introduction There are two main approaches of data-driven dependency parsing – one is graph-based and the other is transition-based. In the graph-based approach, global optimization algorithms find the highest-scoring tree with locally factored models (McDonald et al., 2005). While third-order graph-based models achieve stateof-the-art accuracy, it has O(n4) time complexity for a sentence of length n. Recently, some pruning techniques have been proposed to improve the efficiency of third-order models (Rush and Petrov, 2012; Zhang and McDonald, 2012). The transition-based approach usually employs the shift-reduce parsing algorithm with linear-time complexity (Nivre, 2008). It greedily chooses the transition with the highest score and the resulting transition sequence is not always globally optimal. The beam search algorithm improves parsing flexibility in deterministic parsing (Zhang and Clark, 2008; Zhang and Nivre, 2011), and dynamic programming makes beam search more efficient (Huang and Sagae, 2010). There is also an alternative approach that integrates graph-based and transition-based models (Sagae and Lavi</context>
<context position="25007" citStr="Rush and Petrov, 2012" startWordPosition="4226" endWordPosition="4229"> Intel Core i7 2.8GHz. our proposed systems together with results from related work. The parsing times are reported in tokens/second for comparison. Note that, however, the difference of the parsing time does not represent the efficiency of the algorithm directly because each system was implemented in different programming language and the times were measured on different environments. The accuracy of local reranking on non-spurious forests is the best among unlabeled shift-reduce parsers, but slightly behind the third-order graphbased systems (Koo and Collins, 2010; Zhang and McDonald, 2012; Rush and Petrov, 2012). It is likely that the difference comes from the fact that our local reranking model can define only some of the grand-child related features. w/ guide. w/o guide. UAS 92.98 92.86 feature Linear (first) 89,330 89,215 CorePos (first) 1,047,948 1,053,796 TwoObs (first) 1,303,911 1,325,990 Sibling (second) 290,291 292,849 Trip (second) 19,333 19,267 Grand-child 16,975 16,951 Guide 4,934 – Tri-sibling 277,770 279,720 PP-Attachment 32,695 32,993 total 3,083,187 3,110,781 Table 9: Accuracy and the number of non-zero weighted features of the local reranking models with and without guide features: th</context>
<context position="32301" citStr="Rush and Petrov, 2012" startWordPosition="5365" endWordPosition="5368">006). Our system copes only with the projective case, but is simpler than theirs and we show its efficacy empirically through some experiments. The arc-eager shift-reduce parser also has a spurious ambiguity problem. Goldberg and Nivre (2012) addressed this problem by not only training with a canonical transition sequence but also with alternate optimal transitions that are calculated dynamically for a current state. 7.2 Methods to Improve Dependency Parsing Higher-order features like third-order dependency relations are essential to improve dependency parsing accuracy (Koo and Collins, 2010; Rush and Petrov, 2012; Zhang and McDonald, 2012). A reranking approach is one effective solution to introduce rich features to a parser model in the context of constituency parsing (Charniak and Johnson, 2005; Huang, 2008). Hall (2007) applied a k-best maximum spanning tree algorithm to non-projective dependency analysis, and showed that k-best discriminative reranking improves parsing accuracy in several languages. Sangati et al. (2009) proposed a k-best dependency reranking algorithm using a third-order generative model, and Hayashi et al. (2011) extended it to a forest algorithm. Though forest reranking require</context>
</contexts>
<marker>Rush, Petrov, 2012</marker>
<rawString>A. Rush and S. Petrov. 2012. Vine pruning for efficient multi-pass dependency parsing. In Proceedings of the 2012 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, pages 498–507.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Sagae</author>
<author>A Lavie</author>
</authors>
<title>Parser combination by reparsing.</title>
<date>2006</date>
<booktitle>In Proc. HLT,</booktitle>
<pages>129--132</pages>
<contexts>
<context position="2107" citStr="Sagae and Lavie, 2006" startWordPosition="301" endWordPosition="304">d Petrov, 2012; Zhang and McDonald, 2012). The transition-based approach usually employs the shift-reduce parsing algorithm with linear-time complexity (Nivre, 2008). It greedily chooses the transition with the highest score and the resulting transition sequence is not always globally optimal. The beam search algorithm improves parsing flexibility in deterministic parsing (Zhang and Clark, 2008; Zhang and Nivre, 2011), and dynamic programming makes beam search more efficient (Huang and Sagae, 2010). There is also an alternative approach that integrates graph-based and transition-based models (Sagae and Lavie, 2006; Zhang and Clark, 2008; Nivre and McDonald, 2008; Martins et al., 2008). Martins et al. (2008) formulated their approach as stacking of parsers where the output of the first-stage parser is provided to the second as guide features. In particular, they used a transition-based parser for the first stage and a graph-based parser for the second stage. The main drawback of this approach is that the efficiency of the transition-based parser is sacrificed because the second-stage employs full parsing. This paper proposes an efficient stacked parsing method through discriminative reranking with highe</context>
<context position="33611" citStr="Sagae and Lavie (2006)" startWordPosition="5559" endWordPosition="5562">re larger search space than k-best reranking. The stacking approach (Nivre and McDonald, 2008; Martins et al., 2008) uses the output of one dependency parser to provide guide features for another. Stacking improves the parsing accuracy of second stage parsers on various language datasets. The joint graph-based and transition-based approach (Zhang and Clark, 2008; Bohnet and Kuhn, 2012) uses an arc-eager shift-reduce parser with a joint graph-based and transition-based model. Though it improves parsing accuracy significantly, the large beam size of the shift-reduce parser harms its efficiency. Sagae and Lavie (2006) showed that combining the outputs of graph-based and transitionbased parsers can improve parsing accuracies. 8 Conclusion We have presented a discriminative forest reranking algorithm for dependency parsing. This can be seen as a kind of joint transition-based and graph-based approach because the first-stage parser is a shiftreduce parser and the second-stage reranker uses a graph-based model. Additionally, we have proposed a dynamic programming arc-standard transition-based dependency parser without spurious ambiguity, along with a heuristic that encodes the correct tree in the output packed</context>
</contexts>
<marker>Sagae, Lavie, 2006</marker>
<rawString>K. Sagae and A. Lavie. 2006. Parser combination by reparsing. In Proc. HLT, pages 129–132.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Sangati</author>
<author>W Zuidema</author>
<author>R Bod</author>
</authors>
<title>A generative re-ranking model for dependency parsing.</title>
<date>2009</date>
<booktitle>In Proceedings of the 11th International Conference on Parsing Technologies (IWPT’09),</booktitle>
<pages>238--241</pages>
<contexts>
<context position="32721" citStr="Sangati et al. (2009)" startWordPosition="5428" endWordPosition="5431"> 7.2 Methods to Improve Dependency Parsing Higher-order features like third-order dependency relations are essential to improve dependency parsing accuracy (Koo and Collins, 2010; Rush and Petrov, 2012; Zhang and McDonald, 2012). A reranking approach is one effective solution to introduce rich features to a parser model in the context of constituency parsing (Charniak and Johnson, 2005; Huang, 2008). Hall (2007) applied a k-best maximum spanning tree algorithm to non-projective dependency analysis, and showed that k-best discriminative reranking improves parsing accuracy in several languages. Sangati et al. (2009) proposed a k-best dependency reranking algorithm using a third-order generative model, and Hayashi et al. (2011) extended it to a forest algorithm. Though forest reranking requires some approximations such as cube-pruning to integrate non-local features, it can explore larger search space than k-best reranking. The stacking approach (Nivre and McDonald, 2008; Martins et al., 2008) uses the output of one dependency parser to provide guide features for another. Stacking improves the parsing accuracy of second stage parsers on various language datasets. The joint graph-based and transition-based</context>
</contexts>
<marker>Sangati, Zuidema, Bod, 2009</marker>
<rawString>F. Sangati, W. Zuidema, and R. Bod. 2009. A generative re-ranking model for dependency parsing. In Proceedings of the 11th International Conference on Parsing Technologies (IWPT’09), pages 238–241.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S M Shieber</author>
<author>Y Schabes</author>
<author>F C N Pereira</author>
</authors>
<title>Principles and implementation of deductive parsing.</title>
<date>1995</date>
<journal>J. Log. Program.,</journal>
<pages>24--1</pages>
<contexts>
<context position="4803" citStr="Shieber et al., 1995" startWordPosition="774" endWordPosition="777">d graph-based models. • In contrast to joint transition-based/graphbased approaches (Zhang and Clark, 2008; Bohnet and Kuhn, 2012) which require a large beam size and make dynamic programming impractical, our two-stage approach can integrate both models with little loss of efficiency. In addition, the elimination of spurious ambiguity from the arc-standard shift-reduce parser improves the efficiency and accuracy of our approach. 2 Arc-Standard Shift-Reduce Parsing We use a beam search shift-reduce parser with dynamic programming as our baseline system. Figure 1 shows it as a deductive system (Shieber et al., 1995). A state is defined as the following: ℓ : (i, j, sd|sd−1 |... |s1|s0) : π where ℓ is the step size, [i, j] is the span of the topmost stack element s0, and sd|sd−1 |... |s1 shows a stack with d elements at the top, where d is the window size used for defining features. The axiom is initialized with an input sentence of length n, x = w0 ... wn where w0 is a special root symbol $0. The system takes 2n steps for a complete analysis. π is a set of pointers to the predictor states, each of which is the state just before shifting the root word s0.h.t o s0.lc.t o s0.lc2.t s0.h.t o s0.rc.t o s0.rc2.t</context>
</contexts>
<marker>Shieber, Schabes, Pereira, 1995</marker>
<rawString>S. M. Shieber, Y. Schabes, and F. C. N. Pereira. 1995. Principles and implementation of deductive parsing. J. Log. Program., 24(1&amp;2):3–36.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Sutton</author>
<author>M Sindelar</author>
<author>A McCallum</author>
</authors>
<title>Reducing weight undertraining in structured discriminative learning.</title>
<date>2006</date>
<booktitle>In Conference on Human Language Technology and North American Association for Computational Linguistics (HLT-NAACL).</booktitle>
<contexts>
<context position="19146" citStr="Sutton et al., 2006" startWordPosition="3250" endWordPosition="3253">s, and each fold is parsed by each of the spurious and non-spurious shift-reduce parsers using beam size 12 with the model trained on sentences from the remaining 19 folds, dumping the outputs as packed forests. The reranker is modeled by either equation (1) or (4). By our preliminary experiments using development data (WSJ22), we modeled the reranker with equation (1) when training, and with equation (4) when testing5 (i.e., the scores of the first-stage parser are not considered during training of the reranking model). This prevents the discriminative reranking features from under-training (Sutton et al., 2006; Hollingshead and Roark, 2008). A discriminative reranking model is trained on the packed forests by using the averaged perceptron algorithm with 5 iterations. When training nonlocal reranking models, we set k-best size of cubepruning to 5. For dumping packed forests for test data, spurious and non-spurious shift-reduce parsers are trained by the averaged perceptron algorithm. In all experiments on English data, we fixed beam size to 12 for training both parsers. 6.2 Test with Gold POS tags We show the comparison of dumped spurious and non-spurious packed forests for training data in Table 4.</context>
</contexts>
<marker>Sutton, Sindelar, McCallum, 2006</marker>
<rawString>C. Sutton, M. Sindelar, and A. McCallum. 2006. Reducing weight undertraining in structured discriminative learning. In Conference on Human Language Technology and North American Association for Computational Linguistics (HLT-NAACL).</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Yamada</author>
<author>Y Matsumoto</author>
</authors>
<title>Statistical dependency analysis with support vector machines.</title>
<date>2003</date>
<booktitle>In Proceedings of the 10th International Conference on Parsing Technologies (IWPT’03),</booktitle>
<pages>195--206</pages>
<contexts>
<context position="9591" citStr="Yamada and Matsumoto, 2003" startWordPosition="1638" endWordPosition="1641">ate and all the hyperedges going out from a vertex corresponding to the consequent state can be attached to the vertex corresponding to the antecedent state. The scan weight of the removed unary hyperedge is added to each weight of the hyperedges attached to the antecedent. 4 Experiments (Spurious Ambiguity vs. Non-Spurious Ambiguity) We conducted experiments on the English Penn Treebank (PTB) data to compare spurious and nonspurious shift-reduce parsers. We split the WSJ part of PTB into sections 02-21 for training, section 22 for development, and section 23 for test. We used the head rules (Yamada and Matsumoto, 2003) to convert phrase structure to dependency structure. 141 axiom(c0) : 0 : (0, 1, w0) : 0 goal(c3,,) : 3n : (0, n, s0) : 0 state p z } |{ ℓ :( , j, sd|sd−1 |... |s1|s0) : ℓ + 1 : (j,j + 1,sd−1|sd−2 |... |s0|w∗j) : (p) j&lt; n ℓ : (i, j, sd|sd−1 |... |s1|s∗0) : π ℓ + 1 : (i, j, sd|sd−1 |... |s1|s0) : π reduce↶ : reduce↷ : Figure 3: The dynamic programming arc-standard transition-based deductive system without spurious ambiguity: the symbol represents that the root node of the topmost element on the stack has not been scanned yet. 8 16 32 64 128 UAS (w/o punc.) 92.5 (93.5) 92.7 (93.6) 92.6 (93.6) 92</context>
</contexts>
<marker>Yamada, Matsumoto, 2003</marker>
<rawString>H. Yamada and Y. Matsumoto. 2003. Statistical dependency analysis with support vector machines. In Proceedings of the 10th International Conference on Parsing Technologies (IWPT’03), pages 195–206.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Zhang</author>
<author>S Clark</author>
</authors>
<title>A tale of two parsers: Investigating and combining graph-based and transitionbased dependency parsing using beam-search.</title>
<date>2008</date>
<booktitle>In Proceedings of the 2008 Conference on Empirical Methods in Natural Language Processing,</booktitle>
<pages>562--571</pages>
<contexts>
<context position="1883" citStr="Zhang and Clark, 2008" startWordPosition="266" endWordPosition="269">rder graph-based models achieve stateof-the-art accuracy, it has O(n4) time complexity for a sentence of length n. Recently, some pruning techniques have been proposed to improve the efficiency of third-order models (Rush and Petrov, 2012; Zhang and McDonald, 2012). The transition-based approach usually employs the shift-reduce parsing algorithm with linear-time complexity (Nivre, 2008). It greedily chooses the transition with the highest score and the resulting transition sequence is not always globally optimal. The beam search algorithm improves parsing flexibility in deterministic parsing (Zhang and Clark, 2008; Zhang and Nivre, 2011), and dynamic programming makes beam search more efficient (Huang and Sagae, 2010). There is also an alternative approach that integrates graph-based and transition-based models (Sagae and Lavie, 2006; Zhang and Clark, 2008; Nivre and McDonald, 2008; Martins et al., 2008). Martins et al. (2008) formulated their approach as stacking of parsers where the output of the first-stage parser is provided to the second as guide features. In particular, they used a transition-based parser for the first stage and a graph-based parser for the second stage. The main drawback of this</context>
<context position="4288" citStr="Zhang and Clark, 2008" startWordPosition="694" endWordPosition="697">standard transition-based dependency parsing system with dynamic programming: means “take anything”. a↷b denotes that a tree b is attached to a tree a. shift : state p � � 1 : (i, j, s′d|s′d−1 |... |s′ 1|s′0) : π′ state q � � 1 ℓ : (j, k, sd|sd−1 |... |s1|s0) : π s′ 0.h.w =� w0 n p E π ℓ + 1 : (i, k, s′ d|s′ d−1 |. . . |s′ 1|s′ 0↶s0) : π′ state p � � 1 : (i,j, s′d|s′d−1 |... |s′1|s′0) : π′ state q � � 1 ℓ : (j, k, sd|sd−1 |... |s1|s0) : π + 1 : i k s′ s′ _ s&apos; s′ ↷s π′ p E (&gt; , dI d-1 I lI 0 0) rated in standard graph-based models. • In contrast to joint transition-based/graphbased approaches (Zhang and Clark, 2008; Bohnet and Kuhn, 2012) which require a large beam size and make dynamic programming impractical, our two-stage approach can integrate both models with little loss of efficiency. In addition, the elimination of spurious ambiguity from the arc-standard shift-reduce parser improves the efficiency and accuracy of our approach. 2 Arc-Standard Shift-Reduce Parsing We use a beam search shift-reduce parser with dynamic programming as our baseline system. Figure 1 shows it as a deductive system (Shieber et al., 1995). A state is defined as the following: ℓ : (i, j, sd|sd−1 |... |s1|s0) : π where ℓ is</context>
<context position="30437" citStr="Zhang and Clark (2008)" startWordPosition="5076" endWordPosition="5079">ion and F-measure of grandchild structures whose grand parent is a sentence root symbol $. The results support the above assumption. The root correct rate directly influences on prediction of the overall structures of a sentence, and it is likely that the reduction of root prediction errors brings better results. 6.5 Experiments on Chinese We also experiment on the Penn Chinese Treebank (CTB5). Following Huang and Sagae (2010), we split it into training (secs 001-815 and 1001-1136), development (secs 886-931 and 1148-1151), and test (secs 816-885 and 1137-1147) sets, and use the head rules of Zhang and Clark (2008). The training set is split into 10 folds to dump packed forests for training of reranking models. We set the beam size of both spurious and nonspurious parsers to 12, and the number of perceptron training iterations to 25 for the parsers and to 8 for both rerankers. Table 14 shows the results for the test sets. As we expected, reranking on non-spurious forests outperforms that on spurious forests. 92.6 95.8 45.6 92.98 96.1 48.1 93.12 96.3 48.2 147 system UAS root comp. sr (12) 85.3 78.6 33.4 w/ non-local (12, k=3) 85.8 79.4 34.2 non-sp sr (12) 85.3 78.4 33.7 w/ non-local (12, k=3) 85.9 79.6 3</context>
<context position="33353" citStr="Zhang and Clark, 2008" startWordPosition="5521" endWordPosition="5524"> k-best dependency reranking algorithm using a third-order generative model, and Hayashi et al. (2011) extended it to a forest algorithm. Though forest reranking requires some approximations such as cube-pruning to integrate non-local features, it can explore larger search space than k-best reranking. The stacking approach (Nivre and McDonald, 2008; Martins et al., 2008) uses the output of one dependency parser to provide guide features for another. Stacking improves the parsing accuracy of second stage parsers on various language datasets. The joint graph-based and transition-based approach (Zhang and Clark, 2008; Bohnet and Kuhn, 2012) uses an arc-eager shift-reduce parser with a joint graph-based and transition-based model. Though it improves parsing accuracy significantly, the large beam size of the shift-reduce parser harms its efficiency. Sagae and Lavie (2006) showed that combining the outputs of graph-based and transitionbased parsers can improve parsing accuracies. 8 Conclusion We have presented a discriminative forest reranking algorithm for dependency parsing. This can be seen as a kind of joint transition-based and graph-based approach because the first-stage parser is a shiftreduce parser </context>
</contexts>
<marker>Zhang, Clark, 2008</marker>
<rawString>Y. Zhang and S. Clark. 2008. A tale of two parsers: Investigating and combining graph-based and transitionbased dependency parsing using beam-search. In Proceedings of the 2008 Conference on Empirical Methods in Natural Language Processing, pages 562–571.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Zhang</author>
<author>R McDonald</author>
</authors>
<title>Generalized higherorder dependency parsing with cube pruning.</title>
<date>2012</date>
<booktitle>In Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning,</booktitle>
<pages>320--331</pages>
<contexts>
<context position="1527" citStr="Zhang and McDonald, 2012" startWordPosition="216" endWordPosition="219">ing gave a state-of-the-art unlabeled dependency accuracy of 93.12. 1 Introduction There are two main approaches of data-driven dependency parsing – one is graph-based and the other is transition-based. In the graph-based approach, global optimization algorithms find the highest-scoring tree with locally factored models (McDonald et al., 2005). While third-order graph-based models achieve stateof-the-art accuracy, it has O(n4) time complexity for a sentence of length n. Recently, some pruning techniques have been proposed to improve the efficiency of third-order models (Rush and Petrov, 2012; Zhang and McDonald, 2012). The transition-based approach usually employs the shift-reduce parsing algorithm with linear-time complexity (Nivre, 2008). It greedily chooses the transition with the highest score and the resulting transition sequence is not always globally optimal. The beam search algorithm improves parsing flexibility in deterministic parsing (Zhang and Clark, 2008; Zhang and Nivre, 2011), and dynamic programming makes beam search more efficient (Huang and Sagae, 2010). There is also an alternative approach that integrates graph-based and transition-based models (Sagae and Lavie, 2006; Zhang and Clark, 2</context>
<context position="24983" citStr="Zhang and McDonald, 2012" startWordPosition="4222" endWordPosition="4225"> our systems were taken on Intel Core i7 2.8GHz. our proposed systems together with results from related work. The parsing times are reported in tokens/second for comparison. Note that, however, the difference of the parsing time does not represent the efficiency of the algorithm directly because each system was implemented in different programming language and the times were measured on different environments. The accuracy of local reranking on non-spurious forests is the best among unlabeled shift-reduce parsers, but slightly behind the third-order graphbased systems (Koo and Collins, 2010; Zhang and McDonald, 2012; Rush and Petrov, 2012). It is likely that the difference comes from the fact that our local reranking model can define only some of the grand-child related features. w/ guide. w/o guide. UAS 92.98 92.86 feature Linear (first) 89,330 89,215 CorePos (first) 1,047,948 1,053,796 TwoObs (first) 1,303,911 1,325,990 Sibling (second) 290,291 292,849 Trip (second) 19,333 19,267 Grand-child 16,975 16,951 Guide 4,934 – Tri-sibling 277,770 279,720 PP-Attachment 32,695 32,993 total 3,083,187 3,110,781 Table 9: Accuracy and the number of non-zero weighted features of the local reranking models with and wi</context>
<context position="32328" citStr="Zhang and McDonald, 2012" startWordPosition="5369" endWordPosition="5372">only with the projective case, but is simpler than theirs and we show its efficacy empirically through some experiments. The arc-eager shift-reduce parser also has a spurious ambiguity problem. Goldberg and Nivre (2012) addressed this problem by not only training with a canonical transition sequence but also with alternate optimal transitions that are calculated dynamically for a current state. 7.2 Methods to Improve Dependency Parsing Higher-order features like third-order dependency relations are essential to improve dependency parsing accuracy (Koo and Collins, 2010; Rush and Petrov, 2012; Zhang and McDonald, 2012). A reranking approach is one effective solution to introduce rich features to a parser model in the context of constituency parsing (Charniak and Johnson, 2005; Huang, 2008). Hall (2007) applied a k-best maximum spanning tree algorithm to non-projective dependency analysis, and showed that k-best discriminative reranking improves parsing accuracy in several languages. Sangati et al. (2009) proposed a k-best dependency reranking algorithm using a third-order generative model, and Hayashi et al. (2011) extended it to a forest algorithm. Though forest reranking requires some approximations such </context>
</contexts>
<marker>Zhang, McDonald, 2012</marker>
<rawString>H. Zhang and R. McDonald. 2012. Generalized higherorder dependency parsing with cube pruning. In Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning, pages 320–331.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Zhang</author>
<author>J Nivre</author>
</authors>
<title>Transition-based dependency parsing with rich non-local features.</title>
<date>2011</date>
<booktitle>In Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies,</booktitle>
<pages>188--193</pages>
<contexts>
<context position="1907" citStr="Zhang and Nivre, 2011" startWordPosition="270" endWordPosition="273"> achieve stateof-the-art accuracy, it has O(n4) time complexity for a sentence of length n. Recently, some pruning techniques have been proposed to improve the efficiency of third-order models (Rush and Petrov, 2012; Zhang and McDonald, 2012). The transition-based approach usually employs the shift-reduce parsing algorithm with linear-time complexity (Nivre, 2008). It greedily chooses the transition with the highest score and the resulting transition sequence is not always globally optimal. The beam search algorithm improves parsing flexibility in deterministic parsing (Zhang and Clark, 2008; Zhang and Nivre, 2011), and dynamic programming makes beam search more efficient (Huang and Sagae, 2010). There is also an alternative approach that integrates graph-based and transition-based models (Sagae and Lavie, 2006; Zhang and Clark, 2008; Nivre and McDonald, 2008; Martins et al., 2008). Martins et al. (2008) formulated their approach as stacking of parsers where the output of the first-stage parser is provided to the second as guide features. In particular, they used a transition-based parser for the first stage and a graph-based parser for the second stage. The main drawback of this approach is that the ef</context>
</contexts>
<marker>Zhang, Nivre, 2011</marker>
<rawString>Y. Zhang and J. Nivre. 2011. Transition-based dependency parsing with rich non-local features. In Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies, pages 188–193.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>