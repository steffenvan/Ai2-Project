<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.695112">
A COMPUTATIONAL MECHANISM FOR PRONOMINAL REFERENCE
</title>
<note confidence="0.8905075">
Robert J. P. lngria
David Stallard
BBN Systems and Technologies, Incorporated
10 Moulton Street
Mailstop 009
Cambridge, MA 02238
</note>
<sectionHeader confidence="0.916467" genericHeader="abstract">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.999604375">
This paper describes an implemented mechanism
for handling bound anaphora, disjoint reference, and
pronominal reference. The algorithm maps over
every node in a parse tree in a left-to-right, depth first
manner. Forward and backwards coreference, and
disjoint reference are assigned during this tree walk.
A semantic interpretation procedure is used to deal
with multiple antecedents.
</bodyText>
<sectionHeader confidence="0.999108" genericHeader="keywords">
1. INTRODUCTION
</sectionHeader>
<bodyText confidence="0.999839583333333">
This paper describes an implemented mechanism
for assigning antecedents to bound anaphors and per-
sonal pronouns, and for establishing disjoint reference
between Noun Phrases. This mechanism is part of
the BBN Spoken Language System (Boisen, et al.
(1989)). The algorithm used is inspired by the index-
ing scheme of Chomsky (1980), augmented by tables
analogous to the &amp;quot;Table of Coreference&amp;quot; of Jack-
endoff (1972). This mechanism handles only intra-
sentential phenomena and only selects the syntac-
tically and semantically possible antecedents. Ul-
timately, it is meant to be used in conjunction with an
extra-sentential reference mechanism like that
described in Ayuso (1989) to include antecedents
from other utterances and to utilize discourse factors
in its final selection of an antecedent.
In Section 2 the empirical and theoretical back-
ground to this treatment is sketched out. In Section 3,
the actual algorithm used is described in detail. In
Section 4, the associated semantic interpretation
mechanism is presented. In Section 5, we compare
the algorithm with related work. Finally, in Section 6,
remaining theoretical and implementational issues are
discussed.
</bodyText>
<sectionHeader confidence="0.999136" genericHeader="introduction">
2. THEORETICAL BACKGROUND
</sectionHeader>
<bodyText confidence="0.999449285714286">
While most computational systems are interested
in the potential antecedents of pronouns, work in
generative grammar by Lasnik (1976) and Reinhart
(1976) has led to the conclusion that sentential syntax
is responsible for assigning possible antecedents to
bound anaphors (reflexives, such as &amp;quot;himself&amp;quot;,
&amp;quot;herself&amp;quot;, &amp;quot;themselves&amp;quot;, etc., and the reciprocals
&amp;quot;each other&amp;quot; and &amp;quot;one another&amp;quot;) but not to personal
pronouns (&amp;quot;he&amp;quot;, &amp;quot;she&amp;quot;, &amp;quot;they&amp;quot;, etc). In the case of
personal pronouns, sentential syntax only determines
the syntactically impossible antecedents. This latter
procedure is called disjoint reference, since the im-
possible antecedents can not even overlap in refer-
ence with the pronoun; compare the cases in sen-
tences (1) and (2), where the underlined items are
non-identical in reference, with those in (3) and (4),
where they are non-overlapping in reference. In (1)
and (2), &amp;quot;he&amp;quot; and &amp;quot;him&amp;quot; cannot refer to &amp;quot;John&amp;quot; (non-
identical reference); while in (3) and (4) &amp;quot;John&amp;quot; cannot
be a member of the set referred to by &amp;quot;they&amp;quot; and
&amp;quot;them&amp;quot; (non-overlapping or disjoint reference).
</bodyText>
<listItem confidence="0.982349">
(1) He likes John. (3) They like John.
(2) John likes him. (4) John likes them.
</listItem>
<bodyText confidence="0.99708075">
Disjoint reference is even more noticeable with
first and second person pronouns where it does not
merely produce impossible interpretations, but actual
ungrammaticality:
</bodyText>
<listItem confidence="0.9847435">
(5) *I like me. (7) We like me.
(6) *I like us. (8) You like you.
</listItem>
<bodyText confidence="0.943019833333333">
A crucial notion both for assigining antecedents to
bound anaphors and for establishing disjoint refer-
ence between Noun Phrases is that of c-command, a
structural relation. Briefly, a node c-commands its
sisters and any nodes dominated by its sisters.1
Figure 2-1 illustrates this.
</bodyText>
<figure confidence="0.78305525">
A c-commands B, C, F, D, and G
B c-commands A and E
C c-commands D and G
D c-commands C and F
</figure>
<figureCaption confidence="0.95483">
Figure 2-1: C-Command
</figureCaption>
<note confidence="0.8021365">
&apos;This differs from Reinhart&apos;s (1976) definition, for reasons dis-
cussed in Section 6.
</note>
<page confidence="0.992396">
262
</page>
<bodyText confidence="0.8910595">
Essentially, the relation between c-comm and and
reference phenomena is the following:
</bodyText>
<listItem confidence="0.993574833333333">
1. A non-pronominal NP cannot overlap in
reference with any NP that c-commands it.
2. The antecedent of a bound anaphor must
c-command it.2
3. A personal pronoun cannot overlap in ref-
erence with an NP that c-commands it.2
</listItem>
<bodyText confidence="0.985657142857143">
Condition 1 is motivated by sentences such as
those in (9), where the underlined pronouns &amp;quot;he&amp;quot;,
&amp;quot;him&amp;quot;, &amp;quot;they&amp;quot;, and &amp;quot;them&amp;quot; must be disjoint in refer•
-
ence with &amp;quot;John&amp;quot;. In each case, the pronouns c-
command the NP &amp;quot;John&amp;quot;. In (9a) &amp;quot;he&amp;quot;/&amp;quot;they&amp;quot; is in the
subject position, and so c-commands &amp;quot;John&amp;quot;, in the
direct object slot. In (9b) the pronouns (&amp;quot;He&amp;quot;, &amp;quot;They&amp;quot;)
are once again in the subject position, and &amp;quot;John&amp;quot; is
the object of a preposition, itself contained in the
direct object of the sentence. Finally, in (9c), the NP
&amp;quot;John&amp;quot; appears as the object of a preposition, which
is c-commanded by the subject (&amp;quot;He&amp;quot;, &amp;quot;They&amp;quot;) and
the direct object (&amp;quot;him&amp;quot;, &amp;quot;them&amp;quot;).
</bodyText>
<listItem confidence="0.6493">
(9) a. He likes John.
They like John.
b. He likes pictures of John.
They like pictures of John.
c. He told them about John.
They told him about John.
</listItem>
<bodyText confidence="0.9956879">
Condition 2 is motivated by examples such as
those in (10), where the reflexive pronoun &amp;quot;himself&amp;quot;
and its antecedent(s) are bracketed. As in the cor-
responding examples in (9), &amp;quot;himself&amp;quot; either appears
as a direct object (10a), the object of a preposition
within the direct object (10b), or as a prepositional
object (10c). In all cases, the c-commanding subject
(&amp;quot;John&amp;quot;) is a possible antecedent; in (10c), where the
c-commanding object NP &amp;quot;Bill&amp;quot; is added, it is also a
possible antecedent.
</bodyText>
<listItem confidence="0.996030666666667">
(10) a. [John] likes [himself].
b. [John] likes pictures of [himself].
c. [John] told [Bill] about [himself].
</listItem>
<bodyText confidence="0.992531166666667">
Condition 3 is motivated by examples such as
those in (11). The pronoun under consideration
(&amp;quot;him&amp;quot; or &amp;quot;them&amp;quot;) always appears as an object or
prepositional object and is disjoint in reference to the
c-commanding subject &amp;quot;John&amp;quot; (in (11a.b,c)) and to the
c-commanding direct object &amp;quot;Bill&amp;quot; in (11c).
</bodyText>
<listItem confidence="0.968656333333333">
(11) a. John likes him.
John likes them.
b. John likes pictures of him.
John likes pictures of them.
c. John told Bill about him.
John told Bill about them.
</listItem>
<bodyText confidence="0.9934305">
While condition 1 is unconditionally true, con-
ditions 2 and 3 are subject to a further constraint,
</bodyText>
<subsectionHeader confidence="0.651204">
2Within a minimal syntactic domain; this will be explained shortly.
</subsectionHeader>
<bodyText confidence="0.786657619047619">
which we might term minimality. Essentially, the
structural theory of pronominal reference outlined
here may be viewed as making the following claim.
Bound anaphors are short-distance anaphors and re-
quire their antecedents to be c-commanding NPs
within a minimal domain. Ordinary personal
pronouns, on the other hand, are long-distance
anaphors, and only permit antecedents to come from
outside of their minimal domain, and exclude any c-
commanding antecedents within their minimal
domain. The most immediately dominating finite
clause (S) node always constitutes a minimal domain
for a bound anaphor or personal pronoun. NP nodes
normally do not constitute a minimal domain, unless
they contain a possessive. This is illustrated in
(12)--(14) (underlining indicates disjoint reference:
bracketing indicates co-reference). The subject NP in
(13) is not a possible antecedent for the reflexive;
while the subject NP in (14) need not be disjoint in
reference with the underlined pronoun. Compare (13)
with (10b) and (14) with (11 b).
</bodyText>
<listItem confidence="0.992861166666667">
(12) F.i ikelyleiks BeBill&apos;s picturesilrspictureso John.
They
f John. il
(13) John likes [Bill&apos;s] pictures of [himself].
(14) [John] likes Bill&apos;s pictures of ttril.
[John] likes Bill&apos;s pictures of [them].
</listItem>
<bodyText confidence="0.99710537037037">
Given these paradigms of reference facts, we now
turn to the theoretical linguistics literature for treat
ments that might be implemented in a natural Ian
guage system. In the Government-Binding framework
of Chomsky (1981), these generalizations are cap
tured by the Binding Theory—a set of well
formedness conditions on syntactic structural
representations annotated with subscript and super-
script &amp;quot;indices&amp;quot;. The paradigm assumed there is
Generate and Test: indices are freely assigned and
the Binding Conditions are applied to rule in or rule
out a particular assignment. Clearly, from a computa-
tional standpoint this is grossly inefficient. However,
in earlier work, Chomsky (1980, pp. 38--44) proposed
a two pass indexing mechanism that captures these
facts procedurally.
His proposal assigns each non-bound anaphor
(i.e. non-pronominal NP or personal pronoun) the pair
(r,A) where r (for Referential index) is a non-negative
integer and A (for Anaphoric index) is a set of such
integers. In the first pass, r and A are assigned from
left-to-right in a depth-first manner. Each non-bound
anaphor NP is assigned a unique r; in addition, the r
index of each NP c-commanding it is added to its A
index. This set of indices indicates all the other NPs
with which it &amp;quot; is disjoint in reference. For non-
pronominal NPs, only one pass is needed:
</bodyText>
<listItem confidence="0.576219">
(15) John2 told Bill(3.(21) about Fred(4,(2.3))
</listItem>
<bodyText confidence="0.9901926">
The indices here indicate that &amp;quot;John&amp;quot;, &amp;quot;Bill&amp;quot;, and
&apos;Fred&amp;quot; are all disjoint in reference.
In the case of personal pronouns, a second pass
$ necessary. Consider example (14), repeated here
as (16), after the first pass:
</bodyText>
<page confidence="0.992036">
263
</page>
<listItem confidence="0.37544">
(16) John2 likes Bill&apos;s(3,(20 pictures of him(4,{2.2})
</listItem>
<bodyText confidence="0.985659777777778">
The indexing at this stage indicates that &amp;quot;Bill&amp;quot; is dis-
joint in reference from &amp;quot;John&amp;quot; and that &amp;quot;him&amp;quot; is dis-
joint in reference from &amp;quot;Bill&amp;quot;, which is correct, and also
from &amp;quot;John&amp;quot;, which is not. To correct this, Chomsky
(1980, pp. 38-44) has a second pass, in which the r
indices of NPs outside the current minimal domain are
removed from the A index of personal pronouns,
thereby allowing them to serve as potential antece-
dents. After this second pass, the indexing is:
</bodyText>
<equation confidence="0.404592">
(17) John2 likes Bill&apos;s(3.{2}) pictures of him(4.01)
</equation>
<bodyText confidence="0.999794529411765">
At this stage &amp;quot;John&amp;quot; is no longer specified as being
disjoint in reference with &amp;quot;him&amp;quot;.
We have taken this procedure as the basis for a
more efficient pronominal reference algorithm that im-
proves on two problematic features. First, while
Chomsky&apos;s procedure requires two passes, our algo-
rithm is single pass. While there may not be a great
computational loss in the two-pass character of
Chomsky&apos;s original proposal, clearly it is cleaner to do
things in one pass. Moreover, the mechanism is ex-
tensionally richer than Chomsky&apos;s: it also handles
cases of backwards-pronominalization and split-
antecedence.
A second problem with Chomsky&apos;s procedure is
that the potential antecedents of a personal pronoun
are only implicitly represented: any NP whose r index
is not a member of that pronoun&apos;s A index set is a
syntactically permissible antecedent, but this set of
permissible antecedents is not enumerated. For ex-
ample, in (17), &amp;quot;John&amp;quot; is indicated as a potential an-
tecedent of &amp;quot;him&amp;quot; by virtue of the fact that its r index,
2, is not part of the A index of &amp;quot;him&amp;quot;, and in no other
way. Our algorithm explicitly indicates the potential
antecedents of a personal pronoun. Again, this is
more desirable than leaving this information implicit;
besides the potential (and perhaps small) computa-
tional savings of not needing to recompute this infor-
mation, there is the more general consideration that
we are not interested in creating syntactic represen-
tations for their own sakes, but to make use of them.
Explicitly representing antecedence information for
personal pronouns contributes to this goal.
In the next section, we show how our algorithm
overcomes these limitations.
</bodyText>
<sectionHeader confidence="0.997463" genericHeader="method">
3. THE ALGORITHM
</sectionHeader>
<bodyText confidence="0.999320063492064">
Before giving the details of the algorithm, we will
sketch its general structure. The algorithm applies to
a completed parse tree and traverses it in a left-to-
right, depth-first manner. The algorithm uses the no-
tion of minimal domain introduced in the preceding
section: the S node or NP node (when minimality has
been induced by the presence of a possessive) that
most immediately dominates the node being
processed, and the related notions of &amp;quot;internal&amp;quot; and
&amp;quot;external&amp;quot; nodes. Internal nodes are dominated by
the current minimal domain node; external nodes c-
command the current minimal domain node. Essen-
tially, the algorithm passes each node all the nodes
that c-command it, subdivided into two sets, those
that are internal to the current minimal domain and
those that are external. As each node is processed, a
subroutine is called that dispatches on the category of
the node and performs any actions that are ap-
propriate. It is this subroutine that implements the
pronominal reference mechanism proper.
Given this overview, we can now turn to the data
structures that are used by the algorithm, as well as to
the details of the algorithm. Each node in a parse tree
is a Common LISP structure; two of its slots are used
for establishing pronominal reference:
:possible-antecedents—a list of all the nodes that
can be co-referent or overlapping in reference with it.
:impossible-antecedents—a list of all the nodes
that are disjoint in reference with it.
The algorithm also uses two global
variables—lable-of-proforms* and
lable-of-antecedents*—in a &amp;quot;blackboard&amp;quot; fashion.
The algorithm uses two major procedures. The
first, pass-down-c-commanding-nodes, is respon-
sible for actually traversing each node in the tree.
The actual algorithm it uses is shown in Figure 6-1 in
a LISP-type notation. Its functionality can be stated
as follows. Whenever it encounters a new node, it
first processes that node by calling the procedure
update-node, which will be described shortly. It next
determines whether the node being processed counts
as a minimal domain for its children. When the node
is a finite S node, it does count as a minimal domain,
for all its children. Hence, only nodes that it
dominates can be internal nodes for its children; all
other nodes are now treated as external by its
children. When the node is an NP, there are two
possibilities. If there is no possessive NP, the NP
does not count as a minimal domain, hence, the ex-
ternal nodes remain as before and the nodes it
dominates are added to the set of internal nodes.
However, when the NP does contain a possessive, it
does count as a minimal domain, for all the nodes that
it dominates, except the possessive itself.3 Finally, if
the node is of any other category, it is not a minimal
domain, so the external nodes remain as before and
the internal nodes are augmented by the constituents
it dom inates.4 In all cases,
pass-down-c-commanding-nodes calls itself recur-
sively on the children of the node being processed,
with the appropriate lists of internal and external
nodes as arguments.
update-node, in turn, processes the node passed
</bodyText>
<footnote confidence="0.957323">
3The reason for this exception will be explained in Section 6.
&apos;Non-finite clauses also need special treatment. However, con-
sideration of this case requires discussion of whether non-finite
clauses are Sc or VPs, which is beyond the scope of this paper.
</footnote>
<page confidence="0.996004">
264
</page>
<bodyText confidence="0.999329705882353">
to it, on the basis of the nodes internal and external to
the current minimal domain. In particular,
update-node performs the correct pronominal assign-
ment. The algorithm used by update-node is shown
in Figure 6-2 in a LISP-type notation. We also dis-
cuss each clause separately.
Clause [I] implements condition 1 (non-pronominal
NPs). Since there are no minimality conditions on dis-
joint reference for non-pronominal NPs, all NP nodes
c-commanding a non-pronominal NP are added to its
:impossible-antecedents slot, whether they are in-
ternal ([I.A]) or external to the current minimal domain
([1.13]). This handles sentences such as those in (9)
and (12). While it might seem odd to specify that a
non-pronominal NP has no antecedents, this infor-
mation is useful in handling cases of backwards
pronominalization, as in (18).
</bodyText>
<listItem confidence="0.903679">
(18) [His] mother loves [John].
</listItem>
<bodyText confidence="0.999788064516129">
Clause [LC] handles backwards pronominalization by
making use of information in *table-of-proforms*, a
table of all the pronouns encountered so far in the
course of the tree walk.5 After update-node has
added all c-commanding NP nodes to the
:Impossible-antecedents slot of a non-pronominal
NP, it then searches lable-of-proforms&amp;quot; for any
pronouns that are not on its
:Impossible-antecedents list; whenever it finds one,
it adds the current non-pronominal NP to the
pronoun&apos;s :possible-antecedents list. The last thing
update-node does in processing a non-pronominal
NP is to add it to &apos;table-of-antecedents* ([I.Dj),
whose use will be explained shortly.
Clause [II] implements condition 2 (bound
anaphors). Since bound anaphors are short-distance
anaphors, all and only the c-commanding NPs internal
to the current minimal domain are added to the
:possible-antecedents slot of a bound anaphor.
Clause [III] implements condition 3 (personal
pronouns). Since personal pronouns are long-
distance anaphors, clause pi performs a number of
operations. First, all the c-commanding NPs internal
to the current minimal domain are added to the
:Impossible-antecedents slot of a personal pronoun
([111.AD, disallowing them as antecedents. Next, all
the c-commanding NPs external to the current min-
imal domain are added to the :possible-antecedents
slot of a personal pronoun ([111.131), indicating that they
are potential antecedents. Clause [III.C] handles sen-
tences like (19).
</bodyText>
<listItem confidence="0.914692">
(19) [John&apos;s] mother loves [him].
</listItem>
<bodyText confidence="0.9999354">
in which a non-pronominal NP that does not c-
command a personal pronoun serves as its antece-
dent. As was noted above, each non-pronominal NP
is added to the *table-of-antecedents&apos; by clause
[I.D]. When update-node has added all the ap-
</bodyText>
<subsectionHeader confidence="0.755018">
&apos;Ibis table a filled in by Clause (111.01.
</subsectionHeader>
<bodyText confidence="0.999947964285714">
propriate c-commanding nodes to the
:impossible-antecedents slot of a personal pronoun,
it then adds any NPs on *table-of-antecedents* that
are not already on the pronoun&apos;s
:impossible-antecedents slot to its
:possible-antecedents slot. Finally, when
update-node is finished processing a pronominal NP
node, it adds it to lable-of-proforms ([111.131), for use
in backwards pronominalization.
Note that, because our algorithm both establishes
minimal domains and assigns possible and impossible
antecedents during the course of the tree traversal, it
can be single pass, in contrast to Chomsky&apos;s proce-
dure, which assigned impossible antecedents in one
traversal and checked for minimality during a second.
Since update-node is a general mechanism for
adding or modifying information to a node on the
basis of c-commanding constituents it is fairly
straightforward to extend to handle other phenomena
that involve c-command by modifying its top level
CASE statement to dispatch on other categories. In
fact, we have extended it in this manner to handle
examples of &amp;quot;N anaphora&amp;quot;; i.e. cases where the head
noun of a Noun Phrase is either &amp;quot;one&amp;quot; (which has
been argued in Baker (1978) to be an anaphor for Ns,
i.e. a noun and its complements, but not for full Noun
Phrases) or phonologically null (0), which seems to
have the same possibilities for antecedents.
</bodyText>
<listItem confidence="0.6592558">
(20) Give me a list of ships which are in the
gulf of Alaska that have casualty reports
dated earlier than Esteem&apos;s oldest one.
(21) Is the Willamette&apos;s last problem rated
worse than Wichita&apos;s 0?
</listItem>
<figure confidence="0.958147384615385">
(when (pro-n-bar-p ofg-nodo)
(loop for othor-nodo
in external-node-liat
(when (and (equal (category
other-node)
&apos;NP)
(pro-n-bar-antecedent
other-node)
(add
(get-.on-of-category
other-node &apos;N-BAR)
(possible-antecedents
cfg-node) ) ) ) ) )
</figure>
<figureCaption confidence="0.7815915">
Figure 3-1: Algorithm for Pro N-BAR
Anaphora
</figureCaption>
<bodyText confidence="0.9998556">
The addition to the algorithm that deals with this
phenomenon is presented in Figure 3-1. This clause
is considerably simpler that those that handle disjoint
reference and co-reference phenomena for personal
pronouns: only external nodes are involved and only
forward antecedence is possible. This clause finds all
the Noun Phrases that c-command an N pro-form and
that are external to the current minimal domain. This
excludes the possessive in a Noun Phrase such as
&amp;quot;Esteem&apos;s oldest one&amp;quot; or &amp;quot;Wichita&apos;s 0&amp;quot; from serving
</bodyText>
<page confidence="0.990887">
265
</page>
<figure confidence="0.6604216">
(defun pass-down-c-commanding-nodes (cfg-node external-node-list internal-nods-list)
(update-node cfg-nodo external-node-list internal-node-list)
(cond ((finite-clause cfg-node)
(lot ((external-node-list (append intornal-node-list external-node-list)))
(loop for node in (children cfg-noddo)
(let ((internal-node-list (sisters node)))
(pass-down-c-commanding-nodes node
external-nods-list
intornal-node-list)))))
((equal (category cfg-nods) &apos;NP)
(cond ((equal (category (first (children cfg-node))) &apos;NP)
(pass-down-c-commanding-nodes (first (Children cfg-node))
external-node-list
internal-node-list)
(let ((external-node-list (append external-node-list internal-node-list)))
(loop for node in (rest (children cfg-node))
(let ((internal-nodo-list (sisters node)))
(pass-down-c-commanding-nodes node
external-node-list
internal-node-list)))))
(T (loop for node in (children cfg-nods)
(1st ((internal-node-list (append (sisters nods) internal-nods-list));
(pass-down-c-commanding-nodes node
external-nods-list
internal-node-list))))))
(T (loop for nods in (children ofg-node).
(let ((internal-node-list (append (sisters node) internal-nods-list)))
(pass-down-c-commanding-nodes nods
external-node-list
internal-node-list))))))
</figure>
<figureCaption confidence="0.960271">
Figure 6-1: TheTreeWalkingAlgorithm
</figureCaption>
<table confidence="0.969046517241379">
(defun update-node (cfg-node external-node-list internal-nods-list)
(case (category cfg-node)
(NP
(cond ((non-pronominal ofg-nods) [1]
(loop for other-node in extornal-node-list pfki
(when (equal (category other-node) &apos;NV)
(add other-nods (impossible-antecedents ofg-node))))
(loop for other-node in internal-nods-list [LB]
(when (equal (category other-nods) &apos;NP)
(add other-node (Impossible-antecedents cfg-node))))
(loop for pro in *table-of-proforms* [LC]
(when (not (member pro (impossible-antecedents cfg-node)))
(add cfg-node (possible-antecedents pro))))
(push ofg-nod. *table-of-antecedents*)) (1.0]
((bound-anaphor cfg-node)
(loop for other-node in internal-node-list
(when (equal (category other-nods) &apos;NV)
(add other-nods (possiblo-antecedonts cfg-nods)))))
((personal-pronoun cfg-node)
(loop for other-nods in internal-node-list pulti
(whim (equal (category other-node) &apos;NP)
(add other-node (impossible-antecedents ofg-node))))
(loop for other-node in external-node-list [KB]
(when (equal (category other-node) &apos;NP)
(add other-nods (possible-antecedents cfg-node))))
(loop for NP in *table-of-antecedents* [KC] -
(when (not (member NP (impossible-antecedents cfg-node)))
(add NP (possible-antecedents ofg-node))))
(Fish cfg-node *table-of-proforms*)))))) [MA
</table>
<figureCaption confidence="0.935924">
Figure 6-2: The Reference Algorithm
</figureCaption>
<page confidence="0.987768">
266
</page>
<bodyText confidence="0.999912">
as the antecedent to its pro-R. External NPs that
meet this criterion are filtered, since not all NPs can
be antecedents of an N anaphor. For example,
proper nouns cannot serve as such antecedents.
Each NP that meets these criteria has its N-BAR
added to the :possible-antecedents slot of the N-
BAR node being processed.
</bodyText>
<sectionHeader confidence="0.9999195" genericHeader="method">
4. INTERACTION WITH SEMANTIC
INTERPRETATION
</sectionHeader>
<bodyText confidence="0.999758813953489">
Syntactic constraints will not always identify just
one allowable referent for a pronoun. Consider (22):
(22) The committee awarded the prize to itself.
Syntactically, &amp;quot;itself&amp;quot; in this sentence can refer to ei-
ther &amp;quot;the prize&amp;quot; or &amp;quot;the committee&amp;quot;. The additional
use of semantic constraints is required to determine
that the proper referent of the reflexive pronoun is
&amp;quot;the committee&amp;quot;.
Applying such constraints is the responsibility of
the semantic interpretation component of our system.
In the current implementation reported on here,
semantic interpretation is applied after both parsing
and the c-command tree-traversal have been per-
formed. It is a two-stage process in which the first
stage is concerned with &amp;quot;structural semantics&amp;quot;—the
semantic consequence of syntactic structure—and
the second stage with &amp;quot;lexical semantics&amp;quot;—the
specific meanings of individual words with respect to a
given application domain. This architecture for
semantic interpretation was adopted from the
PHLIOA1 system (Bronnenberg, et al. (1980)) and
has been used in treating several difficult semantic
phenomena (de Bruin and Scha (1988); Scha and
Stallard (1988)).
The structural semantics stage operates on the
parse tree to produce an expression of a language
called &amp;quot;EFL&amp;quot; (for English-oriented Formal Language).
This language is a higher-order intensional logic
which includes a single descriptive constant for each
word in the lexicon, however many senses that word
may have. (From this standpoint, therefore, ER. is
actually an ambiguous logical language.) Expres-
sions of ER_ are produced from the parse tree by a
system of semantic rules, paired one-for-one with the
syntactic rules of the grammar, which compute the
ER translation of a tree node from the ER. trans-
lations of its daughter nodes. The single EFL of a
word is stored in its entry in the lexicon.
The lexical semantics stage operates on an ex-
pression of EFL to produce zero or more expressions
of a language called &amp;quot;WML&amp;quot; (for World Model
Language). WML is a higher-order intensional logic,
with the same set of operations as ER, but with un-
ambiguous descriptive constants which correspond to
the primitive concepts and relations of the particular
application domain. WML expressions also have
types, which are derived from the primitive disjoint
categories of the application domain and which serve
to delimit the set of meaningful WML expressions.
A set of translation rules pair ambiguous con-
stants of EFL with one or more unambiguous expres-
sions of WML. Translation to WML is performed by
producing all possible combinations formed from
replacing the EFL constants with their translations,
and filtering to remove combinations which are dis-
allowed by WML&apos;s type system. In this way selec-
tonal restrictions are represented and enforced.
The algorithms for producing EFL and WML are
slightly modified in the case of anaphoric consituents:
that is, reflexive pronouns, personal pronouns, and
pro N-BARs. When the structural semantics com-
ponent encounters an anaphoric constituent in the
course of translating a parse tree to EFL, it creates a
new EFL constant &amp;quot;on the fly&amp;quot; to serve as the EFL
translation of this constituent. It marks this constant
specially and attaches to it the EFL translations of the
syntactically possible antecedents of the constituent,
along with semantic type information (such as for
gender) constraining the antecedents which make
sense for it. If the constituent is a personal pronoun
or pro N-BAR (but not a reflexive pronoun), a special
constant of WML is also attached, marked with the
EFL translations of the impossible antecedents of the
constituent. This special WML constant represents
the possibility of extra-sentential resolution of the
anaphor.
The EFL to WML translation algorithm treats the
anaphoric EFL constant specially, returning as its
WML translations the translations of the &amp;quot;possible
antecedents&amp;quot; that were attached in the ER phase,
together with the WML constant for extra-sentential
reference (when this is appropriate). Expansion and
filtering then proceed as described above.
(22) is handled as follows. We will suppose the
following &amp;quot;domain model&amp;quot; of WML constants and
types:
</bodyText>
<sectionHeader confidence="0.976934666666667" genericHeader="method">
AWARD: (FUN (TUPLES AGENTS
VALUABLES AGENTS)
TV)
</sectionHeader>
<bodyText confidence="0.954631333333333">
SUB-TYPE(COMMITTEES,AGENTS)
SUB-TYPE(PRIZES,VALUABLES)
TYPE-INTERSECTION(VALUABLES,AGENTS)
NULL-SET
The structural semantics stage constructs the fol-
lowing clausal interpretation in EFL:
(AWARD (THE COMMITTEES) (THE PRIZES)
ITSELF001)
where
</bodyText>
<sectionHeader confidence="0.931327" genericHeader="method">
ITSELF001 (THE COMMITTEES)
(THE PRIZES)
</sectionHeader>
<page confidence="0.991448">
267
</page>
<bodyText confidence="0.999634">
The combinatorially possible WML translations are the
following, where anomally with respect to the type
system is marked with a &amp;quot;*&amp;quot;:
</bodyText>
<listItem confidence="0.6587115">
• (AWARD (THE COMMITTEES) (THE PRIZES)
(THE PRIZES))
</listItem>
<sectionHeader confidence="0.753949" genericHeader="method">
(AWARD (THE COMMITTEES) (THE PRIZES)
(THE COMMITTEES))
</sectionHeader>
<bodyText confidence="0.998346583333333">
The first interpretation is anomalous because the
function &amp;quot;AWARD&amp;quot; is applied to an argument whose
type is disjoint with the function&apos;s domain (in the third
argument place). It is therefore discarded, leaving the
second interpretation as the correct one.
A different example, in which a pronoun could
have an extra-sentential antecedent, is:
(23) The committee awarded the prize to it.
In this case, neither NP inside the sentence is syntac-
tically allowable as an antecedent of &amp;quot;it&amp;quot;, and so only
the extra-sentential possibility remains. The WML
translation for (23) is:
</bodyText>
<sectionHeader confidence="0.765103" genericHeader="method">
(AWARD (THE COMMITTEE) (THE PRIZES) IT001)
</sectionHeader>
<bodyText confidence="0.998036">
where IT001 is a WML constant marked for disjoint
reference:
</bodyText>
<sectionHeader confidence="0.993624" genericHeader="method">
IT001 * (THE COMMITTEES)
* (THE PRIZES)
</sectionHeader>
<bodyText confidence="0.999851846153846">
This information is necessary so that the module
responsible for extra-sentential discourse can prevent
external resolution of the pronoun to an internally
(syntactically) forbidden antecedent—as could other-
wise happen if &amp;quot;the committee&amp;quot; or &amp;quot;the prize&amp;quot; was
mentioned in preceding discourse.
Unless the anaphoric constituent is a reflexive
pronoun, an extra-sentential alternative will always be
present as a WML translation option, and survive type
filtering (since it is given the most general possible
type). When both intra- and extra-sentential alter-
natives survive type filtering, our current heuristic is to
prefer the intra-sentential one.
</bodyText>
<sectionHeader confidence="0.996665" genericHeader="method">
5. COMPARISON WITH RELATED WORK
</sectionHeader>
<bodyText confidence="0.997642808510638">
Hobbs (1978) has done the only previous work we
know of to use traversal of a syntactic parse tree to
determine pronominal reference and we compare our
algorithm with his in this section. Hobbs proposes a
syntactic tree-traversal algorithm for pronominal refer-
ence that is &amp;quot;part of a larger left-to-right interpretation
process&amp;quot; (Hobbs (1978, p. 318)). When a pronoun is
encountered, the algorithm moves up to the nearest S
or NP node (our &amp;quot;minimal domain nodes&amp;quot;) that
dominates the pronoun and searches to the left of the
pronoun for any NP nodes that are dominated by an
intervening $ or NP node to propose as antecedents.
The algorithm then proceeds up to the next NP or S
node and searches to the left of the pronoun for any
NP nodes to propose as antecedents. At this level,
search is also made to the right for NP nodes to
propose as antecedents. This will handle cases of
backwards pronominalization, as in (18). However,
this portion of the search is bounded; it does not seek
antecedents below any NP or S nodes encountered.
The search for c-commanding antecedents and an-
tecedents for backwards pronominalization continues
in this fashion until the top S is reached. At this point,
preceding utterances in the discourse are searched,
going from most recent to least recent. Each tree is
searched in a left-to-right, breadth-first manner for
NPs to propose as antecedents.
There are several differences between this algo-
rithm and ours. The major one is that our algorithm is
a single-pass, depth-first, exhaustive traversal
whereas Hobbs&apos; algorithm first walks down the tree,
then up, and then back down and is not guaranteed to
be exhaustive. Hobbs also imposes a &amp;quot;nearness&amp;quot;
condition on the search for antecedents in the case of
backwards pronominalization. However, as Hobbs
points out, this restriction rules out the perfectly ac-
ceptable (24a) and (24b).
(24) a. Mary sacked out in [his] apartment before
[Sam] could kick her out.
b. Girls who [he] has dated say that [Sam] is
charming.
These examples show that the question of what the
correct nearness constraint, if any, is remains open.
Finally, Hobbs&apos; algorithm handles both intra-sentential
and extra-sentential pronominal reference relations,
while ours is only intended to handle intra-sentential
cases.
</bodyText>
<sectionHeader confidence="0.9994655" genericHeader="method">
6. CURRENT STATUS AND FUTURE
RESEARCH
</sectionHeader>
<bodyText confidence="0.985304095238095">
In this section, we conclude by discussing some of
the strengths and weaknesses of the current im-
plementation and areas for future research. The
shortcomings fall into two general categories: limita-
tions of the implementation proper and limitations of
the theory of pronominal reference that was imple-
mented.
There are two general sorts of limitations to the
mechanism described here: those that may be over-
come by adding additional filtering devices to the
basic tree-walking engine and those that may require
a change in that basic engine. We begin with limita-
tions of the first sort.
Currently, the algorithm does not do any checking
on the potential antecedents of a pronoun or bound
anaphora to see if they agree in person and number.6
For bound anaphors, this is straightforward: a bound
anaphor and its antecedent must agree in person and
number. For personal pronouns, on the other hand,
&apos;Currently, NPs are not specified for gender in our system, so this
cannot be checked.
</bodyText>
<page confidence="0.994039">
268
</page>
<bodyText confidence="0.9577366">
the situation is more complicated. In the singular, first
(&amp;quot;I&amp;quot;, &amp;quot;me&amp;quot;), second (&amp;quot;you&amp;quot;), and third (&amp;quot;he&amp;quot;, &amp;quot;him&amp;quot;,
&amp;quot;she&amp;quot;, &amp;quot;her&amp;quot;, &amp;quot;it&amp;quot;) personal pronouns require agree-
ment in both person and number. In the plural,
however, the number requirement is dropped because
of &amp;quot;split antecedents&amp;quot; cases, in which more than one
NP forms part of the antecedent of a pronoun, as in:
(25) [John] told [Bill] that [they] should leave.
where &amp;quot;John&amp;quot; and &amp;quot;Bill&amp;quot;, together, antecede &amp;quot;they&amp;quot;.
Third person plural pronouns still require that each
antecedent of a split antecedent itself be third person.
First person (&amp;quot;we&amp;quot;, &amp;quot;us&amp;quot;) and second person
(&amp;quot;you&amp;quot;) pronouns also allow split antecedents, but
with looser person agreement requirements:
(26)da..
that [we] should go.
toolldlci[ly
Jouo that
thata t tyo[ uwl [we] shouldshould g og.o .
b.Io td (you]
</bodyText>
<listItem confidence="0.398408666666667">
c. [Bill] told [you] that [you] should go.
e. John told Bill that we should go.
f. John told Bill that yai should go.
</listItem>
<bodyText confidence="0.999559740740741">
Note that a first person plural pronoun allows split
antecedents only if at least one of them is itself first
person; contrast (26a) and (26b) with (26e). Similarly,
a second person plural pronoun allows split antece-
dents only if at least one of them is also second
person—contrast (26c) with (26f)—but not if one is
first person; contrast (26c) with (26d).
While the constraints on singular and third person
plural pronouns could be implemented as a local
agreement check (e.g. as a pre-condition for being
added to a pronoun&apos;s :possible-antecedents slot),
the person agreement constraint on first and second
person plural pronouns would require a separate post-
process, since it is not a local constraint on individual
split antecedents, but a global constraint on the set of
them. Currently, since our algorithm imposes no
agreement checks, it allows both the good cases of
split antecedents as well as the impossible ones. We
need to add the check to our algorithm and extend the
semantics to also deal with split antecedents.
The algorithm also does not check for &amp;quot;crossover&amp;quot;
cases. Roughly speaking, these are examples similar
to backwards pronominalization cases such as (18)
(repeated here as (27a)), in which the potential an-
tecedent is a quantifier or a trace of a moved WH
element. In such cases, overlapping reference is im-
possible. Contrast (27a) with (27b) and (27c).
</bodyText>
<listItem confidence="0.708969666666667">
(27) a. [His] mother loves [John].
b. His mother loves everyone.
c. Who does his mother love !who?
</listItem>
<bodyText confidence="0.976830953846154">
These particular cases can be handled by adding
a check to clause [LC] to prohibit quantified NPs and
WH-traces from participating in backwards
pronominalization. However, the more general
problem of how elements dislocated by WH move-
ment or by topicalization interact with the algorithm
given here is a topic that requires further work beyond
this simple measure.
More seriously, there is also a well-known case of
pronominal reference within NPs that is not handled
by the algorithm. A constraint from the syntactic
theory of reference implemented by our algorithm is
that if the antecedent-anaphor relation holds between
two positions, disjoint reference also holds between
them; see examples (10) and (11), and (13) and (14).
However, there is one position in English where this
generalization is known not to hold: the possessive
position of an NP. A bound anaphor is possible here,
but a pronoun in the same position is not subject to
disjoint reference; see (28):
(28) a. [The men] read [each other&apos;s] books.
b. [The men] read [their] books.
(28a) is correctly handled by the algorithm as al-
ready outlined; pass-down-c-commanding-nodes
treats the nodes internal to the current minimal
domain as internal nodes for the possessive in a
Noun Phrase, so the NP &amp;quot;the men&amp;quot; will be added to
the :possible-antecedents slot of a bound anaphor
in this position. However, the same characteristics of
the algorithm will also result in the NP &amp;quot;the men&amp;quot; be-
ing assigned to the :impossible-antecedents slot of
&amp;quot;their&amp;quot; in (28b). One possible remedy for this situa-
tion is to add a clause to update-node that checks for
possessive pronouns separately from other pronouns
and that allows NPs both internal and external to the
current minimal domain to be possible antecedents.
However, the more far-reaching modifications
proposed in the discussion below of the theory of
pronominal reference would obviate this change.
There are several areas where our implemen-
tation points out problems with the structural theory of
pronominal reference. The first of these is the defini-
tion of c-command itself.7 Under Reinhart&apos;s (1976)
original definition, a node A c-commands node B iff
the branching node most immediately dominating A
also dominates B and A does not dominate B. The
difference between the two definitions can be seen in
Figure 2-1; in addition to the c-command statements
given there, Reinhart&apos;s definition adds the following:
E c-commands B, C, F, D, and G
F c-commands D and G
G c-commands C and F
These statements are true under Reinhart&apos;s definition
of c-command, because no branching category inter-
venes between the c-commanding and c-commanded
nodes, but not under that used in the implemented
algorithm, since there is no sisterhood among the
nodes. We have found this modified definition to be
easier to implement; moreover, various researchers
(e.g. Aoun and Sportiche (1983)) have pointed out
problems with Reinhart&apos;s definition that the modified
definition solves.
?Our algorithm uses a definition that is equivalent to the in
construction with relation of Klima (1964, p. 297), which inspired
c-command.
</bodyText>
<page confidence="0.993107">
269
</page>
<bodyText confidence="0.9528186">
The implementation has also brought to light
asymmetries in the strictness of c-command used to
determine the antecedents of a bound anaphor and
that used to determine the non-antecedents of a
pronoun. In particular, none of the conjuncts of a
conjoined NP can be the antecedent of a reflexive:
(29) *John and Mary like himself.
However, all of the conjuncts of a conjoined NP are
impossible antecedents for any pronoun for which the
entire conjoined NP is an impossible antecedent. In
</bodyText>
<listItem confidence="0.529075">
(30) John and Mary like him.
</listItem>
<bodyText confidence="0.999779296296296">
&amp;quot;John&amp;quot; cannot be an antecedent of &amp;quot;him&amp;quot;, despite the
fact that &amp;quot;John&amp;quot; does not c-command &amp;quot;him&amp;quot;. Contrast
this with (19) where a non-c-commanding possessive
can be the antecedent of a pronoun. This is handled
correctly in the implementation. Whenever our algo-
rithm adds a conjoined NP to the
:impossible-antecedents slots of a pronoun or a
non-pronominal NP, it adds all the conjuncts of that
NP, as well. While this works, there is clearly some-
thing that is being missed here. Presumably, it should
follow by definition that no individual conjunct of a
conjoined NP can be a possible antecedent of a Noun
Phrase with which the entire conjoined NP is disjoint
in reference.°
A more serious problem with the theory of
pronominal reference elaborated in Chom sky (1980)
and (1981), and which our algorithm implements, is
the crucial assumption that referentially dependent
Noun Phrases can be exhaustively partitioned into
bound anaphors vs. personal pronouns and that,
therefore, they will be in complementary distribution.
However, examples such as (28), as well as (31)
(pointed out by Kuno (1987)) and (32) indicate that
the notion of exhaustive partitioning of bound
anaphors against personal pronouns is incorrect in
the general .case, even though it may be the typical
state of affairs.
</bodyText>
<listItem confidence="0.99277675">
(31) a. [John] put the blanket under [himself].
b. [John] put the blanket under [him].
(32) a. I&apos;ll buy myself a beer.
b. I&apos;ll buy me a beer.
</listItem>
<bodyText confidence="0.977482736842105">
We can keep the insight of the structural theory of
pronominal reference (i.e. that structural relations play
a role in delimiting reference possibilities), while still
incorporating these facts, if we give up the restriction
that bound anaphors and personal pronouns are al-
ways in complementary distribution. One possible ap-
proach to this problem is to use feature decomposition
to characterize bound anaphors and pronouns: the
feature ±short-distance indicates whether a
pronominal can be used as a short-distance anaphor
while the feature tIong-distance indicates whether it
*Thanks to Leland George for this insight, as well as for discussion
of short and long distance anaphors.
can be used as a long-distance anaphor.9. While, in
the normal case, personal pronouns in English are
specified to be long-distance anaphors that cannot be
used as short-distance anaphors, (i.e. as
[—short-distance +long-distance]) this system would
allow the feature governing a pronominal&apos;s use as a
short-distance anaphor to be left free (i.e. as
?short-distance) in certain syntactic contexts in
English, such as the possessive position of a Noun
Phrase, the object of certain prepositions, and the in-
direct object position of verbs.10 Such a view of the
syntax of personal pronouns could be implemented in
a unification grammar fairly straightforwardly.
While such a treatment of personal pronouns as
short-distance anaphors does not handle all the
counter-examples to the syntactic theory of
pronominal reference raised by researchers such as
Kuno, it does begin to address them seriously.
Clearly, it is more in accord with the facts than a
theory that postulates an exhaustive partitioning of
bound anaphors vs. personal pronouns, and so con-
stitutes, in our opinion, a promising start towards han-
dling the full range of pronoun reference facts in a
reasonable manner.
Finally, we consider alternate ways of combining
our pronominal reference mechanism with parsing
and semantic interpretation. One possibility is a fully
incremental architecture in which c-command con-
straints, semantic interpretations, and external refer-
ence resolution are computed simultaneously with the
parse. Such an architecture might seem particularly
attractive for processing large sets of alternatives,
such as are encountered when processing spoken in-
put. The intra-sentential reference phenomena
described in this paper pose a problem for such an
incremental approach, however. The possiblities for
internal resolution for an anaphor cannot all be known
locally to the anaphor, but must be obtained from
elsewhere in the sentence. In many cases antece-
dents will lie to the left of the anaphor in the sentence,
and thus will have been seen by a left-to-right parser
by the time the anaphor is reached. But consider a
case of backward pronominalization, as in (18),
repeated here as (33):
</bodyText>
<listItem confidence="0.336957">
(33) His mother loves John.
</listItem>
<bodyText confidence="0.999958">
A wholly incremental mechanism, parsing the NP &amp;quot;his
mother&amp;quot; first, would have to conclude that the referent
of &amp;quot;his&amp;quot; was extra-sentential, since no intra-sentential
referent was seen to the left. And if no extra-
sentential referent could be found, the NP would have
to be rejected. To be successful, such an incremental
mechanism would have to be modified to include a
kind of &amp;quot;lazy evaluation&amp;quot; which could rule out certain
</bodyText>
<footnote confidence="0.800498">
&apos;This is akin to the feature system tanaphorIc ipronomlnal of
Chomsky (1981)
&apos;eThis suggestion was originally made by Lust, et at, (1989) who
support it on the basis of language acquisition data.
</footnote>
<page confidence="0.990843">
270
</page>
<bodyText confidence="0.987362875">
referents for an anaphor but never rule an anaphor
empty of referents until utterance processing had
been corn pleted.
Another alternative would be to separate intra-
sentential anaphor resolution from semantic inter-
pretation, performing it instead in conjunction with
extra-sentential discourse processing. A possible
problem for this approach can be seen in sentences
where the anaphor is combined with another am-
biguous element, so that proliferation of semantic in-
terpretations occur, as in:
(34) John&apos;s car is better than Bill&apos;s.
where the pro N-BAR, left completely unspecified
during semantic interpretation, is free to generate all
sorts of combinations with the possessive, including
those in which the possession is appropriate to
various &amp;quot;relational&amp;quot; interpretations of the pro N-BAR
(de Bruin and Scha (1988)).
In future work, we plan to combine parsing and
semantic interpretation into a single unification gram-
mar incorporating semantic information in additional
features. Part of that work will be to look for the
optimal method of combining it with the pronominal
reference mechanism presented here.
</bodyText>
<sectionHeader confidence="0.997991" genericHeader="acknowledgments">
ACKNOWLEDGEMENTS
</sectionHeader>
<bodyText confidence="0.995621111111111">
The work reported here was supported by the Ad-
vanced Research Projects Agency under Contract No.
N00014-C-87-0085 monitored by the Office of Naval
Research. The views and conclusions contained in
this document are those of the author and should not
be interpreted as necessarily representing the official
policies, either expressed or implied, of the Defense
Advanced Research Projects Agency of the United
States Government.
</bodyText>
<sectionHeader confidence="0.999772" genericHeader="references">
REFERENCES
</sectionHeader>
<reference confidence="0.999800967213115">
Aoun, Yousef and Dominique Sportiche (1983) &amp;quot;On
the Formal Theory of Government&amp;quot;, The Linguistic
Review 2, pp. 211-236.
Ayuso, Damaris M. (1989) &amp;quot;Discourse Entities in
Janus&amp;quot;, 27th Annual Meeting of the Association
for Computational Linguistics: Proceedings of the
Conference, Association for Computational Lin-
guistics, Morristown, NJ.
Baker, C.L. (1978) Introduction to Generative-
Transformational Syntax, Prentice-Hall, Inc.,
Englewood Cliffs NJ.
Boisen S., Y. Chow, A. Haas, R. Ingria, S. Roucos,
R. Scha, D. Stallard and M. Vilain (1989)
Integration of Speech and Natural Language: Final
Report, Report No. 6991, BBN Systems and Tech-
nologies Corporation, Cambridge, Massachusetts.
Bronnenberg, W.J.H.J., Harry C. Bunt, S.P. Jan
Landsbergen, Remko J.H. Scha, W.J. Schoen-
makers, and E.P.C. van Utteren (1980) &amp;quot;The
Question Answering System PHLIQA1&amp;quot;, in
Leonard Bolc, ed., Natural Language Question
Answering Systems, Hanser, Munich, pp.
217-305.
Chomsky, Noam (1980) &amp;quot;On Binding&amp;quot;, Linguistic
Inquiry 11.1, pp. 1-46.
Chomsky, Noam (1981) Lectures on Government and
Binding, FORIS PUBLICATIONS, Dordrecht -
Holland/Cinnaminson - U.S.A.
de Bruin, Jos and Remko Scha (1988) The Inter-
pretation of Relational Nouns&amp;quot;, 26th Annual Meet-
ing of the Association for Computational Linguis-
tics: Proceedings of the Conference, Association
for Computational Linguistics, Morristown, NJ, pp.
25--32.
Hobbs, Jerry R. (1978) &amp;quot;Resolving Pronoun
References&amp;quot;, Lingua 44, pp. 311--338.
Jackendoff, Ray (1972) Semantic Interpretation in
Generative Grammar, MIT Press, Cambridge, MA.
Klima, Edward S. (1964) &amp;quot;Negation in English&amp;quot;, in
J. A. Fodor and J. J. Katz, eds., The Structure of
Language: Readings in the Philosophy of
Language, Prentice-Hall, Englewood Cliffs, N. J.
Kuno, Susumu (1987) Functional Syntax: Anaphora,
Discourse, and Empathy, The University of
Chicago Press, Chicago and London.
Lasnik, Howard (1976) &amp;quot;Remarks on Coreference&amp;quot;,
Linguistic Analysis 2.1, pp. 1--22.
Lust, Barbara, Reiko Mazuka, Gita Martohardjono,
and Jeong Me Yoon (1989) &amp;quot;On Parameter Set-
ting in First Language Acquisition: The Case of the
Binding Theory&amp;quot;, Paper presented at The 12th
GLOW Colloquium, Utrecht, April 5, 1989.
Reinhart, Tanya (1976) The Syntactic Domain of
Anaphora, Ph.D. Dissertation, MIT, Cambridge,
Massachusetts.
Scha, Remko and David Stallard (1988) &amp;quot;Multi-Level
Plurals and Distributivity&amp;quot;, 26th Annual Meeting of
the Association for Computational Linguistics:
Proceedings of the Conference, Association for
Computational Linguistics, Morristown, NJ, pp.
17-24.
</reference>
<page confidence="0.997792">
271
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.958873">
<title confidence="0.999717">A COMPUTATIONAL MECHANISM FOR PRONOMINAL REFERENCE</title>
<author confidence="0.9998615">Robert J P lngria David Stallard</author>
<affiliation confidence="0.976066">BBN Systems and Technologies, Incorporated</affiliation>
<address confidence="0.997501333333333">10 Moulton Street Mailstop 009 Cambridge, MA 02238</address>
<abstract confidence="0.998265333333333">This paper describes an implemented mechanism for handling bound anaphora, disjoint reference, and pronominal reference. The algorithm maps over every node in a parse tree in a left-to-right, depth first manner. Forward and backwards coreference, and disjoint reference are assigned during this tree walk. A semantic interpretation procedure is used to deal with multiple antecedents.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Yousef Aoun</author>
<author>Dominique Sportiche</author>
</authors>
<title>On the Formal Theory of Government&amp;quot;,</title>
<date>1983</date>
<journal>The Linguistic Review</journal>
<volume>2</volume>
<pages>211--236</pages>
<contexts>
<context position="37161" citStr="Aoun and Sportiche (1983)" startWordPosition="5729" endWordPosition="5732">B. The difference between the two definitions can be seen in Figure 2-1; in addition to the c-command statements given there, Reinhart&apos;s definition adds the following: E c-commands B, C, F, D, and G F c-commands D and G G c-commands C and F These statements are true under Reinhart&apos;s definition of c-command, because no branching category intervenes between the c-commanding and c-commanded nodes, but not under that used in the implemented algorithm, since there is no sisterhood among the nodes. We have found this modified definition to be easier to implement; moreover, various researchers (e.g. Aoun and Sportiche (1983)) have pointed out problems with Reinhart&apos;s definition that the modified definition solves. ?Our algorithm uses a definition that is equivalent to the in construction with relation of Klima (1964, p. 297), which inspired c-command. 269 The implementation has also brought to light asymmetries in the strictness of c-command used to determine the antecedents of a bound anaphor and that used to determine the non-antecedents of a pronoun. In particular, none of the conjuncts of a conjoined NP can be the antecedent of a reflexive: (29) *John and Mary like himself. However, all of the conjuncts of a </context>
</contexts>
<marker>Aoun, Sportiche, 1983</marker>
<rawString>Aoun, Yousef and Dominique Sportiche (1983) &amp;quot;On the Formal Theory of Government&amp;quot;, The Linguistic Review 2, pp. 211-236.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Damaris M Ayuso</author>
</authors>
<title>Discourse Entities in Janus&amp;quot;,</title>
<date>1989</date>
<booktitle>27th Annual Meeting of the Association for Computational Linguistics: Proceedings of the Conference, Association for Computational Linguistics,</booktitle>
<location>Morristown, NJ.</location>
<contexts>
<context position="1260" citStr="Ayuso (1989)" startWordPosition="183" endWordPosition="184">g antecedents to bound anaphors and personal pronouns, and for establishing disjoint reference between Noun Phrases. This mechanism is part of the BBN Spoken Language System (Boisen, et al. (1989)). The algorithm used is inspired by the indexing scheme of Chomsky (1980), augmented by tables analogous to the &amp;quot;Table of Coreference&amp;quot; of Jackendoff (1972). This mechanism handles only intrasentential phenomena and only selects the syntactically and semantically possible antecedents. Ultimately, it is meant to be used in conjunction with an extra-sentential reference mechanism like that described in Ayuso (1989) to include antecedents from other utterances and to utilize discourse factors in its final selection of an antecedent. In Section 2 the empirical and theoretical background to this treatment is sketched out. In Section 3, the actual algorithm used is described in detail. In Section 4, the associated semantic interpretation mechanism is presented. In Section 5, we compare the algorithm with related work. Finally, in Section 6, remaining theoretical and implementational issues are discussed. 2. THEORETICAL BACKGROUND While most computational systems are interested in the potential antecedents o</context>
</contexts>
<marker>Ayuso, 1989</marker>
<rawString>Ayuso, Damaris M. (1989) &amp;quot;Discourse Entities in Janus&amp;quot;, 27th Annual Meeting of the Association for Computational Linguistics: Proceedings of the Conference, Association for Computational Linguistics, Morristown, NJ.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C L Baker</author>
</authors>
<title>Introduction to GenerativeTransformational Syntax,</title>
<date>1978</date>
<publisher>Prentice-Hall, Inc.,</publisher>
<location>Englewood Cliffs NJ.</location>
<contexts>
<context position="18288" citStr="Baker (1978)" startWordPosition="2910" endWordPosition="2911">s, in contrast to Chomsky&apos;s procedure, which assigned impossible antecedents in one traversal and checked for minimality during a second. Since update-node is a general mechanism for adding or modifying information to a node on the basis of c-commanding constituents it is fairly straightforward to extend to handle other phenomena that involve c-command by modifying its top level CASE statement to dispatch on other categories. In fact, we have extended it in this manner to handle examples of &amp;quot;N anaphora&amp;quot;; i.e. cases where the head noun of a Noun Phrase is either &amp;quot;one&amp;quot; (which has been argued in Baker (1978) to be an anaphor for Ns, i.e. a noun and its complements, but not for full Noun Phrases) or phonologically null (0), which seems to have the same possibilities for antecedents. (20) Give me a list of ships which are in the gulf of Alaska that have casualty reports dated earlier than Esteem&apos;s oldest one. (21) Is the Willamette&apos;s last problem rated worse than Wichita&apos;s 0? (when (pro-n-bar-p ofg-nodo) (loop for othor-nodo in external-node-liat (when (and (equal (category other-node) &apos;NP) (pro-n-bar-antecedent other-node) (add (get-.on-of-category other-node &apos;N-BAR) (possible-antecedents cfg-node</context>
</contexts>
<marker>Baker, 1978</marker>
<rawString>Baker, C.L. (1978) Introduction to GenerativeTransformational Syntax, Prentice-Hall, Inc., Englewood Cliffs NJ.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Boisen</author>
<author>Y Chow</author>
<author>A Haas</author>
<author>R Ingria</author>
<author>S Roucos</author>
<author>R Scha</author>
<author>D Stallard</author>
<author>M Vilain</author>
</authors>
<date>1989</date>
<journal>Integration of Speech and Natural Language: Final</journal>
<booktitle>BBN Systems and Technologies Corporation,</booktitle>
<tech>Report, Report No. 6991,</tech>
<location>Cambridge, Massachusetts.</location>
<contexts>
<context position="844" citStr="Boisen, et al. (1989)" startWordPosition="117" endWordPosition="120">d mechanism for handling bound anaphora, disjoint reference, and pronominal reference. The algorithm maps over every node in a parse tree in a left-to-right, depth first manner. Forward and backwards coreference, and disjoint reference are assigned during this tree walk. A semantic interpretation procedure is used to deal with multiple antecedents. 1. INTRODUCTION This paper describes an implemented mechanism for assigning antecedents to bound anaphors and personal pronouns, and for establishing disjoint reference between Noun Phrases. This mechanism is part of the BBN Spoken Language System (Boisen, et al. (1989)). The algorithm used is inspired by the indexing scheme of Chomsky (1980), augmented by tables analogous to the &amp;quot;Table of Coreference&amp;quot; of Jackendoff (1972). This mechanism handles only intrasentential phenomena and only selects the syntactically and semantically possible antecedents. Ultimately, it is meant to be used in conjunction with an extra-sentential reference mechanism like that described in Ayuso (1989) to include antecedents from other utterances and to utilize discourse factors in its final selection of an antecedent. In Section 2 the empirical and theoretical background to this tr</context>
</contexts>
<marker>Boisen, Chow, Haas, Ingria, Roucos, Scha, Stallard, Vilain, 1989</marker>
<rawString>Boisen S., Y. Chow, A. Haas, R. Ingria, S. Roucos, R. Scha, D. Stallard and M. Vilain (1989) Integration of Speech and Natural Language: Final Report, Report No. 6991, BBN Systems and Technologies Corporation, Cambridge, Massachusetts.</rawString>
</citation>
<citation valid="true">
<title>The Question Answering System PHLIQA1&amp;quot;,</title>
<date>1980</date>
<booktitle>Natural Language Question Answering Systems,</booktitle>
<pages>217--305</pages>
<editor>Bronnenberg, W.J.H.J., Harry C. Bunt, S.P. Jan Landsbergen, Remko J.H. Scha, W.J. Schoenmakers, and E.P.C. van Utteren</editor>
<location>Hanser, Munich,</location>
<contexts>
<context position="918" citStr="(1980)" startWordPosition="133" endWordPosition="133">e algorithm maps over every node in a parse tree in a left-to-right, depth first manner. Forward and backwards coreference, and disjoint reference are assigned during this tree walk. A semantic interpretation procedure is used to deal with multiple antecedents. 1. INTRODUCTION This paper describes an implemented mechanism for assigning antecedents to bound anaphors and personal pronouns, and for establishing disjoint reference between Noun Phrases. This mechanism is part of the BBN Spoken Language System (Boisen, et al. (1989)). The algorithm used is inspired by the indexing scheme of Chomsky (1980), augmented by tables analogous to the &amp;quot;Table of Coreference&amp;quot; of Jackendoff (1972). This mechanism handles only intrasentential phenomena and only selects the syntactically and semantically possible antecedents. Ultimately, it is meant to be used in conjunction with an extra-sentential reference mechanism like that described in Ayuso (1989) to include antecedents from other utterances and to utilize discourse factors in its final selection of an antecedent. In Section 2 the empirical and theoretical background to this treatment is sketched out. In Section 3, the actual algorithm used is descri</context>
<context position="23430" citStr="(1980)" startWordPosition="3545" endWordPosition="3545">sponsibility of the semantic interpretation component of our system. In the current implementation reported on here, semantic interpretation is applied after both parsing and the c-command tree-traversal have been performed. It is a two-stage process in which the first stage is concerned with &amp;quot;structural semantics&amp;quot;—the semantic consequence of syntactic structure—and the second stage with &amp;quot;lexical semantics&amp;quot;—the specific meanings of individual words with respect to a given application domain. This architecture for semantic interpretation was adopted from the PHLIOA1 system (Bronnenberg, et al. (1980)) and has been used in treating several difficult semantic phenomena (de Bruin and Scha (1988); Scha and Stallard (1988)). The structural semantics stage operates on the parse tree to produce an expression of a language called &amp;quot;EFL&amp;quot; (for English-oriented Formal Language). This language is a higher-order intensional logic which includes a single descriptive constant for each word in the lexicon, however many senses that word may have. (From this standpoint, therefore, ER. is actually an ambiguous logical language.) Expressions of ER_ are produced from the parse tree by a system of semantic rule</context>
<context position="38678" citStr="(1980)" startWordPosition="5982" endWordPosition="5982">be the antecedent of a pronoun. This is handled correctly in the implementation. Whenever our algorithm adds a conjoined NP to the :impossible-antecedents slots of a pronoun or a non-pronominal NP, it adds all the conjuncts of that NP, as well. While this works, there is clearly something that is being missed here. Presumably, it should follow by definition that no individual conjunct of a conjoined NP can be a possible antecedent of a Noun Phrase with which the entire conjoined NP is disjoint in reference.° A more serious problem with the theory of pronominal reference elaborated in Chom sky (1980) and (1981), and which our algorithm implements, is the crucial assumption that referentially dependent Noun Phrases can be exhaustively partitioned into bound anaphors vs. personal pronouns and that, therefore, they will be in complementary distribution. However, examples such as (28), as well as (31) (pointed out by Kuno (1987)) and (32) indicate that the notion of exhaustive partitioning of bound anaphors against personal pronouns is incorrect in the general .case, even though it may be the typical state of affairs. (31) a. [John] put the blanket under [himself]. b. [John] put the blanket u</context>
</contexts>
<marker>1980</marker>
<rawString>Bronnenberg, W.J.H.J., Harry C. Bunt, S.P. Jan Landsbergen, Remko J.H. Scha, W.J. Schoenmakers, and E.P.C. van Utteren (1980) &amp;quot;The Question Answering System PHLIQA1&amp;quot;, in Leonard Bolc, ed., Natural Language Question Answering Systems, Hanser, Munich, pp. 217-305.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Noam Chomsky</author>
</authors>
<title>On Binding&amp;quot;,</title>
<date>1980</date>
<journal>Linguistic Inquiry</journal>
<volume>11</volume>
<pages>1--46</pages>
<contexts>
<context position="918" citStr="Chomsky (1980)" startWordPosition="132" endWordPosition="133">ence. The algorithm maps over every node in a parse tree in a left-to-right, depth first manner. Forward and backwards coreference, and disjoint reference are assigned during this tree walk. A semantic interpretation procedure is used to deal with multiple antecedents. 1. INTRODUCTION This paper describes an implemented mechanism for assigning antecedents to bound anaphors and personal pronouns, and for establishing disjoint reference between Noun Phrases. This mechanism is part of the BBN Spoken Language System (Boisen, et al. (1989)). The algorithm used is inspired by the indexing scheme of Chomsky (1980), augmented by tables analogous to the &amp;quot;Table of Coreference&amp;quot; of Jackendoff (1972). This mechanism handles only intrasentential phenomena and only selects the syntactically and semantically possible antecedents. Ultimately, it is meant to be used in conjunction with an extra-sentential reference mechanism like that described in Ayuso (1989) to include antecedents from other utterances and to utilize discourse factors in its final selection of an antecedent. In Section 2 the empirical and theoretical background to this treatment is sketched out. In Section 3, the actual algorithm used is descri</context>
<context position="7919" citStr="Chomsky (1980" startWordPosition="1247" endWordPosition="1248">al linguistics literature for treat ments that might be implemented in a natural Ian guage system. In the Government-Binding framework of Chomsky (1981), these generalizations are cap tured by the Binding Theory—a set of well formedness conditions on syntactic structural representations annotated with subscript and superscript &amp;quot;indices&amp;quot;. The paradigm assumed there is Generate and Test: indices are freely assigned and the Binding Conditions are applied to rule in or rule out a particular assignment. Clearly, from a computational standpoint this is grossly inefficient. However, in earlier work, Chomsky (1980, pp. 38--44) proposed a two pass indexing mechanism that captures these facts procedurally. His proposal assigns each non-bound anaphor (i.e. non-pronominal NP or personal pronoun) the pair (r,A) where r (for Referential index) is a non-negative integer and A (for Anaphoric index) is a set of such integers. In the first pass, r and A are assigned from left-to-right in a depth-first manner. Each non-bound anaphor NP is assigned a unique r; in addition, the r index of each NP c-commanding it is added to its A index. This set of indices indicates all the other NPs with which it &amp;quot; is disjoint in </context>
</contexts>
<marker>Chomsky, 1980</marker>
<rawString>Chomsky, Noam (1980) &amp;quot;On Binding&amp;quot;, Linguistic Inquiry 11.1, pp. 1-46.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Noam Chomsky</author>
</authors>
<date>1981</date>
<booktitle>Lectures on Government and Binding, FORIS PUBLICATIONS, Dordrecht -Holland/Cinnaminson -</booktitle>
<publisher>U.S.A.</publisher>
<contexts>
<context position="7458" citStr="Chomsky (1981)" startWordPosition="1179" endWordPosition="1180"> is not a possible antecedent for the reflexive; while the subject NP in (14) need not be disjoint in reference with the underlined pronoun. Compare (13) with (10b) and (14) with (11 b). (12) F.i ikelyleiks BeBill&apos;s picturesilrspictureso John. They f John. il (13) John likes [Bill&apos;s] pictures of [himself]. (14) [John] likes Bill&apos;s pictures of ttril. [John] likes Bill&apos;s pictures of [them]. Given these paradigms of reference facts, we now turn to the theoretical linguistics literature for treat ments that might be implemented in a natural Ian guage system. In the Government-Binding framework of Chomsky (1981), these generalizations are cap tured by the Binding Theory—a set of well formedness conditions on syntactic structural representations annotated with subscript and superscript &amp;quot;indices&amp;quot;. The paradigm assumed there is Generate and Test: indices are freely assigned and the Binding Conditions are applied to rule in or rule out a particular assignment. Clearly, from a computational standpoint this is grossly inefficient. However, in earlier work, Chomsky (1980, pp. 38--44) proposed a two pass indexing mechanism that captures these facts procedurally. His proposal assigns each non-bound anaphor (i</context>
<context position="42731" citStr="Chomsky (1981)" startWordPosition="6614" endWordPosition="6615"> But consider a case of backward pronominalization, as in (18), repeated here as (33): (33) His mother loves John. A wholly incremental mechanism, parsing the NP &amp;quot;his mother&amp;quot; first, would have to conclude that the referent of &amp;quot;his&amp;quot; was extra-sentential, since no intra-sentential referent was seen to the left. And if no extrasentential referent could be found, the NP would have to be rejected. To be successful, such an incremental mechanism would have to be modified to include a kind of &amp;quot;lazy evaluation&amp;quot; which could rule out certain &apos;This is akin to the feature system tanaphorIc ipronomlnal of Chomsky (1981) &apos;eThis suggestion was originally made by Lust, et at, (1989) who support it on the basis of language acquisition data. 270 referents for an anaphor but never rule an anaphor empty of referents until utterance processing had been corn pleted. Another alternative would be to separate intrasentential anaphor resolution from semantic interpretation, performing it instead in conjunction with extra-sentential discourse processing. A possible problem for this approach can be seen in sentences where the anaphor is combined with another ambiguous element, so that proliferation of semantic interpretati</context>
</contexts>
<marker>Chomsky, 1981</marker>
<rawString>Chomsky, Noam (1981) Lectures on Government and Binding, FORIS PUBLICATIONS, Dordrecht -Holland/Cinnaminson - U.S.A.</rawString>
</citation>
<citation valid="true">
<authors>
<author>de Bruin</author>
</authors>
<title>Jos and Remko Scha</title>
<date>1988</date>
<booktitle>26th Annual Meeting of the Association for Computational Linguistics: Proceedings of the Conference, Association for Computational Linguistics,</booktitle>
<pages>25--32</pages>
<location>Morristown, NJ,</location>
<marker>de Bruin, 1988</marker>
<rawString>de Bruin, Jos and Remko Scha (1988) The Interpretation of Relational Nouns&amp;quot;, 26th Annual Meeting of the Association for Computational Linguistics: Proceedings of the Conference, Association for Computational Linguistics, Morristown, NJ, pp. 25--32.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jerry R Hobbs</author>
</authors>
<title>Resolving Pronoun References&amp;quot;,</title>
<date>1978</date>
<journal>Lingua</journal>
<volume>44</volume>
<pages>311--338</pages>
<contexts>
<context position="28571" citStr="Hobbs (1978)" startWordPosition="4327" endWordPosition="4328">al discourse can prevent external resolution of the pronoun to an internally (syntactically) forbidden antecedent—as could otherwise happen if &amp;quot;the committee&amp;quot; or &amp;quot;the prize&amp;quot; was mentioned in preceding discourse. Unless the anaphoric constituent is a reflexive pronoun, an extra-sentential alternative will always be present as a WML translation option, and survive type filtering (since it is given the most general possible type). When both intra- and extra-sentential alternatives survive type filtering, our current heuristic is to prefer the intra-sentential one. 5. COMPARISON WITH RELATED WORK Hobbs (1978) has done the only previous work we know of to use traversal of a syntactic parse tree to determine pronominal reference and we compare our algorithm with his in this section. Hobbs proposes a syntactic tree-traversal algorithm for pronominal reference that is &amp;quot;part of a larger left-to-right interpretation process&amp;quot; (Hobbs (1978, p. 318)). When a pronoun is encountered, the algorithm moves up to the nearest S or NP node (our &amp;quot;minimal domain nodes&amp;quot;) that dominates the pronoun and searches to the left of the pronoun for any NP nodes that are dominated by an intervening $ or NP node to propose as </context>
</contexts>
<marker>Hobbs, 1978</marker>
<rawString>Hobbs, Jerry R. (1978) &amp;quot;Resolving Pronoun References&amp;quot;, Lingua 44, pp. 311--338.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ray Jackendoff</author>
</authors>
<title>Semantic Interpretation in Generative Grammar,</title>
<date>1972</date>
<publisher>MIT Press,</publisher>
<location>Cambridge, MA.</location>
<contexts>
<context position="1000" citStr="Jackendoff (1972)" startWordPosition="144" endWordPosition="146">pth first manner. Forward and backwards coreference, and disjoint reference are assigned during this tree walk. A semantic interpretation procedure is used to deal with multiple antecedents. 1. INTRODUCTION This paper describes an implemented mechanism for assigning antecedents to bound anaphors and personal pronouns, and for establishing disjoint reference between Noun Phrases. This mechanism is part of the BBN Spoken Language System (Boisen, et al. (1989)). The algorithm used is inspired by the indexing scheme of Chomsky (1980), augmented by tables analogous to the &amp;quot;Table of Coreference&amp;quot; of Jackendoff (1972). This mechanism handles only intrasentential phenomena and only selects the syntactically and semantically possible antecedents. Ultimately, it is meant to be used in conjunction with an extra-sentential reference mechanism like that described in Ayuso (1989) to include antecedents from other utterances and to utilize discourse factors in its final selection of an antecedent. In Section 2 the empirical and theoretical background to this treatment is sketched out. In Section 3, the actual algorithm used is described in detail. In Section 4, the associated semantic interpretation mechanism is p</context>
</contexts>
<marker>Jackendoff, 1972</marker>
<rawString>Jackendoff, Ray (1972) Semantic Interpretation in Generative Grammar, MIT Press, Cambridge, MA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Edward S Klima</author>
</authors>
<title>Negation in English&amp;quot;,</title>
<date>1964</date>
<booktitle>The Structure of Language: Readings in the Philosophy of Language, Prentice-Hall,</booktitle>
<editor>in J. A. Fodor and J. J. Katz, eds.,</editor>
<location>Englewood</location>
<contexts>
<context position="37356" citStr="Klima (1964" startWordPosition="5760" endWordPosition="5761">ds D and G G c-commands C and F These statements are true under Reinhart&apos;s definition of c-command, because no branching category intervenes between the c-commanding and c-commanded nodes, but not under that used in the implemented algorithm, since there is no sisterhood among the nodes. We have found this modified definition to be easier to implement; moreover, various researchers (e.g. Aoun and Sportiche (1983)) have pointed out problems with Reinhart&apos;s definition that the modified definition solves. ?Our algorithm uses a definition that is equivalent to the in construction with relation of Klima (1964, p. 297), which inspired c-command. 269 The implementation has also brought to light asymmetries in the strictness of c-command used to determine the antecedents of a bound anaphor and that used to determine the non-antecedents of a pronoun. In particular, none of the conjuncts of a conjoined NP can be the antecedent of a reflexive: (29) *John and Mary like himself. However, all of the conjuncts of a conjoined NP are impossible antecedents for any pronoun for which the entire conjoined NP is an impossible antecedent. In (30) John and Mary like him. &amp;quot;John&amp;quot; cannot be an antecedent of &amp;quot;him&amp;quot;, des</context>
</contexts>
<marker>Klima, 1964</marker>
<rawString>Klima, Edward S. (1964) &amp;quot;Negation in English&amp;quot;, in J. A. Fodor and J. J. Katz, eds., The Structure of Language: Readings in the Philosophy of Language, Prentice-Hall, Englewood Cliffs, N. J.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Susumu Kuno</author>
</authors>
<title>Functional Syntax: Anaphora, Discourse, and Empathy,</title>
<date>1987</date>
<institution>The University of Chicago Press, Chicago and London.</institution>
<contexts>
<context position="39009" citStr="Kuno (1987)" startWordPosition="6030" endWordPosition="6031">y, it should follow by definition that no individual conjunct of a conjoined NP can be a possible antecedent of a Noun Phrase with which the entire conjoined NP is disjoint in reference.° A more serious problem with the theory of pronominal reference elaborated in Chom sky (1980) and (1981), and which our algorithm implements, is the crucial assumption that referentially dependent Noun Phrases can be exhaustively partitioned into bound anaphors vs. personal pronouns and that, therefore, they will be in complementary distribution. However, examples such as (28), as well as (31) (pointed out by Kuno (1987)) and (32) indicate that the notion of exhaustive partitioning of bound anaphors against personal pronouns is incorrect in the general .case, even though it may be the typical state of affairs. (31) a. [John] put the blanket under [himself]. b. [John] put the blanket under [him]. (32) a. I&apos;ll buy myself a beer. b. I&apos;ll buy me a beer. We can keep the insight of the structural theory of pronominal reference (i.e. that structural relations play a role in delimiting reference possibilities), while still incorporating these facts, if we give up the restriction that bound anaphors and personal prono</context>
</contexts>
<marker>Kuno, 1987</marker>
<rawString>Kuno, Susumu (1987) Functional Syntax: Anaphora, Discourse, and Empathy, The University of Chicago Press, Chicago and London.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Howard Lasnik</author>
</authors>
<title>Remarks on Coreference&amp;quot;,</title>
<date>1976</date>
<journal>Linguistic Analysis</journal>
<volume>2</volume>
<pages>1--22</pages>
<contexts>
<context position="1915" citStr="Lasnik (1976)" startWordPosition="280" endWordPosition="281">ces and to utilize discourse factors in its final selection of an antecedent. In Section 2 the empirical and theoretical background to this treatment is sketched out. In Section 3, the actual algorithm used is described in detail. In Section 4, the associated semantic interpretation mechanism is presented. In Section 5, we compare the algorithm with related work. Finally, in Section 6, remaining theoretical and implementational issues are discussed. 2. THEORETICAL BACKGROUND While most computational systems are interested in the potential antecedents of pronouns, work in generative grammar by Lasnik (1976) and Reinhart (1976) has led to the conclusion that sentential syntax is responsible for assigning possible antecedents to bound anaphors (reflexives, such as &amp;quot;himself&amp;quot;, &amp;quot;herself&amp;quot;, &amp;quot;themselves&amp;quot;, etc., and the reciprocals &amp;quot;each other&amp;quot; and &amp;quot;one another&amp;quot;) but not to personal pronouns (&amp;quot;he&amp;quot;, &amp;quot;she&amp;quot;, &amp;quot;they&amp;quot;, etc). In the case of personal pronouns, sentential syntax only determines the syntactically impossible antecedents. This latter procedure is called disjoint reference, since the impossible antecedents can not even overlap in reference with the pronoun; compare the cases in sentences (1) and (2),</context>
</contexts>
<marker>Lasnik, 1976</marker>
<rawString>Lasnik, Howard (1976) &amp;quot;Remarks on Coreference&amp;quot;, Linguistic Analysis 2.1, pp. 1--22.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Barbara Lust</author>
<author>Reiko Mazuka</author>
<author>Gita Martohardjono</author>
<author>Jeong Me Yoon</author>
</authors>
<title>On Parameter Setting in First Language Acquisition: The Case of the Binding Theory&amp;quot;, Paper presented at The 12th GLOW Colloquium,</title>
<date>1989</date>
<location>Utrecht,</location>
<marker>Lust, Mazuka, Martohardjono, Yoon, 1989</marker>
<rawString>Lust, Barbara, Reiko Mazuka, Gita Martohardjono, and Jeong Me Yoon (1989) &amp;quot;On Parameter Setting in First Language Acquisition: The Case of the Binding Theory&amp;quot;, Paper presented at The 12th GLOW Colloquium, Utrecht, April 5, 1989.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tanya Reinhart</author>
</authors>
<title>The Syntactic Domain of Anaphora,</title>
<date>1976</date>
<location>Ph.D. Dissertation, MIT, Cambridge, Massachusetts.</location>
<contexts>
<context position="1935" citStr="Reinhart (1976)" startWordPosition="283" endWordPosition="284"> discourse factors in its final selection of an antecedent. In Section 2 the empirical and theoretical background to this treatment is sketched out. In Section 3, the actual algorithm used is described in detail. In Section 4, the associated semantic interpretation mechanism is presented. In Section 5, we compare the algorithm with related work. Finally, in Section 6, remaining theoretical and implementational issues are discussed. 2. THEORETICAL BACKGROUND While most computational systems are interested in the potential antecedents of pronouns, work in generative grammar by Lasnik (1976) and Reinhart (1976) has led to the conclusion that sentential syntax is responsible for assigning possible antecedents to bound anaphors (reflexives, such as &amp;quot;himself&amp;quot;, &amp;quot;herself&amp;quot;, &amp;quot;themselves&amp;quot;, etc., and the reciprocals &amp;quot;each other&amp;quot; and &amp;quot;one another&amp;quot;) but not to personal pronouns (&amp;quot;he&amp;quot;, &amp;quot;she&amp;quot;, &amp;quot;they&amp;quot;, etc). In the case of personal pronouns, sentential syntax only determines the syntactically impossible antecedents. This latter procedure is called disjoint reference, since the impossible antecedents can not even overlap in reference with the pronoun; compare the cases in sentences (1) and (2), where the underline</context>
</contexts>
<marker>Reinhart, 1976</marker>
<rawString>Reinhart, Tanya (1976) The Syntactic Domain of Anaphora, Ph.D. Dissertation, MIT, Cambridge, Massachusetts.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Remko Scha</author>
<author>David Stallard</author>
</authors>
<title>Multi-Level Plurals and Distributivity&amp;quot;,</title>
<date>1988</date>
<booktitle>26th Annual Meeting of the Association for Computational Linguistics: Proceedings of the Conference, Association for Computational Linguistics,</booktitle>
<pages>17--24</pages>
<location>Morristown, NJ,</location>
<contexts>
<context position="23550" citStr="Scha and Stallard (1988)" startWordPosition="3561" endWordPosition="3564">orted on here, semantic interpretation is applied after both parsing and the c-command tree-traversal have been performed. It is a two-stage process in which the first stage is concerned with &amp;quot;structural semantics&amp;quot;—the semantic consequence of syntactic structure—and the second stage with &amp;quot;lexical semantics&amp;quot;—the specific meanings of individual words with respect to a given application domain. This architecture for semantic interpretation was adopted from the PHLIOA1 system (Bronnenberg, et al. (1980)) and has been used in treating several difficult semantic phenomena (de Bruin and Scha (1988); Scha and Stallard (1988)). The structural semantics stage operates on the parse tree to produce an expression of a language called &amp;quot;EFL&amp;quot; (for English-oriented Formal Language). This language is a higher-order intensional logic which includes a single descriptive constant for each word in the lexicon, however many senses that word may have. (From this standpoint, therefore, ER. is actually an ambiguous logical language.) Expressions of ER_ are produced from the parse tree by a system of semantic rules, paired one-for-one with the syntactic rules of the grammar, which compute the ER translation of a tree node from the </context>
</contexts>
<marker>Scha, Stallard, 1988</marker>
<rawString>Scha, Remko and David Stallard (1988) &amp;quot;Multi-Level Plurals and Distributivity&amp;quot;, 26th Annual Meeting of the Association for Computational Linguistics: Proceedings of the Conference, Association for Computational Linguistics, Morristown, NJ, pp. 17-24.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>