<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.969878">
Another Facet of LIG Parsing
</title>
<author confidence="0.918496">
Pierre Boullier
</author>
<affiliation confidence="0.827848">
INRIA-Rocquencourt
</affiliation>
<address confidence="0.885107">
BP 105
78153 Le Chesnay Cedex, France
</address>
<email confidence="0.997298">
Pierre.Boullier@inria.fr
</email>
<sectionHeader confidence="0.998566" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999680555555556">
In this paperl we present a new pars-
ing algorithm for linear indexed grammars
(LIGs) in the same spirit as the one de-
scribed in (Vijay-Shanker and Weir, 1993)
for tree adjoining grammars. For a LIG L
and an input string x of length n, we build
a non ambiguous context-free grammar
whose sentences are all (and exclusively)
valid derivation sequences in L which lead
to x. We show that this grammar can
be built in 0(n6) time and that individ-
ual parses can be extracted in linear time
with the size of the extracted parse tree.
Though this 0(n6) upper bound does not
improve over previous results, the average
case behaves much better. Moreover, prac-
tical parsing times can be decreased by
some statically performed computations.
</bodyText>
<sectionHeader confidence="0.999471" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.9949516875">
The class of mildly context-sensitive languages can
be described by several equivalent grammar types.
Among these types we can notably cite tree adjoin-
ing grammars (TAGs) and linear indexed grammars
(LIGs). In (Vijay-Shanker and Weir, 1994) TAGs
are transformed into equivalent LIGs. Though
context-sensitive linguistic phenomena seem to be
more naturally expressed in TAG formalism, from
a computational point of view, many authors think
that LIGs play a central role and therefore the un-
derstanding of LIGs and LIG parsing is of impor-
tance. For example, quoted from (Schabes and
Shieber, 1994) &amp;quot;The LIG version of TAG can be used
for recognition and parsing. Because the LIG for-
malism is based on augmented rewriting, the pars-
ing algorithms can be much simpler to understand
</bodyText>
<footnote confidence="0.806302">
1See (Boullier, 1996) for an extended version.
</footnote>
<bodyText confidence="0.954839457142857">
and easier to modify, and no loss of generality is in-
curred&amp;quot;. In (Vijay-Shanker and Weir, 1993) LIGs
are used to express the derivations of a sentence in
TAGs. In (Vijay-Shanker, Weir and Rambow, 1995)
the approach used for parsing a new formalism, the
D-Tree Grammars (DTG), is to translate a DTG
into a Linear Prioritized Multiset Grammar which
is similar to a LIG but uses multisets in place of
stacks.
LIGs can be seen as usual context-free grammars
(CFGs) upon which constraints are imposed. These
constraints are expressed by stacks of symbols as-
sociated with non-terminals. We study parsing of
LIGs, our goal being to define a structure that ver-
ifies the LIG constraints and codes all (and exclu-
sively) parse trees deriving sentences.
Since derivations in LIGs are constrained CF
derivations, we can think of a scheme where the
CF derivations for a given input are expressed by
a shared forest from which individual parse trees
which do not satisfied the LIG constraints are
erased. Unhappily this view is too simplistic, since
the erasing of individual trees whose parts can be
shared with other valid trees can only be performed
after some unfolding (unsharing) that can produced
a forest whose size is exponential or even unbounded.
In (Vijay-Shanker and Weir, 1993), the context-
freeness of adjunction in TAGs is captured by giving
a CFG to represent the set of all possible derivation
sequences. In this paper we study a new parsing
scheme for LIGs based upon similar principles and
which, on the other side, emphasizes as (Lang, 1991)
and (Lang, 1994), the use of grammars (shared for-
est) to represent parse trees and is an extension of
our previous work (Boullier, 1995).
</bodyText>
<footnote confidence="0.6855326">
This previous paper describes a recognition algo-
rithm for LIGs, but not a parser. For a LIG and an
input string, all valid parse trees are actually coded
into the CF shared parse forest used by this recog-
nizer, but, on some parse trees of this forest, the
</footnote>
<page confidence="0.993603">
87
</page>
<bodyText confidence="0.994740790697675">
checking of the LIG constraints can possibly failed. This shows that the rightmost derivation language
At first sight, there are two conceivable ways to ex- of a CFG is also CF. We will show in section 4 that
tend this recognizer into a parser: a similar result holds for LIGs.
1. only &amp;quot;good&amp;quot; trees are kept; Following (Lang, 1994), CF parsing is the inter-
2. the LIG constraints are [re-}checked while the section of a CFG and a finite-state automaton (FSA)
extraction of valid trees is performed. which models the input string x2. The result of this
As explained above, the first solution can produce intersection is a CFG G&apos; = (V/fr,V7&apos;, P5, [S) called
an unbounded number of trees. The second solution a shared parse forest which is a specialization of the
is also uncomfortable since it necessitates the reeval- initial .CFG G = (VN ,VT, P, S) to x. Each produc-
uation on each tree of the LIG conditions and, doing tion ri? E P5, is the production ri E P up to some
so, we move away from the usual idea that individ- non-terminal renaming. The non-terminal symbols
ual parse trees can be extracted by a simple walk in 1/1,,, are triples denoted [A], where A E VN, and
through a structure. p and q are states. When such a non-terminal is
In this paper, we advocate a third way which will productive, [A]„q w, we have q E 6(p, w).
use (see section 4), the same basic material as the G&apos;
one used in (Boullier, 1995). For a given LIG L and If we build the rightmost derivation grammar as-
an input string x, we exhibit a non ambiguous CFG sociated with a shared parse forest, and we remove
whose sentences are all possible valid derivation se- all its useless symbols, we get a reduced CFG say D&apos;.
quences in L which lead to x. We show that this The CF recognition problem for (C, x) is equivalent
CFG can be constructed in 0(n6) time and that in- to the existence of an [S]-production in D5. More-
dividual parses can be extracted in time linear with over, each rightmost Six-derivation in G is (the re-
the size of the extracted tree. verse of) a sentence in .C(D&apos;). However, this result
2 Derivation Grammar and CF is not very interesting since individual parse trees
Parse Forest can be as easily extracted directly from the parse
In a CFG G = (VN, VT, P, S), the derives relation forest. This is due to the fact that in the CF case, a
is the set {(o-Bai, crOcri) I B )3EPAV= tree that is derived (a parse tree) contains all the
VN U VT A a, a&apos; E V*}. A derivation is a sequence information about its derivation (the sequence of
of strings in V* s.t. the relation derives holds be- rewritings used) and therefore there is no need to
tween any two consecutive strings. In a rightmost distinguish between these two notions. Though this
derivation, at each step, the rightmost non-terminal is not always the case with non CF formalisms, we
say B is replaced by the right-hand side (RHS) of will see in the next sections that a similar approach,
a B-production. Equivalently if cro an is when applied to LIGs, leads to a shared parse for-
a rightmost derivation where the relation symbol is est which is a LIG while it is possible to define a
overlined by the production used at each step, we derivation grammar which is CF.
say that r1 rn is a rightmost a-o/an-derivation. 3 Linear Indexed Grammars
For a CFG G, the set of its rightmost Six- An indexed grammar is a CFG in which stack of
derivations, where x E L(G), can itself be defined symbols are associated with non-terminals. LIGs are
by a grammar. a restricted form of indexed grammars in which the
Definition 1 Let G = (VN,VT,P,S) be a CFG, dependence between stacks is such that at most one
its rightmost derivation grammar is the CFG D = stack in the RHS of a production is related with the
(VN , P, PD , S) where PD = {,40 441 Aqr I r = stack in its LHS. Other non-terminals are associated
Ao woAiwi E P A wi E Vgt A Aj E with independant stacks of bounded size.
VN} Following (Vijay-Shanker and Weir, 1994)
LFrom the natural bijection between P and Pp, Definition 2 L = (VN,VT)VI)PL,S) denotes a
we can easily prove that LIG where VN, VT, VI and Pi, are respectively fi-
r(D) = P.n. • • ri I nite sets of non-terminals, terminals, stack symbols
ri rn is a rightmost Six-derivation in G} and productions, and S is the start symbol.
In the sequel we will only consider a restricted
88 2if x = al ... an, the states can be the integers 0.
0 is the initial state, n the unique final state, and the
transition function 6 is s.t. i E (5(i —1, ai) and i E 5(i, e).
form of LIGs with productions of the form
FL = {A() w} U {A(..a) riB(..00r2}
where A, B E VN, WE V4t A 0 &lt; lw I &lt;2, aa&apos; E VI* A
0 &lt; &lt; 1 and F1r2 E VTU{E}U{CO I C E VN}.
An element like A(. .a) is a primary constituent
while CO is a secondary constituent. The stack
schema (..a) of a primary constituent matches all
the stacks whose prefix (bottom) part is left unspec-
ified and whose suffix (top) part is a; the stack of a
secondary constituent is always empty.
Such a form has been chosen both for complexity
reasons and to decrease the number of cases we have
to deal with. However, it is easy to see that this form
of LIG constitutes a normal form.
We use r() to denote a production in 13L, where
the parentheses remind us that we are in a LIG!
The CF-backbone of a LIG is the underlying CFG
in which each production is a LIG production where
the stack part of each constituent has been deleted,
leaving only the non-terminal part. We will only
consider LIGs such there is a bijection between its
production set and the production set of its CF-
backbone3.
We call object the pair denoted A(a) where A
is a non-terminal and (a) a stack of symbols. Let
Vo = {A(a) I A E VN A a E 171} be the set of
objects. We define on (V0 U VT)* the binary relation
derives denoted = (the relation symbol is sometimes
overlined by a production):
child and a secondary object. Our particular deriva-
tion strategy is such that this distinguished child will
always be derived after the secondary object (and its
descendants), whether this secondary object lays to
its left or to its right. This derives relation is denoted
and is called lineal&amp;
</bodyText>
<equation confidence="0.59694375">
t,L
A spine is the sequence of objects Al (ai )
...
A1 (a1) Ai±i(ai+i) Ap(ap) if, there is a deriva-
</equation>
<bodyText confidence="0.999208">
tion in which each object Ai+1 (ai+i) is the distin-
guished child of Ai (a1) (and therefore the distin-
guished descendant of Ai (ai),1 &lt; j &lt; i).
</bodyText>
<sectionHeader confidence="0.990045" genericHeader="method">
4 Linear Derivation Grammar
</sectionHeader>
<bodyText confidence="0.974635">
For a given LIG L, consider a linear SO/x-derivation
</bodyText>
<equation confidence="0.8638265">
so r4) ... 1.4) . . . r4) X
1,L 1,L 1,L
</equation>
<bodyText confidence="0.974735125">
The sequence of productions r1() ri()
(considered in reverse order) is a string in P. The
purpose of this section is to define the set of such
strings as the language defined by some CFG.
Associated with a LIG L = (VN , VT , S),
we first define a bunch of binary relations which are
borrowed from (Boullier, 1995)
{(A,B) I A(..) -+ r1B(..)r2 E PL}
f(A,B) I A(..) -4 r1B(..7)F2 E
{(A, B) I A(..7) -÷ r1B(..)r2 E PL}
rI.A(a&amp;quot; a)r2 A(..a)--V1(..cr&apos;)r2 rir1B(anai)r2v2 = {(AI,Ap) I Ai() +: r1ApOr2 and Ap0
ri,A0V2 A0—&gt;tv viwri2 is a distinguished descendant of A10}
In the first above element we say that the object
B(a&amp;quot;a&apos;) is the distinguished child of A(a&amp;quot;a), and if
Fir, = co, co is the secondary object. A deriva-
tion r1,..., is a sequence of strings
where the relation derives holds between any two
consecutive strings
The language defined by a LIG L is the set:
r(L)={x1,50+:xAxelq}
As in the CF case we can talk of rightmost deriva-
tions when the rightmost object is derived at each
step. Of course, many other derivation strategies
may be thought of. For our parsing algorithm, we
need such a particular derives relation. Assume that
at one step an object derives both a distinguished
3rp and rp() with the same index p designate associ-
ated productions.
The 1-level relations simply indicate, for each pro-
duction, which operation can be apply to the stack
associated with the LHS non-terminal to get the
stack associated with its distinguished child; in-
</bodyText>
<sectionHeader confidence="0.462113" genericHeader="method">
7 &apos;Y
</sectionHeader>
<bodyText confidence="0.993475416666667">
dicates equality, the pushing of 7, and &gt;- the pop-
ping of 7.
If we look at the evolution of a stack along
a spine Ai (al ) . Ai (ai)Ai±i (ai+ ) Ap (ap), be-
tween any two objects one of the following holds:
ai = ai+i, ai-Y = az+i, or ai = ai+17.
The -4- relation select pairs of non-terminals
(A1, Ap) s.t. al = ap = E along non trivial spines.
&apos;linear reminds us that we are in a LIG and relies
upon a linear (total) order over object occurrences in
a derivation. See (Boullier, 1996) for a more formal
definition.
</bodyText>
<page confidence="0.968206">
89
</page>
<equation confidence="0.853642">
&apos;Y
If the relations &gt;- and are defined as
+ + 1
U -*-&gt;•-• and,&apos;&amp;quot;:;== U1,071 , we can see that the
+1 1+
</equation>
<bodyText confidence="0.54735">
following identity holds
Property 1
</bodyText>
<equation confidence="0.9826785">
U U --0- -0- U -0-
1 +
</equation>
<bodyText confidence="0.74388175">
In (Boullier, 1995) we can found an algorithm5
which computes the -0-, &gt;- and relations as the
+ +
composition of -0-, -‹ and &gt;- in 0(IVNI3) time.
</bodyText>
<construct confidence="0.8556285">
Definition 3 For a LIG L = (VN VT, V1, PL, S),
we call linear derivation grammar (LDG) the
CFG DL (or D when L is understood) D =
(11 ,V1) ,PD,SD) where
</construct>
<listItem confidence="0.978537142857143">
• 171,DI = {[A] I A E VN} {[AP-B] I A, B E VN A
p E R-}, and R is the set of relations
+ +
• V71-,) = Pi,
• SD = [S]
• Below, [r1r2] denotes either the non-terminal
symbol [X] when r1r2 = X() or the empty
</listItem>
<bodyText confidence="0.905655">
string E when rir, E PD is defined as
</bodyText>
<equation confidence="0.963074333333333">
being
{[A] -4 r() I r() = A() -4 w E PL} (1)
Ul[A] r()[A B]
r() = B() -+ w E (2)
U {[A C] [r ir dr 0 I
r() = A(..) --+ r1c(..)r2 E PL,} (3)
uf[A -&lt;+;- C] -4 [A Cil (4)
Ul[A C] [B C][F ir dr() I
r0 = A(-) —&gt; r1B(..)r2 E PL} (5)
U{[A -t C] —&gt; [B (6)
uf[A pe, C] [B C][l&apos;ir dr() I
r() = A(..) -4 r1B(..7)r2 E (7)
</equation>
<footnote confidence="0.9932018">
5Though in the referred paper, these relations are de-
fined on constituents, the algorithm also applies to non-
terminals.
6In fact we will only use valid non-terminals [ApB]
for which the relation p holds between A and B.
</footnote>
<equation confidence="0.99799775">
uf[A ;‘±- C] [r1r2]r0
r() = A(..7) r1c(..)r2 E PO (8)
uf[A &gt;7; C] [rirdrO[A IA I
r() = B(..7) —&gt; r1c(..)r2 E PL} (9)
</equation>
<bodyText confidence="0.9992872">
The productions in PD define all the ways lin-
ear derivations can be composed from linear sub-
derivations. This compositions rely on one side upon
property 1 (recall that the productions in PL„ must
be produced in reverse order) and, on the other side,
upon the order in which secondary spines (the r, F2-
spines) are processed to get the linear derivation or-
der.
In (Boullier, 1996), we prove that LDGs are not
ambiguous (in fact they are SLR(1)) and define
</bodyText>
<equation confidence="0.995894333333333">
L(D) = Iri0 • • • rn0 I SO r4) • • • r4)
1,L 1,L
Ax E .C(L)}
</equation>
<bodyText confidence="0.999257857142857">
If, by some classical algorithm, we remove from D
all its useless symbols, we get a reduced CFG say
D&apos; = ,PD&apos; , SD&apos; ). In this grammar, all its
terminal symbols, which are productions in L, are
useful. By the way, the construction of D&apos; solve the
emptiness problem for LIGs: L specify the empty
set if the set VP is empty7.
</bodyText>
<sectionHeader confidence="0.986258" genericHeader="method">
5 LIG parsing
</sectionHeader>
<bodyText confidence="0.995638047619048">
Given a LIG L = (VN ,VT S) we want to find
all the syntactic structures associated with an input
string x E V. In section 2 we used a CFG (the
shared parse forest) for representing all parses in a
CFG. In this section we will see how to build a CFG
which represents all parses in a LIG.
In (Boullier, 1995) we give a recognizer for LIGs
with the following scheme: in a first phase a general
CF parsing algorithm, working on the CF-backbone
builds a shared parse forest for a given input string x.
In a second phase, the LIG conditions are checked on
this forest. This checking can result in some subtree
(production) deletions, namely the ones for which
there is no valid symbol stack evaluation. If the re-
sulting grammar is not empty, then x is a sentence.
However, in the general case, this resulting gram-
mar is not a shared parse forest for the initial LIG
in the sense that the computation of stack of sym-
bols along spines are not guaranteed to be consis-
tent. Such invalid spines are not deleted during the
check of the LIG conditions because they could be
</bodyText>
<footnote confidence="0.931469">
7In (Vijay-Shanker and Weir, 1993) the emptiness
problem for LIGs is solved by constructing an FSA.
</footnote>
<page confidence="0.994734">
90
</page>
<bodyText confidence="0.952274690909091">
composed of sub-spines which are themselves parts The recognition problem for (L, x) (i.e. is x an
of other valid spines. One way to solve this problem element of f(L)) is equivalent to the non-emptiness
is to unfold the shared parse forest and to extract of the production set of DL-.
individual parse trees. A parse tree is then kept if Moreover, each linear SO/x-derivation in L is (the
the LIG conditions are valid on that tree. But such reverse of) a string in f(DL. )6. So the extraction of
a method is not practical since the number of parse individual parses in a LIG is merely reduced to the
trees can be unbounded when the CF-backbone is derivation of strings in a CFG.
cyclic. Even for non cyclic grammars, the number An important issue is about the complexity, in
of parse trees can be exponential in the size of the time and space, of DL.. Let n be the length of
input. Moreover, it is problematic that a worst case the input string x. Since G is in binary form we
polynomial size structure could be reached by some know that the shared parse forest Gx can be build
sharing compatible both with the syntactic and the in 0(n3) time and the number of its productions
&amp;quot;semantic&amp;quot; features. is also in 0(n3). Moreover, the cardinality of Vifi
However, we know that derivations in TAGs are is 0(n2) and, for any given non-terminal, say [A]l),
context-free (see (Vijay-Shanker, 1987)) and (Vijay- there are at most 0(n) [A]-productions. Of course,
Shanker and Weir, 1993) exhibits a CFG which rep- these complexities extend to the LIGed forest L&apos;.
resents all possible derivation sequences in a TAG. We now look at the LDG complexity when the
We will show that the analogous holds for LIGs and input LIG is a LIGed forest. In fact, we mainly have
leads to an 0(n6) time parsing algorithm. to check two forms of productions (see definition 3).
Definition 4 Let L (VN, VT PL, S) be a LIG, The first form is production (6) ([A -0- C] [B
G = (VN,VT, PG, S) its CF-backbone, x a string CIA BD, where three different non-terminals in
in E(G), and Gx = (V§,V1,P6,Sx) its shared VN are implied (i.e. A, B and C), so the number of
parse forest for x. We define the LIGed forest productions of that form is cubic in the number of
for x as being the LIG Lx = Pt, Sz) non-terminals and therefore is 0(n6).
s.t. Gz is its CF-backbone and its productions are In the second form (productions (5), (7) and (9)),
the productions of P6 in which the corresponding exemplified by [A C] -4 [B C][1&amp;quot;11&apos;2]r(), there
stack-schemas of L have been added. For exam- are four non-terminals in VN (i.e. A, B, C, and X
ple r() = [A](..a) [B]1.(..a&apos;)[C[11() E Pr, if if rir2 = x()) and a production r() (the number
71,= [A] -4 [B],ji [C]i3F E P A rp =- A BC E of relation symbols ›- is a constant), therefore, the
GA rp() = A(..ce) -+ B(...ce)C0 E L. number of such productions seems to be of fourth
Between a LIG L and its LIGed forest Lx for x, degree in the number of non-terminals and linear in
we have: the number of productions. However, these variables
x E f(L) x E r(Lz) are not independant. For a given A, the number of
If we follow(Lang, 1994), the previous definition triples (B,X,r()) is the number of A-productions
which produces a LIGed forest from any L and x hence 0(n). So, at the end, the number of produc-
is a (LIG) parser&apos;: given a LIG L and a string x, tions of that form is 0(n5).
we have constructed a new LIG Lx for the intersec- We can easily check that the other form of pro-
tion f(L) n {x}, which is the shared forest for all ductions have a lesser degree.
parses of the sentences in the intersection. However, Therefore, the number of productions is domi-
we wish to go one step further since the parsing (or nated by the first form and the size (and in fact
even recognition) problem for LIGs cannot be triv- the construction time) of this grammar is 0(n6).
ially extracted from the LIGed forests. This (once again) shows that the recognition and
Our vision for the parsing of a string x with a LIG parsing problem for a LIG can be solved in 0(n6)
L can be summarized in few lines. Let G be the CF- time.
backbone of L, we first build Gz the CFG shared For a LDG D (q,VP,PD,SD), we note that
parse forest by any classical general CF parsing al- for any given non-terminal A E VIN? and string a E
gorithm and then Lx its LIGed forest. Afterwards, L(A) with Icrl &gt; 2, a single production A .X1X2
we build the reduced LDG DL. associated with Lx or A -4 Xi X2X3 in PD is needed to &amp;quot;cut&amp;quot; a into two
as shown in section 4. or three non-empty pieces cri, 0-2, and 03, such that
91n fact, the terminal symbols in DL. are produc-
tions in I,&apos; (say MO), which trivially can be mapped to
productions in L (here rp()).
&apos;Of course, instead of x, we can consider any FSA.
91
production set PG is:
</bodyText>
<equation confidence="0.9823245">
S-&gt; S -&gt; Sb S -&gt; Sc S T
T --&gt; aT T --&gt; bT T -&gt; cT T -&gt; c
</equation>
<bodyText confidence="0.98056125">
defines the language L(G) = {wcw&apos; I w,w1 E
{a, b, cr }. We remark that the stacks of symbols in
L constrain the string w&apos; to be equal to w and there-
fore the language .C(L) is {wcw I w E {a,b,c}*}.
We note that in L the key part is played by the
middle c, introduced by production r8(), and that
this grammar is non ambiguous, while in G the sym-
bol c, introduced by the last production T --&gt; c, is
only a separator between w and w&apos; and that this
grammar is ambiguous (any occurrence of c may be
this separator).
The computation of the relations gives:
</bodyText>
<figure confidence="0.928444476190476">
-&amp;quot;&lt; = &amp;quot;Yb = -&amp;quot;0&amp;quot;- {(S,T)}
1 = &apos;Yb = 1 {(S, S)}
7a = 76 &apos;Yc {(T,T)}
1 1 {(S,T)}
7a 7c {(S,T)}
&gt;- {(T,T),(S,T)}
1
&apos;Ye
The production set PD of the LDG D associated
with L is:
[S] r8 [S
[S T] -&gt; r4
[S T] --&gt; [S T]
[S T] --&gt; [S T]ri() (7)
[S T] [S;b- T]r20 (7)
[S T] -&gt; [S &amp;quot;)! T]r3() (7)
[S T] --&gt; r50[S T] (9)
[S T] -&gt; r60[S T] (9)
[S;= T] -&gt; r70[S T] (9)
The numbers (i) refer to definition 3. We can
easily checked that this grammar is reduced.
</figure>
<bodyText confidence="0.846429333333333">
Let x = ccc be an input string. Since x is an
element of L(G), its shared parse forest Gx is not
empty. Its production set P6 is:
</bodyText>
<equation confidence="0.974983166666667">
rA = [s]g [s]ge
r3 = [s[g [sme
= [5]6 -* [T]l,
= -+ c[T]?
r11 = [T]6 c
ri= [s]g [T[g
</equation>
<listItem confidence="0.769503666666667">
• = [Shl [T]
• = [T]g c[T]1
• = [T]? -&gt; c
</listItem>
<bodyText confidence="0.985693725">
cri, except when the production form num-
ber (4) is used. In such a case, this cutting needs
two productions (namely (4) and (7)). This shows
that the cutting out of any string of length /, into
elementary pieces of length 1, is performed in using
0(1) productions. Therefore, the extraction of a lin-
ear S()/x-derivation in L is performed in time linear
with the length of that derivation. If we assume that
the CF-backbone G is non cyclic, the extraction of
a parse is linear in n. Moreover, during an extrac-
tion, since DL. is not ambiguous, at some place, the
choice of another A-production will result in a dif-
ferent linear derivation.
Of course, practical generations of LDGs must im-
prove over a blind application of definition 3. One
way is to consider a top-down strategy: the X -
productions in a LDG are generated if X is the start
symbol or occurs in the RHS of an already generated
production. The examples in section 6 are produced
this way.
If the number of ambiguities in the initial LIG is
bounded, the size of DL., for a given input string x
of length n, is linear in n.
The size and the time needed to compute DL. are
closely related to the actual sizes of the -0-- , &gt;- and
+ +
relations. As pointed out in (Boullier, 1995), their
0(n4) maximum sizes seem to be seldom reached in
practice. This means that the average parsing time
is much better than this 0(n6) worst case.
Moreover, our parsing schema allow to avoid some
useless computations. Assume that the symbol
[A -0-- B] is useless in the LDG DL associated with
the initial LIG L, we know that any non-terminal
s.t. [[A] -0- [B]] is also useless in DL.. Therefore,
the static computation of a reduced LDG for the
initial LIG L (and the corresponding -0-, and
+ +
relations) can be used to direct the parsing process
and decrease the parsing time (see section 6).
</bodyText>
<sectionHeader confidence="0.941985" genericHeader="method">
6 Two Examples
</sectionHeader>
<subsectionHeader confidence="0.998794">
6.1 First Example
</subsectionHeader>
<bodyText confidence="0.913011">
In this section, we illustrate our algorithm with a
LIG L ({S,T},{a,b,c}, 7c} , S) where
PL contains the following productions:
</bodyText>
<equation confidence="0.998818">
r2() = S(..) S(..7b)b
r3() = S(..) r4() = S(.-) T(..)
7&apos;60 = T(..-Yb) -&gt; bT(..)
r80 = TQ -&gt; c
</equation>
<bodyText confidence="0.917352">
It is easy to see that its CF-backbone G, whose
</bodyText>
<page confidence="0.989256">
92
</page>
<bodyText confidence="0.999826428571429">
We can observe that this shared parse forest denotes
in fact three different parse trees. Each one corre-
sponding to a different cutting out of x = wcw&apos; (i.e.
w = E and w&apos; = cc, or w = c and w&apos; = c, or w = cc
and w&apos; =e).
The corresponding LIGed forest whose start sym-
bol is ,s- = [5]3, and production set Pf, is:
</bodyText>
<equation confidence="0.999835454545455">
1&apos;40 = [S]g-) -&gt; --&gt;
r() = [4(..) --&gt; -+
r30 = [4(..) -&gt; -&gt;
r10 = [S](..) -&gt; -&gt;
110 = [S]jG.) -4 [S]4- (..-ye)c
710 = [T]g(-7c) c[T]1(-.)
rQ = [TN ( _rye ) c[T](..)
r10 = {T20 c
() = [TV,(..7,) c
7&apos;1°0 = [T]i() c
r1() [T]0
</equation>
<bodyText confidence="0.907276">
For this LIGed forest the relations are:
</bodyText>
<listItem confidence="0.882082">
• (Pig, [7]), aSlO, [T]), ((S], [T])}
</listItem>
<equation confidence="0.770637833333333">
= {([S]O, PM) ([4, [SI)}
=
= I aSIO, [T])}
▪ = U
1
&apos;Ye &apos;Ye
</equation>
<bodyText confidence="0.8875945">
= U{([S]g [TM, ([S], [TJ)}
The start symbol of the LDG associated with the
LIGed forest L&apos; is [[s]g}. If we assume that an A-
production is generated if it is an [[4]-production
</bodyText>
<listItem confidence="0.442214">
or A occurs in an already generated production, we
get:
(4)
(7)
(9)
</listItem>
<bodyText confidence="0.88209">
This CFG is reduced. Since its production set is
non empty, we have ccc E C(L). Its language is
</bodyText>
<equation confidence="0.8669455">
{ 7-1°04 ()ri ()} which shows that the only linear
r3() r7
derivation in L is SO S ey,)c T
t,L 1,L I,L
</equation>
<bodyText confidence="0.485328">
7&apos;8 0
</bodyText>
<sectionHeader confidence="0.521254" genericHeader="method">
CT OC CCC.
IL
</sectionHeader>
<bodyText confidence="0.99812">
In computing the relations for the initial LIG L,
we remark that though T &gt;- T, T T, and T&apos;g T,
</bodyText>
<equation confidence="0.468585">
7a &apos;Y
</equation>
<bodyText confidence="0.722436666666667">
the non-terminals [T &gt;- T], [T &gt;- T], and [T &gt;- T] are
not used in PD. This means that for any LIGed for-
est LX, the elements of the form ([TJ, [T],) do not
</bodyText>
<equation confidence="0.616088">
7a 76 7c
</equation>
<bodyText confidence="0.993198">
need to be computed in the&gt;-, &gt;- , and &gt;- relations
++
since they will never produce a useful non-terminal.
In this example, the subset &gt;- of &gt;- is useless.
</bodyText>
<equation confidence="0.657359">
1 +
</equation>
<bodyText confidence="0.998874">
The next example shows the handling of a cyclic
grammar.
</bodyText>
<subsectionHeader confidence="0.998395">
6.2 Second Example
</subsectionHeader>
<bodyText confidence="0.8228996">
The following LIG L, where A is the start symbol:
7&apos;10 = A(..) -4 A(..7a) r2() = A(..) --&gt; B(..)
r3() B(..-ya) B(..) r4() = B() -&gt; a
is cyclic (we have A 4 A and B B in its CF-
backbone), and the stack schemas in production r10
indicate that an unbounded number of push &apos;Ya ac-
tions can take place, while production r3() indicates
an unbounded number of pops. Its CF-backbone is
unbounded ambiguous though its language contains
the single string a.
The computation of the relations gives:
{(A,B)}
-r.
{(A, A)}
{(B,B)}
{(A, B)}
= {(A, B)}
7&gt;2.= {(A, B), (B , B)}
The start symbol of the LDG associated with L is
[A] and its productions set PD is:
</bodyText>
<equation confidence="0.999053">
[A] -+ r40[A B] (2)
[A B] -&gt; r20 (3)
[A -.0- B] -&gt; [A B] (4)
[A B] -&gt; [A B]ri() (7)
[A B] -&gt; r3 ()[A B] (9)
</equation>
<bodyText confidence="0.99953625">
We can easily checked that this grammar is re-
duced.
We want to parse the input string x = a (i.e. find
all the linear S 0 / a-derivations).
</bodyText>
<figure confidence="0.965342230769231">
e■J
f[s]gl
Uslg &amp;quot;: [T]fl
E[S18
[1,518 ^g
[TJ]
1[4 .1- [T]]
93
Its LIGed forest, whose start symbol is [43 is:
1&apos;10 = [A](..) -+ [A](..7.)
7&apos;30 = [A}(..) —&gt; LBW-)
r() = [B]O(..7a) -4
710 . P3M0 --+ a
</figure>
<bodyText confidence="0.994277090909091">
though much better results occur in practical situa-
tions. Moreover, static computations on the initial
LIG may decrease this practical complexity in avoid-
ing useless computations. Each sentence in this CFG
is a derivation of the given input string by the LIG,
and is extracted in linear time.
For this LIGed forest LX, the relations are:
The start symbol of the LDG associated with L&apos;
is RAW. If we assume that an A-production is gen-
erated if it is an UAW-production or A occurs in an
already generated production, its production set is:
</bodyText>
<table confidence="0.7639216">
[{AM] --+
RAM 1- [B]] --
RAM -&amp;quot;&lt;±&gt;-- [B]] —4
RAM P-&apos; [BM] -4
[B])} -4
</table>
<bodyText confidence="0.9866783">
This CFG is reduced. Since its production set
is non empty, we have a E E(L). Its language is
{r1017-30}kr30{7.10}k I 0 &lt; k} which shows that
the only valid linear derivations w.r.t. L must con-
tain an identical number k of productions which
push rya (i.e. the production r1 0) and productions
which pop -yo (i.e. the production r30).
As in the previous example, we can see that the
element [B]l) ;- [B] is useless.
+
</bodyText>
<sectionHeader confidence="0.998875" genericHeader="conclusions">
7 Conclusion
</sectionHeader>
<bodyText confidence="0.9999842">
We have shown that the parses of a LIG can be rep-
resented by a non ambiguous CFG. This represen-
tation captures the fact that the values of a stack of
symbols is well parenthesized. When a symbol -y is
pushed on a stack at a given index at some place, this
very symbol must be popped some place else, and we
know that such (recursive) pairing is the essence of
context-freeness.
In this approach, the number of productions and
the construction time of this CFG is at worst 0(n6),
</bodyText>
<sectionHeader confidence="0.999136" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.997236953488372">
Pierre Boullier. 1995. Yet another 0(n6) recog-
nition algorithm for mildly context-sensitive lan-
guages. In Proceedings of the fourth international
workshop on parsing technologies (IWPT&apos;95),
Prague and Karlovy Vary, Czech Republic, pages
34-47. See also Research Report No 2730
at http : //www. inria . fr/RRRT/RR-2730 . html,
INRIA-Rocquencourt, France, Nov. 1995, 22
pages.
Pierre Boullier. 1996. Another Facet of LIG Parsing
(extended version). In Research Report No 2858
at http : //www. inria . fr/RRRT/RR-2858 . html,
INRIA-Rocquencourt, France, Apr. 1996, 22
pages.
Bernard Lang. 1991. Towards a uniform formal
framework for parsing. In Current Issues in Pars-
ing Technology, edited by M. Tomita, Kluwer Aca-
demic Publishers, pages 153-171.
Bernard Lang. 1994. Recognition can be harder
than parsing. In Computational Intelligence, Vol.
10, No. 4, pages 486-494.
Yves Schabes, Stuart M. Shieber. 1994. An Alter-
native Conception of Tree-Adjoining Derivation.
In ACL Computational Linguistics, Vol. 20, No.
1, pages 91-124.
K. Vijay-Shanker. 1987. A study of tree adjoining
grammars. PhD thesis, University of Pennsylva-
nia.
K. Vijay-Shanker, David J. Weir. 1993. The Used of
Shared Forests in Tree Adjoining Grammar Pars-
ing. In Proceedings of the 6th Conference of the
European Chapter of the Association for Com-
putational Linguistics (EACL&apos;93), Utrecht, The
Netherlands, pages 384-393.
K. Vijay-Shanker, David J. Weir. 1994. Parsing
some constrained grammar formalisms. In ACL
Computational Linguistics, Vol. 19, No. 4, pages
591-636.
K. Vijay-Shanker, David J. Weir, Owen Rambow.
1995. Parsing D-Tree Grammars. In Proceed-
ings of the fourth international workshop on pars-
ing technologies (IWPT&apos;95), Prague and Karlovy
Vary, Czech Republic, pages 252-259.
</reference>
<figure confidence="0.987806">
= f(fAMJBM)}
7a
= {PM, [A])}
= fa-BM, [B])}
= {GAM., [BM)}
-0-- = {([A], [B])}
+
= {(EAM, IBM), ([BM, [BM)}
+
-0-
1
-‹
1
-r.
&gt;--
1
(7)
(9)
</figure>
<page confidence="0.97789">
94
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.491597">
<title confidence="0.999744">Another Facet of LIG Parsing</title>
<author confidence="0.996807">Pierre Boullier</author>
<email confidence="0.688165">INRIA-Rocquencourt</email>
<address confidence="0.885818">BP 105 78153 Le Chesnay Cedex, France</address>
<email confidence="0.958072">Pierre.Boullier@inria.fr</email>
<abstract confidence="0.998609578947369">In this paperl we present a new parsing algorithm for linear indexed grammars (LIGs) in the same spirit as the one described in (Vijay-Shanker and Weir, 1993) tree adjoining grammars. For a LIG an input string length n, we build a non ambiguous context-free grammar whose sentences are all (and exclusively) derivation sequences in lead show that this grammar can built in time and that individual parses can be extracted in linear time with the size of the extracted parse tree. this bound does not improve over previous results, the average case behaves much better. Moreover, practical parsing times can be decreased by some statically performed computations.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Pierre Boullier</author>
</authors>
<title>Yet another 0(n6) recognition algorithm for mildly context-sensitive languages.</title>
<date>1995</date>
<booktitle>In Proceedings of the fourth international workshop on parsing technologies (IWPT&apos;95), Prague and Karlovy Vary,</booktitle>
<pages>pages</pages>
<location>Czech Republic,</location>
<contexts>
<context position="3387" citStr="Boullier, 1995" startWordPosition="559" endWordPosition="560">hose parts can be shared with other valid trees can only be performed after some unfolding (unsharing) that can produced a forest whose size is exponential or even unbounded. In (Vijay-Shanker and Weir, 1993), the contextfreeness of adjunction in TAGs is captured by giving a CFG to represent the set of all possible derivation sequences. In this paper we study a new parsing scheme for LIGs based upon similar principles and which, on the other side, emphasizes as (Lang, 1991) and (Lang, 1994), the use of grammars (shared forest) to represent parse trees and is an extension of our previous work (Boullier, 1995). This previous paper describes a recognition algorithm for LIGs, but not a parser. For a LIG and an input string, all valid parse trees are actually coded into the CF shared parse forest used by this recognizer, but, on some parse trees of this forest, the 87 checking of the LIG constraints can possibly failed. This shows that the rightmost derivation language At first sight, there are two conceivable ways to ex- of a CFG is also CF. We will show in section 4 that tend this recognizer into a parser: a similar result holds for LIGs. 1. only &amp;quot;good&amp;quot; trees are kept; Following (Lang, 1994), CF par</context>
<context position="5063" citStr="Boullier, 1995" startWordPosition="868" endWordPosition="869">tes the reeval- initial .CFG G = (VN ,VT, P, S) to x. Each producuation on each tree of the LIG conditions and, doing tion ri? E P5, is the production ri E P up to some so, we move away from the usual idea that individ- non-terminal renaming. The non-terminal symbols ual parse trees can be extracted by a simple walk in 1/1,,, are triples denoted [A], where A E VN, and through a structure. p and q are states. When such a non-terminal is In this paper, we advocate a third way which will productive, [A]„q w, we have q E 6(p, w). use (see section 4), the same basic material as the G&apos; one used in (Boullier, 1995). For a given LIG L and If we build the rightmost derivation grammar asan input string x, we exhibit a non ambiguous CFG sociated with a shared parse forest, and we remove whose sentences are all possible valid derivation se- all its useless symbols, we get a reduced CFG say D&apos;. quences in L which lead to x. We show that this The CF recognition problem for (C, x) is equivalent CFG can be constructed in 0(n6) time and that in- to the existence of an [S]-production in D5. Moredividual parses can be extracted in time linear with over, each rightmost Six-derivation in G is (the rethe size of the e</context>
<context position="10459" citStr="Boullier, 1995" startWordPosition="1899" endWordPosition="1900">i±i(ai+i) Ap(ap) if, there is a derivation in which each object Ai+1 (ai+i) is the distinguished child of Ai (a1) (and therefore the distinguished descendant of Ai (ai),1 &lt; j &lt; i). 4 Linear Derivation Grammar For a given LIG L, consider a linear SO/x-derivation so r4) ... 1.4) . . . r4) X 1,L 1,L 1,L The sequence of productions r1() ri() (considered in reverse order) is a string in P. The purpose of this section is to define the set of such strings as the language defined by some CFG. Associated with a LIG L = (VN , VT , S), we first define a bunch of binary relations which are borrowed from (Boullier, 1995) {(A,B) I A(..) -+ r1B(..)r2 E PL} f(A,B) I A(..) -4 r1B(..7)F2 E {(A, B) I A(..7) -÷ r1B(..)r2 E PL} rI.A(a&amp;quot; a)r2 A(..a)--V1(..cr&apos;)r2 rir1B(anai)r2v2 = {(AI,Ap) I Ai() +: r1ApOr2 and Ap0 ri,A0V2 A0—&gt;tv viwri2 is a distinguished descendant of A10} In the first above element we say that the object B(a&amp;quot;a&apos;) is the distinguished child of A(a&amp;quot;a), and if Fir, = co, co is the secondary object. A derivation r1,..., is a sequence of strings where the relation derives holds between any two consecutive strings The language defined by a LIG L is the set: r(L)={x1,50+:xAxelq} As in the CF case we can talk </context>
<context position="12304" citStr="Boullier, 1995" startWordPosition="2242" endWordPosition="2243">tion of a stack along a spine Ai (al ) . Ai (ai)Ai±i (ai+ ) Ap (ap), between any two objects one of the following holds: ai = ai+i, ai-Y = az+i, or ai = ai+17. The -4- relation select pairs of non-terminals (A1, Ap) s.t. al = ap = E along non trivial spines. &apos;linear reminds us that we are in a LIG and relies upon a linear (total) order over object occurrences in a derivation. See (Boullier, 1996) for a more formal definition. 89 &apos;Y If the relations &gt;- and are defined as + + 1 U -*-&gt;•-• and,&apos;&amp;quot;:;== U1,071 , we can see that the +1 1+ following identity holds Property 1 U U --0- -0- U -0- 1 + In (Boullier, 1995) we can found an algorithm5 which computes the -0-, &gt;- and relations as the + + composition of -0-, -‹ and &gt;- in 0(IVNI3) time. Definition 3 For a LIG L = (VN VT, V1, PL, S), we call linear derivation grammar (LDG) the CFG DL (or D when L is understood) D = (11 ,V1) ,PD,SD) where • 171,DI = {[A] I A E VN} {[AP-B] I A, B E VN A p E R-}, and R is the set of relations + + • V71-,) = Pi, • SD = [S] • Below, [r1r2] denotes either the non-terminal symbol [X] when r1r2 = X() or the empty string E when rir, E PD is defined as being {[A] -4 r() I r() = A() -4 w E PL} (1) Ul[A] r()[A B] r() = B() -+ w E</context>
<context position="14637" citStr="Boullier, 1995" startWordPosition="2733" endWordPosition="2734">hm, we remove from D all its useless symbols, we get a reduced CFG say D&apos; = ,PD&apos; , SD&apos; ). In this grammar, all its terminal symbols, which are productions in L, are useful. By the way, the construction of D&apos; solve the emptiness problem for LIGs: L specify the empty set if the set VP is empty7. 5 LIG parsing Given a LIG L = (VN ,VT S) we want to find all the syntactic structures associated with an input string x E V. In section 2 we used a CFG (the shared parse forest) for representing all parses in a CFG. In this section we will see how to build a CFG which represents all parses in a LIG. In (Boullier, 1995) we give a recognizer for LIGs with the following scheme: in a first phase a general CF parsing algorithm, working on the CF-backbone builds a shared parse forest for a given input string x. In a second phase, the LIG conditions are checked on this forest. This checking can result in some subtree (production) deletions, namely the ones for which there is no valid symbol stack evaluation. If the resulting grammar is not empty, then x is a sentence. However, in the general case, this resulting grammar is not a shared parse forest for the initial LIG in the sense that the computation of stack of </context>
<context position="22824" citStr="Boullier, 1995" startWordPosition="4317" endWordPosition="4318">r derivation. Of course, practical generations of LDGs must improve over a blind application of definition 3. One way is to consider a top-down strategy: the X - productions in a LDG are generated if X is the start symbol or occurs in the RHS of an already generated production. The examples in section 6 are produced this way. If the number of ambiguities in the initial LIG is bounded, the size of DL., for a given input string x of length n, is linear in n. The size and the time needed to compute DL. are closely related to the actual sizes of the -0-- , &gt;- and + + relations. As pointed out in (Boullier, 1995), their 0(n4) maximum sizes seem to be seldom reached in practice. This means that the average parsing time is much better than this 0(n6) worst case. Moreover, our parsing schema allow to avoid some useless computations. Assume that the symbol [A -0-- B] is useless in the LDG DL associated with the initial LIG L, we know that any non-terminal s.t. [[A] -0- [B]] is also useless in DL.. Therefore, the static computation of a reduced LDG for the initial LIG L (and the corresponding -0-, and + + relations) can be used to direct the parsing process and decrease the parsing time (see section 6). 6 </context>
</contexts>
<marker>Boullier, 1995</marker>
<rawString>Pierre Boullier. 1995. Yet another 0(n6) recognition algorithm for mildly context-sensitive languages. In Proceedings of the fourth international workshop on parsing technologies (IWPT&apos;95), Prague and Karlovy Vary, Czech Republic, pages</rawString>
</citation>
<citation valid="true">
<title>See also Research Report No 2730 at http : //www. inria .</title>
<date>1995</date>
<booktitle>fr/RRRT/RR-2730 . html, INRIA-Rocquencourt,</booktitle>
<pages>22</pages>
<location>France,</location>
<marker>1995</marker>
<rawString>34-47. See also Research Report No 2730 at http : //www. inria . fr/RRRT/RR-2730 . html, INRIA-Rocquencourt, France, Nov. 1995, 22 pages.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Pierre Boullier</author>
</authors>
<title>Another Facet of LIG Parsing (extended version).</title>
<date>1996</date>
<booktitle>In Research Report No 2858 at http : //www. inria . fr/RRRT/RR-2858 . html, INRIA-Rocquencourt,</booktitle>
<pages>22</pages>
<location>France,</location>
<contexts>
<context position="1678" citStr="Boullier, 1996" startWordPosition="271" endWordPosition="272">ndexed grammars (LIGs). In (Vijay-Shanker and Weir, 1994) TAGs are transformed into equivalent LIGs. Though context-sensitive linguistic phenomena seem to be more naturally expressed in TAG formalism, from a computational point of view, many authors think that LIGs play a central role and therefore the understanding of LIGs and LIG parsing is of importance. For example, quoted from (Schabes and Shieber, 1994) &amp;quot;The LIG version of TAG can be used for recognition and parsing. Because the LIG formalism is based on augmented rewriting, the parsing algorithms can be much simpler to understand 1See (Boullier, 1996) for an extended version. and easier to modify, and no loss of generality is incurred&amp;quot;. In (Vijay-Shanker and Weir, 1993) LIGs are used to express the derivations of a sentence in TAGs. In (Vijay-Shanker, Weir and Rambow, 1995) the approach used for parsing a new formalism, the D-Tree Grammars (DTG), is to translate a DTG into a Linear Prioritized Multiset Grammar which is similar to a LIG but uses multisets in place of stacks. LIGs can be seen as usual context-free grammars (CFGs) upon which constraints are imposed. These constraints are expressed by stacks of symbols associated with non-term</context>
<context position="12088" citStr="Boullier, 1996" startWordPosition="2196" endWordPosition="2197">ion can be apply to the stack associated with the LHS non-terminal to get the stack associated with its distinguished child; in7 &apos;Y dicates equality, the pushing of 7, and &gt;- the popping of 7. If we look at the evolution of a stack along a spine Ai (al ) . Ai (ai)Ai±i (ai+ ) Ap (ap), between any two objects one of the following holds: ai = ai+i, ai-Y = az+i, or ai = ai+17. The -4- relation select pairs of non-terminals (A1, Ap) s.t. al = ap = E along non trivial spines. &apos;linear reminds us that we are in a LIG and relies upon a linear (total) order over object occurrences in a derivation. See (Boullier, 1996) for a more formal definition. 89 &apos;Y If the relations &gt;- and are defined as + + 1 U -*-&gt;•-• and,&apos;&amp;quot;:;== U1,071 , we can see that the +1 1+ following identity holds Property 1 U U --0- -0- U -0- 1 + In (Boullier, 1995) we can found an algorithm5 which computes the -0-, &gt;- and relations as the + + composition of -0-, -‹ and &gt;- in 0(IVNI3) time. Definition 3 For a LIG L = (VN VT, V1, PL, S), we call linear derivation grammar (LDG) the CFG DL (or D when L is understood) D = (11 ,V1) ,PD,SD) where • 171,DI = {[A] I A E VN} {[AP-B] I A, B E VN A p E R-}, and R is the set of relations + + • V71-,) = P</context>
<context position="13856" citStr="Boullier, 1996" startWordPosition="2571" endWordPosition="2572">to nonterminals. 6In fact we will only use valid non-terminals [ApB] for which the relation p holds between A and B. uf[A ;‘±- C] [r1r2]r0 r() = A(..7) r1c(..)r2 E PO (8) uf[A &gt;7; C] [rirdrO[A IA I r() = B(..7) —&gt; r1c(..)r2 E PL} (9) The productions in PD define all the ways linear derivations can be composed from linear subderivations. This compositions rely on one side upon property 1 (recall that the productions in PL„ must be produced in reverse order) and, on the other side, upon the order in which secondary spines (the r, F2- spines) are processed to get the linear derivation order. In (Boullier, 1996), we prove that LDGs are not ambiguous (in fact they are SLR(1)) and define L(D) = Iri0 • • • rn0 I SO r4) • • • r4) 1,L 1,L Ax E .C(L)} If, by some classical algorithm, we remove from D all its useless symbols, we get a reduced CFG say D&apos; = ,PD&apos; , SD&apos; ). In this grammar, all its terminal symbols, which are productions in L, are useful. By the way, the construction of D&apos; solve the emptiness problem for LIGs: L specify the empty set if the set VP is empty7. 5 LIG parsing Given a LIG L = (VN ,VT S) we want to find all the syntactic structures associated with an input string x E V. In section 2 w</context>
</contexts>
<marker>Boullier, 1996</marker>
<rawString>Pierre Boullier. 1996. Another Facet of LIG Parsing (extended version). In Research Report No 2858 at http : //www. inria . fr/RRRT/RR-2858 . html, INRIA-Rocquencourt, France, Apr. 1996, 22 pages.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bernard Lang</author>
</authors>
<title>Towards a uniform formal framework for parsing. In Current Issues in Parsing Technology,</title>
<date>1991</date>
<pages>153--171</pages>
<publisher>Kluwer Academic Publishers,</publisher>
<note>edited by</note>
<contexts>
<context position="3250" citStr="Lang, 1991" startWordPosition="535" endWordPosition="536">which do not satisfied the LIG constraints are erased. Unhappily this view is too simplistic, since the erasing of individual trees whose parts can be shared with other valid trees can only be performed after some unfolding (unsharing) that can produced a forest whose size is exponential or even unbounded. In (Vijay-Shanker and Weir, 1993), the contextfreeness of adjunction in TAGs is captured by giving a CFG to represent the set of all possible derivation sequences. In this paper we study a new parsing scheme for LIGs based upon similar principles and which, on the other side, emphasizes as (Lang, 1991) and (Lang, 1994), the use of grammars (shared forest) to represent parse trees and is an extension of our previous work (Boullier, 1995). This previous paper describes a recognition algorithm for LIGs, but not a parser. For a LIG and an input string, all valid parse trees are actually coded into the CF shared parse forest used by this recognizer, but, on some parse trees of this forest, the 87 checking of the LIG constraints can possibly failed. This shows that the rightmost derivation language At first sight, there are two conceivable ways to ex- of a CFG is also CF. We will show in section </context>
</contexts>
<marker>Lang, 1991</marker>
<rawString>Bernard Lang. 1991. Towards a uniform formal framework for parsing. In Current Issues in Parsing Technology, edited by M. Tomita, Kluwer Academic Publishers, pages 153-171.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bernard Lang</author>
</authors>
<title>Recognition can be harder than parsing.</title>
<date>1994</date>
<journal>In Computational Intelligence,</journal>
<volume>10</volume>
<pages>486--494</pages>
<contexts>
<context position="3267" citStr="Lang, 1994" startWordPosition="538" endWordPosition="539">sfied the LIG constraints are erased. Unhappily this view is too simplistic, since the erasing of individual trees whose parts can be shared with other valid trees can only be performed after some unfolding (unsharing) that can produced a forest whose size is exponential or even unbounded. In (Vijay-Shanker and Weir, 1993), the contextfreeness of adjunction in TAGs is captured by giving a CFG to represent the set of all possible derivation sequences. In this paper we study a new parsing scheme for LIGs based upon similar principles and which, on the other side, emphasizes as (Lang, 1991) and (Lang, 1994), the use of grammars (shared forest) to represent parse trees and is an extension of our previous work (Boullier, 1995). This previous paper describes a recognition algorithm for LIGs, but not a parser. For a LIG and an input string, all valid parse trees are actually coded into the CF shared parse forest used by this recognizer, but, on some parse trees of this forest, the 87 checking of the LIG constraints can possibly failed. This shows that the rightmost derivation language At first sight, there are two conceivable ways to ex- of a CFG is also CF. We will show in section 4 that tend this </context>
<context position="18623" citStr="Lang, 1994" startWordPosition="3467" endWordPosition="3468"> have been added. For exam- are four non-terminals in VN (i.e. A, B, C, and X ple r() = [A](..a) [B]1.(..a&apos;)[C[11() E Pr, if if rir2 = x()) and a production r() (the number 71,= [A] -4 [B],ji [C]i3F E P A rp =- A BC E of relation symbols ›- is a constant), therefore, the GA rp() = A(..ce) -+ B(...ce)C0 E L. number of such productions seems to be of fourth Between a LIG L and its LIGed forest Lx for x, degree in the number of non-terminals and linear in we have: the number of productions. However, these variables x E f(L) x E r(Lz) are not independant. For a given A, the number of If we follow(Lang, 1994), the previous definition triples (B,X,r()) is the number of A-productions which produces a LIGed forest from any L and x hence 0(n). So, at the end, the number of producis a (LIG) parser&apos;: given a LIG L and a string x, tions of that form is 0(n5). we have constructed a new LIG Lx for the intersec- We can easily check that the other form of protion f(L) n {x}, which is the shared forest for all ductions have a lesser degree. parses of the sentences in the intersection. However, Therefore, the number of productions is domiwe wish to go one step further since the parsing (or nated by the first f</context>
</contexts>
<marker>Lang, 1994</marker>
<rawString>Bernard Lang. 1994. Recognition can be harder than parsing. In Computational Intelligence, Vol. 10, No. 4, pages 486-494.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yves Schabes</author>
<author>Stuart M Shieber</author>
</authors>
<title>An Alternative Conception of Tree-Adjoining Derivation.</title>
<date>1994</date>
<journal>In ACL Computational Linguistics,</journal>
<volume>20</volume>
<pages>91--124</pages>
<contexts>
<context position="1475" citStr="Schabes and Shieber, 1994" startWordPosition="234" endWordPosition="237">d computations. 1 Introduction The class of mildly context-sensitive languages can be described by several equivalent grammar types. Among these types we can notably cite tree adjoining grammars (TAGs) and linear indexed grammars (LIGs). In (Vijay-Shanker and Weir, 1994) TAGs are transformed into equivalent LIGs. Though context-sensitive linguistic phenomena seem to be more naturally expressed in TAG formalism, from a computational point of view, many authors think that LIGs play a central role and therefore the understanding of LIGs and LIG parsing is of importance. For example, quoted from (Schabes and Shieber, 1994) &amp;quot;The LIG version of TAG can be used for recognition and parsing. Because the LIG formalism is based on augmented rewriting, the parsing algorithms can be much simpler to understand 1See (Boullier, 1996) for an extended version. and easier to modify, and no loss of generality is incurred&amp;quot;. In (Vijay-Shanker and Weir, 1993) LIGs are used to express the derivations of a sentence in TAGs. In (Vijay-Shanker, Weir and Rambow, 1995) the approach used for parsing a new formalism, the D-Tree Grammars (DTG), is to translate a DTG into a Linear Prioritized Multiset Grammar which is similar to a LIG but </context>
</contexts>
<marker>Schabes, Shieber, 1994</marker>
<rawString>Yves Schabes, Stuart M. Shieber. 1994. An Alternative Conception of Tree-Adjoining Derivation. In ACL Computational Linguistics, Vol. 20, No. 1, pages 91-124.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shanker</author>
</authors>
<title>A study of tree adjoining grammars.</title>
<date>1987</date>
<tech>PhD thesis,</tech>
<institution>University of Pennsylvania.</institution>
<contexts>
<context position="16884" citStr="Vijay-Shanker, 1987" startWordPosition="3135" endWordPosition="3136">ty, in of parse trees can be exponential in the size of the time and space, of DL.. Let n be the length of input. Moreover, it is problematic that a worst case the input string x. Since G is in binary form we polynomial size structure could be reached by some know that the shared parse forest Gx can be build sharing compatible both with the syntactic and the in 0(n3) time and the number of its productions &amp;quot;semantic&amp;quot; features. is also in 0(n3). Moreover, the cardinality of Vifi However, we know that derivations in TAGs are is 0(n2) and, for any given non-terminal, say [A]l), context-free (see (Vijay-Shanker, 1987)) and (Vijay- there are at most 0(n) [A]-productions. Of course, Shanker and Weir, 1993) exhibits a CFG which rep- these complexities extend to the LIGed forest L&apos;. resents all possible derivation sequences in a TAG. We now look at the LDG complexity when the We will show that the analogous holds for LIGs and input LIG is a LIGed forest. In fact, we mainly have leads to an 0(n6) time parsing algorithm. to check two forms of productions (see definition 3). Definition 4 Let L (VN, VT PL, S) be a LIG, The first form is production (6) ([A -0- C] [B G = (VN,VT, PG, S) its CF-backbone, x a string CI</context>
</contexts>
<marker>Vijay-Shanker, 1987</marker>
<rawString>K. Vijay-Shanker. 1987. A study of tree adjoining grammars. PhD thesis, University of Pennsylvania.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shanker</author>
<author>David J Weir</author>
</authors>
<title>The Used of Shared Forests in Tree Adjoining Grammar Parsing.</title>
<date>1993</date>
<booktitle>In Proceedings of the 6th Conference of the European Chapter of the Association for Computational Linguistics (EACL&apos;93),</booktitle>
<pages>384--393</pages>
<location>Utrecht, The</location>
<contexts>
<context position="1799" citStr="Vijay-Shanker and Weir, 1993" startWordPosition="290" endWordPosition="293"> context-sensitive linguistic phenomena seem to be more naturally expressed in TAG formalism, from a computational point of view, many authors think that LIGs play a central role and therefore the understanding of LIGs and LIG parsing is of importance. For example, quoted from (Schabes and Shieber, 1994) &amp;quot;The LIG version of TAG can be used for recognition and parsing. Because the LIG formalism is based on augmented rewriting, the parsing algorithms can be much simpler to understand 1See (Boullier, 1996) for an extended version. and easier to modify, and no loss of generality is incurred&amp;quot;. In (Vijay-Shanker and Weir, 1993) LIGs are used to express the derivations of a sentence in TAGs. In (Vijay-Shanker, Weir and Rambow, 1995) the approach used for parsing a new formalism, the D-Tree Grammars (DTG), is to translate a DTG into a Linear Prioritized Multiset Grammar which is similar to a LIG but uses multisets in place of stacks. LIGs can be seen as usual context-free grammars (CFGs) upon which constraints are imposed. These constraints are expressed by stacks of symbols associated with non-terminals. We study parsing of LIGs, our goal being to define a structure that verifies the LIG constraints and codes all (an</context>
<context position="15426" citStr="Vijay-Shanker and Weir, 1993" startWordPosition="2872" endWordPosition="2875">st for a given input string x. In a second phase, the LIG conditions are checked on this forest. This checking can result in some subtree (production) deletions, namely the ones for which there is no valid symbol stack evaluation. If the resulting grammar is not empty, then x is a sentence. However, in the general case, this resulting grammar is not a shared parse forest for the initial LIG in the sense that the computation of stack of symbols along spines are not guaranteed to be consistent. Such invalid spines are not deleted during the check of the LIG conditions because they could be 7In (Vijay-Shanker and Weir, 1993) the emptiness problem for LIGs is solved by constructing an FSA. 90 composed of sub-spines which are themselves parts The recognition problem for (L, x) (i.e. is x an of other valid spines. One way to solve this problem element of f(L)) is equivalent to the non-emptiness is to unfold the shared parse forest and to extract of the production set of DL-. individual parse trees. A parse tree is then kept if Moreover, each linear SO/x-derivation in L is (the the LIG conditions are valid on that tree. But such reverse of) a string in f(DL. )6. So the extraction of a method is not practical since th</context>
</contexts>
<marker>Vijay-Shanker, Weir, 1993</marker>
<rawString>K. Vijay-Shanker, David J. Weir. 1993. The Used of Shared Forests in Tree Adjoining Grammar Parsing. In Proceedings of the 6th Conference of the European Chapter of the Association for Computational Linguistics (EACL&apos;93), Utrecht, The Netherlands, pages 384-393.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shanker</author>
<author>David J Weir</author>
</authors>
<title>Parsing some constrained grammar formalisms.</title>
<date>1994</date>
<journal>In ACL Computational Linguistics,</journal>
<volume>19</volume>
<pages>591--636</pages>
<contexts>
<context position="1120" citStr="Vijay-Shanker and Weir, 1994" startWordPosition="178" endWordPosition="181">which lead to x. We show that this grammar can be built in 0(n6) time and that individual parses can be extracted in linear time with the size of the extracted parse tree. Though this 0(n6) upper bound does not improve over previous results, the average case behaves much better. Moreover, practical parsing times can be decreased by some statically performed computations. 1 Introduction The class of mildly context-sensitive languages can be described by several equivalent grammar types. Among these types we can notably cite tree adjoining grammars (TAGs) and linear indexed grammars (LIGs). In (Vijay-Shanker and Weir, 1994) TAGs are transformed into equivalent LIGs. Though context-sensitive linguistic phenomena seem to be more naturally expressed in TAG formalism, from a computational point of view, many authors think that LIGs play a central role and therefore the understanding of LIGs and LIG parsing is of importance. For example, quoted from (Schabes and Shieber, 1994) &amp;quot;The LIG version of TAG can be used for recognition and parsing. Because the LIG formalism is based on augmented rewriting, the parsing algorithms can be much simpler to understand 1See (Boullier, 1996) for an extended version. and easier to mo</context>
<context position="7608" citStr="Vijay-Shanker and Weir, 1994" startWordPosition="1343" endWordPosition="1346">x- An indexed grammar is a CFG in which stack of derivations, where x E L(G), can itself be defined symbols are associated with non-terminals. LIGs are by a grammar. a restricted form of indexed grammars in which the Definition 1 Let G = (VN,VT,P,S) be a CFG, dependence between stacks is such that at most one its rightmost derivation grammar is the CFG D = stack in the RHS of a production is related with the (VN , P, PD , S) where PD = {,40 441 Aqr I r = stack in its LHS. Other non-terminals are associated Ao woAiwi E P A wi E Vgt A Aj E with independant stacks of bounded size. VN} Following (Vijay-Shanker and Weir, 1994) LFrom the natural bijection between P and Pp, Definition 2 L = (VN,VT)VI)PL,S) denotes a we can easily prove that LIG where VN, VT, VI and Pi, are respectively fir(D) = P.n. • • ri I nite sets of non-terminals, terminals, stack symbols ri rn is a rightmost Six-derivation in G} and productions, and S is the start symbol. In the sequel we will only consider a restricted 88 2if x = al ... an, the states can be the integers 0. 0 is the initial state, n the unique final state, and the transition function 6 is s.t. i E (5(i —1, ai) and i E 5(i, e). form of LIGs with productions of the form FL = {A(</context>
</contexts>
<marker>Vijay-Shanker, Weir, 1994</marker>
<rawString>K. Vijay-Shanker, David J. Weir. 1994. Parsing some constrained grammar formalisms. In ACL Computational Linguistics, Vol. 19, No. 4, pages 591-636.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shanker</author>
<author>David J Weir</author>
<author>Owen Rambow</author>
</authors>
<title>Parsing D-Tree Grammars.</title>
<date>1995</date>
<booktitle>In Proceedings of the fourth international workshop on parsing technologies (IWPT&apos;95), Prague and Karlovy Vary,</booktitle>
<pages>252--259</pages>
<location>Czech Republic,</location>
<marker>Vijay-Shanker, Weir, Rambow, 1995</marker>
<rawString>K. Vijay-Shanker, David J. Weir, Owen Rambow. 1995. Parsing D-Tree Grammars. In Proceedings of the fourth international workshop on parsing technologies (IWPT&apos;95), Prague and Karlovy Vary, Czech Republic, pages 252-259.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>