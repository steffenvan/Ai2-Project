<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000001">
<title confidence="0.942175">
DATR Theories and DATR Models
</title>
<author confidence="0.995762">
Bill Keller
</author>
<affiliation confidence="0.997574">
School of Cognitive and Computing Sciences
The University of Sussex
</affiliation>
<address confidence="0.598334">
Brighton, UK
</address>
<email confidence="0.998618">
email: billk@cogs.susx.ac.uk
</email>
<sectionHeader confidence="0.993792" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999771352941177">
Evans and Gazdar (Evans and Gazdar,
1989a; Evans and Gazdar, 1989b) intro-
duced DATR as a simple, non-monotonic
language for representing natural language
lexicons. Although a number of implemen-
tations of DATR exist, the full language has
until now lacked an explicit, declarative se-
mantics. This paper rectifies the situation
by providing a mathematical semantics for
DATR. We present a view of DATR as a lan-
guage for defining certain kinds of partial
functions by cases. The formal model pro-
vides a transparent treatment of DATR&apos;s
notion of global context. It is shown that
DATR&apos;s default mechanism can be accoun-
ted for by interpreting value descriptors as
families of values indexed by paths.
</bodyText>
<sectionHeader confidence="0.998991" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999656272727273">
DATR was introduced by Evans and Gazdar (1989a;
1989b) as a simple, declarative language for repre-
senting lexical knowledge in terms of path/value
equations. The language lacks many of the con-
structs found in general purpose, knowledge repre-
sentation formalisms, yet it has sufficient expressive
power to capture concisely the structure of lexical
information at a variety of levels of linguistic des-
cription. At the present time, DATR is probably the
most widely-used formalism for representing natu-
ral language lexicons in the natural language pro-
cessing (NLP) community. There are around a do-
zen different implementations of the language and
large DATR lexicons have been constructed for use
in a variety of applications (Cahill and Evans, 1990;
Andry et al., 1992; Cahill, 1994). DATR has been
applied to problems in inflectional and derivational
morphology (Gazdar, 1992; Kilbury, 1992; Corbett
and Fraser, 1993), lexical semantics (Kilgariff, 1993),
morphonology (Cahill, 1993), prosody (Gibbon and
Bleiching, 1991) and speech (Andry et al., 1992). In
more recent work, the language has been used to
provide a concise encoding of Lexicalised Tree Ad-
joining Grammar (Evans et al., 1994; Evans et al.,
1995).
A primary objective in the development of DATR
has been the provision of an explicit, mathematically
rigorous semantics. This goal was addressed in one
of the first publications on the language (Evans and
Gazdar, 1989b). The definitions given there deal
with a subset of DATR that includes core features of
the language such as the notions of local and global
inheritance and DATR&apos;s default mechanism. Howe-
ver, they exclude some important and widely-used
constructs, most notably string (or &apos;list&apos;) values and
evaluable paths. Moreover, it is by no means clear
that the approach can be generalized appropriately
to cover these features. In particular, the formal ap-
paratus introduced by Evans and Gazdar in (1989b)
provides no explicit model of DATR &apos;s notion of glo-
bal context. Rather, local and global inheritance are
represented by distinct semantic functions C and g.
This approach is possible only on the (overly restric-
tive) assumption that DATR statements involve eit-
her local or global inheritance relations, but never
both.
The purpose of the present paper is to remedy
the deficiencies of the work described in (Evans and
Gazdar, 1989b) by furnishing DATR with a trans-
parent, mathematical semantics. There is a stan-
dard view of DATR as a language for representing a
certain class of non-monotonic inheritance networks
(&apos;semantic nets&apos;). While this perspective provides
an intuitive and appealing way of thinking about the
structure and representation of lexical knowledge, it
is less clear that it provides an accurate or particu-
larly helpful picture of the DATR language itself. In
fact, there are a number of constructs available in
DATR that are impossible to visualize in terms of
simple inheritance hierarchies. For this reason, the
work described in this paper reflects a rather diffe-
rent perspective on DATR, as a language for defining
certain kinds of partial functions by cases. In the fol-
lowing sections this viewpoint is made more precise.
Section 2 presents the syntax of the DATR language
and introduces the notion of a DATR theory. An
</bodyText>
<page confidence="0.997505">
55
</page>
<bodyText confidence="0.99987775">
informal introduction to the DATR language is pro-
vided, by example, in section 3. The semantics of
DATR is then covered in two stages. Section 4.1
introduces DATR interepretations and describes the
semantics of a restricted version of the language wit-
hout defaults. The treatment of implicit information
is covered in section 4.2, which provides a definition
of a default model for a DATR theory.
</bodyText>
<sectionHeader confidence="0.991294" genericHeader="method">
2 DATR Theories
</sectionHeader>
<bodyText confidence="0.998656833333333">
Let NODE and ATOM be disjoint sets of symbols (the
nodes and atoms respectively). Nodes are denoted
by N and atoms by a. The set DESC of DATR value
descriptors (or simply descriptors) is built up from
the atoms and nodes as shown below. Descriptors
are denoted by d.
</bodyText>
<listItem confidence="0.999925">
• a E DESC for any a E ATOM
• For any N E NODE and (11 ... dr, E DESC:
</listItem>
<equation confidence="0.9199645">
N : (di • • • dn) E DESC
&amp;quot;N: (di dn)&amp;quot; E DESC
• • cl„)&amp;quot; E DESC
&amp;quot;N&amp;quot; E DESC
</equation>
<bodyText confidence="0.951768117647059">
Value descriptors are either atoms or inheritance
descriptors, where an inheritance descriptor is fur-
ther distinguished as either local (unquoted) or glo-
bal (quoted). There is just one kind of local descrip-
tor (node/path), but three kinds of global descriptor
(node/path, path and node) 1.
A path (al an) is a (possibly empty) sequence
of atoms enclosed in angle brackets. Paths are deno-
ted by P. For N a node, P a path and a E ATOM* a
(possibly empty) sequence of atoms, an equation of
the form N : P = a is called an extensional sentence.
Intuitively, an extensional sentence N : P = a states
that the value associated with the path P at node
N is a. For a (possibly empty) sequence of value
descriptors, an equation of the form N : P ==
is called a definitional sentence. A definitional sent-
ence N : P == 4) specifies a property of the node N,
namely that the path P is associated with the value
defined by the sequence of value descriptors 0.
A collection of equations can be used to specify the
properties of different nodes in terms of one another,
and a finite set of DATR sentences T is called a DATR
theory. In principle, a DATR theory T may consist
of any combination of DATR sentences, either defini-
tional or extensional, but in practice, DATR theories
are more restricted than this. The theory T is said
to be definitional if it consists solely of definitional
sentences and it is said to be functional if it meets
the following condition:
&apos;The syntax presented in (Evans and Gazdar, 1989a;
Evans and Gazdar, 1989b) permits nodes and paths to
stand as local descriptors. However, these additional
forms can be viewed as conventional abbreviations, in
the appropriate syntactic context, for node/path pairs
</bodyText>
<equation confidence="0.98857">
N : P == (1) and N : P == E &apos;T implies
</equation>
<bodyText confidence="0.998566736842105">
There is a pragmatic distinction between defini-
tional and extensional sentences akin to that drawn
between the language used to define a database and
that used to query it. DATR interpreters conventio-
nally treat all extensional sentences as &apos;goal&apos; state-
ments, and evaluate them as soon as they are en-
countered. Thus, it is not possible, in practice, to
combine definitional and extensional sentences wi-
thin a theory2. Functionality for DATR theories, as
defined above, is really a syntactic notion. Howe-
ver, it approximates a deeper, semantic requirement
that the nodes should correspond to (partial) func-
tions from paths to values.
In the remainder of this paper we will use the term
(DATR) theory always in the sense functional, defi-
nitional (DATR) theory. For a given DATR theory
T and node N of T, we write TIN to denote that
subset of the sentences in T that relate to the node
N. That is:
</bodyText>
<equation confidence="0.913753">
TIN = E Tls = N : P ==
</equation>
<bodyText confidence="0.840962">
The set TIN is referred to as the definition of N
(in T).
</bodyText>
<sectionHeader confidence="0.956743" genericHeader="method">
3 An Overview of DATR
</sectionHeader>
<bodyText confidence="0.999878153846154">
An example of (a fragment of) a DATR theory is
shown in figure 1. The theory makes use of some
standard abbreviatory devices that enable nodes
and/or paths to be omitted in certain cases. For
example, sets of sentences relating to the same node
are written with the node name implicit in all but
the first-given sentence in the set. Also, we write
See : == Verb to abbreviate the definitional
sentence See : == Verb : (), and similarly else-
where.
The theory defines the properties of seven nodes:
an abstract Verb node, nodes EnVerb, Aux and
Modal, and three abstract lexemes Walk, Mow
and Can. Each node is associated with a collec-
tion of definitional sentences that specify values as-
sociated with different paths. This specification is
achieved either explicitly, or implicitly. Values given
explicitly are specified either directly, by exhibiting
a particular value, or indirectly, in terms of local
and/or global inheritance. Implicit specification is
achieved via DATR &apos;s default mechanism.
For example, the definition of the Verb node gives
the values of the paths (syn cat) and (syn type)
directly, as verb and main, respectively. Similarly,
the definition of Walk gives the value of (mor root)
directly as walk. On the other hand, the value of
</bodyText>
<footnote confidence="0.794335">
2It is not clear why one would wish to do this anyway,
but the possibility is explicitly left open in the original
definitions of (Evans and Gazdar, 1989a).
</footnote>
<page confidence="0.994242">
56
</page>
<bodyText confidence="0.947677428571428">
Verb: (syn cat) == verb
(syn type) == main
(mor form) == &amp;quot;(mor &amp;quot;(syn form)&amp;quot;)&amp;quot;
(mor pres) == &amp;quot;(mor root)&amp;quot;
(mor past) == &amp;quot;(mor root)&amp;quot; ed
(mor pres part) == &amp;quot;(mor root)&amp;quot; ing
(mor pres sing three) == &amp;quot;(mor root)&amp;quot; s
</bodyText>
<table confidence="0.470276692307692">
EnVerb : Ø== Verb
(mor past part) == &amp;quot;(mor root)&amp;quot; en
Aux: () == Verb
(syn type) == aux
Modal: () == Aux
(mor pres sing three) == &amp;quot;(mor root)&amp;quot;
Walk: () == Verb
Mow: (mor root) == walk
Can: () == EnVerb
(mor root) == mow
Ø== Modal
(mor root) == can
(mor past) == could
</table>
<figureCaption confidence="0.999626">
Figure 1: A DATR Theory
</figureCaption>
<bodyText confidence="0.993287641509434">
the empty path at Walk is given indirectly, by local
inheritance, as the value of the empty path at Verb.
Note that in itself, this might not appear to be par-
ticularly useful, since the theory does not provide an
explicit value for the empty path in the definition of
Verb. However, DATR&apos;s default mechanism permits
any definitional sentence to be applicable not only
to the path specified in its left-hand-side, but also
for any rightward extension of that path for which
no more specific definitional sentences exist. This
means that the statement Walk : 0 == Verb : 0
actually corresponds to a class of implicit definitio-
nal sentences, each obtained by extending paths on
the left- and the right-hand-sides of the equation in
the same manner. Examples include the following:
Walk: (mor) == Verb: (mor)
Walk: (mor form) == Verb: (mor form)
Walk: (syn cat) == Verb: (syn cat)
Thus, the value associated with (syn cat) at
Walk is given (implicitly) as the value of (syn cat)
at Verb, which is given (explicitly) as verb. Also,
the values of (mor) and (mor form), amongst
many others, are inherited from Verb. In the same
way, the value of (syn cat) at Mow is inherited lo-
cally from EnVerb (which in turn inherits locally
from Verb) and the value of (syn cat) at Can is
inherited locally from Modal (which ultimately gets
its value from Verb via Aux). Note however, that
the following sentences do not follow by default from
the specifications given at the relevant nodes:
Walk: (mor root) == Verb: (mor root)
Can: (mor past) == Modal: (mor past)
Aux : (syn type) == Verb: (syn type)
In each of the above cases, the theory provides an
explicit statement about the value associated with
the indicated path at the given node. As a result
the default mechanism is effectively over-ridden.
In order to understand the use of global (i.e. quo-
ted) inheritance descriptors it is necessary to intro-
duce DATR&apos;s notion of a global context. Suppose
then that we wish to determine the value associated
with the path (mor pres) at the node Walk. In
this case, the global context will initially consist of
the node/path pair Walk/(mor pres). Now, by de-
fault the value associated with (mor pres) at Walk
is inherited locally from (mor pres) at Verb. This,
in turn, inherits globally from the path (mor root).
That is:
Verb: (mor pres) == &amp;quot;(mor root)&amp;quot;
Consequently, the required value is that associated
with (mor root) at the &apos;global node&apos; Walk (i.e.
the node provided by the current global context),
which is just walk. In a similar fashion, the value
</bodyText>
<page confidence="0.997104">
57
</page>
<figureCaption confidence="0.999743">
Figure 2: A Lexical Inheritance Hierarchy
</figureCaption>
<bodyText confidence="0.997310833333334">
associated with (mor past) at Walk is obtained as
walk ed (i.e. the string of atoms formed by evalua-
ting the specification &amp;quot;(mor root)&amp;quot; ed in the global
context Walk/(mor past)).
More generally, the global context is used to fill in
the missing node (path) when a global path (node)
is encountered. In addition however, the evalua-
tion of a global descriptor results in the global con-
text being set to the new node/path pair. Thus in
the preceding example, after the quoted descriptor
&amp;quot;(mor root)&amp;quot; is encountered, the global context ef-
fectively becomes Walk / (mor root) (i.e. the path
component of the global context is altered). Note
that there is a real distinction between a local inhe-
ritance descriptor of the form N : P and it&apos;s global
counterpart &amp;quot;N : P&amp;quot;. The former has no effect on
the global context, while the latter effectively over-
writes it.
Finally, the definition of Verb in the theory of
figure 1 illustrates a use of the &apos;evaluable path&apos; con-
struct:
Verb: (mor form) == &amp;quot;(mor &amp;quot;(syn form)&amp;quot;)&amp;quot;
This states that the value of (mor form) at Verb
is inherited globally from the path (mor • • .), where
the dots represent the result of evaluating the global
path &amp;quot;(syn form)&amp;quot; (i.e. the value associated with
(syn form) in the prevailing global context). Eva-
luable paths provide a powerful means of capturing
generalizations about the structure of lexical infor-
mation.
</bodyText>
<sectionHeader confidence="0.99953" genericHeader="method">
4 DATR Models
</sectionHeader>
<bodyText confidence="0.999693833333333">
To a first level of approximation, the DATR theory
of figure 1 can be understood as a representation of
an inheritance hierarchy (a &apos;semantic network&apos;) as
shown in figure 2. In the diagram, nodes are written
as labelled boxes, and arcs correspond to (local) in-
heritance, or isa links. Thus, the node Can inherits
from Modal which inherits from Aux which in turn
is a Verb. The hierarchy provides a useful means of
visualising the overall structure of the lexical know-
ledge encoded by the DATR theory. However, the
semantic network metaphor is of far less value as
a way of thinking about the DATR language itself.
Note that there is nothing inherent in DATR to en-
sure that theories correspond to simple isa hierar-
chies of the kind shown in the figure. What is more,
the DATR language includes constructs that cannot
be visualized in terms of simple networks of nodes
connected by (local) inheritance links. Global inhe-
ritance, for example, has a dynamic aspect which is
difficult to represent in terms of static links. Simi-
lar problems are presented by both string values and
evaluable paths. Our conclusion is that the network
metaphor is of primary value to the DATR user. In
order to provide a satisfactory, formal model of how
the language &apos;works&apos; it is necessary to adopt a diffe-
rent perspective.
DATR theories can be viewed semantically as coll-
ections of definitions of partial functions (&apos;nodes&apos; in
DATR parlance) that map paths onto values. A mo-
del of a DATR theory is then an assignment of func-
</bodyText>
<page confidence="0.991449">
58
</page>
<bodyText confidence="0.999920416666667">
tions to node symbols that is consistent with the
definitions of those nodes within the theory. This
picture of DATR as a formalism for defining partial
functions is complicated by two features of the lan-
guage however. First, the meaning of a given node
depends, in general, on the global context of inter-
pretation, so that nodes do not correspond directly
to mappings from paths to values, but rather to func-
tions from contexts to such mappings. Second, it is
necessary to provide an account of DATR&apos;s default
mechanism. It will be convenient to present our ac-
count of the semantics of DATR in two stages.
</bodyText>
<subsectionHeader confidence="0.924745">
4.1 DATR Interpretations
</subsectionHeader>
<bodyText confidence="0.9948962">
This section considers a restricted version of DATR
without the default mechanism. Section 4.2 then
shows how implicit information can be modelled by
treating value descriptors as families of values in-
dexed by paths.
</bodyText>
<equation confidence="0.688057857142857">
Definition 4.1 A DATR interpretation is a triple
I = (U, F), where
1. U is a set;
2. lc is a function assigning to each element of the
set (U x U*) a partial function from (U x U*)
to U.
3. F is a valuation function assigning to each node
</equation>
<bodyText confidence="0.951919595744681">
N and atom a an element of U, such that di-
stinct atoms are assigned distinct elements.
Elements of the set U are denoted by u and ele-
ments of U* are denoted by v. Intuitively, U* is the
domain of (semantic) values/paths. Elements of the
set C = (U x U*) are called contexts and denoted
by c. The function K can be thought of as mapping
global contexts onto (partial) functions from local
contexts to values. The function F is extended to
paths, so that for P = (al • • an) (n &gt; 0) we write
F(P) to denote u1 • • • un E U*, where ui = F(a1) for
each i (1 &lt; i &lt; n).
Intuitively, value descriptors denote elements of
U* (as we shall see, this will need to be revised later
in order to account for DATR&apos;s default mechanism).
We associate with the interpretation I = (U, ic, F) a
partial denotation function ni : DESC (C —+ U*)
and write [lc to denote the meaning (value) of de-
scriptor d in the global context c. The denotation
function is defined as shown in figure 3. Note that
an atom always denotes the same element of U, re-
gardless of the context. By contrast, the denotation
of an inheritance descriptor is, in general, sensitive
to the global context c in which it appears. Note
also that in the case of a global inheritance descrip-
tor, the global context is effectively altered to reflect
the new local context c&apos;. The denotation function is
extended to sequences of value descriptors in the ob-
vious way. Thus, for 0 = di. • • (n &gt; 0), we write
[0])c to denote v1 • • vn E U* if vi = (1 &lt;i &lt; n)
is defined (and Plc is undefined otherwise).
Now, let I = (U, tc, F) be an interpretation and
T a theory. We will write [7- INje to denote that
partial function from U* to U* given by
iT= U {(F(P),[010}
It is easy to verify that ITINic does indeed denote a
partial function (it follows from the functionality of
the theory T). Let us also write [NIL to denote that
partial function from U&amp;quot; to U* given by EAric(v) =
,c(c)(F(N),v), for all v E U*. Then, I models T
just in case the following containment holds for each
node N and context c:
In3 [TIN]c
That is, an interpretation is a model of a DATR
theory just in case (for each global context) the func-
tion it associates with each node respects the defini-
tion of that node within the theory.
</bodyText>
<subsectionHeader confidence="0.968139">
4.2 Implicit Information and Default
Models
</subsectionHeader>
<bodyText confidence="0.932789692307692">
The notion of a model presented in the preceding
section is too liberal in that it takes no account of
information implicit in a theory. For example, con-
sider again the definition of the node Walk from the
theory of figure 1, and repeated below.
Walk: Ø== Verb
(mor root) == walk
According to the definition of a model given previ-
ously, any model of the theory of figure 1 will as-
sociate with the node Walk a function from paths
to values which respects the above definition. This
means that for every global context c, the following
containment must hold3:
</bodyText>
<subsectionHeader confidence="0.491539">
[Walkic 3 {((), [Verb : Oh),
</subsectionHeader>
<bodyText confidence="0.977261363636364">
((mor root), walk)}
On the other hand, there is no guarantee that a
given model will also respect the following contain-
ment:
[Walk], 3 {((mor), [Verb: (mor)[,),
((mor root root), walk)}
In fact, this containment (amongst other things)
should hold. It follows &apos;by default&apos; from the state-
ments made about Walk that the path (mor) inhe-
rits locally from Verb and that the value associated
with any extension of (mor root) is walk.
</bodyText>
<footnote confidence="0.998169">
3In this and subsequent examples, syntactic ob-
jects (e.g.walk, (mor root)) are used to stand for
their semantic counterparts under F (i.e. F(walk),
F((mor root)), respectively).
</footnote>
<page confidence="0.989736">
59
</page>
<equation confidence="0.887827">
laic
: (d1 • • •d)i.
1&amp;quot;N : (d1- • • dnric
1&amp;quot;(di • • • dnric
I&amp;quot;N&amp;quot;]1,
Figure 3:
F(a)
</equation>
<bodyText confidence="0.518362">
if vi = Pi], is defined for each i (1 &lt;i &lt; n), then
</bodyText>
<listItem confidence="0.739971">
• .vn)
</listItem>
<bodyText confidence="0.967096688888889">
undefined otherwise
if vi = [di], is defined for each i(1 &lt;i &lt; n), then
tc(d)(&amp;) where c&apos; = (F (N), v1 ••• vn)
undefined otherwise
if vi = IdIc is defined for each i(1 &lt;i &lt; n), then
ic(e)(e) where c = (u, v) and c&apos; = (u, v1 • •• vn)
undefined otherwise
,c(ci)„) where c = (u, v) and c&apos; = (F (N),
Denotation function for DATR Descriptors
There have been a number of formal treatments of
defaults in the setting of attribute-value formalisms
(Carpenter, 1993; Bouma, 1992; Russell et al., 1992;
Young and Rounds, 1993). Each of these approa-
ches formalizes a notion of default inheritance by
defining appropriate operations (e.g. default unifi-
cation) for combining strict and default information.
Strict information is allowed to over-ride default in-
formation where the combination would otherwise
lead to inconsistency (i.e. unification failure). In
the case of DATR however, the formalism does not
draw an explicit distinction between strict and de-
fault values for paths. In fact, all of the information
given explicitly in a DATR theory is strict. The non-
monotonic nature of DATR theories arises from a
general, default mechanism which &apos;fills in the gaps&apos;
by supplying values for paths not explicitly speci-
fied in a theory. More specifically, DATR&apos;s default
mechanism ensures that any path that is not expli-
citly specified for a given node will take its definition
from the longest prefix of that path that is specified.
Thus, the default mechanism defines a class of im-
plicit, definitional sentences with paths on the left
that extend paths found on the left of explicit sent-
ences. Furthermore, this extension of paths is also
carried over to paths occurring on the right. In ef-
fect, each (explicit) path is associated not just with a
single value specification, but with a whole family of
specifications indexed by extensions of those paths.
This suggests the following approach to the se-
mantics of defaults in DATR. Rather than interpre-
ting node definitions (in a given global context) as
partial functions from paths to values (i.e. of type
U5 U&amp;quot;) we choose instead to interpret them as
partial functions from (explicit) paths, to functions
from extensions of those paths to values (i.e. of type
</bodyText>
<equation confidence="0.599430333333333">
U* (U* U5)). Now suppose that f : U*
(US —+ U*) is the function associated with the node
definition TIN in a given DATR interpretation. We
</equation>
<bodyText confidence="0.96058">
can define a partial function A(f) : U* U* (the
default interpretation of TIN) as follows. For each
</bodyText>
<equation confidence="0.9524995">
V E U* set
A(f)(v) = f(vi)(v2)
</equation>
<bodyText confidence="0.982470763157894">
where v = vi v2 and vi is the longest prefix of v
such that f(vi) is defined. In effect, the function
(f) makes explicit that information about paths
and values that is only implicit in f, but just in so
far as it does not conflict with explicit information
provided by f.
In order to re-interpret node definitions in the
manner suggested above, it is necessary to modify
the interpretation of value descriptors. In a given
global context c, a value descriptor d now corre-
sponds to a total function [dic : U* U* (intui-
tively, a function from path extensions to values).
For example, atoms now denote constant functions:
Ictie(v) = F(a) for all v E U*
More generally, value descriptors will denote dif-
ferent values for different paths. Figure 4 shows the
revised clause for global node/path pairs, the other
definitions being very similar. Note the way in which
the &apos;path&apos; argument v is used to extend v1 • • • vn in
order to define the new local (and in this case also,
global) context c&apos;. On the other hand, the meaning
of each of the di is obtained with respect to the &apos;em-
pty path&apos; c (i.e. path extension does not apply to
subterms of inheritance descriptors).
As before, the interpretation function is extended
to sequences of path descriptors, so that for 0 =
d1 • • • dn (n &gt; o) we have 101c(v) = vi • • • vn E U&amp;quot;, if
= [dilly) is defined, for each i (1 &lt; i &lt; n) (and
101,(v) is undefined otherwise). The definition of
the interpretation of node definitions can be taken
over unchanged from the previous section. However,
for a theory T and node N, the function 1T/N1, is
now of type U* —+ (U* —4. U5). An interpretation
I = (U, rc, F) is a default model for theory T just in
case for every context c and node N we have:
ENI, 2 A([T/NJ)
As an example, consider the default interpretation
of the definition of the node Walk given above. By
</bodyText>
<page confidence="0.931559">
60
</page>
<equation confidence="0.644722666666667">
{ if vi = [dilc(E) is defined for each i(1 &lt;i &lt; n), then
[&amp;quot;N : (d1 • - - dn)&amp;quot;1,(v) = tc(c&apos;)(c1) where c&apos; = (F (N), v1 - • - vv)
undefined otherwise
</equation>
<figureCaption confidence="0.998618">
Figure 4: Revised denotation for global node/path pairs
</figureCaption>
<bodyText confidence="0.923653909090909">
definition, any default model of the theory of figure 1
must respect the following containment:
[Walkjc 2 AM() , Av.[Verb :
((mor root), Av.walk)}
LFrom the definition of A, it follows that for any
path v, if v extends (mor root), then it is mapped
onto the value walk, and otherwise it is mapped to
the value given by [Verb : 01,(v). We have the
following picture:
[Walk], 2 1(0, [Verb :
((mor), [Verb:
</bodyText>
<listItem confidence="0.822464">
• - -
</listItem>
<bodyText confidence="0.982259">
((mor root), walk),
((mor root root), walk),
- • -}
The default models of a theory T constitute a pro-
per subset of the models of T: just those that respect
the default interpretations of each of the nodes defi-
ned within the theory.
</bodyText>
<sectionHeader confidence="0.999568" genericHeader="conclusions">
5 Conclusions
</sectionHeader>
<bodyText confidence="0.995142896551724">
The work described in this paper fulfils one of the
objectives of the DATR programme: to provide the
language with an explicit, declarative semantics. We
have presented a formal model of DATR as a lan-
guage for defining partial functions and this model
has been contrasted with an informal view of DATR
as a language for representing inheritance hierar-
chies. The approach provides a transparent treat-
ment of DATR&apos;s notion of (local and global) context
and accounts for DATR&apos;s default mechanism by re-
garding value descriptors (semantically) as families
of values indexed by paths.
The provision of a formal semantics for DATR
is important for several reasons. First, it provi-
des the DATR user with a concise, implementation-
independent account of the meaning of DATR theo-
ries. Second, it serves as a standard against which
other, operational definitions of the formalism can
be judged. Indeed, in the absence of such a stan-
dard, it is impossible to demonstrate formally the
correctness of novel implementation strategies (for
an example of such a strategy, see (Langer, 1994)).
Third, the process of formalisation itself aids our
understanding of the language and its relationship
to other non-monotonic, attribute-value formalisms.
Finally, the semantics presented in this paper provi-
des a sound basis for subsequent investigations into
the mathematical and computational properties of
DATR.
</bodyText>
<sectionHeader confidence="0.99896" genericHeader="acknowledgments">
6 Acknowledgements
</sectionHeader>
<bodyText confidence="0.998709">
The author would like to thank Roger Evans, Gerald
Gazdar, Bill Rounds and David Weir for helpful dis-
cussions on the work described in this paper.
</bodyText>
<sectionHeader confidence="0.999374" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.990801911764706">
Francois Andry, Norman Fraser, Scott McGlashan,
Simon Thornton, and Nick Youd. 1992. Ma-
king DATR work for speech: lexicon compila-
tion in SUNDIAL. Computational Linguistics,
18(3):245-267.
Gosse Bouma. 1992. Feature structures and nonmo-
notonicity. Computational Linguistics, 18(2):183—
203.
Lynne Cahill and Roger Evans. 1990. An applica-
tion of DATR: the TIC lexicon. In Proceedings of
the 9th European Conference on Artificial Intelli-
gence, pages 120-125.
Lynne Cahill. 1993. Morphonology in the lexicon.
In Proceedings of the 6th Conference of the Euro-
pean Chapter of the Association for Computatio-
nal Linguistics, pages 87-96.
Lynne Cahill. 1994. An inheritance-based lexicon
for message understanding systems. In Procee-
dings of the 4th ACL Conference on Applied Na-
tural Language Processing, pages 211-212.
Bob Carpenter. 1993. Skeptical and credulous de-
fault unification with applications to templates
and inheritance. In Ted Briscoe, Valeria de Paiva,
and Ann Copestake, editors, Inheritance, Defaults
and the Lexicon, pages 13-37. Cambridge Univer-
sity Press, Cambridge.
Greville Corbett and Norman Fraser. 1993. Net-
work morphology: a DATR account of Russian
nominal inflection. Journal of Linguistics, 29:113-
142.
Roger Evans and Gerald Gazdar. 1989a. Inference
in DATR. In Proceedings of the 4th Conference of
the European Chapter of the Association for Com-
putational Linguistics, pages 66-71.
</reference>
<page confidence="0.983578">
61
</page>
<reference confidence="0.999494409090909">
Roger Evans and Gerald Gazdar. 1989b. The se-
mantics of DATR. In Proceedings of AISB-89,
pages 79-87.
Roger Evans, Gerald Gazdar, and David Weir.
1994. Using default inheritance to describe LTAG.
In Sc Colloque International sur les Grammaires
d&apos;Arbres Adjoints (TAG+3), pages 79-87.
Roger Evans, Gerald Gazdar, and David Weir.
1995. Encoding lexicalized tree adjoining gram-
mars with a nonmonotonic inheritance hierarchy.
In Proceedings of The 33rd Annual Meeting of the
Association for Computational Linguistics.
Gerald Gazdar. 1992. Paradigm function morpho-
logy in DATR. In Lynne Cahill and Richard Coa-
tes, editors, Sussex Papers in General and Compu-
tational Linguistics, number CSRP 239 in Cogni-
tive Science Research Papers, pages 45-53. Uni-
versity of Sussex, Brighton.
Dafydd Gibbon and Doris Bleiching. 1991. An
ILEX model for German compound stress in
DATR. In Proceedings of the FOR WISS-ASL
Workshop on Prosody in Man-Machine Commu-
nication.
James Kilbury. 1992. Pardigm-based derivational
morphology. In Guenther Goerz, editor, Procee-
dings of KONVENS 92, pages 159-168. Springer,
Berlin.
Adam Kilgariff. 1993. Inheriting verb alternations.
In Proceedings of the 6th Conference of the Euro-
pean Chapter of the Association for Computatio-
nal Linguistics, pages 213-221.
Hagen Langer. 1994. Reverse queries in DATR. In
Proceedings of the 15th International Conference
on Computational Linguistics, volume II, pages
1089-1095, Kyoto.
Graham Russell, Afzal Ballim, John Carroll, and
Susan Warwick-Armstrong. 1992. A practi-
cal approach to multiple default inheritance for
unification-based lexicons. Computational Lingui-
stics, 18(2):311-337.
Mark Young and Bill Rounds. 1993. A logical se-
mantics for nonmonotonic sorts. In Proceedings
of the 31st Annual Meeting of the Association for
Computational Linguistics, pages 209-215.
</reference>
<page confidence="0.999187">
62
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.962680">
<title confidence="0.990041">DATR Theories and DATR Models</title>
<author confidence="0.999466">Bill Keller</author>
<affiliation confidence="0.9997885">School of Cognitive and Computing Sciences The University of Sussex</affiliation>
<address confidence="0.993244">Brighton, UK</address>
<email confidence="0.998624">billk@cogs.susx.ac.uk</email>
<abstract confidence="0.998594">Evans and Gazdar (Evans and Gazdar, 1989a; Evans and Gazdar, 1989b) introduced DATR as a simple, non-monotonic language for representing natural language lexicons. Although a number of implementations of DATR exist, the full language has until now lacked an explicit, declarative semantics. This paper rectifies the situation by providing a mathematical semantics for DATR. We present a view of DATR as a language for defining certain kinds of partial functions by cases. The formal model provides a transparent treatment of DATR&apos;s notion of global context. It is shown that DATR&apos;s default mechanism can be accounted for by interpreting value descriptors as families of values indexed by paths.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Francois Andry</author>
<author>Norman Fraser</author>
<author>Scott McGlashan</author>
<author>Simon Thornton</author>
<author>Nick Youd</author>
</authors>
<title>Making DATR work for speech: lexicon compilation in SUNDIAL.</title>
<date>1992</date>
<journal>Computational Linguistics,</journal>
<pages>18--3</pages>
<contexts>
<context position="1638" citStr="Andry et al., 1992" startWordPosition="254" endWordPosition="257">uations. The language lacks many of the constructs found in general purpose, knowledge representation formalisms, yet it has sufficient expressive power to capture concisely the structure of lexical information at a variety of levels of linguistic description. At the present time, DATR is probably the most widely-used formalism for representing natural language lexicons in the natural language processing (NLP) community. There are around a dozen different implementations of the language and large DATR lexicons have been constructed for use in a variety of applications (Cahill and Evans, 1990; Andry et al., 1992; Cahill, 1994). DATR has been applied to problems in inflectional and derivational morphology (Gazdar, 1992; Kilbury, 1992; Corbett and Fraser, 1993), lexical semantics (Kilgariff, 1993), morphonology (Cahill, 1993), prosody (Gibbon and Bleiching, 1991) and speech (Andry et al., 1992). In more recent work, the language has been used to provide a concise encoding of Lexicalised Tree Adjoining Grammar (Evans et al., 1994; Evans et al., 1995). A primary objective in the development of DATR has been the provision of an explicit, mathematically rigorous semantics. This goal was addressed in one of</context>
</contexts>
<marker>Andry, Fraser, McGlashan, Thornton, Youd, 1992</marker>
<rawString>Francois Andry, Norman Fraser, Scott McGlashan, Simon Thornton, and Nick Youd. 1992. Making DATR work for speech: lexicon compilation in SUNDIAL. Computational Linguistics, 18(3):245-267.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gosse Bouma</author>
</authors>
<title>Feature structures and nonmonotonicity.</title>
<date>1992</date>
<journal>Computational Linguistics,</journal>
<volume>18</volume>
<issue>2</issue>
<pages>203</pages>
<contexts>
<context position="20294" citStr="Bouma, 1992" startWordPosition="3590" endWordPosition="3591">laic : (d1 • • •d)i. 1&amp;quot;N : (d1- • • dnric 1&amp;quot;(di • • • dnric I&amp;quot;N&amp;quot;]1, Figure 3: F(a) if vi = Pi], is defined for each i (1 &lt;i &lt; n), then • .vn) undefined otherwise if vi = [di], is defined for each i(1 &lt;i &lt; n), then tc(d)(&amp;) where c&apos; = (F (N), v1 ••• vn) undefined otherwise if vi = IdIc is defined for each i(1 &lt;i &lt; n), then ic(e)(e) where c = (u, v) and c&apos; = (u, v1 • •• vn) undefined otherwise ,c(ci)„) where c = (u, v) and c&apos; = (F (N), Denotation function for DATR Descriptors There have been a number of formal treatments of defaults in the setting of attribute-value formalisms (Carpenter, 1993; Bouma, 1992; Russell et al., 1992; Young and Rounds, 1993). Each of these approaches formalizes a notion of default inheritance by defining appropriate operations (e.g. default unification) for combining strict and default information. Strict information is allowed to over-ride default information where the combination would otherwise lead to inconsistency (i.e. unification failure). In the case of DATR however, the formalism does not draw an explicit distinction between strict and default values for paths. In fact, all of the information given explicitly in a DATR theory is strict. The nonmonotonic natu</context>
</contexts>
<marker>Bouma, 1992</marker>
<rawString>Gosse Bouma. 1992. Feature structures and nonmonotonicity. Computational Linguistics, 18(2):183— 203.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lynne Cahill</author>
<author>Roger Evans</author>
</authors>
<title>An application of DATR: the TIC lexicon.</title>
<date>1990</date>
<booktitle>In Proceedings of the 9th European Conference on Artificial Intelligence,</booktitle>
<pages>120--125</pages>
<contexts>
<context position="1618" citStr="Cahill and Evans, 1990" startWordPosition="250" endWordPosition="253">n terms of path/value equations. The language lacks many of the constructs found in general purpose, knowledge representation formalisms, yet it has sufficient expressive power to capture concisely the structure of lexical information at a variety of levels of linguistic description. At the present time, DATR is probably the most widely-used formalism for representing natural language lexicons in the natural language processing (NLP) community. There are around a dozen different implementations of the language and large DATR lexicons have been constructed for use in a variety of applications (Cahill and Evans, 1990; Andry et al., 1992; Cahill, 1994). DATR has been applied to problems in inflectional and derivational morphology (Gazdar, 1992; Kilbury, 1992; Corbett and Fraser, 1993), lexical semantics (Kilgariff, 1993), morphonology (Cahill, 1993), prosody (Gibbon and Bleiching, 1991) and speech (Andry et al., 1992). In more recent work, the language has been used to provide a concise encoding of Lexicalised Tree Adjoining Grammar (Evans et al., 1994; Evans et al., 1995). A primary objective in the development of DATR has been the provision of an explicit, mathematically rigorous semantics. This goal was</context>
</contexts>
<marker>Cahill, Evans, 1990</marker>
<rawString>Lynne Cahill and Roger Evans. 1990. An application of DATR: the TIC lexicon. In Proceedings of the 9th European Conference on Artificial Intelligence, pages 120-125.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lynne Cahill</author>
</authors>
<title>Morphonology in the lexicon.</title>
<date>1993</date>
<booktitle>In Proceedings of the 6th Conference of the European Chapter of the Association for Computational Linguistics,</booktitle>
<pages>87--96</pages>
<contexts>
<context position="1854" citStr="Cahill, 1993" startWordPosition="284" endWordPosition="285">ty of levels of linguistic description. At the present time, DATR is probably the most widely-used formalism for representing natural language lexicons in the natural language processing (NLP) community. There are around a dozen different implementations of the language and large DATR lexicons have been constructed for use in a variety of applications (Cahill and Evans, 1990; Andry et al., 1992; Cahill, 1994). DATR has been applied to problems in inflectional and derivational morphology (Gazdar, 1992; Kilbury, 1992; Corbett and Fraser, 1993), lexical semantics (Kilgariff, 1993), morphonology (Cahill, 1993), prosody (Gibbon and Bleiching, 1991) and speech (Andry et al., 1992). In more recent work, the language has been used to provide a concise encoding of Lexicalised Tree Adjoining Grammar (Evans et al., 1994; Evans et al., 1995). A primary objective in the development of DATR has been the provision of an explicit, mathematically rigorous semantics. This goal was addressed in one of the first publications on the language (Evans and Gazdar, 1989b). The definitions given there deal with a subset of DATR that includes core features of the language such as the notions of local and global inheritanc</context>
</contexts>
<marker>Cahill, 1993</marker>
<rawString>Lynne Cahill. 1993. Morphonology in the lexicon. In Proceedings of the 6th Conference of the European Chapter of the Association for Computational Linguistics, pages 87-96.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lynne Cahill</author>
</authors>
<title>An inheritance-based lexicon for message understanding systems.</title>
<date>1994</date>
<booktitle>In Proceedings of the 4th ACL Conference on Applied Natural Language Processing,</booktitle>
<pages>211--212</pages>
<contexts>
<context position="1653" citStr="Cahill, 1994" startWordPosition="258" endWordPosition="259">e lacks many of the constructs found in general purpose, knowledge representation formalisms, yet it has sufficient expressive power to capture concisely the structure of lexical information at a variety of levels of linguistic description. At the present time, DATR is probably the most widely-used formalism for representing natural language lexicons in the natural language processing (NLP) community. There are around a dozen different implementations of the language and large DATR lexicons have been constructed for use in a variety of applications (Cahill and Evans, 1990; Andry et al., 1992; Cahill, 1994). DATR has been applied to problems in inflectional and derivational morphology (Gazdar, 1992; Kilbury, 1992; Corbett and Fraser, 1993), lexical semantics (Kilgariff, 1993), morphonology (Cahill, 1993), prosody (Gibbon and Bleiching, 1991) and speech (Andry et al., 1992). In more recent work, the language has been used to provide a concise encoding of Lexicalised Tree Adjoining Grammar (Evans et al., 1994; Evans et al., 1995). A primary objective in the development of DATR has been the provision of an explicit, mathematically rigorous semantics. This goal was addressed in one of the first publ</context>
</contexts>
<marker>Cahill, 1994</marker>
<rawString>Lynne Cahill. 1994. An inheritance-based lexicon for message understanding systems. In Proceedings of the 4th ACL Conference on Applied Natural Language Processing, pages 211-212.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bob Carpenter</author>
</authors>
<title>Skeptical and credulous default unification with applications to templates and inheritance.</title>
<date>1993</date>
<booktitle>Inheritance, Defaults and the Lexicon,</booktitle>
<pages>13--37</pages>
<editor>In Ted Briscoe, Valeria de Paiva, and Ann Copestake, editors,</editor>
<publisher>Cambridge University Press,</publisher>
<location>Cambridge.</location>
<contexts>
<context position="20281" citStr="Carpenter, 1993" startWordPosition="3588" endWordPosition="3589">espectively). 59 laic : (d1 • • •d)i. 1&amp;quot;N : (d1- • • dnric 1&amp;quot;(di • • • dnric I&amp;quot;N&amp;quot;]1, Figure 3: F(a) if vi = Pi], is defined for each i (1 &lt;i &lt; n), then • .vn) undefined otherwise if vi = [di], is defined for each i(1 &lt;i &lt; n), then tc(d)(&amp;) where c&apos; = (F (N), v1 ••• vn) undefined otherwise if vi = IdIc is defined for each i(1 &lt;i &lt; n), then ic(e)(e) where c = (u, v) and c&apos; = (u, v1 • •• vn) undefined otherwise ,c(ci)„) where c = (u, v) and c&apos; = (F (N), Denotation function for DATR Descriptors There have been a number of formal treatments of defaults in the setting of attribute-value formalisms (Carpenter, 1993; Bouma, 1992; Russell et al., 1992; Young and Rounds, 1993). Each of these approaches formalizes a notion of default inheritance by defining appropriate operations (e.g. default unification) for combining strict and default information. Strict information is allowed to over-ride default information where the combination would otherwise lead to inconsistency (i.e. unification failure). In the case of DATR however, the formalism does not draw an explicit distinction between strict and default values for paths. In fact, all of the information given explicitly in a DATR theory is strict. The nonm</context>
</contexts>
<marker>Carpenter, 1993</marker>
<rawString>Bob Carpenter. 1993. Skeptical and credulous default unification with applications to templates and inheritance. In Ted Briscoe, Valeria de Paiva, and Ann Copestake, editors, Inheritance, Defaults and the Lexicon, pages 13-37. Cambridge University Press, Cambridge.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Greville Corbett</author>
<author>Norman Fraser</author>
</authors>
<title>Network morphology: a DATR account of Russian nominal inflection.</title>
<date>1993</date>
<journal>Journal of Linguistics,</journal>
<pages>29--113</pages>
<contexts>
<context position="1788" citStr="Corbett and Fraser, 1993" startWordPosition="275" endWordPosition="278">ive power to capture concisely the structure of lexical information at a variety of levels of linguistic description. At the present time, DATR is probably the most widely-used formalism for representing natural language lexicons in the natural language processing (NLP) community. There are around a dozen different implementations of the language and large DATR lexicons have been constructed for use in a variety of applications (Cahill and Evans, 1990; Andry et al., 1992; Cahill, 1994). DATR has been applied to problems in inflectional and derivational morphology (Gazdar, 1992; Kilbury, 1992; Corbett and Fraser, 1993), lexical semantics (Kilgariff, 1993), morphonology (Cahill, 1993), prosody (Gibbon and Bleiching, 1991) and speech (Andry et al., 1992). In more recent work, the language has been used to provide a concise encoding of Lexicalised Tree Adjoining Grammar (Evans et al., 1994; Evans et al., 1995). A primary objective in the development of DATR has been the provision of an explicit, mathematically rigorous semantics. This goal was addressed in one of the first publications on the language (Evans and Gazdar, 1989b). The definitions given there deal with a subset of DATR that includes core features </context>
</contexts>
<marker>Corbett, Fraser, 1993</marker>
<rawString>Greville Corbett and Norman Fraser. 1993. Network morphology: a DATR account of Russian nominal inflection. Journal of Linguistics, 29:113-142.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Roger Evans</author>
<author>Gerald Gazdar</author>
</authors>
<title>Inference in DATR.</title>
<date>1989</date>
<booktitle>In Proceedings of the 4th Conference of the European Chapter of the Association for Computational Linguistics,</booktitle>
<pages>66--71</pages>
<contexts>
<context position="916" citStr="Evans and Gazdar (1989" startWordPosition="141" endWordPosition="144">ing natural language lexicons. Although a number of implementations of DATR exist, the full language has until now lacked an explicit, declarative semantics. This paper rectifies the situation by providing a mathematical semantics for DATR. We present a view of DATR as a language for defining certain kinds of partial functions by cases. The formal model provides a transparent treatment of DATR&apos;s notion of global context. It is shown that DATR&apos;s default mechanism can be accounted for by interpreting value descriptors as families of values indexed by paths. 1 Introduction DATR was introduced by Evans and Gazdar (1989a; 1989b) as a simple, declarative language for representing lexical knowledge in terms of path/value equations. The language lacks many of the constructs found in general purpose, knowledge representation formalisms, yet it has sufficient expressive power to capture concisely the structure of lexical information at a variety of levels of linguistic description. At the present time, DATR is probably the most widely-used formalism for representing natural language lexicons in the natural language processing (NLP) community. There are around a dozen different implementations of the language and </context>
<context position="2301" citStr="Evans and Gazdar, 1989" startWordPosition="356" endWordPosition="359"> problems in inflectional and derivational morphology (Gazdar, 1992; Kilbury, 1992; Corbett and Fraser, 1993), lexical semantics (Kilgariff, 1993), morphonology (Cahill, 1993), prosody (Gibbon and Bleiching, 1991) and speech (Andry et al., 1992). In more recent work, the language has been used to provide a concise encoding of Lexicalised Tree Adjoining Grammar (Evans et al., 1994; Evans et al., 1995). A primary objective in the development of DATR has been the provision of an explicit, mathematically rigorous semantics. This goal was addressed in one of the first publications on the language (Evans and Gazdar, 1989b). The definitions given there deal with a subset of DATR that includes core features of the language such as the notions of local and global inheritance and DATR&apos;s default mechanism. However, they exclude some important and widely-used constructs, most notably string (or &apos;list&apos;) values and evaluable paths. Moreover, it is by no means clear that the approach can be generalized appropriately to cover these features. In particular, the formal apparatus introduced by Evans and Gazdar in (1989b) provides no explicit model of DATR &apos;s notion of global context. Rather, local and global inheritance a</context>
<context position="6470" citStr="Evans and Gazdar, 1989" startWordPosition="1090" endWordPosition="1093">iated with the value defined by the sequence of value descriptors 0. A collection of equations can be used to specify the properties of different nodes in terms of one another, and a finite set of DATR sentences T is called a DATR theory. In principle, a DATR theory T may consist of any combination of DATR sentences, either definitional or extensional, but in practice, DATR theories are more restricted than this. The theory T is said to be definitional if it consists solely of definitional sentences and it is said to be functional if it meets the following condition: &apos;The syntax presented in (Evans and Gazdar, 1989a; Evans and Gazdar, 1989b) permits nodes and paths to stand as local descriptors. However, these additional forms can be viewed as conventional abbreviations, in the appropriate syntactic context, for node/path pairs N : P == (1) and N : P == E &apos;T implies There is a pragmatic distinction between definitional and extensional sentences akin to that drawn between the language used to define a database and that used to query it. DATR interpreters conventionally treat all extensional sentences as &apos;goal&apos; statements, and evaluate them as soon as they are encountered. Thus, it is not possible, in pra</context>
<context position="9130" citStr="Evans and Gazdar, 1989" startWordPosition="1553" endWordPosition="1556">lues given explicitly are specified either directly, by exhibiting a particular value, or indirectly, in terms of local and/or global inheritance. Implicit specification is achieved via DATR &apos;s default mechanism. For example, the definition of the Verb node gives the values of the paths (syn cat) and (syn type) directly, as verb and main, respectively. Similarly, the definition of Walk gives the value of (mor root) directly as walk. On the other hand, the value of 2It is not clear why one would wish to do this anyway, but the possibility is explicitly left open in the original definitions of (Evans and Gazdar, 1989a). 56 Verb: (syn cat) == verb (syn type) == main (mor form) == &amp;quot;(mor &amp;quot;(syn form)&amp;quot;)&amp;quot; (mor pres) == &amp;quot;(mor root)&amp;quot; (mor past) == &amp;quot;(mor root)&amp;quot; ed (mor pres part) == &amp;quot;(mor root)&amp;quot; ing (mor pres sing three) == &amp;quot;(mor root)&amp;quot; s EnVerb : Ø== Verb (mor past part) == &amp;quot;(mor root)&amp;quot; en Aux: () == Verb (syn type) == aux Modal: () == Aux (mor pres sing three) == &amp;quot;(mor root)&amp;quot; Walk: () == Verb Mow: (mor root) == walk Can: () == EnVerb (mor root) == mow Ø== Modal (mor root) == can (mor past) == could Figure 1: A DATR Theory the empty path at Walk is given indirectly, by local inheritance, as the value of the empty</context>
</contexts>
<marker>Evans, Gazdar, 1989</marker>
<rawString>Roger Evans and Gerald Gazdar. 1989a. Inference in DATR. In Proceedings of the 4th Conference of the European Chapter of the Association for Computational Linguistics, pages 66-71.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Roger Evans</author>
<author>Gerald Gazdar</author>
</authors>
<title>The semantics of DATR.</title>
<date>1989</date>
<booktitle>In Proceedings of AISB-89,</booktitle>
<pages>79--87</pages>
<contexts>
<context position="916" citStr="Evans and Gazdar (1989" startWordPosition="141" endWordPosition="144">ing natural language lexicons. Although a number of implementations of DATR exist, the full language has until now lacked an explicit, declarative semantics. This paper rectifies the situation by providing a mathematical semantics for DATR. We present a view of DATR as a language for defining certain kinds of partial functions by cases. The formal model provides a transparent treatment of DATR&apos;s notion of global context. It is shown that DATR&apos;s default mechanism can be accounted for by interpreting value descriptors as families of values indexed by paths. 1 Introduction DATR was introduced by Evans and Gazdar (1989a; 1989b) as a simple, declarative language for representing lexical knowledge in terms of path/value equations. The language lacks many of the constructs found in general purpose, knowledge representation formalisms, yet it has sufficient expressive power to capture concisely the structure of lexical information at a variety of levels of linguistic description. At the present time, DATR is probably the most widely-used formalism for representing natural language lexicons in the natural language processing (NLP) community. There are around a dozen different implementations of the language and </context>
<context position="2301" citStr="Evans and Gazdar, 1989" startWordPosition="356" endWordPosition="359"> problems in inflectional and derivational morphology (Gazdar, 1992; Kilbury, 1992; Corbett and Fraser, 1993), lexical semantics (Kilgariff, 1993), morphonology (Cahill, 1993), prosody (Gibbon and Bleiching, 1991) and speech (Andry et al., 1992). In more recent work, the language has been used to provide a concise encoding of Lexicalised Tree Adjoining Grammar (Evans et al., 1994; Evans et al., 1995). A primary objective in the development of DATR has been the provision of an explicit, mathematically rigorous semantics. This goal was addressed in one of the first publications on the language (Evans and Gazdar, 1989b). The definitions given there deal with a subset of DATR that includes core features of the language such as the notions of local and global inheritance and DATR&apos;s default mechanism. However, they exclude some important and widely-used constructs, most notably string (or &apos;list&apos;) values and evaluable paths. Moreover, it is by no means clear that the approach can be generalized appropriately to cover these features. In particular, the formal apparatus introduced by Evans and Gazdar in (1989b) provides no explicit model of DATR &apos;s notion of global context. Rather, local and global inheritance a</context>
<context position="6470" citStr="Evans and Gazdar, 1989" startWordPosition="1090" endWordPosition="1093">iated with the value defined by the sequence of value descriptors 0. A collection of equations can be used to specify the properties of different nodes in terms of one another, and a finite set of DATR sentences T is called a DATR theory. In principle, a DATR theory T may consist of any combination of DATR sentences, either definitional or extensional, but in practice, DATR theories are more restricted than this. The theory T is said to be definitional if it consists solely of definitional sentences and it is said to be functional if it meets the following condition: &apos;The syntax presented in (Evans and Gazdar, 1989a; Evans and Gazdar, 1989b) permits nodes and paths to stand as local descriptors. However, these additional forms can be viewed as conventional abbreviations, in the appropriate syntactic context, for node/path pairs N : P == (1) and N : P == E &apos;T implies There is a pragmatic distinction between definitional and extensional sentences akin to that drawn between the language used to define a database and that used to query it. DATR interpreters conventionally treat all extensional sentences as &apos;goal&apos; statements, and evaluate them as soon as they are encountered. Thus, it is not possible, in pra</context>
<context position="9130" citStr="Evans and Gazdar, 1989" startWordPosition="1553" endWordPosition="1556">lues given explicitly are specified either directly, by exhibiting a particular value, or indirectly, in terms of local and/or global inheritance. Implicit specification is achieved via DATR &apos;s default mechanism. For example, the definition of the Verb node gives the values of the paths (syn cat) and (syn type) directly, as verb and main, respectively. Similarly, the definition of Walk gives the value of (mor root) directly as walk. On the other hand, the value of 2It is not clear why one would wish to do this anyway, but the possibility is explicitly left open in the original definitions of (Evans and Gazdar, 1989a). 56 Verb: (syn cat) == verb (syn type) == main (mor form) == &amp;quot;(mor &amp;quot;(syn form)&amp;quot;)&amp;quot; (mor pres) == &amp;quot;(mor root)&amp;quot; (mor past) == &amp;quot;(mor root)&amp;quot; ed (mor pres part) == &amp;quot;(mor root)&amp;quot; ing (mor pres sing three) == &amp;quot;(mor root)&amp;quot; s EnVerb : Ø== Verb (mor past part) == &amp;quot;(mor root)&amp;quot; en Aux: () == Verb (syn type) == aux Modal: () == Aux (mor pres sing three) == &amp;quot;(mor root)&amp;quot; Walk: () == Verb Mow: (mor root) == walk Can: () == EnVerb (mor root) == mow Ø== Modal (mor root) == can (mor past) == could Figure 1: A DATR Theory the empty path at Walk is given indirectly, by local inheritance, as the value of the empty</context>
</contexts>
<marker>Evans, Gazdar, 1989</marker>
<rawString>Roger Evans and Gerald Gazdar. 1989b. The semantics of DATR. In Proceedings of AISB-89, pages 79-87.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Roger Evans</author>
<author>Gerald Gazdar</author>
<author>David Weir</author>
</authors>
<title>Using default inheritance to describe LTAG.</title>
<date>1994</date>
<booktitle>In Sc Colloque International sur les Grammaires d&apos;Arbres Adjoints (TAG+3),</booktitle>
<pages>79--87</pages>
<contexts>
<context position="2061" citStr="Evans et al., 1994" startWordPosition="317" endWordPosition="320">. There are around a dozen different implementations of the language and large DATR lexicons have been constructed for use in a variety of applications (Cahill and Evans, 1990; Andry et al., 1992; Cahill, 1994). DATR has been applied to problems in inflectional and derivational morphology (Gazdar, 1992; Kilbury, 1992; Corbett and Fraser, 1993), lexical semantics (Kilgariff, 1993), morphonology (Cahill, 1993), prosody (Gibbon and Bleiching, 1991) and speech (Andry et al., 1992). In more recent work, the language has been used to provide a concise encoding of Lexicalised Tree Adjoining Grammar (Evans et al., 1994; Evans et al., 1995). A primary objective in the development of DATR has been the provision of an explicit, mathematically rigorous semantics. This goal was addressed in one of the first publications on the language (Evans and Gazdar, 1989b). The definitions given there deal with a subset of DATR that includes core features of the language such as the notions of local and global inheritance and DATR&apos;s default mechanism. However, they exclude some important and widely-used constructs, most notably string (or &apos;list&apos;) values and evaluable paths. Moreover, it is by no means clear that the approac</context>
</contexts>
<marker>Evans, Gazdar, Weir, 1994</marker>
<rawString>Roger Evans, Gerald Gazdar, and David Weir. 1994. Using default inheritance to describe LTAG. In Sc Colloque International sur les Grammaires d&apos;Arbres Adjoints (TAG+3), pages 79-87.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Roger Evans</author>
<author>Gerald Gazdar</author>
<author>David Weir</author>
</authors>
<title>Encoding lexicalized tree adjoining grammars with a nonmonotonic inheritance hierarchy.</title>
<date>1995</date>
<booktitle>In Proceedings of The 33rd Annual Meeting of the Association for Computational Linguistics.</booktitle>
<contexts>
<context position="2082" citStr="Evans et al., 1995" startWordPosition="321" endWordPosition="324"> dozen different implementations of the language and large DATR lexicons have been constructed for use in a variety of applications (Cahill and Evans, 1990; Andry et al., 1992; Cahill, 1994). DATR has been applied to problems in inflectional and derivational morphology (Gazdar, 1992; Kilbury, 1992; Corbett and Fraser, 1993), lexical semantics (Kilgariff, 1993), morphonology (Cahill, 1993), prosody (Gibbon and Bleiching, 1991) and speech (Andry et al., 1992). In more recent work, the language has been used to provide a concise encoding of Lexicalised Tree Adjoining Grammar (Evans et al., 1994; Evans et al., 1995). A primary objective in the development of DATR has been the provision of an explicit, mathematically rigorous semantics. This goal was addressed in one of the first publications on the language (Evans and Gazdar, 1989b). The definitions given there deal with a subset of DATR that includes core features of the language such as the notions of local and global inheritance and DATR&apos;s default mechanism. However, they exclude some important and widely-used constructs, most notably string (or &apos;list&apos;) values and evaluable paths. Moreover, it is by no means clear that the approach can be generalized </context>
</contexts>
<marker>Evans, Gazdar, Weir, 1995</marker>
<rawString>Roger Evans, Gerald Gazdar, and David Weir. 1995. Encoding lexicalized tree adjoining grammars with a nonmonotonic inheritance hierarchy. In Proceedings of The 33rd Annual Meeting of the Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gerald Gazdar</author>
</authors>
<title>Paradigm function morphology in DATR.</title>
<date>1992</date>
<booktitle>Sussex Papers in General and Computational Linguistics, number CSRP 239 in Cognitive Science Research Papers,</booktitle>
<pages>45--53</pages>
<editor>In Lynne Cahill and Richard Coates, editors,</editor>
<institution>University of Sussex,</institution>
<location>Brighton.</location>
<contexts>
<context position="1746" citStr="Gazdar, 1992" startWordPosition="271" endWordPosition="272">yet it has sufficient expressive power to capture concisely the structure of lexical information at a variety of levels of linguistic description. At the present time, DATR is probably the most widely-used formalism for representing natural language lexicons in the natural language processing (NLP) community. There are around a dozen different implementations of the language and large DATR lexicons have been constructed for use in a variety of applications (Cahill and Evans, 1990; Andry et al., 1992; Cahill, 1994). DATR has been applied to problems in inflectional and derivational morphology (Gazdar, 1992; Kilbury, 1992; Corbett and Fraser, 1993), lexical semantics (Kilgariff, 1993), morphonology (Cahill, 1993), prosody (Gibbon and Bleiching, 1991) and speech (Andry et al., 1992). In more recent work, the language has been used to provide a concise encoding of Lexicalised Tree Adjoining Grammar (Evans et al., 1994; Evans et al., 1995). A primary objective in the development of DATR has been the provision of an explicit, mathematically rigorous semantics. This goal was addressed in one of the first publications on the language (Evans and Gazdar, 1989b). The definitions given there deal with a s</context>
</contexts>
<marker>Gazdar, 1992</marker>
<rawString>Gerald Gazdar. 1992. Paradigm function morphology in DATR. In Lynne Cahill and Richard Coates, editors, Sussex Papers in General and Computational Linguistics, number CSRP 239 in Cognitive Science Research Papers, pages 45-53. University of Sussex, Brighton.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dafydd Gibbon</author>
<author>Doris Bleiching</author>
</authors>
<title>An ILEX model for German compound stress in DATR.</title>
<date>1991</date>
<booktitle>In Proceedings of the FOR WISS-ASL Workshop on Prosody in Man-Machine Communication.</booktitle>
<contexts>
<context position="1892" citStr="Gibbon and Bleiching, 1991" startWordPosition="287" endWordPosition="290">ic description. At the present time, DATR is probably the most widely-used formalism for representing natural language lexicons in the natural language processing (NLP) community. There are around a dozen different implementations of the language and large DATR lexicons have been constructed for use in a variety of applications (Cahill and Evans, 1990; Andry et al., 1992; Cahill, 1994). DATR has been applied to problems in inflectional and derivational morphology (Gazdar, 1992; Kilbury, 1992; Corbett and Fraser, 1993), lexical semantics (Kilgariff, 1993), morphonology (Cahill, 1993), prosody (Gibbon and Bleiching, 1991) and speech (Andry et al., 1992). In more recent work, the language has been used to provide a concise encoding of Lexicalised Tree Adjoining Grammar (Evans et al., 1994; Evans et al., 1995). A primary objective in the development of DATR has been the provision of an explicit, mathematically rigorous semantics. This goal was addressed in one of the first publications on the language (Evans and Gazdar, 1989b). The definitions given there deal with a subset of DATR that includes core features of the language such as the notions of local and global inheritance and DATR&apos;s default mechanism. Howeve</context>
</contexts>
<marker>Gibbon, Bleiching, 1991</marker>
<rawString>Dafydd Gibbon and Doris Bleiching. 1991. An ILEX model for German compound stress in DATR. In Proceedings of the FOR WISS-ASL Workshop on Prosody in Man-Machine Communication.</rawString>
</citation>
<citation valid="true">
<authors>
<author>James Kilbury</author>
</authors>
<title>Pardigm-based derivational morphology.</title>
<date>1992</date>
<booktitle>Proceedings of KONVENS 92,</booktitle>
<pages>159--168</pages>
<editor>In Guenther Goerz, editor,</editor>
<publisher>Springer,</publisher>
<location>Berlin.</location>
<contexts>
<context position="1761" citStr="Kilbury, 1992" startWordPosition="273" endWordPosition="274">ficient expressive power to capture concisely the structure of lexical information at a variety of levels of linguistic description. At the present time, DATR is probably the most widely-used formalism for representing natural language lexicons in the natural language processing (NLP) community. There are around a dozen different implementations of the language and large DATR lexicons have been constructed for use in a variety of applications (Cahill and Evans, 1990; Andry et al., 1992; Cahill, 1994). DATR has been applied to problems in inflectional and derivational morphology (Gazdar, 1992; Kilbury, 1992; Corbett and Fraser, 1993), lexical semantics (Kilgariff, 1993), morphonology (Cahill, 1993), prosody (Gibbon and Bleiching, 1991) and speech (Andry et al., 1992). In more recent work, the language has been used to provide a concise encoding of Lexicalised Tree Adjoining Grammar (Evans et al., 1994; Evans et al., 1995). A primary objective in the development of DATR has been the provision of an explicit, mathematically rigorous semantics. This goal was addressed in one of the first publications on the language (Evans and Gazdar, 1989b). The definitions given there deal with a subset of DATR t</context>
</contexts>
<marker>Kilbury, 1992</marker>
<rawString>James Kilbury. 1992. Pardigm-based derivational morphology. In Guenther Goerz, editor, Proceedings of KONVENS 92, pages 159-168. Springer, Berlin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Adam Kilgariff</author>
</authors>
<title>Inheriting verb alternations.</title>
<date>1993</date>
<booktitle>In Proceedings of the 6th Conference of the European Chapter of the Association for Computational Linguistics,</booktitle>
<pages>213--221</pages>
<contexts>
<context position="1825" citStr="Kilgariff, 1993" startWordPosition="281" endWordPosition="282">f lexical information at a variety of levels of linguistic description. At the present time, DATR is probably the most widely-used formalism for representing natural language lexicons in the natural language processing (NLP) community. There are around a dozen different implementations of the language and large DATR lexicons have been constructed for use in a variety of applications (Cahill and Evans, 1990; Andry et al., 1992; Cahill, 1994). DATR has been applied to problems in inflectional and derivational morphology (Gazdar, 1992; Kilbury, 1992; Corbett and Fraser, 1993), lexical semantics (Kilgariff, 1993), morphonology (Cahill, 1993), prosody (Gibbon and Bleiching, 1991) and speech (Andry et al., 1992). In more recent work, the language has been used to provide a concise encoding of Lexicalised Tree Adjoining Grammar (Evans et al., 1994; Evans et al., 1995). A primary objective in the development of DATR has been the provision of an explicit, mathematically rigorous semantics. This goal was addressed in one of the first publications on the language (Evans and Gazdar, 1989b). The definitions given there deal with a subset of DATR that includes core features of the language such as the notions o</context>
</contexts>
<marker>Kilgariff, 1993</marker>
<rawString>Adam Kilgariff. 1993. Inheriting verb alternations. In Proceedings of the 6th Conference of the European Chapter of the Association for Computational Linguistics, pages 213-221.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hagen Langer</author>
</authors>
<title>Reverse queries in DATR.</title>
<date>1994</date>
<booktitle>In Proceedings of the 15th International Conference on Computational Linguistics, volume II,</booktitle>
<pages>1089--1095</pages>
<location>Kyoto.</location>
<marker>Langer, 1994</marker>
<rawString>Hagen Langer. 1994. Reverse queries in DATR. In Proceedings of the 15th International Conference on Computational Linguistics, volume II, pages 1089-1095, Kyoto.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Graham Russell</author>
<author>Afzal Ballim</author>
<author>John Carroll</author>
<author>Susan Warwick-Armstrong</author>
</authors>
<title>A practical approach to multiple default inheritance for unification-based lexicons.</title>
<date>1992</date>
<journal>Computational Linguistics,</journal>
<pages>18--2</pages>
<contexts>
<context position="20316" citStr="Russell et al., 1992" startWordPosition="3592" endWordPosition="3595">• •d)i. 1&amp;quot;N : (d1- • • dnric 1&amp;quot;(di • • • dnric I&amp;quot;N&amp;quot;]1, Figure 3: F(a) if vi = Pi], is defined for each i (1 &lt;i &lt; n), then • .vn) undefined otherwise if vi = [di], is defined for each i(1 &lt;i &lt; n), then tc(d)(&amp;) where c&apos; = (F (N), v1 ••• vn) undefined otherwise if vi = IdIc is defined for each i(1 &lt;i &lt; n), then ic(e)(e) where c = (u, v) and c&apos; = (u, v1 • •• vn) undefined otherwise ,c(ci)„) where c = (u, v) and c&apos; = (F (N), Denotation function for DATR Descriptors There have been a number of formal treatments of defaults in the setting of attribute-value formalisms (Carpenter, 1993; Bouma, 1992; Russell et al., 1992; Young and Rounds, 1993). Each of these approaches formalizes a notion of default inheritance by defining appropriate operations (e.g. default unification) for combining strict and default information. Strict information is allowed to over-ride default information where the combination would otherwise lead to inconsistency (i.e. unification failure). In the case of DATR however, the formalism does not draw an explicit distinction between strict and default values for paths. In fact, all of the information given explicitly in a DATR theory is strict. The nonmonotonic nature of DATR theories ar</context>
</contexts>
<marker>Russell, Ballim, Carroll, Warwick-Armstrong, 1992</marker>
<rawString>Graham Russell, Afzal Ballim, John Carroll, and Susan Warwick-Armstrong. 1992. A practical approach to multiple default inheritance for unification-based lexicons. Computational Linguistics, 18(2):311-337.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Young</author>
<author>Bill Rounds</author>
</authors>
<title>A logical semantics for nonmonotonic sorts.</title>
<date>1993</date>
<booktitle>In Proceedings of the 31st Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>209--215</pages>
<contexts>
<context position="20341" citStr="Young and Rounds, 1993" startWordPosition="3596" endWordPosition="3599"> dnric 1&amp;quot;(di • • • dnric I&amp;quot;N&amp;quot;]1, Figure 3: F(a) if vi = Pi], is defined for each i (1 &lt;i &lt; n), then • .vn) undefined otherwise if vi = [di], is defined for each i(1 &lt;i &lt; n), then tc(d)(&amp;) where c&apos; = (F (N), v1 ••• vn) undefined otherwise if vi = IdIc is defined for each i(1 &lt;i &lt; n), then ic(e)(e) where c = (u, v) and c&apos; = (u, v1 • •• vn) undefined otherwise ,c(ci)„) where c = (u, v) and c&apos; = (F (N), Denotation function for DATR Descriptors There have been a number of formal treatments of defaults in the setting of attribute-value formalisms (Carpenter, 1993; Bouma, 1992; Russell et al., 1992; Young and Rounds, 1993). Each of these approaches formalizes a notion of default inheritance by defining appropriate operations (e.g. default unification) for combining strict and default information. Strict information is allowed to over-ride default information where the combination would otherwise lead to inconsistency (i.e. unification failure). In the case of DATR however, the formalism does not draw an explicit distinction between strict and default values for paths. In fact, all of the information given explicitly in a DATR theory is strict. The nonmonotonic nature of DATR theories arises from a general, defa</context>
</contexts>
<marker>Young, Rounds, 1993</marker>
<rawString>Mark Young and Bill Rounds. 1993. A logical semantics for nonmonotonic sorts. In Proceedings of the 31st Annual Meeting of the Association for Computational Linguistics, pages 209-215.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>