<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000013">
<title confidence="0.873597">
Translating a Unification Grammar with Disjunctions into Logical Constraints
</title>
<note confidence="0.783207666666667">
Mikio Nakano and Akira Shimazu*
NTT Basic Research Laboratories
3-1 Morinosato-Wakamiya, Atsugi 243-0198 Japan
</note>
<email confidence="0.962381">
E-mail: nakano@atom.brl.ntt.cojp, shimazu@jaistac.jp
</email>
<sectionHeader confidence="0.994217" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999664166666667">
This paper proposes a method for generating a logical-
constraint-based internal representation from a unifica-
tion grammar formalism with disjunctive information.
Unification grammar formalisms based on path equa-
tions and lists of pairs of labels and values are better
than those based on first-order terms in that the former
is easier to describe and to understand. Parsing with
term-based internal representations is more efficient than
parsing with graph-based representations. Therefore, it
is effective to translate unification grammar formalism
based on path equations and lists of pairs of labels and
values into a term-based internal representation. Pre-
vious translation methods cannot deal with disjunctive
feature descriptions, which reduce redundancies in the
grammar and make parsing efficient. Since the pro-
posed method translates a formalism without expanding
disjunctions, parsing with the resulting representation is
efficient.
</bodyText>
<sectionHeader confidence="0.998786" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999899052631579">
The objective of our research is to build a natural language
understanding system that is based on unification. The
reason we have chosen a unification-based approach is
that it enables us to describe grammar declaratively,
making the development and amendment of grammar
easy.
Analysis systems that are based on unification gram-
mars can be classified into two groups from the viewpoint
of the ways feature structures are represented: (a) those
using labeled, directed graphs (Shieber, 1984) and (b)
those using first-order terms (Pereira and Warren, 1980;
Matsumoto et al., 1983; Tokunaga et al., 1991).
In addition to internal representation, grammar for-
malisms can be classified into two groups, (i) those that
describe feature structures with path equations and lists
of pairs of labels and values (Mukai and Yasukawa,
1985; Alt-Kaci, 1986; Tsuda, 1994), and (ii) those that
describe feature structures with first-order terms (Pereira
and Warren, 1980; Matsumoto et al., 1983; Tokunaga et
</bodyText>
<listItem confidence="0.851832">
• Presently with Japan Advanced Institute of Science and Technology.
</listItem>
<bodyText confidence="0.997479542857143">
al., 1991). Since formalisms (i) are used in the family
of the PATR parsing systems (Shieber, 1984), hereafter
they will be called PATR-like formalisms.
Most of the previous systems are either ones that
generate representation (a) from formalisms (i) or ones
that generate representation (b) from formalisms (ii).
However, representation (b) is superior, and formalism
(i) is far better. Representation (b) is superior for
the following two reasons. First, unification of terms
is more efficient of that of graphs because the data
structure of terms is simpler (Schoter, 1993).1 Second,
it is easy to represent and process named disjunctions
(Done and Eisele, 1990) in the term-based representation.
Named disjunctions are effective when two or more
disjunctive feature values depend on each other. The
treatment of named disjunctions in graph unification
requires a complex process, while it is simple in our
logical-constraint-based representations. Formalism (i)
is better because term-based formalism is problematic
in that readers need to memorize the correspondence
between arguments and features and it is not easy to
add new features or delete features (Gazdar and Mellish,
1989).
Therefore, it is effective to translate formalism (i)
into representation (b). Previous translation methods2
(Covington, 1989; Hirsh, 1988; Schoter, 1993; Erbach,
1995) are problematic in that they cannot deal with dis-
junctive feature descriptions, which reduce redundancies
in grammar. Moreover, incorporating disjunctive infor-
mation into internal representation makes parsing more
efficient (Kasper, 1987; Eisele and Done, 1988; Maxwell
and Kaplan, 1991; Hasida, 1986).
This paper presents a method for translating grammar
formalism with disjunctive information based on path
equations and lists of pairs of labels and values into term-
</bodyText>
<footnote confidence="0.9693245">
&apos;Since unspecified features are represented by variables in term
unification, when most of the features are unspecified, it is inefficient
to represent feature structures by terms. In current linguistic theories
such as HPSG (Pollard and Sag, 1994), however, thanks to the type
specifications, the number of features that a feature structure can have
is reduced, so it does not cause as much trouble.
2Methods that generate representation (b) after generating represen-
tation (a) are included.
</footnote>
<page confidence="0.998131">
934
</page>
<bodyText confidence="0.9997015">
based representations, without expanding disjunctions.
The formalism used here is feature-based formalism with
disjunctively defined macros (FF-DDM), an extension of
the PATR-like formalisms that incorporates a descrip-
tion of disjunctive information. The representation used
here is logical-constraint-based grammar representation
(LCGR), in which disjunctive feature structures are rep-
resented by Horn clauses.
</bodyText>
<sectionHeader confidence="0.980249" genericHeader="introduction">
2 Unification Grammar Formalisms with
Disjunctive Information
</sectionHeader>
<bodyText confidence="0.973980294117647">
The main difference between PATR and FF-DDM is
that there can be only one definition for one macro
in PATR while multiple definitions are possible in FF-
DDM. These definitions are disjuncts. If the conditions
in one of the definitions of a macro are satisfied, the
condition the macro represents is satisfied. In FF-DDM,
the grammar is described using four kinds of elements:
type definitions, phrase structure rules, lexical entries,
and macro definitions.
Some examples are shown below. The first is an
example of type definition.
(0 (deftype sign
pos agr subj)
This means that there is a type named sign and the
feature structures of type sign can have POS, AGR, and
SUBJ features.
This is an example of a phrase structure rule.
</bodyText>
<listItem confidence="0.792568">
(2) (defrule psrl (s -&gt; np vp)
</listItem>
<equation confidence="0.944630666666667">
(‹s pos&gt; = sentence
&lt;np pos&gt; = noun
&lt;vp pos&gt; = verb
&lt;vp subj&gt; = &lt;np&gt;
&lt;np agr&gt; = &lt;vp agr&gt;
&lt;s agr&gt; = &lt;vp agr&gt; ) )
</equation>
<bodyText confidence="0.999633214285714">
Here psrl is the name of this rule. Variable s denotes
the feature structure of the mother node, and np and
vp are variables that denote the feature structures of the
daughter nodes. Rule psrl denotes the relationship
between three feature structures s, np, and vp. The
fourth argument is a set of path equations. The path
equation &lt;s pos&gt; = sentence indicates that the
POS feature value in the feature structure represented
by the variable s is sentence. The path equation &lt;vp
subj &gt; = &lt;np&gt; means the sum feature value of vp is
identical to the feature structure np. A path can be a list
of pairs of labels and values, although we do not explain
this in detail in this paper.
Next we show an example of a lexical item.
</bodyText>
<listItem confidence="0.980831">
(3) (defword walk (sign)
(&lt;sign pos&gt; = verb
&lt;sign agr&gt; = &lt;sign subj agr&gt;)
(not3s &lt;sign agr&gt;))
</listItem>
<bodyText confidence="0.982109">
Here sign is the variable that represents the lexical
feature structure for walk. The disjunctively defined
macro ( not3 s &lt;sign agr&gt;) in the last line shows
that the AGR feature value of sign must satisfy one of
the definitions of not 3 s.
Examples of macro definitions, or definitions of
not 3s, are shown below.
</bodyText>
<listItem confidence="0.9977726">
(4) (defddmacro not3s (agr)
(&lt;agr num&gt; = sing)
(lst-or-2nd &lt;agr per&gt;))
(5) (defddmacro not3s (agr)
(&lt;agr num&gt; = plural))
</listItem>
<bodyText confidence="0.998735666666667">
If one of these is satisfied, the condition for macro
not 3 s is satisfied. Two definitions, (4) and (5) stand in
a disjunction relation. 3
</bodyText>
<sectionHeader confidence="0.999645" genericHeader="method">
3 Logical-Constraint-Based Grammar
Representation
</sectionHeader>
<subsectionHeader confidence="0.9896935">
3.1 Logical Constraint Representation of
Disjunctive Feature Structures
</subsectionHeader>
<bodyText confidence="0.997835714285714">
We will first define logical constraints. A logical con-
straint (constraint for short) is a set of positive literals of
first-order logic. Each positive literal that is an element
of a constraint is called a constraint element.
An example of a constraint is (6). Constraint elements
are written in the DEC-10 Prolog notation. The names
of variables start with capital letters.
</bodyText>
<listItem confidence="0.847879">
(6) {p(X),g(X, f (Y))1
</listItem>
<bodyText confidence="0.901045">
A definition clause of a predicate is a Horn clause having
that predicate as the predicate of its head. For example,
</bodyText>
<listItem confidence="0.8970015">
(7) is a definition clause of p.4
(7) p(f (X ,Y)) +-MX), s(Y)}
</listItem>
<bodyText confidence="0.868899928571429">
The bodies of definition clauses can be considered as
constraints, that is, bodies can be considered to constrain
the variables in the head. For example, definition clause
(7) means that, for a pair of the variables X and Y,
p( f (X ,Y)) is true if the instances satisfy the constraint
fr(X), s(Y)}. We omit the body when it is empty. The
set of definition clauses registered in the system is called
a database.
Feature structures that do not include any disjunctions
can be represented by first-order terms. For example, (8)
is described by (9).
(8) sign POS v [ NUM sing] { NUM sing ]]
AGR agr PER 3rd PER 3rd
SUBJ sign [AGR agr
</bodyText>
<footnote confidence="0.9991548">
3Since there is no limitation on the number of arguments of a macro,
named disjunctions can be described.
4Hom clauses are described in a different notation from DEC-10
Prolog so as to indicate explicitly that the bodies can be recognized as
constraints.
</footnote>
<page confidence="0.987775">
935
</page>
<listItem confidence="0.679965">
(9) sign(v,agr(sing, 3rd), sign(_, agr(sing,3rd), _))
</listItem>
<bodyText confidence="0.907899923076923">
Feature structure (8) is a typed feature structure used
in typed unification grammars (Emele and Zajac, 1990).
The set of features that a feature structure can have
is specified according to types. In this paper, we do
not consider type hierarchies. Symbol &amp;quot;_&amp;quot; in (9) is an
anonymous variable. The arguments of function symbol
sign correspond to POS feature, AGR feature, and SUBJ
feature values.
Disjunctions are represented by the bodies of definition
clauses. A constraint element in a body whose predicate
has multiple definition clauses represents a disjunction.
For example, in our framework a disjunctive feature
description (10)5 is represented by (11).
</bodyText>
<table confidence="0.9962115">
sign POS agr NUM sing fist
sign AGR *1 agr PER I d 1
— SUBJ sign { NUM plural]
POS n [ AGR *I ]
AGR agr NUM sing
[ PER 3rd 1
</table>
<listItem confidence="0.690516">
(11) p(sign(v, Agr, sign(_, Agr, _)))
4—{not_3s(Agr)}
p(sign(n,agr(sing,3rd), _))
not_3s(agr(sing, Per)) 4—{1st_or_2nd(Per)}
</listItem>
<equation confidence="0.654886333333333">
not_3s(agr(plural, _)) 4—
1st_ o r _2nd(lst)
st _or _2nd(2nd)
</equation>
<bodyText confidence="0.9974012">
Literal p(X) means that variable X is a candidate for the
disjunctive feature structure (DFS) specified by predicate
p. The constraint element lst_or_2nd(Per) in (11)
constrains variable Per to be either 1st or 2nd. In
a similar way, not_3s(Agr) means that Agr is a term
having the form agr (Num, Per), and that either Num is
sing and Per is subject to 1st_or_2nd(Per) or that Num
is plural. As this example shows, constraint elements in
bodies represent disjunctions and each definition clause
of their predicates represents a disjunct.
</bodyText>
<subsectionHeader confidence="0.9773575">
3.2 Unification by Logical Constraint
Transformation
</subsectionHeader>
<bodyText confidence="0.9999501">
Unification of DFSs corresponds to logical constraint
satisfaction. For example, the unification of DFSs p(X)
and q(Y) is equivalent to obtaining all instances of X
that satisfy {p(X),q(X)}.
In order to be able to use the result of one unification
in another unification, it would be useful to output results
in the form of constraints. Such a method of satisfaction
is called constraint transformation (Hasida, 1986). Con-
straint transformation returns a constraint equivalent to
the input when it is satisfiable, but it fails otherwise.
</bodyText>
<sectionHeader confidence="0.65862" genericHeader="method">
5 Braces represent disjunctions.
</sectionHeader>
<bodyText confidence="0.999972888888889">
The efficiency of another unification using the result-
ing constraint depends on which form of constraint the
transformation process has returned. Obtaining compact
constraints corresponds to avoiding unnecessary expan-
sions of disjunctions in graph unification (Kasper, 1987;
Eisele and D6rre, 1988). Some constraint transformation
methods whose resulting constraints are compact have
been proposed (Hasida, 1986; Nakano, 1991). By using
these algorithms, we can efficiently analyze using LCGR.
</bodyText>
<subsectionHeader confidence="0.997283">
3.3 Grammar Representation
</subsectionHeader>
<bodyText confidence="0.999258">
LCGR consists of a set of phrase structure rules, a set of
lexical items, and a database.
Each phrase structure rule is a triplate ( V —&gt; e,
C ), where V is a variable, e is a list of variables,
and C is a constraint on V and variables in e. This
means if instances of the variables satisfy constraint C,
they form the syntactic structure permitted by this rule.
For example, ( X Y Z, {psrl(X,Y, Z)} ) means
if there is a set of instances x, y, and z of X, Y,
and Z that satisfies {psrl(X,Y, Z)}, the sequence of a
phrase having feature structure y and that having feature
structure z can be recognized as a phrase having feature
structure x.
Each lexical item is a pair (w ,p), where w is a word
and p is a predicate. This means an instance of X
that satisfies {p(X)} can be a lexical feature structure
for word w. For example, (walk, lex _walk) means
instances of X that satisfy {lex_walk(X)} are lexical
feature structures for walk.
The database is a set of definite clauses. Predicates
used in the constraints and predicates that appear in the
bodies of the definite clauses in the database should have
their definition clauses in the database.
</bodyText>
<sectionHeader confidence="0.992438" genericHeader="method">
4 Translation Algorithm
</sectionHeader>
<bodyText confidence="0.9934512">
LCGR representation is generated from the grammar
in the FF-DDM formalism as follows. (i) Predicates
that represent feature values are generated from type
definitions. (ii) Phrase structure rules, lexical items, and
macro definitions are translated into LCGR elements.
(iii) Redundancies are removed from definite clauses
by reduction. Below we explain the algorithm through
examples.
Creating predicates that represent feature values
Let us consider the following type definition.
</bodyText>
<listItem confidence="0.8984145">
(12) (def type sign
pos agr subj )
</listItem>
<bodyText confidence="0.9834772">
Then a feature structure of the type sign is represented
by three-argument term sign(_, _), and its arguments
represent POS, AGR, and SUBJ features. By using this, the
following three definite clauses are created and added to
the database.
</bodyText>
<equation confidence="0.9145635">
1
_
936
(13) pos(sign(X, _), X) 4-
agr(sign(_, X, _), X) &lt;-
subj(sign(_, _, X), X) 4--
</equation>
<bodyText confidence="0.9991502">
Translation of phrase structure rules, lexical items,
and macro definitions Each of the phrase structure
rules, lexical items, and macro definitions is translated
into a definite clause and added to the database. This is
done as follows.
</bodyText>
<listItem confidence="0.883683">
(I) Create a literal to be the head. In the case of
a phrase structure rule and a lexical item, let a
newly created symbol be the predicate and all the
variables in the third element be the arguments.
With macro definition, let the macro name be the
predicate and all the variables in the third element
be the arguments.
(II) Compute the body by using path equations and
disjunctively defined macros, and add the created
Horn clause to the database.
(III) By using the predicates created at the step (I),
phrase structure rules and lexical items in LCGR
are created.
</listItem>
<bodyText confidence="0.9577275">
For example, let us consider the following lexical item
for verb walk.
</bodyText>
<equation confidence="0.78331475">
(14) (defword walk (sign)
(&lt;sign pos&gt; = verb
&lt;sign agr&gt; = &lt;sign subj agr&gt;)
(not3s &lt;sign agr&gt;) )
</equation>
<bodyText confidence="0.999823888888889">
First at the step (I), a new predicate c0 and LCGR
variable Sign that corresponds to sign are created,
cO(Sign) being the head. At the step (II), &lt;sign
pos&gt; in the second line is replaced by the variable
X1 and pos(Sign, X1) is added to the body. The
symbol verb is replaced by the LCGR constant verb.
Then eq(Xl, verb) is added to the body, where eq is a
predicate that represents the identity relation and that has
the following definition clause.
</bodyText>
<equation confidence="0.759752">
eq(X, X) 4-
</equation>
<bodyText confidence="0.999956444444444">
As for the third line, the path &lt;sign agr&gt; at
the left-hand side is replaced by X2, &lt;sign subj
agr&gt; at the right-hand side is replaced by X4,
and {agr(Sign, X2), subj(Sign, X3), agr(X3, X4)}
is added to the body. Then eq(X2, X4) is added
to the body. For macro ( not3 s &lt;sign agr&gt; ) ,
&lt;sign agr&gt; is replaced by X5, and agr(Sign, X5)
and not3s(X5) are added to the body. Then (15) is
added to the database.
</bodyText>
<equation confidence="0.533796333333333">
(15) cO(Sign) 4-1 pos(Sign, X1), eq(X 1, verb),
agr(Sign, X2), subj(Sign, X3), agr(X3, X4),
eq(X2, X4), agr(Sign, X5), not3s(X5)}
</equation>
<bodyText confidence="0.87904375">
Finally, (walk, c0) is registered as a lexical item. Phrase
structure rules and macro definitions are translated in the
same way. Horn clause (16) is generated from (2), and (
S NP VP, {cl(S, N P, VP)} ) is registered.
</bodyText>
<listItem confidence="0.3596998">
(16) cl (S, NP, VP) &lt;-1 pos(S , X1), eq(X 1 , sentence),
pos(NP, X2), eq(X2, noun), pos(V P, X3),
eq(X3, verb), subj(V P, X4), eq(X4, NP),
agr(N P, X5), agr(V P, X6), eq(X5, X6),
agr(S, X7), agr(V P, X8), eq(X7 , X8)}
</listItem>
<bodyText confidence="0.98615">
In the same way, Horn clauses (17) are generated from
the macro definitions (4) and (5).
</bodyText>
<equation confidence="0.839679333333333">
(17) not3s(Agr) 4--Inum(Agr, X1), eq(X 1, sing),
per(Agr, X2), lst_or _2nd(X2)}
not3s(Agr) 4--{nurn(Agr, X 1), eq(X1, plural)}
</equation>
<bodyText confidence="0.999962285714286">
In the above translation process, if a macro m has multiple
definitions, predicate m&apos; also has multiple definitions.
This means disjunctions are not expanded during this
process.
Removing Redundancy by Reduction In the defini-
tion clauses created by the above proposed method, many
predicates that have only one definition clause are used,
such as predicate eq, predicates representing feature val-
ues, and predicates representing macro that have only one
definition. We call these predicates definite predicates.
If these definition clauses are used in analysis as they
are, it will be inefficient because the definition clause of
definite predicates must be investigated every time these
clauses are used.
Therefore, by using the procedure reduce (Tsuda,
1994) each literal whose predicate is definite in the body
is replaced by the body of its definition clause.
Let us consider (18) below as an example. If the sole
definition clause of c2 is (19), c2(X ,Y) in (18) is unified
with the head of (19). Then, (18) is transformed into
(20).
</bodyText>
<listItem confidence="0.951479666666667">
(18) cl(f (X), Y) 4-{c2(X, Y)}
(19) c2(g(A, B), Y) i-{c3(A), c4(B)}
(20) cl(f (g(A, B)), Y) 4---{c3(A),c4(B)}
</listItem>
<bodyText confidence="0.941675">
By using this operation, Horn clause (15) above is trans-
formed into the following one.
c0(sign(verb, X6, sign(X7 , X6, X8)))
4- {not3s(X6)}
Since not3s has two definitions, not3s(X6) is not re-
placed. Consequently, the disjunction denoted by not3s
is not expanded in this translation.
</bodyText>
<sectionHeader confidence="0.999512" genericHeader="evaluation">
5 Experiment
</sectionHeader>
<bodyText confidence="0.99995575">
The advantage of this method compared to the previous
methods is that it can translate without expanding dis-
junctions. To show this, we compared the time taken
for two analyses: the first using a grammar translated
</bodyText>
<page confidence="0.991217">
937
</page>
<bodyText confidence="0.99995275">
into terms after expanding disjunctions6 and the second
using a grammar translated without expanding disjunc-
tions through our method. The computation times were
measured using a bottom-up chart parser (Kay, 1980)
in Allegro Common Lisp 4.3 running on Digital Unix
3.2 on DEC Alpha station 500/333MHz. It employs
constraint projection (Nakano, 1991) as an efficient con-
straint transformation method. We measured the time
for computing all parses. We used a Japanese grammar
based on Japanese Phrase Structure Grammar (JPSG)
(Gunji, 1987) that covers fundamental grammatical con-
structions of Japanese sentences. For all of 21 example
sentences (5 to 16 words), the time taken for analysis
using the grammar translated without disjunction expan-
sion was shorter (43% to 72%). This demonstrates the
advantage of our method.
</bodyText>
<sectionHeader confidence="0.999694" genericHeader="conclusions">
6 Conclusion
</sectionHeader>
<bodyText confidence="0.999970857142857">
This paper presented a method for translating a grammar
formalism with disjunctive information that is based on
path equations and lists of pairs of labels and values
into logical-constraint-based grammar representations,
without expanding disjunctions. Although we did not
treat type hierarchies in this paper, we can incorporate
them by using the method proposed by Erbach (1995).
</bodyText>
<sectionHeader confidence="0.991326" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.9998184">
We would like to thank Dr. Ken&apos; ichiro Ishii, Dr. Takeshi
Kawabata, and the members of the Dialogue Understand-
ing Research Group for their comments. Thanks also go
to Ms. Mizuho Inoue and Mr. Yutaka Imai who helped
us to build the experimental system.
</bodyText>
<sectionHeader confidence="0.980433" genericHeader="references">
References
</sectionHeader>
<bodyText confidence="0.98774">
Hassan Aft-Kaci. 1986. LOGIN: A logic programming
language with built-in inheritance. Journal of Logic
Programming, 3:185-215.
Michael Covington. 1989. GULP 2.0: An extension
of Prolog for unification-based grammar. Technical
Report AI-1989-01, The University of Georgia.
Jochen Done and Andreas Eisele. 1990. Feature logic
with disjunctive unification. In COLING-90, vol-
ume 2, pages 100-105.
A. Eisele and J. Diirre. 1988. Unification of disjunctive
feature descriptions. In ACL-88, pages 286-294.
</bodyText>
<reference confidence="0.966118606557377">
Martin C. Emele and Remi Zajac. 1990. Typed unifi-
cation grammars. In COLING-90, volume 3, pages
293-298.
Gregor Erbach. 1995. ProFIT: Prolog with features,
inheritance and templates. In EACL-95, pages 180-
187.
6Note that disjunctions whose elements are all atomic values are
not expanded.
Gerald Gazdar and Chris Mellish. 1989. Natural Lan-
guage Processing in Lisp: An Introduction to Compu-
tational Linguistics. Addison-Wesley.
Takao Gunji. 1987. Japanese Phrase Structure Gram-
mar. Reidel, Dordrecht.
Koiti Hasida. 1986. Conditioned unification for natural
language processing. In COLING-86, pages 85-87.
Susan Hirsh. 1988. P-PATR: A compiler for unification-
based grammars. In V. Dahl and P. Saint-Dizier, ed-
itors, Natural Language and Logic Programming, II,
pages 63-78. Elsevier Science Publishers.
Robert T. Kasper. 1987. A unification method for dis-
junctive feature descriptions. In ACL-87, pages 235-
242.
Martin Kay. 1980. Algorithm schemata and data struc-
tures in syntactic processing. Technical Report CSL-
80-12, Xerox PARC.
Yuji Matsumoto, Hozumi Tanaka, Hideki Hirakawa,
Hideo Miyoshi, and Hideki Yasukawa. 1983. BUP: A
bottom-up parser embedded in Prolog. New Genera-
tion Computing, 1:145-158.
John T. Maxwell and Ronald M. Kaplan. 1991. A method
for disjunctive constraint satisfaction. In Masaru
Tomita, editor, Current Issues in Parsing technology,
pages 173-190. Kluwer.
Kuniaki Mukai and Hideki Yasukawa. 1985. Com-
plex indeterminates in Prolog and its application
to discourse models. New Generation Computing,
3(4):145-158.
Mikio Nakano. 1991. Constraint projection: An efficient
treatment of disjunctive feature descriptions. In A CL-
91, pages 307-314.
Fernando C. N. Pereira and David H. D. Warren. 1980.
Definite clause grammars for language analysis-a
survey of the formalism and a comparison with aug-
mented transition networks. Artificial Intelligence,
13:231-278.
Carl J. Pollard and Ivan A. Sag. 1994. Head-Driven
Phrase Structure Grammar. CSLI, Stanford.
Andreas Schoter. 1993. Compiling feature structures
into terms: an empirical study in Prolog. Technical
Report EUCCS/RP-55, Centre for Cognitive Science,
University of Edinburgh.
Stuart M. Shieber. 1984. The design of a computer
language for linguistic information. In COLING-84,
pages 362-366.
Takenobu Tokunaga, Makoto Iwayama, and Hozumi
Tanaka. 1991. Handling gaps in logic grammars.
Trans. of Information Processing Society of Japan,
32(11):1355-1365. (in Japanese).
Hiroshi Tsuda. 1994. cu-Prolog for constraint-based
natural language processing. lEICE Transactions on
Information and Systems, E77-D(2):171-180.
</reference>
<page confidence="0.997421">
938
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.871149">
<title confidence="0.999829">Translating a Unification Grammar with Disjunctions into Logical Constraints</title>
<author confidence="0.991471">Nakano Shimazu</author>
<affiliation confidence="0.999224">NTT Basic Research Laboratories</affiliation>
<address confidence="0.993135">3-1 Morinosato-Wakamiya, Atsugi 243-0198 Japan</address>
<email confidence="0.997901">E-mail:nakano@atom.brl.ntt.cojp,shimazu@jaistac.jp</email>
<abstract confidence="0.993981263157895">This paper proposes a method for generating a logicalconstraint-based internal representation from a unification grammar formalism with disjunctive information. Unification grammar formalisms based on path equations and lists of pairs of labels and values are better than those based on first-order terms in that the former is easier to describe and to understand. Parsing with term-based internal representations is more efficient than parsing with graph-based representations. Therefore, it is effective to translate unification grammar formalism based on path equations and lists of pairs of labels and values into a term-based internal representation. Previous translation methods cannot deal with disjunctive feature descriptions, which reduce redundancies in the grammar and make parsing efficient. Since the proposed method translates a formalism without expanding disjunctions, parsing with the resulting representation is efficient.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Martin C Emele</author>
<author>Remi Zajac</author>
</authors>
<title>Typed unification grammars.</title>
<date>1990</date>
<booktitle>In COLING-90,</booktitle>
<volume>3</volume>
<pages>293--298</pages>
<contexts>
<context position="9084" citStr="Emele and Zajac, 1990" startWordPosition="1426" endWordPosition="1429">that do not include any disjunctions can be represented by first-order terms. For example, (8) is described by (9). (8) sign POS v [ NUM sing] { NUM sing ]] AGR agr PER 3rd PER 3rd SUBJ sign [AGR agr 3Since there is no limitation on the number of arguments of a macro, named disjunctions can be described. 4Hom clauses are described in a different notation from DEC-10 Prolog so as to indicate explicitly that the bodies can be recognized as constraints. 935 (9) sign(v,agr(sing, 3rd), sign(_, agr(sing,3rd), _)) Feature structure (8) is a typed feature structure used in typed unification grammars (Emele and Zajac, 1990). The set of features that a feature structure can have is specified according to types. In this paper, we do not consider type hierarchies. Symbol &amp;quot;_&amp;quot; in (9) is an anonymous variable. The arguments of function symbol sign correspond to POS feature, AGR feature, and SUBJ feature values. Disjunctions are represented by the bodies of definition clauses. A constraint element in a body whose predicate has multiple definition clauses represents a disjunction. For example, in our framework a disjunctive feature description (10)5 is represented by (11). sign POS agr NUM sing fist sign AGR *1 agr PER </context>
</contexts>
<marker>Emele, Zajac, 1990</marker>
<rawString>Martin C. Emele and Remi Zajac. 1990. Typed unification grammars. In COLING-90, volume 3, pages 293-298.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gregor Erbach</author>
</authors>
<title>ProFIT: Prolog with features, inheritance and templates.</title>
<date>1995</date>
<booktitle>In EACL-95,</booktitle>
<pages>180--187</pages>
<contexts>
<context position="3626" citStr="Erbach, 1995" startWordPosition="524" endWordPosition="525"> more disjunctive feature values depend on each other. The treatment of named disjunctions in graph unification requires a complex process, while it is simple in our logical-constraint-based representations. Formalism (i) is better because term-based formalism is problematic in that readers need to memorize the correspondence between arguments and features and it is not easy to add new features or delete features (Gazdar and Mellish, 1989). Therefore, it is effective to translate formalism (i) into representation (b). Previous translation methods2 (Covington, 1989; Hirsh, 1988; Schoter, 1993; Erbach, 1995) are problematic in that they cannot deal with disjunctive feature descriptions, which reduce redundancies in grammar. Moreover, incorporating disjunctive information into internal representation makes parsing more efficient (Kasper, 1987; Eisele and Done, 1988; Maxwell and Kaplan, 1991; Hasida, 1986). This paper presents a method for translating grammar formalism with disjunctive information based on path equations and lists of pairs of labels and values into term&apos;Since unspecified features are represented by variables in term unification, when most of the features are unspecified, it is inef</context>
<context position="19150" citStr="Erbach (1995)" startWordPosition="3092" endWordPosition="3093">entences. For all of 21 example sentences (5 to 16 words), the time taken for analysis using the grammar translated without disjunction expansion was shorter (43% to 72%). This demonstrates the advantage of our method. 6 Conclusion This paper presented a method for translating a grammar formalism with disjunctive information that is based on path equations and lists of pairs of labels and values into logical-constraint-based grammar representations, without expanding disjunctions. Although we did not treat type hierarchies in this paper, we can incorporate them by using the method proposed by Erbach (1995). Acknowledgments We would like to thank Dr. Ken&apos; ichiro Ishii, Dr. Takeshi Kawabata, and the members of the Dialogue Understanding Research Group for their comments. Thanks also go to Ms. Mizuho Inoue and Mr. Yutaka Imai who helped us to build the experimental system. References Hassan Aft-Kaci. 1986. LOGIN: A logic programming language with built-in inheritance. Journal of Logic Programming, 3:185-215. Michael Covington. 1989. GULP 2.0: An extension of Prolog for unification-based grammar. Technical Report AI-1989-01, The University of Georgia. Jochen Done and Andreas Eisele. 1990. Feature l</context>
</contexts>
<marker>Erbach, 1995</marker>
<rawString>Gregor Erbach. 1995. ProFIT: Prolog with features, inheritance and templates. In EACL-95, pages 180-187.</rawString>
</citation>
<citation valid="false">
<title>6Note that disjunctions whose elements are all atomic values are not expanded.</title>
<marker></marker>
<rawString>6Note that disjunctions whose elements are all atomic values are not expanded.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gerald Gazdar</author>
<author>Chris Mellish</author>
</authors>
<title>Natural Language Processing in Lisp: An Introduction to Computational Linguistics.</title>
<date>1989</date>
<publisher>Addison-Wesley.</publisher>
<contexts>
<context position="3456" citStr="Gazdar and Mellish, 1989" startWordPosition="500" endWordPosition="503">Schoter, 1993).1 Second, it is easy to represent and process named disjunctions (Done and Eisele, 1990) in the term-based representation. Named disjunctions are effective when two or more disjunctive feature values depend on each other. The treatment of named disjunctions in graph unification requires a complex process, while it is simple in our logical-constraint-based representations. Formalism (i) is better because term-based formalism is problematic in that readers need to memorize the correspondence between arguments and features and it is not easy to add new features or delete features (Gazdar and Mellish, 1989). Therefore, it is effective to translate formalism (i) into representation (b). Previous translation methods2 (Covington, 1989; Hirsh, 1988; Schoter, 1993; Erbach, 1995) are problematic in that they cannot deal with disjunctive feature descriptions, which reduce redundancies in grammar. Moreover, incorporating disjunctive information into internal representation makes parsing more efficient (Kasper, 1987; Eisele and Done, 1988; Maxwell and Kaplan, 1991; Hasida, 1986). This paper presents a method for translating grammar formalism with disjunctive information based on path equations and lists </context>
</contexts>
<marker>Gazdar, Mellish, 1989</marker>
<rawString>Gerald Gazdar and Chris Mellish. 1989. Natural Language Processing in Lisp: An Introduction to Computational Linguistics. Addison-Wesley.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Takao Gunji</author>
</authors>
<date>1987</date>
<booktitle>Japanese Phrase Structure Grammar.</booktitle>
<location>Reidel, Dordrecht.</location>
<contexts>
<context position="18473" citStr="Gunji, 1987" startWordPosition="2990" endWordPosition="2991">d the time taken for two analyses: the first using a grammar translated 937 into terms after expanding disjunctions6 and the second using a grammar translated without expanding disjunctions through our method. The computation times were measured using a bottom-up chart parser (Kay, 1980) in Allegro Common Lisp 4.3 running on Digital Unix 3.2 on DEC Alpha station 500/333MHz. It employs constraint projection (Nakano, 1991) as an efficient constraint transformation method. We measured the time for computing all parses. We used a Japanese grammar based on Japanese Phrase Structure Grammar (JPSG) (Gunji, 1987) that covers fundamental grammatical constructions of Japanese sentences. For all of 21 example sentences (5 to 16 words), the time taken for analysis using the grammar translated without disjunction expansion was shorter (43% to 72%). This demonstrates the advantage of our method. 6 Conclusion This paper presented a method for translating a grammar formalism with disjunctive information that is based on path equations and lists of pairs of labels and values into logical-constraint-based grammar representations, without expanding disjunctions. Although we did not treat type hierarchies in this</context>
</contexts>
<marker>Gunji, 1987</marker>
<rawString>Takao Gunji. 1987. Japanese Phrase Structure Grammar. Reidel, Dordrecht.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Koiti Hasida</author>
</authors>
<title>Conditioned unification for natural language processing.</title>
<date>1986</date>
<booktitle>In COLING-86,</booktitle>
<pages>85--87</pages>
<contexts>
<context position="3928" citStr="Hasida, 1986" startWordPosition="565" endWordPosition="566">morize the correspondence between arguments and features and it is not easy to add new features or delete features (Gazdar and Mellish, 1989). Therefore, it is effective to translate formalism (i) into representation (b). Previous translation methods2 (Covington, 1989; Hirsh, 1988; Schoter, 1993; Erbach, 1995) are problematic in that they cannot deal with disjunctive feature descriptions, which reduce redundancies in grammar. Moreover, incorporating disjunctive information into internal representation makes parsing more efficient (Kasper, 1987; Eisele and Done, 1988; Maxwell and Kaplan, 1991; Hasida, 1986). This paper presents a method for translating grammar formalism with disjunctive information based on path equations and lists of pairs of labels and values into term&apos;Since unspecified features are represented by variables in term unification, when most of the features are unspecified, it is inefficient to represent feature structures by terms. In current linguistic theories such as HPSG (Pollard and Sag, 1994), however, thanks to the type specifications, the number of features that a feature structure can have is reduced, so it does not cause as much trouble. 2Methods that generate represent</context>
<context position="10957" citStr="Hasida, 1986" startWordPosition="1730" endWordPosition="1731">this example shows, constraint elements in bodies represent disjunctions and each definition clause of their predicates represents a disjunct. 3.2 Unification by Logical Constraint Transformation Unification of DFSs corresponds to logical constraint satisfaction. For example, the unification of DFSs p(X) and q(Y) is equivalent to obtaining all instances of X that satisfy {p(X),q(X)}. In order to be able to use the result of one unification in another unification, it would be useful to output results in the form of constraints. Such a method of satisfaction is called constraint transformation (Hasida, 1986). Constraint transformation returns a constraint equivalent to the input when it is satisfiable, but it fails otherwise. 5 Braces represent disjunctions. The efficiency of another unification using the resulting constraint depends on which form of constraint the transformation process has returned. Obtaining compact constraints corresponds to avoiding unnecessary expansions of disjunctions in graph unification (Kasper, 1987; Eisele and D6rre, 1988). Some constraint transformation methods whose resulting constraints are compact have been proposed (Hasida, 1986; Nakano, 1991). By using these alg</context>
</contexts>
<marker>Hasida, 1986</marker>
<rawString>Koiti Hasida. 1986. Conditioned unification for natural language processing. In COLING-86, pages 85-87.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Susan Hirsh</author>
</authors>
<title>P-PATR: A compiler for unificationbased grammars.</title>
<date>1988</date>
<booktitle>Natural Language and Logic Programming, II,</booktitle>
<pages>63--78</pages>
<editor>In V. Dahl and P. Saint-Dizier, editors,</editor>
<publisher>Elsevier Science Publishers.</publisher>
<contexts>
<context position="3596" citStr="Hirsh, 1988" startWordPosition="520" endWordPosition="521">ns are effective when two or more disjunctive feature values depend on each other. The treatment of named disjunctions in graph unification requires a complex process, while it is simple in our logical-constraint-based representations. Formalism (i) is better because term-based formalism is problematic in that readers need to memorize the correspondence between arguments and features and it is not easy to add new features or delete features (Gazdar and Mellish, 1989). Therefore, it is effective to translate formalism (i) into representation (b). Previous translation methods2 (Covington, 1989; Hirsh, 1988; Schoter, 1993; Erbach, 1995) are problematic in that they cannot deal with disjunctive feature descriptions, which reduce redundancies in grammar. Moreover, incorporating disjunctive information into internal representation makes parsing more efficient (Kasper, 1987; Eisele and Done, 1988; Maxwell and Kaplan, 1991; Hasida, 1986). This paper presents a method for translating grammar formalism with disjunctive information based on path equations and lists of pairs of labels and values into term&apos;Since unspecified features are represented by variables in term unification, when most of the featur</context>
</contexts>
<marker>Hirsh, 1988</marker>
<rawString>Susan Hirsh. 1988. P-PATR: A compiler for unificationbased grammars. In V. Dahl and P. Saint-Dizier, editors, Natural Language and Logic Programming, II, pages 63-78. Elsevier Science Publishers.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert T Kasper</author>
</authors>
<title>A unification method for disjunctive feature descriptions.</title>
<date>1987</date>
<booktitle>In ACL-87,</booktitle>
<pages>235--242</pages>
<contexts>
<context position="3864" citStr="Kasper, 1987" startWordPosition="555" endWordPosition="556"> term-based formalism is problematic in that readers need to memorize the correspondence between arguments and features and it is not easy to add new features or delete features (Gazdar and Mellish, 1989). Therefore, it is effective to translate formalism (i) into representation (b). Previous translation methods2 (Covington, 1989; Hirsh, 1988; Schoter, 1993; Erbach, 1995) are problematic in that they cannot deal with disjunctive feature descriptions, which reduce redundancies in grammar. Moreover, incorporating disjunctive information into internal representation makes parsing more efficient (Kasper, 1987; Eisele and Done, 1988; Maxwell and Kaplan, 1991; Hasida, 1986). This paper presents a method for translating grammar formalism with disjunctive information based on path equations and lists of pairs of labels and values into term&apos;Since unspecified features are represented by variables in term unification, when most of the features are unspecified, it is inefficient to represent feature structures by terms. In current linguistic theories such as HPSG (Pollard and Sag, 1994), however, thanks to the type specifications, the number of features that a feature structure can have is reduced, so it </context>
<context position="11384" citStr="Kasper, 1987" startWordPosition="1789" endWordPosition="1790">one unification in another unification, it would be useful to output results in the form of constraints. Such a method of satisfaction is called constraint transformation (Hasida, 1986). Constraint transformation returns a constraint equivalent to the input when it is satisfiable, but it fails otherwise. 5 Braces represent disjunctions. The efficiency of another unification using the resulting constraint depends on which form of constraint the transformation process has returned. Obtaining compact constraints corresponds to avoiding unnecessary expansions of disjunctions in graph unification (Kasper, 1987; Eisele and D6rre, 1988). Some constraint transformation methods whose resulting constraints are compact have been proposed (Hasida, 1986; Nakano, 1991). By using these algorithms, we can efficiently analyze using LCGR. 3.3 Grammar Representation LCGR consists of a set of phrase structure rules, a set of lexical items, and a database. Each phrase structure rule is a triplate ( V —&gt; e, C ), where V is a variable, e is a list of variables, and C is a constraint on V and variables in e. This means if instances of the variables satisfy constraint C, they form the syntactic structure permitted by </context>
</contexts>
<marker>Kasper, 1987</marker>
<rawString>Robert T. Kasper. 1987. A unification method for disjunctive feature descriptions. In ACL-87, pages 235-242.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Martin Kay</author>
</authors>
<title>Algorithm schemata and data structures in syntactic processing.</title>
<date>1980</date>
<tech>Technical Report CSL80-12, Xerox PARC.</tech>
<contexts>
<context position="18149" citStr="Kay, 1980" startWordPosition="2940" endWordPosition="2941"> X8))) 4- {not3s(X6)} Since not3s has two definitions, not3s(X6) is not replaced. Consequently, the disjunction denoted by not3s is not expanded in this translation. 5 Experiment The advantage of this method compared to the previous methods is that it can translate without expanding disjunctions. To show this, we compared the time taken for two analyses: the first using a grammar translated 937 into terms after expanding disjunctions6 and the second using a grammar translated without expanding disjunctions through our method. The computation times were measured using a bottom-up chart parser (Kay, 1980) in Allegro Common Lisp 4.3 running on Digital Unix 3.2 on DEC Alpha station 500/333MHz. It employs constraint projection (Nakano, 1991) as an efficient constraint transformation method. We measured the time for computing all parses. We used a Japanese grammar based on Japanese Phrase Structure Grammar (JPSG) (Gunji, 1987) that covers fundamental grammatical constructions of Japanese sentences. For all of 21 example sentences (5 to 16 words), the time taken for analysis using the grammar translated without disjunction expansion was shorter (43% to 72%). This demonstrates the advantage of our m</context>
</contexts>
<marker>Kay, 1980</marker>
<rawString>Martin Kay. 1980. Algorithm schemata and data structures in syntactic processing. Technical Report CSL80-12, Xerox PARC.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yuji Matsumoto</author>
<author>Hozumi Tanaka</author>
<author>Hideki Hirakawa</author>
<author>Hideo Miyoshi</author>
<author>Hideki Yasukawa</author>
</authors>
<title>BUP: A bottom-up parser embedded in Prolog.</title>
<date>1983</date>
<journal>New Generation Computing,</journal>
<pages>1--145</pages>
<contexts>
<context position="1786" citStr="Matsumoto et al., 1983" startWordPosition="248" endWordPosition="251">epresentation is efficient. 1 Introduction The objective of our research is to build a natural language understanding system that is based on unification. The reason we have chosen a unification-based approach is that it enables us to describe grammar declaratively, making the development and amendment of grammar easy. Analysis systems that are based on unification grammars can be classified into two groups from the viewpoint of the ways feature structures are represented: (a) those using labeled, directed graphs (Shieber, 1984) and (b) those using first-order terms (Pereira and Warren, 1980; Matsumoto et al., 1983; Tokunaga et al., 1991). In addition to internal representation, grammar formalisms can be classified into two groups, (i) those that describe feature structures with path equations and lists of pairs of labels and values (Mukai and Yasukawa, 1985; Alt-Kaci, 1986; Tsuda, 1994), and (ii) those that describe feature structures with first-order terms (Pereira and Warren, 1980; Matsumoto et al., 1983; Tokunaga et • Presently with Japan Advanced Institute of Science and Technology. al., 1991). Since formalisms (i) are used in the family of the PATR parsing systems (Shieber, 1984), hereafter they w</context>
</contexts>
<marker>Matsumoto, Tanaka, Hirakawa, Miyoshi, Yasukawa, 1983</marker>
<rawString>Yuji Matsumoto, Hozumi Tanaka, Hideki Hirakawa, Hideo Miyoshi, and Hideki Yasukawa. 1983. BUP: A bottom-up parser embedded in Prolog. New Generation Computing, 1:145-158.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John T Maxwell</author>
<author>Ronald M Kaplan</author>
</authors>
<title>A method for disjunctive constraint satisfaction.</title>
<date>1991</date>
<booktitle>Current Issues in Parsing technology,</booktitle>
<pages>173--190</pages>
<editor>In Masaru Tomita, editor,</editor>
<publisher>Kluwer.</publisher>
<contexts>
<context position="3913" citStr="Maxwell and Kaplan, 1991" startWordPosition="561" endWordPosition="564">in that readers need to memorize the correspondence between arguments and features and it is not easy to add new features or delete features (Gazdar and Mellish, 1989). Therefore, it is effective to translate formalism (i) into representation (b). Previous translation methods2 (Covington, 1989; Hirsh, 1988; Schoter, 1993; Erbach, 1995) are problematic in that they cannot deal with disjunctive feature descriptions, which reduce redundancies in grammar. Moreover, incorporating disjunctive information into internal representation makes parsing more efficient (Kasper, 1987; Eisele and Done, 1988; Maxwell and Kaplan, 1991; Hasida, 1986). This paper presents a method for translating grammar formalism with disjunctive information based on path equations and lists of pairs of labels and values into term&apos;Since unspecified features are represented by variables in term unification, when most of the features are unspecified, it is inefficient to represent feature structures by terms. In current linguistic theories such as HPSG (Pollard and Sag, 1994), however, thanks to the type specifications, the number of features that a feature structure can have is reduced, so it does not cause as much trouble. 2Methods that gen</context>
</contexts>
<marker>Maxwell, Kaplan, 1991</marker>
<rawString>John T. Maxwell and Ronald M. Kaplan. 1991. A method for disjunctive constraint satisfaction. In Masaru Tomita, editor, Current Issues in Parsing technology, pages 173-190. Kluwer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kuniaki Mukai</author>
<author>Hideki Yasukawa</author>
</authors>
<title>Complex indeterminates in Prolog and its application to discourse models.</title>
<date>1985</date>
<journal>New Generation Computing,</journal>
<pages>3--4</pages>
<contexts>
<context position="2034" citStr="Mukai and Yasukawa, 1985" startWordPosition="287" endWordPosition="290">ammar declaratively, making the development and amendment of grammar easy. Analysis systems that are based on unification grammars can be classified into two groups from the viewpoint of the ways feature structures are represented: (a) those using labeled, directed graphs (Shieber, 1984) and (b) those using first-order terms (Pereira and Warren, 1980; Matsumoto et al., 1983; Tokunaga et al., 1991). In addition to internal representation, grammar formalisms can be classified into two groups, (i) those that describe feature structures with path equations and lists of pairs of labels and values (Mukai and Yasukawa, 1985; Alt-Kaci, 1986; Tsuda, 1994), and (ii) those that describe feature structures with first-order terms (Pereira and Warren, 1980; Matsumoto et al., 1983; Tokunaga et • Presently with Japan Advanced Institute of Science and Technology. al., 1991). Since formalisms (i) are used in the family of the PATR parsing systems (Shieber, 1984), hereafter they will be called PATR-like formalisms. Most of the previous systems are either ones that generate representation (a) from formalisms (i) or ones that generate representation (b) from formalisms (ii). However, representation (b) is superior, and formal</context>
</contexts>
<marker>Mukai, Yasukawa, 1985</marker>
<rawString>Kuniaki Mukai and Hideki Yasukawa. 1985. Complex indeterminates in Prolog and its application to discourse models. New Generation Computing, 3(4):145-158.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mikio Nakano</author>
</authors>
<title>Constraint projection: An efficient treatment of disjunctive feature descriptions.</title>
<date>1991</date>
<booktitle>In A CL91,</booktitle>
<pages>307--314</pages>
<contexts>
<context position="11537" citStr="Nakano, 1991" startWordPosition="1809" endWordPosition="1810">int transformation (Hasida, 1986). Constraint transformation returns a constraint equivalent to the input when it is satisfiable, but it fails otherwise. 5 Braces represent disjunctions. The efficiency of another unification using the resulting constraint depends on which form of constraint the transformation process has returned. Obtaining compact constraints corresponds to avoiding unnecessary expansions of disjunctions in graph unification (Kasper, 1987; Eisele and D6rre, 1988). Some constraint transformation methods whose resulting constraints are compact have been proposed (Hasida, 1986; Nakano, 1991). By using these algorithms, we can efficiently analyze using LCGR. 3.3 Grammar Representation LCGR consists of a set of phrase structure rules, a set of lexical items, and a database. Each phrase structure rule is a triplate ( V —&gt; e, C ), where V is a variable, e is a list of variables, and C is a constraint on V and variables in e. This means if instances of the variables satisfy constraint C, they form the syntactic structure permitted by this rule. For example, ( X Y Z, {psrl(X,Y, Z)} ) means if there is a set of instances x, y, and z of X, Y, and Z that satisfies {psrl(X,Y, Z)}, the sequ</context>
<context position="18285" citStr="Nakano, 1991" startWordPosition="2961" endWordPosition="2962">ot expanded in this translation. 5 Experiment The advantage of this method compared to the previous methods is that it can translate without expanding disjunctions. To show this, we compared the time taken for two analyses: the first using a grammar translated 937 into terms after expanding disjunctions6 and the second using a grammar translated without expanding disjunctions through our method. The computation times were measured using a bottom-up chart parser (Kay, 1980) in Allegro Common Lisp 4.3 running on Digital Unix 3.2 on DEC Alpha station 500/333MHz. It employs constraint projection (Nakano, 1991) as an efficient constraint transformation method. We measured the time for computing all parses. We used a Japanese grammar based on Japanese Phrase Structure Grammar (JPSG) (Gunji, 1987) that covers fundamental grammatical constructions of Japanese sentences. For all of 21 example sentences (5 to 16 words), the time taken for analysis using the grammar translated without disjunction expansion was shorter (43% to 72%). This demonstrates the advantage of our method. 6 Conclusion This paper presented a method for translating a grammar formalism with disjunctive information that is based on path</context>
</contexts>
<marker>Nakano, 1991</marker>
<rawString>Mikio Nakano. 1991. Constraint projection: An efficient treatment of disjunctive feature descriptions. In A CL91, pages 307-314.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fernando C N Pereira</author>
<author>David H D Warren</author>
</authors>
<title>Definite clause grammars for language analysis-a survey of the formalism and a comparison with augmented transition networks.</title>
<date>1980</date>
<journal>Artificial Intelligence,</journal>
<pages>13--231</pages>
<contexts>
<context position="1762" citStr="Pereira and Warren, 1980" startWordPosition="244" endWordPosition="247">rsing with the resulting representation is efficient. 1 Introduction The objective of our research is to build a natural language understanding system that is based on unification. The reason we have chosen a unification-based approach is that it enables us to describe grammar declaratively, making the development and amendment of grammar easy. Analysis systems that are based on unification grammars can be classified into two groups from the viewpoint of the ways feature structures are represented: (a) those using labeled, directed graphs (Shieber, 1984) and (b) those using first-order terms (Pereira and Warren, 1980; Matsumoto et al., 1983; Tokunaga et al., 1991). In addition to internal representation, grammar formalisms can be classified into two groups, (i) those that describe feature structures with path equations and lists of pairs of labels and values (Mukai and Yasukawa, 1985; Alt-Kaci, 1986; Tsuda, 1994), and (ii) those that describe feature structures with first-order terms (Pereira and Warren, 1980; Matsumoto et al., 1983; Tokunaga et • Presently with Japan Advanced Institute of Science and Technology. al., 1991). Since formalisms (i) are used in the family of the PATR parsing systems (Shieber,</context>
</contexts>
<marker>Pereira, Warren, 1980</marker>
<rawString>Fernando C. N. Pereira and David H. D. Warren. 1980. Definite clause grammars for language analysis-a survey of the formalism and a comparison with augmented transition networks. Artificial Intelligence, 13:231-278.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Carl J Pollard</author>
<author>Ivan A Sag</author>
</authors>
<date>1994</date>
<booktitle>Head-Driven Phrase Structure Grammar. CSLI,</booktitle>
<location>Stanford.</location>
<contexts>
<context position="4343" citStr="Pollard and Sag, 1994" startWordPosition="626" endWordPosition="629">edundancies in grammar. Moreover, incorporating disjunctive information into internal representation makes parsing more efficient (Kasper, 1987; Eisele and Done, 1988; Maxwell and Kaplan, 1991; Hasida, 1986). This paper presents a method for translating grammar formalism with disjunctive information based on path equations and lists of pairs of labels and values into term&apos;Since unspecified features are represented by variables in term unification, when most of the features are unspecified, it is inefficient to represent feature structures by terms. In current linguistic theories such as HPSG (Pollard and Sag, 1994), however, thanks to the type specifications, the number of features that a feature structure can have is reduced, so it does not cause as much trouble. 2Methods that generate representation (b) after generating representation (a) are included. 934 based representations, without expanding disjunctions. The formalism used here is feature-based formalism with disjunctively defined macros (FF-DDM), an extension of the PATR-like formalisms that incorporates a description of disjunctive information. The representation used here is logical-constraint-based grammar representation (LCGR), in which dis</context>
</contexts>
<marker>Pollard, Sag, 1994</marker>
<rawString>Carl J. Pollard and Ivan A. Sag. 1994. Head-Driven Phrase Structure Grammar. CSLI, Stanford.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andreas Schoter</author>
</authors>
<title>Compiling feature structures into terms: an empirical study in Prolog.</title>
<date>1993</date>
<tech>Technical Report EUCCS/RP-55,</tech>
<institution>Centre for Cognitive Science, University of Edinburgh.</institution>
<contexts>
<context position="2845" citStr="Schoter, 1993" startWordPosition="412" endWordPosition="413"> Institute of Science and Technology. al., 1991). Since formalisms (i) are used in the family of the PATR parsing systems (Shieber, 1984), hereafter they will be called PATR-like formalisms. Most of the previous systems are either ones that generate representation (a) from formalisms (i) or ones that generate representation (b) from formalisms (ii). However, representation (b) is superior, and formalism (i) is far better. Representation (b) is superior for the following two reasons. First, unification of terms is more efficient of that of graphs because the data structure of terms is simpler (Schoter, 1993).1 Second, it is easy to represent and process named disjunctions (Done and Eisele, 1990) in the term-based representation. Named disjunctions are effective when two or more disjunctive feature values depend on each other. The treatment of named disjunctions in graph unification requires a complex process, while it is simple in our logical-constraint-based representations. Formalism (i) is better because term-based formalism is problematic in that readers need to memorize the correspondence between arguments and features and it is not easy to add new features or delete features (Gazdar and Mel</context>
</contexts>
<marker>Schoter, 1993</marker>
<rawString>Andreas Schoter. 1993. Compiling feature structures into terms: an empirical study in Prolog. Technical Report EUCCS/RP-55, Centre for Cognitive Science, University of Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
</authors>
<title>The design of a computer language for linguistic information.</title>
<date>1984</date>
<booktitle>In COLING-84,</booktitle>
<pages>362--366</pages>
<contexts>
<context position="1698" citStr="Shieber, 1984" startWordPosition="236" endWordPosition="237">nslates a formalism without expanding disjunctions, parsing with the resulting representation is efficient. 1 Introduction The objective of our research is to build a natural language understanding system that is based on unification. The reason we have chosen a unification-based approach is that it enables us to describe grammar declaratively, making the development and amendment of grammar easy. Analysis systems that are based on unification grammars can be classified into two groups from the viewpoint of the ways feature structures are represented: (a) those using labeled, directed graphs (Shieber, 1984) and (b) those using first-order terms (Pereira and Warren, 1980; Matsumoto et al., 1983; Tokunaga et al., 1991). In addition to internal representation, grammar formalisms can be classified into two groups, (i) those that describe feature structures with path equations and lists of pairs of labels and values (Mukai and Yasukawa, 1985; Alt-Kaci, 1986; Tsuda, 1994), and (ii) those that describe feature structures with first-order terms (Pereira and Warren, 1980; Matsumoto et al., 1983; Tokunaga et • Presently with Japan Advanced Institute of Science and Technology. al., 1991). Since formalisms </context>
</contexts>
<marker>Shieber, 1984</marker>
<rawString>Stuart M. Shieber. 1984. The design of a computer language for linguistic information. In COLING-84, pages 362-366.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Takenobu Tokunaga</author>
<author>Makoto Iwayama</author>
<author>Hozumi Tanaka</author>
</authors>
<title>Handling gaps in logic grammars.</title>
<date>1991</date>
<journal>Trans. of Information Processing Society of Japan,</journal>
<pages>32--11</pages>
<note>(in Japanese).</note>
<contexts>
<context position="1810" citStr="Tokunaga et al., 1991" startWordPosition="252" endWordPosition="255">nt. 1 Introduction The objective of our research is to build a natural language understanding system that is based on unification. The reason we have chosen a unification-based approach is that it enables us to describe grammar declaratively, making the development and amendment of grammar easy. Analysis systems that are based on unification grammars can be classified into two groups from the viewpoint of the ways feature structures are represented: (a) those using labeled, directed graphs (Shieber, 1984) and (b) those using first-order terms (Pereira and Warren, 1980; Matsumoto et al., 1983; Tokunaga et al., 1991). In addition to internal representation, grammar formalisms can be classified into two groups, (i) those that describe feature structures with path equations and lists of pairs of labels and values (Mukai and Yasukawa, 1985; Alt-Kaci, 1986; Tsuda, 1994), and (ii) those that describe feature structures with first-order terms (Pereira and Warren, 1980; Matsumoto et al., 1983; Tokunaga et • Presently with Japan Advanced Institute of Science and Technology. al., 1991). Since formalisms (i) are used in the family of the PATR parsing systems (Shieber, 1984), hereafter they will be called PATR-like </context>
</contexts>
<marker>Tokunaga, Iwayama, Tanaka, 1991</marker>
<rawString>Takenobu Tokunaga, Makoto Iwayama, and Hozumi Tanaka. 1991. Handling gaps in logic grammars. Trans. of Information Processing Society of Japan, 32(11):1355-1365. (in Japanese).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hiroshi Tsuda</author>
</authors>
<title>cu-Prolog for constraint-based natural language processing.</title>
<date>1994</date>
<journal>lEICE Transactions on Information and Systems,</journal>
<pages>77--2</pages>
<contexts>
<context position="2064" citStr="Tsuda, 1994" startWordPosition="293" endWordPosition="294">t and amendment of grammar easy. Analysis systems that are based on unification grammars can be classified into two groups from the viewpoint of the ways feature structures are represented: (a) those using labeled, directed graphs (Shieber, 1984) and (b) those using first-order terms (Pereira and Warren, 1980; Matsumoto et al., 1983; Tokunaga et al., 1991). In addition to internal representation, grammar formalisms can be classified into two groups, (i) those that describe feature structures with path equations and lists of pairs of labels and values (Mukai and Yasukawa, 1985; Alt-Kaci, 1986; Tsuda, 1994), and (ii) those that describe feature structures with first-order terms (Pereira and Warren, 1980; Matsumoto et al., 1983; Tokunaga et • Presently with Japan Advanced Institute of Science and Technology. al., 1991). Since formalisms (i) are used in the family of the PATR parsing systems (Shieber, 1984), hereafter they will be called PATR-like formalisms. Most of the previous systems are either ones that generate representation (a) from formalisms (i) or ones that generate representation (b) from formalisms (ii). However, representation (b) is superior, and formalism (i) is far better. Represe</context>
<context position="17032" citStr="Tsuda, 1994" startWordPosition="2755" endWordPosition="2756"> expanded during this process. Removing Redundancy by Reduction In the definition clauses created by the above proposed method, many predicates that have only one definition clause are used, such as predicate eq, predicates representing feature values, and predicates representing macro that have only one definition. We call these predicates definite predicates. If these definition clauses are used in analysis as they are, it will be inefficient because the definition clause of definite predicates must be investigated every time these clauses are used. Therefore, by using the procedure reduce (Tsuda, 1994) each literal whose predicate is definite in the body is replaced by the body of its definition clause. Let us consider (18) below as an example. If the sole definition clause of c2 is (19), c2(X ,Y) in (18) is unified with the head of (19). Then, (18) is transformed into (20). (18) cl(f (X), Y) 4-{c2(X, Y)} (19) c2(g(A, B), Y) i-{c3(A), c4(B)} (20) cl(f (g(A, B)), Y) 4---{c3(A),c4(B)} By using this operation, Horn clause (15) above is transformed into the following one. c0(sign(verb, X6, sign(X7 , X6, X8))) 4- {not3s(X6)} Since not3s has two definitions, not3s(X6) is not replaced. Consequentl</context>
</contexts>
<marker>Tsuda, 1994</marker>
<rawString>Hiroshi Tsuda. 1994. cu-Prolog for constraint-based natural language processing. lEICE Transactions on Information and Systems, E77-D(2):171-180.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>