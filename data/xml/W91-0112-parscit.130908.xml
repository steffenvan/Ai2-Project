<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.990496">
A GENERAL COMPUTATIONAL METHOD FOR GRAMMAR INVERSION
</title>
<author confidence="0.725145">
Tomek Strzalkowski
</author>
<affiliation confidence="0.731524">
Courant Institute of Mathematical Sciences
</affiliation>
<address confidence="0.800207333333333">
New York University
715 Broadway, rm. 704
New York, NY 10003
</address>
<email confidence="0.998788">
tomek@cs.nyu.edu
</email>
<sectionHeader confidence="0.990372" genericHeader="abstract">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.999971875">
A reversible grammar is usually understood as a
computational or linguistic system that can be used
both for analysis and generation of the language it
defines. For example, a directive
pars_gen(Sent,Forin) would assign, depending upon
the binding status of its arguments, the representation
in (Toronto,chased (Fido,John)) to the sentence Fido
chased John in Toi;onto, or it would produce one of
the several possible paraphrases of this sentence
given its representation. Building such bi-directional
systems has long been considered critical for various
natural language processing tasks, especially in
machine translation. This paper presents a general
computational method for automated inversion of a
unification-based parser for natural language into an
efficient generator. It clarifies and expands the
results of earlier work on reversible grammars by this
author and the others. A more powerful version of
the grammar inversion algorithm is developed with a
special emphasis being placed on the proper treat-
ment of recursive &apos; rules. The grammar inversion
algorithm described here is at the core of the
Japanese-English machine translation project
currently under development at NYU.
</bodyText>
<sectionHeader confidence="0.992152" genericHeader="keywords">
REVERSIBLE GRAMMARS
</sectionHeader>
<bodyText confidence="0.9989481">
A reversible grammar is usually understood as
a computational or linguistic system that can be used
both for analysis and generation of the language it
defines. For example, a directive
pars_gen(Sent,Form) would assign, depending upon
the binding status of its arguments, the representation
in (Toronto,chased (Fido ,John)) to the sentence Fido
chased John in Toronto, or it would produce one of
the several possible paraphrases of this sentence
given its representation. In the last several years,
there have been a growing amount of research
activity in reversible grammars for natural language,
particularly in connection with machine translation
work, and in natural language generation. Develop-
ment of reversible grammar systems is considered
desirable for variety of reasons that include their
immediate use in both parsing and generation, a
reduction in the development and maintenance effort,
soundness and completeness of linguistic coverage,
as well as the match between their analysis and syn-
thesis capabilities. These properties are important in
any linguistic system, especially in machine transla-
tion, and in various interactive natural language sys-
tems where the direction of communication fre-
quently changes. In this paper we are primarily
interested in the computational aspects&apos; of reversibil-
ity that include bi-directional evaluation and dual
compilation of computer grammars, inversion of
parsers into efficient generators, and derivation of
&amp;quot;generating-versions&amp;quot; of existing parsing algorithms.
Some of the recent research in this area is reported in
(Calder et al., 1989; Dymetman and Isabelle, 1988;
Dymetman et al., 1990; Estival, 1990; Hasida and
Isizaki, 1987; Ishizaki, 1990; Shieber, 1988; Shieber
et al., 1990; Strzalkowski, 1990a-c; Strzalkowski and
Peng, 1990; van Noord, 1990; and Wedekind, 1988).
Dymetman and Isabelle (1988) describe a top-down
interpreter for definite clause grammars that statically
reorders clause literals according to a hand-coded
specification, and further allows for dynamic selec-
tion of AND goals2 during execution, using the tech-
nique known as the goal freezing (Colmerauer, 1982;
Naish, 1986). Shieber et al. (1990) propose a mixed
top-down/bottom-up interpretation, in which certain
goals, namely those whose expansion is defined by
the so-called &amp;quot;chain rules&amp;quot;,3 are not expanded during
the top-down phase of the interpreter, but instead
they are passed over until a nearest non-chain rule is
reached. In the bottom-up phase the missing parts of
the goal-expansion tree will be filled in by applying
For linguistic aspects of reversible grammars, see (Kay,
1984; Landsbergen, 1987; Neuman, 1990; Steedman, 1987).
2 Literals on the right-hand side of a clause create AND
goals; literals with the same predicate names on the left-hand sides
of different clauses create OR goals.
A chain rule is one where the main binding-carrying argu-
ment (the &amp;quot;head&amp;quot;) is passed unchanged from the left-hand side to
the right. For example, assert(P) --&gt;
subj(P1),verb(P2),obj(P1,P2,P), is a chain rule with respect to the
argument P, assuming that P is the &apos;head&apos; argument
</bodyText>
<page confidence="0.997521">
91
</page>
<bodyText confidence="0.987919871794872">
the chain rules in a backward manner. This tech-
nique, known as &apos;head-driven&apos; evaluation, can be
applied quite profitably to various grammar compila-
tion tasks, including the inverse computation, but it
requires that the underlying grammar is given in a
form where the information about the semantic heads
in nonterminals is made explicit. In addition, the pro-
cedure, as described in (Shieber et al, 1990), makes
no attempt to impose a proper ordering of the &amp;quot;non-
chain&amp;quot; goals, which may have an adverse effect on
the generator efficiency.4
The grammar inversion method described in
this paper transforms one set of PROLOG clauses
(representing a parser, eg.) into another set of
clauses (representing a generator) using an off-line
compilation process. The generator is thus just
another PROLOG program that has the property of
being an inverse of the parser program, that is, it per-
forms inverse computation.5 A unification grammar
is normally compiled into PROLOG to obtain an exe-
cutable program (usually a parser). Subsequently, the
inversion process takes place at the PROLOG code
level, and is therefore independent of any specific
grammar formalism used. The obtained inverted pro-
gram has been demonstrated to be quite efficient, and
we noted that the same technique can be applied to
parser/generator optimization. Our method is also
shown to deal adequately with recursive clauses that
created problems in purely top-down compilation.6
The inter-clausal inversion procedure discussed here
effects global changes in goal ordering by moving
selected goals between clauses and even creating
new clauses. The net effect is similar to that achieved
in the head-driven evaluation, except that no explicit
concept of &apos;head&apos; or &apos;chain-rule&apos; is used. The algo-
rithm has been tested on a substantial coverage PRO-
LOG grammar for English derived form the PRO-
TEUS Parser Grammar (Grishman, 1986), and the
Linguistic String Grammar for English (Sager,
</bodyText>
<page confidence="0.371419">
1981).7
</page>
<tableCaption confidence="0.797250625">
Some concern has also been voiced (Gardent and Plain-
fosse, 1990) about the termination conditions of this algorithm.
&apos;Some programs may in fact be multi-directional, and there-
fore may have several &apos;inverses&apos; or &apos;modes&apos;.
6 Shieber et at. (1990) have shown that some recursive
clauses cannot be executed using top-down evaluation thus
motivating the use of a mixed top-down/bottom-up evaluation of
their &apos;head-driven&apos; compilation.
</tableCaption>
<bodyText confidence="0.426697">
&apos;At present the grammar consists of 400i- productions.
</bodyText>
<sectionHeader confidence="0.887135" genericHeader="introduction">
IN AND OUT ARGUMENTS IN LITERALS
</sectionHeader>
<bodyText confidence="0.99929375">
Literals in the grammar clauses can be marked
for the &amp;quot;modes&amp;quot; in which they are used. When a
literal is submitted to execution then those of its argu-
ments which are bound at that time are called the &amp;quot;in&amp;quot;
arguments. After the computation is complete, some
of the previously unbound arguments may become
bound; these are called the &amp;quot;out&amp;quot; arguments. For
example, in concataa,b],[cAl],Z), which is used for
list concatenation, the first two arguments are &amp;quot;in&amp;quot;,
while the third is &amp;quot;out&amp;quot;. The roles are reversed when
concat is used for decomposition, as in
concat(X,Y4a,b,c,d1). In the literal
subject(Al ,A2.NUM,P), taken from an English gram-
mar, Al and A2 are input and output strings of words,
NUM is the number of the subject phrase, and P is
the final translation. When the grammar is used for
parsing, the &amp;quot;in&amp;quot; argument is Al; the &amp;quot;out&amp;quot; arguments
are A2, NUM and P; when it is used for generation,
the &amp;quot;in&amp;quot; argument is P; the &amp;quot;out&amp;quot; arguments are Al
and NUM. In generation, A2 is neither &amp;quot;in&amp;quot; nor &amp;quot;out&amp;quot;.
&amp;quot;In&amp;quot; and &amp;quot;out&amp;quot; status of arguments in a PROLOG
program can be computed statically at compile time.
The general algorithm has been described in (Strzal-
kowski, 1990c; Strzalkowski and Peng, 1990),
</bodyText>
<sectionHeader confidence="0.977029" genericHeader="method">
ESSENTIAL ARGUMENTS: AN EXTENSION
</sectionHeader>
<bodyText confidence="0.999615739130435">
The notion of an essential argument in a PRO-
WG literal has been first introduced in (Strzalkowski,
1989), and subsequently extended in (Strzalkowski,
1990bc; Strzalkowski and Peng, 1990). In short, X is
an essential argument in a literal p ( • • X • ) if X is
required to be &amp;quot;in&amp;quot; for a successful evaluation of this
literal. By a successful evaluation of a literal we
mean here the execution that is guaranteed to stop,
and moreover, that will proceed along an optimal
path. For instance, an evaluation of the goal
mem (a,L), with an intention to find a list L of which
a is a member, leads to a non-terminating execution
unless L&apos;s value is known. Likewise, a request to
generate a main verb in a sentence when the only
information we have is its root form (or &amp;quot;logical
form&amp;quot;) may lead to repeated access to the lexicon
until the &amp;quot;correct&amp;quot; surface form is chosen. Therefore,
for a lex icon access goal, say
acclex (Word,F eats ,Root), it is reasonable to require
that both Feats and Root are the essential arguments,
in other words, that the set (Feat,Root) is a minimal
set of essential arguments, or a MSEA, for acclex.
The following procedure computes the set of active
</bodyText>
<page confidence="0.989666">
92
</page>
<bodyText confidence="0.8912505">
MSEA&apos;s in a clause head literal! (6) For MSEAS (MS,MSEA,VP,s+1,OUT), i.e., for
i=s+1, do MS := (MSEA).
</bodyText>
<subsectionHeader confidence="0.650555">
PROCEDURE MSEAS(MS,MSEA,VP,i3OUT)
</subsectionHeader>
<bodyText confidence="0.936546">
[computing active MSEAs]
Given a clause p (X 1, • • • ,X„):— ri(X Li • • • X 1.0,
</bodyText>
<listItem confidence="0.974967">
• • • , r5(X8,1 • • • X.,4), where al, we compute the
set of active MSEAs in the head predicate p as fol-
lows:9
(1) Start with MSEA = 0,
VP = VAR ((X 1, • • • ,Xml), 1=1, and
OUT = OUT() = 0. The set of active MSEA&apos;s for
p is returned in MS.
(2) For 1=1, • • • 4, let MR; be the set of active
MSEA&apos;s of ri, and let MRU; = (m41 I j=1 • • • r;)
be obtained from MR; by replacing all variables
by their corresponding actual arguments of ri.
(3) Compute the set MP; = (1.ti,i I j=1 • r; )1, where
= (VAR (mii)— OUT;_i,k), where OUTi_i,k is
the set of all &apos;&apos;out&amp;quot; arguments in literals 1&apos;1 to
(4) For each go in MP; where do the follow-
ing:
(a) if KJ = 0 then:
(i) compute set OUTi of &amp;quot;out&amp;quot; arguments of
ri;
(ii) compute OUTiJ := OUTi u OUTi_i,k;
(iii) call
</listItem>
<bodyText confidence="0.867278833333333">
MSEAS(MS0,14...1,k,VP,i+1,0U7&apos;0);
otherwise, if gi 0 then find all distinct
minimal size sets v, c VP such that when-
ever the arguments in v, are &amp;quot;in&amp;quot;, then the
arguments in Ki are &amp;quot;out&amp;quot;. If such v,&apos;s exist,
then for every v, do:
</bodyText>
<listItem confidence="0.938291">
(i) assumeiv, is &amp;quot;in&amp;quot; in p;
(ii) compute the set OUTo, of &amp;quot;out&amp;quot; argu-
ments in all literals from r1 to r1;
(iii) call
(c) otherwise, if no such v, exist, MS; := 0.
(5) Compute MS :=
</listItem>
<subsectionHeader confidence="0.350213">
j=1..r
</subsectionHeader>
<bodyText confidence="0.998884347826087">
&apos;Active MSEA&apos;s are those existing with a given definition
of a predicate. Other, non-active MSEA&apos;s can be activated when
the clauses making up this definition are altered in some way. The
procedure can be straightforwardly augmented to compute all
MSEAs (Strzalkowski, 1990c).
&apos;For i =1 the sets of essential arguments are selected so as to
minimize the number of possible solutions to I.
As a simple example consider the following clause:
sent(P) vp(N,P),np(N).
Assuming that MSEA&apos;S for vp and np are (P) and
(N), respectively, and that N is &amp;quot;out&amp;quot; in vp, we can
easily compute that (P) is the MSEA in sent. To see it,
we note that MRUI for vp is ((P)) and, therefore,
that 111.1 = (P). Next, we note that MRU2 for np is
((N)), and since OUTLI from vp is (N), we obtain
that L2.1 = 0, and subsequently that (P) is the only
MSEA in sent.
The procedure presented above is sufficient in
many cases, but it cannot properly handle certain
types of recursive definitions. Consider, for example,
the problem of assigning the set of MSEA&apos;s to
mem(Elem,List), where mem (list membership) is
defined as follows:
</bodyText>
<construct confidence="0.972263666666667">
mem (Elem, [First !List]) :—
mem (Elem,List).
mem (Elem, [Elem !List]).
</construct>
<bodyText confidence="0.992982833333333">
The MSEAS procedure assigns MS =f (Elem),(List)),
we note however, that the first argument of mem can-
not alone control the recursion in the first clause
since the right-hand side (rhs) literal would repeat-
edly unify with the clause head, thus causing infinite
recursion. This consideration excludes (Elem) from
the list of possible MSEAs for mem. In (Strzalkowski,
1989) we introduced the directed relation always
unifiable among terms, which was informally charac-
terized as follows. A term X is always unifiable with
term Y if they unify regardless of any bindings that
may occur in X, providing that variables in X and Y
are standardized apart, and that Y remains unchanged.
According to this definition any term is always
unifiable with a variable, while the opposite is not
necessarily true. For example, the variable X is not
always unifiable with the functional term f(Y)
because binding X with g(Z) will make these two
terms non-unifiable. This relation can be formally
characterized as follows: given two terms X and Y we
say that Y is always unifiable with X (and write .Ar.Y)
if the unification of X and Y yields Y, where the vari-
ables occurring in X and Y have been standardized
apart.&amp;quot;) Since 5 describes a partial order among
terms, we can talk of its transitive closure ?. Now
we can augment the MSEAS procedure with the fol-
lowing two steps (to be placed between steps (2) and
I° So defined, the relation always unifiable becomes an in-
verse of another relation: less instantiated, hence the particular
direction of S sign.
</bodyText>
<figure confidence="0.799729">
(b)
</figure>
<page confidence="0.991704">
93
</page>
<bodyText confidence="0.996789684210526">
(3)) that would exclude certain MSEAs from recur-
sive clauses.
If ri = p then for every mi E MRUi if for every
argument Yi E mi.., where Yi is the /-th argument
in ri, and Xi is the /-th argument in p, we have
that X/5* Yi then remove m from MRUi.
For every set mi.„i = u (Zi.i), where 41 is
the j-th argument in ri such that it is not already
in m1.. and it is not the case that Y15 Z41, where
Yi is a j-th argument in p, if m1,, is not a super-
set of any other mid remaining in MRUi, then
add to MRUI.
In order for the MSEAS procedure to retain its practi-
cal significance we need to restrict the closure of 5 to
be defined only on certain special sets of terms that
we call ordered series.&amp;quot; It turns out that this res-
tricted relation is entirely sufficient in the task of
grammar inversion, if we assume that the original
grammar is itself well-defined.
</bodyText>
<sectionHeader confidence="0.89594" genericHeader="method">
DEFINITION I (argument series)
</sectionHeader>
<bodyText confidence="0.962020857142857">
Let p( • • Y • • ) r1, • • • ,r„ be a clause, and
ri1, • ,rik be an ordered subset of the literals on the
right-hand side of this clause. Let rik+1 be either a
literal to the right of r or the head literal p. The
ordered set of terms &lt;Y0,X1,Y1, • ,Xk,Yk,Xk.,.i&gt; is
an argument series iff the following conditions are
met
</bodyText>
<listItem confidence="0.994788111111111">
(1) Xic.fi is an argument in ri5+1;
(2) for every 1=1 • • k, Xi is different from any Xi
for] &lt;i;
(3) for every j=1 • • k, X and Yi are arguments to
rii, that is, rii(- • XJ,Y • -), such that if Xi is
&amp;quot;in&amp;quot; then Yi is &amp;quot;out&amp;quot; 12; and
(4) for every j43 • • k, either Xi.0=Y1 or
X1.414 (Yi) or Yi=f ()Cf.&amp;quot;), where f (X) denotes a
term containing a subterm X.
</listItem>
<bodyText confidence="0.926443111111111">
Note that this definition already ensures that
the argument series obtained between X0 and Xk+1 is
the shortest one. As an example, consider the follow-
ing clauses:
&amp;quot; A similar concept of guide-structure is introduced in
(Dymetman et al., 1990), however the ordered series is less restric-
tive and covers a larger class of recursive programs.
12 Yi may be partially &amp;quot;out&amp;quot;; see (Strzalkowski, 1990c) for
the definition of delayed &amp;quot;out&amp;quot; status.
</bodyText>
<equation confidence="0.5672215">
vp (X) :— np (X ,Y),vp (Y).
np(f (X),X).
</equation>
<bodyText confidence="0.9998904">
Assuming that the argument X in the literal vp (X) on
the left-hand side (lhs) of the first clause is &amp;quot;in&amp;quot;, we
can easily check that &lt;X,X,Y,Y&gt; constitutes an argu-
ment series between arguments of vp in the first
clause.
</bodyText>
<sectionHeader confidence="0.454906" genericHeader="method">
DEFINITION 2 (weakly ordered series)13
</sectionHeader>
<bodyText confidence="0.99867175">
An argument series &lt;Y0,X1,Y1, • • • ,Xk,YkXk.i&gt; in
the clause p :—ri • r„ is weakly ordered iff
Y05*X1,4.1 [or Xk.4.15*Y0], where 5* is a closure of 5_
defined as follows:
</bodyText>
<listItem confidence="0.980205571428571">
(1) for every i=1 • • k, such that r.(&amp;quot; • Xi,Yi • • )
there exists a clause
rii( • • • ,X,Y, • • ):— si, • • • ,s„„ where X and Y
unify with X and Yi, respectively, such that
X5*Y [or Y5*X];
(2) for every • • k, Xi.,4=Yi or Xi+1=1 (V) [or
Y14 (Xi+1)].
</listItem>
<bodyText confidence="0.998726461538461">
Looking back at the definition of mem (Elem,List) we
note that the first (recursive) clause contains two
ordered series. The first series, &lt;Elem,Elem&gt;, is not
ordered (or we may say it is ordered weakly in both
directions), and therefore Elem on the left-hand side
of the clause will always unify with Elem on the
right, thus causing non-terminating recursion. The
other series, &lt;First I List] ,List&gt;, is ordered in such
a way that [First IList] will not be always unifiable
with List, and thus the recursion is guaranteed to ter-
minate. This leaves (List) as the only acceptable
MSEA for mem.
Consider now the following new example:
</bodyText>
<listItem confidence="0.734116">
vp (X) :— np (X ,Y),vp (Y).
vp (X) :— v (X).
np (X,f (X)).
</listItem>
<bodyText confidence="0.999337454545455">
Note that the series &lt;X,X,Y,Y &gt; in the first clause is
ordered so that X5*Y. In other words, Y in vp on the
rhs is always unifiable with X on the lhs. This means
that a non-terminating recursion will result if we
attempt to execute the first clause top-down. On the
other hand, it may be noted that since the series is
ordered in one direction only, that is, we don&apos;t have
Y5*X, we could invert it so as to obtain Y5*X, but not
X?Y. To accomplish this, it is enough to swap the
arguments in the clause defining np, thus redirecting
the recursion. The revised program is guaranteed to
</bodyText>
<footnote confidence="0.459685666666667">
&amp;quot; A series can also be strongly ordered in a given direction,
if it is weakly ordered in that direction and it is not weakly ordered
in the opposite direction.
</footnote>
<page confidence="0.998345">
94
</page>
<bodyText confidence="0.813896428571429">
terminate, providing that vp&apos;s argument is bound,
which may be achieved by further reordering of
goals.I4
The ordered series relation is crucial in detect-
ing and removing of non-terminating left-recursive
rules of the grammar. The first of the following two
algorithms finds if an argument series is ordered in a
specified direction, without performing a partial
evaluation of goals. The second algorithm shows how
a directed series can be inverted.
ALGORITHM 1 (finding if YO?&apos;Xk+1 (weakly))
Given an argument series
&lt;Y0 ,X ,Y1 &apos; • • ,Xk, YkXk.fi &gt; do the following:
(1) Find if for every i=0 • • • k, either X,4.1=Y, or
(Y,); if the answer is negative, return NO
and quit.
(2) For every i=1 • • • k, find a clause
— • X,Y • • • ) S1, • • such that X and
Yj unify with X and Y, respectively, and there is a
leading series &lt;X • • Y&gt; such that Y. Return
NO if no such clause is found, and quit.
</bodyText>
<listItem confidence="0.999869">
(3) In the special case when k:), i.e., p has no
right-hand side, Y0aX if either Y0--X, or
Xi =,/ (Yo). If this is not the case return NO, and
quit.
(4) Otherwise, return YES.
</listItem>
<bodyText confidence="0.999141">
When ALGORITHM I returns a YES, it has generated
an ordered path (i.e., the series with all the necessary
subseries) between X0 and Xki.i to prove it. If this
path is ordered in one direction only, that is, there
exists at least one pair of adjacent elements Xi and Yi
within this path such that either X,=f (Y1) or
Yr-f (X), but not Xi=yi, then we say that the path is
properly ordered. In addition, if we force ALGO-
RITHM 1 to generate all the paths for a given series,
and they all turn out to be properly ordered, then we
will say that the series itself is properly ordered. We
can attempt to invert a properly ordered path, but not
the one which is only improperly ordered, i.e., in
both directions. Therefore, for a series to be inverti-
ble all its paths must be properly ordered, though not
necessarily in the same direction.&amp;quot;
ALGORITHM 2 (inverting properly ordered series)
Given a clause p:—r,, • • ,r„, and an argument
</bodyText>
<footnote confidence="0.270281">
&apos;4 Reordering of goals may be required to make sure that ap-
propriate essential arguments are bound.
</footnote>
<page confidence="0.932185">
15
</page>
<bodyText confidence="0.875268512820513">
Recursion defi;ed with respect to improperly ordered
series is considered ill-formed.
series &lt;Y0,X1,Y1 , • • ,Xk,YkXk4.1&gt; such that it is
properly (weakly) ordered as X0?Xk4.1 [or
0], invert it as follows:
(1) For each rij(- • ,X1,Yi, • • • ) appearing on the
rhs of the clause, find all clauses
rii( • • ,X,Y, • • ) s 1, • • ,s„, such that X and
Y unify with X; and Yj, respectively, and there is
a proper ordering X1C.*Y [or Ken
(2) Recursively invert the series &lt;X • • • Y&gt;; for the
special case where m=0, that is, rei clause has no
rhs, exchange places of X and Y.
(3) For every pair of Y1 and X,4.1 (i=0 • • • k), if either
Yi=f (Xj.4.1) or X14.1=f (Y,), where f is fully
instantiated, exchange Yi with Xi+1, and do noth-
ing otherwise.
We now return to the MSEAS procedure and add a
new step (2C), that will follow the two steps (2A)
and (2B) discussed earlier. The option in (2C) is used
when the expansion of a MSEA rejected in step (2A)
has failed in (2B). In an earlier formulation of this
procedure an empty MSEA was returned, indicating
an non-executable clause. In step (2C) we attempt to
rescue those clauses in which the recursion is based
on invertible weakly ordered series.
(2C)
Find an argument Y, E a t-th argument of ri,
such that X,? Y, where X, is the t-th argument in
the head literal p and the series &lt;X, • • Y1&gt; is
properly ordered. If no such Y, is found, augment
mi,„ with additional arguments; quit if no further
progress is possible.16 Invert the series with
Awolumm 2, obtaining a strongly ordered series
&lt;X&apos;, • • • Y&apos;,&gt; such that Replace V,
with r, in mi,„ and add the resulting set to
At this point we may consider a specific linguistic
example involving a generalized left-recursive pro-
duction based on a properly ordered series.I7
</bodyText>
<figure confidence="0.719702571428571">
[1] sent (V 1,V 3,Sem)
np (V1 ,V2,Ssem),
vp(V2,V3,[Ssem],Sem).
[2] vp (V1 ,V3,Args,Vsem)
vp (V1 ,V2,[Csem I Args],Vsem),
np(V2,V3,Csem).
&amp;quot;As in step (213) we have to maintain the minimality of
</figure>
<footnote confidence="0.276509">
This example is loosely based on the grammar described
in (Shieber et al., 1990).
</footnote>
<page confidence="0.988263">
95
</page>
<figure confidence="0.966899142857143">
[3] vp (V1 ,V2,Args,Vsem) :—
v (V1 ,V2,Args,Vsem).
[4] v (V1 ,V2 ,(Obj,Subj ],chased (Subj,Obj))
chased (V1 ,V2).
[5] chased ([chased IX ],X).
[6] np ([john IX ],X,john).
[7] np ([fido IX ],X ,fido).
</figure>
<bodyText confidence="0.977971357142857">
We concentrate here on the clause [2], and note that
there are three argument series between the vp
literals: &lt; V/ , V/ &gt;, &lt;Args, [Csem I Args ]&gt;, and
&lt;Vsem,Vsem &gt; , of which only the second one is
invertible. We also note that in clause [3], the collec-
tion of MSEAs for vp include ( V/ ) and (Vsem),
where V1 represents the surface string, and Vsem its
&amp;quot;semantics&amp;quot;. When we use this grammar for genera-
tion, (V1) is eliminated in step (2A) of the MSEAS
procedure, while (Vsem), is rescued in step (2C),
where it is augmented with Args which belongs to the
invertible series. We obtain a new set (Args&apos;,Vsem),
which, if we decide to use it, will also alter the clause
[2] as shown below.18
</bodyText>
<equation confidence="0.971264">
[2a] vp (V1 ,V3,[Csem I Args],Vsem)
vp (V1 ,V2,Args,Vsem),np (V2 ,V3 ,Csem).
</equation>
<bodyText confidence="0.999956857142857">
This altered clause can be used in the generator code,
but we still have to solve the problem of having the
[Csem I Args] bound, in addition to Vsem.19 It must
be noted that we can no longer meaningfully use the
former &amp;quot;in&amp;quot; status (if there was one) of this argument
position, once the series it heads has been inverted.
We shall return to this problem shortly.
</bodyText>
<sectionHeader confidence="0.995748" genericHeader="method">
INTRA-CLAUSAL INVERSION
</sectionHeader>
<bodyText confidence="0.98750756">
The following general rule is adopted for an
effective execution of logic programs: never expand
a goal before at least one of its active MSEAs is &amp;quot;in&amp;quot;.
This simple principle can be easily violated when a
program written to perform in a given direction is
used to run &amp;quot;backwards&amp;quot;, or for that matter, in any
other direction. In particular, a parser frequently can-
not be used as a generator without violating the
MSEA-binding rule. This problem is particularly
acute within a fixed-order evaluation strategy, such
as that of PROLOG. The most unpleasant consequence
of disregarding the above rule is that the program
may go into an infinite loop and have to be aborted,
which happens surprisingly often for non-trivial size
Is In our inversion algorithm we would not alter the clause
until we find that the MSEA needs to be used.
19 Vsem is expected to be &amp;quot;in&amp;quot; during generation, since it car-
ries the &amp;quot;semantics&amp;quot; of vp, that is, provides the input to the genera-
tor.
programs. Even if this does not happen, the program
performance can be seriously hampered by excessive
guessing and backtracking. Therefore, in order to
run a parser in the reverse, we must rearrange the
order in which its goals are expanded. This can be
achieved in the following three steps:
</bodyText>
<sectionHeader confidence="0.515639" genericHeader="method">
PROCEDURE INVERSE
</sectionHeader>
<listItem confidence="0.992747357142857">
(1) Compute &amp;quot;in&amp;quot; and &amp;quot;out&amp;quot; status of arguments for
the reversed computation. If the top-level goal
parse (String,Sem) is used to invoke a generator,
then Sem is initially &amp;quot;in&amp;quot;, while String is
expected to have &amp;quot;out&amp;quot; status.
(2) Compute sets of all (active and non-active)
MSEAs for predicates used in the program.
(3) For each goal, if none of its MSEAs is &amp;quot;in&amp;quot; then
move this goal to a new position with respect to
other goals in such a way that at least one of its
MSEAs is &amp;quot;in&amp;quot;. If this &amp;quot;in&amp;quot; MSEA is not an active
one, recursively invert clauses defining the
goal&apos;s predicate so as to make the MSEA become
active.
</listItem>
<bodyText confidence="0.999728090909091">
In a basic formulation of the inversion algorithm the
movement of goals in step (3) is confined to be
within the right-hand sides of program clauses, that
is, goals cannot be moved between clauses. The
inversion process proceeds top-down, starting with
the top-level clause, for example parse (String,Sem)
:— sent (String, [],Sem). The restricted movement
inversion algorithm INVERSE has been documented in
detail in (Strzalkowski, 1990ac). It is demonstrated
here on the following clause taken from a parser pro-
gram, and which recognizes yes-no questions:
</bodyText>
<construct confidence="0.906329">
yesnoq (Al ,A4,P) :—
verb (Al ,A2,Num,P2),
subject (A2,A3,Num,P1),
object (A3 ,A4,P 1 ,P2,P).
</construct>
<bodyText confidence="0.986388">
When rewriting this clause for generation, we would
place object first (it has P &amp;quot;in&amp;quot;, and A3, PI, P2 &amp;quot;out&amp;quot;),
then subject (it has the essential PI &amp;quot;in&amp;quot;, and A2 and
Num &amp;quot;out&amp;quot;), and finally verb (its MSEA is either
(Al) or (Num,P2), the latter being completely &amp;quot;in&amp;quot;
now). The net effect is the following generator
clause:&amp;quot;
</bodyText>
<construct confidence="0.97794375">
yesnoq (Al ,A4,P) :—
object (A3 ,A4 ,P 1 ,P2,P),
subject (A2,A3,Num,P1),
verb (Al ,A2,Num,P2).
</construct>
<bodyText confidence="0.70975825">
INVERSE works satisfactorily for most grammars, but
it cannot properly handle certain types of clauses
&amp;quot; Note that the surface linguistic string is not generated
from the left to the right.
</bodyText>
<page confidence="0.986416">
96
</page>
<bodyText confidence="0.997864">
where no definite ordering of goals can be achieved
even after redefinition of goal predicates. This can
happen when two or more literals wait for one
another to have bindings delivered to some of their
essential arguments. The extended MSEAS procedure
is used to define a general inversion procedure INTER-
CLAUSAL to be discussed next.
</bodyText>
<sectionHeader confidence="0.977804" genericHeader="method">
INTER-CLAUSAL INVERSION
</sectionHeader>
<bodyText confidence="0.990663285714286">
Consider again the example given at the end of
the section on essential arguments. After applying
MSEAS procedure we find that the only way to save
MSEA (Args,Vsem) is to invert the series
&lt;Args,[Csem I Args]&gt; between vp literals. This
alters the affected clause [2] as shown below (we
show also other clauses that will be affected at a later
</bodyText>
<figure confidence="0.961967714285714">
stage):21
[1] sent (Sem) :—
np (Ssem),T ([Ssem ],Sem).
[2] vp (fC sem I Argsl,Vsem) :—
vp (Args,Vsem),np (Csem).
[3] vp (Args,Vsem) :—
v (Args,Vsern).
</figure>
<bodyText confidence="0.9543214">
In order to use the second clause for generation, we
now require [CsemlArgs] to be &amp;quot;in&amp;quot; at the head literal
vp. This, however, is not the case since the only input
we receive for generation is the binding to Sem in
clause [1], and subsequently, Vsem in [2], for exam-
ple, ?—sent (chased (Fido,John)). Therefore the code
still cannot be executed. Moreover, we note that
clause [1] is now deadlocked, since neither vp nor np
can be executed first. 22 At this point the only remain-
ing option is to use interclausal ordering in an effort
to inverse [1]. We move v from the rhs of [3] to [1],
while np travels from [1] to [3]. The following new
code is obtained (the second argument in the new vp&apos;
can be dropped, and the new MSEA for vp&apos; is
(Args)):&apos;&apos;
</bodyText>
<subsectionHeader confidence="0.798299">
The string variables VI, V2, etc. are dropped for clarity.
</subsectionHeader>
<bodyText confidence="0.997216538461538">
n There are situations when a clause would not appear
deadlocked but still require expansion, for example if we replace
III by seni(Sem,Ssem) :-Ivp(Ssem,Sem), with Ssem bound in sent.
This clause is equivalent to sent(Sem,Ssem) :-
Vsemm--Ssem,vp(Vsem,Sem), but since the series in 121 has been in-
verted we can no longer meaningfully evaluate the rhs literals in
the given order. In fact we need to evaluate vp first which cannot be
done until Vsem is bound.
&amp;quot; An alternative is to leave Eli intact (except for goal order-
ing) and add an &amp;quot;interface&amp;quot; clause that would relate the old vp to
the new vp&apos;. In such case the procedure would generate an addi-
tional argument for vp&apos; in order to return the final value of Args
which needs lobe passed to np.
</bodyText>
<figure confidence="0.967983666666667">
[11 sent (Sem) :—
v (Args,Sem),v1(Args).
[21 vp&apos;([Csem I Args]) :—
vp&apos;(Args),np (Csem).
[31 vp&apos;([Ssem]) :—
np (Ssem).
</figure>
<bodyText confidence="0.999227">
This code is executable provided that Sem is bound in
sent. Since Args is &amp;quot;out&amp;quot; in v, the recursion in [21 is
well defined at last. The effect of the interclausal
ordering is achieved by adopting the INTERCLAUSAL
procedure described below. The procedure is
invoked when a deadlocked clause has been
identified by INVERSE, that is, a clause in which the
right-hand side literals cannot be completely ordered.
</bodyText>
<sectionHeader confidence="0.732391" genericHeader="method">
PROCEDURE INTERCLAUSAL(DLC)
</sectionHeader>
<bodyText confidence="0.783999">
[Inter-clausal inversion]
</bodyText>
<listItem confidence="0.896509666666667">
(1) Convert the deadlocked clause into a special
canonical form in which the clause consists
exclusively of two types of literals: the
unification goals in the form X =Y where X is a
variable and Y is a term, and the remaining
literals whose arguments are only variables (i.e.,
</listItem>
<bodyText confidence="0.9690435">
no constants or functional terms are allowed).
Any unification goals derived from the head
literal are placed at the front of the rhs. In addi-
tion, if p ( • • • X • • ) is a recursive goal on the
rhs of the clause, such that X is an &amp;quot;in&amp;quot; variable
unifiable with the head of an inverted series in
the definition of p, then replace X by a new vari-
able X/ and insert a unification goal X/.X. The
clause in [1] above is transformed into the fol-
lowing form:
</bodyText>
<figure confidence="0.78748475">
[1] sent (Sem) :—
np (Ssem),
Args=[Ssem],
vp (A rgs,Sem).
</figure>
<bodyText confidence="0.9302483125">
(2) Select one or more non-unification goals, starting
with the &amp;quot;semantic-head&amp;quot; goal (if any), for static
expansion. The &amp;quot;semantic-head&amp;quot; goal is the one
that shares an essential argument with the literal
at the head of the clause. Recursive clauses in
the definitions of goal predicates should never be
used for expansion. In the example at hand, vp
can be expanded with [3].
(3) Convert the clauses to be used for goal expan-
sion into the canonical form. In our example [3]
needs no conversion.
(4) Expand deadlocked goals by replacing them with
appropriately aliased right-hand sides of the
clauses selected for expansion. In effect we per-
form a partial evaluation of these goals. Expand-
ing vp in [1] with [3] yields the following new
</bodyText>
<page confidence="0.995203">
97
</page>
<figure confidence="0.7357755">
clause:
flal sent (Sem) :—
np (Ssem),
Args -=[Ssem ],
v (Args,Sem).
(5) Find an executable order of the goals in the
</figure>
<figureCaption confidence="0.506761">
expanded clause. If not possible, expand more
goals by recursively invoking INFERCLAUSAL,
until the clause can be ordered or no further
expansion is possible. In our example [la] can
be ordered as follows:
</figureCaption>
<construct confidence="0.8781305">
[lb] sent (Sem) :—
v (Args,Sem),
Args =[Ssem],
np (Ssem).
</construct>
<bodyText confidence="0.985484636363636">
(6) Break the expanded clause back into two (or
more) &amp;quot;original&amp;quot; clauses in such a way that: (a)
the resulting clauses are executable, and (b) the
clause which has been expanded is made as gen-
eral as possible by moving as many unification
goals as possible out to the clause(s) used in
expansion. In our example v (Args,Sem) has to
remain in [lb], but the remainer of the rhs can be
moved to the new vp&apos; clause. We obtain the fol-
lowing clauses (note that clause [2] has thus far
remained unchanged throughout this process):
</bodyText>
<figure confidence="0.988419777777778">
[Ib] sent (Sem) :—
v (Args,Sem),
vp&apos;(Args,_).
[2b] vp&apos;([C sem I Args],Sem) :—
vp/(Args,Sem),
np (C sem).
[3b] vp&apos;(Args,_)
Args =[Ssem
np (Ssem).
</figure>
<bodyText confidence="0.6660085">
(7) Finally, simplify the clauses and return to the
standard form by removing unification goals.
Remove superfluous arguments in literals. The
result are the clauses [1&apos;] to [31 above.
</bodyText>
<sectionHeader confidence="0.997305" genericHeader="conclusions">
CONCLUSIONS
</sectionHeader>
<bodyText confidence="0.997855256410257">
We described a general method for inversion
of logic grammars that transforms a parser into an
efficient generator using an off-line compilation pro-
cess that manipulates parser&apos;s clauses. The resulting
&amp;quot;inverted-parser&amp;quot; generator behaves as if it was
&amp;quot;parsing&amp;quot; a structured representation translating it
into a well-formed linguistic string. The augmented
grammar compilation procedure presented here is
already quite general: it appears to subsume both the
static compilation procedure of Strzalkowski (1990c),
and the head-driven grammar evaluation technique of
Shieber et al. (1990).
The process of grammar inversion is logically
divided into two stages: (a) computing the collections
of minimal sets of essential arguments (MSEAs) in
predicates, and (b) rearranging the order of goals in
the grammar so that at least one active MSEA is &amp;quot;in&amp;quot;
in every literal when its expansion is attempted. The
first stage also includes computing the &amp;quot;in&amp;quot; and &amp;quot;out&amp;quot;
arguments. In the second stage, the goal inversion
process is initialized by the procedure INVERSE,
which recursively reorders goals on the right-hand
sides of clauses to meet the MSEA-binding require-
ment. Deadlocked clauses which cannot be ordered
with INVERSE are passed for the interclausal ordering
with the procedure INTERCLAUSAL. Special treatment
is provided for recursive goals defined with respect to
properly ordered series of arguments. Whenever
necessary, the direction of recursion is inverted
allowing for &amp;quot;backward&amp;quot; computation of these goals.
This provision eliminates an additional step of gram-
mar normalization.
In this paper we described the main principles
of grammar inversion and discussed some of the cen-
tral procedures, but we have mostly abstracted from
implementation level considerations. A substantial
part of the grammar inversion procedure has been
implemented, including the computation of minimal
sets of essential arguments, and is used in a
</bodyText>
<sectionHeader confidence="0.989473" genericHeader="discussions">
Japanese-English machine translation system?&amp;quot;
ACKNOWLEDGEMENTS
</sectionHeader>
<bodyText confidence="0.671286375">
This paper is based upon work supported by
the Defense Advanced Research Project Agency
under Contract N00014-904-1851 from the Office of
Naval Research, and by the National Science Foun-
dation under Grant IRI-89-02304. Thanks to Marc
Dymetman, Patrick Saint-Dizier, and Gertjan van
Noord for their comments on an earlier version of
this paper.
</bodyText>
<sectionHeader confidence="0.973036" genericHeader="references">
REFERENCES
</sectionHeader>
<reference confidence="0.975441666666667">
Calder, Jonathan, Mike Reape and Henk
Zeevai 1989. &amp;quot;An Algorithm for Generation in
Unification Categorial Grammar.&amp;quot; Proc. 4th Conf
of the European Chapter of the ACL, Manchester,
England, April 1989. pp. 233-240.
Colmerauer, Main. 1982. PROLOG II:
Manuel de reference et modele theorique. Groupe
Further details can be found in (Peng and Strzallcowski,
1990; Strzalkowsld and Peng, 1990; and Peng, forthcoming).
</reference>
<page confidence="0.989174">
98
</page>
<reference confidence="0.998625876404495">
d&apos;Intelligence Artificielle, Faculte de Sciences de
Luminy, Marseille.
Dymetman, Marc and Pierre Isabelle. 1988.
&amp;quot;Reversible Logic Grammars for Machine Transla-
tion.&amp;quot; Proc. 2nd Int. Conf. on Machine Translation,
Carnegie-Mellon Univ.
Dymetman, Marc, Pierre Isabelle and Francois
Perrault. 1990. &amp;quot;A Symmetrical Approach to Pars-
ing and Generation.&amp;quot; COLING-90, Helsinki, Fin-
land, August 1990. Vol. 3, pp. 90-96.
Estival, Dominique. 1990. &amp;quot;Generating
French with a Reversible Unification Grammar.&amp;quot;
COLING-90, Helsinki, Finland, August 1990. Vol. 2,
pp. 106-111.
Gardent, Claire and Agnes Plainfosse. 1990
&amp;quot;Generating from Deep Structure.&amp;quot; COLING-90,
Helsinki, Finland, August 1990. Vol 2, pp. 127-132.
Grishman, Ralph. 1986. Proteus Parser Refer-
ence Manual. Proteus Project Memorandum #4,
Courant Institute of Mathematical Sciences, New
York University.
Hasida, Koiti, Syun Isizaki. 1987. &amp;quot;Depen-
dency Propagation: A Unified Theory of Sentence
Comprehension and Generation.&amp;quot; IJCAI-87, Milano,
Italy, August 1987. pp. 664-670.
Ishizaki, Masato. 1990. &amp;quot;A Bottom-up Gen-
eration for Principle-based Grammars Using Con-
straint Propagation.&amp;quot; COLING-90, Helsinki, Fin-
land, August 1990. Vol 2, pp. 188-193.
Kay, Martin. 1984. &amp;quot;Functional Unification
Grammar: A Formalism for Machine Translation.&amp;quot;
COLING-84, StanfOrd, CA, July 1984, pp. 75-78.
Landsbergen, Jan. 1987. &amp;quot;Montague Gram-
mar and Machine Translation.&amp;quot; Eindhoven, Holland:
Philips Research M.S. 14.026.
Naish, Lee. 1986. Negation and Control in
PROLOG. Lecture Notes in Computer Science, 238,
Springer.
Newman, P. 1990. &amp;quot;Towards Convenient Bi-
Directional Grammar Formalisms.&amp;quot; COLING-90,
Helsinki, Finland, August 1990. Vol. 2, pp. 294-298.
Peng, Ping. forthcoming. &amp;quot;A Japanese/English
Reversible Machine Translation System With Sub-
language Approach.&amp;quot; Courant Institute of
Mathematical Sciences, New York University.
Peng, Ping and Tomek Strzalkowski. 1990.
&amp;quot;An Implementation of a Reversible Grammar.&amp;quot;
Proc. 8th Canadiari: Conf on Artificial Intelligence,
Ottawa, Canada, June 1990. pp. 121-127.
Sager, Naomi. 1981. Natural Language Infor-
mation Processing. Addison-Wesley.
Shieber, Stuart, M. 1988. &amp;quot;A uniform archi-
tecture for parsing and generation.&amp;quot; COLING-88,
Budapest, Hungary, August 1988, pp. 614-619.
Shieber, Stuart, M., Gertjan van Noord, Robert
C. Moore, Fernando C. N. Pereira. 1990. &amp;quot;A
Semantic-Head-Driven Generation.&amp;quot; Computational
Linguistics, 16(1), pp. 30-42. MIT Press.
Steedman, Mark. 1987. &amp;quot;Combinatory Gram-
mars and Parasitic Gaps.&amp;quot; Natural Language and
Linguistic Theory, 5, pp. 403-439.
Strzalkowski, Tomek. 1989. Automated Inver-
sion of a Unification Parser into a Unification Gen-
erator. Technical Report 465, Department of Com-
puter Science, Courant Institute of Mathematical Sci-
ences, New York University.
Strzalkowski, Tomek. 1990a. &amp;quot;An algorithm
for inverting a unification grammar into an efficient
unification generator.&amp;quot; Applied Mathematics Letters,
3(1), pp. 93-96. Pergamon Press.
Strzalkowski, Tomek. 1990b. &amp;quot;How to Invert
a Parser into an Efficient Generator an algorithm for
logic grammars.&amp;quot; COLING-90, Helsinki, Finland,
August 1990. Vol. 2, pp. 347-352.
Strzalkowski, Tomek. 1990c. &amp;quot;Reversible
logic grammars for natural language parsing and gen-
eration.&amp;quot; Computational Intelligence, 6(3), pp. 145-
171. NRC Canada.
Strzalkowski, Tomek and Ping Peng. 1990.
&amp;quot;Automated Inversion of Logic Grammars for Gen-
eration.&amp;quot; Proc. of 28th ACL, Pittsburgh, PA, June
1990. pp. 212-219.
van Noord, Gertjan. 1990. &amp;quot;Reversible
Unification Based Machine Translation.&amp;quot; COLING-
90, Helsinki, Finland, August 1990. Vol. 2, pp. 299-
304.
Wedekind, Jurgen. 1988. &amp;quot;Generation as
structure driven derivation.&amp;quot; COLING-88, Budapest,
Hungary, August 1988, pp. 732-737.
</reference>
<page confidence="0.998937">
99
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.000001">
<title confidence="0.999362">A GENERAL COMPUTATIONAL METHOD FOR GRAMMAR INVERSION</title>
<author confidence="0.991063">Tomek</author>
<affiliation confidence="0.999664">Courant Institute of Mathematical</affiliation>
<address confidence="0.885314666666667">New York 715 Broadway, rm. New York, NY</address>
<email confidence="0.999066">tomek@cs.nyu.edu</email>
<abstract confidence="0.998246017857143">A reversible grammar is usually understood as a computational or linguistic system that can be used both for analysis and generation of the language it defines. For example, a assign, depending upon the binding status of its arguments, the representation (Toronto,chased (Fido,John)) to sentence John in Toi;onto, it would produce one of the several possible paraphrases of this sentence given its representation. Building such bi-directional systems has long been considered critical for various natural language processing tasks, especially in machine translation. This paper presents a general computational method for automated inversion of a unification-based parser for natural language into an efficient generator. It clarifies and expands the results of earlier work on reversible grammars by this author and the others. A more powerful version of the grammar inversion algorithm is developed with a special emphasis being placed on the proper treatment of recursive &apos; rules. The grammar inversion algorithm described here is at the core of the Japanese-English machine translation project currently under development at NYU. REVERSIBLE GRAMMARS A reversible grammar is usually understood as a computational or linguistic system that can be used both for analysis and generation of the language it defines. For example, a assign, depending upon the binding status of its arguments, the representation (Toronto,chased (Fido ,John)) the sentence John in Toronto, it would produce one of the several possible paraphrases of this sentence given its representation. In the last several years, there have been a growing amount of research activity in reversible grammars for natural language, particularly in connection with machine translation work, and in natural language generation. Development of reversible grammar systems is considered desirable for variety of reasons that include their immediate use in both parsing and generation, a reduction in the development and maintenance effort, soundness and completeness of linguistic coverage, as well as the match between their analysis and synthesis capabilities. These properties are important in any linguistic system, especially in machine translation, and in various interactive natural language systems where the direction of communication frequently changes. In this paper we are primarily interested in the computational aspects&apos; of reversibility that include bi-directional evaluation and dual compilation of computer grammars, inversion of parsers into efficient generators, and derivation of &amp;quot;generating-versions&amp;quot; of existing parsing algorithms.</abstract>
<note confidence="0.909600571428572">Some of the recent research in this area is reported in (Calder et al., 1989; Dymetman and Isabelle, 1988; Dymetman et al., 1990; Estival, 1990; Hasida and Isizaki, 1987; Ishizaki, 1990; Shieber, 1988; Shieber et al., 1990; Strzalkowski, 1990a-c; Strzalkowski and Peng, 1990; van Noord, 1990; and Wedekind, 1988). Dymetman and Isabelle (1988) describe a top-down</note>
<abstract confidence="0.998178933503837">interpreter for definite clause grammars that statically reorders clause literals according to a hand-coded and further allows for dynamic selecof AND during execution, using the techknown as the freezing 1982; Naish, 1986). Shieber et al. (1990) propose a mixed top-down/bottom-up interpretation, in which certain goals, namely those whose expansion is defined by so-called &amp;quot;chain are not expanded during the top-down phase of the interpreter, but instead they are passed over until a nearest non-chain rule is reached. In the bottom-up phase the missing parts of the goal-expansion tree will be filled in by applying For linguistic aspects of reversible grammars, see (Kay, 1984; Landsbergen, 1987; Neuman, 1990; Steedman, 1987). 2Literals on the right-hand side of a clause create AND goals; literals with the same predicate names on the left-hand sides of different clauses create OR goals. A chain rule is one where the main binding-carrying argument (the &amp;quot;head&amp;quot;) is passed unchanged from the left-hand side to right. For example, a chain rule with respect to the that the &apos;head&apos; argument 91 the chain rules in a backward manner. This technique, known as &apos;head-driven&apos; evaluation, can be applied quite profitably to various grammar compilation tasks, including the inverse computation, but it requires that the underlying grammar is given in a form where the information about the semantic heads in nonterminals is made explicit. In addition, the procedure, as described in (Shieber et al, 1990), makes no attempt to impose a proper ordering of the &amp;quot;nonchain&amp;quot; goals, which may have an adverse effect on generator The grammar inversion method described in paper transforms one set of (representing a parser, eg.) into another set of clauses (representing a generator) using an off-line compilation process. The generator is thus just that has the property of an inverse of the parser program, that is, it perinverse A unification grammar normally compiled into obtain an executable program (usually a parser). Subsequently, the process takes place at the level, and is therefore independent of any specific grammar formalism used. The obtained inverted program has been demonstrated to be quite efficient, and we noted that the same technique can be applied to parser/generator optimization. Our method is also shown to deal adequately with recursive clauses that problems in purely top-down The inter-clausal inversion procedure discussed here effects global changes in goal ordering by moving selected goals between clauses and even creating new clauses. The net effect is similar to that achieved in the head-driven evaluation, except that no explicit concept of &apos;head&apos; or &apos;chain-rule&apos; is used. The algohas been tested on a substantial coverage PROfor English derived form the PRO- TEUS Parser Grammar (Grishman, 1986), and the Linguistic String Grammar for English (Sager, Some concern has also been voiced (Gardent and Plainfosse, 1990) about the termination conditions of this algorithm. programs may in fact be multi-directional, and therefore may have several &apos;inverses&apos; or &apos;modes&apos;. 6Shieber et at. (1990) have shown that some recursive clauses cannot be executed using top-down evaluation thus motivating the use of a mixed top-down/bottom-up evaluation of their &apos;head-driven&apos; compilation. present the grammar consists of 400iproductions. IN AND OUT ARGUMENTS IN LITERALS Literals in the grammar clauses can be marked for the &amp;quot;modes&amp;quot; in which they are used. When a literal is submitted to execution then those of its arguments which are bound at that time are called the &amp;quot;in&amp;quot; arguments. After the computation is complete, some of the previously unbound arguments may become bound; these are called the &amp;quot;out&amp;quot; arguments. For example, in concataa,b],[cAl],Z), which is used for list concatenation, the first two arguments are &amp;quot;in&amp;quot;, while the third is &amp;quot;out&amp;quot;. The roles are reversed when used for decomposition, as in concat(X,Y4a,b,c,d1). In the ,A2.NUM,P), from an English gram- Al and input and output strings of words, is number of the subject phrase, and the final translation. When the grammar is used for parsing, the &amp;quot;in&amp;quot; argument is Al; the &amp;quot;out&amp;quot; arguments NUM it is used for generation, &amp;quot;in&amp;quot; argument is the arguments are generation, A2 is neither &amp;quot;in&amp;quot; nor &amp;quot;out&amp;quot;. and &amp;quot;out&amp;quot; status of arguments in a program can be computed statically at compile time. The general algorithm has been described in (Strzalkowski, 1990c; Strzalkowski and Peng, 1990), ESSENTIAL ARGUMENTS: AN EXTENSION notion of an essential argument in a PROhas been first introduced in (Strzalkowski, 1989), and subsequently extended in (Strzalkowski, and Peng, 1990). In short, is argument in a p ( • • X • ) required to be &amp;quot;in&amp;quot; for a successful evaluation of this literal. By a successful evaluation of a literal we mean here the execution that is guaranteed to stop, and moreover, that will proceed along an optimal For instance, an evaluation of the (a,L), an intention to find a list which a is a member, leads to a non-terminating execution unless L&apos;s value is known. Likewise, a request to generate a main verb in a sentence when the only information we have is its root form (or &amp;quot;logical form&amp;quot;) may lead to repeated access to the lexicon until the &amp;quot;correct&amp;quot; surface form is chosen. Therefore, for a lex icon access goal, (Word,F eats ,Root), is reasonable to require both are essential arguments, other words, that the set is a minimal of essential arguments, a The following procedure computes the set of active 92 in clause head literal! (6) For (MS,MSEA,VP,s+1,OUT), i.e., [computing active MSEAs] a clause (X • • • ,X„):— Li• • • X • • , • • • X.,4), al, we compute the of active MSEAs in the head predicate fol- Start with = 0, = VAR ((X 1, • • • ,Xml), = OUT() = 0. set of active returned in For 1=1, • • • 4, let be the set of active let = I j=1 • • • obtained from by replacing all variables their corresponding actual arguments of Compute the set = I j=1 • where the set of all &apos;&apos;out&amp;quot; arguments in literals 1&apos;1 to For each in MP; do the following: if = 0 compute set of &amp;quot;out&amp;quot; arguments of compute := (iii) call if 0 then find all distinct size sets v, c that whenever the arguments in v, are &amp;quot;in&amp;quot;, then the in are &amp;quot;out&amp;quot;. If such v,&apos;s exist, then for every v, do: assumeiv, is &amp;quot;in&amp;quot; in compute the set &amp;quot;out&amp;quot; arguin all literals from to (iii) call otherwise, if no such v, exist, := Compute j=1..r those existing with a given definition a predicate. Other, non-active be activated when the clauses making up this definition are altered in some way. The procedure can be straightforwardly augmented to compute all 1990c). the sets of essential arguments are selected so as to minimize the number of possible solutions to I. As a simple example consider the following clause: sent(P) vp(N,P),np(N). that are (P) and that is in we compute that the see it, note that for is ((P)) therefore, = we note that for is since from (N), we obtain and subsequently that is only The procedure presented above is sufficient in many cases, but it cannot properly handle certain types of recursive definitions. Consider, for example, problem of assigning the set of to membership) is defined as follows: mem (Elem, [First !List]) :— mem (Elem,List). mem (Elem, [Elem !List]). assigns note however, that the first argument of cannot alone control the recursion in the first clause since the right-hand side (rhs) literal would repeatedly unify with the clause head, thus causing infinite This consideration excludes list of possible (Strzalkowski, we introduced the directed relation terms, which was informally characas follows. A term is always unifiable term Y if they unify regardless of any bindings that occur in that variables in Y are standardized apart, and that Y remains unchanged. According to this definition any term is always unifiable with a variable, while the opposite is not necessarily true. For example, the variable X is not always unifiable with the functional term f(Y) because binding X with g(Z) will make these two terms non-unifiable. This relation can be formally as follows: given two terms Y we that Y is unifiable write .Ar.Y) the unification of Y yields Y, where the varioccurring in Y have been standardized Since a partial order among terms, we can talk of its transitive closure ?. Now can augment the with the following two steps (to be placed between steps (2) and I°So defined, the relation unifiable an inof another relation: instantiated, the particular direction of S sign. (b) 93 that would exclude certain recursive clauses. = p for every mi if for every E where is the /-th argument is the /-th argument in have then remove every set = u where j-th argument in such that it is not already it is not the case that where is a j-th argument in not a superof any other remaining in to order for the to retain its practical significance we need to restrict the closure of 5 to be defined only on certain special sets of terms that call ordered series.&amp;quot; turns out that this restricted relation is entirely sufficient in the task of grammar inversion, if we assume that the original grammar is itself well-defined. (argument series) • • Y • • ) • • • be a clause, • be an ordered subset of the literals on the side of this clause. Let be either a to the right of r or the head literal set of terms • series the following conditions are met (1) is an argument in for every 1=1 • • is different from any &lt;i; for every j=1 • • X are arguments to that is, • • -), that if is then is &amp;quot;out&amp;quot; for every • or or where (X) a containing a subterm Note that this definition already ensures that argument series obtained between and is the shortest one. As an example, consider the following clauses: A similar concept of introduced in (Dymetman et al., 1990), however the ordered series is less restrictive and covers a larger class of recursive programs. 12Yi be partially &amp;quot;out&amp;quot;; see (Strzalkowski, 1990c) for the definition of delayed &amp;quot;out&amp;quot; status. vp (X) :— np (X ,Y),vp (Y). np(f (X),X). that the argument the literal (X) the left-hand side (lhs) of the first clause is &amp;quot;in&amp;quot;, we easily check that an arguseries between arguments of the first clause. 2 ordered argument series • • • clause • r„ weakly ordered iff [or where is a closure of defined as follows: for every i=1 • • that r.(&amp;quot; • • • ) there exists a • • ,X,Y, • • ):— • • • Y with respectively, such that [or for every • • or Y14 (Xi+1)]. back at the definition of (Elem,List) note that the first (recursive) clause contains two series. The first series, not ordered (or we may say it is ordered weakly in both and therefore the left-hand side the clause will always unify with the right, thus causing non-terminating recursion. The series, I List] ,List&gt;, ordered in such way that IList] not be always unifiable thus the recursion is guaranteed to ter- This leaves the only acceptable Consider now the following new example: vp (X) :— np (X ,Y),vp (Y). vp (X) :— v (X). np (X,f (X)). that the series &gt; the first clause is so that In other words, Y in the is unifiable with X the lhs. This means that a non-terminating recursion will result if we attempt to execute the first clause top-down. On the other hand, it may be noted that since the series is ordered in one direction only, that is, we don&apos;t have we could invert it so as to obtain but not accomplish this, it is enough to swap the in the clause defining redirecting the recursion. The revised program is guaranteed to &amp;quot; A series can also be strongly ordered in a given direction, if it is weakly ordered in that direction and it is not weakly ordered in the opposite direction. 94 terminate, providing that vp&apos;s argument is bound, which may be achieved by further reordering of The ordered series relation is crucial in detecting and removing of non-terminating left-recursive rules of the grammar. The first of the following two algorithms finds if an argument series is ordered in a specified direction, without performing a partial evaluation of goals. The second algorithm shows how a directed series can be inverted. (finding if Given an argument ,X &apos; • • do the following: Find if for every i=0 • • • either or (Y,); if the answer is negative, return NO and quit. For every i=1 • • • a clause — • X,Y • • • ) • • that unify with Y, respectively, and there is a leading series &lt;X • • Y&gt; such that Y. NO if no such clause is found, and quit. In the special case when no side, if either or =,/ If this is not the case return NO, and quit. (4) Otherwise, return YES. I a YES, it has generated an ordered path (i.e., the series with all the necessary between and prove it. If this path is ordered in one direction only, that is, there at least one pair of adjacent elements and this path such that either (X), not we say that the path is ordered. In addition, if we force ALGO- 1 generate all the paths for a given series, and they all turn out to be properly ordered, then we will say that the series itself is properly ordered. We can attempt to invert a properly ordered path, but not the one which is only improperly ordered, i.e., in both directions. Therefore, for a series to be invertible all its paths must be properly ordered, though not necessarily in the same direction.&amp;quot; 2 properly ordered series) a clause • • ,r„, an argument Reordering of goals may be required to make sure that appropriate essential arguments are bound. 15 Recursion defi;ed with respect to improperly ordered series is considered ill-formed. , • • that it is (weakly) ordered as [or it as follows: For each • • • • ) on the rhs of the clause, find all clauses • • • ) s 1, • • ,s„, that unify with and respectively, and there is proper ordering [or Ken Recursively invert the &lt;X • • • Y&gt;; the case where m=0, that is, clause has no exchange places of Y. For every pair of and (i=0 • • • k), either where fully exchange with and do nothing otherwise. now return to the and add a new step (2C), that will follow the two steps (2A) and (2B) discussed earlier. The option in (2C) is used the expansion of a in step (2A) has failed in (2B). In an earlier formulation of this an empty returned, indicating an non-executable clause. In step (2C) we attempt to rescue those clauses in which the recursion is based on invertible weakly ordered series. (2C) an argument Y, of that Y, the t-th argument in head literal the series &lt;X, • • is properly ordered. If no such Y, is found, augment additional arguments; quit if no further is Invert the series with a strongly ordered series • • • such that Replace r, in add the resulting set to At this point we may consider a specific linguistic example involving a generalized left-recursive probased on a properly ordered</abstract>
<note confidence="0.692318470588235">[1] sent (V 1,V 3,Sem) np (V1 ,V2,Ssem), vp(V2,V3,[Ssem],Sem). [2] vp (V1 ,V3,Args,Vsem) vp (V1 ,V2,[Csem I Args],Vsem), np(V2,V3,Csem). &amp;quot;As in step (213) we have to maintain the minimality of This example is loosely based on the grammar described in (Shieber et al., 1990). 95 [3] vp (V1 ,V2,Args,Vsem) :— v (V1 ,V2,Args,Vsem). v ,V2 ,(Obj,Subj ],chased (Subj,Obj)) chased (V1 ,V2). [5] chased ([chased IX ],X). [6] np ([john IX ],X,john). [7] np ([fido IX ],X ,fido).</note>
<abstract confidence="0.998635155234657">We concentrate here on the clause [2], and note that are three argument series between vp &lt; [Csem I Args ]&gt;, &gt; , which only the second one is invertible. We also note that in clause [3], the collecof ( V/ ) and the surface string, and &amp;quot;semantics&amp;quot;. When we use this grammar for generaeliminated in step (2A) of the while rescued in step (2C), it is augmented with belongs to the series. We obtain a new set which, if we decide to use it, will also alter the clause as shown (V1 ,V3,[Csem I Args],Vsem) vp (V1 ,V2,Args,Vsem),np (V2 ,V3 ,Csem). This altered clause can be used in the generator code, but we still have to solve the problem of having the I Args] in addition to It be noted that we can no longer meaningfully use the former &amp;quot;in&amp;quot; status (if there was one) of this argument position, once the series it heads has been inverted. We shall return to this problem shortly. INTRA-CLAUSAL INVERSION The following general rule is adopted for an effective execution of logic programs: never expand goal before at least one of its active is This simple principle can be easily violated when a program written to perform in a given direction is used to run &amp;quot;backwards&amp;quot;, or for that matter, in any other direction. In particular, a parser frequently cannot be used as a generator without violating the MSEA-binding rule. This problem is particularly acute within a fixed-order evaluation strategy, such that of most unpleasant consequence of disregarding the above rule is that the program may go into an infinite loop and have to be aborted, which happens surprisingly often for non-trivial size IsIn our inversion algorithm we would not alter the clause until we find that the MSEA needs to be used. 19Vsem expected to be &amp;quot;in&amp;quot; during generation, since it carthe &amp;quot;semantics&amp;quot; of that provides the input to the generator. programs. Even if this does not happen, the program performance can be seriously hampered by excessive guessing and backtracking. Therefore, in order to run a parser in the reverse, we must rearrange the order in which its goals are expanded. This can be achieved in the following three steps: PROCEDURE INVERSE (1) Compute &amp;quot;in&amp;quot; and &amp;quot;out&amp;quot; status of arguments for the reversed computation. If the top-level goal (String,Sem) is to invoke a generator, is initially while is expected to have &amp;quot;out&amp;quot; status. (2) Compute sets of all (active and non-active) predicates used in the program. For each goal, if none of its is then move this goal to a new position with respect to other goals in such a way that at least one of its is If this &amp;quot;in&amp;quot; not an active one, recursively invert clauses defining the predicate so as to make the active. In a basic formulation of the inversion algorithm the movement of goals in step (3) is confined to be within the right-hand sides of program clauses, that is, goals cannot be moved between clauses. The inversion process proceeds top-down, starting with top-level clause, for example (String,Sem) sent (String, [],Sem).The restricted movement algorithm been documented in detail in (Strzalkowski, 1990ac). It is demonstrated here on the following clause taken from a parser program, and which recognizes yes-no questions: yesnoq (Al ,A4,P) :— verb (Al ,A2,Num,P2), subject (A2,A3,Num,P1), object (A3 ,A4,P 1 ,P2,P). When rewriting this clause for generation, we would (it has P &amp;quot;in&amp;quot;, and A3, PI, P2 &amp;quot;out&amp;quot;), has the essential PI &amp;quot;in&amp;quot;, and A2 and &amp;quot;out&amp;quot;), and finally (its MSEA is (Al) or (Num,P2), the latter being completely &amp;quot;in&amp;quot; now). The net effect is the following generator clause:&amp;quot; yesnoq (Al ,A4,P) :— object (A3 ,A4 ,P 1 ,P2,P), subject (A2,A3,Num,P1), verb (Al ,A2,Num,P2). satisfactorily for most grammars, but it cannot properly handle certain types of clauses &amp;quot; Note that the surface linguistic string is not generated from the left to the right. 96 where no definite ordering of goals can be achieved even after redefinition of goal predicates. This can happen when two or more literals wait for one another to have bindings delivered to some of their arguments. The extended used to define a general inversion procedure INTERbe discussed next. INTER-CLAUSAL INVERSION Consider again the example given at the end of the section on essential arguments. After applying we find that the only way to save (Args,Vsem) is to the series I Args]&gt; This alters the affected clause [2] as shown below (we show also other clauses that will be affected at a later [1] sent (Sem) :— np (Ssem),T ([Ssem ],Sem). [2] vp (fC sem I Argsl,Vsem) :— vp (Args,Vsem),np (Csem). [3] vp (Args,Vsem) :— v (Args,Vsern). In order to use the second clause for generation, we require be &amp;quot;in&amp;quot; at the head literal however, is not the case since the only input receive for generation is the binding to [1], and subsequently, [2], for exam- (chased (Fido,John)). the code still cannot be executed. Moreover, we note that [1] is now deadlocked, since neither be executed first. 22At this point the only remaining option is to use interclausal ordering in an effort to inverse [1]. We move v from the rhs of [3] to [1], from [1] to [3]. The following new is obtained (the second argument in the new be dropped, and the new is (Args)):&apos;&apos; The string variables VI, V2, etc. are dropped for clarity. nThere are when a clause would not appear deadlocked but still require expansion, for example if we replace seni(Sem,Ssem) sent. clause is equivalent to since the series in 121 has been inverted we can no longer meaningfully evaluate the rhs literals in given order. In fact we need to evaluate which cannot be until bound. &amp;quot; An alternative is to leave Eli intact (except for goal orderand add an &amp;quot;interface&amp;quot; clause that would relate the old new such case the procedure would generate an addiargument for order to return the final value of needs lobe passed to [11 sent (Sem) :— v (Args,Sem),v1(Args). I Args]) :— vp&apos;(Args),np (Csem). :— np (Ssem). code is executable provided that bound is in v, the recursion in [21 is well defined at last. The effect of the interclausal is achieved by adopting the procedure described below. The procedure is invoked when a deadlocked clause has been by is, a clause in which the right-hand side literals cannot be completely ordered. PROCEDURE INTERCLAUSAL(DLC) [Inter-clausal inversion] (1) Convert the deadlocked clause into a special canonical form in which the clause consists exclusively of two types of literals: the goals in the form =Y a variable and Y is a term, and the remaining literals whose arguments are only variables (i.e., no constants or functional terms are allowed). Any unification goals derived from the head literal are placed at the front of the rhs. In addiif ( • • • X • • ) is a goal on the of the clause, such that an &amp;quot;in&amp;quot; variable unifiable with the head of an inverted series in definition of replace a new variinsert a unification goal clause in [1] above is transformed into the following form: (Sem) :— np (Ssem), vp (A rgs,Sem). (2) Select one or more non-unification goals, starting with the &amp;quot;semantic-head&amp;quot; goal (if any), for static expansion. The &amp;quot;semantic-head&amp;quot; goal is the one that shares an essential argument with the literal at the head of the clause. Recursive clauses in the definitions of goal predicates should never be for expansion. In the example at hand, can be expanded with [3]. (3) Convert the clauses to be used for goal expansion into the canonical form. In our example [3] needs no conversion. (4) Expand deadlocked goals by replacing them with appropriately aliased right-hand sides of the clauses selected for expansion. In effect we perform a partial evaluation of these goals. Expandin with [3] yields the following new 97 clause: (Sem) :— np (Ssem), Args -=[Ssem ], v (Args,Sem). (5) Find an executable order of the goals in the expanded clause. If not possible, expand more by recursively invoking until the clause can be ordered or no further expansion is possible. In our example [la] can be ordered as follows: (Sem) :— v (Args,Sem), Args =[Ssem], np (Ssem). (6) Break the expanded clause back into two (or more) &amp;quot;original&amp;quot; clauses in such a way that: (a) the resulting clauses are executable, and (b) the clause which has been expanded is made as general as possible by moving as many unification goals as possible out to the clause(s) used in In our example v to remain in [lb], but the remainer of the rhs can be to the new We obtain the following clauses (note that clause [2] has thus far remained unchanged throughout this process): (Sem) :— v (Args,Sem), vp&apos;(Args,_). sem I Args],Sem) :— vp/(Args,Sem), np (C sem). Args =[Ssem np (Ssem). (7) Finally, simplify the clauses and return to the standard form by removing unification goals. Remove superfluous arguments in literals. The result are the clauses [1&apos;] to [31 above. CONCLUSIONS We described a general method for inversion of logic grammars that transforms a parser into an efficient generator using an off-line compilation process that manipulates parser&apos;s clauses. The resulting &amp;quot;inverted-parser&amp;quot; generator behaves as if it was &amp;quot;parsing&amp;quot; a structured representation translating it into a well-formed linguistic string. The augmented grammar compilation procedure presented here is already quite general: it appears to subsume both the static compilation procedure of Strzalkowski (1990c), and the head-driven grammar evaluation technique of Shieber et al. (1990). The process of grammar inversion is logically divided into two stages: (a) computing the collections minimal sets of essential arguments predicates, and (b) rearranging the order of goals in grammar so that at least one active is &amp;quot;in&amp;quot; in every literal when its expansion is attempted. The first stage also includes computing the &amp;quot;in&amp;quot; and &amp;quot;out&amp;quot; arguments. In the second stage, the goal inversion is initialized by the procedure which recursively reorders goals on the right-hand sides of clauses to meet the MSEA-binding requirement. Deadlocked clauses which cannot be ordered passed for the interclausal ordering the procedure treatment is provided for recursive goals defined with respect to properly ordered series of arguments. Whenever necessary, the direction of recursion is inverted allowing for &amp;quot;backward&amp;quot; computation of these goals. This provision eliminates an additional step of grammar normalization. In this paper we described the main principles of grammar inversion and discussed some of the central procedures, but we have mostly abstracted from implementation level considerations. A substantial part of the grammar inversion procedure has been implemented, including the computation of minimal sets of essential arguments, and is used in a Japanese-English machine translation system?&amp;quot; ACKNOWLEDGEMENTS</abstract>
<note confidence="0.86519052631579">This paper is based upon work supported by the Defense Advanced Research Project Agency under Contract N00014-904-1851 from the Office of Naval Research, and by the National Science Foundation under Grant IRI-89-02304. Thanks to Marc Dymetman, Patrick Saint-Dizier, and Gertjan van Noord for their comments on an earlier version of this paper. REFERENCES Calder, Jonathan, Mike Reape and Henk Zeevai 1989. &amp;quot;An Algorithm for Generation in Categorial Grammar.&amp;quot; 4th Conf the European Chapter of the ACL, England, April 1989. pp. 233-240. Main. 1982. II: de reference et modele theorique. Further details can be found in (Peng and Strzallcowski, 1990; Strzalkowsld and Peng, 1990; and Peng, forthcoming). 98 d&apos;Intelligence Artificielle, Faculte de Sciences de Luminy, Marseille. Dymetman, Marc and Pierre Isabelle. 1988. &amp;quot;Reversible Logic Grammars for Machine Transla- 2nd Int. Conf. on Machine Translation, Carnegie-Mellon Univ. Dymetman, Marc, Pierre Isabelle and Francois Perrault. 1990. &amp;quot;A Symmetrical Approach to Parsand Generation.&amp;quot; Finland, August 1990. Vol. 3, pp. 90-96. Estival, Dominique. 1990. &amp;quot;Generating French with a Reversible Unification Grammar.&amp;quot; Finland, August 1990. Vol. 2, pp. 106-111. Gardent, Claire and Agnes Plainfosse. 1990 from Deep Structure.&amp;quot; Helsinki, Finland, August 1990. Vol 2, pp. 127-132. Ralph. 1986. Parser Refer- Manual. Project Memorandum #4,</note>
<affiliation confidence="0.991578">Courant Institute of Mathematical Sciences, New York University.</affiliation>
<address confidence="0.827743">Hasida, Koiti, Syun Isizaki. 1987. &amp;quot;Depen-</address>
<note confidence="0.792814595238095">dency Propagation: A Unified Theory of Sentence and Generation.&amp;quot; Italy, August 1987. pp. 664-670. Ishizaki, Masato. 1990. &amp;quot;A Bottom-up Generation for Principle-based Grammars Using Con- Propagation.&amp;quot; Finland, August 1990. Vol 2, pp. 188-193. Kay, Martin. 1984. &amp;quot;Functional Unification Grammar: A Formalism for Machine Translation.&amp;quot; CA, July 1984, pp. 75-78. Landsbergen, Jan. 1987. &amp;quot;Montague Grammar and Machine Translation.&amp;quot; Eindhoven, Holland: Philips Research M.S. 14.026. Lee. 1986. and Control in Notes in Computer Science, 238, Springer. Newman, P. 1990. &amp;quot;Towards Convenient Bi- Grammar Formalisms.&amp;quot; Helsinki, Finland, August 1990. Vol. 2, pp. 294-298. Peng, Ping. forthcoming. &amp;quot;A Japanese/English Reversible Machine Translation System With Sublanguage Approach.&amp;quot; Courant Institute of Mathematical Sciences, New York University. Peng, Ping and Tomek Strzalkowski. 1990. &amp;quot;An Implementation of a Reversible Grammar.&amp;quot; Proc. 8th Canadiari: Conf on Artificial Intelligence, June 1990. pp. 121-127. Naomi. 1981. Language Infor- Processing. Shieber, Stuart, M. 1988. &amp;quot;A uniform archifor parsing and generation.&amp;quot; Budapest, Hungary, August 1988, pp. 614-619. Shieber, Stuart, M., Gertjan van Noord, Robert C. Moore, Fernando C. N. Pereira. 1990. &amp;quot;A Generation.&amp;quot; pp. 30-42. MIT Press. Steedman, Mark. 1987. &amp;quot;Combinatory Gramand Parasitic Gaps.&amp;quot; Language and Theory, pp. 403-439. Tomek. 1989. Inversion of a Unification Parser into a Unification Gen- Report 465, Department of Com-</note>
<affiliation confidence="0.709816">puter Science, Courant Institute of Mathematical Sciences, New York University.</affiliation>
<address confidence="0.814114">Strzalkowski, Tomek. 1990a. &amp;quot;An algorithm</address>
<abstract confidence="0.460880333333333">for inverting a unification grammar into an efficient generator.&amp;quot; Mathematics Letters, 3(1), pp. 93-96. Pergamon Press.</abstract>
<note confidence="0.906065894736842">Strzalkowski, Tomek. 1990b. &amp;quot;How to Invert a Parser into an Efficient Generator an algorithm for grammars.&amp;quot; Finland, August 1990. Vol. 2, pp. 347-352. Strzalkowski, Tomek. 1990c. &amp;quot;Reversible logic grammars for natural language parsing and gen- Intelligence, pp. 145- 171. NRC Canada. Strzalkowski, Tomek and Ping Peng. 1990. &amp;quot;Automated Inversion of Logic Grammars for Genof 28th ACL, PA, June 1990. pp. 212-219. van Noord, Gertjan. 1990. &amp;quot;Reversible Based Machine Translation.&amp;quot; COLING- Finland, August 1990. Vol. 2, pp. 299- 304. Wedekind, Jurgen. 1988. &amp;quot;Generation as driven derivation.&amp;quot; Hungary, August 1988, pp. 732-737.</note>
<intro confidence="0.69872">99</intro>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Jonathan Calder</author>
</authors>
<title>Mike Reape and Henk Zeevai</title>
<date>1989</date>
<booktitle>Proc. 4th Conf of the European Chapter of the ACL,</booktitle>
<pages>233--240</pages>
<location>Manchester, England,</location>
<marker>Calder, 1989</marker>
<rawString>Calder, Jonathan, Mike Reape and Henk Zeevai 1989. &amp;quot;An Algorithm for Generation in Unification Categorial Grammar.&amp;quot; Proc. 4th Conf of the European Chapter of the ACL, Manchester, England, April 1989. pp. 233-240.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Main Colmerauer</author>
</authors>
<title>PROLOG II: Manuel de reference et modele theorique. Groupe Further details can be found in (Peng and Strzallcowski,</title>
<date>1982</date>
<journal>Strzalkowsld</journal>
<location>Marseille.</location>
<contexts>
<context position="3554" citStr="Colmerauer, 1982" startWordPosition="515" endWordPosition="516"> the recent research in this area is reported in (Calder et al., 1989; Dymetman and Isabelle, 1988; Dymetman et al., 1990; Estival, 1990; Hasida and Isizaki, 1987; Ishizaki, 1990; Shieber, 1988; Shieber et al., 1990; Strzalkowski, 1990a-c; Strzalkowski and Peng, 1990; van Noord, 1990; and Wedekind, 1988). Dymetman and Isabelle (1988) describe a top-down interpreter for definite clause grammars that statically reorders clause literals according to a hand-coded specification, and further allows for dynamic selection of AND goals2 during execution, using the technique known as the goal freezing (Colmerauer, 1982; Naish, 1986). Shieber et al. (1990) propose a mixed top-down/bottom-up interpretation, in which certain goals, namely those whose expansion is defined by the so-called &amp;quot;chain rules&amp;quot;,3 are not expanded during the top-down phase of the interpreter, but instead they are passed over until a nearest non-chain rule is reached. In the bottom-up phase the missing parts of the goal-expansion tree will be filled in by applying For linguistic aspects of reversible grammars, see (Kay, 1984; Landsbergen, 1987; Neuman, 1990; Steedman, 1987). 2 Literals on the right-hand side of a clause create AND goals; </context>
</contexts>
<marker>Colmerauer, 1982</marker>
<rawString>Colmerauer, Main. 1982. PROLOG II: Manuel de reference et modele theorique. Groupe Further details can be found in (Peng and Strzallcowski, 1990; Strzalkowsld and Peng, 1990; and Peng, forthcoming). d&apos;Intelligence Artificielle, Faculte de Sciences de Luminy, Marseille.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Marc Dymetman</author>
<author>Pierre Isabelle</author>
</authors>
<title>Reversible Logic Grammars for Machine Translation.&amp;quot;</title>
<date>1988</date>
<booktitle>Proc. 2nd Int. Conf. on Machine Translation, Carnegie-Mellon Univ.</booktitle>
<contexts>
<context position="3036" citStr="Dymetman and Isabelle, 1988" startWordPosition="438" endWordPosition="441">s and synthesis capabilities. These properties are important in any linguistic system, especially in machine translation, and in various interactive natural language systems where the direction of communication frequently changes. In this paper we are primarily interested in the computational aspects&apos; of reversibility that include bi-directional evaluation and dual compilation of computer grammars, inversion of parsers into efficient generators, and derivation of &amp;quot;generating-versions&amp;quot; of existing parsing algorithms. Some of the recent research in this area is reported in (Calder et al., 1989; Dymetman and Isabelle, 1988; Dymetman et al., 1990; Estival, 1990; Hasida and Isizaki, 1987; Ishizaki, 1990; Shieber, 1988; Shieber et al., 1990; Strzalkowski, 1990a-c; Strzalkowski and Peng, 1990; van Noord, 1990; and Wedekind, 1988). Dymetman and Isabelle (1988) describe a top-down interpreter for definite clause grammars that statically reorders clause literals according to a hand-coded specification, and further allows for dynamic selection of AND goals2 during execution, using the technique known as the goal freezing (Colmerauer, 1982; Naish, 1986). Shieber et al. (1990) propose a mixed top-down/bottom-up interpret</context>
</contexts>
<marker>Dymetman, Isabelle, 1988</marker>
<rawString>Dymetman, Marc and Pierre Isabelle. 1988. &amp;quot;Reversible Logic Grammars for Machine Translation.&amp;quot; Proc. 2nd Int. Conf. on Machine Translation, Carnegie-Mellon Univ.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Marc Dymetman</author>
<author>Pierre Isabelle</author>
<author>Francois Perrault</author>
</authors>
<title>A Symmetrical Approach to Parsing and Generation.&amp;quot;</title>
<date>1990</date>
<volume>3</volume>
<pages>90--96</pages>
<location>COLING-90, Helsinki, Finland,</location>
<contexts>
<context position="3059" citStr="Dymetman et al., 1990" startWordPosition="442" endWordPosition="445"> These properties are important in any linguistic system, especially in machine translation, and in various interactive natural language systems where the direction of communication frequently changes. In this paper we are primarily interested in the computational aspects&apos; of reversibility that include bi-directional evaluation and dual compilation of computer grammars, inversion of parsers into efficient generators, and derivation of &amp;quot;generating-versions&amp;quot; of existing parsing algorithms. Some of the recent research in this area is reported in (Calder et al., 1989; Dymetman and Isabelle, 1988; Dymetman et al., 1990; Estival, 1990; Hasida and Isizaki, 1987; Ishizaki, 1990; Shieber, 1988; Shieber et al., 1990; Strzalkowski, 1990a-c; Strzalkowski and Peng, 1990; van Noord, 1990; and Wedekind, 1988). Dymetman and Isabelle (1988) describe a top-down interpreter for definite clause grammars that statically reorders clause literals according to a hand-coded specification, and further allows for dynamic selection of AND goals2 during execution, using the technique known as the goal freezing (Colmerauer, 1982; Naish, 1986). Shieber et al. (1990) propose a mixed top-down/bottom-up interpretation, in which certain</context>
<context position="15318" citStr="Dymetman et al., 1990" startWordPosition="2591" endWordPosition="2594">owing conditions are met (1) Xic.fi is an argument in ri5+1; (2) for every 1=1 • • k, Xi is different from any Xi for] &lt;i; (3) for every j=1 • • k, X and Yi are arguments to rii, that is, rii(- • XJ,Y • -), such that if Xi is &amp;quot;in&amp;quot; then Yi is &amp;quot;out&amp;quot; 12; and (4) for every j43 • • k, either Xi.0=Y1 or X1.414 (Yi) or Yi=f ()Cf.&amp;quot;), where f (X) denotes a term containing a subterm X. Note that this definition already ensures that the argument series obtained between X0 and Xk+1 is the shortest one. As an example, consider the following clauses: &amp;quot; A similar concept of guide-structure is introduced in (Dymetman et al., 1990), however the ordered series is less restrictive and covers a larger class of recursive programs. 12 Yi may be partially &amp;quot;out&amp;quot;; see (Strzalkowski, 1990c) for the definition of delayed &amp;quot;out&amp;quot; status. vp (X) :— np (X ,Y),vp (Y). np(f (X),X). Assuming that the argument X in the literal vp (X) on the left-hand side (lhs) of the first clause is &amp;quot;in&amp;quot;, we can easily check that &lt;X,X,Y,Y&gt; constitutes an argument series between arguments of vp in the first clause. DEFINITION 2 (weakly ordered series)13 An argument series &lt;Y0,X1,Y1, • • • ,Xk,YkXk.i&gt; in the clause p :—ri • r„ is weakly ordered iff Y05*X1,</context>
</contexts>
<marker>Dymetman, Isabelle, Perrault, 1990</marker>
<rawString>Dymetman, Marc, Pierre Isabelle and Francois Perrault. 1990. &amp;quot;A Symmetrical Approach to Parsing and Generation.&amp;quot; COLING-90, Helsinki, Finland, August 1990. Vol. 3, pp. 90-96.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dominique Estival</author>
</authors>
<title>Generating French with a Reversible Unification Grammar.&amp;quot;</title>
<date>1990</date>
<volume>2</volume>
<pages>106--111</pages>
<location>COLING-90, Helsinki, Finland,</location>
<contexts>
<context position="3074" citStr="Estival, 1990" startWordPosition="446" endWordPosition="447">mportant in any linguistic system, especially in machine translation, and in various interactive natural language systems where the direction of communication frequently changes. In this paper we are primarily interested in the computational aspects&apos; of reversibility that include bi-directional evaluation and dual compilation of computer grammars, inversion of parsers into efficient generators, and derivation of &amp;quot;generating-versions&amp;quot; of existing parsing algorithms. Some of the recent research in this area is reported in (Calder et al., 1989; Dymetman and Isabelle, 1988; Dymetman et al., 1990; Estival, 1990; Hasida and Isizaki, 1987; Ishizaki, 1990; Shieber, 1988; Shieber et al., 1990; Strzalkowski, 1990a-c; Strzalkowski and Peng, 1990; van Noord, 1990; and Wedekind, 1988). Dymetman and Isabelle (1988) describe a top-down interpreter for definite clause grammars that statically reorders clause literals according to a hand-coded specification, and further allows for dynamic selection of AND goals2 during execution, using the technique known as the goal freezing (Colmerauer, 1982; Naish, 1986). Shieber et al. (1990) propose a mixed top-down/bottom-up interpretation, in which certain goals, namely </context>
</contexts>
<marker>Estival, 1990</marker>
<rawString>Estival, Dominique. 1990. &amp;quot;Generating French with a Reversible Unification Grammar.&amp;quot; COLING-90, Helsinki, Finland, August 1990. Vol. 2, pp. 106-111.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Claire Gardent</author>
<author>Agnes Plainfosse</author>
</authors>
<title>Generating from Deep Structure.&amp;quot;</title>
<date>1990</date>
<volume>2</volume>
<pages>127--132</pages>
<location>COLING-90, Helsinki, Finland,</location>
<contexts>
<context position="6550" citStr="Gardent and Plainfosse, 1990" startWordPosition="984" endWordPosition="988"> that created problems in purely top-down compilation.6 The inter-clausal inversion procedure discussed here effects global changes in goal ordering by moving selected goals between clauses and even creating new clauses. The net effect is similar to that achieved in the head-driven evaluation, except that no explicit concept of &apos;head&apos; or &apos;chain-rule&apos; is used. The algorithm has been tested on a substantial coverage PROLOG grammar for English derived form the PROTEUS Parser Grammar (Grishman, 1986), and the Linguistic String Grammar for English (Sager, 1981).7 Some concern has also been voiced (Gardent and Plainfosse, 1990) about the termination conditions of this algorithm. &apos;Some programs may in fact be multi-directional, and therefore may have several &apos;inverses&apos; or &apos;modes&apos;. 6 Shieber et at. (1990) have shown that some recursive clauses cannot be executed using top-down evaluation thus motivating the use of a mixed top-down/bottom-up evaluation of their &apos;head-driven&apos; compilation. &apos;At present the grammar consists of 400i- productions. IN AND OUT ARGUMENTS IN LITERALS Literals in the grammar clauses can be marked for the &amp;quot;modes&amp;quot; in which they are used. When a literal is submitted to execution then those of its ar</context>
</contexts>
<marker>Gardent, Plainfosse, 1990</marker>
<rawString>Gardent, Claire and Agnes Plainfosse. 1990 &amp;quot;Generating from Deep Structure.&amp;quot; COLING-90, Helsinki, Finland, August 1990. Vol 2, pp. 127-132.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ralph Grishman</author>
</authors>
<title>Proteus Parser Reference Manual.</title>
<date>1986</date>
<booktitle>Proteus Project Memorandum #4, Courant Institute of Mathematical Sciences,</booktitle>
<location>New York University.</location>
<contexts>
<context position="6422" citStr="Grishman, 1986" startWordPosition="967" endWordPosition="968">an be applied to parser/generator optimization. Our method is also shown to deal adequately with recursive clauses that created problems in purely top-down compilation.6 The inter-clausal inversion procedure discussed here effects global changes in goal ordering by moving selected goals between clauses and even creating new clauses. The net effect is similar to that achieved in the head-driven evaluation, except that no explicit concept of &apos;head&apos; or &apos;chain-rule&apos; is used. The algorithm has been tested on a substantial coverage PROLOG grammar for English derived form the PROTEUS Parser Grammar (Grishman, 1986), and the Linguistic String Grammar for English (Sager, 1981).7 Some concern has also been voiced (Gardent and Plainfosse, 1990) about the termination conditions of this algorithm. &apos;Some programs may in fact be multi-directional, and therefore may have several &apos;inverses&apos; or &apos;modes&apos;. 6 Shieber et at. (1990) have shown that some recursive clauses cannot be executed using top-down evaluation thus motivating the use of a mixed top-down/bottom-up evaluation of their &apos;head-driven&apos; compilation. &apos;At present the grammar consists of 400i- productions. IN AND OUT ARGUMENTS IN LITERALS Literals in the gra</context>
</contexts>
<marker>Grishman, 1986</marker>
<rawString>Grishman, Ralph. 1986. Proteus Parser Reference Manual. Proteus Project Memorandum #4, Courant Institute of Mathematical Sciences, New York University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Koiti Hasida</author>
<author>Syun Isizaki</author>
</authors>
<title>Dependency Propagation: A Unified Theory of Sentence Comprehension and Generation.&amp;quot; IJCAI-87,</title>
<date>1987</date>
<pages>664--670</pages>
<location>Milano, Italy,</location>
<contexts>
<context position="3100" citStr="Hasida and Isizaki, 1987" startWordPosition="448" endWordPosition="451"> linguistic system, especially in machine translation, and in various interactive natural language systems where the direction of communication frequently changes. In this paper we are primarily interested in the computational aspects&apos; of reversibility that include bi-directional evaluation and dual compilation of computer grammars, inversion of parsers into efficient generators, and derivation of &amp;quot;generating-versions&amp;quot; of existing parsing algorithms. Some of the recent research in this area is reported in (Calder et al., 1989; Dymetman and Isabelle, 1988; Dymetman et al., 1990; Estival, 1990; Hasida and Isizaki, 1987; Ishizaki, 1990; Shieber, 1988; Shieber et al., 1990; Strzalkowski, 1990a-c; Strzalkowski and Peng, 1990; van Noord, 1990; and Wedekind, 1988). Dymetman and Isabelle (1988) describe a top-down interpreter for definite clause grammars that statically reorders clause literals according to a hand-coded specification, and further allows for dynamic selection of AND goals2 during execution, using the technique known as the goal freezing (Colmerauer, 1982; Naish, 1986). Shieber et al. (1990) propose a mixed top-down/bottom-up interpretation, in which certain goals, namely those whose expansion is d</context>
</contexts>
<marker>Hasida, Isizaki, 1987</marker>
<rawString>Hasida, Koiti, Syun Isizaki. 1987. &amp;quot;Dependency Propagation: A Unified Theory of Sentence Comprehension and Generation.&amp;quot; IJCAI-87, Milano, Italy, August 1987. pp. 664-670.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Masato Ishizaki</author>
</authors>
<title>A Bottom-up Generation for Principle-based Grammars Using Constraint Propagation.&amp;quot;</title>
<date>1990</date>
<volume>2</volume>
<pages>188--193</pages>
<location>COLING-90, Helsinki, Finland,</location>
<contexts>
<context position="3116" citStr="Ishizaki, 1990" startWordPosition="452" endWordPosition="453">ally in machine translation, and in various interactive natural language systems where the direction of communication frequently changes. In this paper we are primarily interested in the computational aspects&apos; of reversibility that include bi-directional evaluation and dual compilation of computer grammars, inversion of parsers into efficient generators, and derivation of &amp;quot;generating-versions&amp;quot; of existing parsing algorithms. Some of the recent research in this area is reported in (Calder et al., 1989; Dymetman and Isabelle, 1988; Dymetman et al., 1990; Estival, 1990; Hasida and Isizaki, 1987; Ishizaki, 1990; Shieber, 1988; Shieber et al., 1990; Strzalkowski, 1990a-c; Strzalkowski and Peng, 1990; van Noord, 1990; and Wedekind, 1988). Dymetman and Isabelle (1988) describe a top-down interpreter for definite clause grammars that statically reorders clause literals according to a hand-coded specification, and further allows for dynamic selection of AND goals2 during execution, using the technique known as the goal freezing (Colmerauer, 1982; Naish, 1986). Shieber et al. (1990) propose a mixed top-down/bottom-up interpretation, in which certain goals, namely those whose expansion is defined by the so</context>
</contexts>
<marker>Ishizaki, 1990</marker>
<rawString>Ishizaki, Masato. 1990. &amp;quot;A Bottom-up Generation for Principle-based Grammars Using Constraint Propagation.&amp;quot; COLING-90, Helsinki, Finland, August 1990. Vol 2, pp. 188-193.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Martin Kay</author>
</authors>
<title>Functional Unification Grammar: A Formalism for Machine Translation.&amp;quot;</title>
<date>1984</date>
<pages>75--78</pages>
<location>COLING-84, StanfOrd, CA,</location>
<contexts>
<context position="4038" citStr="Kay, 1984" startWordPosition="590" endWordPosition="591">allows for dynamic selection of AND goals2 during execution, using the technique known as the goal freezing (Colmerauer, 1982; Naish, 1986). Shieber et al. (1990) propose a mixed top-down/bottom-up interpretation, in which certain goals, namely those whose expansion is defined by the so-called &amp;quot;chain rules&amp;quot;,3 are not expanded during the top-down phase of the interpreter, but instead they are passed over until a nearest non-chain rule is reached. In the bottom-up phase the missing parts of the goal-expansion tree will be filled in by applying For linguistic aspects of reversible grammars, see (Kay, 1984; Landsbergen, 1987; Neuman, 1990; Steedman, 1987). 2 Literals on the right-hand side of a clause create AND goals; literals with the same predicate names on the left-hand sides of different clauses create OR goals. A chain rule is one where the main binding-carrying argument (the &amp;quot;head&amp;quot;) is passed unchanged from the left-hand side to the right. For example, assert(P) --&gt; subj(P1),verb(P2),obj(P1,P2,P), is a chain rule with respect to the argument P, assuming that P is the &apos;head&apos; argument 91 the chain rules in a backward manner. This technique, known as &apos;head-driven&apos; evaluation, can be applied</context>
</contexts>
<marker>Kay, 1984</marker>
<rawString>Kay, Martin. 1984. &amp;quot;Functional Unification Grammar: A Formalism for Machine Translation.&amp;quot; COLING-84, StanfOrd, CA, July 1984, pp. 75-78.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jan Landsbergen</author>
</authors>
<title>Montague Grammar and Machine Translation.&amp;quot;</title>
<date>1987</date>
<booktitle>Philips Research M.S.</booktitle>
<pages>14--026</pages>
<location>Eindhoven, Holland:</location>
<contexts>
<context position="4057" citStr="Landsbergen, 1987" startWordPosition="592" endWordPosition="593">dynamic selection of AND goals2 during execution, using the technique known as the goal freezing (Colmerauer, 1982; Naish, 1986). Shieber et al. (1990) propose a mixed top-down/bottom-up interpretation, in which certain goals, namely those whose expansion is defined by the so-called &amp;quot;chain rules&amp;quot;,3 are not expanded during the top-down phase of the interpreter, but instead they are passed over until a nearest non-chain rule is reached. In the bottom-up phase the missing parts of the goal-expansion tree will be filled in by applying For linguistic aspects of reversible grammars, see (Kay, 1984; Landsbergen, 1987; Neuman, 1990; Steedman, 1987). 2 Literals on the right-hand side of a clause create AND goals; literals with the same predicate names on the left-hand sides of different clauses create OR goals. A chain rule is one where the main binding-carrying argument (the &amp;quot;head&amp;quot;) is passed unchanged from the left-hand side to the right. For example, assert(P) --&gt; subj(P1),verb(P2),obj(P1,P2,P), is a chain rule with respect to the argument P, assuming that P is the &apos;head&apos; argument 91 the chain rules in a backward manner. This technique, known as &apos;head-driven&apos; evaluation, can be applied quite profitably t</context>
</contexts>
<marker>Landsbergen, 1987</marker>
<rawString>Landsbergen, Jan. 1987. &amp;quot;Montague Grammar and Machine Translation.&amp;quot; Eindhoven, Holland: Philips Research M.S. 14.026.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lee Naish</author>
</authors>
<title>Negation and Control in PROLOG.</title>
<date>1986</date>
<journal>Lecture Notes in Computer Science,</journal>
<volume>238</volume>
<publisher>Springer.</publisher>
<contexts>
<context position="3568" citStr="Naish, 1986" startWordPosition="517" endWordPosition="518">ch in this area is reported in (Calder et al., 1989; Dymetman and Isabelle, 1988; Dymetman et al., 1990; Estival, 1990; Hasida and Isizaki, 1987; Ishizaki, 1990; Shieber, 1988; Shieber et al., 1990; Strzalkowski, 1990a-c; Strzalkowski and Peng, 1990; van Noord, 1990; and Wedekind, 1988). Dymetman and Isabelle (1988) describe a top-down interpreter for definite clause grammars that statically reorders clause literals according to a hand-coded specification, and further allows for dynamic selection of AND goals2 during execution, using the technique known as the goal freezing (Colmerauer, 1982; Naish, 1986). Shieber et al. (1990) propose a mixed top-down/bottom-up interpretation, in which certain goals, namely those whose expansion is defined by the so-called &amp;quot;chain rules&amp;quot;,3 are not expanded during the top-down phase of the interpreter, but instead they are passed over until a nearest non-chain rule is reached. In the bottom-up phase the missing parts of the goal-expansion tree will be filled in by applying For linguistic aspects of reversible grammars, see (Kay, 1984; Landsbergen, 1987; Neuman, 1990; Steedman, 1987). 2 Literals on the right-hand side of a clause create AND goals; literals with </context>
</contexts>
<marker>Naish, 1986</marker>
<rawString>Naish, Lee. 1986. Negation and Control in PROLOG. Lecture Notes in Computer Science, 238, Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Newman</author>
</authors>
<title>Towards Convenient BiDirectional Grammar Formalisms.&amp;quot; COLING-90,</title>
<date>1990</date>
<volume>2</volume>
<pages>294--298</pages>
<location>Helsinki, Finland,</location>
<marker>Newman, 1990</marker>
<rawString>Newman, P. 1990. &amp;quot;Towards Convenient BiDirectional Grammar Formalisms.&amp;quot; COLING-90, Helsinki, Finland, August 1990. Vol. 2, pp. 294-298.</rawString>
</citation>
<citation valid="false">
<authors>
<author>forthcoming</author>
</authors>
<title>A Japanese/English Reversible Machine Translation System With Sublanguage Approach.&amp;quot;</title>
<booktitle>Courant Institute of Mathematical Sciences,</booktitle>
<location>New York University.</location>
<marker>forthcoming, </marker>
<rawString>Peng, Ping. forthcoming. &amp;quot;A Japanese/English Reversible Machine Translation System With Sublanguage Approach.&amp;quot; Courant Institute of Mathematical Sciences, New York University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ping Peng</author>
<author>Tomek Strzalkowski</author>
</authors>
<title>An Implementation of a Reversible Grammar.&amp;quot;</title>
<date>1990</date>
<booktitle>Proc. 8th Canadiari: Conf on Artificial Intelligence,</booktitle>
<pages>121--127</pages>
<location>Ottawa, Canada,</location>
<marker>Peng, Strzalkowski, 1990</marker>
<rawString>Peng, Ping and Tomek Strzalkowski. 1990. &amp;quot;An Implementation of a Reversible Grammar.&amp;quot; Proc. 8th Canadiari: Conf on Artificial Intelligence, Ottawa, Canada, June 1990. pp. 121-127.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Naomi Sager</author>
</authors>
<title>Natural Language Information Processing.</title>
<date>1981</date>
<publisher>Addison-Wesley.</publisher>
<contexts>
<context position="6483" citStr="Sager, 1981" startWordPosition="976" endWordPosition="977">so shown to deal adequately with recursive clauses that created problems in purely top-down compilation.6 The inter-clausal inversion procedure discussed here effects global changes in goal ordering by moving selected goals between clauses and even creating new clauses. The net effect is similar to that achieved in the head-driven evaluation, except that no explicit concept of &apos;head&apos; or &apos;chain-rule&apos; is used. The algorithm has been tested on a substantial coverage PROLOG grammar for English derived form the PROTEUS Parser Grammar (Grishman, 1986), and the Linguistic String Grammar for English (Sager, 1981).7 Some concern has also been voiced (Gardent and Plainfosse, 1990) about the termination conditions of this algorithm. &apos;Some programs may in fact be multi-directional, and therefore may have several &apos;inverses&apos; or &apos;modes&apos;. 6 Shieber et at. (1990) have shown that some recursive clauses cannot be executed using top-down evaluation thus motivating the use of a mixed top-down/bottom-up evaluation of their &apos;head-driven&apos; compilation. &apos;At present the grammar consists of 400i- productions. IN AND OUT ARGUMENTS IN LITERALS Literals in the grammar clauses can be marked for the &amp;quot;modes&amp;quot; in which they are </context>
</contexts>
<marker>Sager, 1981</marker>
<rawString>Sager, Naomi. 1981. Natural Language Information Processing. Addison-Wesley.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart Shieber</author>
<author>M</author>
</authors>
<title>A uniform architecture for parsing and generation.&amp;quot; COLING-88,</title>
<date>1988</date>
<pages>614--619</pages>
<location>Budapest, Hungary,</location>
<marker>Shieber, M, 1988</marker>
<rawString>Shieber, Stuart, M. 1988. &amp;quot;A uniform architecture for parsing and generation.&amp;quot; COLING-88, Budapest, Hungary, August 1988, pp. 614-619.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart Shieber</author>
<author>Gertjan van Noord M</author>
<author>Robert C Moore</author>
<author>Fernando C N Pereira</author>
</authors>
<title>A Semantic-Head-Driven Generation.&amp;quot;</title>
<date>1990</date>
<journal>Computational Linguistics,</journal>
<volume>16</volume>
<issue>1</issue>
<pages>30--42</pages>
<publisher>MIT Press.</publisher>
<contexts>
<context position="3153" citStr="Shieber et al., 1990" startWordPosition="456" endWordPosition="459">d in various interactive natural language systems where the direction of communication frequently changes. In this paper we are primarily interested in the computational aspects&apos; of reversibility that include bi-directional evaluation and dual compilation of computer grammars, inversion of parsers into efficient generators, and derivation of &amp;quot;generating-versions&amp;quot; of existing parsing algorithms. Some of the recent research in this area is reported in (Calder et al., 1989; Dymetman and Isabelle, 1988; Dymetman et al., 1990; Estival, 1990; Hasida and Isizaki, 1987; Ishizaki, 1990; Shieber, 1988; Shieber et al., 1990; Strzalkowski, 1990a-c; Strzalkowski and Peng, 1990; van Noord, 1990; and Wedekind, 1988). Dymetman and Isabelle (1988) describe a top-down interpreter for definite clause grammars that statically reorders clause literals according to a hand-coded specification, and further allows for dynamic selection of AND goals2 during execution, using the technique known as the goal freezing (Colmerauer, 1982; Naish, 1986). Shieber et al. (1990) propose a mixed top-down/bottom-up interpretation, in which certain goals, namely those whose expansion is defined by the so-called &amp;quot;chain rules&amp;quot;,3 are not expan</context>
<context position="4938" citStr="Shieber et al, 1990" startWordPosition="733" endWordPosition="736">e &amp;quot;head&amp;quot;) is passed unchanged from the left-hand side to the right. For example, assert(P) --&gt; subj(P1),verb(P2),obj(P1,P2,P), is a chain rule with respect to the argument P, assuming that P is the &apos;head&apos; argument 91 the chain rules in a backward manner. This technique, known as &apos;head-driven&apos; evaluation, can be applied quite profitably to various grammar compilation tasks, including the inverse computation, but it requires that the underlying grammar is given in a form where the information about the semantic heads in nonterminals is made explicit. In addition, the procedure, as described in (Shieber et al, 1990), makes no attempt to impose a proper ordering of the &amp;quot;nonchain&amp;quot; goals, which may have an adverse effect on the generator efficiency.4 The grammar inversion method described in this paper transforms one set of PROLOG clauses (representing a parser, eg.) into another set of clauses (representing a generator) using an off-line compilation process. The generator is thus just another PROLOG program that has the property of being an inverse of the parser program, that is, it performs inverse computation.5 A unification grammar is normally compiled into PROLOG to obtain an executable program (usuall</context>
<context position="21816" citStr="Shieber et al., 1990" startWordPosition="3802" endWordPosition="3805">nts; quit if no further progress is possible.16 Invert the series with Awolumm 2, obtaining a strongly ordered series &lt;X&apos;, • • • Y&apos;,&gt; such that Replace V, with r, in mi,„ and add the resulting set to At this point we may consider a specific linguistic example involving a generalized left-recursive production based on a properly ordered series.I7 [1] sent (V 1,V 3,Sem) np (V1 ,V2,Ssem), vp(V2,V3,[Ssem],Sem). [2] vp (V1 ,V3,Args,Vsem) vp (V1 ,V2,[Csem I Args],Vsem), np(V2,V3,Csem). &amp;quot;As in step (213) we have to maintain the minimality of This example is loosely based on the grammar described in (Shieber et al., 1990). 95 [3] vp (V1 ,V2,Args,Vsem) :— v (V1 ,V2,Args,Vsem). [4] v (V1 ,V2 ,(Obj,Subj ],chased (Subj,Obj)) chased (V1 ,V2). [5] chased ([chased IX ],X). [6] np ([john IX ],X,john). [7] np ([fido IX ],X ,fido). We concentrate here on the clause [2], and note that there are three argument series between the vp literals: &lt; V/ , V/ &gt;, &lt;Args, [Csem I Args ]&gt;, and &lt;Vsem,Vsem &gt; , of which only the second one is invertible. We also note that in clause [3], the collection of MSEAs for vp include ( V/ ) and (Vsem), where V1 represents the surface string, and Vsem its &amp;quot;semantics&amp;quot;. When we use this grammar for</context>
<context position="32674" citStr="Shieber et al. (1990)" startWordPosition="5668" endWordPosition="5671">uses [1&apos;] to [31 above. CONCLUSIONS We described a general method for inversion of logic grammars that transforms a parser into an efficient generator using an off-line compilation process that manipulates parser&apos;s clauses. The resulting &amp;quot;inverted-parser&amp;quot; generator behaves as if it was &amp;quot;parsing&amp;quot; a structured representation translating it into a well-formed linguistic string. The augmented grammar compilation procedure presented here is already quite general: it appears to subsume both the static compilation procedure of Strzalkowski (1990c), and the head-driven grammar evaluation technique of Shieber et al. (1990). The process of grammar inversion is logically divided into two stages: (a) computing the collections of minimal sets of essential arguments (MSEAs) in predicates, and (b) rearranging the order of goals in the grammar so that at least one active MSEA is &amp;quot;in&amp;quot; in every literal when its expansion is attempted. The first stage also includes computing the &amp;quot;in&amp;quot; and &amp;quot;out&amp;quot; arguments. In the second stage, the goal inversion process is initialized by the procedure INVERSE, which recursively reorders goals on the right-hand sides of clauses to meet the MSEA-binding requirement. Deadlocked clauses which </context>
</contexts>
<marker>Shieber, M, Moore, Pereira, 1990</marker>
<rawString>Shieber, Stuart, M., Gertjan van Noord, Robert C. Moore, Fernando C. N. Pereira. 1990. &amp;quot;A Semantic-Head-Driven Generation.&amp;quot; Computational Linguistics, 16(1), pp. 30-42. MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Steedman</author>
</authors>
<title>Combinatory Grammars and Parasitic Gaps.&amp;quot;</title>
<date>1987</date>
<journal>Natural Language and Linguistic Theory,</journal>
<volume>5</volume>
<pages>403--439</pages>
<contexts>
<context position="4088" citStr="Steedman, 1987" startWordPosition="596" endWordPosition="597">uring execution, using the technique known as the goal freezing (Colmerauer, 1982; Naish, 1986). Shieber et al. (1990) propose a mixed top-down/bottom-up interpretation, in which certain goals, namely those whose expansion is defined by the so-called &amp;quot;chain rules&amp;quot;,3 are not expanded during the top-down phase of the interpreter, but instead they are passed over until a nearest non-chain rule is reached. In the bottom-up phase the missing parts of the goal-expansion tree will be filled in by applying For linguistic aspects of reversible grammars, see (Kay, 1984; Landsbergen, 1987; Neuman, 1990; Steedman, 1987). 2 Literals on the right-hand side of a clause create AND goals; literals with the same predicate names on the left-hand sides of different clauses create OR goals. A chain rule is one where the main binding-carrying argument (the &amp;quot;head&amp;quot;) is passed unchanged from the left-hand side to the right. For example, assert(P) --&gt; subj(P1),verb(P2),obj(P1,P2,P), is a chain rule with respect to the argument P, assuming that P is the &apos;head&apos; argument 91 the chain rules in a backward manner. This technique, known as &apos;head-driven&apos; evaluation, can be applied quite profitably to various grammar compilation t</context>
</contexts>
<marker>Steedman, 1987</marker>
<rawString>Steedman, Mark. 1987. &amp;quot;Combinatory Grammars and Parasitic Gaps.&amp;quot; Natural Language and Linguistic Theory, 5, pp. 403-439.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tomek Strzalkowski</author>
</authors>
<title>Automated Inversion of a Unification Parser into a Unification Generator.</title>
<date>1989</date>
<tech>Technical Report 465,</tech>
<institution>Department of Computer Science, Courant Institute of Mathematical Sciences, New York University.</institution>
<contexts>
<context position="8339" citStr="Strzalkowski, 1989" startWordPosition="1282" endWordPosition="1283">ubject phrase, and P is the final translation. When the grammar is used for parsing, the &amp;quot;in&amp;quot; argument is Al; the &amp;quot;out&amp;quot; arguments are A2, NUM and P; when it is used for generation, the &amp;quot;in&amp;quot; argument is P; the &amp;quot;out&amp;quot; arguments are Al and NUM. In generation, A2 is neither &amp;quot;in&amp;quot; nor &amp;quot;out&amp;quot;. &amp;quot;In&amp;quot; and &amp;quot;out&amp;quot; status of arguments in a PROLOG program can be computed statically at compile time. The general algorithm has been described in (Strzalkowski, 1990c; Strzalkowski and Peng, 1990), ESSENTIAL ARGUMENTS: AN EXTENSION The notion of an essential argument in a PROWG literal has been first introduced in (Strzalkowski, 1989), and subsequently extended in (Strzalkowski, 1990bc; Strzalkowski and Peng, 1990). In short, X is an essential argument in a literal p ( • • X • ) if X is required to be &amp;quot;in&amp;quot; for a successful evaluation of this literal. By a successful evaluation of a literal we mean here the execution that is guaranteed to stop, and moreover, that will proceed along an optimal path. For instance, an evaluation of the goal mem (a,L), with an intention to find a list L of which a is a member, leads to a non-terminating execution unless L&apos;s value is known. Likewise, a request to generate a main verb in a senten</context>
<context position="12341" citStr="Strzalkowski, 1989" startWordPosition="2023" endWordPosition="2024"> certain types of recursive definitions. Consider, for example, the problem of assigning the set of MSEA&apos;s to mem(Elem,List), where mem (list membership) is defined as follows: mem (Elem, [First !List]) :— mem (Elem,List). mem (Elem, [Elem !List]). The MSEAS procedure assigns MS =f (Elem),(List)), we note however, that the first argument of mem cannot alone control the recursion in the first clause since the right-hand side (rhs) literal would repeatedly unify with the clause head, thus causing infinite recursion. This consideration excludes (Elem) from the list of possible MSEAs for mem. In (Strzalkowski, 1989) we introduced the directed relation always unifiable among terms, which was informally characterized as follows. A term X is always unifiable with term Y if they unify regardless of any bindings that may occur in X, providing that variables in X and Y are standardized apart, and that Y remains unchanged. According to this definition any term is always unifiable with a variable, while the opposite is not necessarily true. For example, the variable X is not always unifiable with the functional term f(Y) because binding X with g(Z) will make these two terms non-unifiable. This relation can be fo</context>
</contexts>
<marker>Strzalkowski, 1989</marker>
<rawString>Strzalkowski, Tomek. 1989. Automated Inversion of a Unification Parser into a Unification Generator. Technical Report 465, Department of Computer Science, Courant Institute of Mathematical Sciences, New York University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tomek Strzalkowski</author>
</authors>
<title>An algorithm for inverting a unification grammar into an efficient unification generator.&amp;quot;</title>
<date>1990</date>
<journal>Applied Mathematics Letters,</journal>
<volume>3</volume>
<issue>1</issue>
<pages>93--96</pages>
<publisher>Pergamon Press.</publisher>
<contexts>
<context position="3173" citStr="Strzalkowski, 1990" startWordPosition="460" endWordPosition="461">ve natural language systems where the direction of communication frequently changes. In this paper we are primarily interested in the computational aspects&apos; of reversibility that include bi-directional evaluation and dual compilation of computer grammars, inversion of parsers into efficient generators, and derivation of &amp;quot;generating-versions&amp;quot; of existing parsing algorithms. Some of the recent research in this area is reported in (Calder et al., 1989; Dymetman and Isabelle, 1988; Dymetman et al., 1990; Estival, 1990; Hasida and Isizaki, 1987; Ishizaki, 1990; Shieber, 1988; Shieber et al., 1990; Strzalkowski, 1990a-c; Strzalkowski and Peng, 1990; van Noord, 1990; and Wedekind, 1988). Dymetman and Isabelle (1988) describe a top-down interpreter for definite clause grammars that statically reorders clause literals according to a hand-coded specification, and further allows for dynamic selection of AND goals2 during execution, using the technique known as the goal freezing (Colmerauer, 1982; Naish, 1986). Shieber et al. (1990) propose a mixed top-down/bottom-up interpretation, in which certain goals, namely those whose expansion is defined by the so-called &amp;quot;chain rules&amp;quot;,3 are not expanded during the top-d</context>
<context position="8168" citStr="Strzalkowski, 1990" startWordPosition="1255" endWordPosition="1257"> in concat(X,Y4a,b,c,d1). In the literal subject(Al ,A2.NUM,P), taken from an English grammar, Al and A2 are input and output strings of words, NUM is the number of the subject phrase, and P is the final translation. When the grammar is used for parsing, the &amp;quot;in&amp;quot; argument is Al; the &amp;quot;out&amp;quot; arguments are A2, NUM and P; when it is used for generation, the &amp;quot;in&amp;quot; argument is P; the &amp;quot;out&amp;quot; arguments are Al and NUM. In generation, A2 is neither &amp;quot;in&amp;quot; nor &amp;quot;out&amp;quot;. &amp;quot;In&amp;quot; and &amp;quot;out&amp;quot; status of arguments in a PROLOG program can be computed statically at compile time. The general algorithm has been described in (Strzalkowski, 1990c; Strzalkowski and Peng, 1990), ESSENTIAL ARGUMENTS: AN EXTENSION The notion of an essential argument in a PROWG literal has been first introduced in (Strzalkowski, 1989), and subsequently extended in (Strzalkowski, 1990bc; Strzalkowski and Peng, 1990). In short, X is an essential argument in a literal p ( • • X • ) if X is required to be &amp;quot;in&amp;quot; for a successful evaluation of this literal. By a successful evaluation of a literal we mean here the execution that is guaranteed to stop, and moreover, that will proceed along an optimal path. For instance, an evaluation of the goal mem (a,L), with an</context>
<context position="11070" citStr="Strzalkowski, 1990" startWordPosition="1803" endWordPosition="1804">inct minimal size sets v, c VP such that whenever the arguments in v, are &amp;quot;in&amp;quot;, then the arguments in Ki are &amp;quot;out&amp;quot;. If such v,&apos;s exist, then for every v, do: (i) assumeiv, is &amp;quot;in&amp;quot; in p; (ii) compute the set OUTo, of &amp;quot;out&amp;quot; arguments in all literals from r1 to r1; (iii) call (c) otherwise, if no such v, exist, MS; := 0. (5) Compute MS := j=1..r &apos;Active MSEA&apos;s are those existing with a given definition of a predicate. Other, non-active MSEA&apos;s can be activated when the clauses making up this definition are altered in some way. The procedure can be straightforwardly augmented to compute all MSEAs (Strzalkowski, 1990c). &apos;For i =1 the sets of essential arguments are selected so as to minimize the number of possible solutions to I. As a simple example consider the following clause: sent(P) vp(N,P),np(N). Assuming that MSEA&apos;S for vp and np are (P) and (N), respectively, and that N is &amp;quot;out&amp;quot; in vp, we can easily compute that (P) is the MSEA in sent. To see it, we note that MRUI for vp is ((P)) and, therefore, that 111.1 = (P). Next, we note that MRU2 for np is ((N)), and since OUTLI from vp is (N), we obtain that L2.1 = 0, and subsequently that (P) is the only MSEA in sent. The procedure presented above is suf</context>
<context position="15469" citStr="Strzalkowski, 1990" startWordPosition="2618" endWordPosition="2619">i are arguments to rii, that is, rii(- • XJ,Y • -), such that if Xi is &amp;quot;in&amp;quot; then Yi is &amp;quot;out&amp;quot; 12; and (4) for every j43 • • k, either Xi.0=Y1 or X1.414 (Yi) or Yi=f ()Cf.&amp;quot;), where f (X) denotes a term containing a subterm X. Note that this definition already ensures that the argument series obtained between X0 and Xk+1 is the shortest one. As an example, consider the following clauses: &amp;quot; A similar concept of guide-structure is introduced in (Dymetman et al., 1990), however the ordered series is less restrictive and covers a larger class of recursive programs. 12 Yi may be partially &amp;quot;out&amp;quot;; see (Strzalkowski, 1990c) for the definition of delayed &amp;quot;out&amp;quot; status. vp (X) :— np (X ,Y),vp (Y). np(f (X),X). Assuming that the argument X in the literal vp (X) on the left-hand side (lhs) of the first clause is &amp;quot;in&amp;quot;, we can easily check that &lt;X,X,Y,Y&gt; constitutes an argument series between arguments of vp in the first clause. DEFINITION 2 (weakly ordered series)13 An argument series &lt;Y0,X1,Y1, • • • ,Xk,YkXk.i&gt; in the clause p :—ri • r„ is weakly ordered iff Y05*X1,4.1 [or Xk.4.15*Y0], where 5* is a closure of 5_ defined as follows: (1) for every i=1 • • k, such that r.(&amp;quot; • Xi,Yi • • ) there exists a clause rii( •</context>
<context position="25502" citStr="Strzalkowski, 1990" startWordPosition="4447" endWordPosition="4448"> a way that at least one of its MSEAs is &amp;quot;in&amp;quot;. If this &amp;quot;in&amp;quot; MSEA is not an active one, recursively invert clauses defining the goal&apos;s predicate so as to make the MSEA become active. In a basic formulation of the inversion algorithm the movement of goals in step (3) is confined to be within the right-hand sides of program clauses, that is, goals cannot be moved between clauses. The inversion process proceeds top-down, starting with the top-level clause, for example parse (String,Sem) :— sent (String, [],Sem). The restricted movement inversion algorithm INVERSE has been documented in detail in (Strzalkowski, 1990ac). It is demonstrated here on the following clause taken from a parser program, and which recognizes yes-no questions: yesnoq (Al ,A4,P) :— verb (Al ,A2,Num,P2), subject (A2,A3,Num,P1), object (A3 ,A4,P 1 ,P2,P). When rewriting this clause for generation, we would place object first (it has P &amp;quot;in&amp;quot;, and A3, PI, P2 &amp;quot;out&amp;quot;), then subject (it has the essential PI &amp;quot;in&amp;quot;, and A2 and Num &amp;quot;out&amp;quot;), and finally verb (its MSEA is either (Al) or (Num,P2), the latter being completely &amp;quot;in&amp;quot; now). The net effect is the following generator clause:&amp;quot; yesnoq (Al ,A4,P) :— object (A3 ,A4 ,P 1 ,P2,P), subject (A2,A3</context>
<context position="32597" citStr="Strzalkowski (1990" startWordPosition="5659" endWordPosition="5660">on goals. Remove superfluous arguments in literals. The result are the clauses [1&apos;] to [31 above. CONCLUSIONS We described a general method for inversion of logic grammars that transforms a parser into an efficient generator using an off-line compilation process that manipulates parser&apos;s clauses. The resulting &amp;quot;inverted-parser&amp;quot; generator behaves as if it was &amp;quot;parsing&amp;quot; a structured representation translating it into a well-formed linguistic string. The augmented grammar compilation procedure presented here is already quite general: it appears to subsume both the static compilation procedure of Strzalkowski (1990c), and the head-driven grammar evaluation technique of Shieber et al. (1990). The process of grammar inversion is logically divided into two stages: (a) computing the collections of minimal sets of essential arguments (MSEAs) in predicates, and (b) rearranging the order of goals in the grammar so that at least one active MSEA is &amp;quot;in&amp;quot; in every literal when its expansion is attempted. The first stage also includes computing the &amp;quot;in&amp;quot; and &amp;quot;out&amp;quot; arguments. In the second stage, the goal inversion process is initialized by the procedure INVERSE, which recursively reorders goals on the right-hand sid</context>
</contexts>
<marker>Strzalkowski, 1990</marker>
<rawString>Strzalkowski, Tomek. 1990a. &amp;quot;An algorithm for inverting a unification grammar into an efficient unification generator.&amp;quot; Applied Mathematics Letters, 3(1), pp. 93-96. Pergamon Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tomek Strzalkowski</author>
</authors>
<date>1990</date>
<note>How to Invert</note>
<contexts>
<context position="3173" citStr="Strzalkowski, 1990" startWordPosition="460" endWordPosition="461">ve natural language systems where the direction of communication frequently changes. In this paper we are primarily interested in the computational aspects&apos; of reversibility that include bi-directional evaluation and dual compilation of computer grammars, inversion of parsers into efficient generators, and derivation of &amp;quot;generating-versions&amp;quot; of existing parsing algorithms. Some of the recent research in this area is reported in (Calder et al., 1989; Dymetman and Isabelle, 1988; Dymetman et al., 1990; Estival, 1990; Hasida and Isizaki, 1987; Ishizaki, 1990; Shieber, 1988; Shieber et al., 1990; Strzalkowski, 1990a-c; Strzalkowski and Peng, 1990; van Noord, 1990; and Wedekind, 1988). Dymetman and Isabelle (1988) describe a top-down interpreter for definite clause grammars that statically reorders clause literals according to a hand-coded specification, and further allows for dynamic selection of AND goals2 during execution, using the technique known as the goal freezing (Colmerauer, 1982; Naish, 1986). Shieber et al. (1990) propose a mixed top-down/bottom-up interpretation, in which certain goals, namely those whose expansion is defined by the so-called &amp;quot;chain rules&amp;quot;,3 are not expanded during the top-d</context>
<context position="8168" citStr="Strzalkowski, 1990" startWordPosition="1255" endWordPosition="1257"> in concat(X,Y4a,b,c,d1). In the literal subject(Al ,A2.NUM,P), taken from an English grammar, Al and A2 are input and output strings of words, NUM is the number of the subject phrase, and P is the final translation. When the grammar is used for parsing, the &amp;quot;in&amp;quot; argument is Al; the &amp;quot;out&amp;quot; arguments are A2, NUM and P; when it is used for generation, the &amp;quot;in&amp;quot; argument is P; the &amp;quot;out&amp;quot; arguments are Al and NUM. In generation, A2 is neither &amp;quot;in&amp;quot; nor &amp;quot;out&amp;quot;. &amp;quot;In&amp;quot; and &amp;quot;out&amp;quot; status of arguments in a PROLOG program can be computed statically at compile time. The general algorithm has been described in (Strzalkowski, 1990c; Strzalkowski and Peng, 1990), ESSENTIAL ARGUMENTS: AN EXTENSION The notion of an essential argument in a PROWG literal has been first introduced in (Strzalkowski, 1989), and subsequently extended in (Strzalkowski, 1990bc; Strzalkowski and Peng, 1990). In short, X is an essential argument in a literal p ( • • X • ) if X is required to be &amp;quot;in&amp;quot; for a successful evaluation of this literal. By a successful evaluation of a literal we mean here the execution that is guaranteed to stop, and moreover, that will proceed along an optimal path. For instance, an evaluation of the goal mem (a,L), with an</context>
<context position="11070" citStr="Strzalkowski, 1990" startWordPosition="1803" endWordPosition="1804">inct minimal size sets v, c VP such that whenever the arguments in v, are &amp;quot;in&amp;quot;, then the arguments in Ki are &amp;quot;out&amp;quot;. If such v,&apos;s exist, then for every v, do: (i) assumeiv, is &amp;quot;in&amp;quot; in p; (ii) compute the set OUTo, of &amp;quot;out&amp;quot; arguments in all literals from r1 to r1; (iii) call (c) otherwise, if no such v, exist, MS; := 0. (5) Compute MS := j=1..r &apos;Active MSEA&apos;s are those existing with a given definition of a predicate. Other, non-active MSEA&apos;s can be activated when the clauses making up this definition are altered in some way. The procedure can be straightforwardly augmented to compute all MSEAs (Strzalkowski, 1990c). &apos;For i =1 the sets of essential arguments are selected so as to minimize the number of possible solutions to I. As a simple example consider the following clause: sent(P) vp(N,P),np(N). Assuming that MSEA&apos;S for vp and np are (P) and (N), respectively, and that N is &amp;quot;out&amp;quot; in vp, we can easily compute that (P) is the MSEA in sent. To see it, we note that MRUI for vp is ((P)) and, therefore, that 111.1 = (P). Next, we note that MRU2 for np is ((N)), and since OUTLI from vp is (N), we obtain that L2.1 = 0, and subsequently that (P) is the only MSEA in sent. The procedure presented above is suf</context>
<context position="15469" citStr="Strzalkowski, 1990" startWordPosition="2618" endWordPosition="2619">i are arguments to rii, that is, rii(- • XJ,Y • -), such that if Xi is &amp;quot;in&amp;quot; then Yi is &amp;quot;out&amp;quot; 12; and (4) for every j43 • • k, either Xi.0=Y1 or X1.414 (Yi) or Yi=f ()Cf.&amp;quot;), where f (X) denotes a term containing a subterm X. Note that this definition already ensures that the argument series obtained between X0 and Xk+1 is the shortest one. As an example, consider the following clauses: &amp;quot; A similar concept of guide-structure is introduced in (Dymetman et al., 1990), however the ordered series is less restrictive and covers a larger class of recursive programs. 12 Yi may be partially &amp;quot;out&amp;quot;; see (Strzalkowski, 1990c) for the definition of delayed &amp;quot;out&amp;quot; status. vp (X) :— np (X ,Y),vp (Y). np(f (X),X). Assuming that the argument X in the literal vp (X) on the left-hand side (lhs) of the first clause is &amp;quot;in&amp;quot;, we can easily check that &lt;X,X,Y,Y&gt; constitutes an argument series between arguments of vp in the first clause. DEFINITION 2 (weakly ordered series)13 An argument series &lt;Y0,X1,Y1, • • • ,Xk,YkXk.i&gt; in the clause p :—ri • r„ is weakly ordered iff Y05*X1,4.1 [or Xk.4.15*Y0], where 5* is a closure of 5_ defined as follows: (1) for every i=1 • • k, such that r.(&amp;quot; • Xi,Yi • • ) there exists a clause rii( •</context>
<context position="25502" citStr="Strzalkowski, 1990" startWordPosition="4447" endWordPosition="4448"> a way that at least one of its MSEAs is &amp;quot;in&amp;quot;. If this &amp;quot;in&amp;quot; MSEA is not an active one, recursively invert clauses defining the goal&apos;s predicate so as to make the MSEA become active. In a basic formulation of the inversion algorithm the movement of goals in step (3) is confined to be within the right-hand sides of program clauses, that is, goals cannot be moved between clauses. The inversion process proceeds top-down, starting with the top-level clause, for example parse (String,Sem) :— sent (String, [],Sem). The restricted movement inversion algorithm INVERSE has been documented in detail in (Strzalkowski, 1990ac). It is demonstrated here on the following clause taken from a parser program, and which recognizes yes-no questions: yesnoq (Al ,A4,P) :— verb (Al ,A2,Num,P2), subject (A2,A3,Num,P1), object (A3 ,A4,P 1 ,P2,P). When rewriting this clause for generation, we would place object first (it has P &amp;quot;in&amp;quot;, and A3, PI, P2 &amp;quot;out&amp;quot;), then subject (it has the essential PI &amp;quot;in&amp;quot;, and A2 and Num &amp;quot;out&amp;quot;), and finally verb (its MSEA is either (Al) or (Num,P2), the latter being completely &amp;quot;in&amp;quot; now). The net effect is the following generator clause:&amp;quot; yesnoq (Al ,A4,P) :— object (A3 ,A4 ,P 1 ,P2,P), subject (A2,A3</context>
<context position="32597" citStr="Strzalkowski (1990" startWordPosition="5659" endWordPosition="5660">on goals. Remove superfluous arguments in literals. The result are the clauses [1&apos;] to [31 above. CONCLUSIONS We described a general method for inversion of logic grammars that transforms a parser into an efficient generator using an off-line compilation process that manipulates parser&apos;s clauses. The resulting &amp;quot;inverted-parser&amp;quot; generator behaves as if it was &amp;quot;parsing&amp;quot; a structured representation translating it into a well-formed linguistic string. The augmented grammar compilation procedure presented here is already quite general: it appears to subsume both the static compilation procedure of Strzalkowski (1990c), and the head-driven grammar evaluation technique of Shieber et al. (1990). The process of grammar inversion is logically divided into two stages: (a) computing the collections of minimal sets of essential arguments (MSEAs) in predicates, and (b) rearranging the order of goals in the grammar so that at least one active MSEA is &amp;quot;in&amp;quot; in every literal when its expansion is attempted. The first stage also includes computing the &amp;quot;in&amp;quot; and &amp;quot;out&amp;quot; arguments. In the second stage, the goal inversion process is initialized by the procedure INVERSE, which recursively reorders goals on the right-hand sid</context>
</contexts>
<marker>Strzalkowski, 1990</marker>
<rawString>Strzalkowski, Tomek. 1990b. &amp;quot;How to Invert</rawString>
</citation>
<citation valid="true">
<title>a Parser into an Efficient Generator an algorithm for logic grammars.&amp;quot; COLING-90,</title>
<date>1990</date>
<volume>2</volume>
<pages>347--352</pages>
<location>Helsinki, Finland,</location>
<contexts>
<context position="3591" citStr="(1990)" startWordPosition="522" endWordPosition="522">n (Calder et al., 1989; Dymetman and Isabelle, 1988; Dymetman et al., 1990; Estival, 1990; Hasida and Isizaki, 1987; Ishizaki, 1990; Shieber, 1988; Shieber et al., 1990; Strzalkowski, 1990a-c; Strzalkowski and Peng, 1990; van Noord, 1990; and Wedekind, 1988). Dymetman and Isabelle (1988) describe a top-down interpreter for definite clause grammars that statically reorders clause literals according to a hand-coded specification, and further allows for dynamic selection of AND goals2 during execution, using the technique known as the goal freezing (Colmerauer, 1982; Naish, 1986). Shieber et al. (1990) propose a mixed top-down/bottom-up interpretation, in which certain goals, namely those whose expansion is defined by the so-called &amp;quot;chain rules&amp;quot;,3 are not expanded during the top-down phase of the interpreter, but instead they are passed over until a nearest non-chain rule is reached. In the bottom-up phase the missing parts of the goal-expansion tree will be filled in by applying For linguistic aspects of reversible grammars, see (Kay, 1984; Landsbergen, 1987; Neuman, 1990; Steedman, 1987). 2 Literals on the right-hand side of a clause create AND goals; literals with the same predicate name</context>
<context position="6729" citStr="(1990)" startWordPosition="1016" endWordPosition="1016">ating new clauses. The net effect is similar to that achieved in the head-driven evaluation, except that no explicit concept of &apos;head&apos; or &apos;chain-rule&apos; is used. The algorithm has been tested on a substantial coverage PROLOG grammar for English derived form the PROTEUS Parser Grammar (Grishman, 1986), and the Linguistic String Grammar for English (Sager, 1981).7 Some concern has also been voiced (Gardent and Plainfosse, 1990) about the termination conditions of this algorithm. &apos;Some programs may in fact be multi-directional, and therefore may have several &apos;inverses&apos; or &apos;modes&apos;. 6 Shieber et at. (1990) have shown that some recursive clauses cannot be executed using top-down evaluation thus motivating the use of a mixed top-down/bottom-up evaluation of their &apos;head-driven&apos; compilation. &apos;At present the grammar consists of 400i- productions. IN AND OUT ARGUMENTS IN LITERALS Literals in the grammar clauses can be marked for the &amp;quot;modes&amp;quot; in which they are used. When a literal is submitted to execution then those of its arguments which are bound at that time are called the &amp;quot;in&amp;quot; arguments. After the computation is complete, some of the previously unbound arguments may become bound; these are called </context>
<context position="32674" citStr="(1990)" startWordPosition="5671" endWordPosition="5671">1 above. CONCLUSIONS We described a general method for inversion of logic grammars that transforms a parser into an efficient generator using an off-line compilation process that manipulates parser&apos;s clauses. The resulting &amp;quot;inverted-parser&amp;quot; generator behaves as if it was &amp;quot;parsing&amp;quot; a structured representation translating it into a well-formed linguistic string. The augmented grammar compilation procedure presented here is already quite general: it appears to subsume both the static compilation procedure of Strzalkowski (1990c), and the head-driven grammar evaluation technique of Shieber et al. (1990). The process of grammar inversion is logically divided into two stages: (a) computing the collections of minimal sets of essential arguments (MSEAs) in predicates, and (b) rearranging the order of goals in the grammar so that at least one active MSEA is &amp;quot;in&amp;quot; in every literal when its expansion is attempted. The first stage also includes computing the &amp;quot;in&amp;quot; and &amp;quot;out&amp;quot; arguments. In the second stage, the goal inversion process is initialized by the procedure INVERSE, which recursively reorders goals on the right-hand sides of clauses to meet the MSEA-binding requirement. Deadlocked clauses which </context>
</contexts>
<marker>1990</marker>
<rawString>a Parser into an Efficient Generator an algorithm for logic grammars.&amp;quot; COLING-90, Helsinki, Finland, August 1990. Vol. 2, pp. 347-352.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tomek Strzalkowski</author>
</authors>
<title>Reversible logic grammars for natural language parsing and generation.&amp;quot;</title>
<date>1990</date>
<journal>Computational Intelligence,</journal>
<volume>6</volume>
<issue>3</issue>
<pages>145--171</pages>
<publisher>NRC Canada.</publisher>
<contexts>
<context position="3173" citStr="Strzalkowski, 1990" startWordPosition="460" endWordPosition="461">ve natural language systems where the direction of communication frequently changes. In this paper we are primarily interested in the computational aspects&apos; of reversibility that include bi-directional evaluation and dual compilation of computer grammars, inversion of parsers into efficient generators, and derivation of &amp;quot;generating-versions&amp;quot; of existing parsing algorithms. Some of the recent research in this area is reported in (Calder et al., 1989; Dymetman and Isabelle, 1988; Dymetman et al., 1990; Estival, 1990; Hasida and Isizaki, 1987; Ishizaki, 1990; Shieber, 1988; Shieber et al., 1990; Strzalkowski, 1990a-c; Strzalkowski and Peng, 1990; van Noord, 1990; and Wedekind, 1988). Dymetman and Isabelle (1988) describe a top-down interpreter for definite clause grammars that statically reorders clause literals according to a hand-coded specification, and further allows for dynamic selection of AND goals2 during execution, using the technique known as the goal freezing (Colmerauer, 1982; Naish, 1986). Shieber et al. (1990) propose a mixed top-down/bottom-up interpretation, in which certain goals, namely those whose expansion is defined by the so-called &amp;quot;chain rules&amp;quot;,3 are not expanded during the top-d</context>
<context position="8168" citStr="Strzalkowski, 1990" startWordPosition="1255" endWordPosition="1257"> in concat(X,Y4a,b,c,d1). In the literal subject(Al ,A2.NUM,P), taken from an English grammar, Al and A2 are input and output strings of words, NUM is the number of the subject phrase, and P is the final translation. When the grammar is used for parsing, the &amp;quot;in&amp;quot; argument is Al; the &amp;quot;out&amp;quot; arguments are A2, NUM and P; when it is used for generation, the &amp;quot;in&amp;quot; argument is P; the &amp;quot;out&amp;quot; arguments are Al and NUM. In generation, A2 is neither &amp;quot;in&amp;quot; nor &amp;quot;out&amp;quot;. &amp;quot;In&amp;quot; and &amp;quot;out&amp;quot; status of arguments in a PROLOG program can be computed statically at compile time. The general algorithm has been described in (Strzalkowski, 1990c; Strzalkowski and Peng, 1990), ESSENTIAL ARGUMENTS: AN EXTENSION The notion of an essential argument in a PROWG literal has been first introduced in (Strzalkowski, 1989), and subsequently extended in (Strzalkowski, 1990bc; Strzalkowski and Peng, 1990). In short, X is an essential argument in a literal p ( • • X • ) if X is required to be &amp;quot;in&amp;quot; for a successful evaluation of this literal. By a successful evaluation of a literal we mean here the execution that is guaranteed to stop, and moreover, that will proceed along an optimal path. For instance, an evaluation of the goal mem (a,L), with an</context>
<context position="11070" citStr="Strzalkowski, 1990" startWordPosition="1803" endWordPosition="1804">inct minimal size sets v, c VP such that whenever the arguments in v, are &amp;quot;in&amp;quot;, then the arguments in Ki are &amp;quot;out&amp;quot;. If such v,&apos;s exist, then for every v, do: (i) assumeiv, is &amp;quot;in&amp;quot; in p; (ii) compute the set OUTo, of &amp;quot;out&amp;quot; arguments in all literals from r1 to r1; (iii) call (c) otherwise, if no such v, exist, MS; := 0. (5) Compute MS := j=1..r &apos;Active MSEA&apos;s are those existing with a given definition of a predicate. Other, non-active MSEA&apos;s can be activated when the clauses making up this definition are altered in some way. The procedure can be straightforwardly augmented to compute all MSEAs (Strzalkowski, 1990c). &apos;For i =1 the sets of essential arguments are selected so as to minimize the number of possible solutions to I. As a simple example consider the following clause: sent(P) vp(N,P),np(N). Assuming that MSEA&apos;S for vp and np are (P) and (N), respectively, and that N is &amp;quot;out&amp;quot; in vp, we can easily compute that (P) is the MSEA in sent. To see it, we note that MRUI for vp is ((P)) and, therefore, that 111.1 = (P). Next, we note that MRU2 for np is ((N)), and since OUTLI from vp is (N), we obtain that L2.1 = 0, and subsequently that (P) is the only MSEA in sent. The procedure presented above is suf</context>
<context position="15469" citStr="Strzalkowski, 1990" startWordPosition="2618" endWordPosition="2619">i are arguments to rii, that is, rii(- • XJ,Y • -), such that if Xi is &amp;quot;in&amp;quot; then Yi is &amp;quot;out&amp;quot; 12; and (4) for every j43 • • k, either Xi.0=Y1 or X1.414 (Yi) or Yi=f ()Cf.&amp;quot;), where f (X) denotes a term containing a subterm X. Note that this definition already ensures that the argument series obtained between X0 and Xk+1 is the shortest one. As an example, consider the following clauses: &amp;quot; A similar concept of guide-structure is introduced in (Dymetman et al., 1990), however the ordered series is less restrictive and covers a larger class of recursive programs. 12 Yi may be partially &amp;quot;out&amp;quot;; see (Strzalkowski, 1990c) for the definition of delayed &amp;quot;out&amp;quot; status. vp (X) :— np (X ,Y),vp (Y). np(f (X),X). Assuming that the argument X in the literal vp (X) on the left-hand side (lhs) of the first clause is &amp;quot;in&amp;quot;, we can easily check that &lt;X,X,Y,Y&gt; constitutes an argument series between arguments of vp in the first clause. DEFINITION 2 (weakly ordered series)13 An argument series &lt;Y0,X1,Y1, • • • ,Xk,YkXk.i&gt; in the clause p :—ri • r„ is weakly ordered iff Y05*X1,4.1 [or Xk.4.15*Y0], where 5* is a closure of 5_ defined as follows: (1) for every i=1 • • k, such that r.(&amp;quot; • Xi,Yi • • ) there exists a clause rii( •</context>
<context position="25502" citStr="Strzalkowski, 1990" startWordPosition="4447" endWordPosition="4448"> a way that at least one of its MSEAs is &amp;quot;in&amp;quot;. If this &amp;quot;in&amp;quot; MSEA is not an active one, recursively invert clauses defining the goal&apos;s predicate so as to make the MSEA become active. In a basic formulation of the inversion algorithm the movement of goals in step (3) is confined to be within the right-hand sides of program clauses, that is, goals cannot be moved between clauses. The inversion process proceeds top-down, starting with the top-level clause, for example parse (String,Sem) :— sent (String, [],Sem). The restricted movement inversion algorithm INVERSE has been documented in detail in (Strzalkowski, 1990ac). It is demonstrated here on the following clause taken from a parser program, and which recognizes yes-no questions: yesnoq (Al ,A4,P) :— verb (Al ,A2,Num,P2), subject (A2,A3,Num,P1), object (A3 ,A4,P 1 ,P2,P). When rewriting this clause for generation, we would place object first (it has P &amp;quot;in&amp;quot;, and A3, PI, P2 &amp;quot;out&amp;quot;), then subject (it has the essential PI &amp;quot;in&amp;quot;, and A2 and Num &amp;quot;out&amp;quot;), and finally verb (its MSEA is either (Al) or (Num,P2), the latter being completely &amp;quot;in&amp;quot; now). The net effect is the following generator clause:&amp;quot; yesnoq (Al ,A4,P) :— object (A3 ,A4 ,P 1 ,P2,P), subject (A2,A3</context>
<context position="32597" citStr="Strzalkowski (1990" startWordPosition="5659" endWordPosition="5660">on goals. Remove superfluous arguments in literals. The result are the clauses [1&apos;] to [31 above. CONCLUSIONS We described a general method for inversion of logic grammars that transforms a parser into an efficient generator using an off-line compilation process that manipulates parser&apos;s clauses. The resulting &amp;quot;inverted-parser&amp;quot; generator behaves as if it was &amp;quot;parsing&amp;quot; a structured representation translating it into a well-formed linguistic string. The augmented grammar compilation procedure presented here is already quite general: it appears to subsume both the static compilation procedure of Strzalkowski (1990c), and the head-driven grammar evaluation technique of Shieber et al. (1990). The process of grammar inversion is logically divided into two stages: (a) computing the collections of minimal sets of essential arguments (MSEAs) in predicates, and (b) rearranging the order of goals in the grammar so that at least one active MSEA is &amp;quot;in&amp;quot; in every literal when its expansion is attempted. The first stage also includes computing the &amp;quot;in&amp;quot; and &amp;quot;out&amp;quot; arguments. In the second stage, the goal inversion process is initialized by the procedure INVERSE, which recursively reorders goals on the right-hand sid</context>
</contexts>
<marker>Strzalkowski, 1990</marker>
<rawString>Strzalkowski, Tomek. 1990c. &amp;quot;Reversible logic grammars for natural language parsing and generation.&amp;quot; Computational Intelligence, 6(3), pp. 145-171. NRC Canada.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tomek Strzalkowski</author>
<author>Ping Peng</author>
</authors>
<title>Automated Inversion of Logic Grammars for Generation.&amp;quot;</title>
<date>1990</date>
<booktitle>Proc. of 28th ACL,</booktitle>
<pages>212--219</pages>
<location>Pittsburgh, PA,</location>
<contexts>
<context position="3205" citStr="Strzalkowski and Peng, 1990" startWordPosition="462" endWordPosition="465">tems where the direction of communication frequently changes. In this paper we are primarily interested in the computational aspects&apos; of reversibility that include bi-directional evaluation and dual compilation of computer grammars, inversion of parsers into efficient generators, and derivation of &amp;quot;generating-versions&amp;quot; of existing parsing algorithms. Some of the recent research in this area is reported in (Calder et al., 1989; Dymetman and Isabelle, 1988; Dymetman et al., 1990; Estival, 1990; Hasida and Isizaki, 1987; Ishizaki, 1990; Shieber, 1988; Shieber et al., 1990; Strzalkowski, 1990a-c; Strzalkowski and Peng, 1990; van Noord, 1990; and Wedekind, 1988). Dymetman and Isabelle (1988) describe a top-down interpreter for definite clause grammars that statically reorders clause literals according to a hand-coded specification, and further allows for dynamic selection of AND goals2 during execution, using the technique known as the goal freezing (Colmerauer, 1982; Naish, 1986). Shieber et al. (1990) propose a mixed top-down/bottom-up interpretation, in which certain goals, namely those whose expansion is defined by the so-called &amp;quot;chain rules&amp;quot;,3 are not expanded during the top-down phase of the interpreter, bu</context>
<context position="8199" citStr="Strzalkowski and Peng, 1990" startWordPosition="1258" endWordPosition="1261">d1). In the literal subject(Al ,A2.NUM,P), taken from an English grammar, Al and A2 are input and output strings of words, NUM is the number of the subject phrase, and P is the final translation. When the grammar is used for parsing, the &amp;quot;in&amp;quot; argument is Al; the &amp;quot;out&amp;quot; arguments are A2, NUM and P; when it is used for generation, the &amp;quot;in&amp;quot; argument is P; the &amp;quot;out&amp;quot; arguments are Al and NUM. In generation, A2 is neither &amp;quot;in&amp;quot; nor &amp;quot;out&amp;quot;. &amp;quot;In&amp;quot; and &amp;quot;out&amp;quot; status of arguments in a PROLOG program can be computed statically at compile time. The general algorithm has been described in (Strzalkowski, 1990c; Strzalkowski and Peng, 1990), ESSENTIAL ARGUMENTS: AN EXTENSION The notion of an essential argument in a PROWG literal has been first introduced in (Strzalkowski, 1989), and subsequently extended in (Strzalkowski, 1990bc; Strzalkowski and Peng, 1990). In short, X is an essential argument in a literal p ( • • X • ) if X is required to be &amp;quot;in&amp;quot; for a successful evaluation of this literal. By a successful evaluation of a literal we mean here the execution that is guaranteed to stop, and moreover, that will proceed along an optimal path. For instance, an evaluation of the goal mem (a,L), with an intention to find a list L of </context>
</contexts>
<marker>Strzalkowski, Peng, 1990</marker>
<rawString>Strzalkowski, Tomek and Ping Peng. 1990. &amp;quot;Automated Inversion of Logic Grammars for Generation.&amp;quot; Proc. of 28th ACL, Pittsburgh, PA, June 1990. pp. 212-219.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gertjan van Noord</author>
</authors>
<title>Reversible Unification Based Machine Translation.&amp;quot; COLING90,</title>
<date>1990</date>
<volume>2</volume>
<pages>299--304</pages>
<location>Helsinki, Finland,</location>
<marker>van Noord, 1990</marker>
<rawString>van Noord, Gertjan. 1990. &amp;quot;Reversible Unification Based Machine Translation.&amp;quot; COLING90, Helsinki, Finland, August 1990. Vol. 2, pp. 299-304.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jurgen Wedekind</author>
</authors>
<title>Generation as structure driven derivation.&amp;quot; COLING-88,</title>
<date>1988</date>
<pages>732--737</pages>
<location>Budapest, Hungary,</location>
<contexts>
<context position="3243" citStr="Wedekind, 1988" startWordPosition="470" endWordPosition="471">ly changes. In this paper we are primarily interested in the computational aspects&apos; of reversibility that include bi-directional evaluation and dual compilation of computer grammars, inversion of parsers into efficient generators, and derivation of &amp;quot;generating-versions&amp;quot; of existing parsing algorithms. Some of the recent research in this area is reported in (Calder et al., 1989; Dymetman and Isabelle, 1988; Dymetman et al., 1990; Estival, 1990; Hasida and Isizaki, 1987; Ishizaki, 1990; Shieber, 1988; Shieber et al., 1990; Strzalkowski, 1990a-c; Strzalkowski and Peng, 1990; van Noord, 1990; and Wedekind, 1988). Dymetman and Isabelle (1988) describe a top-down interpreter for definite clause grammars that statically reorders clause literals according to a hand-coded specification, and further allows for dynamic selection of AND goals2 during execution, using the technique known as the goal freezing (Colmerauer, 1982; Naish, 1986). Shieber et al. (1990) propose a mixed top-down/bottom-up interpretation, in which certain goals, namely those whose expansion is defined by the so-called &amp;quot;chain rules&amp;quot;,3 are not expanded during the top-down phase of the interpreter, but instead they are passed over until a</context>
</contexts>
<marker>Wedekind, 1988</marker>
<rawString>Wedekind, Jurgen. 1988. &amp;quot;Generation as structure driven derivation.&amp;quot; COLING-88, Budapest, Hungary, August 1988, pp. 732-737.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>