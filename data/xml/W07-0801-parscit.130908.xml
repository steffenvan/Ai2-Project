<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.637166">
ElixirFM — Implementation of Functional Arabic Morphology
</title>
<author confidence="0.93579">
Otakar Smrˇz
</author>
<affiliation confidence="0.978731">
Institute of Formal and Applied Linguistics
Faculty of Mathematics and Physics
Charles University in Prague
</affiliation>
<email confidence="0.989826">
otakar.smrz@mff.cuni.cz
</email>
<sectionHeader confidence="0.994635" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999648944444445">
Functional Arabic Morphology is a formula-
tion of the Arabic inflectional system seek-
ing the working interface between morphol-
ogy and syntax. ElixirFM is its high-level
implementation that reuses and extends the
Functional Morphology library for Haskell.
Inflection and derivation are modeled in
terms of paradigms, grammatical categories,
lexemes and word classes. The computation
of analysis or generation is conceptually dis-
tinguished from the general-purpose linguis-
tic model. The lexicon of ElixirFM is de-
signed with respect to abstraction, yet is no
more complicated than printed dictionaries.
It is derived from the open-source Buckwal-
ter lexicon and is enhanced with information
sourcing from the syntactic annotations of
the Prague Arabic Dependency Treebank.
</bodyText>
<sectionHeader confidence="0.99432" genericHeader="keywords">
1 Overview
</sectionHeader>
<bodyText confidence="0.999607102564102">
One can observe several different streams both in the
computational and the purely linguistic modeling of
morphology. Some are motivated by the need to ana-
lyze word forms as to their compositional structure,
others consider word inflection as being driven by
the underlying system of the language and the for-
mal requirements of its grammar.
In Section 2, before we focus on the principles of
ElixirFM, we briefly follow the characterization of
morphological theories presented by Stump (2001)
and extend the classification to the most promi-
nent computational models of Arabic morphology
(Beesley, 2001; Buckwalter, 2002; Habash et al.,
2005; El Dada and Ranta, 2006).
In Section 3, we survey some of the categories of
the syntax–morphology interface in Modern Written
Arabic, as described by the Functional Arabic Mor-
phology. In passing, we will introduce the basic con-
cepts of programming in Haskell, a modern purely
functional language that is an excellent choice for
declarative generative modeling of morphologies, as
Forsberg and Ranta (2004) have shown.
Section 4 will be devoted to describing the lexicon
of ElixirFM. We will develop a so-called domain-
specific language embedded in Haskell with which
we will achieve lexical definitions that are simulta-
neously a source code that can be checked for con-
sistency, a data structure ready for rather indepen-
dent processing, and still an easy-to-read-and-edit
document resembling the printed dictionaries.
In Section 5, we will illustrate how rules of in-
flection and derivation interact with the parameters
of the grammar and the lexical information. We will
demonstrate, also with reference to the Functional
Morphology library (Forsberg and Ranta, 2004), the
reusability of the system in many applications, in-
cluding computational analysis and generation in
various modes, exploring and exporting of the lex-
icon, printing of the inflectional paradigms, etc.
</bodyText>
<sectionHeader confidence="0.995587" genericHeader="introduction">
2 Morphological Models
</sectionHeader>
<bodyText confidence="0.998926571428571">
According to Stump (2001), morphological theories
can be classified along two scales. The first one
deals with the core or the process of inflection:
lexical theories associate word’s morphosyntactic
properties with affixes
inferential theories consider inflection as a result of
operations on lexemes; morphosyntactic prop-
</bodyText>
<page confidence="0.82272">
1
</page>
<note confidence="0.9212035">
Proceedings of the 5th Workshop on Important Unresolved Matters, pages 1–8,
Prague, Czech Republic, June 2007. c�2007 Association for Computational Linguistics
</note>
<bodyText confidence="0.991978868852459">
erties are expressed by the rules that relate the
form in a given paradigm to the lexeme
The second opposition concerns the question of
inferability of meaning, and theories divide into:
incremental words acquire morphosyntactic prop-
erties only in connection with acquiring the in-
flectional exponents of those properties
realizational association of a set of properties with
a word licenses the introduction of the expo-
nents into the word’s morphology
Evidence favoring inferential–realizational theo-
ries over the other three approaches is presented by
Stump (2001) as well as Baerman et al. (2006) or
Spencer (2004). In trying to classify the implemen-
tations of Arabic morphological models, let us re-
consider this cross-linguistic observation:
The morphosyntactic properties associ-
ated with an inflected word’s individ-
ual inflectional markings may underdeter-
mine the properties associated with the
word as a whole. (Stump, 2001, p. 7)
How do the current morphological analyzers in-
terpret, for instance, the number and gender of the
Arabic broken masculine plurals ˇgudud ��new
ones or qud. ¯ah SLQs judges, or the case of mustawan
�
j��-.A
j a level? Do they identify the values of these
features that the syntax actually operates with, or is
the resolution hindered by some too generic assump-
tions about the relation between meaning and form?
Many of the computational models of Arabic
morphology, including in particular (Beesley, 2001),
(Ramsay and Mansur, 2001) or (Buckwalter, 2002),
are lexical in nature. As they are not designed in
connection with any syntax–morphology interface,
their interpretations are destined to be incremental.
Some signs of a lexical–realizational system can
be found in (Habash, 2004). The author mentions
and fixes the problem of underdetermination of in-
herent number with broken plurals, when develop-
ing a generative counterpart to (Buckwalter, 2002).
The computational models in (Soudi et al., 2001)
and (Habash et al., 2005) attempt the inferential–
realizational direction. Unfortunately, they imple-
ment only sections of the Arabic morphological sys-
tem. The Arabic resource grammar in the Grammat-
ical Framework (El Dada and Ranta, 2006) is per-
haps the most complete inferential–realizational im-
plementation to date. Its style is compatible with
the linguistic description in e.g. (Fischer, 2001) or
(Badawi et al., 2004), but the lexicon is now very
limited and some other extensions for data-oriented
computational applications are still needed.
ElixirFM is inspired by the methodology in (Fors-
berg and Ranta, 2004) and by functional program-
ming, just like the Arabic GF is (El Dada and Ranta,
2006). Nonetheless, ElixirFM reuses the Buckwal-
ter lexicon (2002) and the annotations in the Prague
Arabic Dependency Treebank (Hajiˇc et al., 2004),
and implements yet more refined linguistic model.
</bodyText>
<sectionHeader confidence="0.99496" genericHeader="method">
3 Morphosyntactic Categories
</sectionHeader>
<bodyText confidence="0.942731766666667">
Functional Arabic Morphology and ElixirFM re-
establish the system of inflectional and inher-
ent morphosyntactic properties (alternatively named
grammatical categories or features) and distinguish
precisely the senses of their use in the grammar.
In Haskell, all these categories can be represented
as distinct data types that consist of uniquely identi-
fied values. We can for instance declare that the cate-
gory of case in Arabic discerns three values, that we
also distinguish three values for number or person,
or two values of the given names for verbal voice:
data Case = Nominative  |Genitive |
Accusative
data Number = Singular  |Dual  |Plural
data Person = First  |Second  |Third
data Voice = Active  |Passive
All these declarations introduce new enumerated
types, and we can use some easily-defined meth-
ods of Haskell to work with them. If we load this
(slightly extended) program into the interpreter,1 we
can e.g. ask what category the value Genitive be-
longs to (seen as the :: type signature), or have it
evaluate the list of the values that Person allows:
? :type Genitive Genitive :: Case
? enum :: [Person] [First,Second,Third]
Lists in Haskell are data types that can be
parametrized by the type that they contain. So, the
value [Active, Active, Passive] is a list of three
elements of type Voice, and we can write this if nec-
essary as the signature :: [Voice]. Lists can also
</bodyText>
<footnote confidence="0.992927">
1http://www.haskell.org/
</footnote>
<page confidence="0.995801">
2
</page>
<bodyText confidence="0.977942127272728">
be empty or have just one single element. We denote
lists containing some type a as being of type [a].
Haskell provides a number of useful types al-
ready, such as the enumerated boolean type or the
parametric type for working with optional values:
data Bool = True  |False
data Maybe a = Just a  |Nothing
Similarly, we can define a type that couples other
values together. In the general form, we can write
data Couple a b = a :-: b
which introduces the value :-: as a container for
some value of type a and another of type b.2
Let us return to the grammatical categories. In-
flection of nominals is subject to several formal re-
quirements, which different morphological models
decompose differently into features and values that
are not always complete with respect to the inflec-
tional system, nor mutually orthogonal. We will ex-
plain what we mean by revisiting the notions of state
and definiteness in contemporary written Arabic.
To minimize the confusion of terms, we will de-
part from the formulation presented in (El Dada and
Ranta, 2006). In there, there is only one relevant
category, which we can reimplement as State’:
data State’ = Def  |Indef  |Const
Variation of the values of State’ would enable gen-
erating the forms al-kit¯abu u A��Jº~ Ë@ def., kit¯abun a As�
indef., and kit¯abu u. A&apos;S~ const. for the nominative
singular of book. This seems fine until we explore
more inflectional classes. The very variation for the
nominative plural masculine of the adjective high
gets ar-raf¯~ ana v ñª �Ë @ def., raf¯~ana vñ�ª ; in-
def., and raf¯~tis ñ�ªJ��¯� P~ const. But what value does
the form ar-raf¯~�¯u ñ�ªJ��¯� ��QË@, found in improper annex-
ations such as in al-mas�l¯una ’r-raf¯~a ’l-mustaw¯a
øJ ,
x‚:ÜÏ@ ñ�ªJ��¯��Ë@ vñËð g‚;Ï@ the-officials the-highs-
state in the sense of Fischer, and adding a
feature for the presence of the definite article...
boolean
icle, Just False for
�
forms in some compounds or after l¯a B
However, we would get one unacceptable combina-
tion of the values claiming the presence of the def-
inite article and yet the indefinite state, i.e. possibly
the indefinite article or the diptotic declension.
Functional Arabic Morphology refactors the six
different kinds of forms (if we consider all inflec-
tional situations) depending on two parameters. The
first controls prefixation of the (virtual) definite arti-
cle, the other reduces some suffixes if the word is a
head of an annexation. In ElixirFM, we define these
parameters as type synonyms to what we recall:
type Definite =Maybe Bool
</bodyText>
<subsectionHeader confidence="0.592099">
type Annexing = Bool
</subsectionHeader>
<bodyText confidence="0.841559666666667">
The Definite values include Just True for
forms with the definite art
nexation, i.e. Nothing :-: False. Conversely,
J
is in the state Just True
True.
</bodyText>
<subsectionHeader confidence="0.486999">
The classical construct state is Nothing
</subsectionHeader>
<bodyText confidence="0.95653975">
True.
The definite state is Just _
False, where _ is
True for El Dada and Ranta and False for Fischer.
We may discover that now all the values of
are meaningful.3
Type declarations are also useful for defining in
what categories a given part of speech inflects. For
</bodyText>
<equation confidence="0.6116465">
verbs, this is a bit more involved, an
ar-
raf¯~�¯uñ�ªJ��¯�
@
</equation>
<bodyText confidence="0.9233832">
:-:
:-:
:-:
State
d we leave it for
</bodyText>
<figureCaption confidence="0.962589">
Figure 2. For nouns, we set this algebraic data type:
</figureCaption>
<bodyText confidence="0.689252714285714">
data ParaNoun = NounS Number Case State
2001), where state has exactly the values of
but where the definite state Def covers even forms
without the prefixed al-
article, since also some
separate words like
or
</bodyText>
<equation confidence="0.697292571428571">
oh can have the
effects on inflection that the definite arti
State’,
Ë@
�
l¯aBno
y¯aA~K
</equation>
<bodyText confidence="0.951185">
cle has. To
distinguish all the forms, we might think of keeping
</bodyText>
<footnote confidence="0.60125575">
operators can also be written as prefix functions if en-
closed in
can be written as
2Infix
</footnote>
<equation confidence="0.809208428571429">
. Functions
operators if enclosed
in ‘‘. We will exploit this when defining the lexicon’s notation.
n c s
NounS
 |n &lt;- enum, c &lt;- enum,
s &lt;- values ]
</equation>
<bodyText confidence="0.9494635">
of the-level, receive?
It is interesting to consult for instance (Fischer,
or y¯a A�K�
(absolute negatives or vocatives), and Nothing for
forms that reject the definite article for other reasons.
Functional Arabic Morphology considers state as
a result of coupling the two independent parameters:
type State = Couple Definite Annexing
Thus, the indefinite state Indef describes a word
void of the definite article(s) and not heading an an-
In the interpreter, we can now generate all 54
combinations of inflectional parameters for nouns:
? [
The function values is analogous to enum, and both
need to know their type before they can
evaluate.
</bodyText>
<subsectionHeader confidence="0.856987">
3With Just False
</subsectionHeader>
<bodyText confidence="0.83811775">
True, we can annotate e.g. the
underdetermined
:
in hum-u
</bodyText>
<equation confidence="0.797627636363636">
they-are
highs-of the-level, i.e. they are the high-level
:-:
‘incorrectly’
raf¯~�¯uñ
J��¯~P~
’l-mas�¯ul¯u-
naraf¯~�¯u’l-mustaw¯a øñ�J‚ÖÏ@ ñ�ªJ��¯� P~ �àñËð �ñ‚ÖÏ@ Ñë
the-
of�cials
of�cials.
</equation>
<page confidence="0.964486">
3
</page>
<bodyText confidence="0.999301">
The ‘magic’ is that the bound variables n, c, and s
have their type determined by the NounS constructor,
so we need not type anything explicitly. We used the
list comprehension syntax to cycle over the lists that
enum and values produce, cf. (Hudak, 2000).
</bodyText>
<sectionHeader confidence="0.987152" genericHeader="method">
4 ElixirFM Lexicon
</sectionHeader>
<bodyText confidence="0.950751833333333">
Unstructured text is just a list of characters, or string:
type String = [Char]
Yet words do have structure, particularly in Arabic.
We will work with strings as the superficial word
forms, but the internal representations will be more
abstract (and computationally more efficient, too).
The definition of lexemes can include the deriva-
tional root and pattern information if appropriate,
cf. (Habash et al., 2005), and our model will encour-
age this. The surface word kit¯ab H. As� book can de-
compose to the triconsonantal root k t b I. .»and the
morphophonemic pattern FiCAL of type PatternT:
</bodyText>
<equation confidence="0.943018">
data PatternT = FaCaL  |FAL  |FaCY |
FiCAL  |FuCCAL  |{- ... -}
MustaFCaL  |MustaFaCL
deriving (Eq, Enum, Show)
</equation>
<bodyText confidence="0.98444125">
The deriving clause associates PatternT with
methods for testing equality, enumerating all the val-
ues, and turning the names of the values into strings:
? show FiCAL → &amp;quot;FiCAL&amp;quot;
We choose to build on morphophonemic patterns
rather than CV patterns and vocalisms. Words like
istaˇg¯ab H. A�j.�:ƒ@~ to respond and istaˇgwab
H. �ñj. ~~Jƒ@~
to interrogate have the same underlying VstVCCVC
pattern, so information on CV patterns alone would
not be enough to reconstruct the surface forms. Mor-
phophonemic patterns, in this case IstaFAL and
IstaFCaL, can easily be mapped to the hypothetical
CV patterns and vocalisms, or linked with each other
according to their relationship. Morphophonemic
patterns deliver more information in a more com-
pact way. Of course, ElixirFM provides functions
for properly interlocking the patterns with the roots:
? merge &amp;quot;k t b&amp;quot; FiCAL → &amp;quot;kitAb&amp;quot;
? merge &amp;quot;-g w b&amp;quot; IstaFAL → &amp;quot;ista-gAb&amp;quot;
? merge &amp;quot;-g w b&amp;quot; IstaFCaL → &amp;quot;ista-gwab&amp;quot;
? merge &amp;quot;s ’ l&amp;quot; MaFCUL → &amp;quot;mas’Ul&amp;quot;
? merge &amp;quot;z h r&amp;quot; IFtaCaL → &amp;quot;izdahar&amp;quot;
The izdahar QmS,@~ to flourish case exemplifies that
exceptionless assimilations need not be encoded in
the patterns, but can instead be hidden in rules.
The whole generative model adopts the multi-
purpose notation of ArabTEX (Lagally, 2004) as a
meta-encoding of both the orthography and phonol-
ogy. Therefore, instantiation of the &amp;quot;’&amp;quot; hamza car-
riers or other merely orthographic conventions do
not obscure the morphological model. With Encode
Arabic4 interpreting the notation, ElixirFM can at
the surface level process the original Arabic script
(non-)vocalized to any degree or work with some
kind of transliteration or even transcription thereof.
Morphophonemic patterns represent the stems of
words. The various kinds of abstract prefixes and
suffixes can be expressed either as atomic values, or
as literal strings wrapped into extra constructors:
</bodyText>
<equation confidence="0.990621">
data Prefix = Al  |LA  |Prefix String
data Suffix = Iy  |AT  |At  |An  |Ayn |
Un  |In  |Suffix String
al = Al; lA = LA -- function synonyms
aT = AT; ayn = Ayn; aN = Suffix &amp;quot;aN&amp;quot;
</equation>
<bodyText confidence="0.855518722222222">
Affixes and patterns are arranged together via
the Morphs a data type, where a is a triliteral pat-
tern PatternT or a quadriliteral PatternQ or a non-
templatic word stem Identity of type PatternL:
data PatternL = Identity
data PatternQ = KaRDaS  |KaRADiS {- ... -}
data Morphs a = Morphs a [Prefix] [Suffix]
~
B wireless can thus be
decomposed as the root s l k 1/2Êƒ and the value
� �
Morphs FiCL [LA] [Iy]. Shunning such concrete
representations, we define new operators &gt; |and |&lt;
that denote prefixes, resp. suffixes, inside Morphs a:
? lA &gt; |FiCL |&lt; Iy → Morphs FiCL [LA][Iy]
Implementing &gt; |and |&lt; to be applicable in the in-
tuitive way required Haskell’s multi-parameter type
classes with functional dependencies (Jones, 2000):
</bodyText>
<construct confidence="0.974250333333333">
class Morphing a b  |a -&gt; b where
morph :: a -&gt; Morphs b
instance Morphing (Morphs a) a where
morph = id
instance Morphing PatternT PatternT where
morph x = Morphs x [] []
</construct>
<bodyText confidence="0.925211">
The instance declarations ensure how the morph
method would turn values of type a into Morphs b.
</bodyText>
<footnote confidence="0.868176">
4http://sf.net/projects/encode-arabic/
</footnote>
<bodyText confidence="0.650937">
The word l¯a-silk¯ıy ú~3/4Êƒ&amp;quot;
</bodyText>
<page confidence="0.941794">
4
</page>
<table confidence="0.7062498">
|&gt; &amp;quot;k t b&amp;quot; &lt; |[
FaCaL ‘verb‘ [ &amp;quot;write&amp;quot;,
FiCAL ‘noun‘ [ &amp;quot;book&amp;quot; ]
FiCAL |&lt; aT ‘noun‘ [ &amp;quot;writing&amp;quot;
FiCAL |&lt; aT ‘noun‘ [ &amp;quot;essay&amp;quot;,
FACiL |&lt; Iy ‘noun‘ [ &amp;quot;writer&amp;quot;,
FuCCAL ‘noun‘ [ &amp;quot;kuttab&amp;quot;,
MaFCaL ‘noun‘ [ &amp;quot;office&amp;quot;,
MaFCaL ‘adj‘ [ &amp;quot;office&amp;quot;
MaFCaL |&lt; aT ‘noun‘ [ &amp;quot;library&amp;quot;,
&amp;quot;be destined&amp;quot; ] ‘imperf‘ FCuL,
‘plural‘ FuCuL,
],
&amp;quot;piece of writing&amp;quot; ] ‘plural‘ FiCAL |&lt; At,
&amp;quot;author&amp;quot;, &amp;quot;clerk&amp;quot; ] ‘plural‘ FaCaL |&lt; aT
‘plural‘ FuCCAL,
&amp;quot;Quran school&amp;quot; ] ‘plural‘ FaCACIL,
&amp;quot;department&amp;quot; ] ‘plural‘ MaFACiL,
],
&amp;quot;bookstore&amp;quot; ] ‘plural‘ MaFACiL ]
</table>
<figureCaption confidence="0.999827">
Figure 1: Entries of the ElixirFM lexicon nested under the root k t b `,..using morphophonemic templates.
</figureCaption>
<bodyText confidence="0.9991056">
Supposing that morph is available for the two types,
(|&lt;) is a function on y :: a and x :: Suffix giv-
ing a value of type Morphs b. The intermediate re-
sult of morph y is decomposed, and x is prepended
to the stack s of the already present suffixes.
</bodyText>
<equation confidence="0.857124666666667">
(|&lt;) :: Morphing a b =&gt;
a -&gt; Suffix -&gt; Morphs b
y |&lt; x = Morphs t p (x : s)
</equation>
<bodyText confidence="0.930756558823529">
where Morphs t p s = morph y
With the introduction of patterns, their synony-
mous functions and the &gt; |and |&lt; operators, we have
started the development of what can be viewed as a
domain-specific language embedded in the general-
purpose programming language. Encouraged by the
flexibility of many other domain-specific languages
in Haskell, esp. those used in functional parsing
(Ljungl¨of, 2002) or pretty-printing (Wadler, 2003),
we may design the lexicon to look like e.g.
module Elixir.Data.Lexicon
import Elixir.Lexicon
lexicon = listing {- lexicon’s header -}
|&gt; {- root one -} &lt; |[ {- Entry a -} ]
|&gt; {- root two -} &lt; |[ {- Entry b -} ]
-- other roots or word stems and entries
and yet be a verifiable source code defining a data
structure that is directly interpretable. The meaning
of the combinators |&gt; and &lt; |could be supplied via
an external module Elixir.Lexicon, so is very easy
to customize. The effect of these combinators might
be similar to the : and :-: constructors that we met
previously, but perhaps other data structures might
be built from the code instead of lists and pairs.
Individual entries can be defined with functions in
a convenient notational form using ‘‘. Infix opera-
tors can have different precedence and associativity,
which further increases the options for designing a
lightweight, yet expressive, embedded language.
In Figure 1, each entry reduces to a record of type
Entry PatternT reflecting internally the lexeme’s
inherent properties. Consider one such reduction be-
low. Functions like plural or gender or humanness
could further modify the Noun’s default information:
</bodyText>
<table confidence="0.602529">
? FiCAL |&lt; aT ‘noun‘ [ &amp;quot;writing&amp;quot; ] --+
noun (FiCAL |&lt; aT) [ &amp;quot;writing&amp;quot; ] --+
Entry (Noun [] Nothing Nothing)
(morph (FiCAL |&lt; aT))
[ &amp;quot;writing&amp;quot; ] __+
Entry (Noun [] Nothing Nothing)
(Morphs FiCAL [] [AT])
[ &amp;quot;writing&amp;quot; ]
</table>
<bodyText confidence="0.939659666666667">
The lexicon of ElixirFM is derived from the open-
source Buckwalter lexicon (Buckwalter, 2002).5 We
devised an algorithm in Perl using the morpho-
</bodyText>
<footnote confidence="0.829595">
5Habash (2004) comments on the lexicon’s internal format.
</footnote>
<page confidence="0.980367">
5
</page>
<table confidence="0.886308666666667">
data Mood = Indicative  |Subjunctive  |Jussive  |Energetic deriving (Eq, Enum)
data Gender = Masculine  |Feminine deriving (Eq, Enum)
data ParaVerb = VerbP Voice Person Gender Number
 |VerbI Mood Voice Person Gender Number
 |VerbC Gender Number deriving Eq
paraVerbC :: Morphing a b =&gt; Gender -&gt; Number -&gt; [Char] -&gt; a -&gt; Morphs b
paraVerbC g n i = case n of
Singular -&gt; case g of Masculine -&gt; prefix i . suffix &amp;quot;&amp;quot;
Feminine -&gt; prefix i . suffix &amp;quot;I&amp;quot;
Plural -&gt; case g of Masculine -&gt; prefix i . suffix &amp;quot;UW&amp;quot;
Feminine -&gt; prefix i . suffix &amp;quot;na&amp;quot;
_ -&gt; prefix i . suffix &amp;quot;A&amp;quot;
</table>
<figureCaption confidence="0.992447">
Figure 2: Excerpt from the implementation of verbal inflectional features and paradigms in ElixirFM.
</figureCaption>
<bodyText confidence="0.999775333333333">
phonemic patterns of ElixirFM that finds the roots
and templates of the lexical items, as they are avail-
able only partially in the original, and produces the
lexicon in formats for Perl and for Haskell.
Information in the ElixirFM lexicon can get even
more refined, by lexicographers or by programmers.
Verbs could be declared via indicating their deriva-
tional verbal form (that would, still, reduce to some
Morphs a value), and deverbal nouns and participles
could be defined generically for the extended forms.
The identification of patterns as to their derivational
form is implemented easily with the isForm method:
</bodyText>
<table confidence="0.5772005">
data Form = I  |II  |III  |IV {- .. -} XV
? isForm VIII IFtaCaL True
? isForm II TaKaRDuS True
? filter (‘isForm‘ MuFCI) [I ..] [IV]
</table>
<bodyText confidence="0.996386714285714">
Nominal parts of speech need to be enhanced with
information on the inherent number, gender and hu-
manness, if proper modeling of linguistic agreement
in Arabic is desired.6 Experiments with the Prague
Arabic Dependency Treebank (Hajiˇc et al., 2004)
show that this information can be learned from an-
notations of syntactic relations (Smrˇz, 2007).
</bodyText>
<sectionHeader confidence="0.961571" genericHeader="method">
5 Morphological Rules
</sectionHeader>
<bodyText confidence="0.958248147058824">
Inferential–realizational morphology is modeled in
terms of paradigms, grammatical categories, lex-
emes and word classes. ElixirFM implements the
comprehensive rules that draw the information from
6Cf. e.g. (El Dada and Ranta, 2006; Kremers, 2003).
the lexicon and generate the word forms given the
appropriate morphosyntactic parameters. The whole
is invoked through a convenient inflect method.
The lexicon and the parameters determine the
choice of paradigms. The template selection mecha-
nism differs for nominals (providing plurals) and for
verbs (providing all needed stem alternations in the
extent of the entry specifications of e.g. Hans Wehr’s
dictionary), yet it is quite clear-cut (Smrˇz, 2007).
In Figure 2, the algebraic data type ParaVerb
restricts the space in which verbs are inflected by
defining three Cartesian products of the elementary
categories: a verb can have VerbP perfect forms in-
flected in voice, person, gender, number, VerbI im-
perfect forms inflected also in mood, and VerbC im-
peratives inflected in gender and number only.7
The paradigm for inflecting imperatives, the one
and only such paradigm in ElixirFM, is imple-
mented as paraVerbC. It is a function parametrized
by some particular value of gender g and number n.
It further takes the initial imperative prefix i and the
verbal stem (both inferred from the morphophone-
mic patterns in the lexical entry) to yield the in-
flected imperative form. Note the polymorphic type
of the function, which depends on the following:
prefix, suffix :: Morphing a b =&gt;
[Char] -&gt; a -&gt; Morphs b
prefix x y = Prefix x &gt; |y
suffix x y = y |&lt; Suffix x
</bodyText>
<footnote confidence="0.506226">
7Cf. (Forsberg and Ranta, 2004; El Dada and Ranta, 2006).
</footnote>
<page confidence="0.998838">
6
</page>
<bodyText confidence="0.999915928571429">
If one wished to reuse the paradigm and apply it on
strings only, it would be sufficient to equate these
functions with standard list operations, without any
need to reimplement the paradigm itself.
The definition of paraVerbC is simple and concise
due to the chance to compose with . the partially
applied prefix and suffix functions and to virtu-
ally omit the next argument. This advanced formu-
lation may seem not as minimal as when specifying
the literal endings or prefixes, but we present it here
to illustrate the options that there are. An abstract
paradigm can be used on more abstract types than
just strings.$ Inflected forms need not be merged
with roots yet, and can retain the internal structure:
</bodyText>
<figure confidence="0.9188712">
? paraVerbC Feminine Plural &amp;quot;u&amp;quot; FCuL �
Prefix &amp;quot;u&amp;quot; &gt; |FCuL |&lt; Suffix &amp;quot;na&amp;quot;
? merge &amp;quot;k t b&amp;quot; ({- previous value -}) —
L3
��
g.
i
ra
A&amp;quot;
ra
�
&amp;quot;iqra’I&amp;quot;iqra-¯ı
Q
s
&amp;quot;
q
’
iq
-¯a
_e �e
</figure>
<figureCaption confidence="0.544516">
du. &amp;quot;i q ra ’ na&amp;quot; i q ra -n a �j � @ pl. read!
</figureCaption>
<bodyText confidence="0.999701933333333">
The highlight of the Arabic morphology is that
the ‘irregular’ inflection actually rests in strictly ob-
serving some additional rules, the nature of which
is phonological. Therefore, surprisingly, ElixirFM
does not even distinguish between verbal and nomi-
nal word formation when enforcing these rules. This
reduces the number of paradigms to the prototypical
3 verbal and 5 nominal! Yet, the model is efficient.
Given that the morphophonemic patterns already
do reflect the phonological restrictions, the only
places of further phonological interaction are the
prefix boundaries and the junction of the last letter of
the pattern with the very adjoining suffix. The rules
are implemented with -&gt;- and -&lt;-, respectively, and
are invoked from within the merge function:
</bodyText>
<reference confidence="0.2037706">
merge :: (Morphing a b, Template b) =&gt;
[Char] -&gt; a -&gt; [Char]
(-&gt;-) ::Prefix -&gt; [Char] -&gt; [Char]
(-&lt;-) ::Char -&gt; Suffix -&gt; [Char]
$Cf. some morphology-theoretic views in Spencer (2004).
</reference>
<equation confidence="0.900233285714286">
’I’ -&lt;- x = case x of
AT -&gt; &amp;quot;iyaT&amp;quot; ; Un -&gt; &amp;quot;Una&amp;quot;
Iy -&gt; &amp;quot;Iy&amp;quot; ; In -&gt; &amp;quot;Ina&amp;quot;
Suffix &amp;quot;&amp;quot; -&gt; &amp;quot;i&amp;quot;
Suffix &amp;quot;Una&amp;quot; -&gt; &amp;quot;Una&amp;quot;
Suffix &amp;quot;U&amp;quot; -&gt; &amp;quot;U&amp;quot;
Suffix &amp;quot;UW&amp;quot; -&gt; &amp;quot;UW&amp;quot;
Suffix &amp;quot;I&amp;quot; -&gt; &amp;quot;I&amp;quot;
Suffix x  |x ‘elem‘ [&amp;quot;i&amp;quot;, &amp;quot;u&amp;quot;] -&gt; &amp;quot;I&amp;quot;
x ‘elem‘ [ &amp;quot;iN&amp;quot;, &amp;quot;uN&amp;quot;] -&gt; &amp;quot;i N&amp;quot;
||
 |&amp;quot;n&amp;quot; ‘isPrefixOf‘ x
&amp;quot;t&amp;quot; ‘isPrefixOf‘ x -&gt; &amp;quot;I&amp;quot; ++ x
_ -&gt; &amp;quot;iy&amp;quot; ++ show x
</equation>
<bodyText confidence="0.999868461538462">
(-&lt;-) is likewise defined when matching on ’Y’,
’A’, ’U’, and when not matching. (-&gt;-) imple-
ments definite article assimilation and occasional
prefix interaction with weak verbs.
Nominal inflection is also driven by the informa-
tion from the lexicon and by phonology. The reader
might be noticing that the morphophonemic patterns
and the Morphs a templates are actually extremely
informative. We can use them as determining the in-
flectional class and the paradigm function, and thus
we can almost avoid other unintuitive or excessive
indicators of the kind of weak morphology, diptotic
inflection, and the like.
</bodyText>
<figure confidence="0.74637725">
�
.J»@ fem. pl. write!
~@~Q¯@~ du. &amp;quot;iqra’UA&amp;quot; iqra-¯u @ð ð
~ ~Q~~¯@~ pl.
��
fem.:
j
Suffix &amp;quot;Ina&amp;quot; -&gt; &amp;quot;Ina&amp;quot;
</figure>
<sectionHeader confidence="0.962867" genericHeader="conclusions">
6 Applications and Conclusion
</sectionHeader>
<bodyText confidence="0.9992896875">
The ElixirFM linguistic model and the data of the
lexicon can be integrated into larger applications or
used as standalone libraries and resources.
There is another, language-independent part of
the system that implements the compilation of the
inflected word forms and their associated mor-
phosyntactic categories into morphological analyz-
ers and generators. This part is adapted from (Fors-
berg and Ranta, 2004). The method used for analysis
is deterministic parsing with tries (Ljungl¨of, 2002).
ElixirFM also provides functions for exporting
and pretty-printing the linguistic model into XML,
LATEX, Perl, SQL, and other custom formats.
We have presented ElixirFM as a high-level func-
tional implementation of Functional Arabic Mor-
phology. Next to some theoretical points, we pro-
</bodyText>
<figure confidence="0.997054555555555">
á~~~~~
��&amp;quot;uktubna&amp;quot; uktubna
? [ merge &amp;quot;q r ’&amp;quot; (paraVerbC g n &amp;quot;i&amp;quot;
FCaL)  |g &lt;- values, n &lt;- values ] �
e
masc.: &amp;quot;iqra’ &amp;quot; iqra-
Q@~¯
e
@�sg.&amp;quot;iqra’A&amp;quot;iqra-¯a
</figure>
<page confidence="0.997038">
7
</page>
<bodyText confidence="0.99966505882353">
posed a model that represents the linguistic data
in an abstract and extensible notation that encodes
both orthography and phonology, and whose inter-
pretation is customizable. We developed a domain-
specific language in which the lexicon is stored and
which allows easy manual editing as well as auto-
matic verification of consistency. We believe that the
modeling of both the written language and the spo-
ken dialects can share the presented methodology.
ElixirFM and its lexicons are open-source soft-
ware licensed under GNU GPL and available on
http://sf.net/projects/elixir-fm/.
This work has been supported by the Ministry of
Education of the Czech Republic (MSM00216208-
38), by the Grant Agency of Charles University in
Prague (UK 373/2005), and by the Grant Agency of
the Czech Academy of Sciences (1ET101120413).
</bodyText>
<sectionHeader confidence="0.99917" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999891784810127">
Elsaid Badawi, Mike G. Carter, and Adrian Gully. 2004.
Modern Written Arabic: A Comprehensive Grammar.
Routledge.
Matthew Baerman, Dunstan Brown, and Greville G. Cor-
bett. 2006. The Syntax-Morphology Interface. A
Study of Syncretism. Cambridge Studies in Linguis-
tics. Cambridge University Press.
Kenneth R. Beesley. 2001. Finite-State Morphological
Analysis and Generation of Arabic at Xerox Research:
Status and Plans in 2001. In EACL 2001 Workshop
Proceedings on Arabic Language Processing: Status
and Prospects, pages 1–8, Toulouse, France.
Tim Buckwalter. 2002. Buckwalter Arabic Morpho-
logical Analyzer Version 1.0. LDC catalog number
LDC2002L49, ISBN 1-58563-257-0.
Ali El Dada and Aarne Ranta. 2006. Open Source Arabic
Grammars in Grammatical Framework. In Proceed-
ings of the Arabic Language Processing Conference
(JETALA), Rabat, Morocco, June 2006. IERA.
Wolfdietrich Fischer. 2001. A Grammar of Classical
Arabic. Yale Language Series. Yale University Press,
third revised edition. Translated by Jonathan Rodgers.
Markus Forsberg and Aarne Ranta. 2004. Functional
Morphology. In Proceedings of the Ninth ACM SIG-
PLAN International Conference on Functional Pro-
gramming, ICFP 2004, pages 213–223. ACM Press.
Nizar Habash, Owen Rambow, and George Kiraz. 2005.
Morphological Analysis and Generation for Arabic
Dialects. In Proceedings of the ACL Workshop
on Computational Approaches to Semitic Languages,
pages 17–24, Ann Arbor, Michigan. Association for
Computational Linguistics.
Nizar Habash. 2004. Large Scale Lexeme Based Ara-
bic Morphological Generation. In JEP-TALN 2004,
Session Traitement Automatique de l’Arabe, Fes, Mo-
rocco, April 2004.
Jan Hajiˇc, Otakar Smrˇz, Petr Zem´anek, Jan ˇSnaidauf, and
Emanuel Beˇska. 2004. Prague Arabic Dependency
Treebank: Development in Data and Tools. In NEM-
LAR International Conference on Arabic Language
Resources and Tools, pages 110–117. ELDA.
Paul Hudak. 2000. The Haskell School of Expression:
Learning Functional Programming through Multime-
dia. Cambridge University Press.
Mark P. Jones. 2000. Type Classes with Functional De-
pendencies. In ESOP ’00: Proceedings of the 9th Eu-
ropean Symposium on Programming Languages and
Systems, pages 230–244, London, UK. Springer.
Joost Kremers. 2003. The Arabic Noun Phrase. A
Minimalist Approach. Ph.D. thesis, University of Ni-
jmegen. LOT Dissertation Series 79.
Klaus Lagally. 2004. ArabTEX: Typesetting Arabic and
Hebrew, User Manual Version 4.00. Technical Report
2004/03, Fakult¨at Informatik, Universit¨at Stuttgart.
Peter Ljungl¨of. 2002. Pure Functional Parsing. An Ad-
vanced Tutorial. Licenciate thesis, G¨oteborg Univer-
sity &amp; Chalmers University of Technology.
Allan Ramsay and Hanady Mansur. 2001. Arabic mor-
phology: a categorial approach. In EACL 2001 Work-
shop Proceedings on Arabic Language Processing:
Status and Prospects, pages 17–22, Toulouse, France.
Otakar Smrˇz. 2007. FunctionalArabic Morphology. For-
mal System and Implementation. Ph.D. thesis, Charles
University in Prague.
Abdelhadi Soudi, Violetta Cavalli-Sforza, and Abder-
rahim Jamari. 2001. A Computational Lexeme-Based
Treatment of Arabic Morphology. In EACL 2001
Workshop Proceedings on Arabic Language Process-
ing: Status and Prospects, pages 155–162, Toulouse.
Andrew Spencer. 2004. Generalized Paradigm Function
Morphology. http://privatewww.essex.
ac.uk/˜spena/papers/GPFM.pdf, October 6.
Gregory T. Stump. 2001. Inflectional Morphology. A
Theory of Paradigm Structure. Cambridge Studies in
Linguistics. Cambridge University Press.
Philip Wadler. 2003. A Prettier Printer. In Jeremy
Gibbons and Oege de Moor, editors, The Fun of Pro-
gramming, Cornerstones of Computing, pages 223–
243. Palgrave Macmillan, March 2003.
</reference>
<page confidence="0.998493">
8
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.321917">
<title confidence="0.928365">ElixirFM — Implementation of Functional Arabic Morphology</title>
<author confidence="0.604983">Otakar</author>
<affiliation confidence="0.855587">Institute of Formal and Applied Faculty of Mathematics and Charles University in</affiliation>
<email confidence="0.777695">otakar.smrz@mff.cuni.cz</email>
<abstract confidence="0.992705307692307">Functional Arabic Morphology is a formulation of the Arabic inflectional system seeking the working interface between morphology and syntax. ElixirFM is its high-level implementation that reuses and extends the Functional Morphology library for Haskell. Inflection and derivation are modeled in terms of paradigms, grammatical categories, lexemes and word classes. The computation of analysis or generation is conceptually distinguished from the general-purpose linguistic model. The lexicon of ElixirFM is designed with respect to abstraction, yet is no more complicated than printed dictionaries. It is derived from the open-source Buckwalter lexicon and is enhanced with information sourcing from the syntactic annotations of the Prague Arabic Dependency Treebank. 1 Overview One can observe several different streams both in the computational and the purely linguistic modeling of morphology. Some are motivated by the need to analyze word forms as to their compositional structure, others consider word inflection as being driven by the underlying system of the language and the formal requirements of its grammar. In Section 2, before we focus on the principles of ElixirFM, we briefly follow the characterization of morphological theories presented by Stump (2001) and extend the classification to the most prominent computational models of Arabic morphology (Beesley, 2001; Buckwalter, 2002; Habash et al., 2005; El Dada and Ranta, 2006). In Section 3, we survey some of the categories of the syntax–morphology interface in Modern Written Arabic, as described by the Functional Arabic Morphology. In passing, we will introduce the basic concepts of programming in Haskell, a modern purely functional language that is an excellent choice for declarative generative modeling of morphologies, as Forsberg and Ranta (2004) have shown. Section 4 will be devoted to describing the lexicon of ElixirFM. We will develop a so-called domainspecific language embedded in Haskell with which we will achieve lexical definitions that are simultaneously a source code that can be checked for consistency, a data structure ready for rather independent processing, and still an easy-to-read-and-edit document resembling the printed dictionaries. In Section 5, we will illustrate how rules of inflection and derivation interact with the parameters of the grammar and the lexical information. We will demonstrate, also with reference to the Functional Morphology library (Forsberg and Ranta, 2004), the reusability of the system in many applications, including computational analysis and generation in various modes, exploring and exporting of the lexicon, printing of the inflectional paradigms, etc. 2 Morphological Models According to Stump (2001), morphological theories can be classified along two scales. The first one deals with the core or the process of inflection: associate word’s morphosyntactic with consider inflection as a result of on morphosyntactic prop- 1 of the 5th Workshop on Important Unresolved pages Czech Republic, June 2007. Association for Computational Linguistics are expressed by the relate the form in a given paradigm to the lexeme The second opposition concerns the question of inferability of meaning, and theories divide into: properties only in connection with acquiring the inflectional exponents of those properties of a set of properties with</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>merge</author>
</authors>
<title>(Morphing a b, Template b) =&gt; [Char] -&gt; a -&gt; [Char] (-&gt;-) ::Prefix -&gt; [Char] -&gt; [Char] (-&lt;-) ::Char -&gt; Suffix -&gt; [Char] $Cf. some morphology-theoretic views in Spencer</title>
<date>2004</date>
<publisher>Routledge.</publisher>
<marker>merge, 2004</marker>
<rawString>merge :: (Morphing a b, Template b) =&gt; [Char] -&gt; a -&gt; [Char] (-&gt;-) ::Prefix -&gt; [Char] -&gt; [Char] (-&lt;-) ::Char -&gt; Suffix -&gt; [Char] $Cf. some morphology-theoretic views in Spencer (2004). Modern Written Arabic: A Comprehensive Grammar. Routledge.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Matthew Baerman</author>
<author>Dunstan Brown</author>
<author>Greville G Corbett</author>
</authors>
<title>The Syntax-Morphology Interface. A Study of Syncretism. Cambridge Studies in Linguistics.</title>
<date>2006</date>
<publisher>Cambridge University Press.</publisher>
<contexts>
<context position="4009" citStr="Baerman et al. (2006)" startWordPosition="594" endWordPosition="597">putational Linguistics erties are expressed by the rules that relate the form in a given paradigm to the lexeme The second opposition concerns the question of inferability of meaning, and theories divide into: incremental words acquire morphosyntactic properties only in connection with acquiring the inflectional exponents of those properties realizational association of a set of properties with a word licenses the introduction of the exponents into the word’s morphology Evidence favoring inferential–realizational theories over the other three approaches is presented by Stump (2001) as well as Baerman et al. (2006) or Spencer (2004). In trying to classify the implementations of Arabic morphological models, let us reconsider this cross-linguistic observation: The morphosyntactic properties associated with an inflected word’s individual inflectional markings may underdetermine the properties associated with the word as a whole. (Stump, 2001, p. 7) How do the current morphological analyzers interpret, for instance, the number and gender of the Arabic broken masculine plurals ˇgudud ��new ones or qud. ¯ah SLQs judges, or the case of mustawan � j��-.A j a level? Do they identify the values of these features </context>
</contexts>
<marker>Baerman, Brown, Corbett, 2006</marker>
<rawString>Matthew Baerman, Dunstan Brown, and Greville G. Corbett. 2006. The Syntax-Morphology Interface. A Study of Syncretism. Cambridge Studies in Linguistics. Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth R Beesley</author>
</authors>
<title>Finite-State Morphological Analysis and Generation of Arabic at Xerox Research: Status and Plans in</title>
<date>2001</date>
<booktitle>In EACL 2001 Workshop Proceedings on Arabic Language Processing: Status and Prospects,</booktitle>
<pages>1--8</pages>
<location>Toulouse, France.</location>
<contexts>
<context position="1592" citStr="Beesley, 2001" startWordPosition="232" endWordPosition="233"> 1 Overview One can observe several different streams both in the computational and the purely linguistic modeling of morphology. Some are motivated by the need to analyze word forms as to their compositional structure, others consider word inflection as being driven by the underlying system of the language and the formal requirements of its grammar. In Section 2, before we focus on the principles of ElixirFM, we briefly follow the characterization of morphological theories presented by Stump (2001) and extend the classification to the most prominent computational models of Arabic morphology (Beesley, 2001; Buckwalter, 2002; Habash et al., 2005; El Dada and Ranta, 2006). In Section 3, we survey some of the categories of the syntax–morphology interface in Modern Written Arabic, as described by the Functional Arabic Morphology. In passing, we will introduce the basic concepts of programming in Haskell, a modern purely functional language that is an excellent choice for declarative generative modeling of morphologies, as Forsberg and Ranta (2004) have shown. Section 4 will be devoted to describing the lexicon of ElixirFM. We will develop a so-called domainspecific language embedded in Haskell with</context>
<context position="4850" citStr="Beesley, 2001" startWordPosition="729" endWordPosition="730">flectional markings may underdetermine the properties associated with the word as a whole. (Stump, 2001, p. 7) How do the current morphological analyzers interpret, for instance, the number and gender of the Arabic broken masculine plurals ˇgudud ��new ones or qud. ¯ah SLQs judges, or the case of mustawan � j��-.A j a level? Do they identify the values of these features that the syntax actually operates with, or is the resolution hindered by some too generic assumptions about the relation between meaning and form? Many of the computational models of Arabic morphology, including in particular (Beesley, 2001), (Ramsay and Mansur, 2001) or (Buckwalter, 2002), are lexical in nature. As they are not designed in connection with any syntax–morphology interface, their interpretations are destined to be incremental. Some signs of a lexical–realizational system can be found in (Habash, 2004). The author mentions and fixes the problem of underdetermination of inherent number with broken plurals, when developing a generative counterpart to (Buckwalter, 2002). The computational models in (Soudi et al., 2001) and (Habash et al., 2005) attempt the inferential– realizational direction. Unfortunately, they imple</context>
</contexts>
<marker>Beesley, 2001</marker>
<rawString>Kenneth R. Beesley. 2001. Finite-State Morphological Analysis and Generation of Arabic at Xerox Research: Status and Plans in 2001. In EACL 2001 Workshop Proceedings on Arabic Language Processing: Status and Prospects, pages 1–8, Toulouse, France.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tim Buckwalter</author>
</authors>
<date>2002</date>
<booktitle>Buckwalter Arabic Morphological Analyzer Version 1.0. LDC catalog number LDC2002L49, ISBN</booktitle>
<pages>1--58563</pages>
<contexts>
<context position="1610" citStr="Buckwalter, 2002" startWordPosition="234" endWordPosition="235"> can observe several different streams both in the computational and the purely linguistic modeling of morphology. Some are motivated by the need to analyze word forms as to their compositional structure, others consider word inflection as being driven by the underlying system of the language and the formal requirements of its grammar. In Section 2, before we focus on the principles of ElixirFM, we briefly follow the characterization of morphological theories presented by Stump (2001) and extend the classification to the most prominent computational models of Arabic morphology (Beesley, 2001; Buckwalter, 2002; Habash et al., 2005; El Dada and Ranta, 2006). In Section 3, we survey some of the categories of the syntax–morphology interface in Modern Written Arabic, as described by the Functional Arabic Morphology. In passing, we will introduce the basic concepts of programming in Haskell, a modern purely functional language that is an excellent choice for declarative generative modeling of morphologies, as Forsberg and Ranta (2004) have shown. Section 4 will be devoted to describing the lexicon of ElixirFM. We will develop a so-called domainspecific language embedded in Haskell with which we will ach</context>
<context position="4899" citStr="Buckwalter, 2002" startWordPosition="736" endWordPosition="737">perties associated with the word as a whole. (Stump, 2001, p. 7) How do the current morphological analyzers interpret, for instance, the number and gender of the Arabic broken masculine plurals ˇgudud ��new ones or qud. ¯ah SLQs judges, or the case of mustawan � j��-.A j a level? Do they identify the values of these features that the syntax actually operates with, or is the resolution hindered by some too generic assumptions about the relation between meaning and form? Many of the computational models of Arabic morphology, including in particular (Beesley, 2001), (Ramsay and Mansur, 2001) or (Buckwalter, 2002), are lexical in nature. As they are not designed in connection with any syntax–morphology interface, their interpretations are destined to be incremental. Some signs of a lexical–realizational system can be found in (Habash, 2004). The author mentions and fixes the problem of underdetermination of inherent number with broken plurals, when developing a generative counterpart to (Buckwalter, 2002). The computational models in (Soudi et al., 2001) and (Habash et al., 2005) attempt the inferential– realizational direction. Unfortunately, they implement only sections of the Arabic morphological sy</context>
<context position="19285" citStr="Buckwalter, 2002" startWordPosition="3160" endWordPosition="3161">g a lightweight, yet expressive, embedded language. In Figure 1, each entry reduces to a record of type Entry PatternT reflecting internally the lexeme’s inherent properties. Consider one such reduction below. Functions like plural or gender or humanness could further modify the Noun’s default information: ? FiCAL |&lt; aT ‘noun‘ [ &amp;quot;writing&amp;quot; ] --+ noun (FiCAL |&lt; aT) [ &amp;quot;writing&amp;quot; ] --+ Entry (Noun [] Nothing Nothing) (morph (FiCAL |&lt; aT)) [ &amp;quot;writing&amp;quot; ] __+ Entry (Noun [] Nothing Nothing) (Morphs FiCAL [] [AT]) [ &amp;quot;writing&amp;quot; ] The lexicon of ElixirFM is derived from the opensource Buckwalter lexicon (Buckwalter, 2002).5 We devised an algorithm in Perl using the morpho5Habash (2004) comments on the lexicon’s internal format. 5 data Mood = Indicative |Subjunctive |Jussive |Energetic deriving (Eq, Enum) data Gender = Masculine |Feminine deriving (Eq, Enum) data ParaVerb = VerbP Voice Person Gender Number |VerbI Mood Voice Person Gender Number |VerbC Gender Number deriving Eq paraVerbC :: Morphing a b =&gt; Gender -&gt; Number -&gt; [Char] -&gt; a -&gt; Morphs b paraVerbC g n i = case n of Singular -&gt; case g of Masculine -&gt; prefix i . suffix &amp;quot;&amp;quot; Feminine -&gt; prefix i . suffix &amp;quot;I&amp;quot; Plural -&gt; case g of Masculine -&gt; prefix i . suf</context>
</contexts>
<marker>Buckwalter, 2002</marker>
<rawString>Tim Buckwalter. 2002. Buckwalter Arabic Morphological Analyzer Version 1.0. LDC catalog number LDC2002L49, ISBN 1-58563-257-0.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ali El Dada</author>
<author>Aarne Ranta</author>
</authors>
<title>Open Source Arabic Grammars in Grammatical Framework.</title>
<date>2006</date>
<booktitle>In Proceedings of the Arabic Language Processing Conference (JETALA),</booktitle>
<publisher>IERA.</publisher>
<location>Rabat, Morocco,</location>
<marker>El Dada, Ranta, 2006</marker>
<rawString>Ali El Dada and Aarne Ranta. 2006. Open Source Arabic Grammars in Grammatical Framework. In Proceedings of the Arabic Language Processing Conference (JETALA), Rabat, Morocco, June 2006. IERA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Wolfdietrich Fischer</author>
</authors>
<title>A Grammar of Classical Arabic. Yale Language Series.</title>
<date>2001</date>
<publisher>Yale University Press,</publisher>
<note>third revised edition. Translated by Jonathan Rodgers.</note>
<contexts>
<context position="5746" citStr="Fischer, 2001" startWordPosition="862" endWordPosition="863">The author mentions and fixes the problem of underdetermination of inherent number with broken plurals, when developing a generative counterpart to (Buckwalter, 2002). The computational models in (Soudi et al., 2001) and (Habash et al., 2005) attempt the inferential– realizational direction. Unfortunately, they implement only sections of the Arabic morphological system. The Arabic resource grammar in the Grammatical Framework (El Dada and Ranta, 2006) is perhaps the most complete inferential–realizational implementation to date. Its style is compatible with the linguistic description in e.g. (Fischer, 2001) or (Badawi et al., 2004), but the lexicon is now very limited and some other extensions for data-oriented computational applications are still needed. ElixirFM is inspired by the methodology in (Forsberg and Ranta, 2004) and by functional programming, just like the Arabic GF is (El Dada and Ranta, 2006). Nonetheless, ElixirFM reuses the Buckwalter lexicon (2002) and the annotations in the Prague Arabic Dependency Treebank (Hajiˇc et al., 2004), and implements yet more refined linguistic model. 3 Morphosyntactic Categories Functional Arabic Morphology and ElixirFM reestablish the system of inf</context>
</contexts>
<marker>Fischer, 2001</marker>
<rawString>Wolfdietrich Fischer. 2001. A Grammar of Classical Arabic. Yale Language Series. Yale University Press, third revised edition. Translated by Jonathan Rodgers.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Markus Forsberg</author>
<author>Aarne Ranta</author>
</authors>
<title>Functional Morphology.</title>
<date>2004</date>
<booktitle>In Proceedings of the Ninth ACM SIGPLAN International Conference on Functional Programming, ICFP</booktitle>
<pages>213--223</pages>
<publisher>ACM Press.</publisher>
<contexts>
<context position="2038" citStr="Forsberg and Ranta (2004)" startWordPosition="300" endWordPosition="303">e characterization of morphological theories presented by Stump (2001) and extend the classification to the most prominent computational models of Arabic morphology (Beesley, 2001; Buckwalter, 2002; Habash et al., 2005; El Dada and Ranta, 2006). In Section 3, we survey some of the categories of the syntax–morphology interface in Modern Written Arabic, as described by the Functional Arabic Morphology. In passing, we will introduce the basic concepts of programming in Haskell, a modern purely functional language that is an excellent choice for declarative generative modeling of morphologies, as Forsberg and Ranta (2004) have shown. Section 4 will be devoted to describing the lexicon of ElixirFM. We will develop a so-called domainspecific language embedded in Haskell with which we will achieve lexical definitions that are simultaneously a source code that can be checked for consistency, a data structure ready for rather independent processing, and still an easy-to-read-and-edit document resembling the printed dictionaries. In Section 5, we will illustrate how rules of inflection and derivation interact with the parameters of the grammar and the lexical information. We will demonstrate, also with reference to </context>
<context position="5967" citStr="Forsberg and Ranta, 2004" startWordPosition="894" endWordPosition="898"> 2001) and (Habash et al., 2005) attempt the inferential– realizational direction. Unfortunately, they implement only sections of the Arabic morphological system. The Arabic resource grammar in the Grammatical Framework (El Dada and Ranta, 2006) is perhaps the most complete inferential–realizational implementation to date. Its style is compatible with the linguistic description in e.g. (Fischer, 2001) or (Badawi et al., 2004), but the lexicon is now very limited and some other extensions for data-oriented computational applications are still needed. ElixirFM is inspired by the methodology in (Forsberg and Ranta, 2004) and by functional programming, just like the Arabic GF is (El Dada and Ranta, 2006). Nonetheless, ElixirFM reuses the Buckwalter lexicon (2002) and the annotations in the Prague Arabic Dependency Treebank (Hajiˇc et al., 2004), and implements yet more refined linguistic model. 3 Morphosyntactic Categories Functional Arabic Morphology and ElixirFM reestablish the system of inflectional and inherent morphosyntactic properties (alternatively named grammatical categories or features) and distinguish precisely the senses of their use in the grammar. In Haskell, all these categories can be represen</context>
<context position="22821" citStr="Forsberg and Ranta, 2004" startWordPosition="3748" endWordPosition="3751">cted in gender and number only.7 The paradigm for inflecting imperatives, the one and only such paradigm in ElixirFM, is implemented as paraVerbC. It is a function parametrized by some particular value of gender g and number n. It further takes the initial imperative prefix i and the verbal stem (both inferred from the morphophonemic patterns in the lexical entry) to yield the inflected imperative form. Note the polymorphic type of the function, which depends on the following: prefix, suffix :: Morphing a b =&gt; [Char] -&gt; a -&gt; Morphs b prefix x y = Prefix x &gt; |y suffix x y = y |&lt; Suffix x 7Cf. (Forsberg and Ranta, 2004; El Dada and Ranta, 2006). 6 If one wished to reuse the paradigm and apply it on strings only, it would be sufficient to equate these functions with standard list operations, without any need to reimplement the paradigm itself. The definition of paraVerbC is simple and concise due to the chance to compose with . the partially applied prefix and suffix functions and to virtually omit the next argument. This advanced formulation may seem not as minimal as when specifying the literal endings or prefixes, but we present it here to illustrate the options that there are. An abstract paradigm can be</context>
</contexts>
<marker>Forsberg, Ranta, 2004</marker>
<rawString>Markus Forsberg and Aarne Ranta. 2004. Functional Morphology. In Proceedings of the Ninth ACM SIGPLAN International Conference on Functional Programming, ICFP 2004, pages 213–223. ACM Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Nizar Habash</author>
<author>Owen Rambow</author>
<author>George Kiraz</author>
</authors>
<title>Morphological Analysis and Generation for Arabic Dialects.</title>
<date>2005</date>
<booktitle>In Proceedings of the ACL Workshop on Computational Approaches to Semitic Languages,</booktitle>
<pages>17--24</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<location>Ann Arbor, Michigan.</location>
<contexts>
<context position="1631" citStr="Habash et al., 2005" startWordPosition="236" endWordPosition="239">al different streams both in the computational and the purely linguistic modeling of morphology. Some are motivated by the need to analyze word forms as to their compositional structure, others consider word inflection as being driven by the underlying system of the language and the formal requirements of its grammar. In Section 2, before we focus on the principles of ElixirFM, we briefly follow the characterization of morphological theories presented by Stump (2001) and extend the classification to the most prominent computational models of Arabic morphology (Beesley, 2001; Buckwalter, 2002; Habash et al., 2005; El Dada and Ranta, 2006). In Section 3, we survey some of the categories of the syntax–morphology interface in Modern Written Arabic, as described by the Functional Arabic Morphology. In passing, we will introduce the basic concepts of programming in Haskell, a modern purely functional language that is an excellent choice for declarative generative modeling of morphologies, as Forsberg and Ranta (2004) have shown. Section 4 will be devoted to describing the lexicon of ElixirFM. We will develop a so-called domainspecific language embedded in Haskell with which we will achieve lexical definiti</context>
<context position="5374" citStr="Habash et al., 2005" startWordPosition="806" endWordPosition="809">? Many of the computational models of Arabic morphology, including in particular (Beesley, 2001), (Ramsay and Mansur, 2001) or (Buckwalter, 2002), are lexical in nature. As they are not designed in connection with any syntax–morphology interface, their interpretations are destined to be incremental. Some signs of a lexical–realizational system can be found in (Habash, 2004). The author mentions and fixes the problem of underdetermination of inherent number with broken plurals, when developing a generative counterpart to (Buckwalter, 2002). The computational models in (Soudi et al., 2001) and (Habash et al., 2005) attempt the inferential– realizational direction. Unfortunately, they implement only sections of the Arabic morphological system. The Arabic resource grammar in the Grammatical Framework (El Dada and Ranta, 2006) is perhaps the most complete inferential–realizational implementation to date. Its style is compatible with the linguistic description in e.g. (Fischer, 2001) or (Badawi et al., 2004), but the lexicon is now very limited and some other extensions for data-oriented computational applications are still needed. ElixirFM is inspired by the methodology in (Forsberg and Ranta, 2004) and by</context>
<context position="13021" citStr="Habash et al., 2005" startWordPosition="2082" endWordPosition="2085">etermined by the NounS constructor, so we need not type anything explicitly. We used the list comprehension syntax to cycle over the lists that enum and values produce, cf. (Hudak, 2000). 4 ElixirFM Lexicon Unstructured text is just a list of characters, or string: type String = [Char] Yet words do have structure, particularly in Arabic. We will work with strings as the superficial word forms, but the internal representations will be more abstract (and computationally more efficient, too). The definition of lexemes can include the derivational root and pattern information if appropriate, cf. (Habash et al., 2005), and our model will encourage this. The surface word kit¯ab H. As� book can decompose to the triconsonantal root k t b I. .»and the morphophonemic pattern FiCAL of type PatternT: data PatternT = FaCaL |FAL |FaCY | FiCAL |FuCCAL |{- ... -} MustaFCaL |MustaFaCL deriving (Eq, Enum, Show) The deriving clause associates PatternT with methods for testing equality, enumerating all the values, and turning the names of the values into strings: ? show FiCAL → &amp;quot;FiCAL&amp;quot; We choose to build on morphophonemic patterns rather than CV patterns and vocalisms. Words like istaˇg¯ab H. A�j.�:ƒ@~ to respond and ist</context>
</contexts>
<marker>Habash, Rambow, Kiraz, 2005</marker>
<rawString>Nizar Habash, Owen Rambow, and George Kiraz. 2005. Morphological Analysis and Generation for Arabic Dialects. In Proceedings of the ACL Workshop on Computational Approaches to Semitic Languages, pages 17–24, Ann Arbor, Michigan. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Nizar Habash</author>
</authors>
<title>Large Scale Lexeme Based Arabic Morphological Generation.</title>
<date>2004</date>
<booktitle>In JEP-TALN 2004, Session Traitement Automatique de l’Arabe,</booktitle>
<location>Fes, Morocco,</location>
<contexts>
<context position="5130" citStr="Habash, 2004" startWordPosition="770" endWordPosition="771">, or the case of mustawan � j��-.A j a level? Do they identify the values of these features that the syntax actually operates with, or is the resolution hindered by some too generic assumptions about the relation between meaning and form? Many of the computational models of Arabic morphology, including in particular (Beesley, 2001), (Ramsay and Mansur, 2001) or (Buckwalter, 2002), are lexical in nature. As they are not designed in connection with any syntax–morphology interface, their interpretations are destined to be incremental. Some signs of a lexical–realizational system can be found in (Habash, 2004). The author mentions and fixes the problem of underdetermination of inherent number with broken plurals, when developing a generative counterpart to (Buckwalter, 2002). The computational models in (Soudi et al., 2001) and (Habash et al., 2005) attempt the inferential– realizational direction. Unfortunately, they implement only sections of the Arabic morphological system. The Arabic resource grammar in the Grammatical Framework (El Dada and Ranta, 2006) is perhaps the most complete inferential–realizational implementation to date. Its style is compatible with the linguistic description in e.g.</context>
<context position="19350" citStr="Habash (2004)" startWordPosition="3170" endWordPosition="3172"> entry reduces to a record of type Entry PatternT reflecting internally the lexeme’s inherent properties. Consider one such reduction below. Functions like plural or gender or humanness could further modify the Noun’s default information: ? FiCAL |&lt; aT ‘noun‘ [ &amp;quot;writing&amp;quot; ] --+ noun (FiCAL |&lt; aT) [ &amp;quot;writing&amp;quot; ] --+ Entry (Noun [] Nothing Nothing) (morph (FiCAL |&lt; aT)) [ &amp;quot;writing&amp;quot; ] __+ Entry (Noun [] Nothing Nothing) (Morphs FiCAL [] [AT]) [ &amp;quot;writing&amp;quot; ] The lexicon of ElixirFM is derived from the opensource Buckwalter lexicon (Buckwalter, 2002).5 We devised an algorithm in Perl using the morpho5Habash (2004) comments on the lexicon’s internal format. 5 data Mood = Indicative |Subjunctive |Jussive |Energetic deriving (Eq, Enum) data Gender = Masculine |Feminine deriving (Eq, Enum) data ParaVerb = VerbP Voice Person Gender Number |VerbI Mood Voice Person Gender Number |VerbC Gender Number deriving Eq paraVerbC :: Morphing a b =&gt; Gender -&gt; Number -&gt; [Char] -&gt; a -&gt; Morphs b paraVerbC g n i = case n of Singular -&gt; case g of Masculine -&gt; prefix i . suffix &amp;quot;&amp;quot; Feminine -&gt; prefix i . suffix &amp;quot;I&amp;quot; Plural -&gt; case g of Masculine -&gt; prefix i . suffix &amp;quot;UW&amp;quot; Feminine -&gt; prefix i . suffix &amp;quot;na&amp;quot; _ -&gt; prefix i . suffi</context>
</contexts>
<marker>Habash, 2004</marker>
<rawString>Nizar Habash. 2004. Large Scale Lexeme Based Arabic Morphological Generation. In JEP-TALN 2004, Session Traitement Automatique de l’Arabe, Fes, Morocco, April 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jan Hajiˇc</author>
<author>Otakar Smrˇz</author>
<author>Petr Zem´anek</author>
<author>Jan ˇSnaidauf</author>
<author>Emanuel Beˇska</author>
</authors>
<title>Prague Arabic Dependency Treebank: Development in Data and Tools.</title>
<date>2004</date>
<booktitle>In NEMLAR International Conference on Arabic Language Resources and Tools,</booktitle>
<pages>110--117</pages>
<publisher>ELDA.</publisher>
<marker>Hajiˇc, Smrˇz, Zem´anek, ˇSnaidauf, Beˇska, 2004</marker>
<rawString>Jan Hajiˇc, Otakar Smrˇz, Petr Zem´anek, Jan ˇSnaidauf, and Emanuel Beˇska. 2004. Prague Arabic Dependency Treebank: Development in Data and Tools. In NEMLAR International Conference on Arabic Language Resources and Tools, pages 110–117. ELDA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Paul Hudak</author>
</authors>
<title>The Haskell School of Expression: Learning Functional Programming through Multimedia.</title>
<date>2000</date>
<publisher>Cambridge University Press.</publisher>
<contexts>
<context position="12587" citStr="Hudak, 2000" startWordPosition="2016" endWordPosition="2017">tion values is analogous to enum, and both need to know their type before they can evaluate. 3With Just False True, we can annotate e.g. the underdetermined : in hum-u they-are highs-of the-level, i.e. they are the high-level :-: ‘incorrectly’ raf¯~�¯uñ J��¯~P~ ’l-mas�¯ul¯unaraf¯~�¯u’l-mustaw¯a øñ�J‚ÖÏ@ ñ�ªJ��¯� P~ �àñËð �ñ‚ÖÏ@ Ñë theof�cials of�cials. 3 The ‘magic’ is that the bound variables n, c, and s have their type determined by the NounS constructor, so we need not type anything explicitly. We used the list comprehension syntax to cycle over the lists that enum and values produce, cf. (Hudak, 2000). 4 ElixirFM Lexicon Unstructured text is just a list of characters, or string: type String = [Char] Yet words do have structure, particularly in Arabic. We will work with strings as the superficial word forms, but the internal representations will be more abstract (and computationally more efficient, too). The definition of lexemes can include the derivational root and pattern information if appropriate, cf. (Habash et al., 2005), and our model will encourage this. The surface word kit¯ab H. As� book can decompose to the triconsonantal root k t b I. .»and the morphophonemic pattern FiCAL of t</context>
</contexts>
<marker>Hudak, 2000</marker>
<rawString>Paul Hudak. 2000. The Haskell School of Expression: Learning Functional Programming through Multimedia. Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark P Jones</author>
</authors>
<title>Type Classes with Functional Dependencies.</title>
<date>2000</date>
<booktitle>In ESOP ’00: Proceedings of the 9th European Symposium on Programming Languages and Systems,</booktitle>
<pages>230--244</pages>
<publisher>UK. Springer.</publisher>
<location>London,</location>
<contexts>
<context position="16074" citStr="Jones, 2000" startWordPosition="2600" endWordPosition="2601"> quadriliteral PatternQ or a nontemplatic word stem Identity of type PatternL: data PatternL = Identity data PatternQ = KaRDaS |KaRADiS {- ... -} data Morphs a = Morphs a [Prefix] [Suffix] ~ B wireless can thus be decomposed as the root s l k 1/2Êƒ and the value � � Morphs FiCL [LA] [Iy]. Shunning such concrete representations, we define new operators &gt; |and |&lt; that denote prefixes, resp. suffixes, inside Morphs a: ? lA &gt; |FiCL |&lt; Iy → Morphs FiCL [LA][Iy] Implementing &gt; |and |&lt; to be applicable in the intuitive way required Haskell’s multi-parameter type classes with functional dependencies (Jones, 2000): class Morphing a b |a -&gt; b where morph :: a -&gt; Morphs b instance Morphing (Morphs a) a where morph = id instance Morphing PatternT PatternT where morph x = Morphs x [] [] The instance declarations ensure how the morph method would turn values of type a into Morphs b. 4http://sf.net/projects/encode-arabic/ The word l¯a-silk¯ıy ú~3/4Êƒ&amp;quot; 4 |&gt; &amp;quot;k t b&amp;quot; &lt; |[ FaCaL ‘verb‘ [ &amp;quot;write&amp;quot;, FiCAL ‘noun‘ [ &amp;quot;book&amp;quot; ] FiCAL |&lt; aT ‘noun‘ [ &amp;quot;writing&amp;quot; FiCAL |&lt; aT ‘noun‘ [ &amp;quot;essay&amp;quot;, FACiL |&lt; Iy ‘noun‘ [ &amp;quot;writer&amp;quot;, FuCCAL ‘noun‘ [ &amp;quot;kuttab&amp;quot;, MaFCaL ‘noun‘ [ &amp;quot;office&amp;quot;, MaFCaL ‘adj‘ [ &amp;quot;office&amp;quot; MaFCaL |&lt; aT ‘noun‘ [ &amp;quot;libr</context>
</contexts>
<marker>Jones, 2000</marker>
<rawString>Mark P. Jones. 2000. Type Classes with Functional Dependencies. In ESOP ’00: Proceedings of the 9th European Symposium on Programming Languages and Systems, pages 230–244, London, UK. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joost Kremers</author>
</authors>
<title>The Arabic Noun Phrase. A Minimalist Approach.</title>
<date>2003</date>
<journal>LOT Dissertation Series</journal>
<tech>Ph.D. thesis,</tech>
<volume>79</volume>
<institution>University of Nijmegen.</institution>
<contexts>
<context position="21422" citStr="Kremers, 2003" startWordPosition="3516" endWordPosition="3517">ominal parts of speech need to be enhanced with information on the inherent number, gender and humanness, if proper modeling of linguistic agreement in Arabic is desired.6 Experiments with the Prague Arabic Dependency Treebank (Hajiˇc et al., 2004) show that this information can be learned from annotations of syntactic relations (Smrˇz, 2007). 5 Morphological Rules Inferential–realizational morphology is modeled in terms of paradigms, grammatical categories, lexemes and word classes. ElixirFM implements the comprehensive rules that draw the information from 6Cf. e.g. (El Dada and Ranta, 2006; Kremers, 2003). the lexicon and generate the word forms given the appropriate morphosyntactic parameters. The whole is invoked through a convenient inflect method. The lexicon and the parameters determine the choice of paradigms. The template selection mechanism differs for nominals (providing plurals) and for verbs (providing all needed stem alternations in the extent of the entry specifications of e.g. Hans Wehr’s dictionary), yet it is quite clear-cut (Smrˇz, 2007). In Figure 2, the algebraic data type ParaVerb restricts the space in which verbs are inflected by defining three Cartesian products of the e</context>
</contexts>
<marker>Kremers, 2003</marker>
<rawString>Joost Kremers. 2003. The Arabic Noun Phrase. A Minimalist Approach. Ph.D. thesis, University of Nijmegen. LOT Dissertation Series 79.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Klaus Lagally</author>
</authors>
<title>ArabTEX: Typesetting Arabic and Hebrew, User Manual Version 4.00.</title>
<date>2004</date>
<tech>Technical Report 2004/03,</tech>
<institution>Fakult¨at Informatik, Universit¨at Stuttgart.</institution>
<contexts>
<context position="14564" citStr="Lagally, 2004" startWordPosition="2342" endWordPosition="2343">ding to their relationship. Morphophonemic patterns deliver more information in a more compact way. Of course, ElixirFM provides functions for properly interlocking the patterns with the roots: ? merge &amp;quot;k t b&amp;quot; FiCAL → &amp;quot;kitAb&amp;quot; ? merge &amp;quot;-g w b&amp;quot; IstaFAL → &amp;quot;ista-gAb&amp;quot; ? merge &amp;quot;-g w b&amp;quot; IstaFCaL → &amp;quot;ista-gwab&amp;quot; ? merge &amp;quot;s ’ l&amp;quot; MaFCUL → &amp;quot;mas’Ul&amp;quot; ? merge &amp;quot;z h r&amp;quot; IFtaCaL → &amp;quot;izdahar&amp;quot; The izdahar QmS,@~ to flourish case exemplifies that exceptionless assimilations need not be encoded in the patterns, but can instead be hidden in rules. The whole generative model adopts the multipurpose notation of ArabTEX (Lagally, 2004) as a meta-encoding of both the orthography and phonology. Therefore, instantiation of the &amp;quot;’&amp;quot; hamza carriers or other merely orthographic conventions do not obscure the morphological model. With Encode Arabic4 interpreting the notation, ElixirFM can at the surface level process the original Arabic script (non-)vocalized to any degree or work with some kind of transliteration or even transcription thereof. Morphophonemic patterns represent the stems of words. The various kinds of abstract prefixes and suffixes can be expressed either as atomic values, or as literal strings wrapped into extra c</context>
</contexts>
<marker>Lagally, 2004</marker>
<rawString>Klaus Lagally. 2004. ArabTEX: Typesetting Arabic and Hebrew, User Manual Version 4.00. Technical Report 2004/03, Fakult¨at Informatik, Universit¨at Stuttgart.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Peter Ljungl¨of</author>
</authors>
<title>Pure Functional Parsing. An Advanced Tutorial. Licenciate thesis,</title>
<date>2002</date>
<institution>G¨oteborg University &amp; Chalmers University of Technology.</institution>
<marker>Ljungl¨of, 2002</marker>
<rawString>Peter Ljungl¨of. 2002. Pure Functional Parsing. An Advanced Tutorial. Licenciate thesis, G¨oteborg University &amp; Chalmers University of Technology.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Allan Ramsay</author>
<author>Hanady Mansur</author>
</authors>
<title>Arabic morphology: a categorial approach.</title>
<date>2001</date>
<booktitle>In EACL 2001 Workshop Proceedings on Arabic Language Processing: Status and Prospects,</booktitle>
<pages>17--22</pages>
<location>Toulouse, France.</location>
<contexts>
<context position="4877" citStr="Ramsay and Mansur, 2001" startWordPosition="731" endWordPosition="734">gs may underdetermine the properties associated with the word as a whole. (Stump, 2001, p. 7) How do the current morphological analyzers interpret, for instance, the number and gender of the Arabic broken masculine plurals ˇgudud ��new ones or qud. ¯ah SLQs judges, or the case of mustawan � j��-.A j a level? Do they identify the values of these features that the syntax actually operates with, or is the resolution hindered by some too generic assumptions about the relation between meaning and form? Many of the computational models of Arabic morphology, including in particular (Beesley, 2001), (Ramsay and Mansur, 2001) or (Buckwalter, 2002), are lexical in nature. As they are not designed in connection with any syntax–morphology interface, their interpretations are destined to be incremental. Some signs of a lexical–realizational system can be found in (Habash, 2004). The author mentions and fixes the problem of underdetermination of inherent number with broken plurals, when developing a generative counterpart to (Buckwalter, 2002). The computational models in (Soudi et al., 2001) and (Habash et al., 2005) attempt the inferential– realizational direction. Unfortunately, they implement only sections of the A</context>
</contexts>
<marker>Ramsay, Mansur, 2001</marker>
<rawString>Allan Ramsay and Hanady Mansur. 2001. Arabic morphology: a categorial approach. In EACL 2001 Workshop Proceedings on Arabic Language Processing: Status and Prospects, pages 17–22, Toulouse, France.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Otakar Smrˇz</author>
</authors>
<title>FunctionalArabic Morphology. Formal System and Implementation.</title>
<date>2007</date>
<tech>Ph.D. thesis,</tech>
<institution>Charles University in Prague.</institution>
<marker>Smrˇz, 2007</marker>
<rawString>Otakar Smrˇz. 2007. FunctionalArabic Morphology. Formal System and Implementation. Ph.D. thesis, Charles University in Prague.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Abdelhadi Soudi</author>
<author>Violetta Cavalli-Sforza</author>
<author>Abderrahim Jamari</author>
</authors>
<title>A Computational Lexeme-Based Treatment of Arabic Morphology.</title>
<date>2001</date>
<booktitle>In EACL 2001 Workshop Proceedings on Arabic Language Processing: Status and Prospects,</booktitle>
<pages>155--162</pages>
<location>Toulouse.</location>
<contexts>
<context position="5348" citStr="Soudi et al., 2001" startWordPosition="801" endWordPosition="804"> between meaning and form? Many of the computational models of Arabic morphology, including in particular (Beesley, 2001), (Ramsay and Mansur, 2001) or (Buckwalter, 2002), are lexical in nature. As they are not designed in connection with any syntax–morphology interface, their interpretations are destined to be incremental. Some signs of a lexical–realizational system can be found in (Habash, 2004). The author mentions and fixes the problem of underdetermination of inherent number with broken plurals, when developing a generative counterpart to (Buckwalter, 2002). The computational models in (Soudi et al., 2001) and (Habash et al., 2005) attempt the inferential– realizational direction. Unfortunately, they implement only sections of the Arabic morphological system. The Arabic resource grammar in the Grammatical Framework (El Dada and Ranta, 2006) is perhaps the most complete inferential–realizational implementation to date. Its style is compatible with the linguistic description in e.g. (Fischer, 2001) or (Badawi et al., 2004), but the lexicon is now very limited and some other extensions for data-oriented computational applications are still needed. ElixirFM is inspired by the methodology in (Forsbe</context>
</contexts>
<marker>Soudi, Cavalli-Sforza, Jamari, 2001</marker>
<rawString>Abdelhadi Soudi, Violetta Cavalli-Sforza, and Abderrahim Jamari. 2001. A Computational Lexeme-Based Treatment of Arabic Morphology. In EACL 2001 Workshop Proceedings on Arabic Language Processing: Status and Prospects, pages 155–162, Toulouse.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andrew Spencer</author>
</authors>
<title>Generalized Paradigm Function Morphology.</title>
<date>2004</date>
<note>http://privatewww.essex. ac.uk/˜spena/papers/GPFM.pdf,</note>
<contexts>
<context position="4027" citStr="Spencer (2004)" startWordPosition="599" endWordPosition="600">ties are expressed by the rules that relate the form in a given paradigm to the lexeme The second opposition concerns the question of inferability of meaning, and theories divide into: incremental words acquire morphosyntactic properties only in connection with acquiring the inflectional exponents of those properties realizational association of a set of properties with a word licenses the introduction of the exponents into the word’s morphology Evidence favoring inferential–realizational theories over the other three approaches is presented by Stump (2001) as well as Baerman et al. (2006) or Spencer (2004). In trying to classify the implementations of Arabic morphological models, let us reconsider this cross-linguistic observation: The morphosyntactic properties associated with an inflected word’s individual inflectional markings may underdetermine the properties associated with the word as a whole. (Stump, 2001, p. 7) How do the current morphological analyzers interpret, for instance, the number and gender of the Arabic broken masculine plurals ˇgudud ��new ones or qud. ¯ah SLQs judges, or the case of mustawan � j��-.A j a level? Do they identify the values of these features that the syntax ac</context>
</contexts>
<marker>Spencer, 2004</marker>
<rawString>Andrew Spencer. 2004. Generalized Paradigm Function Morphology. http://privatewww.essex. ac.uk/˜spena/papers/GPFM.pdf, October 6.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gregory T Stump</author>
</authors>
<title>Inflectional Morphology. A Theory of Paradigm Structure. Cambridge Studies in Linguistics.</title>
<date>2001</date>
<publisher>Cambridge University Press.</publisher>
<contexts>
<context position="1483" citStr="Stump (2001)" startWordPosition="216" endWordPosition="217"> enhanced with information sourcing from the syntactic annotations of the Prague Arabic Dependency Treebank. 1 Overview One can observe several different streams both in the computational and the purely linguistic modeling of morphology. Some are motivated by the need to analyze word forms as to their compositional structure, others consider word inflection as being driven by the underlying system of the language and the formal requirements of its grammar. In Section 2, before we focus on the principles of ElixirFM, we briefly follow the characterization of morphological theories presented by Stump (2001) and extend the classification to the most prominent computational models of Arabic morphology (Beesley, 2001; Buckwalter, 2002; Habash et al., 2005; El Dada and Ranta, 2006). In Section 3, we survey some of the categories of the syntax–morphology interface in Modern Written Arabic, as described by the Functional Arabic Morphology. In passing, we will introduce the basic concepts of programming in Haskell, a modern purely functional language that is an excellent choice for declarative generative modeling of morphologies, as Forsberg and Ranta (2004) have shown. Section 4 will be devoted to des</context>
<context position="2951" citStr="Stump (2001)" startWordPosition="441" endWordPosition="442">ther independent processing, and still an easy-to-read-and-edit document resembling the printed dictionaries. In Section 5, we will illustrate how rules of inflection and derivation interact with the parameters of the grammar and the lexical information. We will demonstrate, also with reference to the Functional Morphology library (Forsberg and Ranta, 2004), the reusability of the system in many applications, including computational analysis and generation in various modes, exploring and exporting of the lexicon, printing of the inflectional paradigms, etc. 2 Morphological Models According to Stump (2001), morphological theories can be classified along two scales. The first one deals with the core or the process of inflection: lexical theories associate word’s morphosyntactic properties with affixes inferential theories consider inflection as a result of operations on lexemes; morphosyntactic prop1 Proceedings of the 5th Workshop on Important Unresolved Matters, pages 1–8, Prague, Czech Republic, June 2007. c�2007 Association for Computational Linguistics erties are expressed by the rules that relate the form in a given paradigm to the lexeme The second opposition concerns the question of infe</context>
<context position="4339" citStr="Stump, 2001" startWordPosition="644" endWordPosition="645">ies realizational association of a set of properties with a word licenses the introduction of the exponents into the word’s morphology Evidence favoring inferential–realizational theories over the other three approaches is presented by Stump (2001) as well as Baerman et al. (2006) or Spencer (2004). In trying to classify the implementations of Arabic morphological models, let us reconsider this cross-linguistic observation: The morphosyntactic properties associated with an inflected word’s individual inflectional markings may underdetermine the properties associated with the word as a whole. (Stump, 2001, p. 7) How do the current morphological analyzers interpret, for instance, the number and gender of the Arabic broken masculine plurals ˇgudud ��new ones or qud. ¯ah SLQs judges, or the case of mustawan � j��-.A j a level? Do they identify the values of these features that the syntax actually operates with, or is the resolution hindered by some too generic assumptions about the relation between meaning and form? Many of the computational models of Arabic morphology, including in particular (Beesley, 2001), (Ramsay and Mansur, 2001) or (Buckwalter, 2002), are lexical in nature. As they are not</context>
</contexts>
<marker>Stump, 2001</marker>
<rawString>Gregory T. Stump. 2001. Inflectional Morphology. A Theory of Paradigm Structure. Cambridge Studies in Linguistics. Cambridge University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Philip Wadler</author>
</authors>
<title>A Prettier Printer.</title>
<date>2003</date>
<booktitle>In Jeremy Gibbons and Oege de Moor, editors, The Fun of Programming, Cornerstones of Computing,</booktitle>
<pages>223--243</pages>
<publisher>Palgrave Macmillan,</publisher>
<contexts>
<context position="17793" citStr="Wadler, 2003" startWordPosition="2906" endWordPosition="2907">rmediate result of morph y is decomposed, and x is prepended to the stack s of the already present suffixes. (|&lt;) :: Morphing a b =&gt; a -&gt; Suffix -&gt; Morphs b y |&lt; x = Morphs t p (x : s) where Morphs t p s = morph y With the introduction of patterns, their synonymous functions and the &gt; |and |&lt; operators, we have started the development of what can be viewed as a domain-specific language embedded in the generalpurpose programming language. Encouraged by the flexibility of many other domain-specific languages in Haskell, esp. those used in functional parsing (Ljungl¨of, 2002) or pretty-printing (Wadler, 2003), we may design the lexicon to look like e.g. module Elixir.Data.Lexicon import Elixir.Lexicon lexicon = listing {- lexicon’s header -} |&gt; {- root one -} &lt; |[ {- Entry a -} ] |&gt; {- root two -} &lt; |[ {- Entry b -} ] -- other roots or word stems and entries and yet be a verifiable source code defining a data structure that is directly interpretable. The meaning of the combinators |&gt; and &lt; |could be supplied via an external module Elixir.Lexicon, so is very easy to customize. The effect of these combinators might be similar to the : and :-: constructors that we met previously, but perhaps other da</context>
</contexts>
<marker>Wadler, 2003</marker>
<rawString>Philip Wadler. 2003. A Prettier Printer. In Jeremy Gibbons and Oege de Moor, editors, The Fun of Programming, Cornerstones of Computing, pages 223– 243. Palgrave Macmillan, March 2003.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>