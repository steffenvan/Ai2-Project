<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000241">
<note confidence="0.5002474">
ENGLISH WORDS AND DATA BASES: HOW TO BRIDGE THE GAP
Remko J.H. Scha
Philips Research Laboratories
Eindhoven
The Netherlands
</note>
<sectionHeader confidence="0.504466" genericHeader="abstract">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.999802">
If a q.a. system tries to transform an Eng-
lish question directly into the simplest possible
formulation of the corresponding data base query,
discrepancies between the English lexicon and the
structure of the data base cannot be handled well.
To be able to deal with such discrepancies in a
systematic way, the PHLIQA1 system distinguishes
different levels of semantic representation; it
contains modules which translate from one level
to another, as well as a module which simplifies
expressions within one level. The paper shows how
this approach takes care of some phenomena which
would be problematic in a moresimple-mindedset-up.
</bodyText>
<sectionHeader confidence="0.989856" genericHeader="introduction">
INTRODUCTION
</sectionHeader>
<bodyText confidence="0.986704862068966">
If a question-answering system is to cover a
non-trivial fragment of its natural input-language,
and to allow for an arbitrarily structured data
base, it cannot assume that the syntactic/semantic
structure of an input question has much in common
with the formal query which would formulate in terms
of the actual data base structure what the desired
information is. An important decision in the design
of a q.a. system is therefore, how to embody in the
system the necessary knowledge about the relation
between English words and data base notions.
Most existing programs, however, do not face
this issue. They accept considerable constraints on
both the input language and the possible data base
structures, so as to be able to establish a fairly
direct correspondence between the lexical items of
the input language and the primitives of the data
base, which makes it possible to translate input
questions into query expressions in a rather
straightforward fashion.
In designing the PHLIQA1 system, bridging the
gap between free English input and an equally un-
constrained data base structure was one of the main
goals. In order to deal with this problem in a sys-
tematic way, different levels of semantic analysis
are distinguished in the PHLIQA1 program. At each
of these levels, the meaning of the input question
is represented by an expression of a formal logical
language. The levels differ in that each of them
assumes different semantic primitives.
At the highest of these levels,the meaning of
the question is represented by an expression of the
English-oriented Formal Language (EFL); this lan-
guage uses semantic primitives which correspond to
the descriptive lexical items of English. The prim-
itives of the lowest semantic level are the prim-
itives of the data base (names of files, attributes,
data-items). The formal language used at this level
is therefore called the Data Base Language (DBL).
Between EFL and DBL, several other levels of mean-
ing representation are used as intermediary steps.
Because of the space limitations imposed on the
present paper, I am forced to evoke a somewhat mis-
leading picture of the PHLIQA set-up, by ignoring
these intermediate levels.
Given the distinctions just introduced, the
problem raised by the discrepancy between the Eng-
lish lexicon and the set of primitives of a given
data base can be formulated as follows: one must
devise a formal characterization of the relation
between EFL and DBL, and use this characterization
for an effective procedure which translates EFL
queries into DBL queries. I will introduce PHLIQA&apos;s
solution to this problem by giving a detailed dis-
cussion of some examplesi which display complica-
tions that Robert Moore suggested as topics for the
panel discussion at this conference.
II THE ENGLISH-ORIENTED LEVEL OF MEANING
REPRESENTATION
The highest level of semantic representation
is independent of the subject-domain. It contains a
semantic primitive for every descriptive lexical
item of the input-language2. The semantic types of
these primitives are systematically related to the
syntactic categories of the corresponding lexical
items. For example, for every noun there is a con-
stant which denotes the set of individuals which
fall under the description of this noun: corre-
sponding to &amp;quot;employee&amp;quot; and &amp;quot;employees&amp;quot; there is a
constant EMPLOYEES denoting the set of all employ-
ees, corresponding to &amp;quot;department&amp;quot; and &amp;quot;depart-
ments&amp;quot; there is a constant DEPARTMENTS denoting
the set of all departments. Corresponding to an
n-place verb there is an n-place predicate. For
instance, &amp;quot;to have&amp;quot; corresponds to the 2-place
predicate HAVE. Thus, the input analysis component
1 There is no space for a definition of the logical
formalism I use in this paper. Closely related log-
ical languages are defined in Scha (1976), Lands-
bergen and Scha (1979), and Bronnenberg etal.(1980).
2 In previous papers it has been pointed out that
this idea, taken strictly, leads not to an ordinary
logical language, but requires a formal language
which is ambiguous. I ignore this aspect here. What
I call EFL corresponds to what was called EFL- in
some other papers. SeeLandsbergenand Scha (1979)
and Bronnenberg et al. (1980) for discussion.
</bodyText>
<page confidence="0.991024">
57
</page>
<bodyText confidence="0.9886545">
of the system translates the question
&amp;quot;How many departments have more than 100
</bodyText>
<equation confidence="0.9493185">
employees ?&amp;quot; (1)
into
Count({xe DEPARTMENTS I
Countaye EMPLOYEESIHAVE(x,y)1) &gt; 100)). (2)
</equation>
<bodyText confidence="0.969846439655172">
III THE DATA BASE ORIENTED LEVEL OF MEANING
REPRESENTATION
A data base specifies an interpretation of a
logical language, by specifying the extension of
every constant. A formalization of this view on
data bases, and its application to a CODASYL data
base, can be found in Bronnenberg et al.(1980).
The idea is equally applicable to relational data
bases. A relational data base specifies an inter-
pretation of a logical language which contains for
every relation R [K, An] a constant K de-
noting a set, and n functions A1,..., An which have
the denotation of K as their domain.
Thus, if we have an EMPLOYEE file with a
DEPARTMENT field, this file specifies the extension
of a set EMPS and of a function DEPT which has the
denotation of EMPS as its domain. In terns of such
a data base structure, (1) above may be formulated
as
Count({xe (for: EMPS, apply: DEPT) I
Count(iy e EMPSIDEPT(y)=x})&gt; 1001). (3)
I pointed out before that it would be unwise to
design a system which would directly assign the
meaning (3) to the question (1). A more sensible
strategy is to first assign (1) the meaning (2).
The formula (3), or a logically equivalent One,nmy
then be derived on the basis of a specification of
the relation between the English word meanings used
in (1) and the primitive concepts at the data base
level.
IV THE RELATION BETWEEN EFL AND DBL
Though we defined EFL and DBL independently of
each other (one on the basis of the possible Eng-
lish questions about the subject-domain, the other
on the basis of the structure of the data base
about it) there must be a relation between them.
The data base contains information which can serve
to answer queries formulated in EFL. This means
that the denotation of certain EFL expressions is
fixed if an interpretation of DBL is given.
We now consider how the relation between EFL
and DBL may be formulated in such a way that it can
easily serve as a basis for an effective transla-
tion from EFL expressions into DBL expressions.
The most general formulation would take the form of
a set of axioms, expressed in a logical language
encompassing both EFL and DBL. If we allow the full
generality of that approach, however, it leads to
the use of algorithms which are not efficient and
which are not guaranteed to terminate. An alterna-
tive formulation, which is attractive because it
can easily be implemented by effective procedures,
is one in terms of translation rules. This is the
approach adopted in the PHLIQA1 system. It is de-
scribed in detail in Bronnenberg et al. (1980) and
can be summarized as follows.
The relation between subsequent semantic
levels can be described by means of local transla-
tion rules which specify, for every descriptive
constant of the source language, ? corresponding
expression of the target language . A set of such
translation rules defines for every source language
query-expression an equivalent target language ex-
pression. An effective algorithm can be constructed
which performs this equivalence translation for any
arbitrary expression.
A translation algorithm which applies the
translation rules in a straightforward fashion,
often produces large expressions which allow for
considerably simpler paraphrases. As we will see
later on in this paper, it may be essential that
such simplifications are actually performed. There-
fore, the result of the EFL-to-DBL translation is
processed by a module which applies logical equi-
valence transformations in order to amplify the
expression.
At the most global level of description, the
PHLIQA system can thus be thought to consist of the
following sequence of components: Input analysis,
yielding an EFL expression; EFL-to-DBL translation:
simplification of the DBL expression; evaluation of
the resulting expression.
For the example introduced in the sections II
and III, a specification of the EFL-to-DBL transla-
tion rules might look like this:
DEPARTMENTS (for: EMPS, apply: DEPT)
EMPLOYEES EMPS
HAVE (Xx,y: DEPT(y)=x)
These rules can be directly applied to the formula
(2). Substitution of the right hand expressions for
the corresponding left hand constants in (2), fol-
lowed by X-reduction, yields (3).
V THE PROBLEM OF COMPOUND ATTRIBUTES
It is easy to imagine a different data base
which would also contain sufficient information to
answer question (1). One example would be a data
base which has a file of DEPARTMENTS, and which has
NUMBER-OF-EMPLOYEES as an attribute of this file.
This data base specifies an interpretation of a
logical language which contains the set-constant
DEPTS and the function #EMP (from departments to
Integers) as its descriptive constants. In terms of
this data base, the query expressed by (1) would be:
Count({x DEPTSI #EMP(x) &gt; 100)) . (5)
If we try to describe the relation between
EFL and DBL for this case, we face a difficulty
which did not arise for the data base structure of
section III: the DBL constants do not allow the
construction of DBL expressions whose denotations
Involve employees. So the EFL constant EMPLOYEES
cannot be translated into an equivalent DBL expres-
sion - nor can the relation HAVE, for lack of a
suitable domain. This may seem to force us to give
up local translation for certain cases: instead, we
would have to design an algorithm which looks out
for sub-expressions of the form
</bodyText>
<page confidence="0.480306">
1
</page>
<bodyText confidence="0.79895175">
I ignore the complexities which arise because of
the typing of variables, if a many-sorted logic is
used. Again, see Bronnenberg et al. (1980), for
details.
</bodyText>
<page confidence="0.996382">
58
</page>
<bodyText confidence="0.993494277777778">
(Ay: Count({x CEMPLOYEESIHAVE(y,x)})), where y is
ranging over DEPARTMENTS, and then translates this
whole expression into: #EMP. This is not attractive
- it could only work if EFL expressions would be
first transformed so as to always contain this ex-
pression in exactly this form, or if we would have an
algorithm for recognizing all its variants.
Fortunately, there is another solution. Though
in DBL terms one cannot talk about employees, one
can talk about objects which stand in a one-to-one
correspondence to the employees: the pairs consis-
ting of a department d and apositive integer i such
that i is not larger than than the value of #EMP
for d. Entities which have a one-to-one correspon-
dence with these pairs, and are disjoint with the
extensions of all other semantic types, may be used
as &amp;quot;proxies&amp;quot; for employees. Thus, we may define the
following translation:
</bodyText>
<equation confidence="0.961034833333333">
EMPLOYEES -&gt; U(for: DEPTS,
apply: (Xd:(for: INTS(#EMP(d)),
apply:
x:idempd,x&gt;)))))
DEPARTMENTS -&gt; DEPTS
HAVE (Xy: rid(y[2])[1] = y[11)
</equation>
<bodyText confidence="0.9908265">
where id remn is a functionwhich establishes a one-
-to-one ?respondence between its domain and its
range (its range is disjoint with all other seman-
tic types); rid is the inverse of idem ; INTS is a
function which assigns to any integerPi the set of
integers j such that 0&lt;jSi.
Application of these rules to (2) yields:
Count ({x EDEPTS
</bodyText>
<equation confidence="0.7725576">
CountUyEU(for: DEPTS,
apply:(Xd:(for: INTS(#EMP(d)),
apply:
(Xx:id (&lt;d,x&gt;))))) I
rid(y)[1] = x}) &gt; 10011mP (6)
</equation>
<bodyText confidence="0.989435078947369">
which is logically equivalent to (5) above.
It is clear that this data base, because of
its greater &amp;quot;distance&amp;quot; to the English lexicon, re-
quires a more extensive set of simplification rules
if the DBL query produced by the translation rules
is to be transformed into its simplest possible
form. A simplification algorithm dealing succesful-
ly with complexities of the kind just illustrated
was implemented by W.J. Bronnenberg as a component
of the PHLIQA1 system.
VI EXTENDING THE DATA BASE LANGUAGE
Consider a slight variation on question (1):
&amp;quot;How many departments have more than 100 people ?&amp;quot; (7)
We may want to treat &amp;quot;people&amp;quot; and &amp;quot;employees&amp;quot; as
non-synonymous. For instance, we may want to be
able to answer the question &amp;quot;Are all employees em-
ployed by a department ?&amp;quot; with &amp;quot;Yes&amp;quot;, but &amp;quot;Are all
people employed by a department?&amp;quot; with &amp;quot;I don&apos;t
know&amp;quot;. Nevertheless, (7) can be given a definite
answer on the basis of the data base of section IIL
The method as described so far has a problem with
this example: although the answer to (7) is de-
termined by the data base, the question as formula-
ted refers to entities which are not represented in
the data base, cannot be constructed out of such
entities, and do not stand in a one-to-one corre-
spondence with entities which can be so constructed.
In order to be able to construct a DBL translation
of (7) by means of local substitution rules of the
kind previously illustrated, we need an extended
version of DBL, which we will call DBL*, containing
the same constants as DBL plus a constant NONEMPS,
denoting the set of persons who are not employees.
Now, local translation rules for the EFL-to-DBL*
translation may be specified. Application of these
translation rules to the EFL representation of (7)
yields a DBL* expression containing the unevaluable
constant NONEMPS. The system can only give a defi-
nite answer if this constant is eliminated by the
simplification component.
If the elimination does not succeed, PHLIQA
still gives a meaningful &amp;quot;conditional answer&amp;quot;. It
translates NONEMPS into 0 and prefaces the answer
with &amp;quot;if there are no people other than employees,
...&amp;quot;. Again, see Bronnenberg et al. (1980) for
details.
VII DISCUSSION
Some attractive properties of the translation
method are probably clear from the examples. Local
translation rules can be applied effectively and
have to be evoked only when they are directly re-
levant. Using the techniques of introducing &amp;quot;prox-
ies&amp;quot; (section V) and &amp;quot;complementary constants&amp;quot;
(section VI) in DBL, a considerable distance be-
tween the English lexicon and the data base struc-
ture can be covered by means of local translation
rules.
The problem of simplifying the DBL* expres-
sion (and other, intermediate expressions, in the
full version of the PHLIQA method) can be treated
separately from the peculiarities of particular
data bases and particular constructions of the
input language.
VIII ACKNOWLEDGEMENTS
Some of the ideas presented here are due to
Jan Landsbergen. My confidence in the validity of
the translation method was greatly enhanced by the
fact that others have applied it succesfully. Espe-
cially relevant for the present paper is the work
by Wim Bronnenberg and Eric van Utteren on the
translation rules for the PHLIQA1 data base. Bipin
Indurkhya (1981) implemented a program which shows
how this approach accommodates the meaning postu-
lates of Montague&apos;s PTQ and similar fragments of
English.
IX REFERENCES
</bodyText>
<reference confidence="0.998268125">
W.J.H.J. Bronnenberg, H.C. Bunt, S.P.J. Landsbergen,
R.J.H. Scha, W.J. Schoenmakers and E.P.C. van Utte-
ren: The Question Answering System PHLIQA1. In:
L. Bolc (ed): Natural Language Question Answering
Systems. MUnchen, Wien: Hanger. London, Basing-
stoke: Macmillan. 1980.
B. Indurkhya: Sentence Analysis Programs Based on
Montague Grammar. Unpubl. Master&apos;s Thesis. Phi-
lips International Institute. Eindhoven. 1981.
S.P.J. Landsbergen and R.J.H. Scha: Formal Lan-
guages for Semantic Representation. In: S. All4n
and J.S. PetBfi (eds): Aspects of Automatized
Text Processing. Hamburg: Buske. 1979.
R.J.H. Scha. Semantic Types in PHLIQA1. Preprints
of the 6trl International Conference on Computa-
tional Linguistics. Ottawa. 1976.
</reference>
<page confidence="0.999262">
59
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.724085">
<title confidence="0.981794">ENGLISH WORDS AND DATA BASES: HOW TO BRIDGE THE GAP</title>
<author confidence="0.997705">Remko J H Scha</author>
<affiliation confidence="0.8941245">Philips Research Laboratories Eindhoven</affiliation>
<address confidence="0.963058">The Netherlands</address>
<abstract confidence="0.997414428571429">If a q.a. system tries to transform an English question directly into the simplest possible formulation of the corresponding data base query, discrepancies between the English lexicon and the structure of the data base cannot be handled well. To be able to deal with such discrepancies in a systematic way, the PHLIQA1 system distinguishes different levels of semantic representation; it contains modules which translate from one level to another, as well as a module which simplifies expressions within one level. The paper shows how this approach takes care of some phenomena which would be problematic in a moresimple-mindedset-up.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>W J H J Bronnenberg</author>
<author>H C Bunt</author>
<author>S P J Landsbergen</author>
<author>R J H Scha</author>
<author>W J Schoenmakers</author>
<author>E P C van</author>
</authors>
<title>Utteren: The Question Answering System PHLIQA1. In: L. Bolc (ed): Natural Language Question Answering Systems. MUnchen,</title>
<date>1980</date>
<location>Wien: Hanger. London, Basingstoke: Macmillan.</location>
<contexts>
<context position="4959" citStr="Bronnenberg et al. (1980)" startWordPosition="787" endWordPosition="790">e, &amp;quot;to have&amp;quot; corresponds to the 2-place predicate HAVE. Thus, the input analysis component 1 There is no space for a definition of the logical formalism I use in this paper. Closely related logical languages are defined in Scha (1976), Landsbergen and Scha (1979), and Bronnenberg etal.(1980). 2 In previous papers it has been pointed out that this idea, taken strictly, leads not to an ordinary logical language, but requires a formal language which is ambiguous. I ignore this aspect here. What I call EFL corresponds to what was called EFL- in some other papers. SeeLandsbergenand Scha (1979) and Bronnenberg et al. (1980) for discussion. 57 of the system translates the question &amp;quot;How many departments have more than 100 employees ?&amp;quot; (1) into Count({xe DEPARTMENTS I Countaye EMPLOYEESIHAVE(x,y)1) &gt; 100)). (2) III THE DATA BASE ORIENTED LEVEL OF MEANING REPRESENTATION A data base specifies an interpretation of a logical language, by specifying the extension of every constant. A formalization of this view on data bases, and its application to a CODASYL data base, can be found in Bronnenberg et al.(1980). The idea is equally applicable to relational data bases. A relational data base specifies an interpretation of a</context>
<context position="7667" citStr="Bronnenberg et al. (1980)" startWordPosition="1259" endWordPosition="1262"> basis for an effective translation from EFL expressions into DBL expressions. The most general formulation would take the form of a set of axioms, expressed in a logical language encompassing both EFL and DBL. If we allow the full generality of that approach, however, it leads to the use of algorithms which are not efficient and which are not guaranteed to terminate. An alternative formulation, which is attractive because it can easily be implemented by effective procedures, is one in terms of translation rules. This is the approach adopted in the PHLIQA1 system. It is described in detail in Bronnenberg et al. (1980) and can be summarized as follows. The relation between subsequent semantic levels can be described by means of local translation rules which specify, for every descriptive constant of the source language, ? corresponding expression of the target language . A set of such translation rules defines for every source language query-expression an equivalent target language expression. An effective algorithm can be constructed which performs this equivalence translation for any arbitrary expression. A translation algorithm which applies the translation rules in a straightforward fashion, often produ</context>
<context position="10566" citStr="Bronnenberg et al. (1980)" startWordPosition="1721" endWordPosition="1724">which did not arise for the data base structure of section III: the DBL constants do not allow the construction of DBL expressions whose denotations Involve employees. So the EFL constant EMPLOYEES cannot be translated into an equivalent DBL expression - nor can the relation HAVE, for lack of a suitable domain. This may seem to force us to give up local translation for certain cases: instead, we would have to design an algorithm which looks out for sub-expressions of the form 1 I ignore the complexities which arise because of the typing of variables, if a many-sorted logic is used. Again, see Bronnenberg et al. (1980), for details. 58 (Ay: Count({x CEMPLOYEESIHAVE(y,x)})), where y is ranging over DEPARTMENTS, and then translates this whole expression into: #EMP. This is not attractive - it could only work if EFL expressions would be first transformed so as to always contain this expression in exactly this form, or if we would have an algorithm for recognizing all its variants. Fortunately, there is another solution. Though in DBL terms one cannot talk about employees, one can talk about objects which stand in a one-to-one correspondence to the employees: the pairs consisting of a department d and apositive</context>
<context position="14201" citStr="Bronnenberg et al. (1980)" startWordPosition="2327" endWordPosition="2330">NONEMPS, denoting the set of persons who are not employees. Now, local translation rules for the EFL-to-DBL* translation may be specified. Application of these translation rules to the EFL representation of (7) yields a DBL* expression containing the unevaluable constant NONEMPS. The system can only give a definite answer if this constant is eliminated by the simplification component. If the elimination does not succeed, PHLIQA still gives a meaningful &amp;quot;conditional answer&amp;quot;. It translates NONEMPS into 0 and prefaces the answer with &amp;quot;if there are no people other than employees, ...&amp;quot;. Again, see Bronnenberg et al. (1980) for details. VII DISCUSSION Some attractive properties of the translation method are probably clear from the examples. Local translation rules can be applied effectively and have to be evoked only when they are directly relevant. Using the techniques of introducing &amp;quot;proxies&amp;quot; (section V) and &amp;quot;complementary constants&amp;quot; (section VI) in DBL, a considerable distance between the English lexicon and the data base structure can be covered by means of local translation rules. The problem of simplifying the DBL* expression (and other, intermediate expressions, in the full version of the PHLIQA method) c</context>
</contexts>
<marker>Bronnenberg, Bunt, Landsbergen, Scha, Schoenmakers, van, 1980</marker>
<rawString>W.J.H.J. Bronnenberg, H.C. Bunt, S.P.J. Landsbergen, R.J.H. Scha, W.J. Schoenmakers and E.P.C. van Utteren: The Question Answering System PHLIQA1. In: L. Bolc (ed): Natural Language Question Answering Systems. MUnchen, Wien: Hanger. London, Basingstoke: Macmillan. 1980.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Indurkhya</author>
</authors>
<title>Sentence Analysis Programs Based on Montague Grammar. Unpubl. Master&apos;s Thesis. Philips International Institute.</title>
<date>1981</date>
<location>Eindhoven.</location>
<marker>Indurkhya, 1981</marker>
<rawString>B. Indurkhya: Sentence Analysis Programs Based on Montague Grammar. Unpubl. Master&apos;s Thesis. Philips International Institute. Eindhoven. 1981.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S P J Landsbergen</author>
<author>R J H Scha</author>
</authors>
<title>Formal Languages for Semantic Representation. In:</title>
<date>1979</date>
<booktitle>S. All4n and J.S. PetBfi (eds): Aspects of Automatized Text Processing.</booktitle>
<location>Hamburg: Buske.</location>
<contexts>
<context position="4597" citStr="Landsbergen and Scha (1979)" startWordPosition="727" endWordPosition="731"> of individuals which fall under the description of this noun: corresponding to &amp;quot;employee&amp;quot; and &amp;quot;employees&amp;quot; there is a constant EMPLOYEES denoting the set of all employees, corresponding to &amp;quot;department&amp;quot; and &amp;quot;departments&amp;quot; there is a constant DEPARTMENTS denoting the set of all departments. Corresponding to an n-place verb there is an n-place predicate. For instance, &amp;quot;to have&amp;quot; corresponds to the 2-place predicate HAVE. Thus, the input analysis component 1 There is no space for a definition of the logical formalism I use in this paper. Closely related logical languages are defined in Scha (1976), Landsbergen and Scha (1979), and Bronnenberg etal.(1980). 2 In previous papers it has been pointed out that this idea, taken strictly, leads not to an ordinary logical language, but requires a formal language which is ambiguous. I ignore this aspect here. What I call EFL corresponds to what was called EFL- in some other papers. SeeLandsbergenand Scha (1979) and Bronnenberg et al. (1980) for discussion. 57 of the system translates the question &amp;quot;How many departments have more than 100 employees ?&amp;quot; (1) into Count({xe DEPARTMENTS I Countaye EMPLOYEESIHAVE(x,y)1) &gt; 100)). (2) III THE DATA BASE ORIENTED LEVEL OF MEANING REPRE</context>
</contexts>
<marker>Landsbergen, Scha, 1979</marker>
<rawString>S.P.J. Landsbergen and R.J.H. Scha: Formal Languages for Semantic Representation. In: S. All4n and J.S. PetBfi (eds): Aspects of Automatized Text Processing. Hamburg: Buske. 1979.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R J H Scha</author>
</authors>
<title>Semantic Types in</title>
<date>1976</date>
<booktitle>PHLIQA1. Preprints of the 6trl International Conference on Computational Linguistics.</booktitle>
<location>Ottawa.</location>
<contexts>
<context position="4568" citStr="Scha (1976)" startWordPosition="725" endWordPosition="726">notes the set of individuals which fall under the description of this noun: corresponding to &amp;quot;employee&amp;quot; and &amp;quot;employees&amp;quot; there is a constant EMPLOYEES denoting the set of all employees, corresponding to &amp;quot;department&amp;quot; and &amp;quot;departments&amp;quot; there is a constant DEPARTMENTS denoting the set of all departments. Corresponding to an n-place verb there is an n-place predicate. For instance, &amp;quot;to have&amp;quot; corresponds to the 2-place predicate HAVE. Thus, the input analysis component 1 There is no space for a definition of the logical formalism I use in this paper. Closely related logical languages are defined in Scha (1976), Landsbergen and Scha (1979), and Bronnenberg etal.(1980). 2 In previous papers it has been pointed out that this idea, taken strictly, leads not to an ordinary logical language, but requires a formal language which is ambiguous. I ignore this aspect here. What I call EFL corresponds to what was called EFL- in some other papers. SeeLandsbergenand Scha (1979) and Bronnenberg et al. (1980) for discussion. 57 of the system translates the question &amp;quot;How many departments have more than 100 employees ?&amp;quot; (1) into Count({xe DEPARTMENTS I Countaye EMPLOYEESIHAVE(x,y)1) &gt; 100)). (2) III THE DATA BASE OR</context>
</contexts>
<marker>Scha, 1976</marker>
<rawString>R.J.H. Scha. Semantic Types in PHLIQA1. Preprints of the 6trl International Conference on Computational Linguistics. Ottawa. 1976.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>