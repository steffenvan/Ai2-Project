<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000001">
<note confidence="0.8495338">
LFG System in Prolog
Hideki Yasukawa
The Second Laboratory
.Institute for Hew Generation Computer Technology (ICOT)
Tokyo, 108, Japan
</note>
<bodyText confidence="0.766193">
girl handed the baby a toy&amp;quot; (Maplan,Bresnan 82]).
</bodyText>
<sectionHeader confidence="0.903243" genericHeader="abstract">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.999774363636364">
In order to design and maintain a large scale
grammar, the formal system for representing
syntactic knowledge should be provided. Lexical
Functional Grammar (LFG) (Kaplan,Bresnan 82] is a
powerful formalism for that purpose. In this
paper, the Prolog implementation of LFG system is
described. Prolog provides a good tools for the
implementation of LFG. LFG can be translated into
DCG [Pereira,Uarren 80] and functional structures
(f-structures) are generated during the parsing
process.
</bodyText>
<sectionHeader confidence="0.962656" genericHeader="method">
I INTRODUCTIOU
</sectionHeader>
<bodyText confidence="0.999929166666667">
The fundamental purposes of syntactic
analysis are to check the grammaticality and to
clarify the mapping between semantic structures
and syntactic constituents. DCG provides tools
for fulfilling these purposes. But, due to the
fact that the arbitrary Prolog programs can be
embedded into DCG rules, the grammar becomes too
complicated to understand, debug and maintain.
So, the development of the formal system to
represent syntactic knowledges is needed. The
main concern is to define the appropriate set of
the descriptive primitives used to represent the
syntactic knowledges. LFG seems to be promising
formalism from current linguistic theories which
satisfies these requirements. LFG is adopted for
our preliminary version of the formal system and
the Prolog implementation of LFG is described in
this paper.
</bodyText>
<sectionHeader confidence="0.914566" genericHeader="method">
II SInPLE OVERVIEW OF LFG
</sectionHeader>
<bodyText confidence="0.931700153846154">
In this section, the simple overview of LFG
is described (See [Eaplan,Dresnan 32] for details
). LFG is an extention of context free Grammar
(C7G) and has two-levels of representation, i.e.
c-structures (constituent structures) and
f-structures (functional structures). A
c-structure is generated by CP G and represents the
surface word and phrase configurations in a
sentence, and the f-structure is Generated by the
functional equations associated with the grammar
rules and represents the configuration of the
surface grammatical functions. Fig. 1 shows the
0-structure and f-structure for the sentence &amp;quot;a
</bodyText>
<figure confidence="0.931539043478261">
np-------------vp
det---nnp
7 np-
1 t 1 1
I 1
f 1
, 1 det---n det--n
1 1 1 1
1 I 1 1 1 : 1
a girl hands the baby a toy
(a) c-structure
subj spec a
num sg
pred &apos;girl&apos;
tense past
pred &apos;hand&lt;(T subj)(T obj2)(1 obj)&gt;&apos;
obj spec the
num sg
pred &apos;baby&apos;
obj2 spec a
num sg
pred &apos;toy&apos;
(b) f-structure
</figure>
<figureCaption confidence="0.999802">
Fig. 1 The example c-structure and f-structure
</figureCaption>
<bodyText confidence="0.999543666666667">
As shown in Fig. 1, f-structure is a
hierarchical structure constructed by the pairs of
attribute and its value. An attribute represents
grammatical function or syntactic feature.
Lexical entries specify a direct mapping between
semantic arguments and configurations of surface
grammatical functions, and grammar rules specify a
direct mapping between these surface grammatical
functions and particular constituent structure
configurations. To represent these grammatical
relations, several devices and schemata are
provided in LFG as shown below.
</bodyText>
<figure confidence="0.538587307692308">
(a) meta variables
(i) &amp; (immediate dominance)
(ii) 11■&amp; 4. (bounded dominance)
(b) functional notations
a designator (T subj) indicates the value of
the &amp;quot;subj&amp;quot; attribute of the mother node&apos;s
f-structure.
(c) Equational schema
(i) = (functional equation)
(ii) E (set inclusion)
358
(d) Constraining schema
(1) =c (equational constraint)
</figure>
<bodyText confidence="0.810919857142857">
(ii) d (existential constraint)
where d is a designator
(iii) negation of (i) and (ii)
F4- 2 shows the example grammar
_g.
lexical entries in LFG, which Generate
c-structure and the f-structure in Fig. 1.
</bodyText>
<listItem confidence="0.955852">
1. s -&gt; np vp
(t subj)wi
2. np -&gt; det n
1=4 t=i
3. vp -&gt; v np np
</listItem>
<figure confidence="0.654854714285714">
1=4 (t obj).4 obj2)eir
4. det -&gt; [a]
(T spec).-sa (1 num)=sg
5. det -&gt; [the]
(t spec)=the
6. n -&gt; [girl]
(/ num)=sg (/ pred):&apos;girl&apos;
7. n -&gt; [baby]
(/ num)msg (/ pred)ebaby&apos;
8. n -&gt; [toy]
(/ num)msg pred)s&apos;toy&apos;
9. v -&gt; [handed]
(1 tense)=past
ft pred)ehand&lt;(/ subj)(t obj2)(/ obj)&gt;&apos;
</figure>
<figureCaption confidence="0.986486">
Fig. 2 Example grammar rules and lexical entries
of LFG. (from [Kaplan,Breenan 82])
</figureCaption>
<bodyText confidence="0.999731266666667">
As shown in Fig. 2, the primitives to
represent grammatical relations are encoded in
graLmar rules and lexical entries. Each syntactic
node has its own f-structure and the partial value
of the f-structure is defined by the Equational
schema. For example, the functional equation &amp;quot;(7
subj)=+&amp;quot; associated with the daughter &amp;quot;np&amp;quot; node of
_ram-,ar rule 1. of Fig. 2 specifies that the
value of the &amp;quot;subj&amp;quot; attribute of the f-structure
of the mother &amp;quot;s&amp;quot; node is the f-structure of its
daughter &amp;quot;np&amp;quot; node. The value constraints on the
f-structure are specified by the Constraining
schaza. 1:oreover, the Gramaticality of the
sentence is defined by the three conditions shown
beim.
</bodyText>
<listItem confidence="0.959203444444445">
(1) Uniqueness: a particular attribute may have at
.:ost one value in a Given f-structure.
(2) Completeness: a f-structure must contain all
the governable zranuatical functions Governed by
its predicate.
(3) Coherence: all the Governable Grammatical
faoctions that a f-structure contain must be
,,overned by its predicates.
311 LIPLEI:XITATION OF L70 pnmarms
</listItem>
<bodyText confidence="0.9998175">
As indicated in section II, two distinct
schemata are employed in the constructions of
f-structures. In the current implementation,
f-structures are generated during the parsing
process by executing the functional equations and
set inclusions associated with each syntactic
node. After the parsing is done, the f-structures
are cheched whether their value assignments are
consistent with the value constraints on them.
The Completeness condition on grammaticality is
also checked after the parsing. The L21-1
primitives are realized by the Prolog programs and
embedded into the DCG rules. The Equational
schema is executed during the parsing process by
the execution of DCG rules. The functional
equation can be seen as the extension of the
unification of Prolog by introducing equality on
f-structures.
</bodyText>
<subsectionHeader confidence="0.968093">
A. Representations of Data Types
</subsectionHeader>
<bodyText confidence="0.970237333333333">
The primitive data types constructing
f-structures are symbols, semantic predicates,
subsidiary f-structures, and sets of symbols,
semantic predicates, or f-structures. In current
implementation, these data types are represented
83 follows :
</bodyText>
<listItem confidence="0.9465445">
1) symbols ==&gt; atom or integer
2) semantic predicates mg&gt; sem(X)
where X is a predicate
3) f-structure =a&gt; Id:Obt
</listItem>
<bodyText confidence="0.977069342857143">
where the &amp;quot;Id&amp;quot; is an identifier variable
(ID-variable). Each syntactic node has unique
ID-variable which is used to identify its
f-structure. The &amp;quot;Obt&amp;quot; is a ordered binary
tree each leaf contains the pair of an
attribute and its value.
4) set ==&gt; (element1, element2, elementU)
A f-structure can be seen as a partially
defined data structure, because its value is
partially generated by the Equational schema
during the parsing process. An ordered binary
tree, obt for short, is suitable for representing
partially defined data. An obt is a binary tree
whose labels are ordered. A binary tree &amp;quot;Obt&amp;quot; is
represented by an term of the following form.
Obt = obt(v(Attr,Value),Less,Greater)
The &amp;quot;v(Attr,Value)&amp;quot; is a leaf node of the
tree. The &amp;quot;Attr&amp;quot; is an attribute name and used as
the label of the leaf node, and the &amp;quot;Value&amp;quot; is its
value. The &amp;quot;Less&amp;quot; and &amp;quot;Greater&amp;quot; are also binary
trees. The &amp;quot;Obt&amp;quot; is ordered when the nese
(&amp;quot;Greater&amp;quot;) is also ordered and each label of its
leaf nodes is less (greater) than the label of
&amp;quot;Obt&amp;quot;,i.e. &amp;quot;Attr&amp;quot;. If none of the leaf of a tree
is defined, it is represented by a logical
variable. When its label is defined later, the
logical variable is instantiated. The insertion
of a label and its value into an obt is done by
only one unification, without rewriting the tree.
This is the merit in using an ordered binary tree.
For example, the f-structure for the noun
phrase &amp;quot;a girl&amp;quot;, the value of the &amp;quot;subj&amp;quot; in Fig.1
(b), can be graphically represented in Fig. 3.
The &amp;quot;Vin&apos;s in Fig. 3 are the variables
representing the uninstantiated subtrees.
</bodyText>
<figure confidence="0.726799">
B. Functional Notation
rules and
the
359
ID-variable --&gt; v(spec,a)
1
v(num,sg)
v(per3,3)
4.••••■•+
I I
V1 V2 V3 V4
</figure>
<figureCaption confidence="0.722452">
Fig. 3 the graphical representaion of an obt
</figureCaption>
<bodyText confidence="0.9828272">
The functional notations are represented by
ID-variables instead of Meta variables / and
i.e. Meta variables must be replaced by the
object level variable. For example, the
designator (t subj) associated with the category
S, is described as [subj, /dS], where IdS is the
0-variable for S. The meta variables for bounded
dominance are represented by the terms
controllee(Cat) and controller(Cat), where the
&amp;quot;Cat&amp;quot; is the name of the syntactic category of the
controller or controllee.
C. Predicates for LFG Primitives
The predicates for each LFG primitives are as
follows : (d,d1,d2 are designators, s is a set,
and - is a negation symbol)
</bodyText>
<figure confidence="0.459831333333333">
1) d1 d2 -&gt; equate(d1,d2,01d,New)
2) d G s -&gt; include(d,s,Old,New)
3) d1 2c d2 -&gt; constrain(d1,d2,01dC,NewC)
4) d -&gt; exist(d,OldC,NewC)
5) &amp;quot;(d1 =c d2) -&gt; neg_constrain(d1,d2,01dC,UewC)
6) -d -&gt; not_exist(d,OldC,NewC)
</figure>
<bodyText confidence="0.99266815625">
The &amp;quot;Old&amp;quot; and &amp;quot;New&amp;quot; are global value
assignments. They are used to propagate the
changes of global value assignments made by the
execution of each predicate. The &amp;quot;OldC&amp;quot; and
&amp;quot;NewC&amp;quot; are constraint lists and used to gather all
the constraints in the analysis.
Zesides these predicates, the additional
predicates are provided for checking a constraints
during the parsing process. They are used to kill
the parsing process generating inconsistent result
an soon as the inconsistency is found.
The predicate &amp;quot;equate&amp;quot; gets the temporary
values of the designators d1 and d2, consulting
the global value assignments. Then &amp;quot;equate&amp;quot;
performs the unification of their values. The
unification i3 similar to set-theoretic union
except that it is only defined for sets of
nondistinct attributes. Fig. 4 shows the example
trace output of the &amp;quot;equate&amp;quot; in the course of
analyzing the sentence &amp;quot;a girl hands the baby a
toy&amp;quot;.
In order to keep graamar rules highly
understandable, it would be better to hide
u..7.necessary data, such as global value assignments
or constraint lists. The macro notations similar
to the original notation of LFG are provided to
users for that purpose. The macro expander
translates the macro notations into Prolog
programs corresponding to the LFG primitives.
The value of the designator Det is
spec the
The value of the designator U is
</bodyText>
<figure confidence="0.969542125">
num SE
per 3
pred seu(girl)
Result of unification is
spec the
num sg
per 3
pred sem(girl)
</figure>
<figureCaption confidence="0.979981">
Fig. 4 Tracing results of equate.
</figureCaption>
<bodyText confidence="0.969227">
This macro expansion results in considerable
improvement of the writability and the
understandability of the grammar.
The syntax of macro notations are :
</bodyText>
<figure confidence="0.990912">
(a) d1 d2 -&gt; eq(d1,d2)
(b) d s -&gt; incl(d,$)
(0) d1 d2 -&gt; c(d1,d2)
(d) d -&gt; ex(d)
(e) &amp;quot;(dl =c d2) -&gt; not_c(d1,d2)
(f) &amp;quot;d -&gt; not,_ex(d)
</figure>
<bodyText confidence="0.9532369">
These macro notations for LFG primitives are
placed at the third argument of the each predicate
in DCG rules corresponding to syntactic categories
as shown in Fig. 5 (a), which corresponds to the
grammar rule 1. in Fig. 2.
s(s(NP,VP),Id-S,[]) --&gt;
np(Np,Id_Up,[eq(Csubj,I4_SLId_Np]),
vp(Vp,Id_Vp,[eq(Id-S,Id-VO)]).
(a) The DCG rule with macro for LFG
s(s(Np,Vp),/d_S,Old,New,01dC,NewC) --&gt;
np(Np,IA_Np,Old,Old1,01dC,OldC1),
fequate([subj,Id_SLId_Up,Old1,01d2)},
vp(Vp,Id_Vp,01d2,01d3,01dC1,NewC),
(equate(IeLS,Id_Vp,01d3,New)}.
(b) The result of macro expansion
Fig. 5 Example DCG rule for LFG analysis
The variables &amp;quot;Id_S&amp;quot;, &amp;quot;Id_Np&amp;quot;, and &amp;quot;Id_Vp&amp;quot;
are the ID-variables for each syntactic category.
For example, the grammar rule in Fig. 5 (a) in
translated into the one shown in Si;. 5 (b).
Moro descriptions are translated into the
corresponding predicate in the case of a grammar
rule. In the case of a lexical entry, aacro
descriptions are translated into the corresponding
predicate, which is executed further more and the
f-structure of the lexical entry is generated.
D. Issues on the Implementation
Though f-structures are constructed during
the parsing process, the execution of the
Equational schema is independent of the parsing
</bodyText>
<page confidence="0.993526">
360
</page>
<bodyText confidence="0.993814451612903">
strategy. This is necessary to keep the grammar
rules hiEhly declarative. There are some
advantages of using Prolog in implementing LFG.
First, the Uniqueness condition on a f-structure
is fulfilled by the original unification of
Prolog. Second, an ordered binary tree is a good
data structure for representing a f-structure.
The use of an ordered binary tree reduces the
processing time by 30 percents compared with the
case using a list for representing a f-structure.
And third, the use of ID-variable also effective,
because the sharing of a f-structure can be done
only by one unification of the corresponding
ID-variables.
Though the computational complexity of the
:quational schema is very expensive, the LFG
provides expressive and natural account for
linguistic evidence. In order to overcome the
inefficiency, the introduction of parallel or
concurrent execution mechanism seems to be a
promising approach. The computation model of LFG
is similar to the constraint model of computation
[Steele 803.
The Proles implementation of LFG by Reyle and
Frey [Reyle,Frey 83] aimed at more direct
translation of functional equations into DCG.
Although their implementation is more efficient,
it does not treat the Constraining schema, set
inclusions, the compound functional equation such
as (^ vcomp subj), and the bounded dominance. And
their grammar rules seem to be too complex by
direct encoding of f-structures into them. In
order to provide an formal system having powerful
description capabilities for representing
syntactic knowledges, the more LFG primitives are
realized than their implementation and the grammar
rules are more understandable and can be more
easily modified in my implementation.
TV. THI RESULT OF AN EXPEREENT
Fiz. 6 shows the result of analyzing the
sentence &amp;quot;the girl persuaded the baby to go&amp;quot;. LFG
system is written in Dec-10 Prolog [Pereira,et.al.
73] and executed on Dec 2060.
As shown in Fig. 6, the functional control
[Iaplan,Bresnan 82] is realized in the f-structure
of vp. The value of the &amp;quot;subj&amp;quot; attribute of the
&amp;quot;vcomp&amp;quot; is functionally controlled by the &amp;quot;obj&amp;quot; of
the f-structure of the &amp;quot;s&amp;quot; node. The time used
fsr syntactic analysis includes the time consumed
by parsind process and the time consumed by
2quational schema.
V. concLusion
The Prolos implementation of LFG is
described. It is the first step of the formal
nystem for representing syntactic knowledfts. As
a :esult, it becomes quite obvious that Prolog is
suitable for implementing 1.70.
Further research on the formal system will be
carried by analyzin.: the wider variety of actual
utterances to extract the more primitives
necessLry for the analyses, and to ;ive the
seceszary schemata for those
</bodyText>
<figure confidence="0.968760095238095">
Time used in analysis is
972 ms.(parsing)
19 ms.(checkins constraints)
41 ms.(for checking completeness)
subj spec the
num sc
per 3
pred sem(girl)
pred sem(persuadeasubj,A],[obj,A],[vcomp,A]))
obj spec the
num sg
per 3
pred sem(baby)
tense past
vcomp subj spec the
num sg
per 3
pred sen( baby)
inf
pred sem(go([subj,31))
to
</figure>
<figureCaption confidence="0.974311">
Fig. 6 The result of analyzing the sentence,
&amp;quot;the girl persuaded the baby to go&amp;quot;
</figureCaption>
<sectionHeader confidence="0.519222" genericHeader="method">
VI/. ACICIOTILEDGENENTS
</sectionHeader>
<bodyText confidence="0.983191777777778">
The author is thankful to Dr. K. Furukawa,
the chief of the second research laboratory of
ICOT Research Center, and the members of the
natural language processing group in ICOT Research
Center, both for their discussion. The author is
grateful to Dr. K. Fuchi, Director of the ICOT
Research Center, for providing the opportunity to
conduct this research.
VII/. REFERENCES
</bodyText>
<reference confidence="0.992228117647059">
[Kaplan,Bresnan 82] &amp;quot;Lexical-Functional Grammar:
A Formal System for Grammatical Representation&amp;quot; in
&amp;quot;Mental Representation of Grammatical Relations&amp;quot;,
Bresnan eds., MIT Press, 1982
[Beyle,Frey 83] &amp;quot;A Prolog Implementation of
Lexical Functional Grammar&amp;quot;, Proc. of LICA/-33,
PP. 693-695, 1983
[Pereira,et.al. 78] &amp;quot;User&apos;s Guide to DC
System-10 Prolog&amp;quot;, Department of Artificial
Intelligence, Univ. of alinburgh, 1973
[Pereira,Warren 30] &amp;quot;Definite Clause Grammar for
Language Analysis -- A Survey of the Formalism and
a Comparison with Augmented Transition networks&amp;quot;,
Artificial Intelligence, 13, pp. 231-278, 1930
[Steele 80] &amp;quot;The Definition and Implementation of
a Computer Programming Language based on
Constraints&amp;quot;, HIT AI-TR-595, 1980
</reference>
<page confidence="0.998708">
361
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.317203">
<title confidence="0.999258">LFG System in Prolog</title>
<author confidence="0.992939">Hideki Yasukawa</author>
<affiliation confidence="0.9966325">The Second Laboratory .Institute for Hew Generation Computer Technology (ICOT)</affiliation>
<address confidence="0.992903">Tokyo, 108, Japan</address>
<abstract confidence="0.996806002985074">handed the baby a toy&amp;quot; (Maplan,Bresnan ABSTRACT In order to design and maintain a large scale grammar, the formal system for representing syntactic knowledge should be provided. Lexical Functional Grammar (LFG) (Kaplan,Bresnan 82] is a powerful formalism for that purpose. In this paper, the Prolog implementation of LFG system is described. Prolog provides a good tools for the implementation of LFG. LFG can be translated into DCG [Pereira,Uarren 80] and functional structures (f-structures) are generated during the parsing process. I INTRODUCTIOU The fundamental purposes of syntactic analysis are to check the grammaticality and to clarify the mapping between semantic structures and syntactic constituents. DCG provides tools for fulfilling these purposes. But, due to the fact that the arbitrary Prolog programs can be embedded into DCG rules, the grammar becomes too complicated to understand, debug and maintain. So, the development of the formal system to represent syntactic knowledges is needed. The main concern is to define the appropriate set of the descriptive primitives used to represent the syntactic knowledges. LFG seems to be promising formalism from current linguistic theories which these requirements. LFG for our preliminary version of the formal system and the Prolog implementation of LFG is described in this paper. II SInPLE OVERVIEW OF LFG In this section, the simple overview of LFG is described (See [Eaplan,Dresnan 32] for details ). LFG is an extention of context free Grammar has two-levels of representation, i.e. c-structures (constituent structures) and f-structures (functional structures). A c-structure is generated by CP G and represents the surface word and phrase configurations in a the f-structure is Generated by the associated with the grammar rules and represents the configuration of the surface grammatical functions. Fig. 1 shows the 0-structure and f-structure for the sentence &amp;quot;a det---nnp np- 1 det---n det--n 1 1 1 1 1 I 1 1 1 : 1 the baby a toy (a) c-structure subj spec a num sg tense past pred &apos;hand&lt;(T subj)(T obj2)(1 obj)&gt;&apos; obj spec the num sg pred &apos;baby&apos; obj2 spec a num sg pred &apos;toy&apos; (b) f-structure c-structure and f-structure shown 1, f-structure is hierarchical structure constructed by the pairs of attribute and its value. An attribute represents grammatical function or syntactic feature. Lexical entries specify a direct mapping between semantic arguments and configurations of surface grammatical functions, and grammar rules specify a direct mapping between these surface grammatical functions and particular constituent structure configurations. To represent these grammatical relations, several devices and schemata are provided in LFG as shown below. (a) meta variables (i) &amp; (immediate dominance) 11■&amp; dominance) (b) functional notations a designator (T subj) indicates the value of &amp;quot;subj&amp;quot; attribute of the f-structure. (c) Equational schema (i) = (functional equation) E inclusion) 358 (d) Constraining schema =c constraint) (ii) d (existential constraint) where d is a designator (iii) negation of (i) and (ii) 2 shows the example grammar lexical entries in LFG, which Generate c-structure and the f-structure in Fig. 1. 1. s -&gt; np vp (t subj)wi 2. np -&gt; det n 1=4 t=i 3. vp -&gt; v np np 1=4 (t obj).4 obj2)eir 4. det -&gt; [a] (T spec).-sa (1 num)=sg 5. det -&gt; [the] 6. n -&gt; [girl] (/ num)=sg (/ pred):&apos;girl&apos; n (/ num)msg (/ pred)ebaby&apos; 8. n -&gt; [toy] (/ num)msg pred)s&apos;toy&apos; v [handed] (1 tense)=past subj)(t obj2)(/ obj)&gt;&apos; 2 Example rules and lexical entries LFG. [Kaplan,Breenan 82]) As shown in Fig. 2, the primitives to represent grammatical relations are encoded in rules and lexical entries. Each syntactic has its own f-structure and partial value the f-structure is defined by the example, the functional &amp;quot;(7 associated with the daughter node of _ram-,ar rule 1. of Fig. 2 specifies that the value of the &amp;quot;subj&amp;quot; attribute of the f-structure of the mother &amp;quot;s&amp;quot; node is the f-structure of its &amp;quot;np&amp;quot; node. The value constraints the f-structure are specified by the Constraining schaza. 1:oreover, the Gramaticality of the sentence is defined by the three conditions shown beim. (1) Uniqueness: a particular attribute may have at .:ost one value in a Given f-structure. Completeness: a f-structure must contain governable functions Governed by its predicate. (3) Coherence: all the Governable Grammatical faoctions that a f-structure contain must be ,,overned by its predicates. OF L70 indicated section II, two distinct schemata are employed in the constructions of f-structures. In the current implementation, f-structures are generated during the parsing process by executing the functional equations and associated with each syntactic node. After the parsing is done, the f-structures are cheched whether their value assignments are consistent with the value constraints on them. The Completeness condition on grammaticality is checked after the parsing. The are realized by the Prolog programs into the DCG Equational schema is executed during the parsing process by the execution of DCG rules. The functional equation can be seen as the extension of the unification of Prolog by introducing equality on f-structures. A. Representations of Data Types The primitive data types constructing f-structures are symbols, semantic predicates, subsidiary f-structures, and sets of symbols, semantic predicates, or f-structures. In current implementation, these data types are represented : 1) symbols ==&gt; atom or integer 2) semantic predicates mg&gt; sem(X) where X is a predicate f-structure where the &amp;quot;Id&amp;quot; is an identifier variable (ID-variable). Each syntactic node has unique ID-variable which is used to identify its f-structure. The &amp;quot;Obt&amp;quot; is a ordered binary tree each leaf contains the pair of an attribute and its value. 4) set ==&gt; (element1, element2, elementU) A f-structure can be seen as a partially defined data structure, because its value is partially generated by the Equational schema during the parsing process. An ordered binary tree, obt for short, is suitable for representing partially defined data. An obt is a binary tree whose labels are ordered. A binary tree &amp;quot;Obt&amp;quot; is term of the following form. Obt = obt(v(Attr,Value),Less,Greater) The &amp;quot;v(Attr,Value)&amp;quot; is a leaf node of the tree. The &amp;quot;Attr&amp;quot; is an attribute name and used as label of the leaf node, and the &amp;quot;Value&amp;quot; value. The &amp;quot;Less&amp;quot; and &amp;quot;Greater&amp;quot; are also binary trees. The &amp;quot;Obt&amp;quot; is ordered when the nese (&amp;quot;Greater&amp;quot;) is also ordered and each label of its nodes is less (greater) label of &amp;quot;Obt&amp;quot;,i.e. &amp;quot;Attr&amp;quot;. If none of the leaf of a tree it is represented a variable. When its label is defined later, the logical variable is instantiated. The insertion of a label and its value into an obt is done by only one unification, without rewriting the tree. This is the merit in using an ordered binary tree. For example, the f-structure for the noun phrase &amp;quot;a girl&amp;quot;, the value of the &amp;quot;subj&amp;quot; in Fig.1 can be graphically represented in Fig. in the variables representing the uninstantiated subtrees. B. Functional Notation rules and the 359 ID-variable --&gt; v(spec,a) 1 v(num,sg) v(per3,3) 4.••••■•+ I I V2 V3 3 graphical representaion of an obt The functional notations are represented by ID-variables instead of Meta variables / and i.e. Meta variables must be replaced by the object level variable. For example, the associated with the category S, is described as [subj, /dS], where IdS is the 0-variable for S. The meta variables for bounded dominance are represented by the terms controllee(Cat) and controller(Cat), where the &amp;quot;Cat&amp;quot; is the name of the syntactic category of the controller or controllee. C. Predicates for LFG Primitives The predicates for each LFG primitives are as follows : (d,d1,d2 are designators, s is a set, and is a negation symbol) 1) d1 d2 -&gt; equate(d1,d2,01d,New) d s -&gt; d1 -&gt; constrain(d1,d2,01dC,NewC) 4) d -&gt; exist(d,OldC,NewC) 5) &amp;quot;(d1 =c d2) -&gt; neg_constrain(d1,d2,01dC,UewC) 6) -&gt; not_exist(d,OldC,NewC) The &amp;quot;Old&amp;quot; and &amp;quot;New&amp;quot; are global value assignments. They are used to propagate the changes of global value assignments made by the execution of each predicate. The &amp;quot;OldC&amp;quot; and &amp;quot;NewC&amp;quot; are constraint lists and used to gather all the constraints in the analysis. Zesides these predicates, the additional predicates are provided for checking a constraints during the parsing process. They are used to kill the parsing process generating inconsistent result an soon as the inconsistency is found. The predicate &amp;quot;equate&amp;quot; gets the temporary values of the designators d1 and d2, consulting the global value assignments. Then &amp;quot;equate&amp;quot; performs the unification of their values. The to set-theoretic union that it only defined of nondistinct attributes. Fig. 4 shows the example trace output of the &amp;quot;equate&amp;quot; in the course of the sentence &amp;quot;a girl baby toy&amp;quot;. In order to keep graamar rules highly understandable, it would be better to hide data, such as global value assignments or constraint lists. The macro notations similar to the original notation of LFG are provided to users for that purpose. The macro expander translates the macro notations into Prolog programs corresponding to the LFG primitives. value of designator Det is spec the The value of the designator U is pred seu(girl) Result of unification is spec the num sg pred sem(girl) Fig. 4 Tracing results of equate. This macro expansion results in considerable improvement of the writability and the understandability of the grammar. The syntax of macro notations are : (a) d1 d2 -&gt; eq(d1,d2) (b) d s -&gt; incl(d,$) d2 -&gt; c(d1,d2) (d) d -&gt; ex(d) (e) &amp;quot;(dl =c d2) -&gt; not_c(d1,d2) (f) &amp;quot;d -&gt; not,_ex(d) These macro notations for LFG primitives are placed at the third argument of the each predicate in DCG rules corresponding to syntactic categories shown in Fig. 5 (a), which corresponds to grammar rule 1. in Fig. 2. s(s(NP,VP),Id-S,[]) --&gt; np(Np,Id_Up,[eq(Csubj,I4_SLId_Np]), vp(Vp,Id_Vp,[eq(Id-S,Id-VO)]). (a) The DCG rule with macro for LFG s(s(Np,Vp),/d_S,Old,New,01dC,NewC) --&gt; np(Np,IA_Np,Old,Old1,01dC,OldC1), fequate([subj,Id_SLId_Up,Old1,01d2)}, vp(Vp,Id_Vp,01d2,01d3,01dC1,NewC), (equate(IeLS,Id_Vp,01d3,New)}. (b) The result of macro expansion Example DCG rule for LFG analysis The variables &amp;quot;Id_S&amp;quot;, &amp;quot;Id_Np&amp;quot;, and &amp;quot;Id_Vp&amp;quot; are the ID-variables for each syntactic category. example, the grammar rule in Fig. in translated into the one shown in Si;. 5 (b). descriptions translated into the corresponding predicate in the case of a grammar In the case of a lexical aacro descriptions are translated into the corresponding predicate, which is executed further more and the f-structure of the lexical entry is generated. D. Issues on the Implementation Though f-structures are constructed during the parsing process, the execution of the schema of the parsing 360 strategy. This is necessary to keep the grammar rules hiEhly declarative. There are some advantages of using Prolog in implementing LFG. First, the Uniqueness condition on a f-structure is fulfilled by the original unification of Prolog. Second, an ordered binary tree is a good data structure for representing a f-structure. The use of an ordered binary tree reduces the time by compared with the using a list a f-structure. And third, the use of ID-variable also effective, because the sharing of a f-structure can be done only by one unification of the corresponding ID-variables. Though the computational complexity of the :quational schema is very expensive, the LFG provides expressive and natural account for linguistic evidence. In order to overcome the</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<title>Lexical-Functional Grammar: A Formal System for Grammatical Representation&amp;quot; in &amp;quot;Mental Representation of Grammatical Relations&amp;quot;,</title>
<date>1982</date>
<editor>Bresnan eds.,</editor>
<publisher>MIT Press,</publisher>
<marker>[Kaplan,Bresnan 82]</marker>
<rawString>&amp;quot;Lexical-Functional Grammar: A Formal System for Grammatical Representation&amp;quot; in &amp;quot;Mental Representation of Grammatical Relations&amp;quot;, Bresnan eds., MIT Press, 1982</rawString>
</citation>
<citation valid="true">
<title>A Prolog Implementation of Lexical Functional Grammar&amp;quot;,</title>
<date>1983</date>
<booktitle>Proc. of LICA/-33,</booktitle>
<pages>693--695</pages>
<marker>[Beyle,Frey 83]</marker>
<rawString>&amp;quot;A Prolog Implementation of Lexical Functional Grammar&amp;quot;, Proc. of LICA/-33, PP. 693-695, 1983</rawString>
</citation>
<citation valid="true">
<title>User&apos;s Guide to DC System-10 Prolog&amp;quot;, Department of Artificial Intelligence, Univ. of alinburgh,</title>
<date>1973</date>
<marker>[Pereira,et.al. 78]</marker>
<rawString>&amp;quot;User&apos;s Guide to DC System-10 Prolog&amp;quot;, Department of Artificial Intelligence, Univ. of alinburgh, 1973</rawString>
</citation>
<citation valid="true">
<title>Definite Clause Grammar for Language Analysis -- A Survey of the Formalism and a Comparison with Augmented Transition networks&amp;quot;,</title>
<date>1930</date>
<journal>Artificial Intelligence,</journal>
<volume>13</volume>
<pages>231--278</pages>
<marker>[Pereira,Warren 30]</marker>
<rawString>&amp;quot;Definite Clause Grammar for Language Analysis -- A Survey of the Formalism and a Comparison with Augmented Transition networks&amp;quot;, Artificial Intelligence, 13, pp. 231-278, 1930</rawString>
</citation>
<citation valid="true">
<title>The Definition and Implementation of a Computer Programming Language based on Constraints&amp;quot;,</title>
<date>1980</date>
<booktitle>HIT AI-TR-595,</booktitle>
<marker>[Steele 80]</marker>
<rawString>&amp;quot;The Definition and Implementation of a Computer Programming Language based on Constraints&amp;quot;, HIT AI-TR-595, 1980</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>