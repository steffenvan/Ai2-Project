<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<sectionHeader confidence="0.584117333333333" genericHeader="method">
QUANTIFIER SCOPING
IN THE SRI CORE LANGUAGE ENGINE
Douglas B. Moran
Artificial Intelligence Center
SRI International
333 Ravenswood Avenue
</sectionHeader>
<keyword confidence="0.261299">
Menlo Park, California 94025, USA
</keyword>
<sectionHeader confidence="0.87724" genericHeader="method">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.99992506">
An algorithm for generating the possible quanti-
fier scopings for a sentence, in order of preference,
is outlined. The scoping assigned to a quantifier is
determined by its interactions with other quan-
tifiers, modals, negation, and certain syntactic-
constituent boundaries. When a potential scoping
is logically equivalent to another, the less preferred
one is discarded.
The relative scoping preferences of the individ-
ual quantifiers are not embedded in the algorithm,
but are specified by a set of rules. Many of the
rules presented here have appeared in the linguis-
tics literature and have been used in various natu-
ral language processing systems. However, the co-
ordination of these rules and the resulting coverage
represents a significant contribution. Because ex-
perimental data on human quantifier-scoping pref-
erences are still fragmentary, we chose to design a
system in which the set of preference rules could
be easily modified and expanded.
The algorithm described has been implemented
in Prolog as part of a larger natural language pro-
cessing system. Extensions of this algorithm are
in progress.
Each of these sentences has two quantifier scop-
ings: in one, &amp;quot;every&amp;quot; has wider scope over &amp;quot;a,&amp;quot;
and while in the other, &amp;quot;a&amp;quot; has the wider scope.
However, the readings that most people obtain for
these sentences are quite different. In (1), the
reading in which &amp;quot;a&amp;quot; has wider scope is highly
preferred; in (3), the reading in which &amp;quot;every&amp;quot; has
wider scope is highly preferred; in (2), the reading
with wide-scope &amp;quot;every&amp;quot; is preferred, but wide-
scope &amp;quot;a&amp;quot; is also acceptable. A plausible expla-
nation for the difference between (1) and (2) is
that, since the typical house is located on a street
but not on a square, the default preference rep-
resented by (2) is overridden by a conversational
maxim of quantity—if &amp;quot;a street&apos; has narrow scope,
&amp;quot;on a street&amp;quot; would contribute too little informa-
tion to justify its presence. A plausible explana-
tion for the difference between (2) and (3) is based
on the relationship among the components. The
reading of (3) in which &amp;quot;a&amp;quot; is given wider scope is
improbable because the domain of quantification
for &amp;quot;every&amp;quot; would then be the single patient in
the selected room—an infelicitous use of &amp;quot;every,&amp;quot;
whereas there is no similar problem in (2) because
there are normally multiple houses on a square.
Similarly, in
</bodyText>
<subsectionHeader confidence="0.5148285">
John visited a person on every committee. (4)
INTRODUCTION John visited a house on every street. (5)
</subsectionHeader>
<bodyText confidence="0.99734345">
One of the major sources of ambiguity in sen-
tences results from the different scopes that can be
assigned to the various quantified noun phrases in
the sentence. Part of the problem in determining
the preferred scopings of quantifiers is the number
of factors involved. For example, consider these
three sentences
John visited every house on a street.
John visited every house on a square.
John visited every patient in a private room.
the reading in which &amp;quot;a&amp;quot; has wider scope is reason-
able for (4) but not for (5)—in a normal domain
of discourse, it is conceivable that there could be
a person who is on all of the committees, but it is
highly improbable that the geometry of the streets
is such that a single house could be located on all
of them.
In (1), (3), and (5), discourse criteria and do-
main information seem to be the primary factors
in determining the preferred quantifier scopings,
</bodyText>
<listItem confidence="0.913016">
• whereas in (2) and (4), linguistic criteria seem to
</listItem>
<page confidence="0.998424">
33
</page>
<bodyText confidence="0.998587857142857">
be the determining factors.
Our approach presumes that the determination
of a sentence&apos;s preferred scoping can be divided
into two phases, the first of which is the subject of
the algorithm described here. In this initial phase,
linguistic information is used to generate the possi-
ble quantifier scopings in order of preference. The
relevant linguistic information consists of surface
position, syntactic structure, and the relationship
among the function words (determiners, modals,
and negation). In the second phase (future work),
domain and discourse information is applied suc-
cessively to these scopings, modifying the scores
produced by the first phase. We expect that the
modifications will be only penalties, thus making
it possible to identify the best choice when it is en-
countered (cutting off the processing of remaining
scopings generated by the first phase).
The primary study of quantifier scoping prefer-
ences was done by VanLehn (1978). The experi-
mental data reported therein was of limited useful-
ness in developing the algorithm described here—
it was gathered and evaluated under assumptions
arising from a different linguistic theory.
We shall first present the rules that governed the
structure of our design, then outline the algorithm.
This scoping algorithm has been implemented as
a component of a larger system that is under con-
tinuing development. In this system, called the
Core Language Engine or CLE (Alshawi et al.,
1987), the semantic interpretation phase produces
unscoped logical forms in which quantifier expres-
sions are represented by quantifier terms (qterms).
For example, the sentence &amp;quot;John saw a student&amp;quot;
has the unscoped logical form&apos;
</bodyText>
<subsectionHeader confidence="0.628435">
see(john&apos;,qterm(a ,X,student&apos;(X)))
</subsectionHeader>
<bodyText confidence="0.97542625">
Since the only permissible scope for this quanti-
fier is the whole sentence, the qterm is raised to
produce the scoped logical form
quant(3,X,student&apos;(X), see&apos;(john&apos;,X))
The qterm expression can best be thought of as a
quant expression before its scope has been estab-
lished. In the above qterm and quant expressions,
student&apos;(X) is the restriction of the quantified
variable X; that is, it specifies a set of the pos-
sible values of X over which the quantifier ranges.
&apos;The logical form&apos;s syntax in the implementation is ac-
tually [seeljohnl,qterm(al,X,[studentl,X1)], but the more
conventional notation will be used for perspicuity.
In the above quant expression, see&apos;(john&apos;,X) is re-
ferred to as either the body or the scope of the
quantifier. This treatment of the logical form of
quantifiers follows that employed in many previ-
ous systems (e.g., LUNAR (Woods, 1977), Moore
(1981), Barwise and Cooper (1981), and Hobbs
and Shieber (1987)).
</bodyText>
<sectionHeader confidence="0.995428" genericHeader="method">
RULES AND PREFERENCES
</sectionHeader>
<bodyText confidence="0.995615636363636">
Many of the following rules have appeared in
various forms in multiple places in the literature,
and most natural language processing systems in-
clude some mechanism for selecting a preferred
quantifier scoping. However, the published de-
scriptions of many of those systems&apos; capabilities
tend to be cursory, with the scoping rules utilized
in the LUNAR system still among the best de-
scribed in the NLP literature. Because of space
limitations, it is not possible to cite much of this
discussion, nor to compare this system to others.
</bodyText>
<construct confidence="0.948781571428572">
Rule 1 A quantifier A that is not in the restric-
tion of quantifier B and that occurs within the
scope of B cannot outscope any of the quantifiers
in the restriction of B.
Rule 2 If a quantifier is raised past an operator,
then any quantifier that occurs within its mstric-
lion must also be raised past that operator.
</construct>
<bodyText confidence="0.921892">
These rules, presented by Hobbs and Shieber
(1987), can best be explained with examples.
A bishop visits every, chapel by a river. (6)
has an unscoped logical form of
visit&apos;(qterm(a B, bishop &apos;( B)),
qterm(every&apos;,C,and(chaper(C),
by&apos;(C,qterm(a&apos;,R,river&apos;(R))))))
The following is one of the possible permuta-
tions of the quantifiers, but is not a valid scop-
ing because the restriction of &amp;quot;every&amp;quot; (&amp;quot;chapel by
a river&amp;quot;) has been fragmented:
*q u a nt(V, C, ch a per ( C),
quant(3,B,bishop&apos;(B),
quant(3,R,and(river&apos;(R),by&apos;(C,R)),
visit&apos;(B,C))))
Similarly, for the sentence
John did not visit a chapel by a river. (7)
the quantifier permutation
</bodyText>
<page confidence="0.995081">
34
</page>
<figure confidence="0.886923285714286">
*quant(3,C,chaper(C),
not(quant(3,R,and(river&apos;(R),by&apos;(C,R)),
visit&apos;(john&apos;,C))))
is not a possible scoping of the unscoped logical
form
not(visit&apos;aohn&apos;,qterm(a&apos;,C,and(chaper(C),
by.(C,qterm(a&apos;,R,river&apos;(R)))))))
</figure>
<construct confidence="0.927723666666667">
Rule 3 For a set of quantifiers, which quantifier
receives wide-scope preference can be determined
by a pairwise comparison of the determiners. This
comparison is based upon a combination of factors
that include their relative strengths and surface po-
sitions, and whether or not either has been raised.
</construct>
<bodyText confidence="0.991945636363636">
In many systems, determiners are assigned nu-
merical strengths and these values are compared to
determine what scope should be assigned to each
quantifier. Such a ranking is implicit in our prefer-
ence rules and can be viewed as a first approxima-
tion of the relationships represented by our rules.
Our algorithm permits a set of properties to be
associated with determiners and for these to be
used in ascertaining which determiner has wide-
scope preference. The properties currently em-
ployed are surface position (the integer index of
the determiner) and a Boolean value indicating
when a quantifier has already been raised.
Preference 3.1 There is a strong preference for
&amp;quot;each&amp;quot; to outscope other determiners.
That &amp;quot;each&amp;quot; is the strongest determiner is a
common feature of most quantifier-scoping treat-
ments. However, the evidence for the relative
strengths of the remaining quantifiers is much less
clear—our current ranking of them is an ad hoc
blending of those in TEAM (Grosz et al., 1987)
and VanLehn (1978).
</bodyText>
<construct confidence="0.87583">
Preference 3.2 There is a strong preference for
WH-terms to outscope all determiners except
&amp;quot;each,&amp;quot; which outscopes WH-terms.
</construct>
<bodyText confidence="0.98778425">
In the unscoped logical forms currently pro-
duced, WH-words (&amp;quot;which,&amp;quot; &amp;quot;who,&amp;quot; &amp;quot;what&amp;quot;) and
phrases are represented as qterms. Our scoping-
preference rules assign wide scope to &amp;quot;each&amp;quot; in
</bodyText>
<subsubsectionHeader confidence="0.409892">
Which exams did each student pass? (8)
</subsubsectionHeader>
<bodyText confidence="0.927379434782609">
There is a reported dialect in which sentences of
the above form are judged to be malformed, but
that dialect was not found among our informants.
The design of our algorithm makes it easy to re-
place the current preferences with these.
The definite determiner &amp;quot;the&amp;quot; is currently
treated as a very strong quantifier, but this ap-
proach is not entirely satisfactory. Consider
Every student passed the exam. (9)
The student in every ince celebrated. (10)
The student in each race celebrated. (11)
Every student in the race celebrated. (12)
Each student in the race celebrated. (13)
In (9)–(12), the preferred scopings are as predicted
by the rules. However in (13), the preferred read-
ing selected is the one with wide-scope &amp;quot;each.&amp;quot; Al-
though both scopings of this sentence are logically
equivalent (as are those for (9) and (12)), wide-
scope &amp;quot;the&amp;quot; seems to be the preferred reading.
Our algorithm does not distinguish between spe-
cific and nonspecific use of indefinite articles. It is
debatable whether this belongs in quantifier scop-
ing or in another part of the system.
</bodyText>
<construct confidence="0.98778725">
Preference 3.3 A logically weaker interpretation
is preferred. This preference is strong when it
maintains surface order, weak when it inverts sur-
face order.2
</construct>
<bodyText confidence="0.964081666666667">
The quantifier order V3 is weaker than 3V, ac-
counting for the preferences in
A man loves every woman. (14)
Every man loves a woman. (15)
In both sentences, the reading with wide-scope
&amp;quot;every&amp;quot; is the preferred one; the reading with
wide-scope &amp;quot;a&amp;quot; is possible for (14), but is very
strained for (15).
Rule 4 Raising a quantifier out of certain syntac-
tic constituents changes the strength of its deter-
miner.
VanLehn presents an &amp;quot;embedding hierarchy&amp;quot; of
the probability of a quantifier in the modifier of
an NP being raised to have wider scope than the
quantifier in the NP&apos;s head
2 VanLehn proposes a more general form of this
preference—that, when comparing two quantifiers within
the same general group, the &amp;quot;more numerous&amp;quot; one will have
a preference for wider scope. For example, &amp;quot;many&amp;quot; would
take wider scope over &amp;quot;few.&amp;quot; However, for everything ex-
cept &amp;quot;every&amp;quot; / &amp;quot;a,&amp;quot; such preferences appear to be very slight.
</bodyText>
<page confidence="0.996005">
35
</page>
<note confidence="0.372397">
PP &gt; Reduced Relative Clause &gt; Relative Clause
</note>
<bodyText confidence="0.990595666666666">
A method frequently proposed to account for this
distinction is to use, as a measure of the cost of
raising, a count of the number of nodes in the syn-
tactic structure over which the quantifier is raised.
However, such accounts are acknowledged to have
various deficiencies and to be overly sensitive to
the syntactic representation used. We have cho-
sen to permit rules to associate a cost for raising a
quantifier with certain types of nodes (other nodes
can be viewed as having zero costs). This capabil-
ity of the system is currently invoked only on an
all-or-nothing basis.
Preference 4.1 A quantifier cannot be raised
across more than one major clause boundary.
A common rule in the quantifier-scoping litera-
ture is &amp;quot;quantification is generally clause bound.&amp;quot;
While it is possible to generate sentences with
acceptable readings when a quantifier has wider
scope than the clause in which it occurs, we have
been unable to find any examples showing that it
can be raised out of two clauses.
</bodyText>
<construct confidence="0.825305">
Preference 4.2 A quantifier cannot be raised out
of a relative clause.
</construct>
<bodyText confidence="0.995623083333333">
This is a common restriction in many quantifier-
scoping algorithms. In our system, this is not a
special rule, but one of the preferences. Conse-
quently, this could easily be modified from never
being permitted to being &amp;quot;highly unpreferred.&amp;quot;
Rule 5 In unscoped logical form, quantifiers can
occur within the scope of an opaque operator.
Whether or not to raise such a quantifier outside
that operator is determined by a pairtvise compar-
ison between the operator and the determiner in
the quantifier, as well as by their relative surface
position.
</bodyText>
<construct confidence="0.936448333333333">
Preference 5.1 There is a strong preference for
&amp;quot;some&amp;quot; to outscope negation.
Preference 5.2 There is a preference for nega-
tion to outscope &amp;quot;every.&amp;quot; This preference is strong
when it maintains surface order, weak when it
doesn&apos;t.
</construct>
<bodyText confidence="0.801274782608696">
Different scopings of &amp;quot;some&amp;quot; and &amp;quot;every&apos; under
negation produce equivalent readings (3-, is equiv-
alent to -Ai). The preferred scopings for the two
sentences
John did not see someone. (16)
John did not see everyone. (17)
have equivalent logical forms
q u a nt(3, P, person &apos;( P), not(see &apos;(joh n&apos;,P)))
not(quant(V,P,person&apos;(P),see&apos;(john&apos;,P)))
Similarly, the preferred scopings of sentences
Someone did not see John. (18)
Everyone did not see John. (19)
have equivalent logical forms
quanta P, person 1 P), not(see &apos;( P, john&apos;)))
not(q uant(V,P,person &apos; ( P),see&apos;( P. john &apos;)))
The reading of (16), which would assign nar-
row scope to &amp;quot;some&amp;quot; is produced by substituting
&amp;quot;any&amp;quot; for &amp;quot;some&amp;quot;:
John did not see anyone. (20)
This has the following logical form (no other scop-
ings exist):
not(quant(3,P,person&apos;(P),see&apos;(john&apos;,P))) ,
which is logically equivalent to
q u a nt(V, P, person &apos;( P),not(see&apos;( joh n &apos; ,P))) ,
which corresponds to the strongly &amp;quot;unpreferred&amp;quot;
readings of (16) and (17). Similarly, the sentence
No one saw John. (21)
which has a scoped logical form of
q u a nt(V, P, person &apos; ( P),not(see&apos;( P, john &apos;)))
corresponds to the &amp;quot;unpreferred&amp;quot; scoping for (18)
and (19).
One of LIJNAR&apos;s scoping rules was that in
the antecedent of &amp;quot;if-then&amp;quot; statements, quantifiers
&amp;quot;some&amp;quot; and &amp;quot;any&amp;quot; should be assigned wide scope,
and that &amp;quot;a&amp;quot; and &amp;quot;every&amp;quot; should be given nar-
row scope. If such antecedents were treated as a
negative environment (or equivalent thereto), the
foregoing preferences could produce this effect.
3The CLE system does not currently provide a treat-
ment of &amp;quot;any.&amp;quot; However, within the quantifier-scoping
component, &amp;quot;any&amp;quot; is treated as being potentially am-
biguous between the usual universal quantifier, free-
choice &amp;quot;any,&amp;quot; and a second form, polarity-sensitive &amp;quot;any,&amp;quot;
which occurs in conjunction with negative-polarity items.
Polarity-sensitive &amp;quot;any,&amp;quot; is treated as a narrow-scope exis-
tential quantifier (Ladusaw, 1980).
</bodyText>
<page confidence="0.995562">
36
</page>
<construct confidence="0.6204083">
Preference 5.3 There is a strong preference for
free-choice &amp;quot;any&amp;quot; to have wider scope than modals.
There is a strong preference for all other determin-
ers that occur within the scope of a modal to have
narrower scope than that modal.
Did some student take every test? (22)
Does some student take every test? (23)
Some student took every test. (24)
Some student takes every test. (25)
Some student is taking every test. (26)
</construct>
<bodyText confidence="0.9995869">
For sentences (23), (25), and (26), there are two
acceptable quantifier scopings. However, for (22)
and (24), the scoping in which &amp;quot;every&amp;quot; is assigned
narrower scope seems to be strongly preferred. We
ascribe this to the presence in the logical form
of a modal operator corresponding to the past
tense. This effect is accentuated in (27), which ex-
hibits an ambiguity resulting from whether &amp;quot;some
teacher&amp;quot; is scoped inside or outside the modal, cor-
responding to (28) and (29), respectively:
</bodyText>
<construct confidence="0.807910333333333">
Some teacher took every course. (27)
Last summer, some teacher took every course(28)
As a student, some teacher took every course.(29)
</construct>
<bodyText confidence="0.948678692307692">
The scoping in which &amp;quot;ever?&apos; outscopes &amp;quot;some&amp;quot;
is possible, although unpreferred, for the reading
(28); but it is not a possible scoping for (29) in
any dialect that we have encountered.
Rule 6 If polarity-sensitive &amp;quot;any&amp;quot; occurs within a
clause in which its trigger does not occur, it must
be raised out of that clause.
De Dicto/De Re The mechanism described here
can provide an account for the de dicto/de re dis-
tinction.
Another ambiguity associated with quantifier
terms is whether or not the referent is required
to exist. In PTQ (Montague, 1973), the sentence
</bodyText>
<subsectionHeader confidence="0.77811">
John seeks a unicorn. (30)
</subsectionHeader>
<bodyText confidence="0.93008116">
is assigned a de dicto reading (which does not re-
quire that any unicorns exist),
seekVjohn&apos;,-A(P,quant(3,X,unicorn&apos;(X),-P(X))))
and a de re reading (which requires the existence
of some unicorn)
quant(3,X,unicorn&apos;(X),seek&apos;Cjohn&apos;,&amp;quot;A(P,T(X))))
In PTQ, this distinction is produced by syntactic
rules. Cooper (1975, 1983) demonstrated that a
mechanism using a store could produce both read-
ings from a single logical form.
Our mechanism obtains similar results. Starting
from the unscoped logical form
seek&apos;cjohn&apos;,&amp;quot;A(P,-.P(qterm(a&apos;,X,unicorn.(X)))))
with the intension operator treated as being op-
tionally opaque, both readings are produced by
the quantifier-scoping algorithm described here.
Additional (unwarranted) scopings are not pro-
duced because these are the only two sites at which
quantifiers can be pulled from the store.
Nonrule There is a strong preference for a noun
phrase in a prepositional phrase complement to
outscope the head noun.
This criterion is used in many quantifier scoping
mechanisms. It is a good heuristic, but it is not a
reliable rule. In
</bodyText>
<subsectionHeader confidence="0.3527505">
John visited every house on a street. (31)
John visited every house with a dog. (32)
</subsectionHeader>
<bodyText confidence="0.999868166666667">
the heuristic correctly predicts the preferred scop-
ing for (31), but fails for (32).4 This heuristic is
not part of our scoping algorithm; we believe that
its effects are part of the processing consigned by
us to the second phase of quantifier scoping (future
work).
</bodyText>
<sectionHeader confidence="0.858794" genericHeader="method">
BASIC ALGORITHM
</sectionHeader>
<bodyText confidence="0.999980176470588">
The first level of our scoping algorithm gener-
ates the possible scopings, as described by Hobbs
and Shieber (1987). However, we implemented
this with a different algorithm, partly for reasons
of efficiency and partly because it could be easier
expanded to include additional capabilities. The
performance of the Hobbs and Shieber algorithm
deteriorates as the number of quantifiers in the
sentence increases—our analysis is that it spends
a significant amount of time repeatedly travers-
ing the logical form and doing structure copying
(their goal was to produce a provably correct algo-
rithm, not a highly efficient one). Our algorithm
traverses the unscoped logical form, collecting the
qterms (quantifier terms) into a store; then. as the
scoping for each qterm is determined, it is pulled
out of the store, producing a scoped logical form.
</bodyText>
<footnote confidence="0.944538">
4This was brought to my attention by Richard Crouch.
</footnote>
<page confidence="0.999594">
37
</page>
<bodyText confidence="0.891296428571429">
For a sentence with four quantifiers, our algorithm
is typically an order of magnitude faster than that
presented by Hobbs and Shieber.
A simple example of the use of the store is pro-
vided by the sentence &amp;quot;John saw a student,&amp;quot; which
has an unscoped logical form of
see&apos;aohn&apos;,qterm(a&apos;,X,student&apos;(X)))
After quantifier scoping has placed the qterm in
the store, the logical form is
see &apos;(joh n ,X)
and the store is
[[qterm(a&apos;,X,student.(X))1]
The scope for this quantifier is the whole sentence,
so the qterm is pulled out of the store to produce
the scoped logical form
quant(3,X,student&apos;(X), see&apos;(john&apos;,X))
The sentence &amp;quot;Few students pass most exams&amp;quot; has
the unscoped logical form
pass&apos;(qterm(few&apos;,X,student&apos;(X)),
qterm(most&apos;,Y,exam.(Y)))
After the qterms have been extracted, the remain-
ing logical form and the store are
pass.(X,Y)
[[qterm(few&apos;,X,student&apos;(X))] ,
[qterm(most&apos;,Y,exam&apos;(Y)))]]
A qterm can have other qterms in its restric-
tion and our quantifier store is a structured col-
lection (unlike the stores of Cooper and LUNAR).
The structure of qterms in the store corresponds
to their relative positions in the unscoped logical
form. For example, the unscoped logical form for
&amp;quot;every student in a college attends the lecture&amp;quot; is
attend&apos;(qterm(every&apos;,X,and(student&apos;(X),
in&apos;(X,qterm(a&apos;,Y,college&apos;(Y))))),
qterm(the&apos;,Z,lecture&apos;(Z)))
When such qterms are placed in the store, this re-
lationship is maintained by representing the col-
lected qterms as trees (called qtrees), with the
outer qterm as the root and those in its restric-
tion as daughters:
[[qterm(every&apos;,X,and(student&apos;(X),in&apos;(X,Y))),
qterm(a&apos;,Y,college&apos;(Y))] ,
Eqterm(the&apos;,Z,lecture&apos;(Z))1]
Consequently, the store is a forest of such qtrees,
and the qterms occurring in the restriction of a
qterm are themselves a forest of qtrees and are
treated as if they were a store.
As qterms are collected, they are inserted into
the store in inverse order of preference—e.g., the
qterm that has narrowest-scope preference appears
at the front of the list representing the forest. In
implementing this algorithm in Prolog, we found
that it was considerably easier to generate the
scopings by working from the narrowest to the
widest scope, rather than vice versa. As the vari-
ous permutations of the quantifiers are generated,
equivalent scopings are detected, and all but the
most preferred one are then filtered out. In the
following, both scopings of each sentence are logi-
cally equivalent:
Every student takes every test. (33)
Every student takes each test. (34)
A student takes a test. (35)
</bodyText>
<subsectionHeader confidence="0.7808">
Some student takes a test. (36)
</subsectionHeader>
<bodyText confidence="0.994544681818182">
Each student takes the test. (37)
Every student takes the test. (38)
The student takes every test. (39)
In (33), (35), (37), and (39), the preferred order is
the same as the surface order, while in (34), (36),
and (38), the stronger quantifier occurs second in
surface order, and the scoping that corresponds
to surface order is discarded. Filtering of equiva-
lent permutations is achieved simply by compar-
ing the qtree currently being pulled from the store
with the preceding one; if the quantifiers in their
head qterms are logically equivalent, this quantifier
scoping is discarded unless the qtree being pulled
has wide-scope preference over its predecessor (in
which case the other logically equivalent ordering
will be discarded).
Logically equivalent scopings can also be pro-
duced when a quantifier is raised out of the restric-
tion of another. However, the quantifier permuta-
tions that produce equivalent scopings by raising
are a subset of those produced by permuting sib-
lings:
</bodyText>
<equation confidence="0.460100428571429">
Every student in every race celebrated. (40)
A student in a race celebrated. (41)
Some student in a race celebrated. (42)
38
Each student in the race celebrated. (43)
Every student in the race celebrated. (44)
The student in every race celebrated. (45)
</equation>
<bodyText confidence="0.947394766666667">
Note that the scopings for (40) and (45) are not
logically equivalent. The scopings in the others
are logically equivalent, but in (41) and (43), the
preferred scoping is the one corresponding to con-
stituent structure, whereas in (42) and (44), the
preferred scoping has the NP from the PP raised
to have wider scope over the head noun.
When a qtree is pulled from the store, the algo-
rithm tries to produce additional permutations by
raising subsets of qterms (actually of qtrees) out of
that qtree&apos;s restriction. When a qtree is raised, it
is put back into the store—since qtrees are being
assigned scope from narrowest to widest, this en-
sures that a raised qtree will receive wider scope
than the qtree out of which it was raised.
Because a raised qtree may have its strength re-
duced when it is placed back in the store (an op-
tion in our system), a set of logically equivalent
scopings could have all instances filtered out by
a naive implementation. The problem arises in
the following manner. Before the qtree is raised,
the algorithm determines that the unraised scop-
ing is logically equivalent to a raised one and that
the latter is preferred, so it discards the former.
When the qtree is raised and its strength reduced,
it becomes weaker than the qtree out of which
it was raised. The algorithm detects that the
raised scoping is logically equivalent to an unraised
one, and determines—on the basis of the current
strengths—that the unraised scoping is preferred,
so it now discards the raised one. This problem is
avoided by doing some additional bookkeeping.
The current implementation of the above rules
is very coarse-grained. The &amp;quot;score&amp;quot; indicating
whether or not a quantifier should be assigned
wide scope over another quantifier, logical form
operator (e.g., a modal, negation), or syntactic
constituent is one of four values: always (narrow
scope is impossible), never (wide scope is impos-
sible), pref (wide scope is preferred, but narrow
scope is acceptable), and unpref (narrow scope
is preferred). In the current implementation of
the above preferences, a strong preference to take
wider scope is treated as an instance of always,
and a weak preference is treated as pref. For ex-
ample, Preferences (3.1)–(3.3) are given by the fol-
lowing rules, in which Pref is the preference of a
determiner Detl to take wider scope over another
determiner Det2:
if Detl and Det2 are both &amp;quot;each&amp;quot;:
– if Detl precedes Det2 in surface order,
Pref = pref,
– otherwise, Pref = unpref
otherwise, if Detl is &amp;quot;each&amp;quot; (and Det2 is
not), Pref = always
otherwise, if Detl is an interrogative
determiner, Pref = always
otherwise, if the logical forms for Detl and
Det2 are V and 3, respectively:
– if Detl precedes Det2 in surface order,
Pref = always
– otherwise, Pref = pref.
Overshoot The method described here results in
some quantifiers&apos; being assigned scopes that are
wider than appropriate, relative to other predicates
(but not quantifiers) in the logical form.
The sentence &amp;quot;John visited every person on a
committee&amp;quot; has an unscoped logical form of
visit&apos;aohn&apos;,qterm(every&apos;,P,and(person&apos;(P),
on&apos;(P,qterm(a&apos;,C,committee&apos;(C))))))
and its preferred scoping is
quant(V,P,quant(3,C,committee(C),
and(person&apos;(P),on&apos;(P,C))),
visit&apos;(john&apos;,P))
Note that person(P) is independent of C; thus it
can be outside the scope of the quantifier for C
quant(V,P,and(person&apos;(P),
quant(3,C,committee&apos;(C),on&apos;(P,C))),
visit&apos;(john&apos;,P))
Such transformations can have a significant im-
pact on the performance of the system, substan-
tially reducing the processing time of queries for
even a modest database. Rather than pass ad-
ditional information so that quantifiers could be
pulled at the correct point in the traversal of the
logical form, we chose to let the scoping algorithm
&amp;quot;overshoot&amp;quot; its mark and then lower the quanti-
fiers to the correct position. This was considerably
easier to implement, and it does not seem to have
any performance penalty in our system.
</bodyText>
<sectionHeader confidence="0.99868" genericHeader="conclusions">
CONCLUSION
</sectionHeader>
<bodyText confidence="0.997772666666667">
For lack of a reasonable corpus of human quan-
tifier scoping preferences, the testing of this sys-
tem has been limited to checking conformance to
</bodyText>
<page confidence="0.997899">
39
</page>
<bodyText confidence="0.999987238095238">
the stated rules.5 The semantic component of the
CLE does not produce logical forms with mass or
count NPs or collective readings, but that capa-
bility is currently being developed. The foregoing
description of qterms is a slight simplification; an
extended form is now being used to support gen-
eralized quantifiers in the new semantic rules.
Examples offered by VanLehn (1978) indicate
that dative movement affects quantifier scoping,
but the cause may actually be domain or discourse
information. Our examples show that passiviza-
tion affects quantifier scoping, but we have not yet
found a means of determining whether the effect
is due solely to the cost of raising out of the PP.
The algorithm does not handle &amp;quot;donkey sen-
tences,&amp;quot; nor is it intended to. A scheme for han-
dling such sentences is being explored as part of
the continuing development of the CLE (Fernando
Pereira, personal communication). This would be
a separate mechanism, rather than an extension
of quantifier scoping.
</bodyText>
<sectionHeader confidence="0.999004" genericHeader="acknowledgments">
ACKNOWLEDGMENTS
</sectionHeader>
<bodyText confidence="0.9991954">
The research on which this paper is based was
supported by the Natural Language Processing
Club (NATTIE) of the Alvey Directorate program
in Intelligent Knowledge-Based Systems (Project
No. ALV/P1U/IKBS/105). Most of it was per-
formed while I was a member of SRI&apos;s Cambridge
Computer Science Research Centre. This work
benefited from extensive discussion with and sug-
gestions from Robert C. Moore and Hiyan Al-
shawi.
</bodyText>
<sectionHeader confidence="0.999659" genericHeader="references">
REFERENCES
</sectionHeader>
<reference confidence="0.999766825396826">
Alshawi, Hiyan; Moore, Robert C.; Moran, Dou-
glas B.; and Pulman, Steven G. 1987. Re-
search Programme in Natural-Language Pro-
cessing, Annual Report to the Natural Lan-
guage Processing Club (NATTIE) of the
Alvey Directorate Program in Intelligent
Knowledge-Based Systems, Cambridge Com-
puter Science Research Centre, SRI Interna-
tional, Cambridge, England.
Barwise, Jon and Cooper, Robin 1981. General-
ized Quantifiers and Natural Language. Lin-
guistics and Philosophy 4(2): 159-219.
5The range of quantified noun phrases covered in the
algorithm is larger than what is currently produced by
the syntactic and semantic components of the CLE sys-
tem. Such extensions have been tested by starting from
the anticipated logical form.
Cooper, Robin 1975. Montague&apos;s Semantic The-
ory and Transformational Syntax. Ph.D. dis-
sertation, Department of Linguistics, Uni-
versity of Massachusetts at Amherst, Mas-
sachusetts.
Cooper, Robin 1983. Quantification and Syntactic
Theory, D. Reidel, Dordrecht, Holland.
Grosz, Barbara J.; Appelt, Douglas E.; Mar-
tin, Paul A.; and Pereira, Fernando C.N.
1987. TEAM: An Experiment in the De-
sign of Transportable Natural-Language In-
terfaces. Artificial Intelligence 32(2): 173-
243.
Hobbs, Jerry R. and Shieber, Stuart M. 1987. An
Algorithm for Generating Quantifier Scop-
ings. Computational Linguistics, 13(1-2): 47-
63.
Ladusaw, William 1980. Polarity Sensitivity as
Inherent Scope Relations. Ph.D. disserta-
tion, Department of Linguistics, University of
Texas at Austin; published by Garland Press,
New York, New York.
Montague, Richard 1973. The Proper Treat-
ment of Quantification in Ordinary English.
In: Hintikka, J.; Moravcsik, J.; and Sup-
pee, P. (eds.) 1973. Approaches to Natu-
ral Language, D. Reidel, Dordrecht, Holland:
221-242. Reprinted in: Montague, Richard
1974. Formal Philosophy: Selected Papers of
Richard Montague, edited and with an intro-
duction by Richmond Thomason, Yale Uni-
versity Press, New Haven, Connecticut: 247-
270.
Moore, Robert C. 1981. Problems in Logical
Form. In Proc. of the 19th Annual Meeting
of the Association for Computational Linguis-
tics: 117-124.
VanLehn, Kurt A. 1978. Determining the Scope of
English Quantifiers. Report AI-TR-483, Arti-
ficial Intelligence Laboratory, Massachusetts
Institute of Technology, Cambridge, Mas-
sachusetts.
Woods, William A. 1977. Semantics and Quantifi-
cation in Natural Language Question Answer-
ing. In: Advances in Computers, Volume 17,
Academic Press, New York, New York: 1-87.
</reference>
<page confidence="0.998626">
40
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.001568">
<title confidence="0.987717">QUANTIFIER SCOPING IN THE SRI CORE LANGUAGE ENGINE</title>
<author confidence="0.999821">Douglas B Moran</author>
<affiliation confidence="0.999736">Artificial Intelligence Center SRI International</affiliation>
<address confidence="0.998461">333 Ravenswood Avenue Menlo Park, California 94025, USA</address>
<abstract confidence="0.990864031866465">An algorithm for generating the possible quantifier scopings for a sentence, in order of preference, is outlined. The scoping assigned to a quantifier is determined by its interactions with other quantifiers, modals, negation, and certain syntacticconstituent boundaries. When a potential scoping is logically equivalent to another, the less preferred one is discarded. The relative scoping preferences of the individual quantifiers are not embedded in the algorithm, but are specified by a set of rules. Many of the rules presented here have appeared in the linguistics literature and have been used in various natural language processing systems. However, the coordination of these rules and the resulting coverage represents a significant contribution. Because experimental data on human quantifier-scoping preferences are still fragmentary, we chose to design a system in which the set of preference rules could be easily modified and expanded. The algorithm described has been implemented in Prolog as part of a larger natural language processing system. Extensions of this algorithm are in progress. Each of these sentences has two quantifier scopin one, wider scope over &amp;quot;a,&amp;quot; and while in the other, &amp;quot;a&amp;quot; has the wider scope. However, the readings that most people obtain for these sentences are quite different. In (1), the reading in which &amp;quot;a&amp;quot; has wider scope is highly in (3), the reading in which wider scope is highly preferred; in (2), the reading with wide-scope &amp;quot;every&amp;quot; is preferred, but widescope &amp;quot;a&amp;quot; is also acceptable. A plausible explanation for the difference between (1) and (2) is that, since the typical house is located on a street but not on a square, the default preference represented by (2) is overridden by a conversational of quantity—if &amp;quot;a narrow scope, a contribute too little information to justify its presence. A plausible explanation for the difference between (2) and (3) is based on the relationship among the components. The reading of (3) in which &amp;quot;a&amp;quot; is given wider scope is improbable because the domain of quantification then be the single patient in selected room—an infelicitous use of whereas there is no similar problem in (2) because there are normally multiple houses on a square. Similarly, in visited on every committee. visited on every street. One of the major sources of ambiguity in sentences results from the different scopes that can be assigned to the various quantified noun phrases in the sentence. Part of the problem in determining the preferred scopings of quantifiers is the number of factors involved. For example, consider these three sentences visited every house a John visited every house on a square. visited patient in a private the reading in which &amp;quot;a&amp;quot; has wider scope is reasonable for (4) but not for (5)—in a normal domain of discourse, it is conceivable that there could be a person who is on all of the committees, but it is highly improbable that the geometry of the streets is such that a single house could be located on all of them. In (1), (3), and (5), discourse criteria and domain information seem to be the primary factors in determining the preferred quantifier scopings, • whereas in (2) and (4), linguistic criteria seem to 33 be the determining factors. Our approach presumes that the determination of a sentence&apos;s preferred scoping can be divided into two phases, the first of which is the subject of the algorithm described here. In this initial phase, linguistic information is used to generate the possible quantifier scopings in order of preference. The relevant linguistic information consists of surface position, syntactic structure, and the relationship among the function words (determiners, modals, and negation). In the second phase (future work), domain and discourse information is applied successively to these scopings, modifying the scores produced by the first phase. We expect that the modifications will be only penalties, thus making it possible to identify the best choice when it is encountered (cutting off the processing of remaining scopings generated by the first phase). The primary study of quantifier scoping preferences was done by VanLehn (1978). The experimental data reported therein was of limited usefulness in developing the algorithm described here— and evaluated under assumptions arising from a different linguistic theory. We shall first present the rules that governed the structure of our design, then outline the algorithm. This scoping algorithm has been implemented as a component of a larger system that is under continuing development. In this system, called the Language Engine 1987), the semantic interpretation phase produces unscoped logical forms in which quantifier expressions are represented by quantifier terms (qterms). example, the sentence saw a student&amp;quot; unscoped logical form&apos; see(john&apos;,qterm(a ,X,student&apos;(X))) Since the only permissible scope for this quantifier is the whole sentence, the qterm is raised to produce the scoped logical form quant(3,X,student&apos;(X), see&apos;(john&apos;,X)) The qterm expression can best be thought of as a quant expression before its scope has been established. In the above qterm and quant expressions, student&apos;(X) is the restriction of the quantified variable X; that is, it specifies a set of the possible values of X over which the quantifier ranges. &apos;The logical form&apos;s syntax in the implementation is actually [seeljohnl,qterm(al,X,[studentl,X1)], but the more conventional notation will be used for perspicuity. In the above quant expression, see&apos;(john&apos;,X) is referred to as either the body or the scope of the quantifier. This treatment of the logical form of quantifiers follows that employed in many previous systems (e.g., LUNAR (Woods, 1977), Moore (1981), Barwise and Cooper (1981), and Hobbs and Shieber (1987)). RULES AND PREFERENCES Many of the following rules have appeared in various forms in multiple places in the literature, and most natural language processing systems include some mechanism for selecting a preferred quantifier scoping. However, the published descriptions of many of those systems&apos; capabilities tend to be cursory, with the scoping rules utilized in the LUNAR system still among the best described in the NLP literature. Because of space limitations, it is not possible to cite much of this discussion, nor to compare this system to others. 1 A that not in the restricof B that occurs within the of outscope any of the quantifiers restriction of 2 quantifier is past an operator, quantifier occurs within its mstriclion must also be raised past that operator. These rules, presented by Hobbs and Shieber (1987), can best be explained with examples. bishop visits every, chapel by a (6) has an unscoped logical form of visit&apos;(qterm(a B, bishop &apos;( B)), qterm(every&apos;,C,and(chaper(C), by&apos;(C,qterm(a&apos;,R,river&apos;(R)))))) The following is one of the possible permutations of the quantifiers, but is not a valid scopbecause the restriction of (&amp;quot;chapel a river&amp;quot;) has been fragmented: *q u a nt(V, C, ch a per ( C), quant(3,B,bishop&apos;(B), quant(3,R,and(river&apos;(R),by&apos;(C,R)), visit&apos;(B,C)))) Similarly, for the sentence did not visit a chapel by a (7) the quantifier permutation 34 *quant(3,C,chaper(C), not(quant(3,R,and(river&apos;(R),by&apos;(C,R)), visit&apos;(john&apos;,C)))) is not a possible scoping of the unscoped logical form not(visit&apos;aohn&apos;,qterm(a&apos;,C,and(chaper(C), 3 of quantifiers, which quantifier receives wide-scope preference can be determined by a pairwise comparison of the determiners. This comparison is based upon a combination of factors that include their relative strengths and surface positions, and whether or not either has been raised. In many systems, determiners are assigned numerical strengths and these values are compared to determine what scope should be assigned to each quantifier. Such a ranking is implicit in our preference rules and can be viewed as a first approximation of the relationships represented by our rules. Our algorithm permits a set of properties to be associated with determiners and for these to be used in ascertaining which determiner has widescope preference. The properties currently employed are surface position (the integer index of the determiner) and a Boolean value indicating when a quantifier has already been raised. 3.1 is preference for &amp;quot;each&amp;quot; to outscope other determiners. the strongest determiner is a common feature of most quantifier-scoping treatments. However, the evidence for the relative strengths of the remaining quantifiers is much less current ranking of them is an hoc blending of those in TEAM (Grosz et al., 1987) and VanLehn (1978). 3.2 is a strong preference for WH-terms to outscope all determiners except &amp;quot;each,&amp;quot; which outscopes WH-terms. In the unscoped logical forms currently pro- WH-words &amp;quot;who,&amp;quot; &amp;quot;what&amp;quot;) phrases are represented as qterms. Our scopingrules assign wide scope to in exams did each student pass? There is a reported dialect in which sentences of the above form are judged to be malformed, but that dialect was not found among our informants. The design of our algorithm makes it easy to replace the current preferences with these. definite determiner currently treated as a very strong quantifier, but this approach is not entirely satisfactory. Consider Every student passed the exam. (9) student in every ince celebrated. The student in each race celebrated. (11) student in the race celebrated. student in the race celebrated. In (9)–(12), the preferred scopings are as predicted by the rules. However in (13), the preferred readselected is the one with wide-scope Although both scopings of this sentence are logically equivalent (as are those for (9) and (12)), wideto be the preferred reading. Our algorithm does not distinguish between specific and nonspecific use of indefinite articles. It is debatable whether this belongs in quantifier scoping or in another part of the system. 3.3 logically weaker interpretation is preferred. This preference is strong when it maintains surface order, weak when it inverts sur- The quantifier order V3 is weaker than 3V, accounting for the preferences in man loves woman. (14) man loves woman. (15) In both sentences, the reading with wide-scope the preferred one; the reading with wide-scope &amp;quot;a&amp;quot; is possible for (14), but is very strained for (15). 4 a quantifier out of certain syntactic constituents changes the strength of its determiner. VanLehn presents an &amp;quot;embedding hierarchy&amp;quot; of the probability of a quantifier in the modifier of NP raised to have wider scope than the in the 2VanLehn proposes a more general form of this preference—that, when comparing two quantifiers within same general group, the &amp;quot;more numerous&amp;quot; one will a preference for wider scope. For example, &amp;quot;many&amp;quot; would take wider scope over &amp;quot;few.&amp;quot; However, for everything ex- &amp;quot;a,&amp;quot; such preferences appear to be very slight. 35 PP &gt; Reduced Relative Clause &gt; Relative Clause A method frequently proposed to account for this distinction is to use, as a measure of the cost of raising, a count of the number of nodes in the syntactic structure over which the quantifier is raised. However, such accounts are acknowledged to have various deficiencies and to be overly sensitive to the syntactic representation used. We have chosen to permit rules to associate a cost for raising a quantifier with certain types of nodes (other nodes can be viewed as having zero costs). This capability of the system is currently invoked only on an all-or-nothing basis. 4.1 A cannot be raised across more than one major clause boundary. A common rule in the quantifier-scoping literature is &amp;quot;quantification is generally clause bound.&amp;quot; While it is possible to generate sentences with acceptable readings when a quantifier has wider scope than the clause in which it occurs, we have been unable to find any examples showing that it can be raised out of two clauses. 4.2 quantifier cannot be raised out clause. This is a common restriction in many quantifierscoping algorithms. In our system, this is not a special rule, but one of the preferences. Consequently, this could easily be modified from never being permitted to being &amp;quot;highly unpreferred.&amp;quot; 5 unscoped logical form, quantifiers can occur within the scope of an opaque operator. or not to raise such quantifier operator is determined by pairtvise comparbetween the operator and the determiner well as by their position. 5.1 is a strong preference for &amp;quot;some&amp;quot; to outscope negation. 5.2 is for negation to outscope &amp;quot;every.&amp;quot; This preference is strong when it maintains surface order, weak when it doesn&apos;t. scopings of &amp;quot;every&apos; under produce equivalent readings is equivalent to -Ai). The preferred scopings for the two sentences did not see someone. did not see everyone. (17) have equivalent logical forms u a nt(3, P, person &apos;( P), not(see &apos;(joh not(quant(V,P,person&apos;(P),see&apos;(john&apos;,P))) Similarly, the preferred scopings of sentences did not see John. did not see John. (19) have equivalent logical forms quanta P, person 1 P), not(see &apos;( P, john&apos;))) not(q uant(V,P,person &apos; ( P),see&apos;( P. john &apos;))) The reading of (16), which would assign narscope to produced by substituting for did not see (20) This has the following logical form (no other scopnot(quant(3,P,person&apos;(P),see&apos;(john&apos;,P))) , which is logically equivalent to q u a nt(V, P, person &apos;( P),not(see&apos;( joh n &apos; ,P))) , which corresponds to the strongly &amp;quot;unpreferred&amp;quot; readings of (16) and (17). Similarly, the sentence one saw John. which has a scoped logical form of q u a nt(V, P, person &apos; ( P),not(see&apos;( P, john &apos;))) corresponds to the &amp;quot;unpreferred&amp;quot; scoping for (18) and (19). of LIJNAR&apos;s scoping rules in antecedent of quantifiers &amp;quot;any&amp;quot; should be assigned wide scope, and that &amp;quot;a&amp;quot; and &amp;quot;every&amp;quot; should be given narrow scope. If such antecedents were treated as a negative environment (or equivalent thereto), the foregoing preferences could produce this effect. does not currently provide a treatment of &amp;quot;any.&amp;quot; However, within the quantifier-scoping component, &amp;quot;any&amp;quot; is treated as being potentially ambiguous between the usual universal quantifier, freechoice &amp;quot;any,&amp;quot; and a second form, polarity-sensitive &amp;quot;any,&amp;quot; which occurs in conjunction with negative-polarity items. Polarity-sensitive &amp;quot;any,&amp;quot; is treated as a narrow-scope existential quantifier (Ladusaw, 1980). 36 5.3 is a strong preference for have wider scope than modals. There is a strong preference for all other determiners that occur within the scope of a modal to have narrower scope than that modal. some student take every test? some student take every test? student took every test. student takes every test. student is taking every test. For sentences (23), (25), and (26), there are two acceptable quantifier scopings. However, for (22) (24), the scoping in which assigned narrower scope seems to be strongly preferred. We ascribe this to the presence in the logical form of a modal operator corresponding to the past tense. This effect is accentuated in (27), which exan ambiguity resulting from whether scoped inside or outside the modal, corresponding to (28) and (29), respectively: teacher took every course. Last summer, some teacher took every course(28) some teacher took every course.(29) scoping in which is possible, although unpreferred, for the reading (28); but it is not a possible scoping for (29) in any dialect that we have encountered. 6 polarity-sensitive &amp;quot;any&amp;quot; occurs within clause in which its trigger does not occur, it must be raised out of that clause. Dicto/De Re mechanism described here provide account the de dicto/de distinction. Another ambiguity associated with quantifier terms is whether or not the referent is required exist. In 1973), the sentence seeks a unicorn. assigned a dicto (which does not require that any unicorns exist), a reading (which requires the existence of some unicorn) quant(3,X,unicorn&apos;(X),seek&apos;Cjohn&apos;,&amp;quot;A(P,T(X)))) distinction is produced by syntactic rules. Cooper (1975, 1983) demonstrated that a mechanism using a store could produce both readings from a single logical form. Our mechanism obtains similar results. Starting from the unscoped logical form with the intension operator treated as being optionally opaque, both readings are produced by the quantifier-scoping algorithm described here. Additional (unwarranted) scopings are not produced because these are the only two sites at which quantifiers can be pulled from the store. is a strong preference for a noun phrase in a prepositional phrase complement to outscope the head noun. This criterion is used in many quantifier scoping mechanisms. It is a good heuristic, but it is not a reliable rule. In visited every house on a street. visited every house with a dog. the heuristic correctly predicts the preferred scopfor (31), but fails for This heuristic is not part of our scoping algorithm; we believe that its effects are part of the processing consigned by us to the second phase of quantifier scoping (future work). BASIC ALGORITHM The first level of our scoping algorithm generates the possible scopings, as described by Hobbs and Shieber (1987). However, we implemented this with a different algorithm, partly for reasons of efficiency and partly because it could be easier expanded to include additional capabilities. The performance of the Hobbs and Shieber algorithm deteriorates as the number of quantifiers in the sentence increases—our analysis is that it spends a significant amount of time repeatedly traversing the logical form and doing structure copying (their goal was to produce a provably correct algorithm, not a highly efficient one). Our algorithm traverses the unscoped logical form, collecting the (quantifier terms) into a as the scoping for each qterm is determined, it is pulled out of the store, producing a scoped logical form. was brought to my attention by Richard Crouch. 37 For a sentence with four quantifiers, our algorithm is typically an order of magnitude faster than that presented by Hobbs and Shieber. A simple example of the use of the store is proby the sentence saw a student,&amp;quot; has an unscoped logical form of see&apos;aohn&apos;,qterm(a&apos;,X,student&apos;(X))) After quantifier scoping has placed the qterm in the store, the logical form is see &apos;(joh n ,X) and the store is The scope for this quantifier is the whole sentence, so the qterm is pulled out of the store to produce the scoped logical form quant(3,X,student&apos;(X), see&apos;(john&apos;,X)) sentence students pass most exams&amp;quot; the unscoped logical form pass&apos;(qterm(few&apos;,X,student&apos;(X)), After the qterms have been extracted, the remaining logical form and the store are [[qterm(few&apos;,X,student&apos;(X))] , [qterm(most&apos;,Y,exam&apos;(Y)))]] A qterm can have other qterms in its restriction and our quantifier store is a structured collection (unlike the stores of Cooper and LUNAR). The structure of qterms in the store corresponds to their relative positions in the unscoped logical form. For example, the unscoped logical form for &amp;quot;every student in a college attends the lecture&amp;quot; is attend&apos;(qterm(every&apos;,X,and(student&apos;(X), in&apos;(X,qterm(a&apos;,Y,college&apos;(Y))))), qterm(the&apos;,Z,lecture&apos;(Z))) When such qterms are placed in the store, this relationship is maintained by representing the collected qterms as trees (called qtrees), with the outer qterm as the root and those in its restriction as daughters: [[qterm(every&apos;,X,and(student&apos;(X),in&apos;(X,Y))), qterm(a&apos;,Y,college&apos;(Y))] , Eqterm(the&apos;,Z,lecture&apos;(Z))1] Consequently, the store is a forest of such qtrees, and the qterms occurring in the restriction of a qterm are themselves a forest of qtrees and are treated as if they were a store. As qterms are collected, they are inserted into the store in inverse order of preference—e.g., the qterm that has narrowest-scope preference appears at the front of the list representing the forest. In implementing this algorithm in Prolog, we found that it was considerably easier to generate the scopings by working from the narrowest to the scope, rather than versa. the various permutations of the quantifiers are generated, equivalent scopings are detected, and all but the most preferred one are then filtered out. In the following, both scopings of each sentence are logically equivalent: student takes every test. student takes each test. student takes a test. student takes student takes the test. student takes the test. student takes every test. In (33), (35), (37), and (39), the preferred order is the same as the surface order, while in (34), (36), and (38), the stronger quantifier occurs second in surface order, and the scoping that corresponds to surface order is discarded. Filtering of equivalent permutations is achieved simply by comparing the qtree currently being pulled from the store with the preceding one; if the quantifiers in their head qterms are logically equivalent, this quantifier scoping is discarded unless the qtree being pulled has wide-scope preference over its predecessor (in which case the other logically equivalent ordering will be discarded). Logically equivalent scopings can also be produced when a quantifier is raised out of the restriction of another. However, the quantifier permutations that produce equivalent scopings by raising are a subset of those produced by permuting siblings: student in every race celebrated. student a celebrated. student in a race celebrated. 38 student in the race celebrated. student in the race celebrated. student in every race celebrated. Note that the scopings for (40) and (45) are not logically equivalent. The scopings in the others are logically equivalent, but in (41) and (43), the preferred scoping is the one corresponding to constituent structure, whereas in (42) and (44), the scoping has the the to have wider scope over the head noun. When a qtree is pulled from the store, the algorithm tries to produce additional permutations by raising subsets of qterms (actually of qtrees) out of that qtree&apos;s restriction. When a qtree is raised, it is put back into the store—since qtrees are being assigned scope from narrowest to widest, this ensures that a raised qtree will receive wider scope than the qtree out of which it was raised. Because a raised qtree may have its strength reduced when it is placed back in the store (an option in our system), a set of logically equivalent could have filtered out by a naive implementation. The problem arises in the following manner. Before the qtree is raised, the algorithm determines that the unraised scoping is logically equivalent to a raised one and that the latter is preferred, so it discards the former. When the qtree is raised and its strength reduced, it becomes weaker than the qtree out of which it was raised. The algorithm detects that the raised scoping is logically equivalent to an unraised one, and determines—on the basis of the current strengths—that the unraised scoping is preferred, so it now discards the raised one. This problem is avoided by doing some additional bookkeeping. The current implementation of the above rules is very coarse-grained. The &amp;quot;score&amp;quot; indicating whether or not a quantifier should be assigned wide scope over another quantifier, logical form operator (e.g., a modal, negation), or syntactic constituent is one of four values: always (narrow is impossible), scope is impossible), pref (wide scope is preferred, but narrow scope is acceptable), and unpref (narrow scope is preferred). In the current implementation of the above preferences, a strong preference to take scope is treated as an instance of and a weak preference is treated as pref. For example, Preferences (3.1)–(3.3) are given by the following rules, in which Pref is the preference of a determiner Detl to take wider scope over another determiner Det2: Detl and Det2 are both – if Detl precedes Det2 in surface order, Pref = pref, – otherwise, Pref = unpref if Detl is Det2 is Pref = otherwise, if Detl is an interrogative Pref = otherwise, if the logical forms for Detl and Det2 are V and 3, respectively: – if Detl precedes Det2 in surface order, = otherwise, Pref = method described here results in quantifiers&apos; being assigned scopes that to other predicates not quantifiers) in the logical sentence visited every person on a has an logical form of visit&apos;aohn&apos;,qterm(every&apos;,P,and(person&apos;(P), on&apos;(P,qterm(a&apos;,C,committee&apos;(C)))))) and its preferred scoping is quant(V,P,quant(3,C,committee(C), and(person&apos;(P),on&apos;(P,C))), visit&apos;(john&apos;,P)) that is independent of C; thus it can be outside the scope of the quantifier for C quant(V,P,and(person&apos;(P), quant(3,C,committee&apos;(C),on&apos;(P,C))), visit&apos;(john&apos;,P)) Such transformations can have a significant impact on the performance of the system, substantially reducing the processing time of queries for even a modest database. Rather than pass additional information so that quantifiers could be pulled at the correct point in the traversal of the logical form, we chose to let the scoping algorithm &amp;quot;overshoot&amp;quot; its mark and then lower the quantifiers to the correct position. This was considerably easier to implement, and it does not seem to have any performance penalty in our system. CONCLUSION For lack of a reasonable corpus of human quantifier scoping preferences, the testing of this system has been limited to checking conformance to 39 stated The semantic component of the not produce logical forms with mass or collective readings, but that capability is currently being developed. The foregoing description of qterms is a slight simplification; an extended form is now being used to support generalized quantifiers in the new semantic rules. Examples offered by VanLehn (1978) indicate that dative movement affects quantifier scoping, but the cause may actually be domain or discourse information. Our examples show that passivization affects quantifier scoping, but we have not yet found a means of determining whether the effect due solely to the cost of raising out of the The algorithm does not handle &amp;quot;donkey sentences,&amp;quot; nor is it intended to. A scheme for handling such sentences is being explored as part of continuing development of the Pereira, personal communication). This would be a separate mechanism, rather than an extension of quantifier scoping. ACKNOWLEDGMENTS The research on which this paper is based was supported by the Natural Language Processing Club (NATTIE) of the Alvey Directorate program in Intelligent Knowledge-Based Systems (Project No. ALV/P1U/IKBS/105). Most of it was performed while I was a member of SRI&apos;s Cambridge Computer Science Research Centre. This work benefited from extensive discussion with and suggestions from Robert C. Moore and Hiyan Alshawi. REFERENCES Alshawi, Hiyan; Moore, Robert C.; Moran, Douglas B.; and Pulman, Steven G. 1987. Research Programme in Natural-Language Processing, Annual Report to the Natural Language Processing Club (NATTIE) of the Alvey Directorate Program in Intelligent</abstract>
<affiliation confidence="0.599361">Knowledge-Based Systems, Cambridge Computer Science Research Centre, SRI Interna-</affiliation>
<address confidence="0.736593">tional, Cambridge, England. Barwise, Jon and Cooper, Robin 1981. General-</address>
<abstract confidence="0.79047375">Quantifiers and Natural Language. Linand Philosophy 159-219. range of quantified noun phrases covered in the algorithm is larger than what is currently produced by syntactic and semantic components of the system. Such extensions have been tested by starting from the anticipated logical form. Robin 1975. Semantic Theand Transformational Syntax. dissertation, Department of Linguistics, University of Massachusetts at Amherst, Massachusetts.</abstract>
<note confidence="0.930190846153846">Robin 1983. Quantification and Reidel, Dordrecht, Holland. Grosz, Barbara J.; Appelt, Douglas E.; Martin, Paul A.; and Pereira, Fernando C.N. 1987. TEAM: An Experiment in the Design of Transportable Natural-Language In- Intelligence 173- 243. Hobbs, Jerry R. and Shieber, Stuart M. 1987. An Algorithm for Generating Quantifier Scop- Computational 47- 63. William 1980. Sensitivity as</note>
<author confidence="0.858777">disserta-</author>
<affiliation confidence="0.844885">tion, Department of Linguistics, University of Texas at Austin; published by Garland Press,</affiliation>
<address confidence="0.934941">New York, New York.</address>
<author confidence="0.655373">The Proper Treat-</author>
<affiliation confidence="0.883776">ment of Quantification in Ordinary English.</affiliation>
<note confidence="0.950145590909091">In: Hintikka, J.; Moravcsik, J.; and Sup- P. (eds.) 1973. to Natu- Language, Reidel, Dordrecht, Holland: 221-242. Reprinted in: Montague, Richard Philosophy: Selected Papers of Montague, and with an introduction by Richmond Thomason, Yale University Press, New Haven, Connecticut: 247- 270. Moore, Robert C. 1981. Problems in Logical In of the 19th Annual Meeting of the Association for Computational Linguis- VanLehn, Kurt A. 1978. Determining the Scope of English Quantifiers. Report AI-TR-483, Artificial Intelligence Laboratory, Massachusetts Institute of Technology, Cambridge, Massachusetts. Woods, William A. 1977. Semantics and Quantification in Natural Language Question Answer- In: in Computers, Volume 17, Academic Press, New York, New York: 1-87. 40</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Hiyan Alshawi</author>
<author>Robert C Moore</author>
<author>Douglas B Moran</author>
<author>Steven G Pulman</author>
</authors>
<date>1987</date>
<booktitle>Research Programme in Natural-Language Processing, Annual Report to the Natural Language Processing Club (NATTIE) of the Alvey Directorate Program in Intelligent Knowledge-Based Systems,</booktitle>
<institution>Cambridge Computer Science Research Centre, SRI International,</institution>
<location>Cambridge, England.</location>
<contexts>
<context position="5037" citStr="Alshawi et al., 1987" startWordPosition="820" endWordPosition="823">ng scopings generated by the first phase). The primary study of quantifier scoping preferences was done by VanLehn (1978). The experimental data reported therein was of limited usefulness in developing the algorithm described here— it was gathered and evaluated under assumptions arising from a different linguistic theory. We shall first present the rules that governed the structure of our design, then outline the algorithm. This scoping algorithm has been implemented as a component of a larger system that is under continuing development. In this system, called the Core Language Engine or CLE (Alshawi et al., 1987), the semantic interpretation phase produces unscoped logical forms in which quantifier expressions are represented by quantifier terms (qterms). For example, the sentence &amp;quot;John saw a student&amp;quot; has the unscoped logical form&apos; see(john&apos;,qterm(a ,X,student&apos;(X))) Since the only permissible scope for this quantifier is the whole sentence, the qterm is raised to produce the scoped logical form quant(3,X,student&apos;(X), see&apos;(john&apos;,X)) The qterm expression can best be thought of as a quant expression before its scope has been established. In the above qterm and quant expressions, student&apos;(X) is the restri</context>
</contexts>
<marker>Alshawi, Moore, Moran, Pulman, 1987</marker>
<rawString>Alshawi, Hiyan; Moore, Robert C.; Moran, Douglas B.; and Pulman, Steven G. 1987. Research Programme in Natural-Language Processing, Annual Report to the Natural Language Processing Club (NATTIE) of the Alvey Directorate Program in Intelligent Knowledge-Based Systems, Cambridge Computer Science Research Centre, SRI International, Cambridge, England.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jon Barwise</author>
<author>Robin Cooper</author>
</authors>
<date>1981</date>
<journal>Generalized Quantifiers and Natural Language. Linguistics and Philosophy</journal>
<volume>4</volume>
<issue>2</issue>
<pages>159--219</pages>
<contexts>
<context position="6202" citStr="Barwise and Cooper (1981)" startWordPosition="999" endWordPosition="1002">above qterm and quant expressions, student&apos;(X) is the restriction of the quantified variable X; that is, it specifies a set of the possible values of X over which the quantifier ranges. &apos;The logical form&apos;s syntax in the implementation is actually [seeljohnl,qterm(al,X,[studentl,X1)], but the more conventional notation will be used for perspicuity. In the above quant expression, see&apos;(john&apos;,X) is referred to as either the body or the scope of the quantifier. This treatment of the logical form of quantifiers follows that employed in many previous systems (e.g., LUNAR (Woods, 1977), Moore (1981), Barwise and Cooper (1981), and Hobbs and Shieber (1987)). RULES AND PREFERENCES Many of the following rules have appeared in various forms in multiple places in the literature, and most natural language processing systems include some mechanism for selecting a preferred quantifier scoping. However, the published descriptions of many of those systems&apos; capabilities tend to be cursory, with the scoping rules utilized in the LUNAR system still among the best described in the NLP literature. Because of space limitations, it is not possible to cite much of this discussion, nor to compare this system to others. Rule 1 A quan</context>
</contexts>
<marker>Barwise, Cooper, 1981</marker>
<rawString>Barwise, Jon and Cooper, Robin 1981. Generalized Quantifiers and Natural Language. Linguistics and Philosophy 4(2): 159-219.</rawString>
</citation>
<citation valid="false">
<title>5The range of quantified noun phrases covered in the algorithm is larger than what is currently produced by the syntactic and semantic components of the CLE system. Such extensions have been tested by starting from the anticipated logical form.</title>
<marker></marker>
<rawString>5The range of quantified noun phrases covered in the algorithm is larger than what is currently produced by the syntactic and semantic components of the CLE system. Such extensions have been tested by starting from the anticipated logical form.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robin Cooper</author>
</authors>
<title>Montague&apos;s Semantic Theory and Transformational Syntax.</title>
<date>1975</date>
<institution>Department of Linguistics, University of Massachusetts at Amherst,</institution>
<location>Massachusetts.</location>
<note>Ph.D. dissertation,</note>
<contexts>
<context position="17524" citStr="Cooper (1975" startWordPosition="2830" endWordPosition="2831">e raised out of that clause. De Dicto/De Re The mechanism described here can provide an account for the de dicto/de re distinction. Another ambiguity associated with quantifier terms is whether or not the referent is required to exist. In PTQ (Montague, 1973), the sentence John seeks a unicorn. (30) is assigned a de dicto reading (which does not require that any unicorns exist), seekVjohn&apos;,-A(P,quant(3,X,unicorn&apos;(X),-P(X)))) and a de re reading (which requires the existence of some unicorn) quant(3,X,unicorn&apos;(X),seek&apos;Cjohn&apos;,&amp;quot;A(P,T(X)))) In PTQ, this distinction is produced by syntactic rules. Cooper (1975, 1983) demonstrated that a mechanism using a store could produce both readings from a single logical form. Our mechanism obtains similar results. Starting from the unscoped logical form seek&apos;cjohn&apos;,&amp;quot;A(P,-.P(qterm(a&apos;,X,unicorn.(X))))) with the intension operator treated as being optionally opaque, both readings are produced by the quantifier-scoping algorithm described here. Additional (unwarranted) scopings are not produced because these are the only two sites at which quantifiers can be pulled from the store. Nonrule There is a strong preference for a noun phrase in a prepositional phrase co</context>
</contexts>
<marker>Cooper, 1975</marker>
<rawString>Cooper, Robin 1975. Montague&apos;s Semantic Theory and Transformational Syntax. Ph.D. dissertation, Department of Linguistics, University of Massachusetts at Amherst, Massachusetts.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robin Cooper</author>
</authors>
<title>Quantification and Syntactic Theory,</title>
<date>1983</date>
<location>D. Reidel, Dordrecht, Holland.</location>
<marker>Cooper, 1983</marker>
<rawString>Cooper, Robin 1983. Quantification and Syntactic Theory, D. Reidel, Dordrecht, Holland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Barbara J Grosz</author>
<author>Douglas E Appelt</author>
<author>Paul A Martin</author>
<author>Fernando C N Pereira</author>
</authors>
<title>TEAM: An Experiment in the Design of Transportable Natural-Language Interfaces.</title>
<date>1987</date>
<journal>Artificial Intelligence</journal>
<volume>32</volume>
<issue>2</issue>
<pages>173--243</pages>
<contexts>
<context position="9252" citStr="Grosz et al., 1987" startWordPosition="1477" endWordPosition="1480">nd for these to be used in ascertaining which determiner has widescope preference. The properties currently employed are surface position (the integer index of the determiner) and a Boolean value indicating when a quantifier has already been raised. Preference 3.1 There is a strong preference for &amp;quot;each&amp;quot; to outscope other determiners. That &amp;quot;each&amp;quot; is the strongest determiner is a common feature of most quantifier-scoping treatments. However, the evidence for the relative strengths of the remaining quantifiers is much less clear—our current ranking of them is an ad hoc blending of those in TEAM (Grosz et al., 1987) and VanLehn (1978). Preference 3.2 There is a strong preference for WH-terms to outscope all determiners except &amp;quot;each,&amp;quot; which outscopes WH-terms. In the unscoped logical forms currently produced, WH-words (&amp;quot;which,&amp;quot; &amp;quot;who,&amp;quot; &amp;quot;what&amp;quot;) and phrases are represented as qterms. Our scopingpreference rules assign wide scope to &amp;quot;each&amp;quot; in Which exams did each student pass? (8) There is a reported dialect in which sentences of the above form are judged to be malformed, but that dialect was not found among our informants. The design of our algorithm makes it easy to replace the current preferences with thes</context>
</contexts>
<marker>Grosz, Appelt, Martin, Pereira, 1987</marker>
<rawString>Grosz, Barbara J.; Appelt, Douglas E.; Martin, Paul A.; and Pereira, Fernando C.N. 1987. TEAM: An Experiment in the Design of Transportable Natural-Language Interfaces. Artificial Intelligence 32(2): 173-243.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jerry R Hobbs</author>
<author>Stuart M Shieber</author>
</authors>
<title>An Algorithm for Generating Quantifier Scopings.</title>
<date>1987</date>
<journal>Computational Linguistics,</journal>
<volume>13</volume>
<issue>1</issue>
<pages>47--63</pages>
<contexts>
<context position="6232" citStr="Hobbs and Shieber (1987)" startWordPosition="1004" endWordPosition="1007">ns, student&apos;(X) is the restriction of the quantified variable X; that is, it specifies a set of the possible values of X over which the quantifier ranges. &apos;The logical form&apos;s syntax in the implementation is actually [seeljohnl,qterm(al,X,[studentl,X1)], but the more conventional notation will be used for perspicuity. In the above quant expression, see&apos;(john&apos;,X) is referred to as either the body or the scope of the quantifier. This treatment of the logical form of quantifiers follows that employed in many previous systems (e.g., LUNAR (Woods, 1977), Moore (1981), Barwise and Cooper (1981), and Hobbs and Shieber (1987)). RULES AND PREFERENCES Many of the following rules have appeared in various forms in multiple places in the literature, and most natural language processing systems include some mechanism for selecting a preferred quantifier scoping. However, the published descriptions of many of those systems&apos; capabilities tend to be cursory, with the scoping rules utilized in the LUNAR system still among the best described in the NLP literature. Because of space limitations, it is not possible to cite much of this discussion, nor to compare this system to others. Rule 1 A quantifier A that is not in the re</context>
<context position="18762" citStr="Hobbs and Shieber (1987)" startWordPosition="3025" endWordPosition="3028">tscope the head noun. This criterion is used in many quantifier scoping mechanisms. It is a good heuristic, but it is not a reliable rule. In John visited every house on a street. (31) John visited every house with a dog. (32) the heuristic correctly predicts the preferred scoping for (31), but fails for (32).4 This heuristic is not part of our scoping algorithm; we believe that its effects are part of the processing consigned by us to the second phase of quantifier scoping (future work). BASIC ALGORITHM The first level of our scoping algorithm generates the possible scopings, as described by Hobbs and Shieber (1987). However, we implemented this with a different algorithm, partly for reasons of efficiency and partly because it could be easier expanded to include additional capabilities. The performance of the Hobbs and Shieber algorithm deteriorates as the number of quantifiers in the sentence increases—our analysis is that it spends a significant amount of time repeatedly traversing the logical form and doing structure copying (their goal was to produce a provably correct algorithm, not a highly efficient one). Our algorithm traverses the unscoped logical form, collecting the qterms (quantifier terms) i</context>
</contexts>
<marker>Hobbs, Shieber, 1987</marker>
<rawString>Hobbs, Jerry R. and Shieber, Stuart M. 1987. An Algorithm for Generating Quantifier Scopings. Computational Linguistics, 13(1-2): 47-63.</rawString>
</citation>
<citation valid="true">
<authors>
<author>William Ladusaw</author>
</authors>
<title>Polarity Sensitivity as Inherent Scope Relations.</title>
<date>1980</date>
<tech>Ph.D. dissertation,</tech>
<publisher>Garland Press,</publisher>
<institution>Department of Linguistics, University of Texas</institution>
<location>New York, New York.</location>
<note>at Austin; published by</note>
<contexts>
<context position="15569" citStr="Ladusaw, 1980" startWordPosition="2514" endWordPosition="2515">ope, and that &amp;quot;a&amp;quot; and &amp;quot;every&amp;quot; should be given narrow scope. If such antecedents were treated as a negative environment (or equivalent thereto), the foregoing preferences could produce this effect. 3The CLE system does not currently provide a treatment of &amp;quot;any.&amp;quot; However, within the quantifier-scoping component, &amp;quot;any&amp;quot; is treated as being potentially ambiguous between the usual universal quantifier, freechoice &amp;quot;any,&amp;quot; and a second form, polarity-sensitive &amp;quot;any,&amp;quot; which occurs in conjunction with negative-polarity items. Polarity-sensitive &amp;quot;any,&amp;quot; is treated as a narrow-scope existential quantifier (Ladusaw, 1980). 36 Preference 5.3 There is a strong preference for free-choice &amp;quot;any&amp;quot; to have wider scope than modals. There is a strong preference for all other determiners that occur within the scope of a modal to have narrower scope than that modal. Did some student take every test? (22) Does some student take every test? (23) Some student took every test. (24) Some student takes every test. (25) Some student is taking every test. (26) For sentences (23), (25), and (26), there are two acceptable quantifier scopings. However, for (22) and (24), the scoping in which &amp;quot;every&amp;quot; is assigned narrower scope seems </context>
</contexts>
<marker>Ladusaw, 1980</marker>
<rawString>Ladusaw, William 1980. Polarity Sensitivity as Inherent Scope Relations. Ph.D. dissertation, Department of Linguistics, University of Texas at Austin; published by Garland Press, New York, New York.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Richard Montague</author>
</authors>
<title>The Proper Treatment of Quantification in Ordinary English.</title>
<date>1973</date>
<pages>221--242</pages>
<editor>In: Hintikka, J.; Moravcsik, J.; and Suppee, P. (eds.)</editor>
<publisher>Yale University Press,</publisher>
<location>Dordrecht, Holland:</location>
<contexts>
<context position="17171" citStr="Montague, 1973" startWordPosition="2783" endWordPosition="2784">very course(28) As a student, some teacher took every course.(29) The scoping in which &amp;quot;ever?&apos; outscopes &amp;quot;some&amp;quot; is possible, although unpreferred, for the reading (28); but it is not a possible scoping for (29) in any dialect that we have encountered. Rule 6 If polarity-sensitive &amp;quot;any&amp;quot; occurs within a clause in which its trigger does not occur, it must be raised out of that clause. De Dicto/De Re The mechanism described here can provide an account for the de dicto/de re distinction. Another ambiguity associated with quantifier terms is whether or not the referent is required to exist. In PTQ (Montague, 1973), the sentence John seeks a unicorn. (30) is assigned a de dicto reading (which does not require that any unicorns exist), seekVjohn&apos;,-A(P,quant(3,X,unicorn&apos;(X),-P(X)))) and a de re reading (which requires the existence of some unicorn) quant(3,X,unicorn&apos;(X),seek&apos;Cjohn&apos;,&amp;quot;A(P,T(X)))) In PTQ, this distinction is produced by syntactic rules. Cooper (1975, 1983) demonstrated that a mechanism using a store could produce both readings from a single logical form. Our mechanism obtains similar results. Starting from the unscoped logical form seek&apos;cjohn&apos;,&amp;quot;A(P,-.P(qterm(a&apos;,X,unicorn.(X))))) with the int</context>
</contexts>
<marker>Montague, 1973</marker>
<rawString>Montague, Richard 1973. The Proper Treatment of Quantification in Ordinary English. In: Hintikka, J.; Moravcsik, J.; and Suppee, P. (eds.) 1973. Approaches to Natural Language, D. Reidel, Dordrecht, Holland: 221-242. Reprinted in: Montague, Richard 1974. Formal Philosophy: Selected Papers of Richard Montague, edited and with an introduction by Richmond Thomason, Yale University Press, New Haven, Connecticut: 247-270.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert C Moore</author>
</authors>
<title>Problems in Logical Form.</title>
<date>1981</date>
<booktitle>In Proc. of the 19th Annual Meeting of the Association for Computational Linguistics:</booktitle>
<pages>117--124</pages>
<contexts>
<context position="6175" citStr="Moore (1981)" startWordPosition="997" endWordPosition="998">ished. In the above qterm and quant expressions, student&apos;(X) is the restriction of the quantified variable X; that is, it specifies a set of the possible values of X over which the quantifier ranges. &apos;The logical form&apos;s syntax in the implementation is actually [seeljohnl,qterm(al,X,[studentl,X1)], but the more conventional notation will be used for perspicuity. In the above quant expression, see&apos;(john&apos;,X) is referred to as either the body or the scope of the quantifier. This treatment of the logical form of quantifiers follows that employed in many previous systems (e.g., LUNAR (Woods, 1977), Moore (1981), Barwise and Cooper (1981), and Hobbs and Shieber (1987)). RULES AND PREFERENCES Many of the following rules have appeared in various forms in multiple places in the literature, and most natural language processing systems include some mechanism for selecting a preferred quantifier scoping. However, the published descriptions of many of those systems&apos; capabilities tend to be cursory, with the scoping rules utilized in the LUNAR system still among the best described in the NLP literature. Because of space limitations, it is not possible to cite much of this discussion, nor to compare this syst</context>
</contexts>
<marker>Moore, 1981</marker>
<rawString>Moore, Robert C. 1981. Problems in Logical Form. In Proc. of the 19th Annual Meeting of the Association for Computational Linguistics: 117-124.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kurt A VanLehn</author>
</authors>
<title>Determining the Scope of English Quantifiers.</title>
<date>1978</date>
<tech>Report AI-TR-483,</tech>
<institution>Artificial Intelligence Laboratory, Massachusetts Institute of Technology,</institution>
<location>Cambridge, Massachusetts.</location>
<contexts>
<context position="4537" citStr="VanLehn (1978)" startWordPosition="742" endWordPosition="743">vant linguistic information consists of surface position, syntactic structure, and the relationship among the function words (determiners, modals, and negation). In the second phase (future work), domain and discourse information is applied successively to these scopings, modifying the scores produced by the first phase. We expect that the modifications will be only penalties, thus making it possible to identify the best choice when it is encountered (cutting off the processing of remaining scopings generated by the first phase). The primary study of quantifier scoping preferences was done by VanLehn (1978). The experimental data reported therein was of limited usefulness in developing the algorithm described here— it was gathered and evaluated under assumptions arising from a different linguistic theory. We shall first present the rules that governed the structure of our design, then outline the algorithm. This scoping algorithm has been implemented as a component of a larger system that is under continuing development. In this system, called the Core Language Engine or CLE (Alshawi et al., 1987), the semantic interpretation phase produces unscoped logical forms in which quantifier expressions </context>
<context position="9271" citStr="VanLehn (1978)" startWordPosition="1482" endWordPosition="1483">in ascertaining which determiner has widescope preference. The properties currently employed are surface position (the integer index of the determiner) and a Boolean value indicating when a quantifier has already been raised. Preference 3.1 There is a strong preference for &amp;quot;each&amp;quot; to outscope other determiners. That &amp;quot;each&amp;quot; is the strongest determiner is a common feature of most quantifier-scoping treatments. However, the evidence for the relative strengths of the remaining quantifiers is much less clear—our current ranking of them is an ad hoc blending of those in TEAM (Grosz et al., 1987) and VanLehn (1978). Preference 3.2 There is a strong preference for WH-terms to outscope all determiners except &amp;quot;each,&amp;quot; which outscopes WH-terms. In the unscoped logical forms currently produced, WH-words (&amp;quot;which,&amp;quot; &amp;quot;who,&amp;quot; &amp;quot;what&amp;quot;) and phrases are represented as qterms. Our scopingpreference rules assign wide scope to &amp;quot;each&amp;quot; in Which exams did each student pass? (8) There is a reported dialect in which sentences of the above form are judged to be malformed, but that dialect was not found among our informants. The design of our algorithm makes it easy to replace the current preferences with these. The definite det</context>
<context position="27835" citStr="VanLehn (1978)" startWordPosition="4470" endWordPosition="4471"> implement, and it does not seem to have any performance penalty in our system. CONCLUSION For lack of a reasonable corpus of human quantifier scoping preferences, the testing of this system has been limited to checking conformance to 39 the stated rules.5 The semantic component of the CLE does not produce logical forms with mass or count NPs or collective readings, but that capability is currently being developed. The foregoing description of qterms is a slight simplification; an extended form is now being used to support generalized quantifiers in the new semantic rules. Examples offered by VanLehn (1978) indicate that dative movement affects quantifier scoping, but the cause may actually be domain or discourse information. Our examples show that passivization affects quantifier scoping, but we have not yet found a means of determining whether the effect is due solely to the cost of raising out of the PP. The algorithm does not handle &amp;quot;donkey sentences,&amp;quot; nor is it intended to. A scheme for handling such sentences is being explored as part of the continuing development of the CLE (Fernando Pereira, personal communication). This would be a separate mechanism, rather than an extension of quantifi</context>
</contexts>
<marker>VanLehn, 1978</marker>
<rawString>VanLehn, Kurt A. 1978. Determining the Scope of English Quantifiers. Report AI-TR-483, Artificial Intelligence Laboratory, Massachusetts Institute of Technology, Cambridge, Massachusetts.</rawString>
</citation>
<citation valid="true">
<authors>
<author>William A Woods</author>
</authors>
<title>Semantics and Quantification in Natural Language Question Answering. In:</title>
<date>1977</date>
<booktitle>Advances in Computers, Volume 17,</booktitle>
<pages>1--87</pages>
<publisher>Academic Press,</publisher>
<location>New York, New York:</location>
<contexts>
<context position="6161" citStr="Woods, 1977" startWordPosition="995" endWordPosition="996">as been established. In the above qterm and quant expressions, student&apos;(X) is the restriction of the quantified variable X; that is, it specifies a set of the possible values of X over which the quantifier ranges. &apos;The logical form&apos;s syntax in the implementation is actually [seeljohnl,qterm(al,X,[studentl,X1)], but the more conventional notation will be used for perspicuity. In the above quant expression, see&apos;(john&apos;,X) is referred to as either the body or the scope of the quantifier. This treatment of the logical form of quantifiers follows that employed in many previous systems (e.g., LUNAR (Woods, 1977), Moore (1981), Barwise and Cooper (1981), and Hobbs and Shieber (1987)). RULES AND PREFERENCES Many of the following rules have appeared in various forms in multiple places in the literature, and most natural language processing systems include some mechanism for selecting a preferred quantifier scoping. However, the published descriptions of many of those systems&apos; capabilities tend to be cursory, with the scoping rules utilized in the LUNAR system still among the best described in the NLP literature. Because of space limitations, it is not possible to cite much of this discussion, nor to com</context>
</contexts>
<marker>Woods, 1977</marker>
<rawString>Woods, William A. 1977. Semantics and Quantification in Natural Language Question Answering. In: Advances in Computers, Volume 17, Academic Press, New York, New York: 1-87.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>