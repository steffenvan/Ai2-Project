<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000004">
<title confidence="0.89578">
Disambiguating quantifier scope in DTS
</title>
<author confidence="0.938825">
Livio Robaldo &amp; Jurij Di Carlo
</author>
<affiliation confidence="0.652307">
Dipartimento di Informatica, Universit´a di Torino
</affiliation>
<email confidence="0.917325">
robaldo@di.unito.it, dicarlo.jurij@educ.di.unito.it
</email>
<sectionHeader confidence="0.522763" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999249444444444">
This paper proposes an extension of Dependency Tree Semantics (DTS),
an underspecified logic originally proposed in [20], that uniformily im-
plements constraints on Nested Quantification, Island Constraints and
logical Redundancy. Unfortunately, this extension makes the complex-
ity exponential in the number of NPs, in the worst cases. Nevertheless,
we conducted an experiment on the Turin University Treebank [6], a
Treebank of italian sentences annotated in a syntactic dependency for-
mat, whose results seem to indicate that these cases are very rare in
real sentences.
</bodyText>
<sectionHeader confidence="0.995497" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999877">
Quantifier scope ambiguities may engender several interpretations of an NL
sentence. For instance, (1.a) has two readings that, in standard Generalized
Quantifier (GQ) approach, can be represented as in (1.b-c). (1.b) iff a
particular sound was heard by every man., while (1.c) is true iff each man
has heard a (potentially different) sound.
</bodyText>
<listItem confidence="0.613497">
(1) a. Every man heard a mysterious sound.
b. ly(myst5ound&apos;(y), bx(man&apos;(x), heard&apos;(x, y)))
c. bx(man&apos;(x), ly(myst5ound&apos;(y), heard&apos;(x, y)))
</listItem>
<bodyText confidence="0.999826">
In order to deal with quantifier scope ambiguities, two main problems have
to be taken into account. First, the number of available readings tends to
degenerate into a combinatorial explosion when the number of quantifiers
increases. Second, in many real cases the knowledge needed to disambiguate
is not fully available during the processing of the sentence. In such cases,
all readings must be somehow stored, and, afterwards, when new world
knowledge becomes available, sequentially checked in order to remove the
inconsistent ones.
</bodyText>
<page confidence="0.985985">
195
</page>
<bodyText confidence="0.959859666666667">
Proceedings of the 8th International Conference on Computational Semantics, pages 195–209,
Tilburg, January 2009. c�2009 International Conference on Computational Semantics
In order to provide a flexible solution to semantic ambiguities, Under-
specified formalisms have been recently proposed. In underspecified seman-
tics, semantic ambiguities are seen as instances of unspecified meaning that
can adopt a more restricted sense depending on the preferences grounded
in the syntactic structure, world-knowledge, topic/focus distinctions and so
forth. underspecified logics allow to encapsulate scope ambiguities in a sin-
gle structure. Surveys in underspecified semantics may be found in [8] and
[11].
The first underspecified logic that has been proposed is perhaps the algo-
rithm of Hobbs and Shieber [13], which has subsequently evolved into Quasi
Logical Form [1]. In this proposal, the underspecified representation is a par-
tial formula Φ that may contain underspecified terms, called complex terms,
in the form &lt;q, v, r&gt; where q is a GQ, v an individual variable and r, the re-
striction of q, another partial formula. In order to obtain the disambiguated
formulae, complex terms must be solved. This is done by “pulling out” and
“unstoring” the complex terms one by one. Depending on the order in which
they are solved, different readings are obtained. For instance, the underspec-
ified representation of (1.a) is shown in (2.a). By solving the complex term
&lt;b, x, man&apos;(x)&gt;, we get the partially solved formula in (2.b), from which,
by solving the other complex term &lt;1, y, myst5ound&apos;(x)&gt;, we get reading
(1.a). Conversely, by solving the two complex terms in the opposite order,
we get (1.c).
</bodyText>
<listItem confidence="0.996117">
(2) a. heard&apos;(&lt; b, x, man&apos;(x) &gt;, &lt; 1, y, myst5ound&apos;(x) &gt;)
b. bx(man&apos;(x), heard&apos;(x, &lt; 1, y, myst5ound&apos;(x) &gt;))
</listItem>
<bodyText confidence="0.999823333333333">
A more recent approach to underspecified semantics is grounded in dom-
inance constraints between some kind of scope-bearers and some kind of
scope-arguments. Underspecified Discourse Representation Theory [19], Hole
Semantics [5], the approach of [25], Constraint Language for Lambda Struc-
tures (CLLS) [12], and Minimal Recursion Semantics (MRS) [10], belong to
this approach. In MRS, the underspecified formula of (1) is
</bodyText>
<listItem confidence="0.3248765">
(3) (h0, {h1: bx(h11, h12), h2: 1y(h21, h22), h3: man&apos;(x), h4: myst5ound&apos;(y),
h5: heard&apos;(x, y)}, {h0=qh5, h11=qh3, h21=qh4})
</listItem>
<bodyText confidence="0.99842275">
This representation is a triple whose second element is a flat set of labelled
subformulae called EPs. Each label (h1, h2, etc.) is called an ‘handle’. The
EP associated with a quantifier contains a handle for its restriction and one
for its body. The third element of the triple is a set of constraints in the
</bodyText>
<page confidence="0.998404">
196
</page>
<bodyText confidence="0.999937967741935">
form hx=qhy, specifying that the EP handled by hy must occur in the scope
of hx. Two disambiguations are then possible in (3): fh0 = h1, h12 = h2,
h22 = h5}, which leads to (1.b), and fh0 = h2, h22 = h1, h12 = h5}, which
leads to (1.c).
A new approach to underspecification of quantifier scope ambiguities has
been recently proposed in [20], and implemented into a new formalism called
Dependency Tree Semantics (DTS). In DTS, disambiguation is performed
by explicitly showing the dependencies between involved sets, i.e. by achiev-
ing a sort of underspecified ‘Skolemization’. DTS is presented in detail in
section 3.
Before presenting DTS, however, we will discuss in section 2 three main
linguistic phenomena that reduce the level of ambiguity of NL sentences,
namely Nested Quantification, Island Constraints and logical Redundancy.
Those constraints have to be somehow carried out in an underspecified logic,
in order to avoid readings not available in NL. We will briefly discuss the
alternatives proposed in the aforementioned formalisms and in DTS.
Section 4 contains the core of the research presented here. It proposes
to add in DTS two new constructs that implement the three mentioned
constraints in terms of allowed/disallowed dependencies, in a uniform and
modular way. These constructs, called positive/negative arcs, make DTS ex-
pressively complete, i.e. able to underspecify any possible subset of available
readings. As argued by [11], although expressive completeness is a desider-
able property for underspecified logics, unfortunately it is in trade-off with
spatial/temporal complexity, which, in DTS, turns out to be exponential
in the number d of NPs. The last section, however, presents a small ex-
periment on the Turin University Treebank (TUT) [6], whose results seem
to indicate that, in real cases, the three examined constraints strongly con-
tribute to keep d, and hence the overall computational time, low. We will
then conclude by claiming that the exponential asymptotic behaviour of the
complexity function is a price worth paying for devising a disambiguation
process based on allowed/disallowed dependencies.
</bodyText>
<sectionHeader confidence="0.877359" genericHeader="method">
2 Constraints on underspecified formulae
</sectionHeader>
<bodyText confidence="0.929531">
As pointed out in the introduction, not all possible scopings correspond to
a possible reading in NL. In this section, we investigate the three main lin-
guistic phenomena involved in the unavailability of certain scope patterns,
namely Nested Quantification, Island Constraints, and logical Redundancy.
Nested Quantification: Several unreasonable readings arise from a con-
</bodyText>
<page confidence="0.997134">
197
</page>
<bodyText confidence="0.9994525">
trast between semantic/syntactic nesting of quantifiers. For instance, it is
awkward to take the sentence in (4.a), where the NP a company occurs in
the syntactic restriction of the quantifier every, as describing the situation
corresponding to the scoping bmostl, in which each representative saw a po-
tentially different set of most samples, and he belongs to a different company
for each sample he saw.
</bodyText>
<listItem confidence="0.762449">
(4) a. [Everyx representative of [ay company]] saw [mostz samples] [13].
</listItem>
<equation confidence="0.598206777777778">
b. see&apos;(&lt;b, x, rep_of&apos;(x, &lt;l, y, comp&apos;(y)&gt;)&gt;, &lt;Most, z, sample&apos;(z)&gt;)
c. (h0, fh1: bx(h11, h12), h2: ly(h21, h22), h3: Mostz(h31, h32),
h4:rep_of&apos;(x, y), h5: comp&apos;(y), h6: sample&apos;(z), h7: saw(x, z)},
fh0=qh7, h11=qh4, h21=qh5, h31=qh6})
d. ly(comp&apos;(y), Mostz(samp&apos;(z), bx(rep&apos;(x)nof&apos;(x, y), see&apos;(x, z)))
e. bx(ly(comp&apos;(y), rep&apos;(x)nof&apos;(x, y)), Mostz(samp&apos;(z), see&apos;(x, z)))
f. Mostz(samp&apos;(z), bx(ly(comp&apos;(y), rep&apos;(x)nof&apos;(x, y)), see&apos;(x, z)))
g. ly(comp&apos;(y), bx(rep&apos;(x)nof&apos;(x, y), Mostz(samp&apos;(z), see&apos;(x, z))))
h. Mostz(samp&apos;(z), ly(comp&apos;(y), bx(rep&apos;(x)nof&apos;(x, y), see&apos;(x, z)))
</equation>
<bodyText confidence="0.990133352941177">
In the Hobbs and Shieber algorithm, these readings are forbidden by se-
lecting, at each step, a complex term not included in the restriction of any
other complex term. With this meta-rule, the algorithm, starting from the
underspecified formula in (4.b), computes the five readings in (4.d-h). The
same readings are triggered by the dominance constraints in the MRS rep-
resentation (4.c).
Several authors, e.g. [18], claim that also (4.d) has to be forbidden, in that
if q1 occurs in the restriction of q2, no other quantifier can ‘intercalate’ be-
tween them in the scope order. In underspecified semantic, this view was
accepted by [25] and [15] among others. The former develops a logical the-
ory that identifies intercalating readings by deriving inconsistencies. The
latter extends [14], which proposes a syntax-semantics interface from LTAG
to MRS-like formulae, with a construct based on quantifier sets that pre-
vents intercalating readings.
Island Constraints: certain syntactic structures are scope-“islands”, i.e.
the scope-bearers occurring therein cannot outscope elements outside the
island. Island constraints have been introduced by [21]. There are basically
</bodyText>
<page confidence="0.993392">
198
</page>
<bodyText confidence="0.999954">
two kinds of islands: finite clauses and coordinated structures. An example
of the former is shown in (5.a), where ∀x cannot outscope ∃y in that a stu-
dent is outside the finite clause where every occurs. In contrast, the scope of
NPs can freely rise over non-finite clauses, as shown in (5.b), where ∀x∃y is
available. An example of coordinated structures acting as islands is shown
in (5.c). (5.c) yields two scopings only, ∀x∃y∃z and ∃y∃z∀x, corresponding,
respectively, to a reading where every student reads a own book and a own
paper, and a reading where there is a single a book and a single paper that
have been read by every student.
</bodyText>
<listItem confidence="0.948301">
(5) a. Ay student said you met everyx professor. [16]
b. Ay student wants you to meet everyx professor. [16]
c. Everyx student reads ay book and az paper. [26]
</listItem>
<bodyText confidence="0.9976742">
In underspecified semantic, a standard way to deal with Island constraints of
the first kind introduces special ‘blocking’ place holders, one for each tensed
clause. The scope of the quantifiers in the clause is required to be always
included in the scope of the place holder. In MRS, the place holder may be a
handle referring to the ‘top’ of the clause. [14] implements Island constraints
in an MRS-like framework. Similar alternatives have been proposed in [12]
and [16]. The former implements a mechanism very close to [14], while the
latter devises a feature-based framework where a feature MAXS blocks the
scope of the quantifiers occurring in finite clausesi.
Island constraints carried by coordinate structures have received less atten-
tion in Underspecification, the most recent exception being perhaps [26]. In
[26], Hole Semantics is extended to properly handle the meaning of sentences
as (5.c).
Logical Redundancy: redundancy may arise when existential and uni-
versal quantifiers occur in the sentence. Existential quantifiers range over a
singleton of individuals, and so they cannot induce variation of their narrow-
scope sets. Analogously, universal quantifiers range over a whole domain
of individuals, which do not vary on the entities in their wide-scope sets.
Therefore, in (6.a-b) the scopings ∃x∃y and ∀x∀y are respectively equivalent
to ∃y∃x and ∀y∀x. Therefore, the latter may be taken as redundant. Nev-
ertheless, there is an exception to the rule about universals. It concerns a
&apos;In [16], also prepositions as of in (4) are associated with a feature MAXS. This allows to
deal with islands and nested quantifiers in terms of the same construct. Redundancy and
Coordination are not considered, but the extension of the logic in that direction seems
obvious.
</bodyText>
<page confidence="0.994353">
199
</page>
<bodyText confidence="0.998002">
universal having a modifier (which includes another quantifier) in its restric-
tion. For example, in the case of (6.c), there are two possibilities, according
to the intention of referring to ‘all friends of all participants’ (bxby) or to
‘all friends of any participant’ (bybx).
</bodyText>
<listItem confidence="0.986986">
(6) a. Ax boy read ay book.
b. Everyx man read everyx book.
c. [Everyx friend of [everyy participant]] arrived.
</listItem>
<bodyText confidence="0.9992048">
According to [4], analogous considerations hold for any NP that denotes a
principal filter (see [2]): proper names, definites, but also some bare indefi-
nites. We agree with [4]; proper names, as well as singular definites, clearly
denote constant sets2, while definites seem to behave exactly like universals.
For example, it is easy to see that (7.b-c) yield the same scopings of (6.b-c)
</bodyText>
<listItem confidence="0.8298305">
(7) a. Thex men read everyy book.
b. [Thex friends of [everyy participant]] arrived.
</listItem>
<bodyText confidence="0.995044">
In underspecified semantics, logical redundancy has recently been investi-
gated by [9] and [17]. The former devises an algorithm that allows to prevent
the generation of redundant readings, while the method presented in the lat-
ter generates all readings, but allows to group them into equivalence classes.
</bodyText>
<sectionHeader confidence="0.979105" genericHeader="method">
3 Dependency Tree Semantics
</sectionHeader>
<bodyText confidence="0.999861583333333">
In [20], a new underspecified semantic formalism called Dependency Tree
Semantics (DTS) has been proposed. Well-formed structures in DTS are
based on a graph G that represents the predicate-argument relations. The
nodes of G are either predicates or individual variables called discourse ref-
erents. Predicates connect discourse referents via arcs labelled with the
argument-position. Each discourse referent is also associated, via a function
quant, with a GQ, and with a restriction, via a function restr from discourse
referents to subgraphs of G.
In order to make the dependencies among sets of entities explicit, another
kind of arcs is introduced, termed 5emDep arcs, and resemble Skolem de-
pendencies. A discourse referent is taken to depend on all discourse referents
it is connected to via a 5emDep arc. Moreover, G includes a special element
</bodyText>
<footnote confidence="0.9649215">
2Note that this seems to be true also for personal pronoun (you, she, etc.), singular
demonstratives (this, that, etc.), and singular possessives (his, her, etc.).
</footnote>
<page confidence="0.991862">
200
</page>
<bodyText confidence="0.99969575">
called Ctx. Ctx refers to the context, i.e. the domain wrt which the final
structure will be evaluated. All discourse referents are linked to Ctx via a
SemDep arc; however, the ones linked to Ctx only are assumed to denote
fixed sets of entities, i.e. to correspond to Skolem constants. The several
readings of a sentence differ in the SemDep arcs only. For instance, both
readings of (1.a) share the structures shown in fig.1.a3, but they have two
different sets of SemDep arcs: (1.b) is conveyed by those in fig.1.b; (1.c) by
those in fi g . 1 . c .
</bodyText>
<equation confidence="0.888369">
a) restr(x)restr(y) b)SemDep c)SemDep
quant (x) = b
quant (y) = �]
</equation>
<figureCaption confidence="0.997732">
Figure 1: (a) SDG for sentence (1.a). (b-c) The two disambiguations (1.a)
</figureCaption>
<bodyText confidence="0.999961583333333">
In order to achieve underspecified semantics, SemDep arcs have to be some-
how added incrementally. In [20], this is done by defining another kind of
arcs, termed SkDep arcs. This paper makes use of other two kinds of arc,
termed positive and negative arcs, and propose them as an alternative of
SkDep arcs.
Before proceeding, it is worth stressing the main linguistic advantage of
DTS, although this article is not devoted to it. DTS licenses particular
readings where two or more sets of entities are introduced at the same level
of scope. I refer to such interpretations with the term ‘Independent Set’
(IS) readings. Three basic kinds of IS readings need to be distinguished:
distributive, collective and cumulative IS readings (cf. [22]), respectively
shown in (8.a-c)
</bodyText>
<listItem confidence="0.9728755">
(8) a. Two examiners marked six scripts.
b. Three boys lift a piano.
</listItem>
<tableCaption confidence="0.721098833333333">
3DTS structures are usually displayed in a graphical notation where the subgraphs
corresponding to restr’s values are graphically shown separately. SemDep arcs are shown
as dotted arcs; in order to increase readability, transitive SemDep arcs are omitted. Nev-
ertheless, the reader must always keep in mind that they do occur, i.e. that SemDep
describes a transitive relation. Therefore, in fig.1.b, there is an arc y--&gt;Ctx, even if it is
not shown.
</tableCaption>
<figure confidence="0.998762928571429">
Ctx
X y
hear&apos;
1 2
1
1
man&apos;
mSound&apos;
X y
mSound&apos;
1 1
man&apos;
Ctx
X y
</figure>
<page confidence="0.952801">
201
</page>
<bodyText confidence="0.986464055555555">
c. Three monkeys ate all our bananas.
If we allow both NPs in (8.a) to receive wide scope and we interpret the
main verb distributively, we get a reading where there is a set of two exam-
iners and a set of six scripts and each of the two examiners marked each
of the six scripts. (8.b) is an archetypal example of the so-called collective
readings. The sentence may receive an interpretation where the three boys
lift a single piano with a joint effort. Finally, (8.c) has a cumulative in-
terpretation. The sentence says that the union/cumulation of the bananas
singularly eaten by each of the three monkeys includes the set of all our
bananas. Currently, DTS deals with distributive IS readings only, despite
their controversial existence in NL (see [23]), in that they require less formal
effort. The extension of DTS coverage to collective/cumulative IS readings,
which is taken as the object of future work, would require the introduction
of more complex devices (see [3]).
Since DTS’s coverage includes IS readings, the logic accepts more readings
than other standard approaches to NL semantics. Every partial order be-
tween quantifier corresponds to an available reading. Examples are shown
below in fig.2.
</bodyText>
<sectionHeader confidence="0.890938" genericHeader="evaluation">
4 Positive and negative arcs
</sectionHeader>
<bodyText confidence="0.9994175">
[20] defines some constraints to prevent undesiderable readings arising from
Nested Quantification and logical Redundancy (in contrast, Island Con-
straints are not considered). These constraints are defined in terms of ‘meta-
rules’, like in Hobbs and Shieber’s algorithm:
</bodyText>
<listItem confidence="0.783849">
(9) a. If either d1 or d2 (transitively) occurs in the restriction of a dis-
</listItem>
<bodyText confidence="0.9941982">
course referent d, and the other one does not, then the arc d1--&gt;d2
can be inserted only if the graph contains an arc d--&gt;d2.
b. If quant(d1)=∀ or quant(d2)=∃, the arc d1--&gt;d2 cannot be in-
serted. The only exception is when quant(d1)=∀ and d2 (transi-
tively) occur in the restriction of d1.
By applying (9) to the initial DTS representation of (4.a), we get the five
readings in fig.2, corresponding to (4.d-h).
This section illustrates an alternative way of managing incremental inser-
tion of semantic dependencies, where allowed/disallowed dependencies are
explicitly specified in the representation. This is done by inserting additional
</bodyText>
<page confidence="0.991229">
202
</page>
<figure confidence="0.999945823529412">
b)
C)
d)
e)
Ctx
x z
a)
Ctxz
x
Ctx
z
x
Ctxz
x
z
Ctx
x
</figure>
<figureCaption confidence="0.999798">
Figure 2: SemDep configurations corresponding to (4.d-h).
</figureCaption>
<bodyText confidence="0.998839777777778">
arcs termed positive/negative arcs. With these constructs, we can easily pre-
vent redundant readings by adding a negative arc d1--&gt;d2 for each pair of
discourse referents (d1, d2) such that quant(d1)=∀ or quant(d2)=∃ and the
exception mentioned in (9.b) does not apply; all other arcs are added as
positive arcs.
Nevertheless, how do we achieve (9.a)? Such constraints disallow a set N
of dependencies unless the representation includes a set E of other depen-
dencies. In order to mirror these concepts, we refine the framework in two
ways:
</bodyText>
<listItem confidence="0.650123666666667">
(10) a. We group positive/negative arcs into (positive/negative) sets, and
we impose that all arcs in a set have to be allowed/disallowed
together.
</listItem>
<bodyText confidence="0.999392533333333">
b. We allow each negative set N to be associated with a further set
of arcs E. Those are the arcs that constitute the exception to the
disallowed dependency. In these cases, we will write {N|E}.
In terms of positive and negative sets, the new DTS representation of (4.a)
turns out to be the one in fig.3. Positive and negative sets are separately
shown as members of two families P and N in order to avoid verbose
graphical representations. The positive set {A--&gt;Ctx} compactly refers to
{x--&gt;Ctx, y--&gt;Ctx, z--&gt;Ctx}. Inserting it amounts to connecting all dis-
course referent to Ctx4.
{y--&gt;x} and {z--&gt;x} are allowed and so asserted in P. N contains four
negative sets. {x--&gt;y} and {z--&gt;y} have been disallowed because no arc can
enter an existential quantifier, and {x--&gt;z} because no universal quantifier
can lead to a discourse referent outside its restriction. {y--&gt;z} is disallowed
unless the structure contains a link from x to z. This is handled by adding
the negative set with exception {y--&gt;z|x--&gt;z} in N5. The reader can verify
</bodyText>
<footnote confidence="0.96852925">
4We remind that only graphs where all discourse referents are linked to Ctx can be
model-theoretically interpreted.
5Negative sets cannot be included in other negative sets, e.g. we cannot add
fz--&gt;y|x--&gt;y} in N: fz--&gt;y} already occurs therein. However, negative sets can be
</footnote>
<page confidence="0.998769">
203
</page>
<bodyText confidence="0.691803">
that all possible combinations of the allowed arcs lead to the five readings
in fig.2.
</bodyText>
<figure confidence="0.7195115">
P=ffA Ctx}, f x}, f x}}
N=f f x y}, f y}, f z}, f z x z}}
</figure>
<figureCaption confidence="0.998422">
Figure 3: SemDep configurations corresponding to (4.d-h).
</figureCaption>
<bodyText confidence="0.927220818181818">
In terms of positive/negative arcs, it is rather easy to extend the coverage
of DTS to Island constraints. No discourse referent outside the island may
depend on a discourse referent inside it. A discourse referent inside the
island is, instead, free to depend on any other discourse referent. Hence, if
d1 occurs in an island and d2 does not, we assert {d1--&gt;d2} as positive set
and {d2--&gt;d1} as negative set. Coordinate NPs are further constrained; if
D ≡ {d11, ... d1g,,} is the set of discourse referents in a coordination, and
d1∈D depends on a d2/∈D, so must any other d∈D. This is handled by
inserting a single positive set {d11--&gt;d2, ..., d1g,,--&gt;d2}. In example (5.c),
then, P would be P ={{y--&gt;x, z--&gt;x}, {A--&gt;Ctx}}. It is easy to see that P
generates the two desired readings only.
5 Expressivity, complexity, and real cases
It is not really necessary to add every positive/negative set, i.e. to specify
every possible pattern of allowed/disallowed dependencies in the represen-
tation. For instance, disallowing a dependency is clearly equivalent to not
allowing it. In fig.3, it is easy to see that the negative sets {x--&gt;y}, {z--&gt;y},
and {x--&gt;z} are actually useless because those arcs cannot be generated by
the sets in P. Therefore, they can be removed from N. Although we defined
algorithms implementing such heuristics, lack of space forbids us to provide
further details.
exceptions of other negative sets: the occurrence of fx--&gt;z} in N does not prevent the
insertion of fy--&gt;z|x--&gt;z}.
</bodyText>
<figure confidence="0.997843181818182">
restr(y)
quant(x)=8
restr(x) restr(z)
quant(y)=3 quant(z)=Dlost
1
comp&apos;
1
2
rep-of&apos;
saw&apos;
rep-of&apos;
1
1 2
1
2
1
comp&apos;
sample&apos;
z
z
1
sample&apos;
</figure>
<page confidence="0.997485">
204
</page>
<bodyText confidence="0.981018918918919">
From the point of view of expressivity, positive/negative arcs make DTS
expressively complete, i.e. able to underspecify any subset of dependencies.
This should be a property of every underspecified logic, as argued by [11],
but, unfortunately, it turns out to be in trade-off with computational com-
plexity. In DTS, in order to represent a subset of readings that have nothing
in common, the only solution is listing6 all corresponding positive sets. For
instance, the readings of (5.c) have been “listed” in P =ffy--&gt;x, z--&gt;x},
fA--&gt;Ctx}}. Since the number of partial orders is exponential in the number
of discourse referents (cf. [7]), in the worst cases P has exponential cardi-
nality.
However, we believe that such cases are rare in reality. To provide evi-
dence for this claim, we analyzed the data in TUT. For each sentence we
estimated the number of positive/negative arcs needed to underspecify its
readings. (11) is one of the more complex sentences we found in TUT.
(11) Lax societ´a opera in numerosiy altri settori commerciali e indus-
triali, annoverando tra lez sue propriet´a unak catena di 20w su-
permercati, (alcuniv) centri turistici e unap miniera. (ALB-247)
Thex society operates in severaly other commercial and industrial
sectors, including among itsz properties ak chain of 20w supermar-
kets, (somev) tourism centers and ap mine.
(11) contains seven discourse referents (x, y, z, k, w, v, p), so it initially
yields 7*6=42 non-cycling positive arcs, and more than 6 billion partial
orders between discourse referents. However:
- x is a singular definite with no restriction and z a plural possessive:
both of them must enter Ctx only, and no discourse referent can depend
on x.
- k, v, p are existential quantifiers in a coordination: no discourse ref-
erent can depend on them, and any triple of positive sets fk--&gt;d},
fv--&gt;d}, and fp--&gt;d} is replaced by a the positive set fk--&gt;d, v--&gt;d,
p--&gt;d}7.
- w belongs to the restriction of k: whenever w depends on a discourse
referent d7�k (or viceversa) so must k.
By applying these constraints, we obtain the following sets:
6Actually, we must also forbid those positive sets to combine with each other. This
may be simply achieved by marking in some way every positive set we do not want to
combine.
7Note that v is hidden, since tourism centers is a bare plural.
</bodyText>
<page confidence="0.98125">
205
</page>
<equation confidence="0.63555675">
P {A Ctx}, {y 4 { k w, v w; p WE
{k y, v y, p y}, {k z, v z, p z }}
N�{{y w k w, v w, p w}, {w y k y, v y, p y},
{w z k z, v z, p z }}
</equation>
<bodyText confidence="0.9998749">
The only acceptable reading is the one having all discourse referents linked
to Ctx only. However, in order to identify it, we would need a semantic
knowledge base from which we can infer, for example, that several sectors
cannot depend on his properties, and so the arc y--&gt;z has to be removed
from P.
1715 sentences included in TUT have been analyzed as example (11)8. The
results are shown in Table 1. Sentences have been divided into four classes,
depending on the number D of discourse referents they contain. For each
class, the table shows the average of the number of positive/negative arcs
generated by applying the three constraints discussed above.
</bodyText>
<table confidence="0.859793666666667">
|D |0 &lt; |D |≤ 2 2 &lt; |D |≤ 5 5 &lt; |D |≤ 10 10 &lt; |D |≤ 20
|Sentences |462 643 516 94
|Arcs |1.10 1.85 5.16 12.91
</table>
<tableCaption confidence="0.99904">
Table 1: TUT - Number of positive/negative arcs per discourse referents
</tableCaption>
<bodyText confidence="0.996600333333334">
The number of arcs indicated in Table 1 are very low. The reason for this
is the frequent occurrence in the sentences of proper names and definites
with no restriction. According to the discussion above, such NPs must be
linked to Ctx only, but this is already handled by the positive arc A--&gt;Ctx.
In other words, proper names and definites with no restriction introduce
new discourse referents but do not introduce new arcs, thus decreasing the
average values.
More reliable results are reported in Table 2. The table shows the number
of arcs per discourse referents without considering such NPs. The reader
may see that in the worst cases the number of arcs can be still considered
low.
8We excluded sentences including verbal ellipsis in that, according to [12], they can
engender complex quantifier-scope ambiguities not currently handled in DTS. Anaphora
have been ignored, in that those requiring a referent resolution enter Ctx only, while donkey
sentences, as shown by [24], simply require copies of the referent, with equal dependencies.
</bodyText>
<page confidence="0.99513">
206
</page>
<table confidence="0.997626">
|D |0 &lt; |D |≤ 2 2 &lt; |D |≤ 5 5 &lt; |D |≤ 10 10 &lt; |D |≤ 20
|Sentences |985 574 153 3
|Arcs |1.38 3.39 10.62 36
</table>
<tableCaption confidence="0.973367">
Table 2: TUT - Number of positive/negative arcs per discourse referents,
without considering proper names and definitives with no restriction.
</tableCaption>
<sectionHeader confidence="0.995362" genericHeader="conclusions">
6 Conclusions
</sectionHeader>
<bodyText confidence="0.999967533333333">
In this paper, we presented an extension of DTS where allowed/disallowed
dependencies are explicitly specified by inserting new arcs called positive/negative
arcs. We believe that positive/negative arcs provide a scalable and modu-
lar solution for the management of constraints coming from heterogeneous
sources. For instance, we showed that positive/negative arcs needed to man-
age Nested Quantification, Island Constraints, and logical Redundancy may
be independently defined. Unfortunately, positive/negative arcs lead to a
computational complexity which is exponential in the worst cases. Never-
theless, we performed a rough experiment on the Turin University Treebank,
whose results indicate that those worst cases are very rare in real sentences.
It seems then that the computational complexity is not really a problem. In
a real system, in case the number of possible readings is too high, the sys-
tem may decide to inspect the context in order to detect allowed/disallowed
dependencies to be removed or added in the representation, thus reducing
the number of readings.
</bodyText>
<sectionHeader confidence="0.9983" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999976111111111">
[1] Alshawi, H. The Core Language Engine. Mit Press, Cambridge, UK,
1992.
[2] Barwise, J. &amp; Cooper, R. Generalized Quantifiers and Natural Language.
Linguistics and Philosophy, 4(2), 159–219, 1981.
[3] Beck, S. &amp; Sauerland, U. Cumulation is Needed: A Reply to Winter
(2000). Natural Language Semantics, 8(4), 349–371, 2000.
[4] Beghelli F., Ben-Shalom D., Szabolski, A. Variation, Distributivity, and
the Illusion of Branching In A. Szabolcsi (Eds), Ways of Scope Taking,
Kluwer:Dordrecht, 29-69, 2001.
</reference>
<page confidence="0.96827">
207
</page>
<reference confidence="0.9999821875">
[5] Bos, J. Predicate Logic Unplugged. Proceedings of the 10th Amsterdam
Colloquium. Amsterdam, The Netherlands, 133–142, 1996.
[6] Bosco, C. A grammatical relation system for treebank annotation. Ph.D.
thesis, Department of Computer Science, University of Turin, 2004.
[7] Brinkmann, G. and McKay, B.D. Posets on up to 16 Points. Order,
19(2), 147–179, 2002.
[8] Bunt, H. Semantic Underspecification: Which Technique For What Pur-
pose? . In R. Musken and H. Bunt (Eds.), Computing Meaning. Kluwer,
vol. 3, 2003.
[9] Chaves, R.P. Non-Redundant Scope Disambiguation in Underspecified
Semantics. Proc. of the 8th ESSLLI Student Session, 47-58, Vienna,
2003.
[10] Copestake, A, Flickinger, D. and Sag, I.A. Minimal Recursion Seman-
tics. An introduction. Research on Language and Computation, 3(2),
2005.
[11] Ebert, C. Formal Investigations of Underspecified Representations.
Ph.D thesis, Department of Computer Science, King’s College London,
2005.
[12] Egg, M. and Koller, A. and Niehren, J. The Constraint Language for
Lambda Structures. Journal of Logic, Language and Information, 10(4),
2001.
[13] Hobbs, J. R. and Shieber, S. An Algorithm for Generating Quantifier
Scoping. Computational Linguistics: 13:47–63, 1987.
[14] Joshi, A. K. and Kallmeyer, L. Factoring Predicate Argument and Scope
Semantics: Underspecified Semantics with LTAG. Research on Language
and Computation, 1:3–58, 2003.
[15] Joshi, A. K. and Kallmeyer, L. and Romero, M. Flexible Composition
in LTAG: Quantifier Scope and Inverse Linking. In R. Musken and H.
Bunt (Eds.), Computing Meaning. Kluwer, vol. 3, 2003.
[16] Kallmeyer, L. &amp; Romero, M. Scope and Situation Binding in LTAG
using Semantic Unification. Research on Language and Computation,
6(1), 2008.
</reference>
<page confidence="0.974104">
208
</page>
<reference confidence="0.999596782608696">
[17] Koller A., Thater S. Towards a redundancy elimination algorithm for
underspecified descriptions. Proc. of the 5th Int. Workshop on Inference
in Computational Semantics (ICoS-5) Buxton, England, 2006.
[18] Park, J. Quantifier Scope and Constituency. Proceedings of the 33rd
Annual Meeting of the ACL. pp.205-212, 1995.
[19] Reyle, U. Dealing with ambiguities by Underspecification: Construction,
Representation and Deduction. Journal of Semantics, 13, 123–179, 1993.
[20] Robaldo, L. Dependency Tree Semantics. Ph.D thesis, Department of
Computer Science, Turin University, Italy, 2007.
[21] Ross, J. R. Constraints on Variables in Syntax. Ph.D thesis, Mas-
sachusetts Institute of Technology, 1967.
[22] Scha, R. Distributive, Collective and Cumulative Quantification. In J.
Groenendijk, M. Stokhof (Eds.), Formal Methods in the Study of Lan-
guage, Part 2, pages 483–512. Mathematisch Centrum, Amsterdam, 1981.
[23] Schein, B. Plurals and Events. MIT Press, Cambridge, MA, USA, 1993.
[24] Steedman, M. The Grammar of Scope, forthcom-
ing. See Surface-Compositional Scope-Alternation With-
out Existential Quantifiers. Draft 5.2, Sept 2007.
ftp://ftp.cogsci.ed.ac.uk/pub/steedman/quantifiers/journal6.pdf.
[25] Willis, A. An Efficient Treatment of Quantification in Underspecified
Semantic Representations. Ph.D thesis, University of York, 2000.
[26] Willis, A. NP Coordination in Underspecified Scope Representations.
Proc. of the 7th Workshop on Computational Semantics, Tilburg, 2007.
</reference>
<page confidence="0.998959">
209
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.897341">
<title confidence="0.999522">Disambiguating quantifier scope in DTS</title>
<author confidence="0.988583">Livio Robaldo</author>
<author confidence="0.988583">Jurij Di</author>
<affiliation confidence="0.948227">Dipartimento di Informatica, Universit´a di Torino</affiliation>
<email confidence="0.973515">robaldo@di.unito.it,</email>
<abstract confidence="0.9976248">This paper proposes an extension of Dependency Tree Semantics (DTS), an underspecified logic originally proposed in [20], that uniformily implements constraints on Nested Quantification, Island Constraints and logical Redundancy. Unfortunately, this extension makes the complexity exponential in the number of NPs, in the worst cases. Nevertheless, we conducted an experiment on the Turin University Treebank [6], a Treebank of italian sentences annotated in a syntactic dependency format, whose results seem to indicate that these cases are very rare in real sentences.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>H Alshawi</author>
</authors>
<title>The Core Language Engine.</title>
<date>1992</date>
<publisher>Mit Press,</publisher>
<location>Cambridge, UK,</location>
<contexts>
<context position="2652" citStr="[1]" startWordPosition="381" endWordPosition="381">sms have been recently proposed. In underspecified semantics, semantic ambiguities are seen as instances of unspecified meaning that can adopt a more restricted sense depending on the preferences grounded in the syntactic structure, world-knowledge, topic/focus distinctions and so forth. underspecified logics allow to encapsulate scope ambiguities in a single structure. Surveys in underspecified semantics may be found in [8] and [11]. The first underspecified logic that has been proposed is perhaps the algorithm of Hobbs and Shieber [13], which has subsequently evolved into Quasi Logical Form [1]. In this proposal, the underspecified representation is a partial formula Φ that may contain underspecified terms, called complex terms, in the form &lt;q, v, r&gt; where q is a GQ, v an individual variable and r, the restriction of q, another partial formula. In order to obtain the disambiguated formulae, complex terms must be solved. This is done by “pulling out” and “unstoring” the complex terms one by one. Depending on the order in which they are solved, different readings are obtained. For instance, the underspecified representation of (1.a) is shown in (2.a). By solving the complex term &lt;b, x</context>
</contexts>
<marker>[1]</marker>
<rawString>Alshawi, H. The Core Language Engine. Mit Press, Cambridge, UK, 1992.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Barwise</author>
<author>R Cooper</author>
</authors>
<title>Generalized Quantifiers and Natural Language.</title>
<date>1981</date>
<journal>Linguistics and Philosophy,</journal>
<volume>4</volume>
<issue>2</issue>
<pages>159--219</pages>
<contexts>
<context position="12307" citStr="[2]" startWordPosition="1902" endWordPosition="1902">undancy and Coordination are not considered, but the extension of the logic in that direction seems obvious. 199 universal having a modifier (which includes another quantifier) in its restriction. For example, in the case of (6.c), there are two possibilities, according to the intention of referring to ‘all friends of all participants’ (bxby) or to ‘all friends of any participant’ (bybx). (6) a. Ax boy read ay book. b. Everyx man read everyx book. c. [Everyx friend of [everyy participant]] arrived. According to [4], analogous considerations hold for any NP that denotes a principal filter (see [2]): proper names, definites, but also some bare indefinites. We agree with [4]; proper names, as well as singular definites, clearly denote constant sets2, while definites seem to behave exactly like universals. For example, it is easy to see that (7.b-c) yield the same scopings of (6.b-c) (7) a. Thex men read everyy book. b. [Thex friends of [everyy participant]] arrived. In underspecified semantics, logical redundancy has recently been investigated by [9] and [17]. The former devises an algorithm that allows to prevent the generation of redundant readings, while the method presented in the la</context>
</contexts>
<marker>[2]</marker>
<rawString>Barwise, J. &amp; Cooper, R. Generalized Quantifiers and Natural Language. Linguistics and Philosophy, 4(2), 159–219, 1981.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Beck</author>
<author>U Sauerland</author>
</authors>
<title>Cumulation is Needed: A Reply to Winter</title>
<date>2000</date>
<journal>Natural Language Semantics,</journal>
<volume>8</volume>
<issue>4</issue>
<pages>349--371</pages>
<contexts>
<context position="17057" citStr="[3]" startWordPosition="2693" endWordPosition="2693">ve an interpretation where the three boys lift a single piano with a joint effort. Finally, (8.c) has a cumulative interpretation. The sentence says that the union/cumulation of the bananas singularly eaten by each of the three monkeys includes the set of all our bananas. Currently, DTS deals with distributive IS readings only, despite their controversial existence in NL (see [23]), in that they require less formal effort. The extension of DTS coverage to collective/cumulative IS readings, which is taken as the object of future work, would require the introduction of more complex devices (see [3]). Since DTS’s coverage includes IS readings, the logic accepts more readings than other standard approaches to NL semantics. Every partial order between quantifier corresponds to an available reading. Examples are shown below in fig.2. 4 Positive and negative arcs [20] defines some constraints to prevent undesiderable readings arising from Nested Quantification and logical Redundancy (in contrast, Island Constraints are not considered). These constraints are defined in terms of ‘metarules’, like in Hobbs and Shieber’s algorithm: (9) a. If either d1 or d2 (transitively) occurs in the restricti</context>
</contexts>
<marker>[3]</marker>
<rawString>Beck, S. &amp; Sauerland, U. Cumulation is Needed: A Reply to Winter (2000). Natural Language Semantics, 8(4), 349–371, 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Beghelli</author>
<author>D Ben-Shalom</author>
<author>A Variation Szabolski</author>
</authors>
<title>Distributivity, and the Illusion of Branching</title>
<date>2001</date>
<booktitle>In A. Szabolcsi (Eds), Ways of Scope Taking, Kluwer:Dordrecht,</booktitle>
<pages>29--69</pages>
<contexts>
<context position="12224" citStr="[4]" startWordPosition="1889" endWordPosition="1889">ows to deal with islands and nested quantifiers in terms of the same construct. Redundancy and Coordination are not considered, but the extension of the logic in that direction seems obvious. 199 universal having a modifier (which includes another quantifier) in its restriction. For example, in the case of (6.c), there are two possibilities, according to the intention of referring to ‘all friends of all participants’ (bxby) or to ‘all friends of any participant’ (bybx). (6) a. Ax boy read ay book. b. Everyx man read everyx book. c. [Everyx friend of [everyy participant]] arrived. According to [4], analogous considerations hold for any NP that denotes a principal filter (see [2]): proper names, definites, but also some bare indefinites. We agree with [4]; proper names, as well as singular definites, clearly denote constant sets2, while definites seem to behave exactly like universals. For example, it is easy to see that (7.b-c) yield the same scopings of (6.b-c) (7) a. Thex men read everyy book. b. [Thex friends of [everyy participant]] arrived. In underspecified semantics, logical redundancy has recently been investigated by [9] and [17]. The former devises an algorithm that allows to</context>
</contexts>
<marker>[4]</marker>
<rawString>Beghelli F., Ben-Shalom D., Szabolski, A. Variation, Distributivity, and the Illusion of Branching In A. Szabolcsi (Eds), Ways of Scope Taking, Kluwer:Dordrecht, 29-69, 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Bos</author>
</authors>
<title>Predicate Logic Unplugged.</title>
<date>1996</date>
<booktitle>Proceedings of the 10th Amsterdam Colloquium.</booktitle>
<location>Amsterdam, The</location>
<contexts>
<context position="3820" citStr="[5]" startWordPosition="573" endWordPosition="573">. By solving the complex term &lt;b, x, man&apos;(x)&gt;, we get the partially solved formula in (2.b), from which, by solving the other complex term &lt;1, y, myst5ound&apos;(x)&gt;, we get reading (1.a). Conversely, by solving the two complex terms in the opposite order, we get (1.c). (2) a. heard&apos;(&lt; b, x, man&apos;(x) &gt;, &lt; 1, y, myst5ound&apos;(x) &gt;) b. bx(man&apos;(x), heard&apos;(x, &lt; 1, y, myst5ound&apos;(x) &gt;)) A more recent approach to underspecified semantics is grounded in dominance constraints between some kind of scope-bearers and some kind of scope-arguments. Underspecified Discourse Representation Theory [19], Hole Semantics [5], the approach of [25], Constraint Language for Lambda Structures (CLLS) [12], and Minimal Recursion Semantics (MRS) [10], belong to this approach. In MRS, the underspecified formula of (1) is (3) (h0, {h1: bx(h11, h12), h2: 1y(h21, h22), h3: man&apos;(x), h4: myst5ound&apos;(y), h5: heard&apos;(x, y)}, {h0=qh5, h11=qh3, h21=qh4}) This representation is a triple whose second element is a flat set of labelled subformulae called EPs. Each label (h1, h2, etc.) is called an ‘handle’. The EP associated with a quantifier contains a handle for its restriction and one for its body. The third element of the triple is</context>
</contexts>
<marker>[5]</marker>
<rawString>Bos, J. Predicate Logic Unplugged. Proceedings of the 10th Amsterdam Colloquium. Amsterdam, The Netherlands, 133–142, 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Bosco</author>
</authors>
<title>A grammatical relation system for treebank annotation.</title>
<date>2004</date>
<tech>Ph.D. thesis,</tech>
<institution>Department of Computer Science, University of Turin,</institution>
<contexts>
<context position="6222" citStr="[6]" startWordPosition="959" endWordPosition="959">implement the three mentioned constraints in terms of allowed/disallowed dependencies, in a uniform and modular way. These constructs, called positive/negative arcs, make DTS expressively complete, i.e. able to underspecify any possible subset of available readings. As argued by [11], although expressive completeness is a desiderable property for underspecified logics, unfortunately it is in trade-off with spatial/temporal complexity, which, in DTS, turns out to be exponential in the number d of NPs. The last section, however, presents a small experiment on the Turin University Treebank (TUT) [6], whose results seem to indicate that, in real cases, the three examined constraints strongly contribute to keep d, and hence the overall computational time, low. We will then conclude by claiming that the exponential asymptotic behaviour of the complexity function is a price worth paying for devising a disambiguation process based on allowed/disallowed dependencies. 2 Constraints on underspecified formulae As pointed out in the introduction, not all possible scopings correspond to a possible reading in NL. In this section, we investigate the three main linguistic phenomena involved in the una</context>
</contexts>
<marker>[6]</marker>
<rawString>Bosco, C. A grammatical relation system for treebank annotation. Ph.D. thesis, Department of Computer Science, University of Turin, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Brinkmann</author>
<author>B D McKay</author>
</authors>
<title>Posets on up to 16 Points.</title>
<date>2002</date>
<journal>Order,</journal>
<volume>19</volume>
<issue>2</issue>
<pages>147--179</pages>
<contexts>
<context position="22907" citStr="[7]" startWordPosition="3656" endWordPosition="3656">ivity, positive/negative arcs make DTS expressively complete, i.e. able to underspecify any subset of dependencies. This should be a property of every underspecified logic, as argued by [11], but, unfortunately, it turns out to be in trade-off with computational complexity. In DTS, in order to represent a subset of readings that have nothing in common, the only solution is listing6 all corresponding positive sets. For instance, the readings of (5.c) have been “listed” in P =ffy--&gt;x, z--&gt;x}, fA--&gt;Ctx}}. Since the number of partial orders is exponential in the number of discourse referents (cf. [7]), in the worst cases P has exponential cardinality. However, we believe that such cases are rare in reality. To provide evidence for this claim, we analyzed the data in TUT. For each sentence we estimated the number of positive/negative arcs needed to underspecify its readings. (11) is one of the more complex sentences we found in TUT. (11) Lax societ´a opera in numerosiy altri settori commerciali e industriali, annoverando tra lez sue propriet´a unak catena di 20w supermercati, (alcuniv) centri turistici e unap miniera. (ALB-247) Thex society operates in severaly other commercial and industr</context>
</contexts>
<marker>[7]</marker>
<rawString>Brinkmann, G. and McKay, B.D. Posets on up to 16 Points. Order, 19(2), 147–179, 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Bunt</author>
</authors>
<title>Semantic Underspecification: Which Technique For What Purpose?</title>
<date>2003</date>
<journal>Computing Meaning. Kluwer,</journal>
<volume>3</volume>
<contexts>
<context position="2477" citStr="[8]" startWordPosition="352" endWordPosition="352">–209, Tilburg, January 2009. c�2009 International Conference on Computational Semantics In order to provide a flexible solution to semantic ambiguities, Underspecified formalisms have been recently proposed. In underspecified semantics, semantic ambiguities are seen as instances of unspecified meaning that can adopt a more restricted sense depending on the preferences grounded in the syntactic structure, world-knowledge, topic/focus distinctions and so forth. underspecified logics allow to encapsulate scope ambiguities in a single structure. Surveys in underspecified semantics may be found in [8] and [11]. The first underspecified logic that has been proposed is perhaps the algorithm of Hobbs and Shieber [13], which has subsequently evolved into Quasi Logical Form [1]. In this proposal, the underspecified representation is a partial formula Φ that may contain underspecified terms, called complex terms, in the form &lt;q, v, r&gt; where q is a GQ, v an individual variable and r, the restriction of q, another partial formula. In order to obtain the disambiguated formulae, complex terms must be solved. This is done by “pulling out” and “unstoring” the complex terms one by one. Depending on the</context>
</contexts>
<marker>[8]</marker>
<rawString>Bunt, H. Semantic Underspecification: Which Technique For What Purpose? . In R. Musken and H. Bunt (Eds.), Computing Meaning. Kluwer, vol. 3, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R P Chaves</author>
</authors>
<title>Non-Redundant Scope Disambiguation in Underspecified Semantics.</title>
<date>2003</date>
<booktitle>Proc. of the 8th ESSLLI Student Session,</booktitle>
<pages>47--58</pages>
<location>Vienna,</location>
<contexts>
<context position="12767" citStr="[9]" startWordPosition="1975" endWordPosition="1975">yx friend of [everyy participant]] arrived. According to [4], analogous considerations hold for any NP that denotes a principal filter (see [2]): proper names, definites, but also some bare indefinites. We agree with [4]; proper names, as well as singular definites, clearly denote constant sets2, while definites seem to behave exactly like universals. For example, it is easy to see that (7.b-c) yield the same scopings of (6.b-c) (7) a. Thex men read everyy book. b. [Thex friends of [everyy participant]] arrived. In underspecified semantics, logical redundancy has recently been investigated by [9] and [17]. The former devises an algorithm that allows to prevent the generation of redundant readings, while the method presented in the latter generates all readings, but allows to group them into equivalence classes. 3 Dependency Tree Semantics In [20], a new underspecified semantic formalism called Dependency Tree Semantics (DTS) has been proposed. Well-formed structures in DTS are based on a graph G that represents the predicate-argument relations. The nodes of G are either predicates or individual variables called discourse referents. Predicates connect discourse referents via arcs label</context>
</contexts>
<marker>[9]</marker>
<rawString>Chaves, R.P. Non-Redundant Scope Disambiguation in Underspecified Semantics. Proc. of the 8th ESSLLI Student Session, 47-58, Vienna, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Copestake</author>
<author>D Flickinger</author>
<author>I A Sag</author>
</authors>
<title>Minimal Recursion Semantics. An introduction.</title>
<date>2005</date>
<journal>Research on Language and Computation,</journal>
<volume>3</volume>
<issue>2</issue>
<contexts>
<context position="3941" citStr="[10]" startWordPosition="591" endWordPosition="591">other complex term &lt;1, y, myst5ound&apos;(x)&gt;, we get reading (1.a). Conversely, by solving the two complex terms in the opposite order, we get (1.c). (2) a. heard&apos;(&lt; b, x, man&apos;(x) &gt;, &lt; 1, y, myst5ound&apos;(x) &gt;) b. bx(man&apos;(x), heard&apos;(x, &lt; 1, y, myst5ound&apos;(x) &gt;)) A more recent approach to underspecified semantics is grounded in dominance constraints between some kind of scope-bearers and some kind of scope-arguments. Underspecified Discourse Representation Theory [19], Hole Semantics [5], the approach of [25], Constraint Language for Lambda Structures (CLLS) [12], and Minimal Recursion Semantics (MRS) [10], belong to this approach. In MRS, the underspecified formula of (1) is (3) (h0, {h1: bx(h11, h12), h2: 1y(h21, h22), h3: man&apos;(x), h4: myst5ound&apos;(y), h5: heard&apos;(x, y)}, {h0=qh5, h11=qh3, h21=qh4}) This representation is a triple whose second element is a flat set of labelled subformulae called EPs. Each label (h1, h2, etc.) is called an ‘handle’. The EP associated with a quantifier contains a handle for its restriction and one for its body. The third element of the triple is a set of constraints in the 196 form hx=qhy, specifying that the EP handled by hy must occur in the scope of hx. Two dis</context>
</contexts>
<marker>[10]</marker>
<rawString>Copestake, A, Flickinger, D. and Sag, I.A. Minimal Recursion Semantics. An introduction. Research on Language and Computation, 3(2), 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Ebert</author>
</authors>
<title>Formal Investigations of Underspecified Representations.</title>
<date>2005</date>
<tech>Ph.D thesis,</tech>
<institution>Department of Computer Science, King’s College London,</institution>
<contexts>
<context position="2486" citStr="[11]" startWordPosition="354" endWordPosition="354">lburg, January 2009. c�2009 International Conference on Computational Semantics In order to provide a flexible solution to semantic ambiguities, Underspecified formalisms have been recently proposed. In underspecified semantics, semantic ambiguities are seen as instances of unspecified meaning that can adopt a more restricted sense depending on the preferences grounded in the syntactic structure, world-knowledge, topic/focus distinctions and so forth. underspecified logics allow to encapsulate scope ambiguities in a single structure. Surveys in underspecified semantics may be found in [8] and [11]. The first underspecified logic that has been proposed is perhaps the algorithm of Hobbs and Shieber [13], which has subsequently evolved into Quasi Logical Form [1]. In this proposal, the underspecified representation is a partial formula Φ that may contain underspecified terms, called complex terms, in the form &lt;q, v, r&gt; where q is a GQ, v an individual variable and r, the restriction of q, another partial formula. In order to obtain the disambiguated formulae, complex terms must be solved. This is done by “pulling out” and “unstoring” the complex terms one by one. Depending on the order in</context>
<context position="5903" citStr="[11]" startWordPosition="910" endWordPosition="910">traints have to be somehow carried out in an underspecified logic, in order to avoid readings not available in NL. We will briefly discuss the alternatives proposed in the aforementioned formalisms and in DTS. Section 4 contains the core of the research presented here. It proposes to add in DTS two new constructs that implement the three mentioned constraints in terms of allowed/disallowed dependencies, in a uniform and modular way. These constructs, called positive/negative arcs, make DTS expressively complete, i.e. able to underspecify any possible subset of available readings. As argued by [11], although expressive completeness is a desiderable property for underspecified logics, unfortunately it is in trade-off with spatial/temporal complexity, which, in DTS, turns out to be exponential in the number d of NPs. The last section, however, presents a small experiment on the Turin University Treebank (TUT) [6], whose results seem to indicate that, in real cases, the three examined constraints strongly contribute to keep d, and hence the overall computational time, low. We will then conclude by claiming that the exponential asymptotic behaviour of the complexity function is a price wort</context>
<context position="22494" citStr="[11]" startWordPosition="3589" endWordPosition="3589">ed from N. Although we defined algorithms implementing such heuristics, lack of space forbids us to provide further details. exceptions of other negative sets: the occurrence of fx--&gt;z} in N does not prevent the insertion of fy--&gt;z|x--&gt;z}. restr(y) quant(x)=8 restr(x) restr(z) quant(y)=3 quant(z)=Dlost 1 comp&apos; 1 2 rep-of&apos; saw&apos; rep-of&apos; 1 1 2 1 2 1 comp&apos; sample&apos; z z 1 sample&apos; 204 From the point of view of expressivity, positive/negative arcs make DTS expressively complete, i.e. able to underspecify any subset of dependencies. This should be a property of every underspecified logic, as argued by [11], but, unfortunately, it turns out to be in trade-off with computational complexity. In DTS, in order to represent a subset of readings that have nothing in common, the only solution is listing6 all corresponding positive sets. For instance, the readings of (5.c) have been “listed” in P =ffy--&gt;x, z--&gt;x}, fA--&gt;Ctx}}. Since the number of partial orders is exponential in the number of discourse referents (cf. [7]), in the worst cases P has exponential cardinality. However, we believe that such cases are rare in reality. To provide evidence for this claim, we analyzed the data in TUT. For each sen</context>
</contexts>
<marker>[11]</marker>
<rawString>Ebert, C. Formal Investigations of Underspecified Representations. Ph.D thesis, Department of Computer Science, King’s College London, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Egg</author>
<author>A Koller</author>
<author>J Niehren</author>
</authors>
<title>The Constraint Language for Lambda Structures.</title>
<date>2001</date>
<journal>Journal of Logic, Language and Information,</journal>
<volume>10</volume>
<issue>4</issue>
<contexts>
<context position="3897" citStr="[12]" startWordPosition="585" endWordPosition="585">ormula in (2.b), from which, by solving the other complex term &lt;1, y, myst5ound&apos;(x)&gt;, we get reading (1.a). Conversely, by solving the two complex terms in the opposite order, we get (1.c). (2) a. heard&apos;(&lt; b, x, man&apos;(x) &gt;, &lt; 1, y, myst5ound&apos;(x) &gt;) b. bx(man&apos;(x), heard&apos;(x, &lt; 1, y, myst5ound&apos;(x) &gt;)) A more recent approach to underspecified semantics is grounded in dominance constraints between some kind of scope-bearers and some kind of scope-arguments. Underspecified Discourse Representation Theory [19], Hole Semantics [5], the approach of [25], Constraint Language for Lambda Structures (CLLS) [12], and Minimal Recursion Semantics (MRS) [10], belong to this approach. In MRS, the underspecified formula of (1) is (3) (h0, {h1: bx(h11, h12), h2: 1y(h21, h22), h3: man&apos;(x), h4: myst5ound&apos;(y), h5: heard&apos;(x, y)}, {h0=qh5, h11=qh3, h21=qh4}) This representation is a triple whose second element is a flat set of labelled subformulae called EPs. Each label (h1, h2, etc.) is called an ‘handle’. The EP associated with a quantifier contains a handle for its restriction and one for its body. The third element of the triple is a set of constraints in the 196 form hx=qhy, specifying that the EP handled </context>
<context position="10499" citStr="[12]" startWordPosition="1616" endWordPosition="1616">id you met everyx professor. [16] b. Ay student wants you to meet everyx professor. [16] c. Everyx student reads ay book and az paper. [26] In underspecified semantic, a standard way to deal with Island constraints of the first kind introduces special ‘blocking’ place holders, one for each tensed clause. The scope of the quantifiers in the clause is required to be always included in the scope of the place holder. In MRS, the place holder may be a handle referring to the ‘top’ of the clause. [14] implements Island constraints in an MRS-like framework. Similar alternatives have been proposed in [12] and [16]. The former implements a mechanism very close to [14], while the latter devises a feature-based framework where a feature MAXS blocks the scope of the quantifiers occurring in finite clausesi. Island constraints carried by coordinate structures have received less attention in Underspecification, the most recent exception being perhaps [26]. In [26], Hole Semantics is extended to properly handle the meaning of sentences as (5.c). Logical Redundancy: redundancy may arise when existential and universal quantifiers occur in the sentence. Existential quantifiers range over a singleton of </context>
<context position="26343" citStr="[12]" startWordPosition="4276" endWordPosition="4276">riction. According to the discussion above, such NPs must be linked to Ctx only, but this is already handled by the positive arc A--&gt;Ctx. In other words, proper names and definites with no restriction introduce new discourse referents but do not introduce new arcs, thus decreasing the average values. More reliable results are reported in Table 2. The table shows the number of arcs per discourse referents without considering such NPs. The reader may see that in the worst cases the number of arcs can be still considered low. 8We excluded sentences including verbal ellipsis in that, according to [12], they can engender complex quantifier-scope ambiguities not currently handled in DTS. Anaphora have been ignored, in that those requiring a referent resolution enter Ctx only, while donkey sentences, as shown by [24], simply require copies of the referent, with equal dependencies. 206 |D |0 &lt; |D |≤ 2 2 &lt; |D |≤ 5 5 &lt; |D |≤ 10 10 &lt; |D |≤ 20 |Sentences |985 574 153 3 |Arcs |1.38 3.39 10.62 36 Table 2: TUT - Number of positive/negative arcs per discourse referents, without considering proper names and definitives with no restriction. 6 Conclusions In this paper, we presented an extension of DTS w</context>
</contexts>
<marker>[12]</marker>
<rawString>Egg, M. and Koller, A. and Niehren, J. The Constraint Language for Lambda Structures. Journal of Logic, Language and Information, 10(4), 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J R Hobbs</author>
<author>S Shieber</author>
</authors>
<title>An Algorithm for Generating Quantifier Scoping. Computational Linguistics:</title>
<date>1987</date>
<pages>13--47</pages>
<contexts>
<context position="2592" citStr="[13]" startWordPosition="372" endWordPosition="372">ible solution to semantic ambiguities, Underspecified formalisms have been recently proposed. In underspecified semantics, semantic ambiguities are seen as instances of unspecified meaning that can adopt a more restricted sense depending on the preferences grounded in the syntactic structure, world-knowledge, topic/focus distinctions and so forth. underspecified logics allow to encapsulate scope ambiguities in a single structure. Surveys in underspecified semantics may be found in [8] and [11]. The first underspecified logic that has been proposed is perhaps the algorithm of Hobbs and Shieber [13], which has subsequently evolved into Quasi Logical Form [1]. In this proposal, the underspecified representation is a partial formula Φ that may contain underspecified terms, called complex terms, in the form &lt;q, v, r&gt; where q is a GQ, v an individual variable and r, the restriction of q, another partial formula. In order to obtain the disambiguated formulae, complex terms must be solved. This is done by “pulling out” and “unstoring” the complex terms one by one. Depending on the order in which they are solved, different readings are obtained. For instance, the underspecified representation o</context>
<context position="7484" citStr="[13]" startWordPosition="1149" endWordPosition="1149">ification, Island Constraints, and logical Redundancy. Nested Quantification: Several unreasonable readings arise from a con197 trast between semantic/syntactic nesting of quantifiers. For instance, it is awkward to take the sentence in (4.a), where the NP a company occurs in the syntactic restriction of the quantifier every, as describing the situation corresponding to the scoping bmostl, in which each representative saw a potentially different set of most samples, and he belongs to a different company for each sample he saw. (4) a. [Everyx representative of [ay company]] saw [mostz samples] [13]. b. see&apos;(&lt;b, x, rep_of&apos;(x, &lt;l, y, comp&apos;(y)&gt;)&gt;, &lt;Most, z, sample&apos;(z)&gt;) c. (h0, fh1: bx(h11, h12), h2: ly(h21, h22), h3: Mostz(h31, h32), h4:rep_of&apos;(x, y), h5: comp&apos;(y), h6: sample&apos;(z), h7: saw(x, z)}, fh0=qh7, h11=qh4, h21=qh5, h31=qh6}) d. ly(comp&apos;(y), Mostz(samp&apos;(z), bx(rep&apos;(x)nof&apos;(x, y), see&apos;(x, z))) e. bx(ly(comp&apos;(y), rep&apos;(x)nof&apos;(x, y)), Mostz(samp&apos;(z), see&apos;(x, z))) f. Mostz(samp&apos;(z), bx(ly(comp&apos;(y), rep&apos;(x)nof&apos;(x, y)), see&apos;(x, z))) g. ly(comp&apos;(y), bx(rep&apos;(x)nof&apos;(x, y), Mostz(samp&apos;(z), see&apos;(x, z)))) h. Mostz(samp&apos;(z), ly(comp&apos;(y), bx(rep&apos;(x)nof&apos;(x, y), see&apos;(x, z))) In the Hobbs and Shieber</context>
</contexts>
<marker>[13]</marker>
<rawString>Hobbs, J. R. and Shieber, S. An Algorithm for Generating Quantifier Scoping. Computational Linguistics: 13:47–63, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A K Joshi</author>
<author>L Kallmeyer</author>
</authors>
<title>Factoring Predicate Argument and Scope Semantics: Underspecified Semantics with LTAG.</title>
<date>2003</date>
<journal>Research on Language and Computation,</journal>
<volume>1</volume>
<contexts>
<context position="8846" citStr="[14]" startWordPosition="1345" endWordPosition="1345">rule, the algorithm, starting from the underspecified formula in (4.b), computes the five readings in (4.d-h). The same readings are triggered by the dominance constraints in the MRS representation (4.c). Several authors, e.g. [18], claim that also (4.d) has to be forbidden, in that if q1 occurs in the restriction of q2, no other quantifier can ‘intercalate’ between them in the scope order. In underspecified semantic, this view was accepted by [25] and [15] among others. The former develops a logical theory that identifies intercalating readings by deriving inconsistencies. The latter extends [14], which proposes a syntax-semantics interface from LTAG to MRS-like formulae, with a construct based on quantifier sets that prevents intercalating readings. Island Constraints: certain syntactic structures are scope-“islands”, i.e. the scope-bearers occurring therein cannot outscope elements outside the island. Island constraints have been introduced by [21]. There are basically 198 two kinds of islands: finite clauses and coordinated structures. An example of the former is shown in (5.a), where ∀x cannot outscope ∃y in that a student is outside the finite clause where every occurs. In contra</context>
<context position="10395" citStr="[14]" startWordPosition="1602" endWordPosition="1602">e there is a single a book and a single paper that have been read by every student. (5) a. Ay student said you met everyx professor. [16] b. Ay student wants you to meet everyx professor. [16] c. Everyx student reads ay book and az paper. [26] In underspecified semantic, a standard way to deal with Island constraints of the first kind introduces special ‘blocking’ place holders, one for each tensed clause. The scope of the quantifiers in the clause is required to be always included in the scope of the place holder. In MRS, the place holder may be a handle referring to the ‘top’ of the clause. [14] implements Island constraints in an MRS-like framework. Similar alternatives have been proposed in [12] and [16]. The former implements a mechanism very close to [14], while the latter devises a feature-based framework where a feature MAXS blocks the scope of the quantifiers occurring in finite clausesi. Island constraints carried by coordinate structures have received less attention in Underspecification, the most recent exception being perhaps [26]. In [26], Hole Semantics is extended to properly handle the meaning of sentences as (5.c). Logical Redundancy: redundancy may arise when existen</context>
</contexts>
<marker>[14]</marker>
<rawString>Joshi, A. K. and Kallmeyer, L. Factoring Predicate Argument and Scope Semantics: Underspecified Semantics with LTAG. Research on Language and Computation, 1:3–58, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A K Joshi</author>
<author>L Kallmeyer</author>
<author>M Romero</author>
</authors>
<title>Flexible Composition in LTAG: Quantifier Scope and Inverse Linking. In</title>
<date>2003</date>
<journal>Computing Meaning. Kluwer,</journal>
<volume>3</volume>
<contexts>
<context position="8703" citStr="[15]" startWordPosition="1325" endWordPosition="1325">se readings are forbidden by selecting, at each step, a complex term not included in the restriction of any other complex term. With this meta-rule, the algorithm, starting from the underspecified formula in (4.b), computes the five readings in (4.d-h). The same readings are triggered by the dominance constraints in the MRS representation (4.c). Several authors, e.g. [18], claim that also (4.d) has to be forbidden, in that if q1 occurs in the restriction of q2, no other quantifier can ‘intercalate’ between them in the scope order. In underspecified semantic, this view was accepted by [25] and [15] among others. The former develops a logical theory that identifies intercalating readings by deriving inconsistencies. The latter extends [14], which proposes a syntax-semantics interface from LTAG to MRS-like formulae, with a construct based on quantifier sets that prevents intercalating readings. Island Constraints: certain syntactic structures are scope-“islands”, i.e. the scope-bearers occurring therein cannot outscope elements outside the island. Island constraints have been introduced by [21]. There are basically 198 two kinds of islands: finite clauses and coordinated structures. An ex</context>
</contexts>
<marker>[15]</marker>
<rawString>Joshi, A. K. and Kallmeyer, L. and Romero, M. Flexible Composition in LTAG: Quantifier Scope and Inverse Linking. In R. Musken and H. Bunt (Eds.), Computing Meaning. Kluwer, vol. 3, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Kallmeyer</author>
<author>M Romero</author>
</authors>
<title>Scope and Situation Binding in LTAG using Semantic Unification.</title>
<date>2008</date>
<journal>Research on Language and Computation,</journal>
<volume>6</volume>
<issue>1</issue>
<contexts>
<context position="9928" citStr="[16]" startWordPosition="1519" endWordPosition="1519">s shown in (5.a), where ∀x cannot outscope ∃y in that a student is outside the finite clause where every occurs. In contrast, the scope of NPs can freely rise over non-finite clauses, as shown in (5.b), where ∀x∃y is available. An example of coordinated structures acting as islands is shown in (5.c). (5.c) yields two scopings only, ∀x∃y∃z and ∃y∃z∀x, corresponding, respectively, to a reading where every student reads a own book and a own paper, and a reading where there is a single a book and a single paper that have been read by every student. (5) a. Ay student said you met everyx professor. [16] b. Ay student wants you to meet everyx professor. [16] c. Everyx student reads ay book and az paper. [26] In underspecified semantic, a standard way to deal with Island constraints of the first kind introduces special ‘blocking’ place holders, one for each tensed clause. The scope of the quantifiers in the clause is required to be always included in the scope of the place holder. In MRS, the place holder may be a handle referring to the ‘top’ of the clause. [14] implements Island constraints in an MRS-like framework. Similar alternatives have been proposed in [12] and [16]. The former impleme</context>
<context position="11544" citStr="[16]" startWordPosition="1777" endWordPosition="1777">. Logical Redundancy: redundancy may arise when existential and universal quantifiers occur in the sentence. Existential quantifiers range over a singleton of individuals, and so they cannot induce variation of their narrowscope sets. Analogously, universal quantifiers range over a whole domain of individuals, which do not vary on the entities in their wide-scope sets. Therefore, in (6.a-b) the scopings ∃x∃y and ∀x∀y are respectively equivalent to ∃y∃x and ∀y∀x. Therefore, the latter may be taken as redundant. Nevertheless, there is an exception to the rule about universals. It concerns a &apos;In [16], also prepositions as of in (4) are associated with a feature MAXS. This allows to deal with islands and nested quantifiers in terms of the same construct. Redundancy and Coordination are not considered, but the extension of the logic in that direction seems obvious. 199 universal having a modifier (which includes another quantifier) in its restriction. For example, in the case of (6.c), there are two possibilities, according to the intention of referring to ‘all friends of all participants’ (bxby) or to ‘all friends of any participant’ (bybx). (6) a. Ax boy read ay book. b. Everyx man read e</context>
</contexts>
<marker>[16]</marker>
<rawString>Kallmeyer, L. &amp; Romero, M. Scope and Situation Binding in LTAG using Semantic Unification. Research on Language and Computation, 6(1), 2008.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Koller</author>
<author>S Thater</author>
</authors>
<title>Towards a redundancy elimination algorithm for underspecified descriptions.</title>
<date>2006</date>
<booktitle>Proc. of the 5th Int. Workshop on Inference in Computational Semantics (ICoS-5)</booktitle>
<location>Buxton, England,</location>
<contexts>
<context position="12776" citStr="[17]" startWordPosition="1977" endWordPosition="1977">d of [everyy participant]] arrived. According to [4], analogous considerations hold for any NP that denotes a principal filter (see [2]): proper names, definites, but also some bare indefinites. We agree with [4]; proper names, as well as singular definites, clearly denote constant sets2, while definites seem to behave exactly like universals. For example, it is easy to see that (7.b-c) yield the same scopings of (6.b-c) (7) a. Thex men read everyy book. b. [Thex friends of [everyy participant]] arrived. In underspecified semantics, logical redundancy has recently been investigated by [9] and [17]. The former devises an algorithm that allows to prevent the generation of redundant readings, while the method presented in the latter generates all readings, but allows to group them into equivalence classes. 3 Dependency Tree Semantics In [20], a new underspecified semantic formalism called Dependency Tree Semantics (DTS) has been proposed. Well-formed structures in DTS are based on a graph G that represents the predicate-argument relations. The nodes of G are either predicates or individual variables called discourse referents. Predicates connect discourse referents via arcs labelled with </context>
</contexts>
<marker>[17]</marker>
<rawString>Koller A., Thater S. Towards a redundancy elimination algorithm for underspecified descriptions. Proc. of the 5th Int. Workshop on Inference in Computational Semantics (ICoS-5) Buxton, England, 2006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Park</author>
</authors>
<title>Quantifier Scope and Constituency.</title>
<date>1995</date>
<booktitle>Proceedings of the 33rd Annual Meeting of the ACL.</booktitle>
<pages>205--212</pages>
<contexts>
<context position="8473" citStr="[18]" startWordPosition="1284" endWordPosition="1284">p&apos;(z), bx(ly(comp&apos;(y), rep&apos;(x)nof&apos;(x, y)), see&apos;(x, z))) g. ly(comp&apos;(y), bx(rep&apos;(x)nof&apos;(x, y), Mostz(samp&apos;(z), see&apos;(x, z)))) h. Mostz(samp&apos;(z), ly(comp&apos;(y), bx(rep&apos;(x)nof&apos;(x, y), see&apos;(x, z))) In the Hobbs and Shieber algorithm, these readings are forbidden by selecting, at each step, a complex term not included in the restriction of any other complex term. With this meta-rule, the algorithm, starting from the underspecified formula in (4.b), computes the five readings in (4.d-h). The same readings are triggered by the dominance constraints in the MRS representation (4.c). Several authors, e.g. [18], claim that also (4.d) has to be forbidden, in that if q1 occurs in the restriction of q2, no other quantifier can ‘intercalate’ between them in the scope order. In underspecified semantic, this view was accepted by [25] and [15] among others. The former develops a logical theory that identifies intercalating readings by deriving inconsistencies. The latter extends [14], which proposes a syntax-semantics interface from LTAG to MRS-like formulae, with a construct based on quantifier sets that prevents intercalating readings. Island Constraints: certain syntactic structures are scope-“islands”,</context>
</contexts>
<marker>[18]</marker>
<rawString>Park, J. Quantifier Scope and Constituency. Proceedings of the 33rd Annual Meeting of the ACL. pp.205-212, 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>U Reyle</author>
</authors>
<title>Dealing with ambiguities by Underspecification: Construction, Representation and Deduction.</title>
<date>1993</date>
<journal>Journal of Semantics,</journal>
<volume>13</volume>
<pages>123--179</pages>
<contexts>
<context position="3800" citStr="[19]" startWordPosition="570" endWordPosition="570">.a) is shown in (2.a). By solving the complex term &lt;b, x, man&apos;(x)&gt;, we get the partially solved formula in (2.b), from which, by solving the other complex term &lt;1, y, myst5ound&apos;(x)&gt;, we get reading (1.a). Conversely, by solving the two complex terms in the opposite order, we get (1.c). (2) a. heard&apos;(&lt; b, x, man&apos;(x) &gt;, &lt; 1, y, myst5ound&apos;(x) &gt;) b. bx(man&apos;(x), heard&apos;(x, &lt; 1, y, myst5ound&apos;(x) &gt;)) A more recent approach to underspecified semantics is grounded in dominance constraints between some kind of scope-bearers and some kind of scope-arguments. Underspecified Discourse Representation Theory [19], Hole Semantics [5], the approach of [25], Constraint Language for Lambda Structures (CLLS) [12], and Minimal Recursion Semantics (MRS) [10], belong to this approach. In MRS, the underspecified formula of (1) is (3) (h0, {h1: bx(h11, h12), h2: 1y(h21, h22), h3: man&apos;(x), h4: myst5ound&apos;(y), h5: heard&apos;(x, y)}, {h0=qh5, h11=qh3, h21=qh4}) This representation is a triple whose second element is a flat set of labelled subformulae called EPs. Each label (h1, h2, etc.) is called an ‘handle’. The EP associated with a quantifier contains a handle for its restriction and one for its body. The third elem</context>
</contexts>
<marker>[19]</marker>
<rawString>Reyle, U. Dealing with ambiguities by Underspecification: Construction, Representation and Deduction. Journal of Semantics, 13, 123–179, 1993.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Robaldo</author>
</authors>
<title>Dependency Tree Semantics.</title>
<date>2007</date>
<tech>Ph.D thesis,</tech>
<institution>Department of Computer Science, Turin University,</institution>
<contexts>
<context position="4793" citStr="[20]" startWordPosition="743" endWordPosition="743">t is a flat set of labelled subformulae called EPs. Each label (h1, h2, etc.) is called an ‘handle’. The EP associated with a quantifier contains a handle for its restriction and one for its body. The third element of the triple is a set of constraints in the 196 form hx=qhy, specifying that the EP handled by hy must occur in the scope of hx. Two disambiguations are then possible in (3): fh0 = h1, h12 = h2, h22 = h5}, which leads to (1.b), and fh0 = h2, h22 = h1, h12 = h5}, which leads to (1.c). A new approach to underspecification of quantifier scope ambiguities has been recently proposed in [20], and implemented into a new formalism called Dependency Tree Semantics (DTS). In DTS, disambiguation is performed by explicitly showing the dependencies between involved sets, i.e. by achieving a sort of underspecified ‘Skolemization’. DTS is presented in detail in section 3. Before presenting DTS, however, we will discuss in section 2 three main linguistic phenomena that reduce the level of ambiguity of NL sentences, namely Nested Quantification, Island Constraints and logical Redundancy. Those constraints have to be somehow carried out in an underspecified logic, in order to avoid readings </context>
<context position="13022" citStr="[20]" startWordPosition="2016" endWordPosition="2016">r definites, clearly denote constant sets2, while definites seem to behave exactly like universals. For example, it is easy to see that (7.b-c) yield the same scopings of (6.b-c) (7) a. Thex men read everyy book. b. [Thex friends of [everyy participant]] arrived. In underspecified semantics, logical redundancy has recently been investigated by [9] and [17]. The former devises an algorithm that allows to prevent the generation of redundant readings, while the method presented in the latter generates all readings, but allows to group them into equivalence classes. 3 Dependency Tree Semantics In [20], a new underspecified semantic formalism called Dependency Tree Semantics (DTS) has been proposed. Well-formed structures in DTS are based on a graph G that represents the predicate-argument relations. The nodes of G are either predicates or individual variables called discourse referents. Predicates connect discourse referents via arcs labelled with the argument-position. Each discourse referent is also associated, via a function quant, with a GQ, and with a restriction, via a function restr from discourse referents to subgraphs of G. In order to make the dependencies among sets of entities </context>
<context position="14831" citStr="[20]" startWordPosition="2314" endWordPosition="2314">x only are assumed to denote fixed sets of entities, i.e. to correspond to Skolem constants. The several readings of a sentence differ in the SemDep arcs only. For instance, both readings of (1.a) share the structures shown in fig.1.a3, but they have two different sets of SemDep arcs: (1.b) is conveyed by those in fig.1.b; (1.c) by those in fi g . 1 . c . a) restr(x)restr(y) b)SemDep c)SemDep quant (x) = b quant (y) = �] Figure 1: (a) SDG for sentence (1.a). (b-c) The two disambiguations (1.a) In order to achieve underspecified semantics, SemDep arcs have to be somehow added incrementally. In [20], this is done by defining another kind of arcs, termed SkDep arcs. This paper makes use of other two kinds of arc, termed positive and negative arcs, and propose them as an alternative of SkDep arcs. Before proceeding, it is worth stressing the main linguistic advantage of DTS, although this article is not devoted to it. DTS licenses particular readings where two or more sets of entities are introduced at the same level of scope. I refer to such interpretations with the term ‘Independent Set’ (IS) readings. Three basic kinds of IS readings need to be distinguished: distributive, collective an</context>
<context position="17327" citStr="[20]" startWordPosition="2734" endWordPosition="2734">as. Currently, DTS deals with distributive IS readings only, despite their controversial existence in NL (see [23]), in that they require less formal effort. The extension of DTS coverage to collective/cumulative IS readings, which is taken as the object of future work, would require the introduction of more complex devices (see [3]). Since DTS’s coverage includes IS readings, the logic accepts more readings than other standard approaches to NL semantics. Every partial order between quantifier corresponds to an available reading. Examples are shown below in fig.2. 4 Positive and negative arcs [20] defines some constraints to prevent undesiderable readings arising from Nested Quantification and logical Redundancy (in contrast, Island Constraints are not considered). These constraints are defined in terms of ‘metarules’, like in Hobbs and Shieber’s algorithm: (9) a. If either d1 or d2 (transitively) occurs in the restriction of a discourse referent d, and the other one does not, then the arc d1--&gt;d2 can be inserted only if the graph contains an arc d--&gt;d2. b. If quant(d1)=∀ or quant(d2)=∃, the arc d1--&gt;d2 cannot be inserted. The only exception is when quant(d1)=∀ and d2 (transitively) oc</context>
</contexts>
<marker>[20]</marker>
<rawString>Robaldo, L. Dependency Tree Semantics. Ph.D thesis, Department of Computer Science, Turin University, Italy, 2007.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J R Ross</author>
</authors>
<title>Constraints on Variables in Syntax.</title>
<date>1967</date>
<tech>Ph.D thesis,</tech>
<institution>Massachusetts Institute of Technology,</institution>
<contexts>
<context position="9207" citStr="[21]" startWordPosition="1392" endWordPosition="1392">between them in the scope order. In underspecified semantic, this view was accepted by [25] and [15] among others. The former develops a logical theory that identifies intercalating readings by deriving inconsistencies. The latter extends [14], which proposes a syntax-semantics interface from LTAG to MRS-like formulae, with a construct based on quantifier sets that prevents intercalating readings. Island Constraints: certain syntactic structures are scope-“islands”, i.e. the scope-bearers occurring therein cannot outscope elements outside the island. Island constraints have been introduced by [21]. There are basically 198 two kinds of islands: finite clauses and coordinated structures. An example of the former is shown in (5.a), where ∀x cannot outscope ∃y in that a student is outside the finite clause where every occurs. In contrast, the scope of NPs can freely rise over non-finite clauses, as shown in (5.b), where ∀x∃y is available. An example of coordinated structures acting as islands is shown in (5.c). (5.c) yields two scopings only, ∀x∃y∃z and ∃y∃z∀x, corresponding, respectively, to a reading where every student reads a own book and a own paper, and a reading where there is a sin</context>
</contexts>
<marker>[21]</marker>
<rawString>Ross, J. R. Constraints on Variables in Syntax. Ph.D thesis, Massachusetts Institute of Technology, 1967.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Distributive Scha</author>
</authors>
<title>Collective and Cumulative Quantification. In</title>
<date>1981</date>
<journal>the Study of Language, Part</journal>
<booktitle>Mathematisch Centrum,</booktitle>
<volume>2</volume>
<pages>483--512</pages>
<location>Amsterdam,</location>
<contexts>
<context position="15465" citStr="[22]" startWordPosition="2419" endWordPosition="2419">ther kind of arcs, termed SkDep arcs. This paper makes use of other two kinds of arc, termed positive and negative arcs, and propose them as an alternative of SkDep arcs. Before proceeding, it is worth stressing the main linguistic advantage of DTS, although this article is not devoted to it. DTS licenses particular readings where two or more sets of entities are introduced at the same level of scope. I refer to such interpretations with the term ‘Independent Set’ (IS) readings. Three basic kinds of IS readings need to be distinguished: distributive, collective and cumulative IS readings (cf. [22]), respectively shown in (8.a-c) (8) a. Two examiners marked six scripts. b. Three boys lift a piano. 3DTS structures are usually displayed in a graphical notation where the subgraphs corresponding to restr’s values are graphically shown separately. SemDep arcs are shown as dotted arcs; in order to increase readability, transitive SemDep arcs are omitted. Nevertheless, the reader must always keep in mind that they do occur, i.e. that SemDep describes a transitive relation. Therefore, in fig.1.b, there is an arc y--&gt;Ctx, even if it is not shown. Ctx X y hear&apos; 1 2 1 1 man&apos; mSound&apos; X y mSound&apos; 1 </context>
</contexts>
<marker>[22]</marker>
<rawString>Scha, R. Distributive, Collective and Cumulative Quantification. In J. Groenendijk, M. Stokhof (Eds.), Formal Methods in the Study of Language, Part 2, pages 483–512. Mathematisch Centrum, Amsterdam, 1981.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Schein</author>
</authors>
<title>Plurals and Events.</title>
<date>1993</date>
<publisher>MIT Press,</publisher>
<location>Cambridge, MA, USA,</location>
<contexts>
<context position="16837" citStr="[23]" startWordPosition="2658" endWordPosition="2658">ding where there is a set of two examiners and a set of six scripts and each of the two examiners marked each of the six scripts. (8.b) is an archetypal example of the so-called collective readings. The sentence may receive an interpretation where the three boys lift a single piano with a joint effort. Finally, (8.c) has a cumulative interpretation. The sentence says that the union/cumulation of the bananas singularly eaten by each of the three monkeys includes the set of all our bananas. Currently, DTS deals with distributive IS readings only, despite their controversial existence in NL (see [23]), in that they require less formal effort. The extension of DTS coverage to collective/cumulative IS readings, which is taken as the object of future work, would require the introduction of more complex devices (see [3]). Since DTS’s coverage includes IS readings, the logic accepts more readings than other standard approaches to NL semantics. Every partial order between quantifier corresponds to an available reading. Examples are shown below in fig.2. 4 Positive and negative arcs [20] defines some constraints to prevent undesiderable readings arising from Nested Quantification and logical Red</context>
</contexts>
<marker>[23]</marker>
<rawString>Schein, B. Plurals and Events. MIT Press, Cambridge, MA, USA, 1993.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Steedman</author>
</authors>
<title>The Grammar of</title>
<date>2007</date>
<booktitle>Scope, forthcoming. See Surface-Compositional Scope-Alternation Without Existential Quantifiers. Draft 5.2,</booktitle>
<pages>6</pages>
<contexts>
<context position="26560" citStr="[24]" startWordPosition="4308" endWordPosition="4308">scourse referents but do not introduce new arcs, thus decreasing the average values. More reliable results are reported in Table 2. The table shows the number of arcs per discourse referents without considering such NPs. The reader may see that in the worst cases the number of arcs can be still considered low. 8We excluded sentences including verbal ellipsis in that, according to [12], they can engender complex quantifier-scope ambiguities not currently handled in DTS. Anaphora have been ignored, in that those requiring a referent resolution enter Ctx only, while donkey sentences, as shown by [24], simply require copies of the referent, with equal dependencies. 206 |D |0 &lt; |D |≤ 2 2 &lt; |D |≤ 5 5 &lt; |D |≤ 10 10 &lt; |D |≤ 20 |Sentences |985 574 153 3 |Arcs |1.38 3.39 10.62 36 Table 2: TUT - Number of positive/negative arcs per discourse referents, without considering proper names and definitives with no restriction. 6 Conclusions In this paper, we presented an extension of DTS where allowed/disallowed dependencies are explicitly specified by inserting new arcs called positive/negative arcs. We believe that positive/negative arcs provide a scalable and modular solution for the management of c</context>
</contexts>
<marker>[24]</marker>
<rawString>Steedman, M. The Grammar of Scope, forthcoming. See Surface-Compositional Scope-Alternation Without Existential Quantifiers. Draft 5.2, Sept 2007. ftp://ftp.cogsci.ed.ac.uk/pub/steedman/quantifiers/journal6.pdf.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Willis</author>
</authors>
<title>An Efficient Treatment of Quantification in Underspecified Semantic Representations. Ph.D thesis,</title>
<date>2000</date>
<institution>University of York,</institution>
<contexts>
<context position="3842" citStr="[25]" startWordPosition="577" endWordPosition="577">lex term &lt;b, x, man&apos;(x)&gt;, we get the partially solved formula in (2.b), from which, by solving the other complex term &lt;1, y, myst5ound&apos;(x)&gt;, we get reading (1.a). Conversely, by solving the two complex terms in the opposite order, we get (1.c). (2) a. heard&apos;(&lt; b, x, man&apos;(x) &gt;, &lt; 1, y, myst5ound&apos;(x) &gt;) b. bx(man&apos;(x), heard&apos;(x, &lt; 1, y, myst5ound&apos;(x) &gt;)) A more recent approach to underspecified semantics is grounded in dominance constraints between some kind of scope-bearers and some kind of scope-arguments. Underspecified Discourse Representation Theory [19], Hole Semantics [5], the approach of [25], Constraint Language for Lambda Structures (CLLS) [12], and Minimal Recursion Semantics (MRS) [10], belong to this approach. In MRS, the underspecified formula of (1) is (3) (h0, {h1: bx(h11, h12), h2: 1y(h21, h22), h3: man&apos;(x), h4: myst5ound&apos;(y), h5: heard&apos;(x, y)}, {h0=qh5, h11=qh3, h21=qh4}) This representation is a triple whose second element is a flat set of labelled subformulae called EPs. Each label (h1, h2, etc.) is called an ‘handle’. The EP associated with a quantifier contains a handle for its restriction and one for its body. The third element of the triple is a set of constraints </context>
<context position="8694" citStr="[25]" startWordPosition="1323" endWordPosition="1323">ithm, these readings are forbidden by selecting, at each step, a complex term not included in the restriction of any other complex term. With this meta-rule, the algorithm, starting from the underspecified formula in (4.b), computes the five readings in (4.d-h). The same readings are triggered by the dominance constraints in the MRS representation (4.c). Several authors, e.g. [18], claim that also (4.d) has to be forbidden, in that if q1 occurs in the restriction of q2, no other quantifier can ‘intercalate’ between them in the scope order. In underspecified semantic, this view was accepted by [25] and [15] among others. The former develops a logical theory that identifies intercalating readings by deriving inconsistencies. The latter extends [14], which proposes a syntax-semantics interface from LTAG to MRS-like formulae, with a construct based on quantifier sets that prevents intercalating readings. Island Constraints: certain syntactic structures are scope-“islands”, i.e. the scope-bearers occurring therein cannot outscope elements outside the island. Island constraints have been introduced by [21]. There are basically 198 two kinds of islands: finite clauses and coordinated structur</context>
</contexts>
<marker>[25]</marker>
<rawString>Willis, A. An Efficient Treatment of Quantification in Underspecified Semantic Representations. Ph.D thesis, University of York, 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Willis</author>
</authors>
<title>NP Coordination in Underspecified Scope Representations.</title>
<date>2007</date>
<booktitle>Proc. of the 7th Workshop on Computational Semantics,</booktitle>
<location>Tilburg,</location>
<contexts>
<context position="10034" citStr="[26]" startWordPosition="1539" endWordPosition="1539">ccurs. In contrast, the scope of NPs can freely rise over non-finite clauses, as shown in (5.b), where ∀x∃y is available. An example of coordinated structures acting as islands is shown in (5.c). (5.c) yields two scopings only, ∀x∃y∃z and ∃y∃z∀x, corresponding, respectively, to a reading where every student reads a own book and a own paper, and a reading where there is a single a book and a single paper that have been read by every student. (5) a. Ay student said you met everyx professor. [16] b. Ay student wants you to meet everyx professor. [16] c. Everyx student reads ay book and az paper. [26] In underspecified semantic, a standard way to deal with Island constraints of the first kind introduces special ‘blocking’ place holders, one for each tensed clause. The scope of the quantifiers in the clause is required to be always included in the scope of the place holder. In MRS, the place holder may be a handle referring to the ‘top’ of the clause. [14] implements Island constraints in an MRS-like framework. Similar alternatives have been proposed in [12] and [16]. The former implements a mechanism very close to [14], while the latter devises a feature-based framework where a feature MAX</context>
</contexts>
<marker>[26]</marker>
<rawString>Willis, A. NP Coordination in Underspecified Scope Representations. Proc. of the 7th Workshop on Computational Semantics, Tilburg, 2007.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>