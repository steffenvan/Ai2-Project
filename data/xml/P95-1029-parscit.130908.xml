<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.998432">
Using Higher-Order Logic Programming for Semantic
Interpretation of Coordinate Constructs
</title>
<author confidence="0.973786">
Seth Kulick
</author>
<affiliation confidence="0.955722">
University of Pennsylvania
Computer and Information Science
</affiliation>
<address confidence="0.9470195">
200 South 33rd Street
Philadelphia, PA 19104-6389 USA
</address>
<email confidence="0.97656">
skulickelinc.cis.upenn.edu
</email>
<sectionHeader confidence="0.996843" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999542055555556">
Many theories of semantic interpretation
use A-term manipulation to composition-
ally compute the meaning of a sentence.
These theories are usually implemented in
a language such as Prolog that can simulate
A-term operations with first-order unifica-
tion. However, for some interesting cases,
such as a Combinatory Categorial Gram-
mar account of coordination constructs,
this can only be done by obscuring the un-
derlying linguistic theory with the &amp;quot;tricks&amp;quot;
needed for implementation. This paper
shows how the use of abstract syntax per-
mitted by higher-order logic programming
allows an elegant implementation of the se-.
mantics of Combinatory Categorial Gram-
mar, including its handling of coordination
constructs.
</bodyText>
<sectionHeader confidence="0.999516" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999673862068965">
Many theories of semantic interpretation use A-term
manipulation to compositionally compute the mean-
ing of a sentence. These theories are usually imple-
mented in a language such as Prolog that can sim-
ulate A-term operations with first-order unification.
However, there are cases in which this can only be
done by obscuring the underlying linguistic theory
with the &amp;quot;tricks&amp;quot; needed for implementation. For
example, Combinatory Categorial Grammar (CCG)
(Steedman, 1990) is a theory of syntax and seman-
tic interpretation that has the attractive character-
istic of handling many coordination constructs that
other theories cannot. While many aspects of CCG
semantics can be reasonably simulated in first-order
unification, the simulation breaks down on some of
the most interesting cases that CCG can theoreti-
cally handle. The problem in general, and for CCG
in particular, is that the implementation language
does not have sufficient expressive power to allow a
more direct encoding. The solution given in this pa-
per is to show how advances in logic programming
allow the implementation of semantic theories in a
very direct and natural way, using CCG as a case
study.
We begin by briefly illustrating why first-order
unification is inadequate for some coordination con-
structs, and then review two proposed solutions.
The sentence in (la) usually has the logical form
(LF) in (lb).
</bodyText>
<listItem confidence="0.3570215">
(la) John and Bill run.
(lb) (and (run John) (run Bill))
</listItem>
<bodyText confidence="0.968280611111112">
CCG is one of several theories in which (lb) gets
derived by raising John to be the LF AP.(P john),
where P is a predicate that takes a NP as an argu-
ment to return a sentence. Likewise, Bill gets the
LF AP.(P bill), and coordination results in the fol-
lowing LF for John and Bill:
(2) AP.(and (P john) (P bill))
When (2) is applied to the predicate, (lb) will re-
sult after /3-reduction. However, under first-order
unification, this needs to simulated by having the
variable x in Ax.run(x) unify both with Bill and
John, and this is not possible. See (Jowsey, 1990)
and (Moore, 1989) for a thorough discussion.
(Moore, 1989) suggests that the way to overcome
this problem is to use explicit A-terms and encode
/3-reduction to perform the needed reduction. For
example, the logical form in (3) would be produced,
where X \run(I) is the representation of Ax.run (x).
</bodyText>
<listItem confidence="0.8887585">
(3) and(apply(nrunaLjohn),
apply(nrun(X),hill))
</listItem>
<bodyText confidence="0.999898307692308">
This would then be reduced by the clauses for apply
to result in (lb). For this small example, writing
such an apply predicate is not difficult. However,
as the semantic terms become more complex, it is
no trivial matter to write /3-reduction that will cor-
rectly handle variable capture. Also, if at some point
it was desired to determine if the semantic forms of
two different sentences were the same, a predicate
would be needed to compare two lambda forms for
a-equivalence, which again is not a simple task. Es-
sentially, the logic variable X is meant to be inter-
preted as a bound variable, which requires an addi-
tional layer of programming.
</bodyText>
<page confidence="0.998468">
213
</page>
<bodyText confidence="0.999928571428571">
(Park, 1992) proposes a solution within first-order
unification that can handle not only sentence (la),
but also more complex examples with determiners.
The method used is to introduce spurious bindings
that subsequently get removed. For example, the
semantics of (4a) would be (4b), which would then
get simplified to (4c).
</bodyText>
<listItem confidence="0.727395">
(4a) A farmer and every senator talk
</listItem>
<equation confidence="0.942950666666667">
(4b) existsai,faraer(Xl)
k(exists(12,(12=11)ktalk(12))))
kforallaBosenator(X3)
=&gt;(exists(12,(12=13)ktalk(12))))
(4c) exists(11,faraer(I1)ktalk(X1))
kforall(13,senator(13)=&gt;talk(13))
</equation>
<bodyText confidence="0.999866576923077">
While this pushes first-order unification beyond
what it had been previously shown capable of, there
are two disadvantages to this technique: (1) For ev-
ery possible category that can be conjoined, a sepa-
rate lexical entry for and is required, and (2) As the
conjoinable categories become more complex, the
and entries become correspondingly more complex
and greatly obscure the theoretical background of
the grammar formalism.
The fundamental problem in both cases is that the
concept of free and bound occurrences of variables
is not supported by Prolog, but instead needs to
be implemented by additional programming. While
theoretically possible, it becomes quite problematic
to actually implement. The solution given in this
paper is to use a higher-order logic programming
language, AProlog, that already implements these
concepts, called &amp;quot;abstract syntax&amp;quot; in (Miller, 1991)
and &amp;quot;higher-order abstract syntax&amp;quot; in (Pfenning and
Elliot, 1988). This allows a natural and elegant im-
plementation of the grammatical theory, with only
one lexical entry for and. This paper is meant to be
viewed as furthering the exploration of the utility of
higher-order logic programming for computational
linguistics - see, for example, (Miller &amp; Nadathur,
1986), (Pareschi, 1989), and (Pereira, 1990).
</bodyText>
<sectionHeader confidence="0.994357" genericHeader="introduction">
2 CCG
</sectionHeader>
<bodyText confidence="0.989812181818182">
CCG is a grammatical formalism in which there is
a one-to-one correspondence between the rules of
composition&apos; at the level of syntax and logical form.
Each word is (perhaps ambiguously) assigned a cat-
egory and LF, and when the syntactical operations
assign a new category to a constituent, the corre-
sponding semantic operations produce a new LF for
that constituent as well. The CCG rules shown in
Figure 1 are implemented in the system described
&apos;In the general sense, not specifically the CCG rule
for function composition.
</bodyText>
<table confidence="0.887966333333333">
Function Application (&gt;):
X/Y : F Y:y =&gt; X: Fy
Function Application (&lt;):
Y:y I\Y:F=&gt; X :Fy
Function Composition (&gt; B):
IIY : F Y/Z:G=&gt;I/Z: Ax.F(Gx)
Function Composition (&lt; B):
Y\Z: G X \Y : F =&gt; X \ Z : Ax.F(Gx)
Type Raising (&gt; T):
up : x =&gt; s/(a \np) : AF.Fr
Type Raising (&lt; T):
up : x =&gt; aVainp) : AF.Fx
</table>
<figureCaption confidence="0.996141">
Figure 1: CCG rules
</figureCaption>
<figure confidence="0.997160166666667">
harry found
&gt;T
S:s/(S:s\NP:harry9
(S:found&apos; npl np2\11P:npl)/NP:np2
&gt;13
S:found&apos; harry&apos; np2/11P:np2
</figure>
<figureCaption confidence="0.98678">
Figure 2: CCG derivation of harry found simulated
by first-order unification
</figureCaption>
<bodyText confidence="0.999870428571428">
in this paper.2 3 Each of the three operations have
both a forward and backward variant.
As an illustration of how the semantic rules can
be simulated in first-order unification, consider the
derivation of the constituent harry found, where
harry has the category up with LF harry&apos; and found
is a transitive verb of category (s \np)/np with LF
</bodyText>
<listItem confidence="0.393884">
(5) Aobject.Asubject.(found&apos; subject object)
</listItem>
<bodyText confidence="0.9632716">
In the CCG formalism, the derivation is as fol-
lows: harry gets raised with the &gt; T rule, and
then forward composed by the &gt; B rule with found,
and the result is a category of type sinp with LF
Az.(i ounce harry&apos; x). In section 3 it will be seen
how the use of abstract syntax allows this to be ex-
pressed directly. In first-order unification, it is sim-
ulated as shown in Figure 2.4
The final CCG rule to be considered is the coor-
dination rule that specifies that only like categories
can coordinate:
&apos;The type-raising rules shown are actually a simplifi-
cation of what has been implemented. In order to handle
determiners, a system similar to NP-complement cate-
gories as discussed in (Dowty, 1988) is used. Although
a worthwhile further demonstration of the use of ab-
stract syntax, it has been left out of this paper for space
reasons.
&apos;The \ for a backward-looking category should not
be confused with the \ for A-abstraction.
</bodyText>
<footnote confidence="0.875696">
4example adapted from (Steedman, 1990, p. 220).
</footnote>
<page confidence="0.985801">
214
</page>
<equation confidence="0.537464">
(6) X conj I =&gt;
</equation>
<bodyText confidence="0.999795166666667">
This is actually a schema for a family of rules, col-
lectively called &amp;quot;generalized coordination&amp;quot;, since the
semantic rule is different for each case.5 For exam-
ple, if X is a unary function, then the semantic rule is
(7a), and if the functions have two arguments, then
the rule is (7b).6
</bodyText>
<equation confidence="0.968962">
(7a) 1FGH = Ax.F(Gx)(Hx)
(7b) 4&apos;2FGH = Ax.Ay.F(Gxy)(Hxy)
</equation>
<bodyText confidence="0.9789305">
For example, when processing (la), rule (7a) would
be used with:
</bodyText>
<listItem confidence="0.99891">
• F = Ax.4.(andi x
• G = AP.(P john&apos;)
• H = AP.(P bill&apos;)
</listItem>
<bodyText confidence="0.816914333333333">
with the result
OFGH = Ax.(ance (x john&apos;) bi.1.1!))
which is a-equivalent to (2).
</bodyText>
<sectionHeader confidence="0.985859" genericHeader="method">
3 APROLOG and Abstract Syntax
</sectionHeader>
<bodyText confidence="0.999980842105263">
AProlog is a logic programming language based on
higher-order hereditary Harrop formulae (Miller et
al., 1991). It differs from Prolog in that first-order
terms and unification are replaced with simply-typed
A-terms and higher-order unificationr, respectively.
It also permits universal quantification and implica-
tion in the goals of clauses. The crucial aspect for
this paper is that together these features permits the
usage of abstract syntax to express the logical forms
terms computed by CCG. The built-in A-term ma-
nipulation is used as a &amp;quot;meta-language&amp;quot; in which the
&amp;quot;object-language&amp;quot; of CCG logical forms is expressed,
and variables in the object-language are mapped to
variables in the meta-language.
The AProlog code fragment shown in Figure 3 de-
clares how the CCG logical forms are represented.
Each CCG LF is represented as an untyped A-term,
namely type ta. abs represents object-level abstrac-
tion Ax.M by the meta-level expression (abs X),
</bodyText>
<tableCaption confidence="0.7536608">
6It is not established if this schema should actually
produce an unbounded family of rules. See (Weir, 1988)
and (Weir and Joshi, 1988) for a discussion of the im-
plications for automata-theoretic power of generalized
coordination and composition, and (Gazdar, 1988) for
linguistic arguments that languages like Dutch may re-
quire this power, and (Steedman, 1990) for some further
discussion of the issue. In this paper we use the general-
ized rule to illustrate the elegance of the representation,
but it is an easy change to implement a bounded coor-
dination rule.
6The 4) notation is used because of the combina-
tory logic background of CCG. See (Steedman, 1990)
for details.
&apos;defined as the unification of simply typed A-terms,
</tableCaption>
<table confidence="0.689155625">
modulo conversion.
kind tin type.
type abs (ta —&gt; ta) —&gt; tm.
type app ta —&gt; ta —&gt; ta.
type torah l (ta —&gt; ta) —&gt; ta.
type exists (ta —&gt; ta) —&gt; tn.
type &gt;&gt; ta —&gt; ta —&gt; ta.
type kk ta —&gt; ta —&gt; ta.
</table>
<figureCaption confidence="0.8619005">
Figure 3: Declarations for AProlog representation of
CCG logical forms
</figureCaption>
<bodyText confidence="0.991430717391305">
where N is a meta-level function of type ta tat.
A meta-level A-abstraction Ay.P is written y \P.5
Thus, if walked&apos; has type tat ta, then
A(walkedi y) is a AProlog (meta-level) function
with type tat -+ ta, and (abs y\(walkedi y)) is the
object-level representation, with type ta. The LF
for found shown in (5) would be represented as
(abs obj\(abs subVfoundi sub obj))). app en-
codes application, and so in the derivation of harry
found, the type-raised harry has the AProlog value
(abs Wapp p harry&apos;)).9
The second part of Figure 3 shows declares how
quantifiers are represented, which are required since
the sentences to be processed may have determiners.
torah l and exists are encoded similarly to abstrac-
tion, in that they take a functional argument and
so object-level binding of variables by quantifiers is
handled by meta-level A-abstraction. &gt;&gt; and kk are
simple constructors for implication and conjunction,
to be used with forall and exists respectively, in
the typical manner (Pereira and Shieber, 1987). For
example, the sentence every man found a bone has as
a possible LF (8a), with the AProlog representation
(8b)15:
&apos;This is the same syntax for A-abstraction as in
(3). (Moore, 1989) in fact borrows the notation for A-
abstraction from AProlog. The difference, of course, is
that here the abstraction is a meta-level, built-in con-
struct, while in (3) the interpretation is dependent on an
extra layer of programming. Bound variables in AProlog
can be either upper or lower case, since they are not logic
variables, and will be written in lower case in this paper.
6It is possible to represent the logical forms at the
object-level without using abs and app, so that harry
could be simply p\ (p harry&apos;). The original implemen-
tation of this system was in fact done in this manner.
Space prohibits a full explanation, but essentially the
fact that AProlog is a typed language leads to a good
deal of formal clutter if this method is used.
16The LF for the determiner has the form of a Mon-
tagovian generalized quantifier, giving rise to one fully
scoped logical form for the sentence. It should be
stressed that this particular kind of LF is assumed here
purely for the sake of illustration, to make the point that
composition at the level of derivation and LF are one-
to-one. Section 4 contains an example for which such a
</bodyText>
<page confidence="0.988414">
215
</page>
<table confidence="0.743734875">
type apply tm -&gt; tm -&gt; tm -&gt; o. kind cat type.
type compose tm -&gt; tm -&gt; tm -&gt; o. type is cat -&gt; cat -&gt; cat.
type raise tm -&gt; tm -&gt; o. type be cat -&gt; cat -&gt; cat.
apply (abs R) S (R S). type up cat.
compose (abs F) (abs G) (abs x\(F (G x))). type a cat.
raise Tm (abs P\(app P Tm)). type conj cat.
Figure 4: AProlog implementation of CCG logical type noun cat.
form operations type atomic-type cat -&gt; o.
</table>
<equation confidence="0.5033184">
(8a) 3x.((bonel x) A Vy.((man&apos; (found&apos; y x)))
(8b) (exists x\
((bone&apos; x) kk
(toren xl\
((man&apos; xl) &gt;&gt; (found&apos; xl x)))))
</equation>
<bodyText confidence="0.97440505">
Figure 4 illustrates how directly the CCG opera-
tions can be encodedll. o is the type of a meta-level
proposition, and so the intended usage of apply is
to take three arguments of type tm, where the first
should be an object-level A-abstraction, and set the
third equal to the application of the first to the sec-
ond. Thus, for the query
?- apply (abs sub\(walked&apos; sub)) harry&apos; X.
R unifies with the tm tm function
sub\(walked&apos; sub), S with harry&apos; and M with (R
S), the meta-level application of R to S, which by the
built-in /3-reduction is (walked&apos; harry&apos;). In other
words, object-level function application is handled
simply by the meta-level function application.
Function composition is similar. Consider
again the derivation of harry found by type-
raising and forward composition. harry would
get type-raised by the raise clause to produce
(abs pVapp p harry&apos;)), and then composed with
found, with the result shown in the following query:
</bodyText>
<figure confidence="0.453848777777778">
7- compose (abs p\(app p harry&apos;))
(abs obj\
(abs sub\
(found&apos; sub obj)))
M.
X = (abs x\
(app
(abs sub\(found&apos; sub x))
harry&apos;)).
</figure>
<tableCaption confidence="0.2759218">
derivation fails to yield all available quantifier scopings.
We do not address here the further question of how the
remaining scoped readings are derived. Alternatives that
appear compatible with the present approach are quanti-
fier movement (Hobbs &amp; Shieber, 1987), type-raising at
LF (Partee &amp; Rooth, 1983), or the use of disambiguated
quantifers in the derivation itself (Park, 1995).
There are other clauses, not shown here, that deter-
mine the direction of the CCG rule. For either direction,
however, the semantics are the same and both directional
rules call these clauses for the semantic computation.
atomic-type up.
atomic-type s.
atomic-type conj.
atomic-type noun.
</tableCaption>
<figureCaption confidence="0.9053575">
Figure 5: Implementation of the CCG category sys-
tem
</figureCaption>
<bodyText confidence="0.999145923076923">
At this point a further )6-reduction is needed. Note
however this is not at all the same problem of
writing a /3-reducer in Prolog. Instead it is a
simple matter of using the meta-level /3-reduction
to eliminate /3-redexes to produce the final result
(abs xViound&apos; harry x)). We won&apos;t show the
complete declaration of the /3-reducer, but the key
clause is simply:
red (app (abs X) 11) CM N).
Thus, using the abstract syntax capabilities of
AProlog, we can have a direct implementation of the
underlying linguistic formalism, in stark contrast to
the first-order simulation shown in Figure 2.
</bodyText>
<sectionHeader confidence="0.944697" genericHeader="method">
4 Implementation of Coordination
</sectionHeader>
<bodyText confidence="0.999973904761905">
A primary goal of abstract-syntax is to support re-
cursion through abstractions with bound variables.
This leads to the interpretation of a bound variable
as a &amp;quot;scoped constant&amp;quot; - it acts like a constant that
is not visible from the top of the term, but which
becomes visible during the descent through the ab-
straction. See (Miller, 1991) for a discussion of how
this may be used for evaluation of functional pro-
grams by &amp;quot;pushing&amp;quot; the evaluation through abstrac-
tions to reduce redexes that are not at the top-level.
This technique is also used in the /3-reducer briefly
mentioned at the end of the previous section, and
a similar technique will be used here to implement
coordination by recursively descending through the
two arguments to be coordinated.
Before describing the implementation of coordi-
nation, it is first necessary to mention how CCG
categories are represented in the AProlog code. As
shown in Figure 5, cat is declared to be a primi-
tive type, and up, s, conj, noun are the categories
used in this implementation. is and bs are declared
</bodyText>
<page confidence="0.998069">
216
</page>
<figure confidence="0.851475857142857">
type coord
cat -&gt; tm -&gt; tm -&gt; tm -&gt; o.
coord (is A B) (abs R) (abs S) (abs T) :-
pi x\ (coord B (It k) (S x) (T x)).
coord (ba A B) (abs R) (abs S) (abs T) :-
pi x\ (coord B CR x) (S x) (T x)).
coord B R S (and&apos; R S) atomic-type B.
</figure>
<figureCaption confidence="0.99992">
Figure 6: Implementation of coordination
</figureCaption>
<bodyText confidence="0.999252114285714">
to be constructors for forward and backward slash.
For example, the CCG category for a transitive verb
(s \up)/np would be represented as (is up (be up
s)). Also, the predicate atomic-type is declared to
be true for the four atomic categories. This will be
used in the implementation of coordination as a test
for termination of the recursion.
The implementation of coordination crucially uses
the capability of AProlog for universal quantification
in the goal of a clause. pi is the meta-level operator
for V, and Vx.M is written as pi x\M. The oper-
ational semantics for AProlog state that pi x \ G is
provable if and only if [c/x]G is provable, where c is
a new variable of the same type as x that does not
otherwise occur in the current signature. In other
words, c is a scoped constant and the current signa-
ture gets expanded with c for the proof of [c/x]G.
Since c is meant to be treated as a generic place-
holder for any arbitrary x of the proper type, c must
not appear in any terms instantiated for logic vari-
ables during the proof of [c/x]G. The significance of
this restriction will be illustrated shortly.
The code for coordination is shown in Figure
6. The four arguments to coord are a category
and three terms that are the object-level LF rep-
resentations of constituents of that category. The
last argument will result from the coordination of
the second and third arguments. Consider again
the earlier problematic example (la) of coordina-
tion. Recall that after john is type-raised, its LF
will be (abs p\(app p john&apos;)) and similarly for bill.
They will both have the category (is (be up s)
s). Thus, to obtain the LF for John and Bill, the
following query would be made:
coord (is (be up s) s)
</bodyText>
<subsectionHeader confidence="0.641654333333333">
(abs p\(app p john&apos;))
(abs p\(app p bill&apos;))
N.
</subsectionHeader>
<bodyText confidence="0.990134">
This will match with the first clause for coord, with
</bodyText>
<listItem confidence="0.999856">
• A instantiated to (be up s)
• B to s
• R to (p\(app p john&apos;))
• S to (p\(app p bill&apos;))
• and T a logic variable waiting instantiation.
</listItem>
<bodyText confidence="0.97972">
Then, after the meta-level /3-reduction using the new
scoped constant c, the following goal is called:
coord s (app c john&apos;) (app c bill&apos;) N.
where I = (T c). Since a is an atomic type, the
third coord clause matches with
</bodyText>
<listItem confidence="0.99939225">
• B instantiated to s
• R to (app c john&apos;)
• S to (app c bill&apos;)
• Ito (and&apos; (app c john&apos;) (app c bill&apos;))
</listItem>
<bodyText confidence="0.938368666666667">
Since I (T c), higher-order unification is used by
AProlog to instantiate T by extracting c from I with
the result
T = x \ (and&apos; (app x john&apos;) (app x
and so 11 from the original query is
(abs x \ (and&apos; (app x john&apos;) (app x bill&apos;)))
Note that since c is a scoped constant arising from
the proof of an universal quantification, the instan-
tiation
</bodyText>
<equation confidence="0.944266">
T = x \ (and&apos; (app c john&apos;) (app x
</equation>
<bodyText confidence="0.7940693125">
is prohibited, along with the other extractions that
do not remove c from the body of the abstraction.
This use of universal quantification to extract out
c from a term containing c in this case gives the same
result as a direct implementation of the rule for coo-
ordination of unary functions (7a) would. However,
this same process of recursive descent via scoped
constants will work for any member of the conj rule
family. For example, the following query
coord
(is up (bs up a))
(abs obj\(abs sub\(like&apos; sub obj)))
(abs obj\(abs sub\(hate&apos; sub obj)))
K.
= (abs x\
(abs xl\
(and&apos; (like&apos; xi x)
(hate&apos; xl x)))).
corresponds to rule (7b). Note also that the use
of the same bound variable names obj and sub
causes no difficulty since the use of scoped-constants,
meta-level /3-reduction, and higher-order unification
is used to access and manipulate the inner terms.
Also, whereas (Park, 1992) requires careful consider-
ation of handling of determiners with coordination,
here such sentences are handled just like any others.
For example, the sentence Mary gave every dog a
bone and some policeman a flower results in the LF
12.
&amp;quot;This is a case in which the particular LF assumed
here fails to yield another available scoping. See foot-
note 10.
</bodyText>
<page confidence="0.990393">
217
</page>
<table confidence="0.889745">
(and&apos;
(exists x\((bone&apos; x) tic
(forall xl\((dog&apos; xl)
&gt;&gt; (gave&apos; mary&apos; x x1)))))
(exists x\((flower&apos; x)
(exists x1\((policeman&apos; x1)
at (gave&apos; nary&apos; x x1))))))
</table>
<bodyText confidence="0.999221333333333">
Thus, &amp;quot;generalized coordination&amp;quot;, instead of being a
family of separate rules, can be expressed as a sin-
gle rule on recursive descent through logical forms.
(Steedman, 1990) also discusses &amp;quot;generalized com-
position&amp;quot;, and it may well be that a similar imple-
mentation is possible for that family of rules as well.
</bodyText>
<sectionHeader confidence="0.998865" genericHeader="conclusions">
5 Conclusion
</sectionHeader>
<bodyText confidence="0.99995905">
We have shown how higher-order logic programming
can be used to elegantly implement the semantic the-
ory of CCG, including the previously difficult case
of its handling of coordination constructs. The tech-
niques used here should allow similar advantages for
a variety of such theories.
An argument can be made that the approach
taken here relies on a formalism that entails im-
plementation issues that are more difficult than for
the other solutions and inherently not as efficient.
However, the implementation issues, although more
complex, are also well-understood and it can be ex-
pected that future work will bring further improve-
ments. For example, it is a straightforward matter
to transform the AProlog code into a logic called LA
(Miller, 1990) which requires only a restricted form
of unification that is decidable in linear time and
space. Also, the declarative nature of AProlog pro-
grams opens up the possibility for applications of
program transformations such as partial evaluation.
</bodyText>
<sectionHeader confidence="0.999438" genericHeader="acknowledgments">
6 Acknowledgments
</sectionHeader>
<bodyText confidence="0.999517666666667">
This work is supported by ARO grant DAAL03-89-
0031, DARPA grant N00014-904-1863, and ARO
grant DAAH04-94-G-0426. I would like to thank
Aravind Joshi, Dale Miller, Jong Park, and Mark
Steedman for valuable discussions and comments on
earlier drafts.
</bodyText>
<sectionHeader confidence="0.99897" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.99978078125">
David Dowty. 1988. Type raising, functional com-
position, and non-constituent conjunction. In
Richard T. Oehrle, Emmon Bach, and Deirdre
Wheeler, editors, Cat egorial Grammars and Natu-
ral Language Structures. R,eidel, Dordrecht, pages
153-198.
Gerald Gazdar. 1988. Applicability of indexed
grammars to natural languages. In U. Reyle and
C. Rohrer, editors, Natural language parsing and
linguistic theories. Reidel, Dordrecht, pages 69-94.
Jerry R. Hobbs and Stuart M. Shieber. 1987. An al-
gorithm for generating quantifier scopings. Com-
putational Linguistics, 13:47-63.
Einar Jowsey. 1990. Constraining Montague Gram-
mar for Computational Applications. PhD thesis,
University of Edinburgh.
Dale Miller. 1990. A logic programming language
with lambda abstraction, function variables and
simple unification. In P. Schroeder-Heister, ed-
itor, Extensions of Logic Programming, Lecture
Notes in Artifical Intelligence, Springer-Verlag,
1990.
Dale Miller. 1991. Abstract syntax and logic pro-
gramming. In Proceedings of the Second Rus-
sian Conference on Logic Programming, Septem-
ber 1991.
Dale Miller and Gopalan Nadathur. 1986. Some
uses of higher-order logic in computational linguis-
tics. In 24th Annual Meeting of the Association
for Computational Linguistics, pages 247-255.
Dale Miller, Gopalan Nadathur, Frank Pfenning,
Andre Scedrov. 1991. Uniform proofs as a foun-
dation for logic programming. In Annals of Pure
and Applied Logic, 51:125-157.
Robert C. Moore. 1989. Unification-based seman-
tic interpretation. In 27th Annual Meeting of the
Association for Computational Linguistics, pages
33-41.
Remo Pareschi. 1989. Type-Driven Natural Lan-
guage Aanalysis. PhD thesis, University of Edin-
burgh.
Jong C. Park. 1992. A unification-based semantic
interpretation for coordinate constructs. In 30th
Annual Meeting of the Association for Computa-
tional Linguistics, pages 209-215.
Jong C. Park. 1995. Quantifier scope and con-
stituency. In 33rd Annual Meeting of the Associa-
tion for Computational Linguistics (this volume).
Barbara Partee and Mats Rooth. 1983. General-
ized conjunction and type ambiguity. In Rainer
Bauerle, Christoph Schwarze, and Arnim von Ste-
chow, editors, Meaning, Use, and Interpretation
of Language. W. de Gruyter, Berlin, pages 361-
383.
Fernando C.N. Pereira. 1990. Semantic interpre-
tation as higher-order deduction. In Jan van
Eijck, editor, Logics in AI: European Workshop
JELIA&apos;90, Lecture Notes in Artificial Intelligence
number 478, pages 78-96. Springer-Verlag, Berlin,
Germany.
Fernando C.N. Pereira and Stuart M. Shieber. 1987.
Prolog and Natural-Language Analysis. Number
10 in CSLI Lecture Notes. Center for the Study of
Language and Information, Stanford, California,
</reference>
<page confidence="0.980856">
218
</page>
<reference confidence="0.994076529411765">
1985. Distributed by the University of Chicago
Press.
Frank Pfenning and Conal Elliot. 1988. Higher-
order abstract syntax. In Proceedings of the ACM-
SIGPLAN Conference on Programming Language
Design and Implementation, 1988.
Mark J. Steedman. 1990. Gapping as constituent
coordination. In Linguistics and Philosophy 13,
pages 207-263
David Weir. 1988. Characterizing Mildly Context-
sensitive Grammar Formalism. CIS-88-74, PhD
thesis, University of Pennsylvania.
David Weir and Aravind doshi. 1988. Combina-
tory categorial grammars: generative power and
relation to linear CF rewriting systems. In 261h
Annual Meeting of the Association for Computa-
tional Linguistics, pages 278-285.
</reference>
<page confidence="0.999214">
219
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.840880">
<title confidence="0.9996855">Using Higher-Order Logic Programming for Semantic Interpretation of Coordinate Constructs</title>
<author confidence="0.999989">Seth Kulick</author>
<affiliation confidence="0.9763295">University of Pennsylvania Computer and Information Science</affiliation>
<address confidence="0.995111">200 South 33rd Street Philadelphia, PA 19104-6389 USA</address>
<email confidence="0.999875">skulickelinc.cis.upenn.edu</email>
<abstract confidence="0.991163736842105">Many theories of semantic interpretation use A-term manipulation to compositionally compute the meaning of a sentence. These theories are usually implemented in a language such as Prolog that can simulate A-term operations with first-order unification. However, for some interesting cases, such as a Combinatory Categorial Grammar account of coordination constructs, this can only be done by obscuring the underlying linguistic theory with the &amp;quot;tricks&amp;quot; needed for implementation. This paper shows how the use of abstract syntax permitted by higher-order logic programming allows an elegant implementation of the se-. mantics of Combinatory Categorial Grammar, including its handling of coordination constructs.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>David Dowty</author>
</authors>
<title>Type raising, functional composition, and non-constituent conjunction.</title>
<date>1988</date>
<booktitle>Cat egorial Grammars and Natural Language Structures.</booktitle>
<pages>153--198</pages>
<editor>In Richard T. Oehrle, Emmon Bach, and Deirdre Wheeler, editors,</editor>
<location>R,eidel, Dordrecht,</location>
<contexts>
<context position="7923" citStr="Dowty, 1988" startWordPosition="1261" endWordPosition="1262">rule, and then forward composed by the &gt; B rule with found, and the result is a category of type sinp with LF Az.(i ounce harry&apos; x). In section 3 it will be seen how the use of abstract syntax allows this to be expressed directly. In first-order unification, it is simulated as shown in Figure 2.4 The final CCG rule to be considered is the coordination rule that specifies that only like categories can coordinate: &apos;The type-raising rules shown are actually a simplification of what has been implemented. In order to handle determiners, a system similar to NP-complement categories as discussed in (Dowty, 1988) is used. Although a worthwhile further demonstration of the use of abstract syntax, it has been left out of this paper for space reasons. &apos;The \ for a backward-looking category should not be confused with the \ for A-abstraction. 4example adapted from (Steedman, 1990, p. 220). 214 (6) X conj I =&gt; This is actually a schema for a family of rules, collectively called &amp;quot;generalized coordination&amp;quot;, since the semantic rule is different for each case.5 For example, if X is a unary function, then the semantic rule is (7a), and if the functions have two arguments, then the rule is (7b).6 (7a) 1FGH = Ax.</context>
</contexts>
<marker>Dowty, 1988</marker>
<rawString>David Dowty. 1988. Type raising, functional composition, and non-constituent conjunction. In Richard T. Oehrle, Emmon Bach, and Deirdre Wheeler, editors, Cat egorial Grammars and Natural Language Structures. R,eidel, Dordrecht, pages 153-198.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gerald Gazdar</author>
</authors>
<title>Applicability of indexed grammars to natural languages.</title>
<date>1988</date>
<pages>69--94</pages>
<editor>In U. Reyle and C. Rohrer, editors,</editor>
<location>Reidel, Dordrecht,</location>
<contexts>
<context position="10017" citStr="Gazdar, 1988" startWordPosition="1606" endWordPosition="1607"> forms is expressed, and variables in the object-language are mapped to variables in the meta-language. The AProlog code fragment shown in Figure 3 declares how the CCG logical forms are represented. Each CCG LF is represented as an untyped A-term, namely type ta. abs represents object-level abstraction Ax.M by the meta-level expression (abs X), 6It is not established if this schema should actually produce an unbounded family of rules. See (Weir, 1988) and (Weir and Joshi, 1988) for a discussion of the implications for automata-theoretic power of generalized coordination and composition, and (Gazdar, 1988) for linguistic arguments that languages like Dutch may require this power, and (Steedman, 1990) for some further discussion of the issue. In this paper we use the generalized rule to illustrate the elegance of the representation, but it is an easy change to implement a bounded coordination rule. 6The 4) notation is used because of the combinatory logic background of CCG. See (Steedman, 1990) for details. &apos;defined as the unification of simply typed A-terms, modulo conversion. kind tin type. type abs (ta —&gt; ta) —&gt; tm. type app ta —&gt; ta —&gt; ta. type torah l (ta —&gt; ta) —&gt; ta. type exists (ta —&gt; ta</context>
</contexts>
<marker>Gazdar, 1988</marker>
<rawString>Gerald Gazdar. 1988. Applicability of indexed grammars to natural languages. In U. Reyle and C. Rohrer, editors, Natural language parsing and linguistic theories. Reidel, Dordrecht, pages 69-94.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jerry R Hobbs</author>
<author>Stuart M Shieber</author>
</authors>
<title>An algorithm for generating quantifier scopings.</title>
<date>1987</date>
<journal>Computational Linguistics,</journal>
<pages>13--47</pages>
<contexts>
<context position="14939" citStr="Hobbs &amp; Shieber, 1987" startWordPosition="2476" endWordPosition="2479">n the derivation of harry found by typeraising and forward composition. harry would get type-raised by the raise clause to produce (abs pVapp p harry&apos;)), and then composed with found, with the result shown in the following query: 7- compose (abs p\(app p harry&apos;)) (abs obj\ (abs sub\ (found&apos; sub obj))) M. X = (abs x\ (app (abs sub\(found&apos; sub x)) harry&apos;)). derivation fails to yield all available quantifier scopings. We do not address here the further question of how the remaining scoped readings are derived. Alternatives that appear compatible with the present approach are quantifier movement (Hobbs &amp; Shieber, 1987), type-raising at LF (Partee &amp; Rooth, 1983), or the use of disambiguated quantifers in the derivation itself (Park, 1995). There are other clauses, not shown here, that determine the direction of the CCG rule. For either direction, however, the semantics are the same and both directional rules call these clauses for the semantic computation. atomic-type up. atomic-type s. atomic-type conj. atomic-type noun. Figure 5: Implementation of the CCG category system At this point a further )6-reduction is needed. Note however this is not at all the same problem of writing a /3-reducer in Prolog. Inste</context>
</contexts>
<marker>Hobbs, Shieber, 1987</marker>
<rawString>Jerry R. Hobbs and Stuart M. Shieber. 1987. An algorithm for generating quantifier scopings. Computational Linguistics, 13:47-63.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Einar Jowsey</author>
</authors>
<title>Constraining Montague Grammar for Computational Applications.</title>
<date>1990</date>
<tech>PhD thesis,</tech>
<institution>University of Edinburgh.</institution>
<contexts>
<context position="2975" citStr="Jowsey, 1990" startWordPosition="465" endWordPosition="466">hn and Bill run. (lb) (and (run John) (run Bill)) CCG is one of several theories in which (lb) gets derived by raising John to be the LF AP.(P john), where P is a predicate that takes a NP as an argument to return a sentence. Likewise, Bill gets the LF AP.(P bill), and coordination results in the following LF for John and Bill: (2) AP.(and (P john) (P bill)) When (2) is applied to the predicate, (lb) will result after /3-reduction. However, under first-order unification, this needs to simulated by having the variable x in Ax.run(x) unify both with Bill and John, and this is not possible. See (Jowsey, 1990) and (Moore, 1989) for a thorough discussion. (Moore, 1989) suggests that the way to overcome this problem is to use explicit A-terms and encode /3-reduction to perform the needed reduction. For example, the logical form in (3) would be produced, where X \run(I) is the representation of Ax.run (x). (3) and(apply(nrunaLjohn), apply(nrun(X),hill)) This would then be reduced by the clauses for apply to result in (lb). For this small example, writing such an apply predicate is not difficult. However, as the semantic terms become more complex, it is no trivial matter to write /3-reduction that will</context>
</contexts>
<marker>Jowsey, 1990</marker>
<rawString>Einar Jowsey. 1990. Constraining Montague Grammar for Computational Applications. PhD thesis, University of Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dale Miller</author>
</authors>
<title>A logic programming language with lambda abstraction, function variables and simple unification.</title>
<date>1990</date>
<booktitle>Extensions of Logic Programming, Lecture Notes in Artifical Intelligence,</booktitle>
<editor>In P. Schroeder-Heister, editor,</editor>
<publisher>Springer-Verlag,</publisher>
<marker>Miller, 1990</marker>
<rawString>Dale Miller. 1990. A logic programming language with lambda abstraction, function variables and simple unification. In P. Schroeder-Heister, editor, Extensions of Logic Programming, Lecture Notes in Artifical Intelligence, Springer-Verlag, 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dale Miller</author>
</authors>
<title>Abstract syntax and logic programming.</title>
<date>1991</date>
<booktitle>In Proceedings of the Second Russian Conference on Logic Programming,</booktitle>
<contexts>
<context position="5394" citStr="Miller, 1991" startWordPosition="829" endWordPosition="830">able categories become more complex, the and entries become correspondingly more complex and greatly obscure the theoretical background of the grammar formalism. The fundamental problem in both cases is that the concept of free and bound occurrences of variables is not supported by Prolog, but instead needs to be implemented by additional programming. While theoretically possible, it becomes quite problematic to actually implement. The solution given in this paper is to use a higher-order logic programming language, AProlog, that already implements these concepts, called &amp;quot;abstract syntax&amp;quot; in (Miller, 1991) and &amp;quot;higher-order abstract syntax&amp;quot; in (Pfenning and Elliot, 1988). This allows a natural and elegant implementation of the grammatical theory, with only one lexical entry for and. This paper is meant to be viewed as furthering the exploration of the utility of higher-order logic programming for computational linguistics - see, for example, (Miller &amp; Nadathur, 1986), (Pareschi, 1989), and (Pereira, 1990). 2 CCG CCG is a grammatical formalism in which there is a one-to-one correspondence between the rules of composition&apos; at the level of syntax and logical form. Each word is (perhaps ambiguously</context>
<context position="16364" citStr="Miller, 1991" startWordPosition="2711" endWordPosition="2712">use is simply: red (app (abs X) 11) CM N). Thus, using the abstract syntax capabilities of AProlog, we can have a direct implementation of the underlying linguistic formalism, in stark contrast to the first-order simulation shown in Figure 2. 4 Implementation of Coordination A primary goal of abstract-syntax is to support recursion through abstractions with bound variables. This leads to the interpretation of a bound variable as a &amp;quot;scoped constant&amp;quot; - it acts like a constant that is not visible from the top of the term, but which becomes visible during the descent through the abstraction. See (Miller, 1991) for a discussion of how this may be used for evaluation of functional programs by &amp;quot;pushing&amp;quot; the evaluation through abstractions to reduce redexes that are not at the top-level. This technique is also used in the /3-reducer briefly mentioned at the end of the previous section, and a similar technique will be used here to implement coordination by recursively descending through the two arguments to be coordinated. Before describing the implementation of coordination, it is first necessary to mention how CCG categories are represented in the AProlog code. As shown in Figure 5, cat is declared to</context>
</contexts>
<marker>Miller, 1991</marker>
<rawString>Dale Miller. 1991. Abstract syntax and logic programming. In Proceedings of the Second Russian Conference on Logic Programming, September 1991.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dale Miller</author>
<author>Gopalan Nadathur</author>
</authors>
<title>Some uses of higher-order logic in computational linguistics.</title>
<date>1986</date>
<booktitle>In 24th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>247--255</pages>
<contexts>
<context position="5762" citStr="Miller &amp; Nadathur, 1986" startWordPosition="884" endWordPosition="887">le theoretically possible, it becomes quite problematic to actually implement. The solution given in this paper is to use a higher-order logic programming language, AProlog, that already implements these concepts, called &amp;quot;abstract syntax&amp;quot; in (Miller, 1991) and &amp;quot;higher-order abstract syntax&amp;quot; in (Pfenning and Elliot, 1988). This allows a natural and elegant implementation of the grammatical theory, with only one lexical entry for and. This paper is meant to be viewed as furthering the exploration of the utility of higher-order logic programming for computational linguistics - see, for example, (Miller &amp; Nadathur, 1986), (Pareschi, 1989), and (Pereira, 1990). 2 CCG CCG is a grammatical formalism in which there is a one-to-one correspondence between the rules of composition&apos; at the level of syntax and logical form. Each word is (perhaps ambiguously) assigned a category and LF, and when the syntactical operations assign a new category to a constituent, the corresponding semantic operations produce a new LF for that constituent as well. The CCG rules shown in Figure 1 are implemented in the system described &apos;In the general sense, not specifically the CCG rule for function composition. Function Application (&gt;): </context>
</contexts>
<marker>Miller, Nadathur, 1986</marker>
<rawString>Dale Miller and Gopalan Nadathur. 1986. Some uses of higher-order logic in computational linguistics. In 24th Annual Meeting of the Association for Computational Linguistics, pages 247-255.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dale Miller</author>
<author>Gopalan Nadathur</author>
<author>Frank Pfenning</author>
<author>Andre Scedrov</author>
</authors>
<title>Uniform proofs as a foundation for logic programming.</title>
<date>1991</date>
<booktitle>In Annals of Pure and Applied Logic,</booktitle>
<pages>51--125</pages>
<contexts>
<context position="8909" citStr="Miller et al., 1991" startWordPosition="1432" endWordPosition="1435">d &amp;quot;generalized coordination&amp;quot;, since the semantic rule is different for each case.5 For example, if X is a unary function, then the semantic rule is (7a), and if the functions have two arguments, then the rule is (7b).6 (7a) 1FGH = Ax.F(Gx)(Hx) (7b) 4&apos;2FGH = Ax.Ay.F(Gxy)(Hxy) For example, when processing (la), rule (7a) would be used with: • F = Ax.4.(andi x • G = AP.(P john&apos;) • H = AP.(P bill&apos;) with the result OFGH = Ax.(ance (x john&apos;) bi.1.1!)) which is a-equivalent to (2). 3 APROLOG and Abstract Syntax AProlog is a logic programming language based on higher-order hereditary Harrop formulae (Miller et al., 1991). It differs from Prolog in that first-order terms and unification are replaced with simply-typed A-terms and higher-order unificationr, respectively. It also permits universal quantification and implication in the goals of clauses. The crucial aspect for this paper is that together these features permits the usage of abstract syntax to express the logical forms terms computed by CCG. The built-in A-term manipulation is used as a &amp;quot;meta-language&amp;quot; in which the &amp;quot;object-language&amp;quot; of CCG logical forms is expressed, and variables in the object-language are mapped to variables in the meta-language. T</context>
</contexts>
<marker>Miller, Nadathur, Pfenning, Scedrov, 1991</marker>
<rawString>Dale Miller, Gopalan Nadathur, Frank Pfenning, Andre Scedrov. 1991. Uniform proofs as a foundation for logic programming. In Annals of Pure and Applied Logic, 51:125-157.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert C Moore</author>
</authors>
<title>Unification-based semantic interpretation.</title>
<date>1989</date>
<booktitle>In 27th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>33--41</pages>
<contexts>
<context position="2993" citStr="Moore, 1989" startWordPosition="468" endWordPosition="469">b) (and (run John) (run Bill)) CCG is one of several theories in which (lb) gets derived by raising John to be the LF AP.(P john), where P is a predicate that takes a NP as an argument to return a sentence. Likewise, Bill gets the LF AP.(P bill), and coordination results in the following LF for John and Bill: (2) AP.(and (P john) (P bill)) When (2) is applied to the predicate, (lb) will result after /3-reduction. However, under first-order unification, this needs to simulated by having the variable x in Ax.run(x) unify both with Bill and John, and this is not possible. See (Jowsey, 1990) and (Moore, 1989) for a thorough discussion. (Moore, 1989) suggests that the way to overcome this problem is to use explicit A-terms and encode /3-reduction to perform the needed reduction. For example, the logical form in (3) would be produced, where X \run(I) is the representation of Ax.run (x). (3) and(apply(nrunaLjohn), apply(nrun(X),hill)) This would then be reduced by the clauses for apply to result in (lb). For this small example, writing such an apply predicate is not difficult. However, as the semantic terms become more complex, it is no trivial matter to write /3-reduction that will correctly handle </context>
<context position="11945" citStr="Moore, 1989" startWordPosition="1942" endWordPosition="1943">re required since the sentences to be processed may have determiners. torah l and exists are encoded similarly to abstraction, in that they take a functional argument and so object-level binding of variables by quantifiers is handled by meta-level A-abstraction. &gt;&gt; and kk are simple constructors for implication and conjunction, to be used with forall and exists respectively, in the typical manner (Pereira and Shieber, 1987). For example, the sentence every man found a bone has as a possible LF (8a), with the AProlog representation (8b)15: &apos;This is the same syntax for A-abstraction as in (3). (Moore, 1989) in fact borrows the notation for Aabstraction from AProlog. The difference, of course, is that here the abstraction is a meta-level, built-in construct, while in (3) the interpretation is dependent on an extra layer of programming. Bound variables in AProlog can be either upper or lower case, since they are not logic variables, and will be written in lower case in this paper. 6It is possible to represent the logical forms at the object-level without using abs and app, so that harry could be simply p\ (p harry&apos;). The original implementation of this system was in fact done in this manner. Space</context>
</contexts>
<marker>Moore, 1989</marker>
<rawString>Robert C. Moore. 1989. Unification-based semantic interpretation. In 27th Annual Meeting of the Association for Computational Linguistics, pages 33-41.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Remo Pareschi</author>
</authors>
<title>Type-Driven Natural Language Aanalysis.</title>
<date>1989</date>
<tech>PhD thesis,</tech>
<institution>University of Edinburgh.</institution>
<contexts>
<context position="5780" citStr="Pareschi, 1989" startWordPosition="888" endWordPosition="889">it becomes quite problematic to actually implement. The solution given in this paper is to use a higher-order logic programming language, AProlog, that already implements these concepts, called &amp;quot;abstract syntax&amp;quot; in (Miller, 1991) and &amp;quot;higher-order abstract syntax&amp;quot; in (Pfenning and Elliot, 1988). This allows a natural and elegant implementation of the grammatical theory, with only one lexical entry for and. This paper is meant to be viewed as furthering the exploration of the utility of higher-order logic programming for computational linguistics - see, for example, (Miller &amp; Nadathur, 1986), (Pareschi, 1989), and (Pereira, 1990). 2 CCG CCG is a grammatical formalism in which there is a one-to-one correspondence between the rules of composition&apos; at the level of syntax and logical form. Each word is (perhaps ambiguously) assigned a category and LF, and when the syntactical operations assign a new category to a constituent, the corresponding semantic operations produce a new LF for that constituent as well. The CCG rules shown in Figure 1 are implemented in the system described &apos;In the general sense, not specifically the CCG rule for function composition. Function Application (&gt;): X/Y : F Y:y =&gt; X: </context>
</contexts>
<marker>Pareschi, 1989</marker>
<rawString>Remo Pareschi. 1989. Type-Driven Natural Language Aanalysis. PhD thesis, University of Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jong C Park</author>
</authors>
<title>A unification-based semantic interpretation for coordinate constructs.</title>
<date>1992</date>
<booktitle>In 30th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>209--215</pages>
<contexts>
<context position="3984" citStr="Park, 1992" startWordPosition="633" endWordPosition="634">y to result in (lb). For this small example, writing such an apply predicate is not difficult. However, as the semantic terms become more complex, it is no trivial matter to write /3-reduction that will correctly handle variable capture. Also, if at some point it was desired to determine if the semantic forms of two different sentences were the same, a predicate would be needed to compare two lambda forms for a-equivalence, which again is not a simple task. Essentially, the logic variable X is meant to be interpreted as a bound variable, which requires an additional layer of programming. 213 (Park, 1992) proposes a solution within first-order unification that can handle not only sentence (la), but also more complex examples with determiners. The method used is to introduce spurious bindings that subsequently get removed. For example, the semantics of (4a) would be (4b), which would then get simplified to (4c). (4a) A farmer and every senator talk (4b) existsai,faraer(Xl) k(exists(12,(12=11)ktalk(12)))) kforallaBosenator(X3) =&gt;(exists(12,(12=13)ktalk(12)))) (4c) exists(11,faraer(I1)ktalk(X1)) kforall(13,senator(13)=&gt;talk(13)) While this pushes first-order unification beyond what it had been pr</context>
<context position="20900" citStr="Park, 1992" startWordPosition="3557" endWordPosition="3558">ry functions (7a) would. However, this same process of recursive descent via scoped constants will work for any member of the conj rule family. For example, the following query coord (is up (bs up a)) (abs obj\(abs sub\(like&apos; sub obj))) (abs obj\(abs sub\(hate&apos; sub obj))) K. = (abs x\ (abs xl\ (and&apos; (like&apos; xi x) (hate&apos; xl x)))). corresponds to rule (7b). Note also that the use of the same bound variable names obj and sub causes no difficulty since the use of scoped-constants, meta-level /3-reduction, and higher-order unification is used to access and manipulate the inner terms. Also, whereas (Park, 1992) requires careful consideration of handling of determiners with coordination, here such sentences are handled just like any others. For example, the sentence Mary gave every dog a bone and some policeman a flower results in the LF 12. &amp;quot;This is a case in which the particular LF assumed here fails to yield another available scoping. See footnote 10. 217 (and&apos; (exists x\((bone&apos; x) tic (forall xl\((dog&apos; xl) &gt;&gt; (gave&apos; mary&apos; x x1))))) (exists x\((flower&apos; x) (exists x1\((policeman&apos; x1) at (gave&apos; nary&apos; x x1)))))) Thus, &amp;quot;generalized coordination&amp;quot;, instead of being a family of separate rules, can be exp</context>
</contexts>
<marker>Park, 1992</marker>
<rawString>Jong C. Park. 1992. A unification-based semantic interpretation for coordinate constructs. In 30th Annual Meeting of the Association for Computational Linguistics, pages 209-215.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jong C Park</author>
</authors>
<title>Quantifier scope and constituency.</title>
<date>1995</date>
<booktitle>In 33rd Annual Meeting of the Association for Computational Linguistics (this volume).</booktitle>
<contexts>
<context position="15060" citStr="Park, 1995" startWordPosition="2497" endWordPosition="2498">abs pVapp p harry&apos;)), and then composed with found, with the result shown in the following query: 7- compose (abs p\(app p harry&apos;)) (abs obj\ (abs sub\ (found&apos; sub obj))) M. X = (abs x\ (app (abs sub\(found&apos; sub x)) harry&apos;)). derivation fails to yield all available quantifier scopings. We do not address here the further question of how the remaining scoped readings are derived. Alternatives that appear compatible with the present approach are quantifier movement (Hobbs &amp; Shieber, 1987), type-raising at LF (Partee &amp; Rooth, 1983), or the use of disambiguated quantifers in the derivation itself (Park, 1995). There are other clauses, not shown here, that determine the direction of the CCG rule. For either direction, however, the semantics are the same and both directional rules call these clauses for the semantic computation. atomic-type up. atomic-type s. atomic-type conj. atomic-type noun. Figure 5: Implementation of the CCG category system At this point a further )6-reduction is needed. Note however this is not at all the same problem of writing a /3-reducer in Prolog. Instead it is a simple matter of using the meta-level /3-reduction to eliminate /3-redexes to produce the final result (abs xV</context>
</contexts>
<marker>Park, 1995</marker>
<rawString>Jong C. Park. 1995. Quantifier scope and constituency. In 33rd Annual Meeting of the Association for Computational Linguistics (this volume).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Barbara Partee</author>
<author>Mats Rooth</author>
</authors>
<title>Generalized conjunction and type ambiguity.</title>
<date>1983</date>
<booktitle>Meaning, Use, and Interpretation of Language. W. de Gruyter,</booktitle>
<pages>361--383</pages>
<editor>In Rainer Bauerle, Christoph Schwarze, and Arnim von Stechow, editors,</editor>
<location>Berlin,</location>
<contexts>
<context position="14982" citStr="Partee &amp; Rooth, 1983" startWordPosition="2483" endWordPosition="2486">ng and forward composition. harry would get type-raised by the raise clause to produce (abs pVapp p harry&apos;)), and then composed with found, with the result shown in the following query: 7- compose (abs p\(app p harry&apos;)) (abs obj\ (abs sub\ (found&apos; sub obj))) M. X = (abs x\ (app (abs sub\(found&apos; sub x)) harry&apos;)). derivation fails to yield all available quantifier scopings. We do not address here the further question of how the remaining scoped readings are derived. Alternatives that appear compatible with the present approach are quantifier movement (Hobbs &amp; Shieber, 1987), type-raising at LF (Partee &amp; Rooth, 1983), or the use of disambiguated quantifers in the derivation itself (Park, 1995). There are other clauses, not shown here, that determine the direction of the CCG rule. For either direction, however, the semantics are the same and both directional rules call these clauses for the semantic computation. atomic-type up. atomic-type s. atomic-type conj. atomic-type noun. Figure 5: Implementation of the CCG category system At this point a further )6-reduction is needed. Note however this is not at all the same problem of writing a /3-reducer in Prolog. Instead it is a simple matter of using the meta-</context>
</contexts>
<marker>Partee, Rooth, 1983</marker>
<rawString>Barbara Partee and Mats Rooth. 1983. Generalized conjunction and type ambiguity. In Rainer Bauerle, Christoph Schwarze, and Arnim von Stechow, editors, Meaning, Use, and Interpretation of Language. W. de Gruyter, Berlin, pages 361-383.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fernando C N Pereira</author>
</authors>
<title>Semantic interpretation as higher-order deduction.</title>
<date>1990</date>
<booktitle>Logics in AI: European Workshop JELIA&apos;90, Lecture Notes in Artificial Intelligence number 478,</booktitle>
<pages>78--96</pages>
<editor>In Jan van Eijck, editor,</editor>
<publisher>Springer-Verlag,</publisher>
<location>Berlin, Germany.</location>
<contexts>
<context position="5801" citStr="Pereira, 1990" startWordPosition="891" endWordPosition="892">ematic to actually implement. The solution given in this paper is to use a higher-order logic programming language, AProlog, that already implements these concepts, called &amp;quot;abstract syntax&amp;quot; in (Miller, 1991) and &amp;quot;higher-order abstract syntax&amp;quot; in (Pfenning and Elliot, 1988). This allows a natural and elegant implementation of the grammatical theory, with only one lexical entry for and. This paper is meant to be viewed as furthering the exploration of the utility of higher-order logic programming for computational linguistics - see, for example, (Miller &amp; Nadathur, 1986), (Pareschi, 1989), and (Pereira, 1990). 2 CCG CCG is a grammatical formalism in which there is a one-to-one correspondence between the rules of composition&apos; at the level of syntax and logical form. Each word is (perhaps ambiguously) assigned a category and LF, and when the syntactical operations assign a new category to a constituent, the corresponding semantic operations produce a new LF for that constituent as well. The CCG rules shown in Figure 1 are implemented in the system described &apos;In the general sense, not specifically the CCG rule for function composition. Function Application (&gt;): X/Y : F Y:y =&gt; X: Fy Function Applicati</context>
</contexts>
<marker>Pereira, 1990</marker>
<rawString>Fernando C.N. Pereira. 1990. Semantic interpretation as higher-order deduction. In Jan van Eijck, editor, Logics in AI: European Workshop JELIA&apos;90, Lecture Notes in Artificial Intelligence number 478, pages 78-96. Springer-Verlag, Berlin, Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fernando C N Pereira</author>
<author>Stuart M Shieber</author>
</authors>
<title>Prolog and Natural-Language Analysis.</title>
<date>1987</date>
<journal>Number</journal>
<booktitle>in CSLI Lecture Notes. Center for the Study of Language and Information,</booktitle>
<volume>10</volume>
<publisher>Chicago Press.</publisher>
<location>Stanford, California,</location>
<contexts>
<context position="11760" citStr="Pereira and Shieber, 1987" startWordPosition="1908" endWordPosition="1911">cation, and so in the derivation of harry found, the type-raised harry has the AProlog value (abs Wapp p harry&apos;)).9 The second part of Figure 3 shows declares how quantifiers are represented, which are required since the sentences to be processed may have determiners. torah l and exists are encoded similarly to abstraction, in that they take a functional argument and so object-level binding of variables by quantifiers is handled by meta-level A-abstraction. &gt;&gt; and kk are simple constructors for implication and conjunction, to be used with forall and exists respectively, in the typical manner (Pereira and Shieber, 1987). For example, the sentence every man found a bone has as a possible LF (8a), with the AProlog representation (8b)15: &apos;This is the same syntax for A-abstraction as in (3). (Moore, 1989) in fact borrows the notation for Aabstraction from AProlog. The difference, of course, is that here the abstraction is a meta-level, built-in construct, while in (3) the interpretation is dependent on an extra layer of programming. Bound variables in AProlog can be either upper or lower case, since they are not logic variables, and will be written in lower case in this paper. 6It is possible to represent the lo</context>
</contexts>
<marker>Pereira, Shieber, 1987</marker>
<rawString>Fernando C.N. Pereira and Stuart M. Shieber. 1987. Prolog and Natural-Language Analysis. Number 10 in CSLI Lecture Notes. Center for the Study of Language and Information, Stanford, California, 1985. Distributed by the University of Chicago Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Frank Pfenning</author>
<author>Conal Elliot</author>
</authors>
<title>Higherorder abstract syntax.</title>
<date>1988</date>
<booktitle>In Proceedings of the ACMSIGPLAN Conference on Programming Language Design and Implementation,</booktitle>
<contexts>
<context position="5460" citStr="Pfenning and Elliot, 1988" startWordPosition="836" endWordPosition="839">become correspondingly more complex and greatly obscure the theoretical background of the grammar formalism. The fundamental problem in both cases is that the concept of free and bound occurrences of variables is not supported by Prolog, but instead needs to be implemented by additional programming. While theoretically possible, it becomes quite problematic to actually implement. The solution given in this paper is to use a higher-order logic programming language, AProlog, that already implements these concepts, called &amp;quot;abstract syntax&amp;quot; in (Miller, 1991) and &amp;quot;higher-order abstract syntax&amp;quot; in (Pfenning and Elliot, 1988). This allows a natural and elegant implementation of the grammatical theory, with only one lexical entry for and. This paper is meant to be viewed as furthering the exploration of the utility of higher-order logic programming for computational linguistics - see, for example, (Miller &amp; Nadathur, 1986), (Pareschi, 1989), and (Pereira, 1990). 2 CCG CCG is a grammatical formalism in which there is a one-to-one correspondence between the rules of composition&apos; at the level of syntax and logical form. Each word is (perhaps ambiguously) assigned a category and LF, and when the syntactical operations </context>
</contexts>
<marker>Pfenning, Elliot, 1988</marker>
<rawString>Frank Pfenning and Conal Elliot. 1988. Higherorder abstract syntax. In Proceedings of the ACMSIGPLAN Conference on Programming Language Design and Implementation, 1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark J Steedman</author>
</authors>
<title>Gapping as constituent coordination.</title>
<date>1990</date>
<booktitle>In Linguistics and Philosophy 13,</booktitle>
<pages>207--263</pages>
<contexts>
<context position="1444" citStr="Steedman, 1990" startWordPosition="203" endWordPosition="204">s an elegant implementation of the se-. mantics of Combinatory Categorial Grammar, including its handling of coordination constructs. 1 Introduction Many theories of semantic interpretation use A-term manipulation to compositionally compute the meaning of a sentence. These theories are usually implemented in a language such as Prolog that can simulate A-term operations with first-order unification. However, there are cases in which this can only be done by obscuring the underlying linguistic theory with the &amp;quot;tricks&amp;quot; needed for implementation. For example, Combinatory Categorial Grammar (CCG) (Steedman, 1990) is a theory of syntax and semantic interpretation that has the attractive characteristic of handling many coordination constructs that other theories cannot. While many aspects of CCG semantics can be reasonably simulated in first-order unification, the simulation breaks down on some of the most interesting cases that CCG can theoretically handle. The problem in general, and for CCG in particular, is that the implementation language does not have sufficient expressive power to allow a more direct encoding. The solution given in this paper is to show how advances in logic programming allow the</context>
<context position="8191" citStr="Steedman, 1990" startWordPosition="1306" endWordPosition="1307">imulated as shown in Figure 2.4 The final CCG rule to be considered is the coordination rule that specifies that only like categories can coordinate: &apos;The type-raising rules shown are actually a simplification of what has been implemented. In order to handle determiners, a system similar to NP-complement categories as discussed in (Dowty, 1988) is used. Although a worthwhile further demonstration of the use of abstract syntax, it has been left out of this paper for space reasons. &apos;The \ for a backward-looking category should not be confused with the \ for A-abstraction. 4example adapted from (Steedman, 1990, p. 220). 214 (6) X conj I =&gt; This is actually a schema for a family of rules, collectively called &amp;quot;generalized coordination&amp;quot;, since the semantic rule is different for each case.5 For example, if X is a unary function, then the semantic rule is (7a), and if the functions have two arguments, then the rule is (7b).6 (7a) 1FGH = Ax.F(Gx)(Hx) (7b) 4&apos;2FGH = Ax.Ay.F(Gxy)(Hxy) For example, when processing (la), rule (7a) would be used with: • F = Ax.4.(andi x • G = AP.(P john&apos;) • H = AP.(P bill&apos;) with the result OFGH = Ax.(ance (x john&apos;) bi.1.1!)) which is a-equivalent to (2). 3 APROLOG and Abstract</context>
<context position="10113" citStr="Steedman, 1990" startWordPosition="1621" endWordPosition="1622">language. The AProlog code fragment shown in Figure 3 declares how the CCG logical forms are represented. Each CCG LF is represented as an untyped A-term, namely type ta. abs represents object-level abstraction Ax.M by the meta-level expression (abs X), 6It is not established if this schema should actually produce an unbounded family of rules. See (Weir, 1988) and (Weir and Joshi, 1988) for a discussion of the implications for automata-theoretic power of generalized coordination and composition, and (Gazdar, 1988) for linguistic arguments that languages like Dutch may require this power, and (Steedman, 1990) for some further discussion of the issue. In this paper we use the generalized rule to illustrate the elegance of the representation, but it is an easy change to implement a bounded coordination rule. 6The 4) notation is used because of the combinatory logic background of CCG. See (Steedman, 1990) for details. &apos;defined as the unification of simply typed A-terms, modulo conversion. kind tin type. type abs (ta —&gt; ta) —&gt; tm. type app ta —&gt; ta —&gt; ta. type torah l (ta —&gt; ta) —&gt; ta. type exists (ta —&gt; ta) —&gt; tn. type &gt;&gt; ta —&gt; ta —&gt; ta. type kk ta —&gt; ta —&gt; ta. Figure 3: Declarations for AProlog repr</context>
<context position="21584" citStr="Steedman, 1990" startWordPosition="3669" endWordPosition="3670">ination, here such sentences are handled just like any others. For example, the sentence Mary gave every dog a bone and some policeman a flower results in the LF 12. &amp;quot;This is a case in which the particular LF assumed here fails to yield another available scoping. See footnote 10. 217 (and&apos; (exists x\((bone&apos; x) tic (forall xl\((dog&apos; xl) &gt;&gt; (gave&apos; mary&apos; x x1))))) (exists x\((flower&apos; x) (exists x1\((policeman&apos; x1) at (gave&apos; nary&apos; x x1)))))) Thus, &amp;quot;generalized coordination&amp;quot;, instead of being a family of separate rules, can be expressed as a single rule on recursive descent through logical forms. (Steedman, 1990) also discusses &amp;quot;generalized composition&amp;quot;, and it may well be that a similar implementation is possible for that family of rules as well. 5 Conclusion We have shown how higher-order logic programming can be used to elegantly implement the semantic theory of CCG, including the previously difficult case of its handling of coordination constructs. The techniques used here should allow similar advantages for a variety of such theories. An argument can be made that the approach taken here relies on a formalism that entails implementation issues that are more difficult than for the other solutions a</context>
</contexts>
<marker>Steedman, 1990</marker>
<rawString>Mark J. Steedman. 1990. Gapping as constituent coordination. In Linguistics and Philosophy 13, pages 207-263</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Weir</author>
</authors>
<title>Characterizing Mildly Contextsensitive Grammar Formalism.</title>
<date>1988</date>
<tech>CIS-88-74, PhD thesis,</tech>
<institution>University of Pennsylvania.</institution>
<contexts>
<context position="9860" citStr="Weir, 1988" startWordPosition="1583" endWordPosition="1584">xpress the logical forms terms computed by CCG. The built-in A-term manipulation is used as a &amp;quot;meta-language&amp;quot; in which the &amp;quot;object-language&amp;quot; of CCG logical forms is expressed, and variables in the object-language are mapped to variables in the meta-language. The AProlog code fragment shown in Figure 3 declares how the CCG logical forms are represented. Each CCG LF is represented as an untyped A-term, namely type ta. abs represents object-level abstraction Ax.M by the meta-level expression (abs X), 6It is not established if this schema should actually produce an unbounded family of rules. See (Weir, 1988) and (Weir and Joshi, 1988) for a discussion of the implications for automata-theoretic power of generalized coordination and composition, and (Gazdar, 1988) for linguistic arguments that languages like Dutch may require this power, and (Steedman, 1990) for some further discussion of the issue. In this paper we use the generalized rule to illustrate the elegance of the representation, but it is an easy change to implement a bounded coordination rule. 6The 4) notation is used because of the combinatory logic background of CCG. See (Steedman, 1990) for details. &apos;defined as the unification of sim</context>
</contexts>
<marker>Weir, 1988</marker>
<rawString>David Weir. 1988. Characterizing Mildly Contextsensitive Grammar Formalism. CIS-88-74, PhD thesis, University of Pennsylvania.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Weir</author>
<author>Aravind doshi</author>
</authors>
<title>Combinatory categorial grammars: generative power and relation to linear CF rewriting systems.</title>
<date>1988</date>
<booktitle>In 261h Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>278--285</pages>
<marker>Weir, doshi, 1988</marker>
<rawString>David Weir and Aravind doshi. 1988. Combinatory categorial grammars: generative power and relation to linear CF rewriting systems. In 261h Annual Meeting of the Association for Computational Linguistics, pages 278-285.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>