<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000329">
<title confidence="0.967121">
Task-based dialog management using an agenda
</title>
<author confidence="0.898342">
Wei Xu and Alexander I. Rudnicky
</author>
<affiliation confidence="0.899022">
School of Computer Science — Carnegie Mellon University
</affiliation>
<address confidence="0.723844">
5000 Forbes Ave — Pittsburgh, PA 15213
</address>
<email confidence="0.99744">
{xw,air}@cs.cmu.edu
</email>
<sectionHeader confidence="0.987546" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999213">
Dialog management addresses two specific
problems: (I) providing a coherent overall
structure to interaction that extends beyond the
single turn, (2) correctly managing mixed-
initiative interaction. We propose a dialog
management architecture based on the following
elements: handlers that manage interaction
focussed on tightly coupled sets of information,
a product that reflects mutually agreed-upon
information and an agenda that orders the topics
relevant to task completion.
</bodyText>
<sectionHeader confidence="0.998797" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999916102040816">
Spoken language interaction can take many
forms. Even fairly simple interaction can be very
useful, for example in auto-attendant systems.
For many other applications, however, more
complex interactions seem necessary, either
because users cannot always be expected to
exactly specify what they want in a single
utterance (e.g., obtaining schedule information)
or because the task at hand requires some degree
of exploration of complex alternatives (e.g.,
travel planning). Additionally, unpredictable
complexity is introduced through error or
misunderstanding and the system needs to detect
and deal with these cases. We are interested in
managing interaction in the context of a goal-
oriented task that extends over multiple turns.
Dialog management in the context of purposeful
tasks must solve two problems: (1) Keep track
of the overall interaction with a view to ensuring
steady progress towards task completion. That
is, the system must have some idea of how much
of the task has been completed and more
importantly some idea of what is yet to be done,
so that it can participate in the setting of
intermediate goals and generally shepherd the
interaction towards a successful completion of
the task at hand. (2) Robustly handle deviations
from the nominal progression towards problem
solution. Deviations are varied: the user may ask
for something that is not satisfiable (i. e.,
proposes a set of mutually-incompatible
constraints), the user may misspeak (or, more
likely, the system may misunderstand) a request
and perhaps cause an unintended (and maybe
unnoticed) deviation from the task. The user
might also underspecify a request while the
system requires that a single solution be chosen,
Finally the user&apos;s conception of the task might
deviate from the system&apos;s (and its developers)
conception, requiring the system to alter the
order in which it expects to perform the task.
Ideally, a robust dialog management architecture
can accommodate all of these circumstances
within a single framework,
We have been exploring dialog management
issues in the context of the Communicator [3]
task. The Communicator handles a complex
travel task, consisting of air travel, hotels and
car reservations.
</bodyText>
<sectionHeader confidence="0.933218" genericHeader="method">
2 Modeling Dialog
</sectionHeader>
<bodyText confidence="0.998280909090909">
Existing approaches to dialog management are
difficult to adapt to the current problem because
they either impose a rigid structure on the
interaction or because they are not capable of
managing data structures beyond a certain level
of complexity. Call-flow based systems (more
generally, graph-based systems) handle the
complexity of dialog management by explicitly
enumerating all possible dialog states, as well as
allowable transitions between states. This serves
the purpose of partitioning the problem into a
</bodyText>
<page confidence="0.998322">
42
</page>
<bodyText confidence="0.999990882352941">
finite set of states, with which can be associated
topic-specific elements (such as grammar,
prompts, help and interactions with other system
components, e.g., database interaction).
Transition between states is predicated on the
occurrence of specific events, either the user&apos;s
spoken inputs or through (e.g.) a change in back-
end state. It is the nature of these systems that
the graphs are often but not exclusively trees.
Except for the simplest tasks, graph systems
have several limitations: Unless the graph is
carefully designed, users will find themselves
unable to switch to a topic that is coded in a
different sub-tree without going through the
common parent of the two. Often this is through
the root node-of the dialog. Similarly it is not
always possible to navigate an existing tree, in
order, e.g., to correct information supplied in an
earlier node.
Frame-based systems provide an alternate, more
flexible approach. Here the problem is cast as
form filling: the form specifies all relevant
information (slots) for an action. Dialog
management consists of monitoring the form for
completion, setting elements as these are
specified by the user and using the presence of
empty slots as a trigger for questions to the user.
Form-filling does away with the need to specify
a particular order in which slots need to be filled
and allows for a more natural, unconstrained,
form of input. While ideally suited for tasks that
can be expressed in terms of filling a single
form, form-filling can be combined with graph
representations (typically ergodic) to support a
set of (possibly) related activities, each of which
can be cast into a form-filling format.
Both graph and frame systems share the property
that the task usually has a fixed goal which is
achieved by having the user specify information
(fill slots) on successive turns. Using a filled out
form the system performs some action, such as
information retrieval. While this capability
encompasses a large number of useful
applications it does not necessarily extend to
more complex tasks, for example ones where the
goal is to create a complex data object (e.g. [l]).
We have been building a system that allows
users to construct travel itineraries. This domain
poses several problems: there is no &amp;quot;form&amp;quot; as
such to fill out, since we do not know
beforehand the exact type of trip an individual
might take (though the building blocks of an
itinerary are indeed known). The system benefits
from being able to construct the itinerary
dynamically; we denote these solution objects
products. Users also expect to be able to
manipulate and inspect the itinerary under
construction. By contrast, frame systems do not
afford the user the ability to manipulate the
form, past supplying fillers for slots. The
exception is the selection of an item from a
solution set. We do not abandon the concept of a
form altogether: an itinerary is actually a
hierarchical composition of forms, where the
forms in this case correspond to tightly-bound
slots (e.g., those corresponding to the constraints
on a particular flight leg) and which can be
treated as part of the-same topic.
</bodyText>
<sectionHeader confidence="0.739835" genericHeader="method">
3 Task Structure and Scripts
</sectionHeader>
<bodyText confidence="0.999986615384615">
Intuitively (as well as evident from our
empirical studies of human travel agents and
clients) travel planning develops over time as a
succession of episodes, each focused on a
specific topic (such as a given flight leg, a hotel
in a particular city, etc.). Users treat the task as a
succession of topics, each of which ought to be
discussed in full and closed, before moving on
to the next topic. Topics can certainly be
revisited, but doing so corresponds to an explicit
conversational move on the part of the
participants.
Our first dialog manager took advantage of this
task structure ([3]). By analogy to what we
observed in the human-human data we refer to it
as a script-based dialog manager. Script in this
context simply refers to an explicit sequencing
of task-related topics. Each topic is expressed as
a form-filling task, with conventional free-order
input allowed for form slots and a slot-state
driven mixed-initiative interaction (i.e., ask the
user about any empty slot). The topic-specific
form is actually composed of two parts:
constraint slots (typically corresponding to
elements of a query) and a solution slot
(containing the result of an executed query).
</bodyText>
<page confidence="0.998712">
43
</page>
<bodyText confidence="0.999911">
The control strategy is also actually more
complex: slots are pre-ordered based on their
(domain-derived) ability to constrain the
solution; this ordering provides a default
sequence in which the system selects elements to
ask the user about. Control is predicated on the
state of a slot (whether constraint or solution).
The state can either be &amp;quot;empty&amp;quot;, in which case
the system should ask the user for a value, filled
with a single value, in which case it is
&amp;quot;complete&amp;quot;, or filled with multiple values. The
last case is cause to engage the user in a
clarification sub-dialog whose goal is to reduce
multiple values to a single value, either by
selecting an item in the solution set or by
restating a- constraint. Figure 1 shows the
structure of the Flight Leg topic in the script-
based system.
</bodyText>
<figureCaption confidence="0.840294666666667">
Figure 1 Task-based dialog control in a script-based
system, as determined by the structure of a compound
schema, with contributions from three simple schema.
</figureCaption>
<sectionHeader confidence="0.884399" genericHeader="method">
4 An Agenda-based Architecture
</sectionHeader>
<bodyText confidence="0.999954609375">
While capable of efficiently handling routine
travel arrangements, the script-based approach
has a number of perceived limitations: the script
is very closely identified with the product data
structure. Specifically, we used a fixed product
structure that served as a form to fill out. While
the entire form does not need to be filled out to
create a valid itinerary, it nevertheless set limits
on what the user can construct. Instead we
wanted a form structure that could be
dynamically constructed over the course of a
session, with contributions from both the user
and the system. The script-based approach also
seemed to make navigation over the product
difficult. While we implemented a simple undo
and correction mechanism that allowed the user
to revisit preceding product elements, users had
difficulty using it correctly. While some of the
difficulty could be traced to inadequate support
of orientation, the source was more likely the
inability of the system to treat the product
structure independent of the script.
We sought to address_ these problems by
introducing two new data structures: an agenda
to replace a fixed script and a dynamic product
that can evolve over the course of a session. In
the agenda-based system, the product is
represented as a tree, which reflects the natural
hierarchy, and order, of the information needed
to complete the task. A dynamic product is
simply one that can be modified over the course
of a session, for example by adding legs to a trip
as these are requested by the user rather than
working from a fixed form. Operationally, this
means providing a set of operators over tree
structures and making these available to the user
and to the system. In our case, we defined a
library of sub-trees (say air travel legs or local
arrangements) and a way to attach these to the
product structure, triggered either by the setting
of particular values in the existing tree or
through explicit requests on the part of the user
(&amp;quot;and then I&apos;d like to fly to Chicago&amp;quot;).
Each node in the product tree corresponds to a
handler, which encapsulates computation
relevant to a single information item. All
handlers have the same form: they specify a set
of receptors corresponding to input nets, a
transform to be applied to obtain a value and a
specification of what the system might say to the
user in relation to the information governed by
the handler. Handlers correspond to the schema
and compound schema of the script-based
system (see Figure 1).
The agenda is an ordered list of topics,
represented by handlers that govern some single
item or some collection of information. The
agenda specifies the overall &amp;quot;plan&amp;quot; for carrying
out a task. The system&apos;s priorities for action are
captured by the agenda, an ordered list of
handlers generated through traversal of the
product structure. The handler on the top of the
agenda has the highest priority and represents
the focused topic. A handler can capture
</bodyText>
<figure confidence="0.996474">
Destipettion
airpvrt
Flight
Leg
Avvilabk .Nhtx
</figure>
<page confidence="0.998074">
44
</page>
<bodyText confidence="0.9995581">
relevant input from the user and can generate
prompts to the user. A single handler deals only
with a mini dialog centering on a particular
piece of information (e.g. departure date). The
agenda is a generalization of a stack. It indicates
both the current focus of interaction (i.e., the
top-most handier) as well as all undealt-with
business, and captures the order in which such
business should be dealt with. (The system&apos;s
high-level goal is to ensure that all values in the
current product tree have valid settings.) As all
items in. the agenda are potentially activatable
through what the user speaks, the user has
corresponding control over the topic in focus.
The agenda .also contains generic handlers that
sort to the bottom-of the agenda. These can be
used to consume any inputs that are not caught
by product-derived handlers (for example,
requests for help). Figure 2 shows how a
simplest handler looks like
</bodyText>
<figure confidence="0.996605">
Handler User
HandleOutput
If !Valid
NLG(&amp;quot;query user_name&amp;quot;)
Return focused_waiting_answer
Endif
Return pass control
HandleInput
If [name I identification]
ReadProfile
Validate
Endif
Return pass_control
</figure>
<figureCaption confidence="0.999035">
Figure 2 An example of handler
</figureCaption>
<bodyText confidence="0.966748869565217">
The order of the agenda is generated from the
left-to-right, depth-first traversal of the product
tree. When a user input comes in, the system
calls each handler per their order in the agenda
and each handler will try to interpret the user
input. We call the process of letting each handler
to consume user input as input pass. When a
handler captures a single piece of information,
the information is marked as consumed. This
guarantees that a single information item can be
consumed by only one handler. After an input
pass, if the user&apos;s input does not directly cause a
particular handler to generate a question, then
the system will go through an output pass during
which each handler will have- a chance to
generate a prompt about itself (e.g. the handler
for departure date can ask user for a departure
date).
Al: Hello. You&apos;ve reached the [Communicator].
Tell me your full name
U2: hi I&apos;d like to fly to seattle tuesday morning
A3: Traveling to Seattle on Tuesday, August
eleventh in the morning. Your full name?
</bodyText>
<listItem confidence="0.8027444">
U4: [John Doe]
A5: Hello, [John], I&apos;m glad to hear from you
again. You can now ask me for help.
A6: OK. Let&apos;s see I have a United flight
departing Pittsburgh at ten forty five a.m.
arriving into Seattle at one fifty seven p.m.
Is that OK?
U7; Yes
A8: Will you return to Pittsburgh from Seattle?
U9: no i will go to Los Angeles
</listItem>
<tableCaption confidence="0.386985">
A10: Traveling to Los Angeles. on what date
Ul I: Sorry can we go back to talk about the
previous leg again
</tableCaption>
<bodyText confidence="0.636287888888889">
Al2: For the first leg, you are on a United flight
1446 departing Pittsburgh at ten forty five
A.M. tomorrow, arriving in Seattle at one
fifty seven P.M. Do you want to take that?
U13: actually i want to leave on wednesday
A14: a flight on wednesday.
A15: I have a flight departing Pittsburgh at ten
forty five a.m., arrives Seattle at one fifty
seven p.m. Is that OK?
</bodyText>
<footnote confidence="0.640678">
U16: Yes
</footnote>
<note confidence="0.6739265">
A17: OK and on what day do you want to depart
Seattle?
U18: next Monday
A19: Traveling on Monday, August sixteenth.
</note>
<figureCaption confidence="0.966861">
Figure 3 An example dialog
</figureCaption>
<bodyText confidence="0.999878642857143">
The framework can determine the next step from
the return code of a handler, it can choose to
continue the current pass, exit input pass and
switch to output pass, exit current pass and wait
for input from user, etc. During a pass, a handler
can also declare itself as the focus through its
return code. In this case, it will be promoted to
the top of the agenda. In order to preserve the
context of a specific topic, we use a method
called sub-tree promotion. In this method, a
handler is first promoted to the left-most node
among its siblings. The system also handles the
dependencies among the nodes of the product
tree. A typical dependent relationship is between
</bodyText>
<page confidence="0.996152">
45
</page>
<table confidence="0.965091714285714">
The initial product tree (simplified) Product tree at utterance A10
&amp;quot; Figure 4
Travel User User Flight I Next Date2 Flightl_ Flightl Date2
User Travel Travel Destl Flightl Flight2 Dest I Destl Flight2
,Flightl Flight! Flightl Date I Destl Dest2 Dest I Date] Dest2
bestl Dest I Destl Timel Date 1 Time2 Timel Timel Time2
Date I Date I Date I User &apos;Time 1 Next Date2 Date2 Flightl
Timel Timel Timel Travel User Flighti Flight2 Flight2 Destl
Next Next Next Next Travel Dest I Dest2 Dest2 Date I
Datel Time2 Time2 Time 1
Timel Next Next Next
User User User User
Travel Travel Travel Travel
initial Al A3 A6 A8 A10 Al2 A15 A17
</table>
<figureCaption confidence="0.991155">
Figure 5 The change of agenda along the session
</figureCaption>
<bodyText confidence="0.9993448">
a parent node and a child node. Usually, the
value of a parent node is dependent on its
children. Each node maintains a list of its
dependent nodes and it will notify its dependents
about any changes of its value. The dependent
node can then declare itself invalid and therefore
a candidate topic for conversation.
The dialog in figure 3, generated using the
system, shows a number of features: the ability
to absorb an implicit change of topic on the part
of the user (Al -A3), adding to an existing
itinerary (A8-A10) and handling an explicit
topic shift (U11). Figure 2 and Figure 3 show
how the product tree and agenda evolve over the
course of the dialog
</bodyText>
<sectionHeader confidence="0.993859" genericHeader="method">
5 System Implementation
</sectionHeader>
<bodyText confidence="0.999842153846154">
The Communicator is telephone-based and is
implemented as a modular distributed system,
running across NT and Linux platforms.
Currently the task is captured in an
approximately 2500-word language based on
corpora derived from human-human, Wizard of
Oz and human-computer interaction in this
domain. Domain information is obtained from
various sources on the Web. The system has
information about 500 destinations worldwide,
though with a majority of these are in the United
States. To date, we have collected
approximately 6000 calls, from over 360
</bodyText>
<page confidence="0.99777">
46
</page>
<bodyText confidence="0.914671">
factored out as independent processes.
</bodyText>
<sectionHeader confidence="0.986071" genericHeader="conclusions">
6 Summary and Conclusions
</sectionHeader>
<bodyText confidence="0.999993137254902">
The agenda-based approach addresses the
problem of dialog management in complex
problem-solving tasks. It does so by treating the
task at hand as one of cooperatively constructing
a complex data structure, a product, and uses
this structure to guide the task. The product
consists of a tree of handlers, each handler
encapsulates processing relevant to a particular
schema. Handlers correspond to simple or
compound schema, the latter acting essentially
as multi-sleit= fofms. A handler encapsulates
knowledge necesiary for interacting about a
specific information slot, including specification
of user and system language and of interactions
with domain agents. Handlers that deal with
compound schema coordinate tightly bound
schema and correspond to specific identifiable
topics of conversation. We define tightly bound
as those schema that users expect to discuss
interchangeably, without explicit shifts in
conversational focus.
We believe that individual handlers can be
authored independently of others at the same
level of hierarchy; in turn we believe this will
simplify the problem of developing dialog
systems by managing the complexity of the
process.
The agenda contains all topics relevant to the
current task. The order of handlers on the agenda
determines how user input will be will be
attached to product nodes. Bath the system and
the user however have the ability to reorder
items on the agenda, the system to foreground
items that need to be discussed, the user to
reflect their current priorities within the task.
The mechanisms described in this paper do not
cover all necessary aspects of dialog
management but do provide an overall control
architecture. For example, clarification
processes, which involve possibly extended
interaction with respect to the state of a value
slot, fit into the confines of a single handler and
are implemented as such. Ideally they could be
We believe that the agenda mechanism can be
adapted easily to less-complex domains that
might currently be implemented as a standard
form-based system (for example a movie
schedule service). We do not know as yet how
well the technique will succeed for domains of
complexity comparable to travel planning but
with different task structure.
</bodyText>
<sectionHeader confidence="0.999436" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.998851428571429">
[1] James F. Allen, Lenhart K. Schubert, George
Ferguson, Peter Heeman, Chung Hee Hwang,
Tsuneaki Kato, Marc Light, Nathaniel G. Martin,
Bradford W. Miller, Massimo Poesio, and David
R. Traum, &amp;quot;The TRAINS Project: A case study in
building a conversational planning agent&amp;quot; Journal
of Experimental and Theoretical Al, 7(1995), 7-48.
[2] Bansal, D. and Ravishankar, M. &amp;quot;New features for
confidence annotation&amp;quot; In Proceedings of the 5th
International Conference on Spoken Language
Processing (ICSLP), December 1998, Sydney,
Australia
[31 Rudnicky, A., Thayer, E., Constantinities, P.,
Tchou, C., Shern, P.., Lenzo, K., Xu W., Oh, A.
&amp;quot;Creating natural dialogs in the Carnegie Mellon
Communicator system&amp;quot; Proceedings of
Eurospeech, 1999, Paper r014.
[4] Ward, W. and Issar, S. &amp;quot;Recent improvements in
the CMU spoken language understanding system&amp;quot;
In Proceedings of the ARPA Human Language
Technology Workshop, March 1994, 213-216.
</reference>
<page confidence="0.999488">
47
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.931024">
<title confidence="0.944836">Task-based dialog management using an agenda</title>
<author confidence="0.999975">Wei Xu</author>
<author confidence="0.999975">Alexander I Rudnicky</author>
<affiliation confidence="0.999781">School of Computer Science — Carnegie Mellon</affiliation>
<address confidence="0.999866">5000 Forbes Ave — Pittsburgh, PA</address>
<email confidence="0.999495">xw@cs.cmu.edu</email>
<email confidence="0.999495">air@cs.cmu.edu</email>
<abstract confidence="0.998827666666667">Dialog management addresses two specific problems: (I) providing a coherent overall structure to interaction that extends beyond the single turn, (2) correctly managing mixedinitiative interaction. We propose a dialog management architecture based on the following elements: handlers that manage interaction focussed on tightly coupled sets of information, a product that reflects mutually agreed-upon information and an agenda that orders the topics relevant to task completion.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<authors>
<author>James F Allen</author>
<author>Lenhart K Schubert</author>
<author>George Ferguson</author>
<author>Peter Heeman</author>
<author>Chung Hee Hwang</author>
<author>Tsuneaki Kato</author>
<author>Marc Light</author>
<author>Nathaniel G Martin</author>
<author>Bradford W Miller</author>
<author>Massimo Poesio</author>
<author>David R Traum</author>
</authors>
<title>The TRAINS Project: A case study in building a conversational planning agent&amp;quot;</title>
<journal>Journal of Experimental and Theoretical Al,</journal>
<volume>7</volume>
<issue>1995</issue>
<pages>7--48</pages>
<marker>Allen, Schubert, Ferguson, Heeman, Hwang, Kato, Light, Martin, Miller, Poesio, Traum, </marker>
<rawString>[1] James F. Allen, Lenhart K. Schubert, George Ferguson, Peter Heeman, Chung Hee Hwang, Tsuneaki Kato, Marc Light, Nathaniel G. Martin, Bradford W. Miller, Massimo Poesio, and David R. Traum, &amp;quot;The TRAINS Project: A case study in building a conversational planning agent&amp;quot; Journal of Experimental and Theoretical Al, 7(1995), 7-48.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Bansal</author>
<author>M Ravishankar</author>
</authors>
<title>New features for confidence annotation&amp;quot;</title>
<date>1998</date>
<booktitle>In Proceedings of the 5th International Conference on Spoken Language Processing (ICSLP),</booktitle>
<location>Sydney, Australia</location>
<marker>Bansal, Ravishankar, 1998</marker>
<rawString>[2] Bansal, D. and Ravishankar, M. &amp;quot;New features for confidence annotation&amp;quot; In Proceedings of the 5th International Conference on Spoken Language Processing (ICSLP), December 1998, Sydney, Australia</rawString>
</citation>
<citation valid="true">
<title>Creating natural dialogs in the Carnegie Mellon Communicator system&amp;quot;</title>
<date>1999</date>
<booktitle>Proceedings of Eurospeech,</booktitle>
<note>Paper r014.</note>
<marker>1999</marker>
<rawString>[31 Rudnicky, A., Thayer, E., Constantinities, P., Tchou, C., Shern, P.., Lenzo, K., Xu W., Oh, A. &amp;quot;Creating natural dialogs in the Carnegie Mellon Communicator system&amp;quot; Proceedings of Eurospeech, 1999, Paper r014.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W Ward</author>
<author>S Issar</author>
</authors>
<title>Recent improvements in the CMU spoken language understanding system&amp;quot;</title>
<date>1994</date>
<booktitle>In Proceedings of the ARPA Human Language Technology Workshop,</booktitle>
<pages>213--216</pages>
<marker>Ward, Issar, 1994</marker>
<rawString>[4] Ward, W. and Issar, S. &amp;quot;Recent improvements in the CMU spoken language understanding system&amp;quot; In Proceedings of the ARPA Human Language Technology Workshop, March 1994, 213-216.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>