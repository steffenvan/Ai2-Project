<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000967">
<title confidence="0.803251">
From a Surface Analysis to a Dependency Structure
</title>
<author confidence="0.45959">
Luisa Coheur
</author>
<note confidence="0.9165114">
L2F INESC-ID / GRIL
Lisboa, Portugal
Luisa.Coheur@l2f.inesc-id.pt
Nuno Mamede
L2F INESC-ID / IST
Lisboa, Portugal
Nuno.Mamede@inesc-id.pt
Gabriel G. B`es
GRIL / Univ. Blaise-Pascal
Clermont-Ferrand, France
</note>
<email confidence="0.786572">
BesGabriel@yahoo.fr
</email>
<sectionHeader confidence="0.990133" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999718571428571">
This paper describes how we use the arrows
properties from the 5P Paradigm to generate
a dependency structure from a surface analy-
sis. Besides the arrows properties, two mod-
ules, Algas and Ogre, are presented. Moreover,
we show how we express linguistic descriptions
away from parsing decisions.
</bodyText>
<sectionHeader confidence="0.998797" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999900595744681">
Following the 5P Paradigm (B`es, 1999; Hag`ege,
2000; B`es and Hag`ege, 2001) we build a
syntactic-semantic interface which obtains a
graph from the analysis of input text. The
graph express a dependency structure, which is
the domain of a function that will obtain as out-
put a logic semantic interpretation.
The whole syntactic-semantic interface is in-
tegrated by four modules: Susana in charge
of surface analysis, Algas and Ogre, defining
the graph, and ASdeCopas, that obtains the
logic semantic representation. In this paper
we present the first three modules, focussing
mainly on Algas and Ogre.
5P argues for a carefully separation between
linguistic descriptions and algorithms. The first
ones are expressed by Properties and the last
ones by Processes. Futhermore, linguistic mod-
elised and formalised descriptions (i.e. Prop-
erties, P2 of 5P) are not designed to be the
declarative source of algorithms, but rather as
a repository of information (Hag`ege and B`es,
2002) that one should be able to re-use (to-
tally or partially) in each task. Following and
completing this, we assume that the parsing is-
sue can be viewed from at least three different
points of view: (i) modelised and formalised
linguistic observation; (ii) computational effec-
tive procedures; (iii) useful computational con-
straints. These three aspects of the same issue
are distinctly tackled in the proposed syntactic-
semantic interface, but they converge in the ob-
tention of results.
There are three different kinds of Properties
(P2) in 5P: existence, linearity and arrow prop-
erties. The first two underly the Susana module
(3.1). They express which are the possible mor-
phological categories of some expression and the
possible order between them. The third ones
arrow properties specify arrow pairs, which for-
mally are directed arcs of a graph. Arrow prop-
erties underly the Algas (3.2) and Ogre (3.3)
modules. At the level of Projections (i.e. P3
of 5P) the balanced parentheses structure un-
derlying sentences is exploited (2). Computa-
tional useful constraints improve Algas perfor-
mance (5).
</bodyText>
<sectionHeader confidence="0.836892" genericHeader="introduction">
2 Arrow properties
</sectionHeader>
<bodyText confidence="0.996380285714286">
The motivation behind an arrow property is to
connect two elements, because the established
relation is needed to reach the desired semantic
representation (B`es, 1999). Notice that this for-
malism can be applied to establish dependencies
either between words, chunks or phrases. Nev-
ertheless, arrows can be seen as dependencies
but, contrary to the main dependency theories,
an arrow is not labeled and go from dependents
to the head (Hag`ege, 2000).
Let C be the set of category labels available,
M the set of chunk labels, P a set of phrase
labels and I a set of indexes.
Arrow Property: An arrow property is a
</bodyText>
<equation confidence="0.95532375">
tuple (X, n, Z, Y, m, R+, R−) noted by:
Xn —Z Ym,
+R+
-R−
</equation>
<bodyText confidence="0.826156">
where:
</bodyText>
<listItem confidence="0.982232272727273">
• X, Y E M U C (X is said to be the source
and Y the target of the arrow);
• Z E M U P (the segment labeled Z contains
X and Y);
• R+, R− are sets of constraints over the ar-
rows (respectively, the set of constraints
that Z must verify, either positive ones
(R+) on symbols which must be attested or
negative ones (R−) on symbols which must
not occur);
• n, m E I.
</listItem>
<bodyText confidence="0.978807068181818">
Both R+, R− impose simple constraints over
the arrows, such as symbols that should or
should not occur within Z or linear order re-
lations that should be satisfied between its con-
stituents. As an example, the following ar-
row property says that within an interroga-
tive phrase (Pint), an interrogative chunk (IntC)
with an interrogative pronoun inside (pint) ar-
rows a nominal chunk (NC) on its right (i �
k), as long as there is no other nominal chunk
between them (i � j � k).
IntCi({pint}/) —*Pint NCk
-{NCj}
A more complex type of constraint is the
“stack” constraint (Coheur, 2004). This con-
straint is based on the linguistically motivated
work over balanced parentheses of (B`es and
Dahl, 2003; B`es et al., 2003). Briefly, the
idea behind that work is the following: given
a sentence, if we introduce a left parentheses
everytime we find a word such as que(that),
se(if ), ...) – the introducers – and a right
parentheses everytime we find an inflected
verbal form1, at the end of the sentence, the
number of left parentheses is equal to the
number of right ones, and at any point of it,
the number of left ones is equal or greater
that the number of right ones (B`es and Dahl,
2003). In (B`es and Dahl, 2003), they use this
natural language evidence in order to identify
the main phrase, relatives, coordinations, etc.
Within our work, we use it to precise arrowing
relations. For example, consider the sentence
Quais os hot´eis que tˆem piscina?(Which are
the hotels that have a swimming pool?). The
surface analysis of this statement results in the
following (where VC stands for verbal chunk):
(Quais)IntC (os hot´eis)NC (que)RelC
(tˆem)u C (piscina)NC
Typically the NC os hot´eis arrows the main
VC, but in this situation, as there is no main VC
we want it to arrow itself. Nevertheless, there is
an arrow property saying that an NC can arrow
a VC, which applied to this particular situation
</bodyText>
<footnote confidence="0.750817">
1See (B`es and Dahl, 2003) for details about how to
deal with coordination.
would establish a wrong dependency (Figure 1).
</footnote>
<figureCaption confidence="0.998983">
Figure 1: Wrong dependency
</figureCaption>
<bodyText confidence="0.999932333333333">
Roughly, we use the stack constraint that says
that an NC arrows a VC if the stack of introduc-
ers and flexioned verbs is empty between theme:
</bodyText>
<equation confidence="0.98307">
NCi —*S VCk
+{stackj = [ ]}
</equation>
<bodyText confidence="0.9954834">
As a result, if we consider again the example
Quais os hot´eis que tˆem piscina, the NC hot´eis
will not arrow the VC tˆem, because the stack
constraint is not verified between them (there
is only the introducer que).
</bodyText>
<sectionHeader confidence="0.985264" genericHeader="method">
3 Reaching the dependency
structure
</sectionHeader>
<subsectionHeader confidence="0.999964">
3.1 Surface analysis
</subsectionHeader>
<bodyText confidence="0.999774916666667">
From existence and linearity properties (P2
of 5P) specifiyng chunks, it can be deduced
what categories can or must start a chunk,
and which ones can or must be the last one.
Drawing on this linguistic information, chunks
are detected in a surface analysis made by
Susana (Batista and Mamede, 2002). As an
example, consider the question Qual a maior
praia do Algarve?(Which is the biggest beach
in Algarve?). Susana outputs the following
surface analysis (where PC stands for preposi-
tional chunk):
</bodyText>
<sectionHeader confidence="0.7988855" genericHeader="method">
(Qual)IntC (a maior praia)NC (do Al-
garve)PC (?)Ponct
</sectionHeader>
<subsectionHeader confidence="0.998896">
3.2 Algas
</subsectionHeader>
<bodyText confidence="0.998726384615385">
Algas is the C++ program responsible for con-
necting chunks and the elements inside them,
taking as input a structure that contains infor-
mation from arrow properties and also informa-
tion that can limit the search space (see section
4 from details about this). Additionally, as in-
side the majority of the chunks all the elements
arrow the last element (the head), the user can
declare which are the chunks that verify this
property. As a result, no calculus need to be
made in order to compute dependencies inside
these chunks: all its elements arrow the last one.
This possibility is computational very usefull.
</bodyText>
<footnote confidence="0.9703355">
2In fact, this restriction is a little more complicated
than this.
</footnote>
<bodyText confidence="0.9992442">
Continuing with our example, after Algas ex-
ecution, we have the output from Figure 2.
Both the IntC and the PC chunks arrow the
NC and inside them, all the elements arrow the
head.
</bodyText>
<figureCaption confidence="0.997571">
Figure 2: Algas’s output.
</figureCaption>
<bodyText confidence="0.994380333333333">
Algas is able to skip unalyzable parts of a
sentence, but (for the moment) some constraints
are made to its output:
</bodyText>
<listItem confidence="0.982090571428571">
(1) There is at most an element arrowing itself,
inside each chunk;
(2) Cycles are not allowed;
(3) Arrow crossing is not allowed (projectiv-
ity);
(4) An element cannot be the target of an ar-
row if it is not the source of any arrow.
</listItem>
<bodyText confidence="0.999264833333333">
Notice that these constraints are made inside
the program. Notice that, in particular the pro-
jectivity requirement is not imposed by 5P. We
impose it, due to the fact that – for the moment
– we are only dealing with written Portuguese,
that typically respects this property.
</bodyText>
<subsectionHeader confidence="0.983713">
3.3 Ogre
</subsectionHeader>
<bodyText confidence="0.999810769230769">
After Algas, the text is processed by Ogre, a
pipeline of Perl and XSLT scripts, that gener-
ates a graph from the arrowed structures pro-
duced by Algas3. This process is based on the
following: if a chunk arrows another chunk, the
head of the first chunk will arrow the head of
the second chunk, and the chunk label can be
omitted.
Continuing with our example, after Ogre we
have the graph of Figure 3 (a dependency struc-
ture). Basically, IntC and PC head – respec-
tively qual and Algarve – arrow now the NC
head.
</bodyText>
<figureCaption confidence="0.99375">
Figure 3: Ogre’s output.
</figureCaption>
<bodyText confidence="0.945813764705882">
3Arrowed structures produced by Algas can also be
seen as a graph, having nodes containing graphs.
It might seem that we are keeping away infor-
mation in this step, but the new arrowing rela-
tion between chunk heads keeps the lost struc-
tures. Beside, as information about the direc-
tion of the arrows is kept, and the position of
each word is also kept in the graph, we are
still able to distinguish behaviours dependent
on word order for the following semantic task.
That is, both semantic relations and word order
are kept within our graph.
Ogre’s motivation is to converge different
structures into the same graph. For example,
after Ogre’s execution O Ritz e´ onde?, E´ onde
o Ritz? and Onde e´ o Ritz?, they all share the
same graph (appart from positions).
</bodyText>
<sectionHeader confidence="0.7344065" genericHeader="method">
4 From descriptions to the
algorithm input structures
</sectionHeader>
<bodyText confidence="0.9998721875">
In order to keep descriptions apart from pro-
cessing, arrow properties and Algas input struc-
tures are developed in parallel. Then, arrow
properties are formally mapped into Algas in-
put structures (see (Coheur, 2004) for details).
This decision allowed us to add computational
constraints to Algas input structures, leaving
descriptions untouchable.
In fact, in order to reduce the search space,
Algas has the option of letting the user control
the distance between the source and the target
of an arrow. This is particularly very usefull
to control PP attachments (in this case PC
attachments). Thus, if we want a PC to arrow
an NC that is at most n positions away, we
simply say:
</bodyText>
<equation confidence="0.464045">
PC S NC [{NC &lt;n PC}/]
</equation>
<bodyText confidence="0.999948125">
Notice that we could make an extension over
the arrow properties formalism in order to al-
low this kind of information. Nevertheless, it
is well know that in natural language there is
no fix distance between two elements. Adding a
distance constraint over arrow properties would
add procedural information to a repository re-
sulting from natural language observations.
</bodyText>
<sectionHeader confidence="0.992438" genericHeader="method">
5 Applications
</sectionHeader>
<bodyText confidence="0.999872696969697">
Both Algas and Ogre are part of a syntactic-
semantic interface, where the module responsi-
ble for the generation of logical forms is called
AsdeCopas (Coheur et al., 2003). This interface
has been applied in a semantic disambiguation
task of a set of quantifiers and also in question
interpretation.
Notice that, although arrows are not labeled,
the fact that we know its source, target and
direction, give us enough information to find
(or at least guess) a label for it. In fact, we
could add a label to the majority of the ar-
rows. For example, using the link-types from
the Link Grammar (Sleator and Temperley,
1993; Sleator, 1998), if an adverb connects an
adjective, this connection would be labeled EA,
if an adverb connects another adverb, the la-
bel would be EE. AsdeCopas can be used to
add this information to the graph. Neverthe-
less, the fact that we are using an unlabelled
connection serves languages as Portuguese par-
ticularly well. In Portuguese, it is not 100% sure
that we are able to identify the subject. For
example, we can say “O Tom´as come a sopa.”,
“Come a sopa o Tom´as.”, or even “A sopa come
o Tom´as.” having all the same (most probable)
interpretation: Thomas eats the soup. That is,
there is no misleading interpretation due to our
knowledge of the world: a man can eat a soup,
but a soup cannot eat a man. As so, arrow prop-
erties simply establish relations, and we leave to
semantic analysis the task of deciding what is
the nature of these relations.
</bodyText>
<sectionHeader confidence="0.999625" genericHeader="conclusions">
6 Conclusions
</sectionHeader>
<bodyText confidence="0.999929130434783">
We presented two modules – Algas and Ogre
– that build a dependency graph from a sur-
face analysis. Algas uses information from a
formalism called arrows properties. Neverthe-
less this formalism is independent from Algas
input structures, that can be enriched with in-
formation that limits the relations to establish.
In the future we want the user to be able to
control the constraints over Algas output. That
is, the user will have the option to chose if out-
put may contain arrows crossing or not.
For the moment the Susana-Algas-Ogre mod-
ules of the syntactic-semantic interface behave
without problems in the domain of question
interpretation. They apply successfully to an
elicited corpus of questions produced by N por-
tuguese speakers which were asked to produce
them simulating effective and natural questions.
Our next step is to try to use them incremen-
tally (A¨ıt-Mokhtar et al., 2002).
Also, another improvement will be over arrow
properties, as we want to organise them in a
hierarchy.
</bodyText>
<sectionHeader confidence="0.995574" genericHeader="acknowledgments">
7 Acknowledgements
</sectionHeader>
<bodyText confidence="0.971009333333333">
This paper was supported by FCT (Funda¸c˜ao
para a Ciˆencia e Tecnologia) and by Project
POSI/PLP/41319/2001 (FEDER).
</bodyText>
<sectionHeader confidence="0.988467" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.998162423076923">
Salah A¨ıt-Mokhtar, Jean-Pierre Chanod, and
Claude Roux. 2002. Robustness beyound
shallowness: incremental deep parsing. Nat-
ural Language Engineering, pages 121–144.
Fernando Batista and Nuno Mamede. 2002.
SuSAna: M´odulo multifuncional da an´alise
sint´actica de superficie. In Julio Gonzalo,
Anselmo Pe˜nas, and Antonio Ferr´andez, ed-
itors, Proc. Multilingual Information Access
and Natural Language Processing Workshop
(IBERAMIA 2002), pages 29–37, Sevilla,
Spain, November.
Gabriel G. B`es and Veronica Dahl. 2003. Bal-
anced parentheses in nl texts: a useful cue
in the syntax/semantics interface. In Nacy
Workshop on Prospects and Advances in the
Syntax/Semantics Interface.
Gabriel G. B`es and Caroline Hag`ege. 2001.
Properties in 5P. Technical report, GRIL,
Universit´e Blaise-Pascal, Clermont-Ferrand,
France, November.
Gabriel G. B`es, Veronica Dahl, Daniel Guil-
lot, Lionel Lamadon, Ioana Milutinovici, and
Joana Paulo. 2003. A parsing system for bal-
anced parentheses in nl texts. In CLIN’2003.
Gabriel G. B`es. 1999. La phrase verbal noyau
en fran¸cais. In in Recherches sur le fran¸cais
parl´e, volume 15, pages 273–358. Universit´e
de Provence, France.
Luisa Coheur, Nuno Mamede, and Gabriel G.
B´es. 2003. ASdeCopas: a syntactic-semantic
interface. In Epia, Beja, Portugal, Dezembro.
Springer-Verlag.
Luisa Coheur. 2004. A interface entre a sin-
taxe e a semˆantica no quadro das linguas
naturais. Ph.D. thesis, Instituto Superior
T´ecnico, Universidade T´ecnica de Lisboa,
Portugal, Universit´e Blaise-Pascal, France.
work in progress.
Caroline Hag`ege and Gabriel G. B`es. 2002. En-
coding and reusing linguistic information ex-
pressed by linguistic properties. In Proceed-
ings of COLING’2002, Taipei.
Caroline Hag`ege. 2000. Analyse Syntatic
Automatique du Portugais. Ph.D. thesis,
Universit´e Blaise Pascal, Clermont-Ferrand,
France.
Daniel Sleator and Davy Temperley. 1993.
Parsing english with a link grammar. In Pro-
ceedings of the Third International Workshop
on Parsing Technologies.
Daniel Sleator. 1998. Summary of link types.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.022723">
<title confidence="0.994065">From a Surface Analysis to a Dependency Structure</title>
<author confidence="0.978159">Luisa</author>
<affiliation confidence="0.944199">INESC-ID / Lisboa,</affiliation>
<email confidence="0.317347">Luisa.Coheur@l2f.inesc-id.pt</email>
<author confidence="0.618851">Nuno</author>
<affiliation confidence="0.994587">INESC-ID /</affiliation>
<address confidence="0.488166">Lisboa,</address>
<email confidence="0.627025">Nuno.Mamede@inesc-id.pt</email>
<author confidence="0.945524">G Gabriel</author>
<affiliation confidence="0.587245">GRIL / Univ. Clermont-Ferrand,</affiliation>
<email confidence="0.618549">BesGabriel@yahoo.fr</email>
<abstract confidence="0.9986515">This paper describes how we use the arrows properties from the 5P Paradigm to generate a dependency structure from a surface analysis. Besides the arrows properties, two modules, Algas and Ogre, are presented. Moreover, we show how we express linguistic descriptions away from parsing decisions.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Salah A¨ıt-Mokhtar</author>
<author>Jean-Pierre Chanod</author>
<author>Claude Roux</author>
</authors>
<title>Robustness beyound shallowness: incremental deep parsing. Natural Language Engineering,</title>
<date>2002</date>
<pages>121--144</pages>
<marker>A¨ıt-Mokhtar, Chanod, Roux, 2002</marker>
<rawString>Salah A¨ıt-Mokhtar, Jean-Pierre Chanod, and Claude Roux. 2002. Robustness beyound shallowness: incremental deep parsing. Natural Language Engineering, pages 121–144.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fernando Batista</author>
<author>Nuno Mamede</author>
</authors>
<title>SuSAna: M´odulo multifuncional da an´alise sint´actica de superficie.</title>
<date>2002</date>
<booktitle>Proc. Multilingual Information Access and Natural Language Processing Workshop (IBERAMIA 2002),</booktitle>
<pages>29--37</pages>
<editor>In Julio Gonzalo, Anselmo Pe˜nas, and Antonio Ferr´andez, editors,</editor>
<location>Sevilla, Spain,</location>
<contexts>
<context position="6534" citStr="Batista and Mamede, 2002" startWordPosition="1101" endWordPosition="1104">is empty between theme: NCi —*S VCk +{stackj = [ ]} As a result, if we consider again the example Quais os hot´eis que tˆem piscina, the NC hot´eis will not arrow the VC tˆem, because the stack constraint is not verified between them (there is only the introducer que). 3 Reaching the dependency structure 3.1 Surface analysis From existence and linearity properties (P2 of 5P) specifiyng chunks, it can be deduced what categories can or must start a chunk, and which ones can or must be the last one. Drawing on this linguistic information, chunks are detected in a surface analysis made by Susana (Batista and Mamede, 2002). As an example, consider the question Qual a maior praia do Algarve?(Which is the biggest beach in Algarve?). Susana outputs the following surface analysis (where PC stands for prepositional chunk): (Qual)IntC (a maior praia)NC (do Algarve)PC (?)Ponct 3.2 Algas Algas is the C++ program responsible for connecting chunks and the elements inside them, taking as input a structure that contains information from arrow properties and also information that can limit the search space (see section 4 from details about this). Additionally, as inside the majority of the chunks all the elements arrow the </context>
</contexts>
<marker>Batista, Mamede, 2002</marker>
<rawString>Fernando Batista and Nuno Mamede. 2002. SuSAna: M´odulo multifuncional da an´alise sint´actica de superficie. In Julio Gonzalo, Anselmo Pe˜nas, and Antonio Ferr´andez, editors, Proc. Multilingual Information Access and Natural Language Processing Workshop (IBERAMIA 2002), pages 29–37, Sevilla, Spain, November.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gabriel G B`es</author>
<author>Veronica Dahl</author>
</authors>
<title>Balanced parentheses in nl texts: a useful cue in the syntax/semantics interface.</title>
<date>2003</date>
<booktitle>In Nacy Workshop on Prospects and Advances in the Syntax/Semantics Interface.</booktitle>
<marker>B`es, Dahl, 2003</marker>
<rawString>Gabriel G. B`es and Veronica Dahl. 2003. Balanced parentheses in nl texts: a useful cue in the syntax/semantics interface. In Nacy Workshop on Prospects and Advances in the Syntax/Semantics Interface.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gabriel G B`es</author>
<author>Caroline Hag`ege</author>
</authors>
<date>2001</date>
<booktitle>Properties in 5P. Technical report, GRIL, Universit´e Blaise-Pascal,</booktitle>
<location>Clermont-Ferrand, France,</location>
<marker>B`es, Hag`ege, 2001</marker>
<rawString>Gabriel G. B`es and Caroline Hag`ege. 2001. Properties in 5P. Technical report, GRIL, Universit´e Blaise-Pascal, Clermont-Ferrand, France, November.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gabriel G B`es</author>
<author>Veronica Dahl</author>
<author>Daniel Guillot</author>
<author>Lionel Lamadon</author>
<author>Ioana Milutinovici</author>
<author>Joana Paulo</author>
</authors>
<title>A parsing system for balanced parentheses in nl texts.</title>
<date>2003</date>
<booktitle>In CLIN’2003.</booktitle>
<marker>B`es, Dahl, Guillot, Lamadon, Milutinovici, Paulo, 2003</marker>
<rawString>Gabriel G. B`es, Veronica Dahl, Daniel Guillot, Lionel Lamadon, Ioana Milutinovici, and Joana Paulo. 2003. A parsing system for balanced parentheses in nl texts. In CLIN’2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gabriel G B`es</author>
</authors>
<title>La phrase verbal noyau en fran¸cais.</title>
<date>1999</date>
<booktitle>In in Recherches sur le fran¸cais parl´e,</booktitle>
<volume>15</volume>
<pages>273--358</pages>
<location>France.</location>
<marker>B`es, 1999</marker>
<rawString>Gabriel G. B`es. 1999. La phrase verbal noyau en fran¸cais. In in Recherches sur le fran¸cais parl´e, volume 15, pages 273–358. Universit´e de Provence, France.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Luisa Coheur</author>
<author>Nuno Mamede</author>
<author>Gabriel G B´es</author>
</authors>
<title>ASdeCopas: a syntactic-semantic interface. In Epia,</title>
<date>2003</date>
<publisher>Springer-Verlag.</publisher>
<location>Beja, Portugal, Dezembro.</location>
<marker>Coheur, Mamede, B´es, 2003</marker>
<rawString>Luisa Coheur, Nuno Mamede, and Gabriel G. B´es. 2003. ASdeCopas: a syntactic-semantic interface. In Epia, Beja, Portugal, Dezembro. Springer-Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Luisa Coheur</author>
</authors>
<title>A interface entre a sintaxe e a semˆantica no quadro das linguas naturais.</title>
<date>2004</date>
<tech>Ph.D. thesis,</tech>
<institution>Instituto Superior T´ecnico, Universidade T´ecnica de Lisboa, Portugal, Universit´e Blaise-Pascal,</institution>
<note>work in progress.</note>
<contexts>
<context position="4323" citStr="Coheur, 2004" startWordPosition="719" endWordPosition="720">h must not occur); • n, m E I. Both R+, R− impose simple constraints over the arrows, such as symbols that should or should not occur within Z or linear order relations that should be satisfied between its constituents. As an example, the following arrow property says that within an interrogative phrase (Pint), an interrogative chunk (IntC) with an interrogative pronoun inside (pint) arrows a nominal chunk (NC) on its right (i � k), as long as there is no other nominal chunk between them (i � j � k). IntCi({pint}/) —*Pint NCk -{NCj} A more complex type of constraint is the “stack” constraint (Coheur, 2004). This constraint is based on the linguistically motivated work over balanced parentheses of (B`es and Dahl, 2003; B`es et al., 2003). Briefly, the idea behind that work is the following: given a sentence, if we introduce a left parentheses everytime we find a word such as que(that), se(if ), ...) – the introducers – and a right parentheses everytime we find an inflected verbal form1, at the end of the sentence, the number of left parentheses is equal to the number of right ones, and at any point of it, the number of left ones is equal or greater that the number of right ones (B`es and Dahl, 2</context>
<context position="9878" citStr="Coheur, 2004" startWordPosition="1688" endWordPosition="1689">nt on word order for the following semantic task. That is, both semantic relations and word order are kept within our graph. Ogre’s motivation is to converge different structures into the same graph. For example, after Ogre’s execution O Ritz e´ onde?, E´ onde o Ritz? and Onde e´ o Ritz?, they all share the same graph (appart from positions). 4 From descriptions to the algorithm input structures In order to keep descriptions apart from processing, arrow properties and Algas input structures are developed in parallel. Then, arrow properties are formally mapped into Algas input structures (see (Coheur, 2004) for details). This decision allowed us to add computational constraints to Algas input structures, leaving descriptions untouchable. In fact, in order to reduce the search space, Algas has the option of letting the user control the distance between the source and the target of an arrow. This is particularly very usefull to control PP attachments (in this case PC attachments). Thus, if we want a PC to arrow an NC that is at most n positions away, we simply say: PC S NC [{NC &lt;n PC}/] Notice that we could make an extension over the arrow properties formalism in order to allow this kind of inform</context>
</contexts>
<marker>Coheur, 2004</marker>
<rawString>Luisa Coheur. 2004. A interface entre a sintaxe e a semˆantica no quadro das linguas naturais. Ph.D. thesis, Instituto Superior T´ecnico, Universidade T´ecnica de Lisboa, Portugal, Universit´e Blaise-Pascal, France. work in progress.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Caroline Hag`ege</author>
<author>Gabriel G B`es</author>
</authors>
<title>Encoding and reusing linguistic information expressed by linguistic properties.</title>
<date>2002</date>
<booktitle>In Proceedings of COLING’2002,</booktitle>
<location>Taipei.</location>
<marker>Hag`ege, B`es, 2002</marker>
<rawString>Caroline Hag`ege and Gabriel G. B`es. 2002. Encoding and reusing linguistic information expressed by linguistic properties. In Proceedings of COLING’2002, Taipei.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Caroline Hag`ege</author>
</authors>
<title>Analyse Syntatic Automatique du Portugais.</title>
<date>2000</date>
<tech>Ph.D. thesis,</tech>
<institution>Universit´e Blaise Pascal,</institution>
<location>Clermont-Ferrand, France.</location>
<marker>Hag`ege, 2000</marker>
<rawString>Caroline Hag`ege. 2000. Analyse Syntatic Automatique du Portugais. Ph.D. thesis, Universit´e Blaise Pascal, Clermont-Ferrand, France.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Daniel Sleator</author>
<author>Davy Temperley</author>
</authors>
<title>Parsing english with a link grammar.</title>
<date>1993</date>
<booktitle>In Proceedings of the Third International Workshop on Parsing Technologies.</booktitle>
<contexts>
<context position="11364" citStr="Sleator and Temperley, 1993" startWordPosition="1939" endWordPosition="1942">plications Both Algas and Ogre are part of a syntacticsemantic interface, where the module responsible for the generation of logical forms is called AsdeCopas (Coheur et al., 2003). This interface has been applied in a semantic disambiguation task of a set of quantifiers and also in question interpretation. Notice that, although arrows are not labeled, the fact that we know its source, target and direction, give us enough information to find (or at least guess) a label for it. In fact, we could add a label to the majority of the arrows. For example, using the link-types from the Link Grammar (Sleator and Temperley, 1993; Sleator, 1998), if an adverb connects an adjective, this connection would be labeled EA, if an adverb connects another adverb, the label would be EE. AsdeCopas can be used to add this information to the graph. Nevertheless, the fact that we are using an unlabelled connection serves languages as Portuguese particularly well. In Portuguese, it is not 100% sure that we are able to identify the subject. For example, we can say “O Tom´as come a sopa.”, “Come a sopa o Tom´as.”, or even “A sopa come o Tom´as.” having all the same (most probable) interpretation: Thomas eats the soup. That is, there </context>
</contexts>
<marker>Sleator, Temperley, 1993</marker>
<rawString>Daniel Sleator and Davy Temperley. 1993. Parsing english with a link grammar. In Proceedings of the Third International Workshop on Parsing Technologies.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Daniel Sleator</author>
</authors>
<title>Summary of link types.</title>
<date>1998</date>
<contexts>
<context position="11380" citStr="Sleator, 1998" startWordPosition="1943" endWordPosition="1944">e are part of a syntacticsemantic interface, where the module responsible for the generation of logical forms is called AsdeCopas (Coheur et al., 2003). This interface has been applied in a semantic disambiguation task of a set of quantifiers and also in question interpretation. Notice that, although arrows are not labeled, the fact that we know its source, target and direction, give us enough information to find (or at least guess) a label for it. In fact, we could add a label to the majority of the arrows. For example, using the link-types from the Link Grammar (Sleator and Temperley, 1993; Sleator, 1998), if an adverb connects an adjective, this connection would be labeled EA, if an adverb connects another adverb, the label would be EE. AsdeCopas can be used to add this information to the graph. Nevertheless, the fact that we are using an unlabelled connection serves languages as Portuguese particularly well. In Portuguese, it is not 100% sure that we are able to identify the subject. For example, we can say “O Tom´as come a sopa.”, “Come a sopa o Tom´as.”, or even “A sopa come o Tom´as.” having all the same (most probable) interpretation: Thomas eats the soup. That is, there is no misleading</context>
</contexts>
<marker>Sleator, 1998</marker>
<rawString>Daniel Sleator. 1998. Summary of link types.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>