<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000218">
<title confidence="0.579717">
A Modal Temporal Logic for Reasoning about Change
</title>
<author confidence="0.911521">
Eric Mays
</author>
<affiliation confidence="0.997185666666667">
Department of Computer and Information Science
Moore School of Electrical Engineering/D2
University of Pennsylvania
</affiliation>
<address confidence="0.551266">
Philadelphia, PA 19104
</address>
<email confidence="0.462536">
ABSTRACT
</email>
<bodyText confidence="0.999946888888889">
We examine several behaviors for query
systems that become possible with the ability to
represent and reason about change in data bases:
queries about possible futures, queries about
alternative histories, and offers of monitors as
responses to queries. A modal temporal logic is
developed for this purpose. A completion axiom for
history is given and modelling strategies are
given by example.
</bodyText>
<sectionHeader confidence="0.951929" genericHeader="method">
I INTRODUCTION
</sectionHeader>
<bodyText confidence="0.99835895">
In this paper we present a modal temporal
logic that has been developed for reasoning about
change in data bases. The basic motivation is as
follows. A data base contains information about
the world: as the world changes, so does the data
base -- probably maintaining some description of
what the world was like before the change took
place. Moreover, if the world is constrained in
the ways it can change, so is the date base. We
are motivated by the benefits to be gained by
being able to represent those constraints and use
them to reason about the possible states of a data
base.
It is generally accepted that a natural
language query system often needs to provide more
than just the literal answer to a question. For
example, [Kaplan 821 presents methods for
correcting a questioner&apos;s misconceptions (as
reflected in a query) about the contents of a data
base, as well as providing additional information
in support of the literal answer to a query. By
enriching the data base model, Kaplan&apos;s work on
correcting misconceptions was extended in [Mays
801 to distinguish between misconceptions about
data base structure and data base contents. In
either case, however, the model was a static one.
By incorporating a model of the data base in which
a dynamic view is allowed, answers to questions
can include an offer to monitor for some condition
which might possibly occur in the future. The
following is an example:
U: &amp;quot;Is the Kitty Hawk in Norfolk?&amp;quot;
S: &amp;quot;No, shall I let you know when she is?&amp;quot;
1 This work is partially supported by a grant
from the National Science Foundation, NSF-MCS
81-07290.
But just having a dynamic view is not adequate, it
is necessary ITat the dynamic view correspond to
the possible evolution of the world that is
modelled. Otherwise, behaviors such as the
following might arise:
U: &amp;quot;Is New York less than 50 miles from
Philadelphia?&amp;quot;
S: &amp;quot;No, shall I let you know when it is?&amp;quot;
An offer of a monitor is said to be competent only
if the condition to be monitored can possibly
occur. Thus, in the latter example the offer is
not competent, while in the former it is. This
paper is concerned with developing a logic for
reasoning about change in data bases, and
assessing the impact of that capability on the
behavior of question answering systems. The
general area of extended interaction in data base
systems is discussed in [WJMM 831.
As just pointed out, the ability to represent
and reason about change in data bases affects the
range and quality of responses that may be
produced by a query system. Reasoning about prior
possiblity admits a class of queries dealing with
the future possibility of some event or state of
affairs at some time in the past. These queries
have the general form:
&amp;quot;Could it have been the case that p?&amp;quot;
This class of queries will be termed
counterhistoricals in an attempt to draw some
parallel with counterfactuals. The future
correlate of counterhistoricals, which one might
call futurities, are of the form:
&amp;quot;Can it be the case that p?&amp;quot;
i.e. in the sense of:
&amp;quot;Might it ever be the case that p?&amp;quot;
The most interesting aspect of this form of
question is that it admits the ability for a query
system to offer a monitor as a response to a
question for relevant information the system may
become aware of at some future time. A query
system can only competently offer such monitors
when it has this ability, since otherwise it
cannot determine if the monitor may ever be
satisfied.
</bodyText>
<sectionHeader confidence="0.918605" genericHeader="method">
II REPRESENTATION
</sectionHeader>
<bodyText confidence="0.9992306">
We have chosen to use a modal temporal logic.
There are two basic requirements which lead us
toward logic and away from methods such as Petri
nets. First, it may be desirable to assert that
some proposition is the case without necessarily
</bodyText>
<page confidence="0.998502">
38
</page>
<bodyText confidence="0.992714474576271">
specifying exactly when. Secondly, our knowledge
may be disjunctive. That is, our knowledge of
temporal situations may be incomplete and
indefinite, and as others have argued [Moore 82]
(as a recent example), methods based on formal
logic (though usually first-order) are the only
ones that have so far been capable of dealing with
problems of this nature.
In contrast to first-order representations,
modal temporal logic makes a fundamental
distinction between variability over time (as
expressed by modal temporal operators) and
variability in a state (as expressed using
propositional or first-order languages). Modal
temporal logic also reflects the temporally
indefinite structure of language in a way that is
more natural than the commaon method of using
state variables and constants in a first-order
logic. On the side of first-order logic, however,
is expressive power that is not necessarily
present in modal temporal logic. (But, see [Kamp
681 and [GPSS 80] for comparisons of the
expressive power of modal temporal logics with
first-order theories.)
There are several possible structures that
one could reasonably imagine over states in time.
The one we have in mind is discrete, backwards
linear, and infinite in both directions. We allow
branching into the future to capture the idea that
it is open, but the past is determined. Due to
the nature of the intended application, we also
have assumed that time is discrete. It should be
stressed that this decision is not motivated by
the belief that time itself is discrete, but
rather by the data base application. Furthermore,
in cases where it is necessary for the temporal
structure to be dense or continuous, there is no
immediate argument against modal temporal logic in
general. (That is, one could develop a modal
temporal logic that models a continuous structure
of time [RU 71].)
A modal temporal structure is composed of a
set of: states. Each state is a set of propositions
which are true of that state. States are related
by an immediate predecessor-successor relation. A
branch of time is defined by taking some possible
sequence of states accessible over this relation
from a given state. The future fragment of the
logic is based on the unified branching temporal
logic of [BMP 81], which introduces branches and
quantifies over them to make it possible to
describe properties on some or all futures. This
is extended with an &amp;quot;until&amp;quot; operator (as in [Kamp
68], [GPSS 80]) and a past fragment. Since the
structures are backwards linear the existential
and universal operators are merged to form a
linear past fragment.
A. Syntax
Formulas are composed from the symbols,
</bodyText>
<listItem confidence="0.7430915">
- A set of atomic propositions.
- Boolean connectives: v,
- Temporal operators: AX (every next), EX
(some next), AG (every always), EG (some
always), AF (every eventually), EF (some
eventually), AU (every until), EU (some
until), L (immediately past), P (sometime
past), H (always past), S (since). AU, EU,
and S are binary; the others are unary.
For the operators composed of two symbols,
the first symbol (&amp;quot;A&amp;quot; or &amp;quot;E&amp;quot;) can be
thought of as quantifying universally or
existentially over branches in time; the
second symbol as quantifying over states
within the branch. Since branching is not
allowed into the past, past operators have
only one symbol.
using the rules,
- If p6R, then p is a formula.
- If p and q are formulas, then (-p),
(p v q) are formulas.
- If m is a unary temporal operator and p is
a formula, then (m p) is a formula.
- If m is a binary temporal operator and p
and q are formulas, then (p m q) is a
formula.
Parentheses will occasionally be omitted, and E.,
-4, 4-4 used as abbreviations. (In the next
section: &amp;quot;Ax&amp;quot; should be read as the universal
quantifier over the variable x, &amp;quot;Ex&amp;quot; as the
existential quantifier over x.)
B. Semantics
</listItem>
<bodyText confidence="0.998763">
A temporal structure T is a triple (S,Tt&apos;, R)
where,
</bodyText>
<listItem confidence="0.8538057">
- S is a set of states.
-fr:(S -4 A is an assignment of atomic
propositions to states.
- R C (S x S) is an accessibility relation
on S. Each state is required to have at
least one successor and exactly one
predecessor -- i.e., As (Et (sRt) &amp; E!t
(tRs)).
Define b to be an s-branch
b = (..., s-1, s=s0, sl, ...) such that siRsi+1.
</listItem>
<bodyText confidence="0.986047375">
The relation &amp;quot;&gt;&amp;quot; is the transitive closure of
R.
The satisfaction of a formula p at a state s
In a structure T, &lt;T,s&gt; p, is defined as
follows:
&lt;T,s&gt;1= p iff pefks), for PeFP
&lt;T,s&gt;1= -p iff not &lt;T,s&gt;I=p
&lt;T,s&gt;I= p v q iff &lt;T,s&gt;1=p or &lt;T,s&gt;I=q
</bodyText>
<page confidence="0.996417">
39
</page>
<bodyText confidence="0.986082314285714">
&lt;T,s&gt;i= AGp iff AbAt((teb &amp; t&gt;s) -4 &lt;T,01=p)
(p is true at every time of every future)
&lt;T,s&gt;I= AFp iff AbEt(teb &amp; t&gt;s &amp; &lt;T,t&gt;I=p)
(p is true at some time of every future)
&lt;T,s&gt;I= pAUq iff
AbEt(teb &amp; t&gt;s &amp; &lt;T,01=q &amp;
AC((t&apos;61, &amp; s&lt;C&lt;t) -4 &lt;T,C&gt;l=p)))
(q is true at some time of every future and until
q is true p is true)
&lt;T,s&gt;l= AXp iff At(sRt &lt;T,t&gt;I=p)
(p is true at every immediate future)
&lt;T,s&gt;I= EGp iff EbAt((t613 &amp; t&gt;s) -4 &lt;T,01=p)
(p is true at every time of some future)
&lt;T,s&gt;l= EFp iff EbEt(teb &amp; t&gt;s &amp; &lt;T,Ol=p)
(p is true at some time of some future)
&lt;T,s&gt;I= EXp iff Et(sRt &amp; &lt;T,01=P)
(p is true at some immediate future)
&lt;T,s&gt;I= pEUq iff
EbEt(teb &amp; t&gt;s &amp; &lt;T,01=q &amp;
At&apos;((CTb &amp; s&lt;t&apos;&lt;t) -4 &lt;T,C&gt;f=p)))
(q is true at some time of some future and in that
future until q is true p is true)
&lt;T,s&gt;I= Hp iff AbAt((teb &amp; t&lt;s) &lt;T,t&gt;1=p)
(p is true at every time of the past)
&lt;T,s&gt;I= Pp iff AbEt(teb &amp; t&lt;s &amp; &lt;T,01=P)
(p is true at some time of the past)
&lt;T,s&gt;I= Lp iff At(tRs -4 &lt;T,OI=p)
(p is true at the immediate past)
&lt;T,s&gt;I= pSq iff
AbEt(teb &amp; t&lt;s &amp; &lt;T,t&gt;I=q &amp;
At&apos;((t&apos;eb &amp; s&gt;t&apos;&gt;t) &lt;T,C&gt;I=p)))
(q is true at some time of the past and since q is
true p is true)
A formula p is valid iff for every structure
T and every state s in T, &lt;T,s&gt; I= p.
</bodyText>
<sectionHeader confidence="0.96315" genericHeader="method">
III MODELLING CHANGE IN KNOWLEDGE BASES
</sectionHeader>
<bodyText confidence="0.985405767123288">
As noted earlier, this logic was developed to
reason about change in data bases. Although
ultimately the application requires extension to a
first-order language to better express variability
within a state, for now we are restricted to the
propositional case. Such an extension is not
without problems, but should be manageable.
The set of propositional variables for
modelling change in data bases is divided into two
classes. A state proposition asserts the truth of
some atomic condition. An event proposition
associates the occurence of an event with the
state in which it occurs. The idea is to impose
constraints on the occurence of events and then
derive the appropriate state description. To be
specfic, let Osl...psn be state propositions and
Gel...0em be event propositions. If PHI is a
boolean formula of state propositions, then
formulas of the form:
(PHI -4 EX pei) are event constraints. To derive
state descriptions from events frame axioms are
required:
(Oei -4 ((1, PHI1) -4 PHI2)),
where P11I1 and P11I2 are boolean Formulas of state
propositions. In the blocks world, and event
constraint would be that if block A was clear and
block B was clear then move A onto B is a next
possible event:
((cleartop(A) &amp; cleartop(B)) -4 EX move(A,B)).
Two frame axioms are:
(move(A,B) -4 on(A,B)) and
(move(A,B) -4 ((L on(C,D)) on(C,D))).
If the modelling strategy was left as just
outlined, nothing very significant would have been
accomplished. Indeed, a simpler strategy would be
hard to imagine, other than requiring that the
state formulas be a complete description. This can
be improved in two non-trivial ways. The first is
that the conditions on the transitions may
reference states earlier than the last one.
Secondly, we may require that certain conditions
might or must eventually happen, but not
necessarily next. As mentioned earlier, these
capabilities are important considerations for us.
By placing biconditionals on the event
constraints, it can be determined that some
condition may never arise, or from knowledge of
some event a reconstruction of the previous state
may be obtained.
The form of the frame axioms may he inverted
using the until operator to obtain a form that is
perhaps more intuitive. As specified above the
form of the frame axioms will yield identical
previous and next state propositions for those
events that have no effect on them. The standard
example from the blocks world is that moving a
block does not alter the color of the block. If
there are a lot of events like move that don&apos;t
change block color, there will be a lot of frame
axioms around stating that the events don&apos;t change
the block color. But if there is only one event,
say paint, that changes the color of the block,
the &amp;quot;every until&amp;quot; (AU) operator can be used to
state that the color of the block stays the same
until it is painted. This strategy works best if
we maintain a single event condition for each
state; i.e. no more than a single event can occur
in each state. For each application, a decision
must be made as to how to best represent the frame
axioms. Of course, if the world is very
complicated, there will be a lot of complicated
frame axioms. I see no easy way around this
problem in this logic.
</bodyText>
<page confidence="0.996182">
40
</page>
<bodyText confidence="0.996574840909091">
A. Completion of History
As previously mentioned, we assume that the
past is determined (i.e. backwards linear).
However this does not imply that our knowledge of
the past is complete. Since in some cases we may
wish to claim complete knowledge with respect to
one or more predicates in the past, a completion
axiom is developed for an intuitively natural
conception of history. Examples of predicates for
which our knowledge might be complete are
presidential inaugurations, employees of a
company, and courses taken by someone in college.
In a first order theory, T, the completion
axiom with respect to the predicate Q where
(Q cl)...(Q cn) are the only occurences of Q in T
is:
Ax((Q x) 4-&gt; x=c1 v...v x-cn). From right to left
on the biconditional this just says what the
orginal theory T did, that Q is true of cl...cn.
The completion occurs from left to right,
asserting that cl...cn are the only constants for
which Q holds. Thus for some c&apos; which is not equal
to any of cl...cn, it is provable in the completed
theory that -(Q c&amp;quot;), which was not provable in the
original theory T. This axiomcaptures our
intuitive notions about Q. The completion axiom
for temporal logic is developed by introducing
time propositions. The idea is that a conjunct of
a time proposition, T, and some other proposition,
Q, denotes that Q is true at time T. If time
propositions are linearly ordered, and Q occurs
only in the form
P(Q &amp; Ti) &amp;...&amp; P(Q &amp; Tn) in some theory M, then
the history completion axiom for M with respect to
Q is
H(Q Ti v...v Tn). Analogous to the first-
order completion axiom, the direction from left to
right is the completion of Q. An equivalent first-
order theory to M in which each temporal
proposition Ti is a first-order constant ti and Q
is a monadic predicate,
(Q ti) &amp;...&amp; (Q tn), has the first-order
completion axiom (with Q restricted to time
constants of the past, where tO is now):
</bodyText>
<figure confidence="0.845620666666667">
Ax&lt;tO ((Q x) 4-4 x=t1 v...v x=tn).
B. Example
T-reg (AX T-add)
T-add (AX T-drop) - drop follows add
T-drop 4-4 (AX T-enroll) - enroll follows drop
T-enroll 4-4 (AX T-break) - break follows enroll
((T-reg v T-add) &amp; -Qs-reg &amp; -(P Qe-pass)) 4-4
(EX Qe-reg) - if the period is reg or add and
a student is not registered and has not
</figure>
<bodyText confidence="0.98971324">
passed the course then the student may next
register for the course
((T-add v T-drop) &amp; Qs-reg) 4-4 (EX Qe-drop) - if
the period is add or drop and a student is
registered for a course then the student may
next drop the course
(T-enroll &amp; Qs-reg) E-* (EX Qe-pass)) - if the
period is enroll and a student is registered
for a course then the student may next pass
the course
(T-enroll &amp; Qs-reg) 4-* (EX Qe-fail)) - if the
period is enroll and a student is registered
for a course then the student may next fail
the course
Qe-reg (Qs-reg AU (Qe-pass v Qe-fail v
Qe-drop)) - if a student registers for a
course then eventually the student will pass
or fail or drop the course and until then the
student will be registered for the course
((L -Qs-reg) &amp; -Qe-reg) -* -Qs-reg) - not
registering maintains not being registered
AX(Qe-reg &amp; Qe-pass &amp; Qe-fail &amp; Qe-drop &amp; Qe-null)
- one of these events must next happen
-(Qe-i &amp; Qe-j), for -i=j (e.g. -(Qe-reg &amp; Qe-
pass)) - but only one
</bodyText>
<sectionHeader confidence="0.772692" genericHeader="method">
IV COUNTERHISTORICALS
</sectionHeader>
<bodyText confidence="0.999465586206897">
The propositional variables T-reg, T-add, T-
drop, T-enroll, and T-break are time points
intended to denote periods in the academic semster
on which certain activities regarding enrollment
for courses is dependent. The event proposition
are Qe-reg, Qe-pass, Qe-fail, and Qe-drop; for
registering for a course, passing a course,
failing a course, and dropping a couirse,
respectively. The only state is Qs-reg, which
means that a student is registered for a course.
2[Clark 781 contains a general discussion of
predicate completion. [Reiter 821 discusses the
completion axiom with respect to circumscription.
A counterhistorical may be thought of as a
special case of a counterfactual, where rather
than asking the counterfactual, &amp;quot;If kangaroos did
not have tails would they topple over?&amp;quot;, one asks
instead &amp;quot;Could I have taken CSE110 last
semester?&amp;quot;. That is, counterfactuals suppose that
the present state of affairs is slightly different
and then question the consequences.
Counterhistoricals, on the other hand, question
how a course of events might have proceeded
otherwise. If we picture the underlying temporal
structure, we see that although there are no
branches into the past, there are branches from
the past into the future. These are alternative
histories to the one we are actually in.
Counterhistoricals explore these alternate
</bodyText>
<page confidence="0.998634">
41
</page>
<bodyText confidence="0.999666928571429">
histories.
Intuitively, a counterhistorical may be
evaluated by &amp;quot;rolling back&amp;quot; to some previous state
and then reasoning forward, disregarding any
events that actually took place after that state,
to determine whether the specified condition might
arise. For the question, &amp;quot;Could I have registered
for CSE110 last semester?&amp;quot;, we access the state
specified by last semester, and from that state
description, reason forward regarding the
possibility of registering for CSE110.
However, a counterhistorical is really only
interesting if there is some way in which the
course of events is constrained. These constraints
may be legal, physical, moral, bureaucratic, or a
whole host of others. The set of axioms in the
previous section is one example. The formalism
does not provide any facility to distinguish
between various sorts of constraints. Thus the
mortal inevitability that everyone eventually dies
is given the same importance as a university rule
that you can&apos;t take the same course twice.
In the logic, the general counterhistorical
has the form: P(EFp). That is, is there some time
in the past at which there is a future time when p
might possibly be true. Constraints may be placed
on the prior time:
P(q &amp; EFp), e.g. &amp;quot;When I was a sophomore, could I
have taken Phil 6?&amp;quot;. One might wish to require
that some other condition still be accessible:
P(EF(p &amp; EFq)), e.g. &amp;quot;Could I have taken CSE220
and then CSE110?&amp;quot;; or that the counterhistorical
be immediate from the most recent state:
L(EXp). (The latter is interesting in what it has
to say about possible alternatives to -- or the
inevitability of -- what is the case now. [WM 831
shows its use in recognizing and correcting event-
related misconceptions.) For example, in the
registration domain if we know that someone has
passed a course then we can derive from the axioms
above the counterhistorical that they could have
not passed:
</bodyText>
<equation confidence="0.7844795">
((P Qe-pass) -* P(EF-Qe-pass).
V FUTURITIES
</equation>
<bodyText confidence="0.9986965">
stronger forms of future possibility can be
derived it would be desirable to provide
information to that effect.
For example, if a student is not registered
for a course and has not passed the course and the
time wasprior to enrollment, a monitor for the
student registering would be competently made
given some question about registration, since
((-Qs-reg &amp; -(P Qe-pass) &amp; AX(AF Te))
(EF Qe-reg)). However, if the student had
previously passed the course, the monitor offer
would not be competent, since
((-Qs-reg &amp; (P Qe-pass) &amp; A.X(AF Te))
-(EF Qe-reg)).
Note that if a monitor was explicity
requested, &amp;quot;Let me know when p happens,&amp;quot; a
futurity may be used to determine whether p might
ever happen. In addition to the processing
efficiency gained by discarding monitors that can
never be satisfied, one is also in a position to
correct a user&apos;s mistaken belief that p might ever
happen, since in order to make such a request s/he
must believe p could happen. Corrections of this
sort arise from intensional failures of
presumptions in the sense of [Mays 80] and [WM
81]. If at some future time From the monitor
request, due to some intervening events p can no
longer happen, but was originally possible, an
extensional failure of the presumption (in the
sense of (Kaplan 821) might be said to have
occurred.
The application of the constraints when
attempting to determine the validity of an update
to the data base is important to the determination
of monitor competence. The approach we have
adopted is to require that when some formula p is
considered as a potential addition to the data
base that it be provable that EXp. Alternatively
one could just require that the update not be
Inconsistent, that is not provable that AX-p. The
former approach is preferred since it does not
make any requirement on decidability. Thus, in
order to say that a monitor for some condition p
is competent, it must be provable that EFp.
</bodyText>
<sectionHeader confidence="0.921395" genericHeader="method">
VI DISCUSSION
</sectionHeader>
<bodyText confidence="0.999983848484848">
A query regarding future possibility has the
general logical form: EFp. That is, is there some
future time in which p is true. The basic
variations are: Alp, must p eventually be true;
EGp, can p remain true; AGp, must p remain true.
These can be nested to produce infinite variation.
However, answering direct questions about future
possibility is not the only use to be made of
futurities. In addition, futurities permit the
query system to competently offer monitors as
responses to questions. (A monitor watches for
some specified condition to arise and then
performs some action, usually notification that
the condition has occurred.) A monitor can only be
offered competently if it can be shown that the
condition might possibly arise, given the present
state of the data base. Note that if any of the
This work has been influenced most strongly
by work within theory of computation on proving
program correctness ([BMP 811 and (GPSS 80]) and
within philosophy on temporal logic [RU 71]. The
work within Al that is most relevant is that of
[McDermott 821. Two of McDermott&apos;s major points
are regarding the openess of the future and the
continuity of time. With the first of these we are
in agreement, but on the second we differ. This
difference is largely due to the intended
application of the logic. Ours is applied to
changes in data base states (which are discrete),
whereas McDermott&apos;s is physical systems (which are
continuous). But even within the domain of
physical systems it may be worthwhile to consider
discrete structures as a tool for abstraction, for
</bodyText>
<page confidence="0.996502">
42
</page>
<bodyText confidence="0.999916882352941">
which computational methods may prove to be more
tractable. At least by considering modal temporal
logics we may be able to gain some insight into
the reasoning process whether over discrete or
continuous structures.
We have not made at serious effort towards
implementation thus far. A tableau based theorem
prover has been implemented for the future
fragment based on the procedure given in [BMP 811.
It is able to do problems about one—half the size
of the example given here. Based on this limited
experience we have a few ideas which might improve
its abilities. Another procedure based on the
tableau method which is based on ideas from (BMP
811 and [RU 71] has been developed but we are not
sufficiently confident in its correctness to
present it at this point.
</bodyText>
<sectionHeader confidence="0.990872" genericHeader="acknowledgments">
ACKNOWLEDGEMENTS
</sectionHeader>
<bodyText confidence="0.9714532">
I have substantially benefited from comments,
suggestions, and discussions with Aravind Joshi,
Sitaram Lanka, Kathy McCoy, Gopalan Nadathur,
David Silverman, Bonnie Webber, and Scott
Weinstein.
</bodyText>
<sectionHeader confidence="0.981917" genericHeader="references">
REFERENCES
</sectionHeader>
<reference confidence="0.9999648">
[BMP 81] M. Ben—Ari, Z. Manna, A. Pneuli, &amp;quot;The
Temporal Logic of Branching Time,&amp;quot; Eighth ACM
Symposium on Principles of Programming
Languages, Williamsburg, Va., January 1981.
[Clark 78] K.L. Clark, &amp;quot;Negation as Failure,&amp;quot; in
Logic and Data Bases, H. Gallaire and
J. Minker (eds.), Plenum, New York.
[GPSS 801 D. Gabbay, A. Pneuli, S. Shelah,
J. Stavi, &amp;quot;On the Temporal Analysis of
Fairness, Seventh ACM Symposium on Principles
of Programming Languages, 1980.
[Kamp 68] J.A.W. Kamp, Tense Logic and the Theory
of Linear Order, PhD Thesis, UCLA, 1968.
(Kaplan 821 S.J. Kaplan, &amp;quot;Cooperative Responses
from a Portable Natural Language Query
System,&amp;quot; Artificial Intelligence (19, 2),
October 1982.
[Mays 80] E. Mays, &amp;quot;Failures in Natural Language
Systems: Applications to Data Base Query
Systems,&amp;quot; Proceedings of AAAI 80, Stanford,
Ca., August 1980.
[Mays 82] E. Mays, &amp;quot;Monitors as Responses to
Questions: Determining Competence,&amp;quot;
Proceedings of AAAI 82, Pittsburgh, Pa.,
August 1982.
[McDermott 82] D. McDermott, &amp;quot;A Temporal Logic for
Reasoning About Processes and Plans,&amp;quot;
Cognitive Science (6), 1982.
[Moore 821 R.C. Moore, &amp;quot;The Role of Logic in
Knowledge Representation and Commensense
Reasoning,&amp;quot; Proceedings of AAAI 82,
Pittsburgh, Pa., August 1982.
[RU 71] N. Rescher and A. Urquhart, Temporal
Logic, Springer—Verlag, New York, 1971.
[Reiter 82] R. Reiter, &amp;quot;Circumscription Implies
Predicate Completion (Sometimes),&amp;quot;
Proceedings of AAAI 82, Pittsburgh, Pa.,
August 1982.
[WJMM 83] B. Webber, A. Joshi, E. Mays,
K. McKeown, &amp;quot;Extended Natural Language Data
Base Interactions,&amp;quot; International Journal of
Computers and Mathematics, Spring 83.
[WM 83] B. Webber and E. Mays, &amp;quot;Varieties of User
Misconception: Detection and Correction&amp;quot;,
Proceedings of IJCAI 83.
</reference>
<page confidence="0.999833">
43
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.803123">
<title confidence="0.999687">A Modal Temporal Logic for Reasoning about Change</title>
<author confidence="0.999857">Eric Mays</author>
<affiliation confidence="0.940932">Department of Computer and Information Science Moore School of Electrical Engineering/D2 University of Pennsylvania</affiliation>
<address confidence="0.999642">Philadelphia, PA 19104</address>
<abstract confidence="0.9975276">We examine several behaviors for query systems that become possible with the ability to represent and reason about change in data bases: queries about possible futures, queries about alternative histories, and offers of monitors as responses to queries. A modal temporal logic is developed for this purpose. A completion axiom for history is given and modelling strategies are given by example.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>M Ben—Ari</author>
<author>Z Manna</author>
<author>A Pneuli</author>
</authors>
<title>The Temporal Logic of Branching Time,&amp;quot;</title>
<date>1981</date>
<booktitle>Eighth ACM Symposium on Principles of Programming Languages,</booktitle>
<location>Williamsburg, Va.,</location>
<marker>[BMP 81]</marker>
<rawString>M. Ben—Ari, Z. Manna, A. Pneuli, &amp;quot;The Temporal Logic of Branching Time,&amp;quot; Eighth ACM Symposium on Principles of Programming Languages, Williamsburg, Va., January 1981.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K L Clark</author>
</authors>
<title>Negation as Failure,&amp;quot; in Logic and Data Bases,</title>
<date>1980</date>
<booktitle>On the Temporal Analysis of Fairness, Seventh ACM Symposium on Principles of Programming Languages,</booktitle>
<tech>GPSS 801</tech>
<editor>H. Gallaire and J. Minker (eds.),</editor>
<publisher>Plenum,</publisher>
<location>New York.</location>
<marker>[Clark 78]</marker>
<rawString>K.L. Clark, &amp;quot;Negation as Failure,&amp;quot; in Logic and Data Bases, H. Gallaire and J. Minker (eds.), Plenum, New York. [GPSS 801 D. Gabbay, A. Pneuli, S. Shelah, J. Stavi, &amp;quot;On the Temporal Analysis of Fairness, Seventh ACM Symposium on Principles of Programming Languages, 1980.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J A W Kamp</author>
</authors>
<title>Tense Logic and the Theory of Linear Order,</title>
<date>1968</date>
<journal>Kaplan</journal>
<tech>PhD Thesis,</tech>
<volume>821</volume>
<location>UCLA,</location>
<marker>[Kamp 68]</marker>
<rawString>J.A.W. Kamp, Tense Logic and the Theory of Linear Order, PhD Thesis, UCLA, 1968. (Kaplan 821 S.J. Kaplan, &amp;quot;Cooperative Responses from a Portable Natural Language Query System,&amp;quot; Artificial Intelligence (19, 2), October 1982.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Mays</author>
</authors>
<title>Failures in Natural Language Systems: Applications to Data Base Query Systems,&amp;quot;</title>
<date>1980</date>
<booktitle>Proceedings of AAAI 80,</booktitle>
<location>Stanford, Ca.,</location>
<marker>[Mays 80]</marker>
<rawString>E. Mays, &amp;quot;Failures in Natural Language Systems: Applications to Data Base Query Systems,&amp;quot; Proceedings of AAAI 80, Stanford, Ca., August 1980.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Mays</author>
</authors>
<title>Monitors as Responses to Questions: Determining Competence,&amp;quot;</title>
<date>1982</date>
<booktitle>Proceedings of AAAI 82,</booktitle>
<location>Pittsburgh, Pa.,</location>
<marker>[Mays 82]</marker>
<rawString>E. Mays, &amp;quot;Monitors as Responses to Questions: Determining Competence,&amp;quot; Proceedings of AAAI 82, Pittsburgh, Pa., August 1982.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D McDermott</author>
</authors>
<title>A Temporal Logic for Reasoning About Processes and Plans,&amp;quot;</title>
<date>1982</date>
<journal>Cognitive Science</journal>
<booktitle>Proceedings of AAAI 82,</booktitle>
<volume>6</volume>
<location>Pittsburgh, Pa.,</location>
<marker>[McDermott 82]</marker>
<rawString>D. McDermott, &amp;quot;A Temporal Logic for Reasoning About Processes and Plans,&amp;quot; Cognitive Science (6), 1982. [Moore 821 R.C. Moore, &amp;quot;The Role of Logic in Knowledge Representation and Commensense Reasoning,&amp;quot; Proceedings of AAAI 82, Pittsburgh, Pa., August 1982.</rawString>
</citation>
<citation valid="true">
<authors>
<author>N Rescher</author>
<author>A Urquhart</author>
</authors>
<title>Temporal Logic,</title>
<date>1971</date>
<publisher>Springer—Verlag,</publisher>
<location>New York,</location>
<marker>[RU 71]</marker>
<rawString>N. Rescher and A. Urquhart, Temporal Logic, Springer—Verlag, New York, 1971.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Reiter</author>
</authors>
<title>Circumscription Implies Predicate Completion (Sometimes),&amp;quot;</title>
<date>1982</date>
<booktitle>Proceedings of AAAI 82,</booktitle>
<location>Pittsburgh, Pa.,</location>
<marker>[Reiter 82]</marker>
<rawString>R. Reiter, &amp;quot;Circumscription Implies Predicate Completion (Sometimes),&amp;quot; Proceedings of AAAI 82, Pittsburgh, Pa., August 1982.</rawString>
</citation>
<citation valid="false">
<authors>
<author>B Webber</author>
<author>A Joshi</author>
<author>E Mays</author>
<author>K McKeown</author>
</authors>
<title>Extended Natural Language Data Base Interactions,&amp;quot;</title>
<journal>International Journal of Computers and Mathematics, Spring</journal>
<volume>83</volume>
<marker>[WJMM 83]</marker>
<rawString>B. Webber, A. Joshi, E. Mays, K. McKeown, &amp;quot;Extended Natural Language Data Base Interactions,&amp;quot; International Journal of Computers and Mathematics, Spring 83.</rawString>
</citation>
<citation valid="false">
<authors>
<author>B Webber</author>
<author>E Mays</author>
</authors>
<title>Varieties of User Misconception: Detection and Correction&amp;quot;,</title>
<booktitle>Proceedings of IJCAI 83.</booktitle>
<marker>[WM 83]</marker>
<rawString>B. Webber and E. Mays, &amp;quot;Varieties of User Misconception: Detection and Correction&amp;quot;, Proceedings of IJCAI 83.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>