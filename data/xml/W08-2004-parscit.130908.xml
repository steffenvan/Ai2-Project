<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000084">
<title confidence="0.9987465">
Encoding Tree Pair-based Graphs in Learning Algorithms:
the Textual Entailment Recognition Case
</title>
<author confidence="0.997082">
Alessandro Moschitti
</author>
<affiliation confidence="0.997401">
DISI, University of Trento
</affiliation>
<address confidence="0.9342555">
Via Sommarive 14
38100 POVO (TN) - Italy
</address>
<email confidence="0.996442">
moschitti@dit.unitn.it
</email>
<author confidence="0.956139">
Fabio Massimo Zanzotto
</author>
<affiliation confidence="0.972625">
DISP, University of Rome “Tor Vergata”
</affiliation>
<address confidence="0.945615">
Via del Politecnico 1
00133 Roma, Italy
</address>
<email confidence="0.995105">
zanzotto@info.uniroma2.it
</email>
<sectionHeader confidence="0.996583" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999951416666667">
In this paper, we provide a statistical ma-
chine learning representation of textual en-
tailment via syntactic graphs constituted
by tree pairs. We show that the natural way
of representing the syntactic relations be-
tween text and hypothesis consists in the
huge feature space of all possible syntac-
tic tree fragment pairs, which can only be
managed using kernel methods. Experi-
ments with Support Vector Machines and
our new kernels for paired trees show the
validity of our interpretation.
</bodyText>
<sectionHeader confidence="0.998779" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.99967775">
Recently, a lot of valuable work on the recogni-
tion of textual entailment (RTE) has been carried
out (Bar Haim et al., 2006). The aim is to detect
implications between sentences like:
</bodyText>
<equation confidence="0.812476333333333">
T1 ⇒ H1
T1 “Wanadoo bought KStones”
H1 “Wanadoo owns KStones”
</equation>
<bodyText confidence="0.9999743">
where T1 and H1 stand for text and hypothesis, re-
spectively.
Several models, ranging from the simple lexi-
cal similarity between T and H to advanced Logic
Form Representations, have been proposed (Cor-
ley and Mihalcea, 2005; Glickman and Dagan,
2004; de Salvo Braz et al., 2005; Bos and Mark-
ert, 2005). However, since a linguistic theory able
to analytically show how to computationally solve
the RTE problem has not been developed yet, to
</bodyText>
<note confidence="0.723294">
© 2008. Licensed under the Creative Commons
</note>
<footnote confidence="0.967220666666667">
Attribution-Noncommercial-Share Alike 3.0 Unported li-
cense (http://creativecommons.org/licenses/by-nc-sa/3.0/).
Some rights reserved.
</footnote>
<bodyText confidence="0.999593828571428">
design accurate systems, we should rely upon the
application of machine learning. In this perspec-
tive, TE training examples have to be represented
in terms of statistical feature distributions. These
typically consist in word sequences (along with
their lexical similarity) and the syntactic structures
of both text and hypothesis (e.g. their parse trees).
The interesting aspect with respect to other natural
language problems is that, in TE, features useful
at describing an example are composed by pairs of
features from Text and Hypothesis.
For example, using a word representation, a text
and hypothesis pair, (T, H), can be represented
by the sequences of words of the two sentences,
i.e. (t1,.., tn) and (h1,.., hm), respectively. If we
carry out a blind and complete statistical correla-
tion analysis of the two sequences, the entailment
property would be described by the set of subse-
quence pairs from T and H, i.e. the set R =
{(st, sh) : st = (ti1, .., til), sh = (hj1, .., hjr), l &lt;
n, r &lt; m}. The relation set R constitutes a
naive and complete representation of the example
(T, H) in the feature space {(v, w) : v, w E V ∗},
where V is the corpus vocabulary1.
Although the above representation is correct and
complete from a statistically point of view, it suf-
fers from two practical drawbacks: (a) it is expo-
nential in V and (b) it is subject to high degree of
data sparseness which may prevent to carry out ef-
fective learning. The traditional solution for this
problem relates to consider the syntactic structure
of word sequences which provides their general-
ization.
The use of syntactic trees poses the problem
of representing structures in learning algorithms.
</bodyText>
<footnote confidence="0.995814333333333">
1V ∗ is larger than the actual space, which is the one of
all possible subsequences with gaps, i.e. it only contains all
possible concatenations of words respecting their order.
</footnote>
<page confidence="0.972779">
25
</page>
<note confidence="0.69515">
Coling 2008: Proceedings of 3rd Textgraphs workshop on Graph-Based Algorithms in Natural Language Processing, pages 25–32
Manchester, August 2008
</note>
<bodyText confidence="0.99993156">
For this purpose, kernel methods, and in partic-
ular tree kernels allow for representing trees in
terms of all possible subtrees (Collins and Duffy,
2002). Unfortunately, the representation in entail-
ment recognition problems requires the definition
of kernels over graphs constituted by tree pairs,
which are in general different from kernels applied
to single trees. In (Zanzotto and Moschitti, 2006),
this has been addressed by introducing semantic
links (placeholders) between text and hypothesis
parse trees and evaluating two distinct tree ker-
nels for the trees of texts and for those of hypothe-
ses. In order to make such disjoint kernel combi-
nation effective, all possible assignments between
the placeholders of the first and the second en-
tailment pair were generated causing a remarkable
slowdown.
In this paper, we describe the feature space of
all possible tree fragment pairs and we show that it
can be evaluated with a much simpler kernel than
the one used in previous work, both in terms of
design and computational complexity. Moreover,
the experiments on the RTE datasets show that our
proposed kernel provides higher accuracy than the
simple union of tree kernel spaces.
</bodyText>
<sectionHeader confidence="0.751657" genericHeader="method">
2 Fragments of Tree Pair-based Graphs
</sectionHeader>
<bodyText confidence="0.999948307692308">
The previous section has pointed out that RTE can
be seen as a relational problem between word se-
quences of Text and Hypothesis. The syntactic
structures embedded in such sequences can be gen-
eralized by natural language grammars. Such gen-
eralization is very important since it is evident that
entailment cases depend on the syntactic structures
of Text and Hypothesis. More specifically, the set
R described in the previous section can be ex-
tended and generalized by considering syntactic
derivations2 that generate word sequences in the
training examples. This corresponds to the follow-
ing set of tree fragment pairs:
</bodyText>
<equation confidence="0.982929">
RT = I(τt,τh) : τt E F(T),τh E F(H)}, (1)
</equation>
<bodyText confidence="0.9870595">
where F(·) indicates the set of tree fragments of a
parse tree (i.e. the one of the text T or of the hy-
pothesis H). RT contains less sparse relations than
R. For instance, given T1 and H1 of the previous
section, we would have the following relational de-
scription:
2By cutting derivation at different depth, different degrees
of generalization can be obtained.
</bodyText>
<equation confidence="0.994651">
RT NP NP
={
( , ) , ( ,
NNP NNP NP VP NP VP
</equation>
<bodyText confidence="0.999907583333334">
These features (relational pairs) generalize the
entailment property, e.g. the pair ([VP [VBP bought] [NP]],
[VP [VBP own] [NP]]) generalizes many word sequences,
i.e. those external to the verbal phrases and inter-
nal to the NPs.
We can improve this space by adding semantic
links between the tree fragments. Such links
or placeholders have been firstly proposed in
(Zanzotto and Moschitti, 2006). A placeholder
assigned to a node of τt and a node of τh states
that such nodes dominate the same (or similar) in-
formation. In particular, placeholders are assigned
to nodes whose words ti in T are equal, similar, or
semantically dependent on words hj in H. Using
placeholders, we obtain a richer fragment pair
based representation that we call RTp, exemplified
hereafter:
The placeholders (or variables) indicated with
X and Y specify that the NNPs labeled by
the same variables dominate similar or identical
words. Therefore, an automatic algorithm that
assigns placeholders to semantically similar con-
stituents is needed. Moreover, although RTp con-
tains more semantic and less sparse features than
</bodyText>
<figure confidence="0.998537746268657">
NP
NP
S
VP
S
VP
(
NNP
VBP
NP
NNP VBP
) ,
,
NP
bought NNP owns NNP
VP VP
bought NNP owns NNP
�
) , ..
VBP
NP
,
VBP
NP
(
S S
NP VP
NNP X
VBP
NP
NP VP
NNP X
VBP
NP
{
(
,
)
owns
NNP Y
NNP Y
bought
S
NP VP
VBP
bought
S
NP VP
,
VBP
owns
, (
NP
)
NP
NNP Y
NNP Y
S
S
, (
,
NP VP
NP VP
�
) , ...
S S
) ,
</figure>
<page confidence="0.981261">
26
</page>
<bodyText confidence="0.999823">
both Rτ and R, its cardinality is still exponential in
the number of the words of T and H. This means
that standard machine learning algorithms cannot
be applied. In contrast, tree kernels (Collins and
Duffy, 2002) can be used to efficiently generate
the huge space of tree fragments but, to generate
the space of pairs of tree fragments, a new kernel
function has to be defined.
The next section provides a solution to both
problems. i.e. an algorithm for placeholders as-
signments and for the computation of paired tree
kernels which generates Rτ and Rτp representa-
tions.
</bodyText>
<figureCaption confidence="0.997094">
Figure 1: A syntactic parse tree.
</figureCaption>
<sectionHeader confidence="0.9089765" genericHeader="method">
3 Kernels over Semantic Tree Pair-based
Graphs
</sectionHeader>
<bodyText confidence="0.9992321875">
The previous section has shown that placeholders
enrich a tree-based graph with relational informa-
tion, which, in turn, can be captured by means
of word semantic similarities simw(wt, wh), e.g.
(Corley and Mihalcea, 2005; Glickman et al.,
2005). More specifically, we use a two-step greedy
algorithm to anchor the content words (verbs,
nouns, adjectives, and adverbs) in the hypothesis
WH to words in the text WT.
In the first step, each word wh in WH is con-
nected to all words wt in WT that have the max-
imum similarity simw(wt, wh) with it (more than
one wt can have the maximum similarity with wh).
As result, we have a set of anchors A C WT xWH.
simw(wt, wh) is computed by means of three tech-
niques:
</bodyText>
<listItem confidence="0.9956876">
1. Two words are maximally similar if they have
the same surface form wt = wh.
2. Otherwise, WordNet (Miller, 1995) similari-
ties (as in (Corley and Mihalcea, 2005)) and
different relation between words such as verb
</listItem>
<bodyText confidence="0.969297090909091">
entailment and derivational morphology are
applied.
3. The edit distance measure is finally used to
capture the similarity between words that are
missed by the previous analysis (for mis-
spelling errors or for the lack of derivational
forms in WordNet).
In the second step, we select the final anchor set
A′ ⊆ A, such that bwt (or wh) ∃!(wt, wh) E A′.
The selection is based on a simple greedy algo-
rithm that given two pairs (wt, wh) and (w′t, wh)
to be selected and a pair (st, sh) already selected,
considers word proximity (in terms of number of
words) between wt and st and between w′t and st;
the nearest word will be chosen.
Once the graph has been enriched with seman-
tic information we need to represent it in the learn-
ing algorithm; for this purpose, an interesting ap-
proach is based on kernel methods. Since the con-
sidered graphs are composed by only two trees, we
can carried out a simplified computation of a graph
kernel based on tree kernel pairs.
</bodyText>
<subsectionHeader confidence="0.998605">
3.1 Tree Kernels
</subsectionHeader>
<bodyText confidence="0.9999755">
Tree Kernels (e.g. see NLP applications in (Giu-
glea and Moschitti, 2006; Zanzotto and Moschitti,
2006; Moschitti et al., 2007; Moschitti et al.,
2006; Moschitti and Bejan, 2004)) represent trees
in terms of their substructures (fragments) which
are mapped into feature vector spaces, e.g. Rn.
The kernel function measures the similarity be-
tween two trees by counting the number of their
common fragments. For example, Figure 1 shows
some substructures for the parse tree of the sen-
tence &amp;quot;book a flight&amp;quot;. The main advantage of
tree kernels is that, to compute the substructures
shared by two trees 7-1 and 7-2, the whole fragment
space is not used. In the following, we report the
formal definition presented in (Collins and Duffy,
2002).
Given the set of fragments {f1, f2, ..} = F, the
indicator function Ii(n) is equal 1 if the target fi is
rooted at node n and 0 otherwise. A tree kernel is
then defined as:
</bodyText>
<equation confidence="0.820158">
ETK(7-1,7-2) =
n1∈Nτ1
</equation>
<bodyText confidence="0.986426">
where Nτ1 and Nτ2 are the sets of the 7-1’s and 7-2’s
</bodyText>
<figure confidence="0.981802">
a flight a flight
VP
VP
V NP
V
NP
(
F
,
book
D
D
N
N
VP
, V NP
D N
�l
=
a
a
flight
NP
N , D N
flight
NP
D
N
,
D
NP
flight
D N
N
,
NP
,
}, ...
E A(n1, n2) (2)
</figure>
<page confidence="0.8167875">
n2∈Nτ2
27
</page>
<bodyText confidence="0.922543">
nodes, respectively and
</bodyText>
<equation confidence="0.998948">
O(n1, n2) = � |S |Ii(n1)Ii(n2)
i=1
</equation>
<bodyText confidence="0.995264666666667">
The latter is equal to the number of common frag-
ments rooted in the n1 and n2 nodes and O can be
evaluated with the following algorithm:
</bodyText>
<listItem confidence="0.9321975">
1. if the productions at n1 and n2 are different
then O(n1, n2) = 0;
2. if the productions at n1 and n2 are the
same, and n1 and n2 have only leaf children
(i.e. they are pre-terminals symbols) then
O(n1, n2) = 1;
3. if the productions at n1 and n2 are the same,
and n1 and n2 are not pre-terminals then
</listItem>
<equation confidence="0.996603">
nc(n1)
O(n1, n2) = H (1 + O(cjn1, cjn2)) (3)
j=1
</equation>
<bodyText confidence="0.9987805">
where nc(n1) is the number of the children of
n1 and cjn is the j-th child of the node n. Note
that since the productions are the same, nc(n1) =
nc(n2).
Additionally, we add the decay factor A by mod-
ifying steps (2) and (3) as follows3:
</bodyText>
<equation confidence="0.98974925">
2. O(n1, n2) = A,
nc(n1)
3. O(n1, n2) = A H (1 + O(cjn1, cjn2)).
j=1
</equation>
<bodyText confidence="0.927661666666667">
The computational complexity of Eq. 2 is
O(|Nτ1 |x |Nτ2|) although the average running
time tends to be linear (Moschitti, 2006).
</bodyText>
<subsectionHeader confidence="0.999584">
3.2 Tree-based Graph Kernels
</subsectionHeader>
<bodyText confidence="0.9993926">
The above tree kernel function can be applied to
the parse trees of two texts or those of the two hy-
potheses to measure their similarity in terms of the
shared fragments. If we sum the contributions of
the two kernels (for texts and for hypotheses) as
proposed in (Zanzotto and Moschitti, 2006), we
just obtain the feature space of the union of the
fragments which is completely different from the
space of the tree fragments pairs, i.e. Rτ. Note
that the union space is not useful to describe which
</bodyText>
<footnote confidence="0.9944765">
3To have a similarity score between 0 and 1, we also ap-
ply the normalization in the kernel space, i.e. K′(T1,T2) =
</footnote>
<equation confidence="0.4474335">
TK(τ1,τ2)
√T K(τ1,τ1)×T K(τ2,τ2).
</equation>
<bodyText confidence="0.9996468">
grammatical and lexical property is at the same
time held by T and H to trig the implication.
Therefore to generate the space of the frag-
ment pairs we need to define the kernel between
two pairs of entailment examples (T1, H1) and
</bodyText>
<equation confidence="0.988602">
(T2, H2) as
Kp((T1, H1), (T2, H2)) =
O(n1, n2, n3, n4),
</equation>
<bodyText confidence="0.99994125">
where O evaluates the number of subtrees rooted
in n1 and n2 combined with those rooted in n3 and
n4. More specifically, each fragment rooted into
the nodes of the two texts’ trees is combined with
each fragment rooted in the two hypotheses’ trees.
Now, since the number of subtrees rooted in the
texts is independent of the number of trees rooted
in the hypotheses,
</bodyText>
<equation confidence="0.997241555555556">
O(n1, n2, n3, n4) = O(n1, n2)O(n3, n4).
Therefore, we can rewrite Kp as:
Kp((T1, H1), (T2, H2)) =
�= � � � O(n1, n2)O(n3, n4) =
n1ET1 n2ET2 n3EH1 n4EH2
�= � �O(n1, n2) � O(n3, n4) =
n1ET1 n2ET2 n3EH1 n4EH2
= Kt(T1,T2) x Kt(H1,H2).
(4)
</equation>
<bodyText confidence="0.999765571428571">
This result shows that the natural kernel to rep-
resent textual entailment sentences is the kernel
product, which corresponds to the set of all possi-
ble syntactic fragment pairs. Note that, such kernel
can be also used to evaluate the space of fragment
pairs for trees enriched with relational information,
i.e. by placeholders.
</bodyText>
<sectionHeader confidence="0.994671" genericHeader="method">
4 Approximated Graph Kernel
</sectionHeader>
<bodyText confidence="0.998544909090909">
The feature space described in the previous sec-
tion correctly encodes the fragment pairs. How-
ever, such huge space may result inadequate also
for algorithms such as SVMs, which are in general
robust to many irrelevant features. An approxima-
tion of the fragment pair space is given by the ker-
nel described in (Zanzotto and Moschitti, 2006).
Hereafter we illustrate its main points.
First, tree kernels applied to two texts or two hy-
potheses match identical fragments. When place-
holders are added to trees, the labeled fragments
</bodyText>
<equation confidence="0.938279">
�= � � �
n1ET1 n2ET2 n3EH1 n4EH2
</equation>
<page confidence="0.994924">
28
</page>
<bodyText confidence="0.997334419354839">
are matched only if the basic fragments and the
assigned placeholders match. This means that
we should use the same placeholders for all texts
and all hypotheses of the corpus. Moreover, they
should be assigned in a way that similar syntac-
tic structures and similar relational information be-
tween two entailment pairs can be matched, i.e.
same placeholders should be assigned to the po-
tentially similar fragments.
Second, the above task cannot be carried out at
pre-processing time, i.e. when placeholders are
assigned to trees. At the running time, instead,
we can look at the comparing trees and make a
more consistent decision on the type and order of
placeholders. Although, there may be several ap-
proaches to accomplish this task, we apply a basic
heuristic which is very intuitive:
Choose the placeholder assignment that maxi-
mizes the tree kernel function over all possible cor-
respondences
More formally, let A and A′ be the placeholder sets
of (T, H) and (T′, H′), respectively, without loss
of generality, we consider |A |&gt; |A′ |and we align
a subset of A to A′. The best alignment is the one
that maximizes the syntactic and lexical overlap-
ping of the two subtrees induced by the aligned set
of anchors. By calling C the set of all bijective
mappings from S C A, with |S |= |A′|, to A′,
an element c E C is a substitution function. We
define the best alignment cmax the one determined
by
</bodyText>
<equation confidence="0.8768135">
cmax = argmaxcEC(TK(t(T, c), t(T′, i))+
TK(t(H, c), t(H′, i)),
</equation>
<bodyText confidence="0.937935909090909">
where (1) t(·, c) returns the syntactic tree enriched
with placeholders replaced by means of the sub-
stitution c, (2) i is the identity substitution and (3)
TK(7-1,7-2) is a tree kernel function (e.g. the one
specified by Eq. 2) applied to the two trees 7-1 and
7-2.
At the same time, the desired similarity value
to be used in the learning algorithm is given
by the kernel sum: TK(t(T, cmax), t(T′, i)) +
TK(t(H, cmax), t(H′, i)), i.e. by solving the fol-
lowing optimization problem:
</bodyText>
<construct confidence="0.872005333333333">
Ks((T, H), (T′, H′)) =
maxcEC(TK(t(T, c), t(T′, i))+ (5)
TK(t(H, c), t(H′, i)),
</construct>
<bodyText confidence="0.978836677419355">
For example, let us compare the following two
pairs (T1, H1) and (T2, H2) in Fig. 2.
To assign the placeholders 1, 2 and 3 of
(T2, H2) to those of (T1, H1), i.e. X and Y, we
need to maximize the similarity between the two
texts’ trees and between the two hypotheses’ trees.
It is straightforward to derive that X=1 and Y=3 al-
low more substructures (i.e. large part of the trees)
Finally, it should be noted that, (a)
Ks((T, H), (T′, H′)) is a symmetric function
since the set of derivation C are always computed
with respect to the pair that has the largest anchor
set and (b) it is not a valid kernel as the max
function does not in general produce valid kernels.
However, in (Haasdonk, 2005), it is shown that
when kernel functions are not positive semidef-
inite like in this case, SVMs still solve a data
separation problem in pseudo Euclidean spaces.
The drawback is that the solution may be only a
local optimum. Nevertheless, such solution can
still be valuable as the problem is modeled with a
very rich feature space.
Regarding the computational complexity, run-
ning the above kernel on a large training set may
result very expensive. To overcome this drawback,
in (Moschitti and Zanzotto, 2007), it has been de-
signed an algorithm to factorize the evaluation of
tree subparts with respect to the different substitu-
tion. The resulting speed-up makes the application
of such kernel feasible for datasets of ten of thou-
sands of instances.
</bodyText>
<sectionHeader confidence="0.998492" genericHeader="method">
5 Experiments
</sectionHeader>
<bodyText confidence="0.999603">
The aim of the experiments is to show that the
space of tree fragment pairs is the most effective
to represent Tree Pair-based Graphs for the design
of Textual Entailment classifiers.
</bodyText>
<subsectionHeader confidence="0.990379">
5.1 Experimental Setup
</subsectionHeader>
<bodyText confidence="0.996355">
To compare our model with previous work we
implemented the following kernels in SVM-light
(Joachims, 1999):
</bodyText>
<listItem confidence="0.881126">
• Ks(e1, e2) = Kt(T1,T2) + Kt(H1, H2),
where e1 = (T1, H1) and e2 = (T2, H2)
are two text and hypothesis pairs and Kt is
the syntactic tree kernel (Collins and Duffy,
2002) presented in the previous section.
• Kp(e1, e2) = Kt(T1,T2) x Kt(H1, H2),
which (as shown in the previous sections) en-
</listItem>
<equation confidence="0.498514333333333">
to be identical, e.g. [S [NP 1 X VP]] , [VP [VBP
Y]], [S [NP
VP [VBP NP 3
NP3
Y]]].
1 X
</equation>
<page confidence="0.97703">
29
</page>
<figureCaption confidence="0.999332">
Figure 2: The problem of finding the correct mapping between placeholders
</figureCaption>
<figure confidence="0.958116">
S
T2 ⇒ H2
S
S
S
KStones
KStones
T1 ⇒ H1
NP X
NNP X
Wanadoo
VP
NP Y
VBP
owns
NNP Y
NP X
NNP X
Wanadoo
VBP
bought
NP Y
NNP Y
VP
VP
NP 1
PP 2
VBP
NP 3
NP 1
DT NN 1
the president
DT
IN
NP 2
NN 3
of
bought
a
castle
NNP 2
Miramax
NP 1
VP
castle
a
NP 1
DT NN 1
the president
PP 2
NP 3
VBP
NP 2
NN 3
IN
DT
own
of
NNP 2
Miramax
codes the tree fragment pairs with and with-
out placeholders.
• Kmax(e1, e2) = Max (Kt(Oc(T1), Oc(T2)) +
Kt(Oc(H1), Oc(H2))), where c is a possi-
c∈C
</figure>
<bodyText confidence="0.9516915">
ble placeholder assignment which connects
nodes from the first pair with those of the sec-
ond pair and Oc(·) transforms trees according
to c.
</bodyText>
<equation confidence="0.826710333333333">
• Kpmx(e1, e2) = Max (Kt(Oc(T1), Oc(T2)) ×
Kt(Oc(H1), Oc(H2))).
c∈C
</equation>
<bodyText confidence="0.9999820625">
Note that Kmax is the kernel proposed in (Zanzotto
and Moschitti, 2006) and Kpmx is a hybrid kernel
based on the maximum Kp, which uses the space
of tree fragment pairs. For all the above kernels,
we set the default cost factor and trade-off param-
eters and we set A to 0.4.
To experiment with entailment relations, we
used the data sets made available by the first (Da-
gan et al., 2005) and second (Bar Haim et al., 2006)
Recognizing Textual Entailment Challenge. These
corpora are divided in the development sets D1
and D2 and the test sets T1 and T2. D1 contains
567 examples whereas T1, D2 and T2 all have the
same size, i.e. 800 instances. Each example is an
ordered pair of texts for which the entailment rela-
tion has to be decided.
</bodyText>
<subsectionHeader confidence="0.99312">
5.2 Evaluation and Discussion
</subsectionHeader>
<bodyText confidence="0.9999905">
Table 1 shows the results of the above kernels
on the split used for the RTE competitions. The
first column reports the kernel model. The second
and third columns illustrate the model accuracy for
RTE1 whereas column 4 and 5 show the accuracy
for RTE2. Moreover, ¬ P indicates the use of stan-
dard syntactic trees and P the use of trees enriched
with placeholders. We note that:
First, the space of tree fragment pairs, gener-
ated by Kp improves the one generated by Ks (i.e.
the simple union of the fragments of texts and hy-
potheses) of 4 (58.9% vs 54.9%) and 0.9 (53.5%
vs 52.6%) points on RTE1 and RTE2, respectively.
This suggests that the fragment pairs are more ef-
fective for encoding the syntactic rules describing
the entailment concept.
Second, on RTE1, the introduction of placehold-
ers does not improve Kp or Ks suggesting that for
their correct exploitation an extension of the space
of tree fragment pairs should be modeled.
Third, on RTE2, the impact of placeholders
seems more important but only Kmax and Ks
are able to fully exploit their semantic contribu-
tion. A possible explanation is that in order to
use the set of all possible assignments (required by
Kmax), we needed to prune the ”too large” syntac-
tic trees as also suggested in (Zanzotto and Mos-
chitti, 2006). This may have negatively biased the
statistical distribution of tree fragment pairs.
Finally, although we show that Kp is better
</bodyText>
<page confidence="0.990434">
30
</page>
<table confidence="0.999673666666667">
Kernels RTE1 RTE2
¬ P P ¬ P P
Ks 54.9 50.0 52.6 59.5
Kp 58.9 55.5 53.5 56.0
Kmax - 58.25 - 61.0
Kpmx - 50.0 - 56.8
</table>
<tableCaption confidence="0.987444666666667">
Table 1: Accuracy of different kernel models using
(P) and not using (¬ P) placeholder information on
RTE1 and RTE2.
</tableCaption>
<sectionHeader confidence="0.993479" genericHeader="evaluation">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.999925846153846">
We would like to thank the anonymous reviewers
for their professional and competent reviews and
for their invaluable suggestions.
Alessandro Moschitti would like to thank the Eu-
ropean Union project, LUNA (spoken Language
UNderstanding in multilinguAl communication
systems) contract n 33549 for supporting part of
his research.
suited for RTE than the other kernels, its accuracy
is lower than the state-of-the-art in RTE. This is be-
cause the latter uses additional models like the lex-
ical similarity between text and hypothesis, which
greatly improve accuracy.
</bodyText>
<sectionHeader confidence="0.999439" genericHeader="conclusions">
6 Conclusion
</sectionHeader>
<bodyText confidence="0.999951272727273">
In this paper, we have provided a statistical ma-
chine learning representation of textual entailment
via syntactic graphs constituted by tree pairs. We
have analytically shown that the natural way of
representing the syntactic relations between text
and hypothesis in learning algorithms consists in
the huge feature space of all possible syntactic tree
fragment pairs, which can only be managed using
kernel methods.
Therefore, we used tree kernels, which allow for
representing trees in terms of all possible subtrees.
More specifically, we defined a new model for the
entailment recognition problems, which requires
the definition of kernels over graphs constituted by
tree pairs. These are in general different from ker-
nels applied to single trees. We also studied an-
other alternative solution which concerns the use
of semantic links (placeholders) between text and
hypothesis parse trees (to form relevant semantic
fragment pairs) and the evaluation of two distinct
tree kernels for the trees of texts and for those of
hypotheses. In order to make such disjoint kernel
combination effective, all possible assignments be-
tween the placeholders of the first and the second
entailment pair have to be generated (causing a re-
markable slowdown).
Our experiments on the RTE datasets show that
our proposed kernel may provide higher accuracy
than the simple union of tree kernel spaces with a
much simpler and faster algorithm. Future work
will be devoted to make the tree fragment pair
space more effective, e.g. by using smaller and ac-
curate tree representation for text and hypothesis.
</bodyText>
<sectionHeader confidence="0.998892" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.99943756097561">
Bar Haim, Roy, Ido Dagan, Bill Dolan, Lisa Ferro,
Danilo Giampiccolo, Bernardo Magnini, and Idan
Szpektor. 2006. The II PASCAL RTE challenge.
In PASCAL Challenges Workshop, Venice, Italy.
Bos, Johan and Katja Markert. 2005. Recognising
textual entailment with logical inference. In Pro-
ceedings of Human Language Technology Confer-
ence and Conference on Empirical Methods in Nat-
ural Language Processing, pages 628–635, Vancou-
ver, British Columbia, Canada, October. Association
for Computational Linguistics.
Collins, Michael and Nigel Duffy. 2002. New rank-
ing algorithms for parsing and tagging: Kernels over
discrete structures, and the voted perceptron. In Pro-
ceedings ofACL02.
Corley, Courtney and Rada Mihalcea. 2005. Measur-
ing the semantic similarity of texts. In Proc. of the
ACL Workshop on Empirical Modeling of Semantic
Equivalence and Entailment, pages 13–18, Ann Ar-
bor, Michigan, June. Association for Computational
Linguistics.
Dagan, Ido, Oren Glickman, and Bernardo Magnini.
2005. The PASCAL RTE challenge. In PASCAL
Challenges Workshop, Southampton, U.K.
de Salvo Braz, R., R. Girju, V. Punyakanok, D. Roth,
and M. Sammons. 2005. An inference model for se-
mantic entailment in natural language. In Proceed-
ings ofAAAI, pages 1678–1679.
Giuglea, Ana-Maria and Alessandro Moschitti. 2006.
Semantic role labeling via framenet, verbnet and
propbank. In Proceedings of Coling-ACL, Sydney,
Australia.
Glickman, Oren and Ido Dagan. 2004. Probabilistic
textual entailment: Generic applied modeling of lan-
guage variability. In Proceedings ofthe Workshop on
Learning Methods for Text Understanding and Min-
ing, Grenoble, France.
Glickman, Oren, Ido Dagan, and Moshe Koppel. 2005.
Web based probabilistic textual entailment. In Pro-
ceedings of the 1st Pascal Challenge Workshop,
Southampton, UK.
</reference>
<page confidence="0.997682">
31
</page>
<reference confidence="0.999879">
Haasdonk, Bernard. 2005. Feature space interpretation
of SVMs with indefinite kernels. IEEE Trans Pat-
tern Anal Mach Intell, 27(4):482–92, Apr.
Joachims, Thorsten. 1999. Making large-scale svm
learning practical. In Schlkopf, B., C. Burges, and
A. Smola, editors, Advances in Kernel Methods-
Support Vector Learning. MIT Press.
Miller, George A. 1995. WordNet: A lexical
database for English. Communications of the ACM,
38(11):39–41, November.
Moschitti, Alessandro and Cosmin Adrian Bejan.
2004. A semantic kernel for predicate argument
classification. In CoNLL-2004, USA.
Moschitti, A. and F. Zanzotto. 2007. Fast and effective
kernels for relational learning from texts. In Ghahra-
mani, Zoubin, editor, Proceedings of the 24th An-
nual International Conference on Machine Learning
(ICML 2007).
Moschitti, Alessandro, Daniele Pighin, and Roberto
Basili. 2006. Semantic Role Labeling via Tree Ker-
nel Joint Inference. In Proceedings of CoNLL-X.
Moschitti, Alessandro, Silvia Quarteroni, Roberto
Basili, and Suresh Manandhar. 2007. Exploiting
syntactic and shallow semantic kernels for question
answer classification. In Proceedings ACL, Prague,
Czech Republic.
Moschitti, Alessandro. 2006. Efficient convolution
kernels for dependency and constituent syntactic
trees. In ECML’06.
Zanzotto, Fabio Massimo and Alessandro Moschitti.
2006. Automatic learning of textual entailments
with cross-pair similarities. In Proceedings of the
21st Coling and 44th ACL, pages 401–408, Sydney,
Australia, July.
</reference>
<page confidence="0.999299">
32
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.198278">
<title confidence="0.997515">Encoding Tree Pair-based Graphs in Learning the Textual Entailment Recognition Case</title>
<author confidence="0.995084">Alessandro</author>
<affiliation confidence="0.718963">DISI, University of Via Sommarive</affiliation>
<address confidence="0.847193">38100 POVO (TN) -</address>
<email confidence="0.992895">moschitti@dit.unitn.it</email>
<author confidence="0.999392">Fabio Massimo</author>
<affiliation confidence="0.988653">DISP, University of Rome “Tor</affiliation>
<address confidence="0.7390275">Via del Politecnico 00133 Roma,</address>
<email confidence="0.996302">zanzotto@info.uniroma2.it</email>
<abstract confidence="0.999705384615385">In this paper, we provide a statistical machine learning representation of textual entailment via syntactic graphs constituted by tree pairs. We show that the natural way of representing the syntactic relations between text and hypothesis consists in the huge feature space of all possible syntactic tree fragment pairs, which can only be managed using kernel methods. Experiments with Support Vector Machines and our new kernels for paired trees show the validity of our interpretation.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Bar Haim</author>
<author>Ido Dagan Roy</author>
<author>Bill Dolan</author>
<author>Lisa Ferro</author>
<author>Danilo Giampiccolo</author>
<author>Bernardo Magnini</author>
<author>Idan Szpektor</author>
</authors>
<date>2006</date>
<booktitle>The II PASCAL RTE challenge. In PASCAL Challenges Workshop,</booktitle>
<location>Venice, Italy.</location>
<contexts>
<context position="972" citStr="Haim et al., 2006" startWordPosition="145" endWordPosition="148">aper, we provide a statistical machine learning representation of textual entailment via syntactic graphs constituted by tree pairs. We show that the natural way of representing the syntactic relations between text and hypothesis consists in the huge feature space of all possible syntactic tree fragment pairs, which can only be managed using kernel methods. Experiments with Support Vector Machines and our new kernels for paired trees show the validity of our interpretation. 1 Introduction Recently, a lot of valuable work on the recognition of textual entailment (RTE) has been carried out (Bar Haim et al., 2006). The aim is to detect implications between sentences like: T1 ⇒ H1 T1 “Wanadoo bought KStones” H1 “Wanadoo owns KStones” where T1 and H1 stand for text and hypothesis, respectively. Several models, ranging from the simple lexical similarity between T and H to advanced Logic Form Representations, have been proposed (Corley and Mihalcea, 2005; Glickman and Dagan, 2004; de Salvo Braz et al., 2005; Bos and Markert, 2005). However, since a linguistic theory able to analytically show how to computationally solve the RTE problem has not been developed yet, to © 2008. Licensed under the Creative Comm</context>
<context position="19923" citStr="Haim et al., 2006" startWordPosition="3549" endWordPosition="3552">lder assignment which connects nodes from the first pair with those of the second pair and Oc(·) transforms trees according to c. • Kpmx(e1, e2) = Max (Kt(Oc(T1), Oc(T2)) × Kt(Oc(H1), Oc(H2))). c∈C Note that Kmax is the kernel proposed in (Zanzotto and Moschitti, 2006) and Kpmx is a hybrid kernel based on the maximum Kp, which uses the space of tree fragment pairs. For all the above kernels, we set the default cost factor and trade-off parameters and we set A to 0.4. To experiment with entailment relations, we used the data sets made available by the first (Dagan et al., 2005) and second (Bar Haim et al., 2006) Recognizing Textual Entailment Challenge. These corpora are divided in the development sets D1 and D2 and the test sets T1 and T2. D1 contains 567 examples whereas T1, D2 and T2 all have the same size, i.e. 800 instances. Each example is an ordered pair of texts for which the entailment relation has to be decided. 5.2 Evaluation and Discussion Table 1 shows the results of the above kernels on the split used for the RTE competitions. The first column reports the kernel model. The second and third columns illustrate the model accuracy for RTE1 whereas column 4 and 5 show the accuracy for RTE2. </context>
</contexts>
<marker>Haim, Roy, Dolan, Ferro, Giampiccolo, Magnini, Szpektor, 2006</marker>
<rawString>Bar Haim, Roy, Ido Dagan, Bill Dolan, Lisa Ferro, Danilo Giampiccolo, Bernardo Magnini, and Idan Szpektor. 2006. The II PASCAL RTE challenge. In PASCAL Challenges Workshop, Venice, Italy.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Johan Bos</author>
<author>Katja Markert</author>
</authors>
<title>Recognising textual entailment with logical inference.</title>
<date>2005</date>
<booktitle>In Proceedings of Human Language Technology Conference and Conference on Empirical Methods in Natural Language Processing,</booktitle>
<pages>628--635</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<location>Vancouver, British Columbia, Canada,</location>
<contexts>
<context position="1393" citStr="Bos and Markert, 2005" startWordPosition="216" endWordPosition="220">els for paired trees show the validity of our interpretation. 1 Introduction Recently, a lot of valuable work on the recognition of textual entailment (RTE) has been carried out (Bar Haim et al., 2006). The aim is to detect implications between sentences like: T1 ⇒ H1 T1 “Wanadoo bought KStones” H1 “Wanadoo owns KStones” where T1 and H1 stand for text and hypothesis, respectively. Several models, ranging from the simple lexical similarity between T and H to advanced Logic Form Representations, have been proposed (Corley and Mihalcea, 2005; Glickman and Dagan, 2004; de Salvo Braz et al., 2005; Bos and Markert, 2005). However, since a linguistic theory able to analytically show how to computationally solve the RTE problem has not been developed yet, to © 2008. Licensed under the Creative Commons Attribution-Noncommercial-Share Alike 3.0 Unported license (http://creativecommons.org/licenses/by-nc-sa/3.0/). Some rights reserved. design accurate systems, we should rely upon the application of machine learning. In this perspective, TE training examples have to be represented in terms of statistical feature distributions. These typically consist in word sequences (along with their lexical similarity) and the s</context>
</contexts>
<marker>Bos, Markert, 2005</marker>
<rawString>Bos, Johan and Katja Markert. 2005. Recognising textual entailment with logical inference. In Proceedings of Human Language Technology Conference and Conference on Empirical Methods in Natural Language Processing, pages 628–635, Vancouver, British Columbia, Canada, October. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Collins</author>
<author>Nigel Duffy</author>
</authors>
<title>New ranking algorithms for parsing and tagging: Kernels over discrete structures, and the voted perceptron.</title>
<date>2002</date>
<booktitle>In Proceedings ofACL02.</booktitle>
<contexts>
<context position="3869" citStr="Collins and Duffy, 2002" startWordPosition="618" endWordPosition="621"> sequences which provides their generalization. The use of syntactic trees poses the problem of representing structures in learning algorithms. 1V ∗ is larger than the actual space, which is the one of all possible subsequences with gaps, i.e. it only contains all possible concatenations of words respecting their order. 25 Coling 2008: Proceedings of 3rd Textgraphs workshop on Graph-Based Algorithms in Natural Language Processing, pages 25–32 Manchester, August 2008 For this purpose, kernel methods, and in particular tree kernels allow for representing trees in terms of all possible subtrees (Collins and Duffy, 2002). Unfortunately, the representation in entailment recognition problems requires the definition of kernels over graphs constituted by tree pairs, which are in general different from kernels applied to single trees. In (Zanzotto and Moschitti, 2006), this has been addressed by introducing semantic links (placeholders) between text and hypothesis parse trees and evaluating two distinct tree kernels for the trees of texts and for those of hypotheses. In order to make such disjoint kernel combination effective, all possible assignments between the placeholders of the first and the second entailment</context>
<context position="7616" citStr="Collins and Duffy, 2002" startWordPosition="1285" endWordPosition="1288">lly similar constituents is needed. Moreover, although RTp contains more semantic and less sparse features than NP NP S VP S VP ( NNP VBP NP NNP VBP ) , , NP bought NNP owns NNP VP VP bought NNP owns NNP � ) , .. VBP NP , VBP NP ( S S NP VP NNP X VBP NP NP VP NNP X VBP NP { ( , ) owns NNP Y NNP Y bought S NP VP VBP bought S NP VP , VBP owns , ( NP ) NP NNP Y NNP Y S S , ( , NP VP NP VP � ) , ... S S ) , 26 both Rτ and R, its cardinality is still exponential in the number of the words of T and H. This means that standard machine learning algorithms cannot be applied. In contrast, tree kernels (Collins and Duffy, 2002) can be used to efficiently generate the huge space of tree fragments but, to generate the space of pairs of tree fragments, a new kernel function has to be defined. The next section provides a solution to both problems. i.e. an algorithm for placeholders assignments and for the computation of paired tree kernels which generates Rτ and Rτp representations. Figure 1: A syntactic parse tree. 3 Kernels over Semantic Tree Pair-based Graphs The previous section has shown that placeholders enrich a tree-based graph with relational information, which, in turn, can be captured by means of word semanti</context>
<context position="10688" citStr="Collins and Duffy, 2002" startWordPosition="1821" endWordPosition="1824"> et al., 2007; Moschitti et al., 2006; Moschitti and Bejan, 2004)) represent trees in terms of their substructures (fragments) which are mapped into feature vector spaces, e.g. Rn. The kernel function measures the similarity between two trees by counting the number of their common fragments. For example, Figure 1 shows some substructures for the parse tree of the sentence &amp;quot;book a flight&amp;quot;. The main advantage of tree kernels is that, to compute the substructures shared by two trees 7-1 and 7-2, the whole fragment space is not used. In the following, we report the formal definition presented in (Collins and Duffy, 2002). Given the set of fragments {f1, f2, ..} = F, the indicator function Ii(n) is equal 1 if the target fi is rooted at node n and 0 otherwise. A tree kernel is then defined as: ETK(7-1,7-2) = n1∈Nτ1 where Nτ1 and Nτ2 are the sets of the 7-1’s and 7-2’s a flight a flight VP VP V NP V NP ( F , book D D N N VP , V NP D N �l = a a flight NP N , D N flight NP D N , D NP flight D N N , NP , }, ... E A(n1, n2) (2) n2∈Nτ2 27 nodes, respectively and O(n1, n2) = � |S |Ii(n1)Ii(n2) i=1 The latter is equal to the number of common fragments rooted in the n1 and n2 nodes and O can be evaluated with the follow</context>
<context position="18544" citStr="Collins and Duffy, 2002" startWordPosition="3261" endWordPosition="3264">ution. The resulting speed-up makes the application of such kernel feasible for datasets of ten of thousands of instances. 5 Experiments The aim of the experiments is to show that the space of tree fragment pairs is the most effective to represent Tree Pair-based Graphs for the design of Textual Entailment classifiers. 5.1 Experimental Setup To compare our model with previous work we implemented the following kernels in SVM-light (Joachims, 1999): • Ks(e1, e2) = Kt(T1,T2) + Kt(H1, H2), where e1 = (T1, H1) and e2 = (T2, H2) are two text and hypothesis pairs and Kt is the syntactic tree kernel (Collins and Duffy, 2002) presented in the previous section. • Kp(e1, e2) = Kt(T1,T2) x Kt(H1, H2), which (as shown in the previous sections) ento be identical, e.g. [S [NP 1 X VP]] , [VP [VBP Y]], [S [NP VP [VBP NP 3 NP3 Y]]]. 1 X 29 Figure 2: The problem of finding the correct mapping between placeholders S T2 ⇒ H2 S S S KStones KStones T1 ⇒ H1 NP X NNP X Wanadoo VP NP Y VBP owns NNP Y NP X NNP X Wanadoo VBP bought NP Y NNP Y VP VP NP 1 PP 2 VBP NP 3 NP 1 DT NN 1 the president DT IN NP 2 NN 3 of bought a castle NNP 2 Miramax NP 1 VP castle a NP 1 DT NN 1 the president PP 2 NP 3 VBP NP 2 NN 3 IN DT own of NNP 2 Miram</context>
</contexts>
<marker>Collins, Duffy, 2002</marker>
<rawString>Collins, Michael and Nigel Duffy. 2002. New ranking algorithms for parsing and tagging: Kernels over discrete structures, and the voted perceptron. In Proceedings ofACL02.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Courtney Corley</author>
<author>Rada Mihalcea</author>
</authors>
<title>Measuring the semantic similarity of texts.</title>
<date>2005</date>
<booktitle>In Proc. of the ACL Workshop on Empirical Modeling of Semantic Equivalence and Entailment,</booktitle>
<pages>13--18</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<location>Ann Arbor, Michigan,</location>
<contexts>
<context position="1315" citStr="Corley and Mihalcea, 2005" startWordPosition="201" endWordPosition="205">d using kernel methods. Experiments with Support Vector Machines and our new kernels for paired trees show the validity of our interpretation. 1 Introduction Recently, a lot of valuable work on the recognition of textual entailment (RTE) has been carried out (Bar Haim et al., 2006). The aim is to detect implications between sentences like: T1 ⇒ H1 T1 “Wanadoo bought KStones” H1 “Wanadoo owns KStones” where T1 and H1 stand for text and hypothesis, respectively. Several models, ranging from the simple lexical similarity between T and H to advanced Logic Form Representations, have been proposed (Corley and Mihalcea, 2005; Glickman and Dagan, 2004; de Salvo Braz et al., 2005; Bos and Markert, 2005). However, since a linguistic theory able to analytically show how to computationally solve the RTE problem has not been developed yet, to © 2008. Licensed under the Creative Commons Attribution-Noncommercial-Share Alike 3.0 Unported license (http://creativecommons.org/licenses/by-nc-sa/3.0/). Some rights reserved. design accurate systems, we should rely upon the application of machine learning. In this perspective, TE training examples have to be represented in terms of statistical feature distributions. These typic</context>
<context position="8276" citStr="Corley and Mihalcea, 2005" startWordPosition="1393" endWordPosition="1396">e the huge space of tree fragments but, to generate the space of pairs of tree fragments, a new kernel function has to be defined. The next section provides a solution to both problems. i.e. an algorithm for placeholders assignments and for the computation of paired tree kernels which generates Rτ and Rτp representations. Figure 1: A syntactic parse tree. 3 Kernels over Semantic Tree Pair-based Graphs The previous section has shown that placeholders enrich a tree-based graph with relational information, which, in turn, can be captured by means of word semantic similarities simw(wt, wh), e.g. (Corley and Mihalcea, 2005; Glickman et al., 2005). More specifically, we use a two-step greedy algorithm to anchor the content words (verbs, nouns, adjectives, and adverbs) in the hypothesis WH to words in the text WT. In the first step, each word wh in WH is connected to all words wt in WT that have the maximum similarity simw(wt, wh) with it (more than one wt can have the maximum similarity with wh). As result, we have a set of anchors A C WT xWH. simw(wt, wh) is computed by means of three techniques: 1. Two words are maximally similar if they have the same surface form wt = wh. 2. Otherwise, WordNet (Miller, 1995) </context>
</contexts>
<marker>Corley, Mihalcea, 2005</marker>
<rawString>Corley, Courtney and Rada Mihalcea. 2005. Measuring the semantic similarity of texts. In Proc. of the ACL Workshop on Empirical Modeling of Semantic Equivalence and Entailment, pages 13–18, Ann Arbor, Michigan, June. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ido Dagan</author>
<author>Oren Glickman</author>
<author>Bernardo Magnini</author>
</authors>
<date>2005</date>
<booktitle>The PASCAL RTE challenge. In PASCAL Challenges Workshop,</booktitle>
<location>Southampton, U.K.</location>
<contexts>
<context position="19888" citStr="Dagan et al., 2005" startWordPosition="3541" endWordPosition="3545">), where c is a possic∈C ble placeholder assignment which connects nodes from the first pair with those of the second pair and Oc(·) transforms trees according to c. • Kpmx(e1, e2) = Max (Kt(Oc(T1), Oc(T2)) × Kt(Oc(H1), Oc(H2))). c∈C Note that Kmax is the kernel proposed in (Zanzotto and Moschitti, 2006) and Kpmx is a hybrid kernel based on the maximum Kp, which uses the space of tree fragment pairs. For all the above kernels, we set the default cost factor and trade-off parameters and we set A to 0.4. To experiment with entailment relations, we used the data sets made available by the first (Dagan et al., 2005) and second (Bar Haim et al., 2006) Recognizing Textual Entailment Challenge. These corpora are divided in the development sets D1 and D2 and the test sets T1 and T2. D1 contains 567 examples whereas T1, D2 and T2 all have the same size, i.e. 800 instances. Each example is an ordered pair of texts for which the entailment relation has to be decided. 5.2 Evaluation and Discussion Table 1 shows the results of the above kernels on the split used for the RTE competitions. The first column reports the kernel model. The second and third columns illustrate the model accuracy for RTE1 whereas column 4</context>
</contexts>
<marker>Dagan, Glickman, Magnini, 2005</marker>
<rawString>Dagan, Ido, Oren Glickman, and Bernardo Magnini. 2005. The PASCAL RTE challenge. In PASCAL Challenges Workshop, Southampton, U.K.</rawString>
</citation>
<citation valid="true">
<authors>
<author>de Salvo Braz</author>
<author>R Girju R</author>
<author>V Punyakanok</author>
<author>D Roth</author>
<author>M Sammons</author>
</authors>
<title>An inference model for semantic entailment in natural language.</title>
<date>2005</date>
<booktitle>In Proceedings ofAAAI,</booktitle>
<pages>1678--1679</pages>
<contexts>
<context position="1369" citStr="Braz et al., 2005" startWordPosition="212" endWordPosition="215">es and our new kernels for paired trees show the validity of our interpretation. 1 Introduction Recently, a lot of valuable work on the recognition of textual entailment (RTE) has been carried out (Bar Haim et al., 2006). The aim is to detect implications between sentences like: T1 ⇒ H1 T1 “Wanadoo bought KStones” H1 “Wanadoo owns KStones” where T1 and H1 stand for text and hypothesis, respectively. Several models, ranging from the simple lexical similarity between T and H to advanced Logic Form Representations, have been proposed (Corley and Mihalcea, 2005; Glickman and Dagan, 2004; de Salvo Braz et al., 2005; Bos and Markert, 2005). However, since a linguistic theory able to analytically show how to computationally solve the RTE problem has not been developed yet, to © 2008. Licensed under the Creative Commons Attribution-Noncommercial-Share Alike 3.0 Unported license (http://creativecommons.org/licenses/by-nc-sa/3.0/). Some rights reserved. design accurate systems, we should rely upon the application of machine learning. In this perspective, TE training examples have to be represented in terms of statistical feature distributions. These typically consist in word sequences (along with their lexic</context>
</contexts>
<marker>Braz, R, Punyakanok, Roth, Sammons, 2005</marker>
<rawString>de Salvo Braz, R., R. Girju, V. Punyakanok, D. Roth, and M. Sammons. 2005. An inference model for semantic entailment in natural language. In Proceedings ofAAAI, pages 1678–1679.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ana-Maria Giuglea</author>
<author>Alessandro Moschitti</author>
</authors>
<title>Semantic role labeling via framenet, verbnet and propbank.</title>
<date>2006</date>
<booktitle>In Proceedings of Coling-ACL,</booktitle>
<location>Sydney, Australia.</location>
<contexts>
<context position="10023" citStr="Giuglea and Moschitti, 2006" startWordPosition="1711" endWordPosition="1715">rs (wt, wh) and (w′t, wh) to be selected and a pair (st, sh) already selected, considers word proximity (in terms of number of words) between wt and st and between w′t and st; the nearest word will be chosen. Once the graph has been enriched with semantic information we need to represent it in the learning algorithm; for this purpose, an interesting approach is based on kernel methods. Since the considered graphs are composed by only two trees, we can carried out a simplified computation of a graph kernel based on tree kernel pairs. 3.1 Tree Kernels Tree Kernels (e.g. see NLP applications in (Giuglea and Moschitti, 2006; Zanzotto and Moschitti, 2006; Moschitti et al., 2007; Moschitti et al., 2006; Moschitti and Bejan, 2004)) represent trees in terms of their substructures (fragments) which are mapped into feature vector spaces, e.g. Rn. The kernel function measures the similarity between two trees by counting the number of their common fragments. For example, Figure 1 shows some substructures for the parse tree of the sentence &amp;quot;book a flight&amp;quot;. The main advantage of tree kernels is that, to compute the substructures shared by two trees 7-1 and 7-2, the whole fragment space is not used. In the following, we re</context>
</contexts>
<marker>Giuglea, Moschitti, 2006</marker>
<rawString>Giuglea, Ana-Maria and Alessandro Moschitti. 2006. Semantic role labeling via framenet, verbnet and propbank. In Proceedings of Coling-ACL, Sydney, Australia.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Oren Glickman</author>
<author>Ido Dagan</author>
</authors>
<title>Probabilistic textual entailment: Generic applied modeling of language variability.</title>
<date>2004</date>
<booktitle>In Proceedings ofthe Workshop on Learning Methods for Text Understanding and Mining,</booktitle>
<location>Grenoble, France.</location>
<contexts>
<context position="1341" citStr="Glickman and Dagan, 2004" startWordPosition="206" endWordPosition="209">eriments with Support Vector Machines and our new kernels for paired trees show the validity of our interpretation. 1 Introduction Recently, a lot of valuable work on the recognition of textual entailment (RTE) has been carried out (Bar Haim et al., 2006). The aim is to detect implications between sentences like: T1 ⇒ H1 T1 “Wanadoo bought KStones” H1 “Wanadoo owns KStones” where T1 and H1 stand for text and hypothesis, respectively. Several models, ranging from the simple lexical similarity between T and H to advanced Logic Form Representations, have been proposed (Corley and Mihalcea, 2005; Glickman and Dagan, 2004; de Salvo Braz et al., 2005; Bos and Markert, 2005). However, since a linguistic theory able to analytically show how to computationally solve the RTE problem has not been developed yet, to © 2008. Licensed under the Creative Commons Attribution-Noncommercial-Share Alike 3.0 Unported license (http://creativecommons.org/licenses/by-nc-sa/3.0/). Some rights reserved. design accurate systems, we should rely upon the application of machine learning. In this perspective, TE training examples have to be represented in terms of statistical feature distributions. These typically consist in word seque</context>
</contexts>
<marker>Glickman, Dagan, 2004</marker>
<rawString>Glickman, Oren and Ido Dagan. 2004. Probabilistic textual entailment: Generic applied modeling of language variability. In Proceedings ofthe Workshop on Learning Methods for Text Understanding and Mining, Grenoble, France.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Oren Glickman</author>
<author>Ido Dagan</author>
<author>Moshe Koppel</author>
</authors>
<title>Web based probabilistic textual entailment.</title>
<date>2005</date>
<booktitle>In Proceedings of the 1st Pascal Challenge Workshop,</booktitle>
<location>Southampton, UK.</location>
<contexts>
<context position="8300" citStr="Glickman et al., 2005" startWordPosition="1397" endWordPosition="1400">agments but, to generate the space of pairs of tree fragments, a new kernel function has to be defined. The next section provides a solution to both problems. i.e. an algorithm for placeholders assignments and for the computation of paired tree kernels which generates Rτ and Rτp representations. Figure 1: A syntactic parse tree. 3 Kernels over Semantic Tree Pair-based Graphs The previous section has shown that placeholders enrich a tree-based graph with relational information, which, in turn, can be captured by means of word semantic similarities simw(wt, wh), e.g. (Corley and Mihalcea, 2005; Glickman et al., 2005). More specifically, we use a two-step greedy algorithm to anchor the content words (verbs, nouns, adjectives, and adverbs) in the hypothesis WH to words in the text WT. In the first step, each word wh in WH is connected to all words wt in WT that have the maximum similarity simw(wt, wh) with it (more than one wt can have the maximum similarity with wh). As result, we have a set of anchors A C WT xWH. simw(wt, wh) is computed by means of three techniques: 1. Two words are maximally similar if they have the same surface form wt = wh. 2. Otherwise, WordNet (Miller, 1995) similarities (as in (Cor</context>
</contexts>
<marker>Glickman, Dagan, Koppel, 2005</marker>
<rawString>Glickman, Oren, Ido Dagan, and Moshe Koppel. 2005. Web based probabilistic textual entailment. In Proceedings of the 1st Pascal Challenge Workshop, Southampton, UK.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bernard Haasdonk</author>
</authors>
<title>Feature space interpretation of SVMs with indefinite kernels.</title>
<date>2005</date>
<journal>IEEE Trans Pattern Anal Mach Intell,</journal>
<volume>27</volume>
<issue>4</issue>
<contexts>
<context position="17294" citStr="Haasdonk, 2005" startWordPosition="3052" endWordPosition="3053">ig. 2. To assign the placeholders 1, 2 and 3 of (T2, H2) to those of (T1, H1), i.e. X and Y, we need to maximize the similarity between the two texts’ trees and between the two hypotheses’ trees. It is straightforward to derive that X=1 and Y=3 allow more substructures (i.e. large part of the trees) Finally, it should be noted that, (a) Ks((T, H), (T′, H′)) is a symmetric function since the set of derivation C are always computed with respect to the pair that has the largest anchor set and (b) it is not a valid kernel as the max function does not in general produce valid kernels. However, in (Haasdonk, 2005), it is shown that when kernel functions are not positive semidefinite like in this case, SVMs still solve a data separation problem in pseudo Euclidean spaces. The drawback is that the solution may be only a local optimum. Nevertheless, such solution can still be valuable as the problem is modeled with a very rich feature space. Regarding the computational complexity, running the above kernel on a large training set may result very expensive. To overcome this drawback, in (Moschitti and Zanzotto, 2007), it has been designed an algorithm to factorize the evaluation of tree subparts with respec</context>
</contexts>
<marker>Haasdonk, 2005</marker>
<rawString>Haasdonk, Bernard. 2005. Feature space interpretation of SVMs with indefinite kernels. IEEE Trans Pattern Anal Mach Intell, 27(4):482–92, Apr.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Thorsten Joachims</author>
</authors>
<title>Making large-scale svm learning practical.</title>
<date>1999</date>
<booktitle>Advances in Kernel MethodsSupport Vector Learning.</booktitle>
<editor>In Schlkopf, B., C. Burges, and A. Smola, editors,</editor>
<publisher>MIT Press.</publisher>
<contexts>
<context position="18370" citStr="Joachims, 1999" startWordPosition="3228" endWordPosition="3229">his drawback, in (Moschitti and Zanzotto, 2007), it has been designed an algorithm to factorize the evaluation of tree subparts with respect to the different substitution. The resulting speed-up makes the application of such kernel feasible for datasets of ten of thousands of instances. 5 Experiments The aim of the experiments is to show that the space of tree fragment pairs is the most effective to represent Tree Pair-based Graphs for the design of Textual Entailment classifiers. 5.1 Experimental Setup To compare our model with previous work we implemented the following kernels in SVM-light (Joachims, 1999): • Ks(e1, e2) = Kt(T1,T2) + Kt(H1, H2), where e1 = (T1, H1) and e2 = (T2, H2) are two text and hypothesis pairs and Kt is the syntactic tree kernel (Collins and Duffy, 2002) presented in the previous section. • Kp(e1, e2) = Kt(T1,T2) x Kt(H1, H2), which (as shown in the previous sections) ento be identical, e.g. [S [NP 1 X VP]] , [VP [VBP Y]], [S [NP VP [VBP NP 3 NP3 Y]]]. 1 X 29 Figure 2: The problem of finding the correct mapping between placeholders S T2 ⇒ H2 S S S KStones KStones T1 ⇒ H1 NP X NNP X Wanadoo VP NP Y VBP owns NNP Y NP X NNP X Wanadoo VBP bought NP Y NNP Y VP VP NP 1 PP 2 VBP</context>
</contexts>
<marker>Joachims, 1999</marker>
<rawString>Joachims, Thorsten. 1999. Making large-scale svm learning practical. In Schlkopf, B., C. Burges, and A. Smola, editors, Advances in Kernel MethodsSupport Vector Learning. MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>George A Miller</author>
</authors>
<title>WordNet: A lexical database for English.</title>
<date>1995</date>
<journal>Communications of the ACM,</journal>
<volume>38</volume>
<issue>11</issue>
<contexts>
<context position="8875" citStr="Miller, 1995" startWordPosition="1509" endWordPosition="1510">Mihalcea, 2005; Glickman et al., 2005). More specifically, we use a two-step greedy algorithm to anchor the content words (verbs, nouns, adjectives, and adverbs) in the hypothesis WH to words in the text WT. In the first step, each word wh in WH is connected to all words wt in WT that have the maximum similarity simw(wt, wh) with it (more than one wt can have the maximum similarity with wh). As result, we have a set of anchors A C WT xWH. simw(wt, wh) is computed by means of three techniques: 1. Two words are maximally similar if they have the same surface form wt = wh. 2. Otherwise, WordNet (Miller, 1995) similarities (as in (Corley and Mihalcea, 2005)) and different relation between words such as verb entailment and derivational morphology are applied. 3. The edit distance measure is finally used to capture the similarity between words that are missed by the previous analysis (for misspelling errors or for the lack of derivational forms in WordNet). In the second step, we select the final anchor set A′ ⊆ A, such that bwt (or wh) ∃!(wt, wh) E A′. The selection is based on a simple greedy algorithm that given two pairs (wt, wh) and (w′t, wh) to be selected and a pair (st, sh) already selected, </context>
</contexts>
<marker>Miller, 1995</marker>
<rawString>Miller, George A. 1995. WordNet: A lexical database for English. Communications of the ACM, 38(11):39–41, November.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alessandro Moschitti</author>
<author>Cosmin Adrian Bejan</author>
</authors>
<title>A semantic kernel for predicate argument classification.</title>
<date>2004</date>
<booktitle>In CoNLL-2004,</booktitle>
<location>USA.</location>
<contexts>
<context position="10129" citStr="Moschitti and Bejan, 2004" startWordPosition="1728" endWordPosition="1731"> terms of number of words) between wt and st and between w′t and st; the nearest word will be chosen. Once the graph has been enriched with semantic information we need to represent it in the learning algorithm; for this purpose, an interesting approach is based on kernel methods. Since the considered graphs are composed by only two trees, we can carried out a simplified computation of a graph kernel based on tree kernel pairs. 3.1 Tree Kernels Tree Kernels (e.g. see NLP applications in (Giuglea and Moschitti, 2006; Zanzotto and Moschitti, 2006; Moschitti et al., 2007; Moschitti et al., 2006; Moschitti and Bejan, 2004)) represent trees in terms of their substructures (fragments) which are mapped into feature vector spaces, e.g. Rn. The kernel function measures the similarity between two trees by counting the number of their common fragments. For example, Figure 1 shows some substructures for the parse tree of the sentence &amp;quot;book a flight&amp;quot;. The main advantage of tree kernels is that, to compute the substructures shared by two trees 7-1 and 7-2, the whole fragment space is not used. In the following, we report the formal definition presented in (Collins and Duffy, 2002). Given the set of fragments {f1, f2, ..}</context>
</contexts>
<marker>Moschitti, Bejan, 2004</marker>
<rawString>Moschitti, Alessandro and Cosmin Adrian Bejan. 2004. A semantic kernel for predicate argument classification. In CoNLL-2004, USA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Moschitti</author>
<author>F Zanzotto</author>
</authors>
<title>Fast and effective kernels for relational learning from texts.</title>
<date>2007</date>
<booktitle>Proceedings of the 24th Annual International Conference on Machine Learning (ICML</booktitle>
<editor>In Ghahramani, Zoubin, editor,</editor>
<contexts>
<context position="17802" citStr="Moschitti and Zanzotto, 2007" startWordPosition="3134" endWordPosition="3137"> (b) it is not a valid kernel as the max function does not in general produce valid kernels. However, in (Haasdonk, 2005), it is shown that when kernel functions are not positive semidefinite like in this case, SVMs still solve a data separation problem in pseudo Euclidean spaces. The drawback is that the solution may be only a local optimum. Nevertheless, such solution can still be valuable as the problem is modeled with a very rich feature space. Regarding the computational complexity, running the above kernel on a large training set may result very expensive. To overcome this drawback, in (Moschitti and Zanzotto, 2007), it has been designed an algorithm to factorize the evaluation of tree subparts with respect to the different substitution. The resulting speed-up makes the application of such kernel feasible for datasets of ten of thousands of instances. 5 Experiments The aim of the experiments is to show that the space of tree fragment pairs is the most effective to represent Tree Pair-based Graphs for the design of Textual Entailment classifiers. 5.1 Experimental Setup To compare our model with previous work we implemented the following kernels in SVM-light (Joachims, 1999): • Ks(e1, e2) = Kt(T1,T2) + Kt(</context>
</contexts>
<marker>Moschitti, Zanzotto, 2007</marker>
<rawString>Moschitti, A. and F. Zanzotto. 2007. Fast and effective kernels for relational learning from texts. In Ghahramani, Zoubin, editor, Proceedings of the 24th Annual International Conference on Machine Learning (ICML 2007).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alessandro Moschitti</author>
<author>Daniele Pighin</author>
<author>Roberto Basili</author>
</authors>
<title>Semantic Role Labeling via Tree Kernel Joint Inference.</title>
<date>2006</date>
<booktitle>In Proceedings of CoNLL-X.</booktitle>
<contexts>
<context position="10101" citStr="Moschitti et al., 2006" startWordPosition="1724" endWordPosition="1727">iders word proximity (in terms of number of words) between wt and st and between w′t and st; the nearest word will be chosen. Once the graph has been enriched with semantic information we need to represent it in the learning algorithm; for this purpose, an interesting approach is based on kernel methods. Since the considered graphs are composed by only two trees, we can carried out a simplified computation of a graph kernel based on tree kernel pairs. 3.1 Tree Kernels Tree Kernels (e.g. see NLP applications in (Giuglea and Moschitti, 2006; Zanzotto and Moschitti, 2006; Moschitti et al., 2007; Moschitti et al., 2006; Moschitti and Bejan, 2004)) represent trees in terms of their substructures (fragments) which are mapped into feature vector spaces, e.g. Rn. The kernel function measures the similarity between two trees by counting the number of their common fragments. For example, Figure 1 shows some substructures for the parse tree of the sentence &amp;quot;book a flight&amp;quot;. The main advantage of tree kernels is that, to compute the substructures shared by two trees 7-1 and 7-2, the whole fragment space is not used. In the following, we report the formal definition presented in (Collins and Duffy, 2002). Given the s</context>
</contexts>
<marker>Moschitti, Pighin, Basili, 2006</marker>
<rawString>Moschitti, Alessandro, Daniele Pighin, and Roberto Basili. 2006. Semantic Role Labeling via Tree Kernel Joint Inference. In Proceedings of CoNLL-X.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alessandro Moschitti</author>
<author>Silvia Quarteroni</author>
<author>Roberto Basili</author>
<author>Suresh Manandhar</author>
</authors>
<title>Exploiting syntactic and shallow semantic kernels for question answer classification.</title>
<date>2007</date>
<booktitle>In Proceedings ACL,</booktitle>
<location>Prague, Czech Republic.</location>
<contexts>
<context position="10077" citStr="Moschitti et al., 2007" startWordPosition="1720" endWordPosition="1723">) already selected, considers word proximity (in terms of number of words) between wt and st and between w′t and st; the nearest word will be chosen. Once the graph has been enriched with semantic information we need to represent it in the learning algorithm; for this purpose, an interesting approach is based on kernel methods. Since the considered graphs are composed by only two trees, we can carried out a simplified computation of a graph kernel based on tree kernel pairs. 3.1 Tree Kernels Tree Kernels (e.g. see NLP applications in (Giuglea and Moschitti, 2006; Zanzotto and Moschitti, 2006; Moschitti et al., 2007; Moschitti et al., 2006; Moschitti and Bejan, 2004)) represent trees in terms of their substructures (fragments) which are mapped into feature vector spaces, e.g. Rn. The kernel function measures the similarity between two trees by counting the number of their common fragments. For example, Figure 1 shows some substructures for the parse tree of the sentence &amp;quot;book a flight&amp;quot;. The main advantage of tree kernels is that, to compute the substructures shared by two trees 7-1 and 7-2, the whole fragment space is not used. In the following, we report the formal definition presented in (Collins and D</context>
</contexts>
<marker>Moschitti, Quarteroni, Basili, Manandhar, 2007</marker>
<rawString>Moschitti, Alessandro, Silvia Quarteroni, Roberto Basili, and Suresh Manandhar. 2007. Exploiting syntactic and shallow semantic kernels for question answer classification. In Proceedings ACL, Prague, Czech Republic.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alessandro Moschitti</author>
</authors>
<title>Efficient convolution kernels for dependency and constituent syntactic trees.</title>
<date>2006</date>
<booktitle>In ECML’06.</booktitle>
<contexts>
<context position="4116" citStr="Moschitti, 2006" startWordPosition="655" endWordPosition="656">tains all possible concatenations of words respecting their order. 25 Coling 2008: Proceedings of 3rd Textgraphs workshop on Graph-Based Algorithms in Natural Language Processing, pages 25–32 Manchester, August 2008 For this purpose, kernel methods, and in particular tree kernels allow for representing trees in terms of all possible subtrees (Collins and Duffy, 2002). Unfortunately, the representation in entailment recognition problems requires the definition of kernels over graphs constituted by tree pairs, which are in general different from kernels applied to single trees. In (Zanzotto and Moschitti, 2006), this has been addressed by introducing semantic links (placeholders) between text and hypothesis parse trees and evaluating two distinct tree kernels for the trees of texts and for those of hypotheses. In order to make such disjoint kernel combination effective, all possible assignments between the placeholders of the first and the second entailment pair were generated causing a remarkable slowdown. In this paper, we describe the feature space of all possible tree fragment pairs and we show that it can be evaluated with a much simpler kernel than the one used in previous work, both in terms </context>
<context position="6402" citStr="Moschitti, 2006" startWordPosition="1040" endWordPosition="1041">H1 of the previous section, we would have the following relational description: 2By cutting derivation at different depth, different degrees of generalization can be obtained. RT NP NP ={ ( , ) , ( , NNP NNP NP VP NP VP These features (relational pairs) generalize the entailment property, e.g. the pair ([VP [VBP bought] [NP]], [VP [VBP own] [NP]]) generalizes many word sequences, i.e. those external to the verbal phrases and internal to the NPs. We can improve this space by adding semantic links between the tree fragments. Such links or placeholders have been firstly proposed in (Zanzotto and Moschitti, 2006). A placeholder assigned to a node of τt and a node of τh states that such nodes dominate the same (or similar) information. In particular, placeholders are assigned to nodes whose words ti in T are equal, similar, or semantically dependent on words hj in H. Using placeholders, we obtain a richer fragment pair based representation that we call RTp, exemplified hereafter: The placeholders (or variables) indicated with X and Y specify that the NNPs labeled by the same variables dominate similar or identical words. Therefore, an automatic algorithm that assigns placeholders to semantically simila</context>
<context position="10023" citStr="Moschitti, 2006" startWordPosition="1714" endWordPosition="1715">and (w′t, wh) to be selected and a pair (st, sh) already selected, considers word proximity (in terms of number of words) between wt and st and between w′t and st; the nearest word will be chosen. Once the graph has been enriched with semantic information we need to represent it in the learning algorithm; for this purpose, an interesting approach is based on kernel methods. Since the considered graphs are composed by only two trees, we can carried out a simplified computation of a graph kernel based on tree kernel pairs. 3.1 Tree Kernels Tree Kernels (e.g. see NLP applications in (Giuglea and Moschitti, 2006; Zanzotto and Moschitti, 2006; Moschitti et al., 2007; Moschitti et al., 2006; Moschitti and Bejan, 2004)) represent trees in terms of their substructures (fragments) which are mapped into feature vector spaces, e.g. Rn. The kernel function measures the similarity between two trees by counting the number of their common fragments. For example, Figure 1 shows some substructures for the parse tree of the sentence &amp;quot;book a flight&amp;quot;. The main advantage of tree kernels is that, to compute the substructures shared by two trees 7-1 and 7-2, the whole fragment space is not used. In the following, we re</context>
<context position="12090" citStr="Moschitti, 2006" startWordPosition="2126" endWordPosition="2127">pre-terminals symbols) then O(n1, n2) = 1; 3. if the productions at n1 and n2 are the same, and n1 and n2 are not pre-terminals then nc(n1) O(n1, n2) = H (1 + O(cjn1, cjn2)) (3) j=1 where nc(n1) is the number of the children of n1 and cjn is the j-th child of the node n. Note that since the productions are the same, nc(n1) = nc(n2). Additionally, we add the decay factor A by modifying steps (2) and (3) as follows3: 2. O(n1, n2) = A, nc(n1) 3. O(n1, n2) = A H (1 + O(cjn1, cjn2)). j=1 The computational complexity of Eq. 2 is O(|Nτ1 |x |Nτ2|) although the average running time tends to be linear (Moschitti, 2006). 3.2 Tree-based Graph Kernels The above tree kernel function can be applied to the parse trees of two texts or those of the two hypotheses to measure their similarity in terms of the shared fragments. If we sum the contributions of the two kernels (for texts and for hypotheses) as proposed in (Zanzotto and Moschitti, 2006), we just obtain the feature space of the union of the fragments which is completely different from the space of the tree fragments pairs, i.e. Rτ. Note that the union space is not useful to describe which 3To have a similarity score between 0 and 1, we also apply the normal</context>
<context position="14353" citStr="Moschitti, 2006" startWordPosition="2528" endWordPosition="2529">ences is the kernel product, which corresponds to the set of all possible syntactic fragment pairs. Note that, such kernel can be also used to evaluate the space of fragment pairs for trees enriched with relational information, i.e. by placeholders. 4 Approximated Graph Kernel The feature space described in the previous section correctly encodes the fragment pairs. However, such huge space may result inadequate also for algorithms such as SVMs, which are in general robust to many irrelevant features. An approximation of the fragment pair space is given by the kernel described in (Zanzotto and Moschitti, 2006). Hereafter we illustrate its main points. First, tree kernels applied to two texts or two hypotheses match identical fragments. When placeholders are added to trees, the labeled fragments �= � � � n1ET1 n2ET2 n3EH1 n4EH2 28 are matched only if the basic fragments and the assigned placeholders match. This means that we should use the same placeholders for all texts and all hypotheses of the corpus. Moreover, they should be assigned in a way that similar syntactic structures and similar relational information between two entailment pairs can be matched, i.e. same placeholders should be assigned</context>
<context position="19574" citStr="Moschitti, 2006" startWordPosition="3484" endWordPosition="3485">P 1 PP 2 VBP NP 3 NP 1 DT NN 1 the president DT IN NP 2 NN 3 of bought a castle NNP 2 Miramax NP 1 VP castle a NP 1 DT NN 1 the president PP 2 NP 3 VBP NP 2 NN 3 IN DT own of NNP 2 Miramax codes the tree fragment pairs with and without placeholders. • Kmax(e1, e2) = Max (Kt(Oc(T1), Oc(T2)) + Kt(Oc(H1), Oc(H2))), where c is a possic∈C ble placeholder assignment which connects nodes from the first pair with those of the second pair and Oc(·) transforms trees according to c. • Kpmx(e1, e2) = Max (Kt(Oc(T1), Oc(T2)) × Kt(Oc(H1), Oc(H2))). c∈C Note that Kmax is the kernel proposed in (Zanzotto and Moschitti, 2006) and Kpmx is a hybrid kernel based on the maximum Kp, which uses the space of tree fragment pairs. For all the above kernels, we set the default cost factor and trade-off parameters and we set A to 0.4. To experiment with entailment relations, we used the data sets made available by the first (Dagan et al., 2005) and second (Bar Haim et al., 2006) Recognizing Textual Entailment Challenge. These corpora are divided in the development sets D1 and D2 and the test sets T1 and T2. D1 contains 567 examples whereas T1, D2 and T2 all have the same size, i.e. 800 instances. Each example is an ordered p</context>
<context position="21550" citStr="Moschitti, 2006" startWordPosition="3836" endWordPosition="3838">e effective for encoding the syntactic rules describing the entailment concept. Second, on RTE1, the introduction of placeholders does not improve Kp or Ks suggesting that for their correct exploitation an extension of the space of tree fragment pairs should be modeled. Third, on RTE2, the impact of placeholders seems more important but only Kmax and Ks are able to fully exploit their semantic contribution. A possible explanation is that in order to use the set of all possible assignments (required by Kmax), we needed to prune the ”too large” syntactic trees as also suggested in (Zanzotto and Moschitti, 2006). This may have negatively biased the statistical distribution of tree fragment pairs. Finally, although we show that Kp is better 30 Kernels RTE1 RTE2 ¬ P P ¬ P P Ks 54.9 50.0 52.6 59.5 Kp 58.9 55.5 53.5 56.0 Kmax - 58.25 - 61.0 Kpmx - 50.0 - 56.8 Table 1: Accuracy of different kernel models using (P) and not using (¬ P) placeholder information on RTE1 and RTE2. Acknowledgments We would like to thank the anonymous reviewers for their professional and competent reviews and for their invaluable suggestions. Alessandro Moschitti would like to thank the European Union project, LUNA (spoken Langua</context>
</contexts>
<marker>Moschitti, 2006</marker>
<rawString>Moschitti, Alessandro. 2006. Efficient convolution kernels for dependency and constituent syntactic trees. In ECML’06.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fabio Massimo Zanzotto</author>
<author>Alessandro Moschitti</author>
</authors>
<title>Automatic learning of textual entailments with cross-pair similarities.</title>
<date>2006</date>
<booktitle>In Proceedings of the 21st Coling and 44th ACL,</booktitle>
<pages>401--408</pages>
<location>Sydney, Australia,</location>
<contexts>
<context position="4116" citStr="Zanzotto and Moschitti, 2006" startWordPosition="653" endWordPosition="656">. it only contains all possible concatenations of words respecting their order. 25 Coling 2008: Proceedings of 3rd Textgraphs workshop on Graph-Based Algorithms in Natural Language Processing, pages 25–32 Manchester, August 2008 For this purpose, kernel methods, and in particular tree kernels allow for representing trees in terms of all possible subtrees (Collins and Duffy, 2002). Unfortunately, the representation in entailment recognition problems requires the definition of kernels over graphs constituted by tree pairs, which are in general different from kernels applied to single trees. In (Zanzotto and Moschitti, 2006), this has been addressed by introducing semantic links (placeholders) between text and hypothesis parse trees and evaluating two distinct tree kernels for the trees of texts and for those of hypotheses. In order to make such disjoint kernel combination effective, all possible assignments between the placeholders of the first and the second entailment pair were generated causing a remarkable slowdown. In this paper, we describe the feature space of all possible tree fragment pairs and we show that it can be evaluated with a much simpler kernel than the one used in previous work, both in terms </context>
<context position="6402" citStr="Zanzotto and Moschitti, 2006" startWordPosition="1038" endWordPosition="1041">given T1 and H1 of the previous section, we would have the following relational description: 2By cutting derivation at different depth, different degrees of generalization can be obtained. RT NP NP ={ ( , ) , ( , NNP NNP NP VP NP VP These features (relational pairs) generalize the entailment property, e.g. the pair ([VP [VBP bought] [NP]], [VP [VBP own] [NP]]) generalizes many word sequences, i.e. those external to the verbal phrases and internal to the NPs. We can improve this space by adding semantic links between the tree fragments. Such links or placeholders have been firstly proposed in (Zanzotto and Moschitti, 2006). A placeholder assigned to a node of τt and a node of τh states that such nodes dominate the same (or similar) information. In particular, placeholders are assigned to nodes whose words ti in T are equal, similar, or semantically dependent on words hj in H. Using placeholders, we obtain a richer fragment pair based representation that we call RTp, exemplified hereafter: The placeholders (or variables) indicated with X and Y specify that the NNPs labeled by the same variables dominate similar or identical words. Therefore, an automatic algorithm that assigns placeholders to semantically simila</context>
<context position="10053" citStr="Zanzotto and Moschitti, 2006" startWordPosition="1716" endWordPosition="1719">be selected and a pair (st, sh) already selected, considers word proximity (in terms of number of words) between wt and st and between w′t and st; the nearest word will be chosen. Once the graph has been enriched with semantic information we need to represent it in the learning algorithm; for this purpose, an interesting approach is based on kernel methods. Since the considered graphs are composed by only two trees, we can carried out a simplified computation of a graph kernel based on tree kernel pairs. 3.1 Tree Kernels Tree Kernels (e.g. see NLP applications in (Giuglea and Moschitti, 2006; Zanzotto and Moschitti, 2006; Moschitti et al., 2007; Moschitti et al., 2006; Moschitti and Bejan, 2004)) represent trees in terms of their substructures (fragments) which are mapped into feature vector spaces, e.g. Rn. The kernel function measures the similarity between two trees by counting the number of their common fragments. For example, Figure 1 shows some substructures for the parse tree of the sentence &amp;quot;book a flight&amp;quot;. The main advantage of tree kernels is that, to compute the substructures shared by two trees 7-1 and 7-2, the whole fragment space is not used. In the following, we report the formal definition pre</context>
<context position="12415" citStr="Zanzotto and Moschitti, 2006" startWordPosition="2181" endWordPosition="2184">same, nc(n1) = nc(n2). Additionally, we add the decay factor A by modifying steps (2) and (3) as follows3: 2. O(n1, n2) = A, nc(n1) 3. O(n1, n2) = A H (1 + O(cjn1, cjn2)). j=1 The computational complexity of Eq. 2 is O(|Nτ1 |x |Nτ2|) although the average running time tends to be linear (Moschitti, 2006). 3.2 Tree-based Graph Kernels The above tree kernel function can be applied to the parse trees of two texts or those of the two hypotheses to measure their similarity in terms of the shared fragments. If we sum the contributions of the two kernels (for texts and for hypotheses) as proposed in (Zanzotto and Moschitti, 2006), we just obtain the feature space of the union of the fragments which is completely different from the space of the tree fragments pairs, i.e. Rτ. Note that the union space is not useful to describe which 3To have a similarity score between 0 and 1, we also apply the normalization in the kernel space, i.e. K′(T1,T2) = TK(τ1,τ2) √T K(τ1,τ1)×T K(τ2,τ2). grammatical and lexical property is at the same time held by T and H to trig the implication. Therefore to generate the space of the fragment pairs we need to define the kernel between two pairs of entailment examples (T1, H1) and (T2, H2) as Kp</context>
<context position="14353" citStr="Zanzotto and Moschitti, 2006" startWordPosition="2526" endWordPosition="2529">tailment sentences is the kernel product, which corresponds to the set of all possible syntactic fragment pairs. Note that, such kernel can be also used to evaluate the space of fragment pairs for trees enriched with relational information, i.e. by placeholders. 4 Approximated Graph Kernel The feature space described in the previous section correctly encodes the fragment pairs. However, such huge space may result inadequate also for algorithms such as SVMs, which are in general robust to many irrelevant features. An approximation of the fragment pair space is given by the kernel described in (Zanzotto and Moschitti, 2006). Hereafter we illustrate its main points. First, tree kernels applied to two texts or two hypotheses match identical fragments. When placeholders are added to trees, the labeled fragments �= � � � n1ET1 n2ET2 n3EH1 n4EH2 28 are matched only if the basic fragments and the assigned placeholders match. This means that we should use the same placeholders for all texts and all hypotheses of the corpus. Moreover, they should be assigned in a way that similar syntactic structures and similar relational information between two entailment pairs can be matched, i.e. same placeholders should be assigned</context>
<context position="19574" citStr="Zanzotto and Moschitti, 2006" startWordPosition="3482" endWordPosition="3485">NNP Y VP VP NP 1 PP 2 VBP NP 3 NP 1 DT NN 1 the president DT IN NP 2 NN 3 of bought a castle NNP 2 Miramax NP 1 VP castle a NP 1 DT NN 1 the president PP 2 NP 3 VBP NP 2 NN 3 IN DT own of NNP 2 Miramax codes the tree fragment pairs with and without placeholders. • Kmax(e1, e2) = Max (Kt(Oc(T1), Oc(T2)) + Kt(Oc(H1), Oc(H2))), where c is a possic∈C ble placeholder assignment which connects nodes from the first pair with those of the second pair and Oc(·) transforms trees according to c. • Kpmx(e1, e2) = Max (Kt(Oc(T1), Oc(T2)) × Kt(Oc(H1), Oc(H2))). c∈C Note that Kmax is the kernel proposed in (Zanzotto and Moschitti, 2006) and Kpmx is a hybrid kernel based on the maximum Kp, which uses the space of tree fragment pairs. For all the above kernels, we set the default cost factor and trade-off parameters and we set A to 0.4. To experiment with entailment relations, we used the data sets made available by the first (Dagan et al., 2005) and second (Bar Haim et al., 2006) Recognizing Textual Entailment Challenge. These corpora are divided in the development sets D1 and D2 and the test sets T1 and T2. D1 contains 567 examples whereas T1, D2 and T2 all have the same size, i.e. 800 instances. Each example is an ordered p</context>
<context position="21550" citStr="Zanzotto and Moschitti, 2006" startWordPosition="3834" endWordPosition="3838">pairs are more effective for encoding the syntactic rules describing the entailment concept. Second, on RTE1, the introduction of placeholders does not improve Kp or Ks suggesting that for their correct exploitation an extension of the space of tree fragment pairs should be modeled. Third, on RTE2, the impact of placeholders seems more important but only Kmax and Ks are able to fully exploit their semantic contribution. A possible explanation is that in order to use the set of all possible assignments (required by Kmax), we needed to prune the ”too large” syntactic trees as also suggested in (Zanzotto and Moschitti, 2006). This may have negatively biased the statistical distribution of tree fragment pairs. Finally, although we show that Kp is better 30 Kernels RTE1 RTE2 ¬ P P ¬ P P Ks 54.9 50.0 52.6 59.5 Kp 58.9 55.5 53.5 56.0 Kmax - 58.25 - 61.0 Kpmx - 50.0 - 56.8 Table 1: Accuracy of different kernel models using (P) and not using (¬ P) placeholder information on RTE1 and RTE2. Acknowledgments We would like to thank the anonymous reviewers for their professional and competent reviews and for their invaluable suggestions. Alessandro Moschitti would like to thank the European Union project, LUNA (spoken Langua</context>
</contexts>
<marker>Zanzotto, Moschitti, 2006</marker>
<rawString>Zanzotto, Fabio Massimo and Alessandro Moschitti. 2006. Automatic learning of textual entailments with cross-pair similarities. In Proceedings of the 21st Coling and 44th ACL, pages 401–408, Sydney, Australia, July.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>