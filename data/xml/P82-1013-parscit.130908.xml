<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000009">
<note confidence="0.337072">
NATURAL LANGUAGE DATABASE UPDATES
</note>
<author confidence="0.651249">
Sharon C. Salveter
David Maier
</author>
<affiliation confidence="0.708555">
Computer Science Department
SUNY Stony Brook
</affiliation>
<address confidence="0.602151">
Stony Brook, NY 11794
</address>
<email confidence="0.442762">
ABSTRACT
</email>
<bodyText confidence="0.999958625">
Although a great deal of research effort has
been expended in support of natural language (NL)
database querying, little effort has gone to NL
database update. One reason for this state of
affairs is that in NL querying, one can tie nouns
and stative verbs in the query to database objects
(relation names, attributes and domain values). In
many cases this correspondence seems sufficient to
interpret NL queries. ND update seems to require
database counterparts for active verbs, such as
&amp;quot;hire,&amp;quot; &amp;quot;schedule&amp;quot; and &amp;quot;enroll,&amp;quot; rather than for
stative entities. There seem to be no natural can-
didates to fill this role.
We suggest a database counterpart for active
verbs, which we call verbgraphs. The verbgraphs
may be used to support NL update. A verbgraph is a
structure for representing the various database
changes that a given verb might describe. In addi-
tion to describing the variants of a verb, they may
be used to disambiguate the update command. Other
possible uses of verbgraphs include, specification
of defaults, prompting of the user to guide but not
dictate user interaction and enforcing a variety of
types of database integrity constraints.
</bodyText>
<sectionHeader confidence="0.735278" genericHeader="abstract">
I. MOTIVIATION AND PROBLEM STATEMENT
</sectionHeader>
<bodyText confidence="0.980731413793104">
We want to support natural language interface
for all aspects of database manipulation. English
and English-like query systems already exist, such
as ROBOT[Ha77], TQA[Da78], LUNAR[W076] and those
described by Kaplan[Ka79], Walker[Wa78] and Waltz
[Wz75]. We propose to extend natural language
interaction to include data modification (insert,
delete, modify) rather than simply data extraction.
The desirability and unavailability of natural lan-
guage database modification has been noted by
Wiederhold, et al.[Wi81]. Database systems cur-
rently do not contain structures for explicit model-
ling of real world changes.
A state of a database (DB) is meant to repre-
sent a state of a portion of the real world.
This research is partially supported by NSF grants
IST-79-18264 and ENG-79-07794.
lie refer to the abstract description of the portion
of the real world being modelled as the semantic
data description (SDD). A SDD indicates a set of
real world states (RWS) of interest, a DB defini-
tion gives a set of allowable database states
(DES). The correspondence between the SDD and the
DB definition induces connections between DB states
and real world states. The situation is diagrammed
in Figure 1.
Real World Database
semantic database
description correspondence definition
</bodyText>
<figureCaption confidence="0.84695">
Figure 1
</figureCaption>
<bodyText confidence="0.997788705882353">
Natural language (NL) querying of the DB re-
quires that the correspondence between the SDD and
the DB definition be explicitly stated. The query
system must translate a question phrased in terms
of the SDD into a question phrased in terms of a
data retrieval command in the language of the DB
system. The response to the command must be trans-
lated back into terms of the SDD, which yields
information about the real world state. For NL
database modification, this stative correspondence
between DB states and real world states is not
adequate. We want changes in the real world to be
reflected in the DB. In Figure 2 we see that when
some action in the real world causes a state change
from RWS1 to RWS2, we must perform some modifica-
tion to the DB to change its state from DBS1 to
DBS2.
</bodyText>
<figure confidence="0.601064">
Real World Database
RWS1 1 â€¢ DBS1
1 action DHL
RWS2 &lt; &apos;&gt;DBS2
</figure>
<figureCaption confidence="0.86399">
Figure 2
</figureCaption>
<figure confidence="0.972434">
DBS1
DBS2
DBS3
</figure>
<page confidence="0.997891">
67
</page>
<bodyText confidence="0.971002888888889">
We have a means to describe the action that
changed the state of the real world: active verbs.
We also have a means to describe a change in the
DB state: data manipulation language (DML) com-
mand sequences. But given a real world-action, how
do we find a DML command sequence that will accomp-
lish the corresponding change in the DB?
Before we explore ways to represent his
active correspondence--the connection between real
world actions and DB updates--, let us examine how
the stative correspondence is captured for use by
a NL query system. We need to connect entities
and relationships in the SDD with files, fields
and field values in the DB. This stative corres-
pondence between RWS and DBS is generally specif-
ied in a system file. For example, in Harris&apos;
ROBOT system, the semantic description is implicit,
and it is assumed to be given in English. The
entities and relationships in the description are
roughly English nouns and stative verbs. The
correspondence of the SDD to the DB is given by a
lexicon that associates English words with files,
fields and field values in the DB. This lexicon
also gives possible referents for word and phrases
such as &amp;quot;who,&amp;quot; &amp;quot;where&amp;quot; and &amp;quot;how much.&amp;quot;
Consider the following example. Suppose we
have an office DB of employees and their scheduled
meetings, reservations for meeting rooms and mes-
sages from one employee to another. We capture
this information in the following four relations,
EMP(name,office,phone,supervisor)
APPOINTMENT(name,date,time,duration,who,
topic ,location)
MAILBOX(name,date,time,from,message)
ROOMRESERVE(room,date,time,duration,reserver)
with domains (permissible sets of values):
DOMAIN ATTRIBUTES
eliminate the first possibility. Thus we can
arrive at the query
in EMP, ROOMRESERVE retrieve name, phone where
name = reserver and room = 85 and time =
2:45pm and date = CURRENTDATE
Suppose we now want to make a change to the
database:
&amp;quot;Schedule Bob Marley for 2:15pm Friday.&amp;quot;
This request could mean schedule a meeting with an
individual or schedule Bob Marley for a seminar.
We want to connect &amp;quot;schedule&amp;quot; with the insertion
of a tuple in either APPOINTMENT or ROOMRESERVE.
Although we may have pointers from &amp;quot;schedule&amp;quot; to
APPOINTMENT and ROOMRESERVE, we do not have ade-
quate information for choosing the relation to up-
date.
Although files, fields, domains and values
seem to be adequate for expressing the stative
correspondence, we have no similar DB objects to
which we may tie verbs that describe actions in
the real world. The best we can do with files,
fields and domains is to indicate what is to be
modified; we cannot specify how to make the modif-
ication. We need to connect the verbs &amp;quot;schedule,&amp;quot;
&amp;quot;hire&amp;quot; and &amp;quot;reserve&amp;quot; with some structures that
dictate appropriate DML sequences that perform the
corresponding updates to the DB. The best we have
is a specific DM1 command sequence, a transaction,
for each instance of &amp;quot;schedule&amp;quot; in the real world.
No single transaction truly represents all the
implications and variants of the &amp;quot;schedule&amp;quot; action.
&amp;quot;Schedule&amp;quot; really corresponds to a set of similar
transactions, or perhaps some parameterized version
of a DB transaction.
induced connections
</bodyText>
<equation confidence="0.975632625">
1.
RWS2
RWS1
S2\
RWS3
DBS2
DBS1
DBS3
</equation>
<bodyText confidence="0.968374073170732">
personname
roomnum
plionenum
calendardate
clocktime
elapsedtime
text
name, who, from, reserver, supervisor
room, location, office
phone
date
time
duration
message, topic
Consider an analysis of the query
&amp;quot;What is the name and phone # of the person
who reserved room 85 for 2:45pm today?&amp;quot;
Using the lexicon, we can tie words in the query to
domains and relations.
name - personname reserve - ROOMRESERVE
relation
phone - phonenum room - roomnum
person - personname 2:45pm - clocktime
who - personname - calendardate
We need to connect relations MP and ROOMRESERVE.
The possible joins are room-office and name-
reserver. If we have stored the information that
offices and reservable rooms never intersect, we can
&amp;quot;Schedule&amp;quot;4Parameterized
Transaction (PT)
Figure 3
The desired situation is shown in Figure 3.
We 1-;-. 1 an active correspondence between &amp;quot;schedule&amp;quot;
anu a parameterized DB transaction PT. Different
instances of the schedule action, Si and S2, cause
different changes in the real world state. From
the active correspondence of &amp;quot;schedule&amp;quot; and PT, we
want to produce the proper transaction, Ti or T2,
to effect the correct change in the DB state.
There is not an existing candidate for the high-
level specification language for verb descriptions.
</bodyText>
<page confidence="0.996703">
68
</page>
<bodyText confidence="0.973762134831461">
We must be able to readily express the correspond-
ence between actions in the semantic world and
verb descriptions in this high-level specification
We depend heavily on this correspondence to proc-
ess natural language updates, just as the stative
correspondence is used to process natural language
queries. In the next section we examine these
requirements in more detail and offer, by example,
one candidate for the representation.
Another indication of the problem of active
verbs in DB shows up in looking a semantic data
languages. Sematnic data models are systems for
constructing precise descriptions of protions of
the real world - semantic data description (SDD)-
using terms that come from the real world rather
than a particular DB system. A SDD is a starting
point for designing and comparing particular DB
implementations. Some of the semantic models that
have been proposed are the entity-relationship
model[Ch76], SDMEHM81], RM/T[Co79], TAXIS[MB80]
and Beta[Br78]. For some of these models, method-
ologies exist for translating to a DB specification
in various DB models, as well as for expressing
the static correspondence between a SDD in the
semantic model and a particular DB implementation.
To express actions in these models, however, there
are only terms that refer to DBs: insert, delete,
modify, rather than schedule, cancel, postpone
(the notable exception is Skuce[Sk80]).
While there have been a number of approaches
made to NL querying, there seems to be little work
on NI update. Carbonell and Hayes[CH81] have
looked at parsing a limited set of NL update com-
mands, but they do not say much about generating
the DB transactions for these commands. Kaplan
and Davidson[KD81] have looked at the translation
of NL updates to transactions, but the active
verbs they deal with are synonyms for DB terms,
essentially following the semantic data model as
above. This limitation is intentional, as the
following excerpt shows:
First, it is assume that the underlying
database update must be a series of trans-
actions of the same type indicated in the
request. That is, if the update requests
a deletion, this can only be mapped into
a series of deletions in the database.
While some active verbs, such as &amp;quot;schedule,&amp;quot;
may correspond to a single type of DB update,
there are other verbs that will require multiple
types of DB updates, such as &amp;quot;cancel,&amp;quot; which
might require sending message as well as removing
an appointment. &apos;Kaplan and Davidson are also
trying to be domain independent, while we are
trying to exploit domain-specific information.
II. NATURE OF THE REPRESENTATION
We propose a structure, a verbgraph, to repre-
sent action verbs. Verbgraph are extensions of
frame-like structures used to represent verb mean-
ing in MORAN[Sa78] and [Sa79]. One verbgraph is
associated with each sense of a verb; that struc-
ture represents all variants. A real world change
is described by a sentence that contains an active
verb; the DB changes are accomplished by DML com-
mand sequences. A verbgraph is used to select
DML sequences appropriate to process the variants
of verb sense. We also wish to capture that one
verb that may be used as part of another: we may
have a verb sense RESERVE-ROOM that may be used by
itself or may be used as a subpart of the verb
SCHEDULE-TALK.
Figure 4 is an example of verbgraph. It
models the &amp;quot;schedule appointment&amp;quot; sense of the
verb &amp;quot;schedule.&amp;quot; There are four basic variants we
are attempting to capture; they are distinguished
by whether or not the appointment is scheduled with
someone in the company and whether or not a meeting
room is to be reserved. There is also the possi-
bility that the supervisor must be notified of
the meeting.
The verbgraph is directed acyclic graph (DAG)
with 5 kinds of nodes: header, footer, informa-
tion, AND (0) and OR (D). Header is the source of
the graph, the footer is the sink. Every informa-
tion node has one incoming and outgoing edge. An
AND or OR node can have any number of incoming or
outgoing edges. A variant corresponds to a
directed path in the graph. We define a path to
be connected subgraph such that
</bodyText>
<listItem confidence="0.994564666666667">
1) the header is included;
2) the footer is included;
3) if it contains an information node, it
contains the incoming and outgoing edge;
4) if it contains an AND node, it contains
all incoming and outgoing edges; and
5) if it contains an OR node, it contains
exactly one incoming and one outgoing
edge.
</listItem>
<bodyText confidence="0.99985532">
We can think of tracing a path in the graph by
starting at the header and following its outgoing
edge. Whenever we encounter an information node,
we go through it. Whenever we encounter an AND
node, the path divides and follows all outgoing
edges. We may only pass through an AND node if
all its incoming edges have been followed. An OR
node can be entered on only one edge and we leave
it by any of its outgoing edges.
An example of a complete path is one that
consists of theheader, footer, information nodes,
A, B, D, J, and connector nodes, a, b, c, d, g, k,
1, n. Although there is a direction to paths, we
do not intend that the order of nodes on a path
implies any order of prncessing the graph, except
the footer node is always last to be processed.
A variant of a verb sense is described by the set
of all expressions in the information nodes con-
tained in a path.
Expressions in the information nodes can be
of two basic types: assignment and restriction.
The assignment type produces a value to be used
in the update, either by input or computation; the
key word input indicates the value comes from the
user. Some examples of assignment are:
</bodyText>
<page confidence="0.994788">
69
</page>
<figure confidence="0.696606">
SORIMULE-APPOINTMENT
</figure>
<figureCaption confidence="0.983071">
Figure 4 in APPOINTMENT insert AFFT, APT
in ROOMRESERVE insert RES
</figureCaption>
<figure confidence="0.946058023255814">
R1
- APPT.who
APPT. name
- APPT. time
â€” APPr. date
APIT. topic
AFP. T. where
APPT.who la
APPT2.name
APPT2.who â€”
APPT2.time
APPT2.date
APPT2.topie
APPT2.where
R3
APPT.where not in R2
APF,where inout from
_L16
4./
APPT.who not in
AY&amp;
APPT.where â€”R2
APPT. where not In R3
RES.room APPT.where
RES.date â€” APPT.date
R2S.reserver APPT.name
RES.tims â€” APPT.time
RES.duration APPT.duration
APPT.where invut from roomnum
call INFORM(APPT.who,
APPT.name, &apos;Meeting
with me on OPPT.date
at UPPT.time&apos;)
call OF0RM(R4, APPT.name, &apos;Meeting
with 12APPT.wno on IgAPPT.date in
room UPPT.where&apos;)
a
APPT.name â€” USER
APPT.time invut from eloektime
APPT.duration inout from elapsedtime
APPT. date inout from ealendardate
APPT.who input from personname
APPT.topic inout from text
</figure>
<page confidence="0.973544">
70
</page>
<bodyText confidence="0.978591285714286">
1) (node labelled A in Figure 4)
APPT.who -4- input from personname
The user must provide a value from the domain
personname.
2) (node labelled D in Figure 4)
RES.date 4- APPT.date
The value for APPT.date is used as the value
RES.date.
An example of restriction is: (node B in Figure 4)
APPT.who in R1 where R1 = in EMP retrieve name
This statement restricts the value of APPT.who to
be a company employee.
Also in Figure 4, the symbols RI, R2, R3 and R4
stand for the retrievals
</bodyText>
<equation confidence="0.963683142857143">
RI = in EMP retrieve name
R2 = in EMP retrieve office where name =
APPT.name
R3 = in EMP retrieve office where name =
APPT.name or name = APPT.who.
R4 = in EMP retrieve supervisor where name =
APPT.name.
</equation>
<bodyText confidence="0.995640420000001">
In Node B, INFORM(APPT.who, APPT.name, &apos;meeting
with me on %APPT.date at %APPT.time&apos;) stands for
another verbgraph that represents sending a message
by inserting a tuple in MAILBOX. We can treat the
INFORM verbgraph as a procedure by specifying
values for all the slots that must be filled from
input. The input slots for INFORM are (name, from,
message).
III. WHAT CAN WE DO WITH IT?
One use for the verbgraphs is in support of NL
directed manipulation of the DB. In particular,
they can aid in variant selection. We assume that
the correct verb sense has already been selected; we
discuss sense selection later. Our goal is to use
information in the query and user responses to
questions to identify a path in the verbgraph. Let
us refer again to the verbgraph for SCHEDULE-
APPOINTMENT shown in Figure 4. Suppose the user
command is &amp;quot;Schedule an appointment with James
Parker on April 13&amp;quot; where James Parker is a company
employee. Interaction with the verbgraph proceeds
as follows. First, information is extracted from
the command and classified by domain. For example,
James Parker is in domain personname, which can
only be used to instantiate APPT.name, APPT.who,
APPT2.name and APPT2.who. However, since USER is
a system variable, the only slots left are APPT.who
and APPT2.name, which are necessarily the same.
Thus we can instantiate APPT.who and APPT2.name
with &amp;quot;James Parker.&amp;quot; We classify &amp;quot;April 13&amp;quot; as a
calendar date and instantiate APPT.date, APPT2.date
and RES.date with it, because all these must be the
same. Jo more useful information is in the query.
Second, we examine the graph to see if a unique
path has been determined. In this case it has
not. However, other possibilities are constrained
because we know the path must go through node B.
This is because the path must go through either
node B or node C and by analyzing the response to
retrieval R1, we can determine it must be node B
(i.e., James Parker is a company employee). Now
we must determine the rest of the path. One deter-
mination yet to be made is whether or not node D
is in the path. Because no room was mentioned in
the query, we generate from the graph a question
such as &amp;quot;Where will the appointment take place?&amp;quot;
Suppose the answer is &amp;quot;my office.&amp;quot; Presume we
can translate &apos;&apos;my office&amp;quot; into the scheduler&apos;s
office number. This response has two effects.
First, we know that no room has to be reserved, so
node D is not in the path. Second, we can fill in
APPT.where in node F. Finally, all that remains
to be decided is if node H is on the path. A
question like &amp;quot;Should we notify your supervisor?&amp;quot;
is generated. Supposing the answer is &amp;quot;no.&amp;quot; Now
the path is completely determined; it contains
nodes A, B and F. Now that we have determined a
unique path in the graph, we discover that not all
the information has been filled-in in every node
on the path. We now ask the questions to complete
these nodes, such as &apos;&apos;What time?&amp;quot;, &amp;quot;For how long?&amp;quot;
and &amp;quot;What is the topic?&amp;quot;. At this point we have a
complete unique path, so the appropriate calls to
INFORM can be made and the parameterized trans-
action in the footer can be filled-in.
Note that the above interaction was quite rig-
idly structured. In particular, after the user
issues the original command, the verbgraph instan-
tiation program chooses the order of the subsequent
data entry. There is no provision for default, or
optional values. Even if optional values were
allowed, the program would have to ask questions
for them anyway, since the user has no opportunity
to specify them subsequent to the original command.
We want the interaction to be more user-directed.
Our general principle is to allow the user to
volunteer additional information during the course
of the interaction, as long as the path has not
been determined and values remain unspecified. We
use the following interaction protocol. The user
enters the initial command and hits return. The
program will accept additional lines of input.
However, if the user just hits return, and the pro-
gram needs more information, the program will gener-
ate a question. The user answers the question,
followed by a return. As before, additional infor-
mation may be entered on subsequent lines. If the
user hits return on an empty line, another question
is generated, if necessary.
Brodie[Br81] and Skuce[Sk80] both present
systems for representing DB change. Skuce&apos;s
goal is to provide an English-like syntax for DB
procedure specification. Procedures have a rigid
format and require all information to be entered
at time of invocation in a specific order, as with
any computer subprogram. Brodie is attempting to
also specify DB procedures for DB change. He
allows some information to be specified later, but
the order is fixed. Neither allow the user to
choose the order of entry, and neither accomodates
</bodyText>
<page confidence="0.995333">
71
</page>
<bodyText confidence="0.999989885714285">
variants that would require different sets of
values to be specified. However, like our method,
and unlike Kaplan and Davidson[KD81], they attempt
to model DB changes that correspond to real world
actions rather than just specifying English syno-
nyms for single DB commands.
Certain constraints on updates are implicit
on verbgraphs, such as APPT.where + input from R3,
which constrains the location of the meeting to be
the office of one of the two employees. We also
use verbgraphs to maintain database consistency.
Integrity constraints take two forms: constraints
on a single state and constraints on successive
database states. The second kind is harder to en-
force; few systems support constraints on succes-
sive states.
Verbgraphs provide many opportunities for
specifying various defaults. First, we can specify
default values, which may depend on other values.
Second, we can specify default paths. Verbgraphs
are also a means for specifying non-DB operations.
For example, if an appointment is made with someone
outside the company, generate a confirmation letter
to be sent.
All of the above discussion has assumed we are
selecting a variant where the sense has already
been determined. In general sense selection, being
equivalent to the frame selection problem in
Artifical Intelligence[CW76], is very difficult.
We do feel that verbgraph will aid in sense selec-
tion, but will not be as efficacious as for variant
selection. In such a situation, perhaps the English
parser can help disambiguate or we may want to ask
an appropriate question to select the correct
sense, or as a last resort, provide menu selection,
</bodyText>
<sectionHeader confidence="0.650829" genericHeader="categories and subject descriptors">
IV. AN ALTERNATIVE TO VERBGRAPHS
</sectionHeader>
<bodyText confidence="0.993752772727273">
We are currently considering hierarchically
structured transactions, as used in the TAXIS
semantic model [MB80], as an alternative to verb-
graphs. Verbgraphs can be ambiguous, and do not
lend themselves to top-down design. Hierarchical
transactions would seem to overcome both problems.
Hierarchical transactions in TAXIS are not quite as
versatile as verbgraphs in representing variants.
The hierarchy is induced by hierarchies on the
entity classes involved. Variants based on the
relationship among particular entities, as recorded
in the database, cannot be represented. For
example, in the SCHEDULE-APPOINTMENT action, we may
want to require that if a supervisor schedules a
meeting with an employee not under his supervision,
a message must be sent to that employee&apos;s super-
visor. This variant cannot be distinguished by
classif:&apos;ng one entity as a supervisor and the
other as an employee because the variant does not
apply when the supervisor is scheduling a meeting
with his own employee. Also all variants in a TAXIS
transaction hierarchy must involve the same entity
classes, where we may want to involve some classes
only in certain variants. For example, a variant
of SCHEDULE-APPOINTMENT may require that a secretary
be present to take notes, introducing an entity
into that variant that is not present elsewhere.
We are currently trying to extend the TAXIS
model so it can represent such variants. Our ex-
tensions include introducing guards to distinguish
specializations and adding optional actions and
entities to transactions. A guard is a boolean
expression involving the entities and the database
that, when satisfied, indicates the associated
specialization applies. For example, the guard
scheduler in class (supervisor) and
scheduler 0 supervisor-of(schedulee)
would distinguish the variant described above
where an employee&apos;s supervisor must be notified
of any meeting with another supervisor. The dis-
crimination mechanism in TAXIS is a limited form
of guards that only allows testing for entities
in classes.
V. REFERENCES
</bodyText>
<reference confidence="0.999561363636364">
[Br78] Brodie, M.L., Specification and verifica-
tion of data base semantic integrity.
CSRG Report 91, Univ. of Toronto, April
1978.
[Br81] Brodie, M.L., On modelling behavioral
semantics of database. VLDB 7, Cannes
France, Sept. 1981.
[CH81] Carbonell, J. and Hayes, P., Multi-
strategy construction-specification pars-
ing for flexible database query and up-
date. CMU Internal Report, July 1981.
[CW76] Charniak, E. and Wilks, Y., Computation
Semantics. North Holland, 1976.
[Ch76] Chen, P.P.-S., The entity-relationship
model: toward a unified view of data.
ACM TODS 1:1, March 1976, pp. 9-36.
[Co79] Codd, E.F., Extending the database rela-
tional model to capture more meaning. ACM
TODS 4:4, December 1979, pp. 397-434.
Da78] Damereau, F.J., The derivation of answers
from logical forms in a question answering
system. American Journal of Computational
Linguistics. Microfiche 75, 1978,
pp. 3-42.
[HM81] Hammer, M. and McLeod, D., Database
description with SDM: A semantic database
model. ACM TODS 6:3, Sept. 1981,
pp. 351-386.
[Ha77] Harris, L.R., Using the database itself
as a semantic component to aid the parsing
of natural language database queries.
Dartmouth College Mathematics Dept.
TR 77-2, 1977.
</reference>
<page confidence="0.970902">
72
</page>
<reference confidence="0.997971305555556">
[Ka79] Kaplan, S.J., Cooperative responses from a
natural language data base query system.
Stanford Univ. Heuristic Programming
Project paper HPP-79-19.
[KD81] Kaplan, S.J., and Davidson, J., Inter-
preting Natural Language Updates. Proceed-
ings of the 19th Annual Meeting of the
Association for Computational Linguistics,
June 1981.
[MB80] Mylopoulos, J., Bernstein, P.A., and Wong,
H.K.T., A language facility for designing
database-intensive applications. ACM
TODS 5:2, June 1980, pp. 397-434.
[Sa78] Salveter, S.C., Inferring conceptual struc-
tures from pictorial input data. Univer-
sity of Wisconsin, Computer Science Dept.,
TR 328,1978.
[Sa79] Salveter, S.C., Inferring conceptual
graphs. Cognitive Science,3, pp. 141-166.
[Sk80] Skuce, D.R., Bridging the gap between
natural and computer language. Proc. of
Int&apos;l Congress on Applied Systems, and
Cybernetics, Acapulco, December 1980.
[Wa78] Walker, D.E., Understanding Spoken
Language. American Elsevier, 1978.
[Wi81] Wiederhold, G., Kaplan, S.J., and
Sagalowicz, D., Research in knowledge base
management systems. SIGMOD Record, VII,
#3, April 1981, pp. 26-54.
[Wo76] Woods, W., et. al., Speech Understanding
Systems: Final Technical Progress Report.
BBN No. 3438, Cambridge, MA, 1976.
[Wz75] Waltz, D., Natural language access to a
large database: an engineering approach.
In Proc. of the Fourth Int&apos;l Joint Conf.
on Artificial Intelligence, 1976.
</reference>
<page confidence="0.999283">
73
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.000803">
<title confidence="0.998427">NATURAL LANGUAGE DATABASE UPDATES</title>
<author confidence="0.998821">Sharon C Salveter David Maier</author>
<affiliation confidence="0.9913285">Computer Science Department SUNY Stony Brook</affiliation>
<address confidence="0.993024">Stony Brook, NY 11794</address>
<abstract confidence="0.979343554592723">Although a great deal of research effort has been expended in support of natural language (NL) database querying, little effort has gone to NL update.One reason for this state of affairs is that in NL querying, one can tie nouns and stative verbs in the query to database objects (relation names, attributes and domain values). In correspondence seems sufficient to interpret NL queries. ND update seems to require database counterparts for active verbs, such as &amp;quot;hire,&amp;quot; &amp;quot;schedule&amp;quot; and &amp;quot;enroll,&amp;quot; rather than for stative entities. There seem to be no natural candidates to fill this role. We suggest a database counterpart for active which we call verbgraphs.The verbgraphs may be used to support NL update. A verbgraph is a structure for representing the various database changes that a given verb might describe. In addition to describing the variants of a verb, they may be used to disambiguate the update command. Other possible uses of verbgraphs include, specification of defaults, prompting of the user to guide but not dictate user interaction and enforcing a variety of types of database integrity constraints. I. MOTIVIATION AND PROBLEM STATEMENT We want to support natural language interface for all aspects of database manipulation. English English-like querysystems already exist, such as ROBOT[Ha77], TQA[Da78], LUNAR[W076] and those described by Kaplan[Ka79], Walker[Wa78] and Waltz [Wz75]. We propose to extend natural language to include data modification(insert, delete, modify) rather than simply data extraction. The desirability and unavailability of natural language database modification has been noted by Wiederhold, et al.[Wi81]. Database systems currently do not contain structures for explicit modelling of real world changes. A state of a database (DB) is meant to represent a state of a portion of the real world. research supported by NSF grants IST-79-18264 and ENG-79-07794. lie refer to the abstract description of the portion the real world being modelled as the description(SDD). A SDD indicates a set of real world states (RWS) of interest, a DB definition gives a set of allowable database states (DES). The correspondence between the SDD and the DB definition induces connections between DB states and real world states. The situation is diagrammed in Figure 1. Real World Database semantic database description correspondence definition Figure 1 Natural language (NL) querying of the DB requires that the correspondence between the SDD and the DB definition be explicitly stated. The query system must translate a question phrased in terms of the SDD into a question phrased in terms of a data retrieval command in the language of the DB system. The response to the command must be translated back into terms of the SDD, which yields information about the real world state. For NL modification, this correspondence between DB states and real world states is not adequate. We want changes in the real world to be reflected in the DB. In Figure 2 we see that when some action in the real world causes a state change from RWS1 to RWS2, we must perform some modification to the DB to change its state from DBS1 to DBS2. World 1 DHL RWS2 &lt; &apos;&gt;DBS2 Figure 2 DBS1 DBS2 DBS3 67 We have a means to describe the action that changed the state of the real world: active verbs. We also have a means to describe a change in the state: data manipulation language (DML) mand sequences. But given a real world-action, how do we find a DML command sequence that will accomplish the corresponding change in the DB? Before we explore ways to represent his connection between real world actions and DB updates--, let us examine how the stative correspondence is captured for use by a NL query system. We need to connect entities and relationships in the SDD with files, fields and field values in the DB. This stative correspondence between RWS and DBS is generally specified in a system file. For example, in Harris&apos; ROBOT system, the semantic description is implicit, and it is assumed to be given in English. The entities and relationships in the description are roughly English nouns and stative verbs. The correspondence of the SDD to the DB is given by a lexicon that associates English words with files, fields and field values in the DB. This lexicon also gives possible referents for word and phrases such as &amp;quot;who,&amp;quot; &amp;quot;where&amp;quot; and &amp;quot;how much.&amp;quot; Consider the following example. Suppose we have an office DB of employees and their scheduled meetings, reservations for meeting rooms and messages from one employee to another. We capture this information in the following four relations, EMP(name,office,phone,supervisor) APPOINTMENT(name,date,time,duration,who, topic ,location) MAILBOX(name,date,time,from,message) ROOMRESERVE(room,date,time,duration,reserver) with domains (permissible sets of values): DOMAIN ATTRIBUTES eliminate the first possibility. Thus we can arrive at the query EMP, ROOMRESERVE retrievename, phone name = reserver and room = 85 and time = 2:45pm and date = CURRENTDATE Suppose we now want to make a change to the database: &amp;quot;Schedule Bob Marley for 2:15pm Friday.&amp;quot; This request could mean schedule a meeting with an individual or schedule Bob Marley for a seminar. We want to connect &amp;quot;schedule&amp;quot; with the insertion of a tuple in either APPOINTMENT or ROOMRESERVE. Although we may have pointers from &amp;quot;schedule&amp;quot; to APPOINTMENT and ROOMRESERVE, we do not have adequate information for choosing the relation to update. Although files, fields, domains and values seem to be adequate for expressing the stative correspondence, we have no similar DB objects to which we may tie verbs that describe actions in the real world. The best we can do with files, fields and domains is to indicate what is to be modified; we cannot specify how to make the modification. We need to connect the verbs &amp;quot;schedule,&amp;quot; &amp;quot;hire&amp;quot; and &amp;quot;reserve&amp;quot; with some structures that dictate appropriate DML sequences that perform the corresponding updates to the DB. The best we have is a specific DM1 command sequence, a transaction, for each instance of &amp;quot;schedule&amp;quot; in the real world. No single transaction truly represents all the implications and variants of the &amp;quot;schedule&amp;quot; action. &amp;quot;Schedule&amp;quot; really corresponds to a set of similar transactions, or perhaps some parameterized version of a DB transaction. induced connections 1. RWS2 RWS1 S2\ RWS3 DBS2 DBS1 DBS3 personname roomnum plionenum calendardate clocktime elapsedtime text name, who, from, reserver, supervisor room, location, office phone date time duration message, topic Consider an analysis of the query &amp;quot;What is the name and phone # of the person who reserved room 85 for 2:45pm today?&amp;quot; Using the lexicon, we can tie words in the query to domains and relations. name personname reserve - ROOMRESERVE relation phone phonenum room roomnum person personname 2:45pm clocktime who personname calendardate We need to connect relations MP and ROOMRESERVE. The possible joins are room-office and namereserver. If we have stored the information that offices and reservable rooms never intersect, we can &amp;quot;Schedule&amp;quot;4Parameterized Transaction (PT) Figure 3 The desired situation is shown in Figure 3. 1 an active correspondence between &amp;quot;schedule&amp;quot; anu a parameterized DB transaction PT. Different instances of the schedule action, Si and S2, cause different changes in the real world state. From correspondence of &amp;quot;schedule&amp;quot; and PT, we want to produce the proper transaction, Ti or T2, to effect the correct change in the DB state. There is not an existing candidate for the highlevel specification language for verb descriptions. 68 We must be able to readily express the correspondence between actions in the semantic world and verb descriptions in this high-level specification We depend heavily on this correspondence to process natural language updates, just as the stative correspondence is used to process natural language queries. In the next section we examine these requirements in more detail and offer, by example, one candidate for the representation. Another indication of the problem of active verbs in DB shows up in looking a semantic data languages. Sematnic data models are systems for constructing precise descriptions of protions of the real world semantic data description (SDD)using terms that come from the real world rather than a particular DB system. A SDD is a starting point for designing and comparing particular DB implementations. Some of the semantic models that have been proposed are the entity-relationship model[Ch76], SDMEHM81], RM/T[Co79], TAXIS[MB80] and Beta[Br78]. For some of these models, methodologies exist for translating to a DB specification in various DB models, as well as for expressing the static correspondence between a SDD in the semantic model and a particular DB implementation. To express actions in these models, however, there only terms that refer to delete, modify, rather than schedule, cancel, postpone (the notable exception is Skuce[Sk80]). While there have been a number of approaches made to NL querying, there seems to be little work on NI update. Carbonell and Hayes[CH81] have looked at parsing a limited set of NL update commands, but they do not say much about generating the DB transactions for these commands. Kaplan and Davidson[KD81] have looked at the translation of NL updates to transactions, but the active verbs they deal with are synonyms for DB terms, essentially following the semantic data model as above. This limitation is intentional, as the following excerpt shows: First, it is assume that the underlying database update must be a series of transactions of the same type indicated in the request. That is, if the update requests a deletion, this can only be mapped into a series of deletions in the database. While some active verbs, such as &amp;quot;schedule,&amp;quot; may correspond to a single type of DB update, there are other verbs that will require multiple types of DB updates, such as &amp;quot;cancel,&amp;quot; which might require sending message as well as removing an appointment. &apos;Kaplan and Davidson are also trying to be domain independent, while we are trying to exploit domain-specific information. II. NATURE OF THE REPRESENTATION propose a structure, a verbgraph,to represent action verbs. Verbgraph are extensions of frame-like structures used to represent verb meaning in MORAN[Sa78] and [Sa79]. One verbgraph is associated with each sense of a verb; that structure represents all variants. A real world change is described by a sentence that contains an active verb; the DB changes are accomplished by DML command sequences. A verbgraph is used to select DML sequences appropriate to process the variants of verb sense. We also wish to capture that one verb that may be used as part of another: we may have a verb sense RESERVE-ROOM that may be used by itself or may be used as a subpart of the verb SCHEDULE-TALK. Figure 4 is an example of verbgraph. It models the &amp;quot;schedule appointment&amp;quot; sense of the verb &amp;quot;schedule.&amp;quot; There are four basic variants we are attempting to capture; they are distinguished by whether or not the appointment is scheduled with someone in the company and whether or not a meeting room is to be reserved. There is also the possibility that the supervisor must be notified of the meeting. The verbgraph is directed acyclic graph (DAG) with 5 kinds of nodes: header, footer, information, AND (0) and OR (D). Header is the source of the graph, the footer is the sink. Every information node has one incoming and outgoing edge. An AND or OR node can have any number of incoming or outgoing edges. A variant corresponds to a directed path in the graph. We define a path to be connected subgraph such that 1) the header is included; 2) the footer is included; 3) if it contains an information node, it contains the incoming and outgoing edge; 4) if it contains an AND node, it contains all incoming and outgoing edges; and 5) if it contains an OR node, it contains exactly one incoming and one outgoing edge. We can think of tracing a path in the graph by starting at the header and following its outgoing edge. Whenever we encounter an information node, we go through it. Whenever we encounter an AND node, the path divides and follows all outgoing edges. We may only pass through an AND node if all its incoming edges have been followed. An OR node can be entered on only one edge and we leave it by any of its outgoing edges. An example of a complete path is one that consists of theheader, footer, information nodes, A, B, D, J, and connector nodes, a, b, c, d, g, k, 1, n. Although there is a direction to paths, we do not intend that the order of nodes on a path implies any order of prncessing the graph, except the footer node is always last to be processed. A variant of a verb sense is described by the set of all expressions in the information nodes contained in a path. Expressions in the information nodes can be of two basic types: assignment and restriction. The assignment type produces a value to be used in the update, either by input or computation; the word inputindicates the value comes from the user. Some examples of assignment are: 69 SORIMULE-APPOINTMENT Figure 4 APPOINTMENT APT insert RES R1 - APPT.who - APPT. time â€” APPr. date APIT. topic AFP. T. where APPT2.name APPT2.who â€” APPT2.time APPT2.date APPT2.topie APPT2.where R3 APPT.where not in R2 APF,where inout from _L16 4./ APPT.who not in AY&amp; APPT.where â€”R2 APPT. where not In R3 RES.room APPT.where RES.date â€” APPT.date R2S.reserver APPT.name RES.tims â€” APPT.time RES.duration APPT.duration APPT.where invut from roomnum call INFORM(APPT.who, APPT.name, &apos;Meeting with me on OPPT.date at UPPT.time&apos;) call OF0RM(R4, APPT.name, &apos;Meeting with 12APPT.wno on IgAPPT.date in room UPPT.where&apos;) a APPT.name â€” USER APPT.time invut from eloektime APPT.duration inout from elapsedtime APPT. date inout from ealendardate APPT.who input from personname APPT.topic inout from text 70 1) (node labelled A in Figure 4) -4inputfrom personname The user must provide a value from the domain personname. 2) (node labelled D in Figure 4) RES.date 4- APPT.date The value for APPT.date is used as the value RES.date. An example of restriction is: (node B in Figure 4) in R1 where R1 = in EMP retrievename This statement restricts the value of APPT.who to be a company employee. Also in Figure 4, the symbols RI, R2, R3 and R4 stand for the retrievals = in EMP retrievename = in EMP retrieveoffice wherename = APPT.name = in EMP retrieveoffice wherename = APPT.name or name = APPT.who. = in EMP retrievesupervisor wherename = APPT.name. In Node B, INFORM(APPT.who, APPT.name, &apos;meeting with me on %APPT.date at %APPT.time&apos;) stands for another verbgraph that represents sending a message by inserting a tuple in MAILBOX. We can treat the INFORM verbgraph as a procedure by specifying values for all the slots that must be filled from input. The input slots for INFORM are (name, from, message). III. WHAT CAN WE DO WITH IT? One use for the verbgraphs is in support of NL directed manipulation of the DB. In particular, they can aid in variant selection. We assume that the correct verb sense has already been selected; we discuss sense selection later. Our goal is to use information in the query and user responses to questions to identify a path in the verbgraph. Let us refer again to the verbgraph for SCHEDULE- APPOINTMENT shown in Figure 4. Suppose the user command is &amp;quot;Schedule an appointment with James Parker on April 13&amp;quot; where James Parker is a company employee. Interaction with the verbgraph proceeds as follows. First, information is extracted from the command and classified by domain. For example, James Parker is in domain personname, which can only be used to instantiate APPT.name, APPT.who, APPT2.name and APPT2.who. However, since USER is a system variable, the only slots left are APPT.who and APPT2.name, which are necessarily the same. Thus we can instantiate APPT.who and APPT2.name with &amp;quot;James Parker.&amp;quot; We classify &amp;quot;April 13&amp;quot; as a calendar date and instantiate APPT.date, APPT2.date and RES.date with it, because all these must be the same. Jo more useful information is in the query. Second, we examine the graph to see if a unique path has been determined. In this case it has not. However, other possibilities are constrained because we know the path must go through node B. This is because the path must go through either node B or node C and by analyzing the response to retrieval R1, we can determine it must be node B (i.e., James Parker is a company employee). Now we must determine the rest of the path. One determination yet to be made is whether or not node D is in the path. Because no room was mentioned in the query, we generate from the graph a question such as &amp;quot;Where will the appointment take place?&amp;quot; Suppose the answer is &amp;quot;my office.&amp;quot; Presume we can translate &apos;&apos;my office&amp;quot; into the scheduler&apos;s office number. This response has two effects. First, we know that no room has to be reserved, so node D is not in the path. Second, we can fill in APPT.where in node F. Finally, all that remains to be decided is if node H is on the path. A question like &amp;quot;Should we notify your supervisor?&amp;quot; is generated. Supposing the answer is &amp;quot;no.&amp;quot; Now the path is completely determined; it contains nodes A, B and F. Now that we have determined a unique path in the graph, we discover that not all the information has been filled-in in every node on the path. We now ask the questions to complete these nodes, such as &apos;&apos;What time?&amp;quot;, &amp;quot;For how long?&amp;quot; and &amp;quot;What is the topic?&amp;quot;. At this point we have a complete unique path, so the appropriate calls to INFORM can be made and the parameterized transaction in the footer can be filled-in. Note that the above interaction was quite rigidly structured. In particular, after the user issues the original command, the verbgraph instantiation program chooses the order of the subsequent data entry. There is no provision for default, or optional values. Even if optional values were allowed, the program would have to ask questions for them anyway, since the user has no opportunity to specify them subsequent to the original command. We want the interaction to be more user-directed. Our general principle is to allow the user to volunteer additional information during the course of the interaction, as long as the path has not been determined and values remain unspecified. We use the following interaction protocol. The user enters the initial command and hits return. The program will accept additional lines of input. However, if the user just hits return, and the program needs more information, the program will generate a question. The user answers the question, followed by a return. As before, additional information may be entered on subsequent lines. If the user hits return on an empty line, another question is generated, if necessary. Brodie[Br81] and Skuce[Sk80] both present systems for representing DB change. Skuce&apos;s goal is to provide an English-like syntax for DB procedure specification. Procedures have a rigid format and require all information to be entered at time of invocation in a specific order, as with any computer subprogram. Brodie is attempting to also specify DB procedures for DB change. He allows some information to be specified later, but the order is fixed. Neither allow the user to choose the order of entry, and neither accomodates 71 variants that would require different sets of values to be specified. However, like our method, and unlike Kaplan and Davidson[KD81], they attempt to model DB changes that correspond to real world actions rather than just specifying English synonyms for single DB commands. Certain constraints on updates are implicit verbgraphs, such as APPT.where + inputfrom R3, which constrains the location of the meeting to be the office of one of the two employees. We also use verbgraphs to maintain database consistency. Integrity constraints take two forms: constraints on a single state and constraints on successive database states. The second kind is harder to ensystems constraints on successive states. Verbgraphs provide many opportunities for specifying various defaults. First, we can specify default values, which may depend on other values. Second, we can specify default paths. Verbgraphs are also a means for specifying non-DB operations. For example, if an appointment is made with someone outside the company, generate a confirmation letter to be sent. All of the above discussion has assumed we are selecting a variant where the sense has already been determined. In general sense selection, being equivalent to the frame selection problem in Artifical Intelligence[CW76], is very difficult. We do feel that verbgraph will aid in sense selection, but will not be as efficacious as for variant selection. In such a situation, perhaps the English parser can help disambiguate or we may want to ask an appropriate question to select the correct sense, or as a last resort, provide menu selection, IV. AN ALTERNATIVE TO VERBGRAPHS We are currently considering hierarchically structured transactions, as used in the TAXIS semantic model [MB80], as an alternative to verbgraphs. Verbgraphs can be ambiguous, and do not lend themselves to top-down design. Hierarchical transactions would seem to overcome both problems. Hierarchical transactions in TAXIS are not quite as versatile as verbgraphs in representing variants. The hierarchy is induced by hierarchies on the entity classes involved. Variants based on the relationship among particular entities, as recorded in the database, cannot be represented. For example, in the SCHEDULE-APPOINTMENT action, we may want to require that if a supervisor schedules a meeting with an employee not under his supervision, a message must be sent to that employee&apos;s supervisor. This variant cannot be distinguished by classif:&apos;ng one entity as a supervisor and the other as an employee because the variant does not apply when the supervisor is scheduling a meeting with his own employee. Also all variants in a TAXIS transaction hierarchy must involve the same entity classes, where we may want to involve some classes only in certain variants. For example, a variant of SCHEDULE-APPOINTMENT may require that a secretary be present to take notes, introducing an entity into that variant that is not present elsewhere. We are currently trying to extend the TAXIS model so it can represent such variants. Our extensions include introducing guards to distinguish specializations and adding optional actions and entities to transactions. A guard is a boolean expression involving the entities and the database that, when satisfied, indicates the associated specialization applies. For example, the guard scheduler in class (supervisor) and scheduler 0 supervisor-of(schedulee) would distinguish the variant described above where an employee&apos;s supervisor must be notified of any meeting with another supervisor. The discrimination mechanism in TAXIS is a limited form of guards that only allows testing for entities in classes. V. REFERENCES [Br78] Brodie, M.L., Specification and verification of data base semantic integrity.</abstract>
<note confidence="0.973778434782609">CSRG Report 91, Univ. of Toronto, April 1978. [Br81] Brodie, M.L., On modelling behavioral semantics of database. VLDB 7, Cannes France, Sept. 1981. [CH81] Carbonell, J. and Hayes, P., Multistrategy construction-specification parsing for flexible database query and update. CMU Internal Report, July 1981. Charniak, E. and Wilks, Y., Semantics.North Holland, 1976. [Ch76] Chen, P.P.-S., The entity-relationship model: toward a unified view of data. ACM TODS 1:1, March 1976, pp. 9-36. [Co79] Codd, E.F., Extending the database relational model to capture more meaning. ACM TODS 4:4, December 1979, pp. 397-434. Da78] Damereau, F.J., The derivation of answers from logical forms in a question answering Journal of Computational Linguistics.Microfiche 75, 1978, pp. 3-42. [HM81] Hammer, M. and McLeod, D., Database</note>
<abstract confidence="0.762770833333333">description with SDM: A semantic database model. ACM TODS 6:3, Sept. 1981, pp. 351-386. [Ha77] Harris, L.R., Using the database itself as a semantic component to aid the parsing of natural language database queries.</abstract>
<note confidence="0.880404769230769">Dartmouth College Mathematics Dept. TR 77-2, 1977. 72 [Ka79] Kaplan, S.J., Cooperative responses from a natural language data base query system. Stanford Univ. Heuristic Programming Project paper HPP-79-19. [KD81] Kaplan, S.J., and Davidson, J., Inter- Natural Language Updates. Proceedings of the 19th Annual Meeting of the Association for Computational Linguistics, June 1981. [MB80] Mylopoulos, J., Bernstein, P.A., and Wong, H.K.T., A language facility for designing database-intensive applications. ACM TODS 5:2, June 1980, pp. 397-434. [Sa78] Salveter, S.C., Inferring conceptual structures from pictorial input data. University of Wisconsin, Computer Science Dept., TR 328,1978. [Sa79] Salveter, S.C., Inferring conceptual Science,3,pp. 141-166. [Sk80] Skuce, D.R., Bridging the gap between and computer language. of Int&apos;l Congress on Applied Systems, and Cybernetics,Acapulco, December 1980. Walker, D.E., Spoken Language.American Elsevier, 1978. [Wi81] Wiederhold, G., Kaplan, S.J., and Sagalowicz, D., Research in knowledge base systems. Record,VII, Woods, W., et. al., Understanding Systems: Final Technical Progress Report. BBN No. 3438, Cambridge, MA, 1976. [Wz75] Waltz, D., Natural language access to a large database: an engineering approach. of the Fourth Int&apos;l Joint Conf. Artificial Intelligence,1976. 73</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>M L Brodie</author>
</authors>
<title>Specification and verification of data base semantic integrity.</title>
<date>1978</date>
<tech>CSRG Report 91,</tech>
<institution>Univ. of Toronto,</institution>
<contexts>
<context position="8922" citStr="[Br78]" startWordPosition="1437" endWordPosition="1437"> and offer, by example, one candidate for the representation. Another indication of the problem of active verbs in DB shows up in looking a semantic data languages. Sematnic data models are systems for constructing precise descriptions of protions of the real world - semantic data description (SDD)- using terms that come from the real world rather than a particular DB system. A SDD is a starting point for designing and comparing particular DB implementations. Some of the semantic models that have been proposed are the entity-relationship model[Ch76], SDMEHM81], RM/T[Co79], TAXIS[MB80] and Beta[Br78]. For some of these models, methodologies exist for translating to a DB specification in various DB models, as well as for expressing the static correspondence between a SDD in the semantic model and a particular DB implementation. To express actions in these models, however, there are only terms that refer to DBs: insert, delete, modify, rather than schedule, cancel, postpone (the notable exception is Skuce[Sk80]). While there have been a number of approaches made to NL querying, there seems to be little work on NI update. Carbonell and Hayes[CH81] have looked at parsing a limited set of NL u</context>
</contexts>
<marker>[Br78]</marker>
<rawString>Brodie, M.L., Specification and verification of data base semantic integrity. CSRG Report 91, Univ. of Toronto, April 1978.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M L Brodie</author>
</authors>
<title>On modelling behavioral semantics of database.</title>
<date>1981</date>
<journal>VLDB</journal>
<volume>7</volume>
<location>Cannes France,</location>
<contexts>
<context position="19319" citStr="[Br81]" startWordPosition="3235" endWordPosition="3235">mation during the course of the interaction, as long as the path has not been determined and values remain unspecified. We use the following interaction protocol. The user enters the initial command and hits return. The program will accept additional lines of input. However, if the user just hits return, and the program needs more information, the program will generate a question. The user answers the question, followed by a return. As before, additional information may be entered on subsequent lines. If the user hits return on an empty line, another question is generated, if necessary. Brodie[Br81] and Skuce[Sk80] both present systems for representing DB change. Skuce&apos;s goal is to provide an English-like syntax for DB procedure specification. Procedures have a rigid format and require all information to be entered at time of invocation in a specific order, as with any computer subprogram. Brodie is attempting to also specify DB procedures for DB change. He allows some information to be specified later, but the order is fixed. Neither allow the user to choose the order of entry, and neither accomodates 71 variants that would require different sets of values to be specified. However, like</context>
</contexts>
<marker>[Br81]</marker>
<rawString>Brodie, M.L., On modelling behavioral semantics of database. VLDB 7, Cannes France, Sept. 1981.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Carbonell</author>
<author>P Hayes</author>
</authors>
<title>Multistrategy construction-specification parsing for flexible database query and update.</title>
<date>1981</date>
<tech>CMU Internal Report,</tech>
<contexts>
<context position="9477" citStr="[CH81]" startWordPosition="1527" endWordPosition="1527">, SDMEHM81], RM/T[Co79], TAXIS[MB80] and Beta[Br78]. For some of these models, methodologies exist for translating to a DB specification in various DB models, as well as for expressing the static correspondence between a SDD in the semantic model and a particular DB implementation. To express actions in these models, however, there are only terms that refer to DBs: insert, delete, modify, rather than schedule, cancel, postpone (the notable exception is Skuce[Sk80]). While there have been a number of approaches made to NL querying, there seems to be little work on NI update. Carbonell and Hayes[CH81] have looked at parsing a limited set of NL update commands, but they do not say much about generating the DB transactions for these commands. Kaplan and Davidson[KD81] have looked at the translation of NL updates to transactions, but the active verbs they deal with are synonyms for DB terms, essentially following the semantic data model as above. This limitation is intentional, as the following excerpt shows: First, it is assume that the underlying database update must be a series of transactions of the same type indicated in the request. That is, if the update requests a deletion, this can o</context>
</contexts>
<marker>[CH81]</marker>
<rawString>Carbonell, J. and Hayes, P., Multistrategy construction-specification parsing for flexible database query and update. CMU Internal Report, July 1981.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Charniak</author>
<author>Y Wilks</author>
</authors>
<title>Computation Semantics.</title>
<date>1976</date>
<publisher>North</publisher>
<location>Holland,</location>
<contexts>
<context position="21138" citStr="[CW76]" startWordPosition="3521" endWordPosition="3521">aints on successive states. Verbgraphs provide many opportunities for specifying various defaults. First, we can specify default values, which may depend on other values. Second, we can specify default paths. Verbgraphs are also a means for specifying non-DB operations. For example, if an appointment is made with someone outside the company, generate a confirmation letter to be sent. All of the above discussion has assumed we are selecting a variant where the sense has already been determined. In general sense selection, being equivalent to the frame selection problem in Artifical Intelligence[CW76], is very difficult. We do feel that verbgraph will aid in sense selection, but will not be as efficacious as for variant selection. In such a situation, perhaps the English parser can help disambiguate or we may want to ask an appropriate question to select the correct sense, or as a last resort, provide menu selection, IV. AN ALTERNATIVE TO VERBGRAPHS We are currently considering hierarchically structured transactions, as used in the TAXIS semantic model [MB80], as an alternative to verbgraphs. Verbgraphs can be ambiguous, and do not lend themselves to top-down design. Hierarchical transacti</context>
</contexts>
<marker>[CW76]</marker>
<rawString>Charniak, E. and Wilks, Y., Computation Semantics. North Holland, 1976.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P P-S Chen</author>
</authors>
<title>The entity-relationship model: toward a unified view of data.</title>
<date>1976</date>
<journal>ACM TODS</journal>
<volume>1</volume>
<pages>9--36</pages>
<contexts>
<context position="8871" citStr="[Ch76]" startWordPosition="1432" endWordPosition="1432">ection we examine these requirements in more detail and offer, by example, one candidate for the representation. Another indication of the problem of active verbs in DB shows up in looking a semantic data languages. Sematnic data models are systems for constructing precise descriptions of protions of the real world - semantic data description (SDD)- using terms that come from the real world rather than a particular DB system. A SDD is a starting point for designing and comparing particular DB implementations. Some of the semantic models that have been proposed are the entity-relationship model[Ch76], SDMEHM81], RM/T[Co79], TAXIS[MB80] and Beta[Br78]. For some of these models, methodologies exist for translating to a DB specification in various DB models, as well as for expressing the static correspondence between a SDD in the semantic model and a particular DB implementation. To express actions in these models, however, there are only terms that refer to DBs: insert, delete, modify, rather than schedule, cancel, postpone (the notable exception is Skuce[Sk80]). While there have been a number of approaches made to NL querying, there seems to be little work on NI update. Carbonell and Hayes</context>
</contexts>
<marker>[Ch76]</marker>
<rawString>Chen, P.P.-S., The entity-relationship model: toward a unified view of data. ACM TODS 1:1, March 1976, pp. 9-36.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E F Codd</author>
</authors>
<title>Extending the database relational model to capture more meaning.</title>
<date>1979</date>
<journal>ACM TODS</journal>
<volume>4</volume>
<pages>397--434</pages>
<contexts>
<context position="8894" citStr="[Co79]" startWordPosition="1434" endWordPosition="1434"> requirements in more detail and offer, by example, one candidate for the representation. Another indication of the problem of active verbs in DB shows up in looking a semantic data languages. Sematnic data models are systems for constructing precise descriptions of protions of the real world - semantic data description (SDD)- using terms that come from the real world rather than a particular DB system. A SDD is a starting point for designing and comparing particular DB implementations. Some of the semantic models that have been proposed are the entity-relationship model[Ch76], SDMEHM81], RM/T[Co79], TAXIS[MB80] and Beta[Br78]. For some of these models, methodologies exist for translating to a DB specification in various DB models, as well as for expressing the static correspondence between a SDD in the semantic model and a particular DB implementation. To express actions in these models, however, there are only terms that refer to DBs: insert, delete, modify, rather than schedule, cancel, postpone (the notable exception is Skuce[Sk80]). While there have been a number of approaches made to NL querying, there seems to be little work on NI update. Carbonell and Hayes[CH81] have looked at p</context>
</contexts>
<marker>[Co79]</marker>
<rawString>Codd, E.F., Extending the database relational model to capture more meaning. ACM TODS 4:4, December 1979, pp. 397-434. Da78] Damereau, F.J., The derivation of answers from logical forms in a question answering system. American Journal of Computational Linguistics. Microfiche 75, 1978, pp. 3-42.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Hammer</author>
<author>D McLeod</author>
</authors>
<title>Database description with SDM: A semantic database model.</title>
<date>1981</date>
<journal>ACM TODS 6:3,</journal>
<pages>351--386</pages>
<marker>[HM81]</marker>
<rawString>Hammer, M. and McLeod, D., Database description with SDM: A semantic database model. ACM TODS 6:3, Sept. 1981, pp. 351-386.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L R Harris</author>
</authors>
<title>Using the database itself as a semantic component to aid the parsing of natural language database queries. Dartmouth College Mathematics Dept.</title>
<date>1977</date>
<tech>TR 77-2,</tech>
<contexts>
<context position="1492" citStr="[Ha77]" startWordPosition="235" endWordPosition="235">rbgraph is a structure for representing the various database changes that a given verb might describe. In addition to describing the variants of a verb, they may be used to disambiguate the update command. Other possible uses of verbgraphs include, specification of defaults, prompting of the user to guide but not dictate user interaction and enforcing a variety of types of database integrity constraints. I. MOTIVIATION AND PROBLEM STATEMENT We want to support natural language interface for all aspects of database manipulation. English and English-like query systems already exist, such as ROBOT[Ha77], TQA[Da78], LUNAR[W076] and those described by Kaplan[Ka79], Walker[Wa78] and Waltz [Wz75]. We propose to extend natural language interaction to include data modification (insert, delete, modify) rather than simply data extraction. The desirability and unavailability of natural language database modification has been noted by Wiederhold, et al.[Wi81]. Database systems currently do not contain structures for explicit modelling of real world changes. A state of a database (DB) is meant to represent a state of a portion of the real world. This research is partially supported by NSF grants IST-79</context>
</contexts>
<marker>[Ha77]</marker>
<rawString>Harris, L.R., Using the database itself as a semantic component to aid the parsing of natural language database queries. Dartmouth College Mathematics Dept. TR 77-2, 1977.</rawString>
</citation>
<citation valid="false">
<authors>
<author>S J Kaplan</author>
</authors>
<title>Cooperative responses from a natural language data base query system. Stanford Univ. Heuristic Programming Project paper</title>
<pages>79--19</pages>
<contexts>
<context position="1552" citStr="[Ka79]" startWordPosition="242" endWordPosition="242"> changes that a given verb might describe. In addition to describing the variants of a verb, they may be used to disambiguate the update command. Other possible uses of verbgraphs include, specification of defaults, prompting of the user to guide but not dictate user interaction and enforcing a variety of types of database integrity constraints. I. MOTIVIATION AND PROBLEM STATEMENT We want to support natural language interface for all aspects of database manipulation. English and English-like query systems already exist, such as ROBOT[Ha77], TQA[Da78], LUNAR[W076] and those described by Kaplan[Ka79], Walker[Wa78] and Waltz [Wz75]. We propose to extend natural language interaction to include data modification (insert, delete, modify) rather than simply data extraction. The desirability and unavailability of natural language database modification has been noted by Wiederhold, et al.[Wi81]. Database systems currently do not contain structures for explicit modelling of real world changes. A state of a database (DB) is meant to represent a state of a portion of the real world. This research is partially supported by NSF grants IST-79-18264 and ENG-79-07794. lie refer to the abstract descripti</context>
</contexts>
<marker>[Ka79]</marker>
<rawString>Kaplan, S.J., Cooperative responses from a natural language data base query system. Stanford Univ. Heuristic Programming Project paper HPP-79-19.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S J Kaplan</author>
<author>J Davidson</author>
</authors>
<title>Interpreting Natural Language Updates.</title>
<date>1981</date>
<booktitle>Proceedings of the 19th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<contexts>
<context position="9645" citStr="[KD81]" startWordPosition="1556" endWordPosition="1556">s for expressing the static correspondence between a SDD in the semantic model and a particular DB implementation. To express actions in these models, however, there are only terms that refer to DBs: insert, delete, modify, rather than schedule, cancel, postpone (the notable exception is Skuce[Sk80]). While there have been a number of approaches made to NL querying, there seems to be little work on NI update. Carbonell and Hayes[CH81] have looked at parsing a limited set of NL update commands, but they do not say much about generating the DB transactions for these commands. Kaplan and Davidson[KD81] have looked at the translation of NL updates to transactions, but the active verbs they deal with are synonyms for DB terms, essentially following the semantic data model as above. This limitation is intentional, as the following excerpt shows: First, it is assume that the underlying database update must be a series of transactions of the same type indicated in the request. That is, if the update requests a deletion, this can only be mapped into a series of deletions in the database. While some active verbs, such as &amp;quot;schedule,&amp;quot; may correspond to a single type of DB update, there are other ver</context>
<context position="19968" citStr="[KD81]" startWordPosition="3339" endWordPosition="3339">epresenting DB change. Skuce&apos;s goal is to provide an English-like syntax for DB procedure specification. Procedures have a rigid format and require all information to be entered at time of invocation in a specific order, as with any computer subprogram. Brodie is attempting to also specify DB procedures for DB change. He allows some information to be specified later, but the order is fixed. Neither allow the user to choose the order of entry, and neither accomodates 71 variants that would require different sets of values to be specified. However, like our method, and unlike Kaplan and Davidson[KD81], they attempt to model DB changes that correspond to real world actions rather than just specifying English synonyms for single DB commands. Certain constraints on updates are implicit on verbgraphs, such as APPT.where + input from R3, which constrains the location of the meeting to be the office of one of the two employees. We also use verbgraphs to maintain database consistency. Integrity constraints take two forms: constraints on a single state and constraints on successive database states. The second kind is harder to enforce; few systems support constraints on successive states. Verbgrap</context>
</contexts>
<marker>[KD81]</marker>
<rawString>Kaplan, S.J., and Davidson, J., Interpreting Natural Language Updates. Proceedings of the 19th Annual Meeting of the Association for Computational Linguistics, June 1981.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Mylopoulos</author>
<author>P A Bernstein</author>
<author>H K T Wong</author>
</authors>
<title>A language facility for designing database-intensive applications.</title>
<date>1980</date>
<journal>ACM TODS 5:2,</journal>
<pages>397--434</pages>
<contexts>
<context position="8907" citStr="[MB80]" startWordPosition="1435" endWordPosition="1435"> in more detail and offer, by example, one candidate for the representation. Another indication of the problem of active verbs in DB shows up in looking a semantic data languages. Sematnic data models are systems for constructing precise descriptions of protions of the real world - semantic data description (SDD)- using terms that come from the real world rather than a particular DB system. A SDD is a starting point for designing and comparing particular DB implementations. Some of the semantic models that have been proposed are the entity-relationship model[Ch76], SDMEHM81], RM/T[Co79], TAXIS[MB80] and Beta[Br78]. For some of these models, methodologies exist for translating to a DB specification in various DB models, as well as for expressing the static correspondence between a SDD in the semantic model and a particular DB implementation. To express actions in these models, however, there are only terms that refer to DBs: insert, delete, modify, rather than schedule, cancel, postpone (the notable exception is Skuce[Sk80]). While there have been a number of approaches made to NL querying, there seems to be little work on NI update. Carbonell and Hayes[CH81] have looked at parsing a limi</context>
<context position="21605" citStr="[MB80]" startWordPosition="3598" endWordPosition="3598">se has already been determined. In general sense selection, being equivalent to the frame selection problem in Artifical Intelligence[CW76], is very difficult. We do feel that verbgraph will aid in sense selection, but will not be as efficacious as for variant selection. In such a situation, perhaps the English parser can help disambiguate or we may want to ask an appropriate question to select the correct sense, or as a last resort, provide menu selection, IV. AN ALTERNATIVE TO VERBGRAPHS We are currently considering hierarchically structured transactions, as used in the TAXIS semantic model [MB80], as an alternative to verbgraphs. Verbgraphs can be ambiguous, and do not lend themselves to top-down design. Hierarchical transactions would seem to overcome both problems. Hierarchical transactions in TAXIS are not quite as versatile as verbgraphs in representing variants. The hierarchy is induced by hierarchies on the entity classes involved. Variants based on the relationship among particular entities, as recorded in the database, cannot be represented. For example, in the SCHEDULE-APPOINTMENT action, we may want to require that if a supervisor schedules a meeting with an employee not und</context>
</contexts>
<marker>[MB80]</marker>
<rawString>Mylopoulos, J., Bernstein, P.A., and Wong, H.K.T., A language facility for designing database-intensive applications. ACM TODS 5:2, June 1980, pp. 397-434.</rawString>
</citation>
<citation valid="false">
<authors>
<author>S C Salveter</author>
</authors>
<title>Inferring conceptual structures from pictorial input data.</title>
<tech>TR 328,1978.</tech>
<institution>University of Wisconsin, Computer Science Dept.,</institution>
<contexts>
<context position="10701" citStr="[Sa78]" startWordPosition="1730" endWordPosition="1730"> a series of deletions in the database. While some active verbs, such as &amp;quot;schedule,&amp;quot; may correspond to a single type of DB update, there are other verbs that will require multiple types of DB updates, such as &amp;quot;cancel,&amp;quot; which might require sending message as well as removing an appointment. &apos;Kaplan and Davidson are also trying to be domain independent, while we are trying to exploit domain-specific information. II. NATURE OF THE REPRESENTATION We propose a structure, a verbgraph, to represent action verbs. Verbgraph are extensions of frame-like structures used to represent verb meaning in MORAN[Sa78] and [Sa79]. One verbgraph is associated with each sense of a verb; that structure represents all variants. A real world change is described by a sentence that contains an active verb; the DB changes are accomplished by DML command sequences. A verbgraph is used to select DML sequences appropriate to process the variants of verb sense. We also wish to capture that one verb that may be used as part of another: we may have a verb sense RESERVE-ROOM that may be used by itself or may be used as a subpart of the verb SCHEDULE-TALK. Figure 4 is an example of verbgraph. It models the &amp;quot;schedule appoin</context>
</contexts>
<marker>[Sa78]</marker>
<rawString>Salveter, S.C., Inferring conceptual structures from pictorial input data. University of Wisconsin, Computer Science Dept., TR 328,1978.</rawString>
</citation>
<citation valid="false">
<authors>
<author>S C Salveter</author>
</authors>
<title>Inferring conceptual graphs.</title>
<booktitle>Cognitive Science,3,</booktitle>
<pages>141--166</pages>
<contexts>
<context position="10712" citStr="[Sa79]" startWordPosition="1732" endWordPosition="1732">f deletions in the database. While some active verbs, such as &amp;quot;schedule,&amp;quot; may correspond to a single type of DB update, there are other verbs that will require multiple types of DB updates, such as &amp;quot;cancel,&amp;quot; which might require sending message as well as removing an appointment. &apos;Kaplan and Davidson are also trying to be domain independent, while we are trying to exploit domain-specific information. II. NATURE OF THE REPRESENTATION We propose a structure, a verbgraph, to represent action verbs. Verbgraph are extensions of frame-like structures used to represent verb meaning in MORAN[Sa78] and [Sa79]. One verbgraph is associated with each sense of a verb; that structure represents all variants. A real world change is described by a sentence that contains an active verb; the DB changes are accomplished by DML command sequences. A verbgraph is used to select DML sequences appropriate to process the variants of verb sense. We also wish to capture that one verb that may be used as part of another: we may have a verb sense RESERVE-ROOM that may be used by itself or may be used as a subpart of the verb SCHEDULE-TALK. Figure 4 is an example of verbgraph. It models the &amp;quot;schedule appointment&amp;quot; sens</context>
</contexts>
<marker>[Sa79]</marker>
<rawString>Salveter, S.C., Inferring conceptual graphs. Cognitive Science,3, pp. 141-166.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D R Skuce</author>
</authors>
<title>Bridging the gap between natural and computer language.</title>
<date>1980</date>
<booktitle>Proc. of Int&apos;l Congress on Applied Systems, and Cybernetics,</booktitle>
<location>Acapulco,</location>
<contexts>
<context position="9339" citStr="[Sk80]" startWordPosition="1503" endWordPosition="1503">g and comparing particular DB implementations. Some of the semantic models that have been proposed are the entity-relationship model[Ch76], SDMEHM81], RM/T[Co79], TAXIS[MB80] and Beta[Br78]. For some of these models, methodologies exist for translating to a DB specification in various DB models, as well as for expressing the static correspondence between a SDD in the semantic model and a particular DB implementation. To express actions in these models, however, there are only terms that refer to DBs: insert, delete, modify, rather than schedule, cancel, postpone (the notable exception is Skuce[Sk80]). While there have been a number of approaches made to NL querying, there seems to be little work on NI update. Carbonell and Hayes[CH81] have looked at parsing a limited set of NL update commands, but they do not say much about generating the DB transactions for these commands. Kaplan and Davidson[KD81] have looked at the translation of NL updates to transactions, but the active verbs they deal with are synonyms for DB terms, essentially following the semantic data model as above. This limitation is intentional, as the following excerpt shows: First, it is assume that the underlying database</context>
<context position="19335" citStr="[Sk80]" startWordPosition="3237" endWordPosition="3237">e course of the interaction, as long as the path has not been determined and values remain unspecified. We use the following interaction protocol. The user enters the initial command and hits return. The program will accept additional lines of input. However, if the user just hits return, and the program needs more information, the program will generate a question. The user answers the question, followed by a return. As before, additional information may be entered on subsequent lines. If the user hits return on an empty line, another question is generated, if necessary. Brodie[Br81] and Skuce[Sk80] both present systems for representing DB change. Skuce&apos;s goal is to provide an English-like syntax for DB procedure specification. Procedures have a rigid format and require all information to be entered at time of invocation in a specific order, as with any computer subprogram. Brodie is attempting to also specify DB procedures for DB change. He allows some information to be specified later, but the order is fixed. Neither allow the user to choose the order of entry, and neither accomodates 71 variants that would require different sets of values to be specified. However, like our method, and</context>
</contexts>
<marker>[Sk80]</marker>
<rawString>Skuce, D.R., Bridging the gap between natural and computer language. Proc. of Int&apos;l Congress on Applied Systems, and Cybernetics, Acapulco, December 1980.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D E Walker</author>
</authors>
<title>Understanding Spoken Language.</title>
<date>1978</date>
<publisher>American Elsevier,</publisher>
<contexts>
<context position="1566" citStr="[Wa78]" startWordPosition="243" endWordPosition="243">a given verb might describe. In addition to describing the variants of a verb, they may be used to disambiguate the update command. Other possible uses of verbgraphs include, specification of defaults, prompting of the user to guide but not dictate user interaction and enforcing a variety of types of database integrity constraints. I. MOTIVIATION AND PROBLEM STATEMENT We want to support natural language interface for all aspects of database manipulation. English and English-like query systems already exist, such as ROBOT[Ha77], TQA[Da78], LUNAR[W076] and those described by Kaplan[Ka79], Walker[Wa78] and Waltz [Wz75]. We propose to extend natural language interaction to include data modification (insert, delete, modify) rather than simply data extraction. The desirability and unavailability of natural language database modification has been noted by Wiederhold, et al.[Wi81]. Database systems currently do not contain structures for explicit modelling of real world changes. A state of a database (DB) is meant to represent a state of a portion of the real world. This research is partially supported by NSF grants IST-79-18264 and ENG-79-07794. lie refer to the abstract description of the port</context>
</contexts>
<marker>[Wa78]</marker>
<rawString>Walker, D.E., Understanding Spoken Language. American Elsevier, 1978.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Wiederhold</author>
<author>S J Kaplan</author>
<author>D Sagalowicz</author>
</authors>
<title>Research in knowledge base management systems.</title>
<date>1981</date>
<journal>SIGMOD Record, VII,</journal>
<volume>3</volume>
<pages>26--54</pages>
<contexts>
<context position="1845" citStr="[Wi81]" startWordPosition="282" endWordPosition="282"> a variety of types of database integrity constraints. I. MOTIVIATION AND PROBLEM STATEMENT We want to support natural language interface for all aspects of database manipulation. English and English-like query systems already exist, such as ROBOT[Ha77], TQA[Da78], LUNAR[W076] and those described by Kaplan[Ka79], Walker[Wa78] and Waltz [Wz75]. We propose to extend natural language interaction to include data modification (insert, delete, modify) rather than simply data extraction. The desirability and unavailability of natural language database modification has been noted by Wiederhold, et al.[Wi81]. Database systems currently do not contain structures for explicit modelling of real world changes. A state of a database (DB) is meant to represent a state of a portion of the real world. This research is partially supported by NSF grants IST-79-18264 and ENG-79-07794. lie refer to the abstract description of the portion of the real world being modelled as the semantic data description (SDD). A SDD indicates a set of real world states (RWS) of interest, a DB definition gives a set of allowable database states (DES). The correspondence between the SDD and the DB definition induces connections</context>
</contexts>
<marker>[Wi81]</marker>
<rawString>Wiederhold, G., Kaplan, S.J., and Sagalowicz, D., Research in knowledge base management systems. SIGMOD Record, VII, #3, April 1981, pp. 26-54.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W Woods</author>
</authors>
<title>Speech Understanding Systems: Final</title>
<date>1976</date>
<tech>Technical Progress Report. BBN No. 3438,</tech>
<location>Cambridge, MA,</location>
<marker>[Wo76]</marker>
<rawString>Woods, W., et. al., Speech Understanding Systems: Final Technical Progress Report. BBN No. 3438, Cambridge, MA, 1976.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Waltz</author>
</authors>
<title>Natural language access to a large database: an engineering approach.</title>
<date>1976</date>
<booktitle>In Proc. of the Fourth Int&apos;l Joint Conf. on Artificial Intelligence,</booktitle>
<contexts>
<context position="1583" citStr="[Wz75]" startWordPosition="246" endWordPosition="246">t describe. In addition to describing the variants of a verb, they may be used to disambiguate the update command. Other possible uses of verbgraphs include, specification of defaults, prompting of the user to guide but not dictate user interaction and enforcing a variety of types of database integrity constraints. I. MOTIVIATION AND PROBLEM STATEMENT We want to support natural language interface for all aspects of database manipulation. English and English-like query systems already exist, such as ROBOT[Ha77], TQA[Da78], LUNAR[W076] and those described by Kaplan[Ka79], Walker[Wa78] and Waltz [Wz75]. We propose to extend natural language interaction to include data modification (insert, delete, modify) rather than simply data extraction. The desirability and unavailability of natural language database modification has been noted by Wiederhold, et al.[Wi81]. Database systems currently do not contain structures for explicit modelling of real world changes. A state of a database (DB) is meant to represent a state of a portion of the real world. This research is partially supported by NSF grants IST-79-18264 and ENG-79-07794. lie refer to the abstract description of the portion of the real w</context>
</contexts>
<marker>[Wz75]</marker>
<rawString>Waltz, D., Natural language access to a large database: an engineering approach. In Proc. of the Fourth Int&apos;l Joint Conf. on Artificial Intelligence, 1976.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>