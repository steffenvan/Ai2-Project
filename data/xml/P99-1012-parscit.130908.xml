<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000004">
<title confidence="0.9903335">
Preserving Semantic Dependencies in
Synchronous Tree Adjoining Grammar*
</title>
<author confidence="0.972339">
William Schuler
</author>
<affiliation confidence="0.997218">
University of Pennsylvania
</affiliation>
<address confidence="0.9728265">
200 South 33rd Street
Philadelphia, PA 19104 USA
</address>
<email confidence="0.999174">
schuler@linc.cis.upenn.edu
</email>
<sectionHeader confidence="0.995625" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999547263157895">
Rambow, Wier and Vijay-Shanker (Rambow et
al., 1995) point out the differences between TAG
derivation structures and semantic or predicate-
argument dependencies, and Joshi and Vijay-
Shanker (Joshi and Vijay-Shanker, 1999) de-
scribe a monotonic compositional semantics
based on attachment order that represents the
desired dependencies of a derivation without un-
derspecifying predicate-argument relationships
at any stage. In this paper, we apply the Joshi
and Vijay-Shanker conception of compositional
semantics to the problem of preserving seman-
tic dependencies in Synchronous TAG transla-
tion (Shieber and Schabes, 1990; Abeille et al.,
1990). In particular, we describe an algorithm
to obtain the semantic dependencies on a TAG
parse forest and construct a target derivation
forest with isomorphic or locally non-isomorphic
dependencies in 0(n7) time.
</bodyText>
<sectionHeader confidence="0.998522" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999963692307692">
The primary goal of this paper is to solve the
problem of preserving semantic dependencies in
Isomorphic Synchronous Tree Adjoining Gram-
mar (ISTAG) (Shieber, 1994; Shieber and Sch-
abes, 1990), a variant of Tree Adjoining Gram-
mar (Joshi, 1985) in which source and target
elementary trees are assembled into isomorphic
derivations. The problem, first described in
Rambow, Wier and Vijay-Shanker (Rambow et
al., 1995), stems from the fact that the TAG
derivation structure — even using a flat adjunc-
tion of modifiers (Schabes and Shieber, 1994)
— deviates from the appropriate dependency
</bodyText>
<footnote confidence="0.8516354">
*The author would like to thank Karin Kipper,
Aravind Joshi, Martha Palmer, Norm Badler, and
the anonymous reviewers for their valuable comments.
This work was partially supported by NSF Grant
SBR8920230 and ARO Grant DAAH0404-94-GE-0426.
</footnote>
<bodyText confidence="0.829014666666667">
structure in certain cases. This can result in
translation errors.
For example, if we parse sentence (1),
</bodyText>
<equation confidence="0.930444714285714">
(1) X is supposed to be able to fly.
using the trees in Figure 1, we get the following
derivation:1
a:fly
1
th:be-able-to(VP)
02 : is-supposed-to (VP )
</equation>
<bodyText confidence="0.99995425">
with the auxiliary is-supposed-to adjoining at
the VP to predicate over be-able-to and the aux-
iliary be-able-to adjoining at the VP to predi-
cate over fly. If we then try to assemble an iso-
morphic tree in a language such as Portuguese
(which makes less use of raising verbs) using
the ISTAG transfer rules in Figure 2, we will be
forced into an ill-formed derivation:
</bodyText>
<equation confidence="0.922958333333333">
a:voar
:é-capaz-de (VP )
02 :6-pressuposto-que(S?)
</equation>
<bodyText confidence="0.996770714285714">
because the raising construction is-supposed-
to translates to a bridge construction é-
pressuposto-que and cannot adjoin anywhere in
the tree for e-capaz-de (the translation of be-
able-to) because there is no S-labeled adjunction
site.
The correct target derivation:
</bodyText>
<equation confidence="0.446753333333333">
a:voar
:6-capaz-de(VP) 132 :6-pressuposto-que(S)
&apos;The subject is omitted to simplify the diagram.
</equation>
<page confidence="0.997534">
88
</page>
<figure confidence="0.997621625">
VP
Vo VP
is Vo VP
1
supposed Vo VP*
1
to
VP
Vo VP
be Vo VP
able Vo VP*
1
to
NP,. VP
Vo
fly
</figure>
<figureCaption confidence="0.996864">
Figure 1: Sample elementary trees
which yields the translation in sentence (2),
</figureCaption>
<bodyText confidence="0.963205142857143">
(2) E pressuposto que X é capaz de voar.
is not isomorphic to the source. Worse, this
non-isomorphism is unbounded, because the
bridge verb pressuposto may have to migrate
across any number of intervening raising verbs
to find an ancestor that contains an appropriate
adjunction site:
</bodyText>
<equation confidence="0.9964505">
1
0.-1:going(VP) 1
On-i:vai(VP)
On:supp.(VP)
</equation>
<bodyText confidence="0.9975223">
This sort of non-local non-isomorphic transfer
cannot be handled in a synchronous TAG that
has an isomorphism restriction on derivation
trees. On the other hand, we do not wish to
return to the original non-local formulation of
synchronous TAG (Shieber and Schabes, 1990)
because the non-local inheritance of links on
the derived tree is difficult to implement, and
because the non-local formulation can recog-
nize languages beyond the generative power of
TAG. Rambow, Wier and Vijay-Shanker them-
selves introduce D-Tree Grammar (Rambow et
al., 1995) and Candito and Kahane introduce
the DTG variant Graph Adjunction Grammar
(Candito and Kahane, 1998b) in order to solve
this problem using a derivation process that
mirrors composition more directly, but both in-
volve potentially significantly greater recogni-
tion complexity than TAG.
for &amp;quot;supposed to be able to fly&amp;quot;
</bodyText>
<sectionHeader confidence="0.989355" genericHeader="introduction">
2 Overview
</sectionHeader>
<bodyText confidence="0.981692555555556">
Our solution is to retain ISTAG, but move
the isomorphism restriction from the deriva-
tion structure to the predicate-argument at-
tachment structure described in (Joshi and
Vijay-Shanker, 1999).
This structure represents the composition of
semantic predicates for lexicalized elementary
trees, each of which contains a &apos;predicate&apos; vari-
able associated with the situation or entity that
the predicate introduces, and a set of &apos;argument&apos;
variables associated with the foot node and sub-
stitution sites in the original elementary tree.
The predicates are composed by identifying the
predicate variable in one predicate with an ar-
gument variable in another, so that the two vari-
ables refer to the same situation or entity.
Composition proceeds from the bottom up on
the derivation tree, with adjuncts traversed in
order from the lowest to the highest adjunction
site in each elementary tree, in much the same
way that a parser produces a derivation. When-
ever an initial tree is substituted, its predicate
variable is identified in the composed structure
with an argument variable of the tree it substi-
tutes into. Whenever an auxiliary tree is ad-
joined, the predicate variable of the tree it ad-
joins into is identified in the composed struc-
ture with one of its own argument variables. In
cases of adjunction, an auxiliary tree&apos;s seman-
tics can also specify which variable will become
the predicate variable of the composed struc-
ture for use in subsequent adjunctions at higher
adjunction sites: a modifier auxiliary will re-
turn the host tree&apos;s original predicate variable,
and a predicative auxiliary will return its own
predicate variable.2 Since the traversal must
</bodyText>
<footnote confidence="0.801995">
2See (Schabes and Shieber, 1994) for definitions of
modifier and predicative auxiliaries.
</footnote>
<equation confidence="0.8793745">
a:fly a:voar
:capaz(VP) /37,:press.(S)
1
1
[31. :able(VP)
1
</equation>
<page confidence="0.998257">
89
</page>
<table confidence="0.973888235294118">
VP
Vo VP
is Vo VP
supposed Vo VP*
to
Vo Vo
pressuposto Vo S*
que
VP VP
Vo VP Vo VP
be Vo VP 6 Vo VP
able Vo VP* capaz Vo VP*
de
NP,I, VP NP,l, VP
Vo Vo
fly voar
to
</table>
<figureCaption confidence="0.997262">
Figure 2: Synchronous tree pairs for &amp;quot;supposed to be able to fly&amp;quot;
</figureCaption>
<bodyText confidence="0.999900512820513">
proceed from the bottom up, the attachment of
predicates to arguments is neither destructive
nor underspecified at any stage in the interpre-
tation.
For example, assume the initial tree a:fly has
a predicate variable .91, representing the situa-
tion of something flying, and an argument vari-
able xl, representing the thing that is flying;
and assume the predicative auxiliary tree th:be-
able-to has a predicate variable 82, represent-
ing the situation of something being possible,
and an argument variable 83, representing the
thing that is possible. If th is now adjoined
into a, the composed structure would have si
identified with s3 (since the situation of flying
is the thing that is possible), and s2 as an over-
all predicate variable, so if another tree later
adjoins into this composed structure rooted on
a, it will predicate over s2 (the situation that
flying is possible) rather than over a&apos;s original
predicate variable .si (the situation of flying by
itself). Note that Joshi and Vijay-Shanker do
not require the predicate and modifier distinc-
tions, because they can explicitly specify the
fates of any number of predicate variables in
a tree&apos;s semantic representation. For simplicity,
we will limit our discussion to only the two pos-
sibilities of predicative and modifier auxiliaries,
using one predicate variable per tree.
If we represent each such predicate-argument
attachment as an arc in a directed graph, we can
view the predicate-argument attachment struc-
ture of a derivation as a dependency graph, in
much the same way as Candito and Kahane
interpret the original derivation trees (Candito
and Kahane, 1998a). More importantly, we can
see that this definition predicts the predicate-
argument dependencies for sentences (1) and (2)
to be isomorphic:
</bodyText>
<equation confidence="0.902790666666667">
4:supposed-to 00:6-pressuposto-que
01:be-able-to 01:6-capaz-de
02:flY 02:voar
</equation>
<bodyText confidence="0.999483090909091">
even though their derivation trees are not.
This is because the predicative auxiliary for
é-capaz-de returns its predicate variable to the
host tree for subsequent adjunctions, so the aux-
iliary tree for é-pressuposto-que can attach it as
one of its arguments, just as if it had adjoined
directly to the auxiliary, as supposed-to does in
English.
It is also important to note that Joshi and
Vijay-Shanker&apos;s definition of TAG composi-
tional semantics differs from that of Shieber
</bodyText>
<page confidence="0.988817">
90
</page>
<bodyText confidence="0.99977">
and Schabes (Shieber and Schabes, 1990) using
Synchronous TAG, in that the former preserves
the scope ordering of predicative adjunctions,
which may be permuted in the latter, altering
the meaning of the sentence.3 It is precisely
this scope-preserving property we hope to ex-
ploit in our formulation of a dependency-based
isomorphic synchronous TAG in the next two
sections. However, as Josh i and Vijay-Shanker
suggest, the proper treatment of synchronous
translation to logical form may require a multi-
component Synchronous TAG analysis in order
to handle quantifiers, which is beyond the scope
of this paper. For this reason, we will focus on
examples in machine translation.
</bodyText>
<sectionHeader confidence="0.983" genericHeader="method">
3 Obtaining Source Dependencies
</sectionHeader>
<bodyText confidence="0.999990607142857">
If we assume that this attachment structure
captures a sentence&apos;s semantic dependencies,
then in order to preserve semantic dependencies
in synchronous TAG translation, we will need to
obtain this structure from a source derivation
and then construct a target derivation with an
isomorphic structure.
The first algorithm we present obtains se-
mantic dependencies for derivations by keep-
ing track of an additional field in each chart
item during parsing, corresponding to the pred-
icate variable from Section 2. Other than the
additional field, the algorithm remains essen-
tially the same as the parsing algorithm de-
scribed in (Schabes and Shieber, 1994), so it
can be applied as a transducer during recogni-
tion, or as a post-process on a derivation forest
(Vijay-Shanker and Weir, 1993). Once the de-
sired dependencies are obtained, the forest may
be filtered to select a single most-preferred tree
using statistics or rule-based selectional restric-
tions on those dependencies.4
For calculating dependencies, we define a
function arg(777) to return the argument posi-
tion associated with a substitution site or foot
node 77 in elementary tree 7. Let a dependency
be defined as a labeled arc (0,1,q,b), from predi-
cate 0 to predicate 0 with label 1.
</bodyText>
<listItem confidence="0.9702395">
• For each tree selected by 0, set the predi-
cate variable of each anchor item to 0.
</listItem>
<footnote confidence="0.99518475">
3See (Joshi and Vijay-Shanker, 1999) for a complete
description.
4See (Schuler, 1998) for a discussion of statistically
filtering TAG forests using semantic dependencies.
</footnote>
<listItem confidence="0.990165125">
• For each substitution of initial tree Geo
with predicate variable co into -yo at node
address 77, emit (0, arg(ry,71),w)
• For each modifier adjunction of auxil-
iary tree )3,/, into tree 74, with predicate vari-
able x, emit (0,arg(13, FOOT), x) and set
the predicate variable of the composed item
to x.
• For each predicative adjunction of aux-
iliary tree Ap with predicate variable co
into tree -y,/, with predicate variable x, emit
(0, arg(0, FOOT), x) and set the predicate
variable of the composed item to w.
• For all other productions, propagate the
predicate variable up along the path from
the main anchor to the root.
</listItem>
<bodyText confidence="0.966341333333333">
Since the number of possible values for the
additional predicate variable field is bounded
by n, where n is the number of lexical items
in the input sentence, and none of the produc-
tions combine more than one predicate variable,
the complexity of the dependency transducing
algorithm is 0(n7).
This algorithm can be applied to the example
derivation tree in Section 1,
</bodyText>
<equation confidence="0.645514">
a:fly
/3i:be-able-to (VP)
02 As-supposed-to(VP)
</equation>
<bodyText confidence="0.998429">
which resembles the stacked derivation tree for
Candito and Kahane&apos;s example 5a, &amp;quot;Paul claims
Mary said Peter left.&amp;quot;
First, we adjoin 02 : i s - s up posed- to at node VP
of /3 :be-able-to, which produces the dependency
(is-supposed-to, 0,be-able-to). Then we adjoin
th:be-able-to at node VP of aliy, which pro-
duces the dependency (be-able-to, 0,fly). The
resulting dependencies are represented graphi-
cally in the dependency structure below:
</bodyText>
<equation confidence="0.968701333333333">
00 :supposed-to
01 :be-able-to(0)
9521137(0)
</equation>
<bodyText confidence="0.93022275">
This example is relatively straightforward,
simply reversing the direction of adjunction de-
pendencies as described in (Candito and Ka-
hane, 1998a), but this algorithm can transduce
</bodyText>
<page confidence="0.994951">
91
</page>
<bodyText confidence="0.999947857142857">
the correct isomorphic dependency structure for
the Portuguese derivation as well, similar to the
distributed derivation tree in Candito and Ka-
hane&apos;s example 5b, &amp;quot;Paul claims Mary seems to
adore hot dogs,&amp;quot; (Rambow et al., 1995), where
there is no edge corresponding to the depen-
dency between the raising and bridge verbs:
</bodyText>
<equation confidence="0.943576">
a:voar
01:6-capaz-de(VP) 02:é-pressuposto-que(S)
</equation>
<bodyText confidence="0.999973384615385">
We begin by adjoining th:e-capaz-de at node
VP of a:voar, which produces the dependency
(é-capaz-de, 0,voar), just as before. Then we ad-
join 02:é-pressuposto-que at node S of a:voar.
This time, however, we must observe the predi-
cate variable of the chart item for a:voar which
was updated in the previous adjunction, and
now references é-capaz-de instead of voar. Be-
cause the transduction rule for adjunction uses
the predicate variable of the parent instead of
just the predicate, the dependency produced by
the adjunction of 02 is (é-pressuposto-que, 0,e-
capaz-de), yielding the graph:
</bodyText>
<equation confidence="0.934227333333333">
00:6-pressuposto-que
01:6-capaz-de(0)
02:voar(0)
</equation>
<bodyText confidence="0.996387">
The derivation examples above only address
the preservation of dependencies through ad-
junction. Let us now attempt to preserve
both substitution and adjunction dependencies
in transducing a sentence based on Candito and
Kahane&apos;s example 5c, &amp;quot;That Paul has to stay
surprised Mary,&amp;quot; in order to demonstrate how
they interact.5 We begin with the derivation
tree:
</bodyText>
<equation confidence="0.960341333333333">
a1 :surprise
a2:stay(So) a4:Mary(Nip1)
a3:Paul(NP0) 0:have-to(VP)
</equation>
<bodyText confidence="0.973024571428571">
5We have replaced want to in the original example
with have to in order to highlight the dependency struc-
ture and set aside any translation issues related to PRO
control.
As Candito and Kahane point out, this
derivation tree does not match the dependency
structure of the sentence as described in Mean-
ing Text Theory (Mel&apos;cuk, 1988), because there
is no edge in the derivation corresponding to
the dependency between surprise and have-to
(the necessity of Paul&apos;s staying is what surprises
Mary, not his staying in itself). Using the above
algorithm, however, we can still produce the de-
sired dependency structure:
</bodyText>
<equation confidence="0.98148675">
01:surprise
02:have-to(0) 5:Mary(1)
03 :stay(0)
04:Paul(0)
</equation>
<bodyText confidence="0.999939714285714">
by adjoining 0:have-to at node VP of a2:stay
to produce a composed item with have-to as
its predicate variable, as well as the depen-
dency (have-to, 0,stay). When a2:stay substi-
tutes at node So of a1 :surprise, the resulting
dependency also uses the predicate variable of
the argument, yielding (surprise, 0,have-to).
</bodyText>
<sectionHeader confidence="0.995351" genericHeader="method">
4 Obtaining Target Derivations
</sectionHeader>
<bodyText confidence="0.994717125">
Once a source derivation is selected from the
parse forest, the predicate-argument dependen-
cies can be read off from the items in the forest
that constitute the selected derivation. The re-
sulting dependency graph can then be mapped
to a forest of target derivations, where each
predicate node in the source dependency graph
is linked to a set of possible elementary trees in
the target grammar, each of which is instanti-
ated with substitution or adjunction edges lead-
ing to other linked sets in the forest. The el-
ementary trees in the target forest are deter-
mined by the predicate pairs in the transfer lex-
icon, and by the elementary trees that can re-
alize the translated targets. The substitution
and adjunction edges in the target forest are
determined by the argument links in the trans-
fer lexicon, and by the substitution and adjunc-
tion configurations that can realize the trans-
lated targets&apos; dependencies.
Mapping dependencies into substitutions is
relatively straightforward, but we have seen in
Section 2 that different adjunction configura-
tions (such as the raising and bridge verb ad-
</bodyText>
<page confidence="0.990889">
92
</page>
<bodyText confidence="0.999981285714286">
junctions in sentences (I) and (2)) can corre-
spond to the same dependency graph, so we
should expect that some dependencies in our
target graph may correspond to more than one
adjunction configuration in the target deriva-
tion tree. Since a dependency may be realized
by adjunctions at up to n different sites, an un-
constrained algorithm would require exponen-
tial time to find a target derivation in the worst
case. In order to reduce this complexity, we
present a dynamic programming algorithm for
constructing a target derivation forest in time
proportional to 0(n4) which relies on a restric-
tion that the target derivations must preserve
the relative scope ordering of the predicates in
the source dependency graph.
This restriction carries the linguistic implica-
tion that the scope ordering of adjuncts is part
of the meaning of a sentence and should not
be re-arranged in translation. Since we exploit
a notion of locality similar to that of Isomor-
phic Synchronous TAG, we should not expect
the generative power of our definition to exceed
the generative power of TAG, as well.
First, we define an ordering of predicates on
the source dependency graph corresponding to a
depth-first traversal of the graph, originating at
the predicate variable of the root of the source
derivation, and visiting arguments and modi-
fiers in order from lowest to highest scope. In
other words, arguments and modifiers will be
ordered from the bottom up on the elementary
tree structure of the parent, such that the foot
node argument of an elementary tree has the
lowest scope among the arguments, and the first
adjunct on the main (trunk) anchor has the low-
est scope among the modifiers.
Arguments, which can safely be permuted
in translation because their number is finitely
bounded, are traversed entirely before the par-
ent; and modifiers, which should not be per-
muted because they may be arbitrarily numer-
ous, are traversed entirely after the parent.
This enumeration will roughly correspond to
the scoping order for the adjuncts in the source
derivation, while preventing substituted trees
from interrupting possible scoping configura-
tions. We can now identify all the descendants
of any elementary tree in a derivation because
they will form a consecutive series in the enu-
meration described above. It therefore provides
a convenient way to generate a target derivation
forest that preserves the scoping information in
the source, by &apos;parsing&apos; the scope-ordered string
of elementary trees, using indices on this enu-
meration instead of on a string yield.
It is important to note that in defining this
algorithm, we assume that all trees associated
with a particular predicate will use the same
argument structure as that predicate.6 We also
assume that the set of trees associated with a
particular predicate may be filtered by transfer-
ring information such as mood and voice from
source to target predicates.
Apart from the different use of indices, the
algorithm we describe is exactly the reverse of
the transducer described in Section 3, taking
a dependency graph D and producing a TAG
derivation forest containing exactly the set of
derivation trees for which those dependencies
hold. Here, as in a parsing algorithm, we define
forest items as tuples of (70, j, x) where
a, )3, and 7 are elementary trees with node 77, 0
and &apos;0 are predicates, x and w be predicate vari-
ables, and T and 1 are delimiters for opening
and closing adjunction, but now let i, j, and k
refer to the indices on the scoping enumeration
described above, instead of on an input string.
In order to reconcile scoping ranges for substi-
tution, we must also define a function first(q)
to return the leftmost (lowest) edge of the O&apos;s
range in the scope enumeration, and last(0) to
return the rightmost (highest) edge of the 0&apos;s
range in the scope enumeration.
</bodyText>
<listItem confidence="0.99551775">
• For each tree -y mapped from predicate 0
at scope i, introduce (-yo, f ir st(0),i +1, 0).
• If (0, ar g(ry , 77), w) ED,
try substitution of a into
</listItem>
<equation confidence="0.901937">
(av„ ROOT, T, f irst(w),last(w),w)
(&apos;y0777 -1-1 -7 -7 -)
</equation>
<bodyText confidence="0.953546545454545">
6Although this does not hold for certain relative
clause elementary trees with wh-extractions as substi-
tutions sites (since the wh-site is an argument of the
main verb of the clause instead of the foot node), Can-
dito and Kahane (Candito and Kahane, 1998b) suggest
an alternative analysis which can be extended to TAG
by adjoining the relative clause into its wh-word as a
predicative adjunct, and adjoining the wh-word into the
parent noun phrase as a modifier, so the noun phrase is
treated as an argument of the wh-word rather than of
the relative clause.
</bodyText>
<page confidence="0.994105">
93
</page>
<listItem confidence="0.98405675">
• If (11) , arg(0 , FOOT), x) ED,
try modifier adjunction of /3 into -y:
(00, ROOT, T, j, k, u.))
• If (11) , arg(i 3, FOOT), x) ED,
</listItem>
<bodyText confidence="0.913484733333333">
try predicative adjunction of 3 into -y:
(AP, ROOT, , j,k,w)
(ry T, k, w)
• Apply productions for nonterminal projec-
tion as in the transducer algorithm, prop-
agating index ranges and predicative vari-
ables up along the path from the main an-
chor to the root.
Since none of the productions combine more
than three indices and one predicate variable,
and since the indices and predicate variable may
have no more than n distinct values, the algo-
rithm runs in 0(n4) time. Note that one of
the indices may be redundant with the predi-
cate variable, so a more efficient implementation
might be possible in 0(n3).
We can demonstrate this algorithm by trans-
lating the English dependency graph from Sec-
tion 1 into a derivation tree for Portuguese.
First, we enumerate the predicates with their
relative scoping positions:
[3] o:is-supposed-to
[2] 01:be-able-to
[1] 02:fly
Then we construct a derivation forest based
on the translated elementary trees a:voar, /31 :é-
capaz-de, and 02 : é-pressuposto-que. Beginning
at the bottom, we assign to these constituents
the relative scoping ranges of 1-2, 2-3, and 3-$,
respectively, where $ is a terminal symbol.
</bodyText>
<equation confidence="0.573631">
(avoar,1,2, • •) (Ocapaz 7 2,3, • • ) (Opress, 3, $, ..)
</equation>
<bodyText confidence="0.990627722222223">
Since there is a dependency from be-able-to to
fly, we can adjoin [31:6-capaz-de to a:voar such
that it covers the range of scopes from 1 to 3
(from voar to e-capaz-de), so we add this possi-
bility to the forest.
(avoar , 1, 2, • •) (13capaz, 2,3, -•) (Opress, 3,$, ..)
(avow., 1, 3, capaz)
There is also a dependency from is-supposed-
to to be-able-to allowing us to adjoin 02: 6-
pressuposto-que to /31:6-capaz-de to make it
cover the range from 2 to $7 but there would
be no S node to host its adjunction, so this pos-
sibility can not be added to the forest. We can,
however, adjoin 132 : é-pressuposto-que to the in-
stance of a:voar extending to i3 :é-capaz-de that
covers the range from 1 to 3, resulting in a com-
plete analysis of the entire scope from 1 to $,
(from a:voar to 132 :pressuposto) rooted on voar:
</bodyText>
<equation confidence="0.883343333333333">
(avoar, 1, 2, ••) (Ocapaz,2,3, • •) (13press,3,$, ••)
(aVOar, 1,3, capaz)
(avoar, 1, $, press)
</equation>
<bodyText confidence="0.889423166666667">
which matches the distributed derivation tree
where both auxiliary trees adjoin to voar.
[1-$]a:voar
[2-31,31:6-capaz-de(VP) [3-$]/32:6-pressup.-que(S)
Let us compare this to a translation using the
same dependency structure, but different words:
</bodyText>
<reference confidence="0.512592">
[3] 00 :is-going-to
[2] 1:be-able-to
[1] 2:fly
</reference>
<bodyText confidence="0.994446">
Once again we select trees in the target lan-
guage, and enumerate them with scoping ranges
in a pre-order traversal, but this time the con-
struction at scope position 3 must be translated
as a raising verb (vai) instead of as a bridge con-
struction ( 6-pressuposto-que):
(avoar &apos;1,2, .•) (Ocapaz, 2,3, ••) (Ovai, 3,$, -•)
Although we can still adjoin th:ser-capaz-de at
the VP node of a:voar, we will have nowhere
to adjoin 132:vai, since the VP node of a:voar
is now occupied, and only one predicative tree
may adjoin at any node.7
</bodyText>
<footnote confidence="0.589888">
(avoar )1)2) • &apos;) (Ocapaz 72) 3)••) (Ovai,3,$, ••)
1,3, capaz)
7See (Schabes and Shieber, 1994) for the motivations
of this restriction.
</footnote>
<page confidence="0.999115">
94
</page>
<bodyText confidence="0.999810666666667">
Fortunately, we can also realize the depen-
dency between vai and ser-capaz-de by adjoin-
ing f32:vai at the VP.
</bodyText>
<equation confidence="0.988225">
(avoar 1) 2) *•) (13capaz ) 2) 3) • •) (Ovai 31 $) • •)
(Paapaz, 2, $, vai)
</equation>
<bodyText confidence="0.999403333333333">
The new instance spanning from 2 to $ (from
01.:capaz to 02 :vai) can then be adjoined at the
VP node of voar, to complete the derivation.
</bodyText>
<equation confidence="0.943183333333333">
(avOar I 1, 2, ••) (i3aapaz, 2, ••) (13vai 73, $, ..)
(Ocapaz 2, $, vai)
(avoar, 1, $, vai)
</equation>
<bodyText confidence="0.988355333333333">
This corresponds to the stacked derivation,
with 132:vai adjoined to 131:ser-capaz-de and
01:ser-capaz-de adjoined to a:voar:
</bodyText>
<figure confidence="0.55677">
[1-$] a:voar
[2-$] th:ser-capaz-de(VP)
[3-$] 02 :vai(VP)
</figure>
<sectionHeader confidence="0.882931" genericHeader="conclusions">
5 Conclusion
</sectionHeader>
<bodyText confidence="0.999989">
We have presented two algorithms — one for in-
terpreting a derivation forest as a semantic de-
pendency graph, and the other for realizing a
semantic dependency graph as a derivation for-
est — that make use of semantic dependencies as
adapted from the notion of predicate-argument
attachment in (Joshi and Vijay-Shanker, 1999),
and we have described how these algorithms can
be run together in a synchronous TAG trans-
lation system, in 0(n7) time, using transfer
rules predicated on isomorphic or locally non-
isomorphic dependency graphs rather than iso-
morphic or locally non-isomorphic derivation
trees. We have also demonstrated how such
a system would be necessary in translating a
real-world example that is isomorphic on de-
pendency graphs but globally non-isomorphic
on derivation trees. This system is currently
being implemented as part of the Xtag project
at the University of Pennsylvania, and as nat-
ural language interface in the Human Modeling
and Simulation project, also at Penn.
</bodyText>
<sectionHeader confidence="0.997888" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999803">
Anne Abeille, Yves Schabes, and Aravind K. Joshi.
1990. Using lexicalized tree adjoining grammars
for machine translation. In Proceedings of the
13th International Conference on Computational
Linguistics (COLING &apos;90), Helsinki, Finland, Au-
gust.
Marie-Helene Candito and Sylvain Kahane. 1998a.
Can the TAG derivation tree represent a semantic
graph? In Proceedings of the TAG+4 Workshop,
University of Pennsylvania, August.
Marie-Helene Candito and Sylvain Kahane. 1998b.
Defining DTG derivations to get semantic graphs.
In Proceedings of the TAG+4 Workshop, Univer-
sity of Pennsylvania, August.
Aravind Joshi and K. Vijay-Shanker. 1999. Com-
positional Semantics with Lexicalized Tree-
Adjoining Grammar (LTAG): How Much Under-
specification is Necessary? In Proceedings of the
2nd International Workshop on Computational
Semantics.
Aravind K. Joshi. 1985. How much context sensitiv-
ity is necessary for characterizing structural de-
scriptions: Tree adjoining grammars. In L. Kart-
tunen D. Dowty and A. Zwicky, editors, Natural
language parsing: Psychological, computational
and theoretical perspectives, pages 206-250. Cam-
bridge University Press, Cambridge, U.K.
Anthony S. Kroch. 1989. Asymmetries in long dis-
tance extraction in a TAG grammar. In M. Baltin
and A. Kroch, editors, Alternative Conceptions
of Phrase Structure, pages 66-98. University of
Chicago Press.
Igor Mel&apos;cuk. 1988. Dependency syntax: theory and
practice . State University of NY Press, Albany.
Owen Rambow and Giorgio Satta. 1996. Syn-
chronous Models of Language. In Proceedings of
the 34th Annual Meeting of the Association for
Computational Linguistics (ACL &apos;96).
Owen Rambow, David Weir, and K. Vijay-Shanker.
1995. D-tree grammars. In Proceedings of the
33rd Annual Meeting of the Association for Com-
putational Linguistics (ACL &apos;95).
Yves Schabes and Stuart M. Shieber. 1994. An al-
ternative conception of tree-adjoining derivation.
Computational Linguistics, 20(491-124.
William Schuler. 1998. Expoiting semantic depen-
dencies in parsing. Proceedings of the TAG+4
Workshop.
Stuart M. Shieber and Yves Schabes. 1990. Syn-
chronous tree adjoining grammars. In Proceedings
of the 13th International Conference on Compu-
tational Linguistics (COLING &apos;90), Helsinki, Fin-
land, August.
Stuart M. Shieber. 1994. Restricting the weak-
generative capability of synchronous tree adjoin-
ing grammars. Computational Intelligence, 10(4).
K. Vijay-Shanker and D.J. Weir. 1993. The use of
shared forests in tree adjoining grammar parsing.
In Proceedings of EA CL &apos;93, pages 384-393.
</reference>
<page confidence="0.999078">
95
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.751153">
<title confidence="0.9972415">Preserving Semantic Dependencies in Synchronous Tree Adjoining Grammar*</title>
<author confidence="0.999843">William Schuler</author>
<affiliation confidence="0.999895">University of Pennsylvania</affiliation>
<address confidence="0.9952395">200 South 33rd Street Philadelphia, PA 19104 USA</address>
<email confidence="0.999795">schuler@linc.cis.upenn.edu</email>
<abstract confidence="0.998739368421053">Rambow, Wier and Vijay-Shanker (Rambow et al., 1995) point out the differences between TAG derivation structures and semantic or predicateargument dependencies, and Joshi and Vijay- Shanker (Joshi and Vijay-Shanker, 1999) describe a monotonic compositional semantics based on attachment order that represents the desired dependencies of a derivation without underspecifying predicate-argument relationships at any stage. In this paper, we apply the Joshi and Vijay-Shanker conception of compositional semantics to the problem of preserving semantic dependencies in Synchronous TAG translation (Shieber and Schabes, 1990; Abeille et al., 1990). In particular, we describe an algorithm the semantic dependencies on a TAG parse forest and construct a target derivation forest with isomorphic or locally non-isomorphic</abstract>
<intro confidence="0.773334">in</intro>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<note>[3] 00 :is-going-to [2] 1:be-able-to [1] 2:fly</note>
<marker></marker>
<rawString>[3] 00 :is-going-to [2] 1:be-able-to [1] 2:fly</rawString>
</citation>
<citation valid="true">
<authors>
<author>Anne Abeille</author>
<author>Yves Schabes</author>
<author>Aravind K Joshi</author>
</authors>
<title>Using lexicalized tree adjoining grammars for machine translation.</title>
<date>1990</date>
<booktitle>In Proceedings of the 13th International Conference on Computational Linguistics (COLING &apos;90),</booktitle>
<location>Helsinki, Finland,</location>
<contexts>
<context position="840" citStr="Abeille et al., 1990" startWordPosition="110" endWordPosition="113">jay-Shanker (Rambow et al., 1995) point out the differences between TAG derivation structures and semantic or predicateargument dependencies, and Joshi and VijayShanker (Joshi and Vijay-Shanker, 1999) describe a monotonic compositional semantics based on attachment order that represents the desired dependencies of a derivation without underspecifying predicate-argument relationships at any stage. In this paper, we apply the Joshi and Vijay-Shanker conception of compositional semantics to the problem of preserving semantic dependencies in Synchronous TAG translation (Shieber and Schabes, 1990; Abeille et al., 1990). In particular, we describe an algorithm to obtain the semantic dependencies on a TAG parse forest and construct a target derivation forest with isomorphic or locally non-isomorphic dependencies in 0(n7) time. 1 Introduction The primary goal of this paper is to solve the problem of preserving semantic dependencies in Isomorphic Synchronous Tree Adjoining Grammar (ISTAG) (Shieber, 1994; Shieber and Schabes, 1990), a variant of Tree Adjoining Grammar (Joshi, 1985) in which source and target elementary trees are assembled into isomorphic derivations. The problem, first described in Rambow, Wier </context>
</contexts>
<marker>Abeille, Schabes, Joshi, 1990</marker>
<rawString>Anne Abeille, Yves Schabes, and Aravind K. Joshi. 1990. Using lexicalized tree adjoining grammars for machine translation. In Proceedings of the 13th International Conference on Computational Linguistics (COLING &apos;90), Helsinki, Finland, August.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Marie-Helene Candito</author>
<author>Sylvain Kahane</author>
</authors>
<title>Can the TAG derivation tree represent a semantic graph?</title>
<date>1998</date>
<booktitle>In Proceedings of the TAG+4 Workshop,</booktitle>
<institution>University of Pennsylvania,</institution>
<contexts>
<context position="4080" citStr="Candito and Kahane, 1998" startWordPosition="627" endWordPosition="630">on-isomorphic transfer cannot be handled in a synchronous TAG that has an isomorphism restriction on derivation trees. On the other hand, we do not wish to return to the original non-local formulation of synchronous TAG (Shieber and Schabes, 1990) because the non-local inheritance of links on the derived tree is difficult to implement, and because the non-local formulation can recognize languages beyond the generative power of TAG. Rambow, Wier and Vijay-Shanker themselves introduce D-Tree Grammar (Rambow et al., 1995) and Candito and Kahane introduce the DTG variant Graph Adjunction Grammar (Candito and Kahane, 1998b) in order to solve this problem using a derivation process that mirrors composition more directly, but both involve potentially significantly greater recognition complexity than TAG. for &amp;quot;supposed to be able to fly&amp;quot; 2 Overview Our solution is to retain ISTAG, but move the isomorphism restriction from the derivation structure to the predicate-argument attachment structure described in (Joshi and Vijay-Shanker, 1999). This structure represents the composition of semantic predicates for lexicalized elementary trees, each of which contains a &apos;predicate&apos; variable associated with the situation or </context>
<context position="7972" citStr="Candito and Kahane, 1998" startWordPosition="1268" endWordPosition="1271">er do not require the predicate and modifier distinctions, because they can explicitly specify the fates of any number of predicate variables in a tree&apos;s semantic representation. For simplicity, we will limit our discussion to only the two possibilities of predicative and modifier auxiliaries, using one predicate variable per tree. If we represent each such predicate-argument attachment as an arc in a directed graph, we can view the predicate-argument attachment structure of a derivation as a dependency graph, in much the same way as Candito and Kahane interpret the original derivation trees (Candito and Kahane, 1998a). More importantly, we can see that this definition predicts the predicateargument dependencies for sentences (1) and (2) to be isomorphic: 4:supposed-to 00:6-pressuposto-que 01:be-able-to 01:6-capaz-de 02:flY 02:voar even though their derivation trees are not. This is because the predicative auxiliary for é-capaz-de returns its predicate variable to the host tree for subsequent adjunctions, so the auxiliary tree for é-pressuposto-que can attach it as one of its arguments, just as if it had adjoined directly to the auxiliary, as supposed-to does in English. It is also important to note that </context>
<context position="12554" citStr="Candito and Kahane, 1998" startWordPosition="1996" endWordPosition="2000">resembles the stacked derivation tree for Candito and Kahane&apos;s example 5a, &amp;quot;Paul claims Mary said Peter left.&amp;quot; First, we adjoin 02 : i s - s up posed- to at node VP of /3 :be-able-to, which produces the dependency (is-supposed-to, 0,be-able-to). Then we adjoin th:be-able-to at node VP of aliy, which produces the dependency (be-able-to, 0,fly). The resulting dependencies are represented graphically in the dependency structure below: 00 :supposed-to 01 :be-able-to(0) 9521137(0) This example is relatively straightforward, simply reversing the direction of adjunction dependencies as described in (Candito and Kahane, 1998a), but this algorithm can transduce 91 the correct isomorphic dependency structure for the Portuguese derivation as well, similar to the distributed derivation tree in Candito and Kahane&apos;s example 5b, &amp;quot;Paul claims Mary seems to adore hot dogs,&amp;quot; (Rambow et al., 1995), where there is no edge corresponding to the dependency between the raising and bridge verbs: a:voar 01:6-capaz-de(VP) 02:é-pressuposto-que(S) We begin by adjoining th:e-capaz-de at node VP of a:voar, which produces the dependency (é-capaz-de, 0,voar), just as before. Then we adjoin 02:é-pressuposto-que at node S of a:voar. This t</context>
<context position="20426" citStr="Candito and Kahane, 1998" startWordPosition="3283" endWordPosition="3286">the leftmost (lowest) edge of the O&apos;s range in the scope enumeration, and last(0) to return the rightmost (highest) edge of the 0&apos;s range in the scope enumeration. • For each tree -y mapped from predicate 0 at scope i, introduce (-yo, f ir st(0),i +1, 0). • If (0, ar g(ry , 77), w) ED, try substitution of a into (av„ ROOT, T, f irst(w),last(w),w) (&apos;y0777 -1-1 -7 -7 -) 6Although this does not hold for certain relative clause elementary trees with wh-extractions as substitutions sites (since the wh-site is an argument of the main verb of the clause instead of the foot node), Candito and Kahane (Candito and Kahane, 1998b) suggest an alternative analysis which can be extended to TAG by adjoining the relative clause into its wh-word as a predicative adjunct, and adjoining the wh-word into the parent noun phrase as a modifier, so the noun phrase is treated as an argument of the wh-word rather than of the relative clause. 93 • If (11) , arg(0 , FOOT), x) ED, try modifier adjunction of /3 into -y: (00, ROOT, T, j, k, u.)) • If (11) , arg(i 3, FOOT), x) ED, try predicative adjunction of 3 into -y: (AP, ROOT, , j,k,w) (ry T, k, w) • Apply productions for nonterminal projection as in the transducer algorithm, propag</context>
</contexts>
<marker>Candito, Kahane, 1998</marker>
<rawString>Marie-Helene Candito and Sylvain Kahane. 1998a. Can the TAG derivation tree represent a semantic graph? In Proceedings of the TAG+4 Workshop, University of Pennsylvania, August.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Marie-Helene Candito</author>
<author>Sylvain Kahane</author>
</authors>
<title>Defining DTG derivations to get semantic graphs.</title>
<date>1998</date>
<booktitle>In Proceedings of the TAG+4 Workshop,</booktitle>
<institution>University of Pennsylvania,</institution>
<contexts>
<context position="4080" citStr="Candito and Kahane, 1998" startWordPosition="627" endWordPosition="630">on-isomorphic transfer cannot be handled in a synchronous TAG that has an isomorphism restriction on derivation trees. On the other hand, we do not wish to return to the original non-local formulation of synchronous TAG (Shieber and Schabes, 1990) because the non-local inheritance of links on the derived tree is difficult to implement, and because the non-local formulation can recognize languages beyond the generative power of TAG. Rambow, Wier and Vijay-Shanker themselves introduce D-Tree Grammar (Rambow et al., 1995) and Candito and Kahane introduce the DTG variant Graph Adjunction Grammar (Candito and Kahane, 1998b) in order to solve this problem using a derivation process that mirrors composition more directly, but both involve potentially significantly greater recognition complexity than TAG. for &amp;quot;supposed to be able to fly&amp;quot; 2 Overview Our solution is to retain ISTAG, but move the isomorphism restriction from the derivation structure to the predicate-argument attachment structure described in (Joshi and Vijay-Shanker, 1999). This structure represents the composition of semantic predicates for lexicalized elementary trees, each of which contains a &apos;predicate&apos; variable associated with the situation or </context>
<context position="7972" citStr="Candito and Kahane, 1998" startWordPosition="1268" endWordPosition="1271">er do not require the predicate and modifier distinctions, because they can explicitly specify the fates of any number of predicate variables in a tree&apos;s semantic representation. For simplicity, we will limit our discussion to only the two possibilities of predicative and modifier auxiliaries, using one predicate variable per tree. If we represent each such predicate-argument attachment as an arc in a directed graph, we can view the predicate-argument attachment structure of a derivation as a dependency graph, in much the same way as Candito and Kahane interpret the original derivation trees (Candito and Kahane, 1998a). More importantly, we can see that this definition predicts the predicateargument dependencies for sentences (1) and (2) to be isomorphic: 4:supposed-to 00:6-pressuposto-que 01:be-able-to 01:6-capaz-de 02:flY 02:voar even though their derivation trees are not. This is because the predicative auxiliary for é-capaz-de returns its predicate variable to the host tree for subsequent adjunctions, so the auxiliary tree for é-pressuposto-que can attach it as one of its arguments, just as if it had adjoined directly to the auxiliary, as supposed-to does in English. It is also important to note that </context>
<context position="12554" citStr="Candito and Kahane, 1998" startWordPosition="1996" endWordPosition="2000">resembles the stacked derivation tree for Candito and Kahane&apos;s example 5a, &amp;quot;Paul claims Mary said Peter left.&amp;quot; First, we adjoin 02 : i s - s up posed- to at node VP of /3 :be-able-to, which produces the dependency (is-supposed-to, 0,be-able-to). Then we adjoin th:be-able-to at node VP of aliy, which produces the dependency (be-able-to, 0,fly). The resulting dependencies are represented graphically in the dependency structure below: 00 :supposed-to 01 :be-able-to(0) 9521137(0) This example is relatively straightforward, simply reversing the direction of adjunction dependencies as described in (Candito and Kahane, 1998a), but this algorithm can transduce 91 the correct isomorphic dependency structure for the Portuguese derivation as well, similar to the distributed derivation tree in Candito and Kahane&apos;s example 5b, &amp;quot;Paul claims Mary seems to adore hot dogs,&amp;quot; (Rambow et al., 1995), where there is no edge corresponding to the dependency between the raising and bridge verbs: a:voar 01:6-capaz-de(VP) 02:é-pressuposto-que(S) We begin by adjoining th:e-capaz-de at node VP of a:voar, which produces the dependency (é-capaz-de, 0,voar), just as before. Then we adjoin 02:é-pressuposto-que at node S of a:voar. This t</context>
<context position="20426" citStr="Candito and Kahane, 1998" startWordPosition="3283" endWordPosition="3286">the leftmost (lowest) edge of the O&apos;s range in the scope enumeration, and last(0) to return the rightmost (highest) edge of the 0&apos;s range in the scope enumeration. • For each tree -y mapped from predicate 0 at scope i, introduce (-yo, f ir st(0),i +1, 0). • If (0, ar g(ry , 77), w) ED, try substitution of a into (av„ ROOT, T, f irst(w),last(w),w) (&apos;y0777 -1-1 -7 -7 -) 6Although this does not hold for certain relative clause elementary trees with wh-extractions as substitutions sites (since the wh-site is an argument of the main verb of the clause instead of the foot node), Candito and Kahane (Candito and Kahane, 1998b) suggest an alternative analysis which can be extended to TAG by adjoining the relative clause into its wh-word as a predicative adjunct, and adjoining the wh-word into the parent noun phrase as a modifier, so the noun phrase is treated as an argument of the wh-word rather than of the relative clause. 93 • If (11) , arg(0 , FOOT), x) ED, try modifier adjunction of /3 into -y: (00, ROOT, T, j, k, u.)) • If (11) , arg(i 3, FOOT), x) ED, try predicative adjunction of 3 into -y: (AP, ROOT, , j,k,w) (ry T, k, w) • Apply productions for nonterminal projection as in the transducer algorithm, propag</context>
</contexts>
<marker>Candito, Kahane, 1998</marker>
<rawString>Marie-Helene Candito and Sylvain Kahane. 1998b. Defining DTG derivations to get semantic graphs. In Proceedings of the TAG+4 Workshop, University of Pennsylvania, August.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Aravind Joshi</author>
<author>K Vijay-Shanker</author>
</authors>
<title>Compositional Semantics with Lexicalized TreeAdjoining Grammar (LTAG): How Much Underspecification is Necessary?</title>
<date>1999</date>
<booktitle>In Proceedings of the 2nd International Workshop on Computational Semantics.</booktitle>
<contexts>
<context position="4500" citStr="Joshi and Vijay-Shanker, 1999" startWordPosition="691" endWordPosition="694">erative power of TAG. Rambow, Wier and Vijay-Shanker themselves introduce D-Tree Grammar (Rambow et al., 1995) and Candito and Kahane introduce the DTG variant Graph Adjunction Grammar (Candito and Kahane, 1998b) in order to solve this problem using a derivation process that mirrors composition more directly, but both involve potentially significantly greater recognition complexity than TAG. for &amp;quot;supposed to be able to fly&amp;quot; 2 Overview Our solution is to retain ISTAG, but move the isomorphism restriction from the derivation structure to the predicate-argument attachment structure described in (Joshi and Vijay-Shanker, 1999). This structure represents the composition of semantic predicates for lexicalized elementary trees, each of which contains a &apos;predicate&apos; variable associated with the situation or entity that the predicate introduces, and a set of &apos;argument&apos; variables associated with the foot node and substitution sites in the original elementary tree. The predicates are composed by identifying the predicate variable in one predicate with an argument variable in another, so that the two variables refer to the same situation or entity. Composition proceeds from the bottom up on the derivation tree, with adjunct</context>
<context position="10746" citStr="Joshi and Vijay-Shanker, 1999" startWordPosition="1705" endWordPosition="1708">a derivation forest (Vijay-Shanker and Weir, 1993). Once the desired dependencies are obtained, the forest may be filtered to select a single most-preferred tree using statistics or rule-based selectional restrictions on those dependencies.4 For calculating dependencies, we define a function arg(777) to return the argument position associated with a substitution site or foot node 77 in elementary tree 7. Let a dependency be defined as a labeled arc (0,1,q,b), from predicate 0 to predicate 0 with label 1. • For each tree selected by 0, set the predicate variable of each anchor item to 0. 3See (Joshi and Vijay-Shanker, 1999) for a complete description. 4See (Schuler, 1998) for a discussion of statistically filtering TAG forests using semantic dependencies. • For each substitution of initial tree Geo with predicate variable co into -yo at node address 77, emit (0, arg(ry,71),w) • For each modifier adjunction of auxiliary tree )3,/, into tree 74, with predicate variable x, emit (0,arg(13, FOOT), x) and set the predicate variable of the composed item to x. • For each predicative adjunction of auxiliary tree Ap with predicate variable co into tree -y,/, with predicate variable x, emit (0, arg(0, FOOT), x) and set the</context>
</contexts>
<marker>Joshi, Vijay-Shanker, 1999</marker>
<rawString>Aravind Joshi and K. Vijay-Shanker. 1999. Compositional Semantics with Lexicalized TreeAdjoining Grammar (LTAG): How Much Underspecification is Necessary? In Proceedings of the 2nd International Workshop on Computational Semantics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Aravind K Joshi</author>
</authors>
<title>How much context sensitivity is necessary for characterizing structural descriptions: Tree adjoining grammars.</title>
<date>1985</date>
<booktitle>Natural language parsing: Psychological, computational and theoretical perspectives,</booktitle>
<pages>206--250</pages>
<editor>In L. Karttunen D. Dowty and A. Zwicky, editors,</editor>
<publisher>Cambridge University Press,</publisher>
<location>Cambridge, U.K.</location>
<contexts>
<context position="1307" citStr="Joshi, 1985" startWordPosition="184" endWordPosition="185">nal semantics to the problem of preserving semantic dependencies in Synchronous TAG translation (Shieber and Schabes, 1990; Abeille et al., 1990). In particular, we describe an algorithm to obtain the semantic dependencies on a TAG parse forest and construct a target derivation forest with isomorphic or locally non-isomorphic dependencies in 0(n7) time. 1 Introduction The primary goal of this paper is to solve the problem of preserving semantic dependencies in Isomorphic Synchronous Tree Adjoining Grammar (ISTAG) (Shieber, 1994; Shieber and Schabes, 1990), a variant of Tree Adjoining Grammar (Joshi, 1985) in which source and target elementary trees are assembled into isomorphic derivations. The problem, first described in Rambow, Wier and Vijay-Shanker (Rambow et al., 1995), stems from the fact that the TAG derivation structure — even using a flat adjunction of modifiers (Schabes and Shieber, 1994) — deviates from the appropriate dependency *The author would like to thank Karin Kipper, Aravind Joshi, Martha Palmer, Norm Badler, and the anonymous reviewers for their valuable comments. This work was partially supported by NSF Grant SBR8920230 and ARO Grant DAAH0404-94-GE-0426. structure in certa</context>
</contexts>
<marker>Joshi, 1985</marker>
<rawString>Aravind K. Joshi. 1985. How much context sensitivity is necessary for characterizing structural descriptions: Tree adjoining grammars. In L. Karttunen D. Dowty and A. Zwicky, editors, Natural language parsing: Psychological, computational and theoretical perspectives, pages 206-250. Cambridge University Press, Cambridge, U.K.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Anthony S Kroch</author>
</authors>
<title>Asymmetries in long distance extraction in a TAG grammar.</title>
<date>1989</date>
<booktitle>Alternative Conceptions of Phrase Structure,</booktitle>
<pages>66--98</pages>
<editor>In M. Baltin and A. Kroch, editors,</editor>
<publisher>University of Chicago Press.</publisher>
<marker>Kroch, 1989</marker>
<rawString>Anthony S. Kroch. 1989. Asymmetries in long distance extraction in a TAG grammar. In M. Baltin and A. Kroch, editors, Alternative Conceptions of Phrase Structure, pages 66-98. University of Chicago Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Igor Mel&apos;cuk</author>
</authors>
<title>Dependency syntax: theory and practice .</title>
<date>1988</date>
<publisher>State University of NY Press,</publisher>
<location>Albany.</location>
<contexts>
<context position="14359" citStr="Mel&apos;cuk, 1988" startWordPosition="2274" endWordPosition="2275"> and adjunction dependencies in transducing a sentence based on Candito and Kahane&apos;s example 5c, &amp;quot;That Paul has to stay surprised Mary,&amp;quot; in order to demonstrate how they interact.5 We begin with the derivation tree: a1 :surprise a2:stay(So) a4:Mary(Nip1) a3:Paul(NP0) 0:have-to(VP) 5We have replaced want to in the original example with have to in order to highlight the dependency structure and set aside any translation issues related to PRO control. As Candito and Kahane point out, this derivation tree does not match the dependency structure of the sentence as described in Meaning Text Theory (Mel&apos;cuk, 1988), because there is no edge in the derivation corresponding to the dependency between surprise and have-to (the necessity of Paul&apos;s staying is what surprises Mary, not his staying in itself). Using the above algorithm, however, we can still produce the desired dependency structure: 01:surprise 02:have-to(0) 5:Mary(1) 03 :stay(0) 04:Paul(0) by adjoining 0:have-to at node VP of a2:stay to produce a composed item with have-to as its predicate variable, as well as the dependency (have-to, 0,stay). When a2:stay substitutes at node So of a1 :surprise, the resulting dependency also uses the predicate </context>
</contexts>
<marker>Mel&apos;cuk, 1988</marker>
<rawString>Igor Mel&apos;cuk. 1988. Dependency syntax: theory and practice . State University of NY Press, Albany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Owen Rambow</author>
<author>Giorgio Satta</author>
</authors>
<title>Synchronous Models of Language.</title>
<date>1996</date>
<booktitle>In Proceedings of the 34th Annual Meeting of the Association for Computational Linguistics (ACL &apos;96).</booktitle>
<marker>Rambow, Satta, 1996</marker>
<rawString>Owen Rambow and Giorgio Satta. 1996. Synchronous Models of Language. In Proceedings of the 34th Annual Meeting of the Association for Computational Linguistics (ACL &apos;96).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Owen Rambow</author>
<author>David Weir</author>
<author>K Vijay-Shanker</author>
</authors>
<title>D-tree grammars.</title>
<date>1995</date>
<booktitle>In Proceedings of the 33rd Annual Meeting of the Association for Computational Linguistics (ACL &apos;95).</booktitle>
<contexts>
<context position="1479" citStr="Rambow et al., 1995" startWordPosition="207" endWordPosition="210"> describe an algorithm to obtain the semantic dependencies on a TAG parse forest and construct a target derivation forest with isomorphic or locally non-isomorphic dependencies in 0(n7) time. 1 Introduction The primary goal of this paper is to solve the problem of preserving semantic dependencies in Isomorphic Synchronous Tree Adjoining Grammar (ISTAG) (Shieber, 1994; Shieber and Schabes, 1990), a variant of Tree Adjoining Grammar (Joshi, 1985) in which source and target elementary trees are assembled into isomorphic derivations. The problem, first described in Rambow, Wier and Vijay-Shanker (Rambow et al., 1995), stems from the fact that the TAG derivation structure — even using a flat adjunction of modifiers (Schabes and Shieber, 1994) — deviates from the appropriate dependency *The author would like to thank Karin Kipper, Aravind Joshi, Martha Palmer, Norm Badler, and the anonymous reviewers for their valuable comments. This work was partially supported by NSF Grant SBR8920230 and ARO Grant DAAH0404-94-GE-0426. structure in certain cases. This can result in translation errors. For example, if we parse sentence (1), (1) X is supposed to be able to fly. using the trees in Figure 1, we get the followi</context>
<context position="3980" citStr="Rambow et al., 1995" startWordPosition="612" endWordPosition="615">propriate adjunction site: 1 0.-1:going(VP) 1 On-i:vai(VP) On:supp.(VP) This sort of non-local non-isomorphic transfer cannot be handled in a synchronous TAG that has an isomorphism restriction on derivation trees. On the other hand, we do not wish to return to the original non-local formulation of synchronous TAG (Shieber and Schabes, 1990) because the non-local inheritance of links on the derived tree is difficult to implement, and because the non-local formulation can recognize languages beyond the generative power of TAG. Rambow, Wier and Vijay-Shanker themselves introduce D-Tree Grammar (Rambow et al., 1995) and Candito and Kahane introduce the DTG variant Graph Adjunction Grammar (Candito and Kahane, 1998b) in order to solve this problem using a derivation process that mirrors composition more directly, but both involve potentially significantly greater recognition complexity than TAG. for &amp;quot;supposed to be able to fly&amp;quot; 2 Overview Our solution is to retain ISTAG, but move the isomorphism restriction from the derivation structure to the predicate-argument attachment structure described in (Joshi and Vijay-Shanker, 1999). This structure represents the composition of semantic predicates for lexicaliz</context>
<context position="12821" citStr="Rambow et al., 1995" startWordPosition="2039" endWordPosition="2042">-to at node VP of aliy, which produces the dependency (be-able-to, 0,fly). The resulting dependencies are represented graphically in the dependency structure below: 00 :supposed-to 01 :be-able-to(0) 9521137(0) This example is relatively straightforward, simply reversing the direction of adjunction dependencies as described in (Candito and Kahane, 1998a), but this algorithm can transduce 91 the correct isomorphic dependency structure for the Portuguese derivation as well, similar to the distributed derivation tree in Candito and Kahane&apos;s example 5b, &amp;quot;Paul claims Mary seems to adore hot dogs,&amp;quot; (Rambow et al., 1995), where there is no edge corresponding to the dependency between the raising and bridge verbs: a:voar 01:6-capaz-de(VP) 02:é-pressuposto-que(S) We begin by adjoining th:e-capaz-de at node VP of a:voar, which produces the dependency (é-capaz-de, 0,voar), just as before. Then we adjoin 02:é-pressuposto-que at node S of a:voar. This time, however, we must observe the predicate variable of the chart item for a:voar which was updated in the previous adjunction, and now references é-capaz-de instead of voar. Because the transduction rule for adjunction uses the predicate variable of the parent inste</context>
</contexts>
<marker>Rambow, Weir, Vijay-Shanker, 1995</marker>
<rawString>Owen Rambow, David Weir, and K. Vijay-Shanker. 1995. D-tree grammars. In Proceedings of the 33rd Annual Meeting of the Association for Computational Linguistics (ACL &apos;95).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yves Schabes</author>
<author>Stuart M Shieber</author>
</authors>
<title>An alternative conception of tree-adjoining derivation.</title>
<date>1994</date>
<journal>Computational Linguistics,</journal>
<pages>20--491</pages>
<contexts>
<context position="1606" citStr="Schabes and Shieber, 1994" startWordPosition="229" endWordPosition="232"> with isomorphic or locally non-isomorphic dependencies in 0(n7) time. 1 Introduction The primary goal of this paper is to solve the problem of preserving semantic dependencies in Isomorphic Synchronous Tree Adjoining Grammar (ISTAG) (Shieber, 1994; Shieber and Schabes, 1990), a variant of Tree Adjoining Grammar (Joshi, 1985) in which source and target elementary trees are assembled into isomorphic derivations. The problem, first described in Rambow, Wier and Vijay-Shanker (Rambow et al., 1995), stems from the fact that the TAG derivation structure — even using a flat adjunction of modifiers (Schabes and Shieber, 1994) — deviates from the appropriate dependency *The author would like to thank Karin Kipper, Aravind Joshi, Martha Palmer, Norm Badler, and the anonymous reviewers for their valuable comments. This work was partially supported by NSF Grant SBR8920230 and ARO Grant DAAH0404-94-GE-0426. structure in certain cases. This can result in translation errors. For example, if we parse sentence (1), (1) X is supposed to be able to fly. using the trees in Figure 1, we get the following derivation:1 a:fly 1 th:be-able-to(VP) 02 : is-supposed-to (VP ) with the auxiliary is-supposed-to adjoining at the VP to pr</context>
<context position="5998" citStr="Schabes and Shieber, 1994" startWordPosition="933" endWordPosition="936">variable of the tree it substitutes into. Whenever an auxiliary tree is adjoined, the predicate variable of the tree it adjoins into is identified in the composed structure with one of its own argument variables. In cases of adjunction, an auxiliary tree&apos;s semantics can also specify which variable will become the predicate variable of the composed structure for use in subsequent adjunctions at higher adjunction sites: a modifier auxiliary will return the host tree&apos;s original predicate variable, and a predicative auxiliary will return its own predicate variable.2 Since the traversal must 2See (Schabes and Shieber, 1994) for definitions of modifier and predicative auxiliaries. a:fly a:voar :capaz(VP) /37,:press.(S) 1 1 [31. :able(VP) 1 89 VP Vo VP is Vo VP supposed Vo VP* to Vo Vo pressuposto Vo S* que VP VP Vo VP Vo VP be Vo VP 6 Vo VP able Vo VP* capaz Vo VP* de NP,I, VP NP,l, VP Vo Vo fly voar to Figure 2: Synchronous tree pairs for &amp;quot;supposed to be able to fly&amp;quot; proceed from the bottom up, the attachment of predicates to arguments is neither destructive nor underspecified at any stage in the interpretation. For example, assume the initial tree a:fly has a predicate variable .91, representing the situation o</context>
<context position="10033" citStr="Schabes and Shieber, 1994" startWordPosition="1584" endWordPosition="1587">ttachment structure captures a sentence&apos;s semantic dependencies, then in order to preserve semantic dependencies in synchronous TAG translation, we will need to obtain this structure from a source derivation and then construct a target derivation with an isomorphic structure. The first algorithm we present obtains semantic dependencies for derivations by keeping track of an additional field in each chart item during parsing, corresponding to the predicate variable from Section 2. Other than the additional field, the algorithm remains essentially the same as the parsing algorithm described in (Schabes and Shieber, 1994), so it can be applied as a transducer during recognition, or as a post-process on a derivation forest (Vijay-Shanker and Weir, 1993). Once the desired dependencies are obtained, the forest may be filtered to select a single most-preferred tree using statistics or rule-based selectional restrictions on those dependencies.4 For calculating dependencies, we define a function arg(777) to return the argument position associated with a substitution site or foot node 77 in elementary tree 7. Let a dependency be defined as a labeled arc (0,1,q,b), from predicate 0 to predicate 0 with label 1. • For e</context>
</contexts>
<marker>Schabes, Shieber, 1994</marker>
<rawString>Yves Schabes and Stuart M. Shieber. 1994. An alternative conception of tree-adjoining derivation. Computational Linguistics, 20(491-124.</rawString>
</citation>
<citation valid="true">
<authors>
<author>William Schuler</author>
</authors>
<title>Expoiting semantic dependencies in parsing.</title>
<date>1998</date>
<booktitle>Proceedings of the TAG+4 Workshop.</booktitle>
<contexts>
<context position="10795" citStr="Schuler, 1998" startWordPosition="1714" endWordPosition="1715">red dependencies are obtained, the forest may be filtered to select a single most-preferred tree using statistics or rule-based selectional restrictions on those dependencies.4 For calculating dependencies, we define a function arg(777) to return the argument position associated with a substitution site or foot node 77 in elementary tree 7. Let a dependency be defined as a labeled arc (0,1,q,b), from predicate 0 to predicate 0 with label 1. • For each tree selected by 0, set the predicate variable of each anchor item to 0. 3See (Joshi and Vijay-Shanker, 1999) for a complete description. 4See (Schuler, 1998) for a discussion of statistically filtering TAG forests using semantic dependencies. • For each substitution of initial tree Geo with predicate variable co into -yo at node address 77, emit (0, arg(ry,71),w) • For each modifier adjunction of auxiliary tree )3,/, into tree 74, with predicate variable x, emit (0,arg(13, FOOT), x) and set the predicate variable of the composed item to x. • For each predicative adjunction of auxiliary tree Ap with predicate variable co into tree -y,/, with predicate variable x, emit (0, arg(0, FOOT), x) and set the predicate variable of the composed item to w. • </context>
</contexts>
<marker>Schuler, 1998</marker>
<rawString>William Schuler. 1998. Expoiting semantic dependencies in parsing. Proceedings of the TAG+4 Workshop.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
<author>Yves Schabes</author>
</authors>
<title>Synchronous tree adjoining grammars.</title>
<date>1990</date>
<booktitle>In Proceedings of the 13th International Conference on Computational Linguistics (COLING &apos;90),</booktitle>
<location>Helsinki, Finland,</location>
<contexts>
<context position="817" citStr="Shieber and Schabes, 1990" startWordPosition="106" endWordPosition="109">bstract Rambow, Wier and Vijay-Shanker (Rambow et al., 1995) point out the differences between TAG derivation structures and semantic or predicateargument dependencies, and Joshi and VijayShanker (Joshi and Vijay-Shanker, 1999) describe a monotonic compositional semantics based on attachment order that represents the desired dependencies of a derivation without underspecifying predicate-argument relationships at any stage. In this paper, we apply the Joshi and Vijay-Shanker conception of compositional semantics to the problem of preserving semantic dependencies in Synchronous TAG translation (Shieber and Schabes, 1990; Abeille et al., 1990). In particular, we describe an algorithm to obtain the semantic dependencies on a TAG parse forest and construct a target derivation forest with isomorphic or locally non-isomorphic dependencies in 0(n7) time. 1 Introduction The primary goal of this paper is to solve the problem of preserving semantic dependencies in Isomorphic Synchronous Tree Adjoining Grammar (ISTAG) (Shieber, 1994; Shieber and Schabes, 1990), a variant of Tree Adjoining Grammar (Joshi, 1985) in which source and target elementary trees are assembled into isomorphic derivations. The problem, first des</context>
<context position="3703" citStr="Shieber and Schabes, 1990" startWordPosition="570" endWordPosition="573">slation in sentence (2), (2) E pressuposto que X é capaz de voar. is not isomorphic to the source. Worse, this non-isomorphism is unbounded, because the bridge verb pressuposto may have to migrate across any number of intervening raising verbs to find an ancestor that contains an appropriate adjunction site: 1 0.-1:going(VP) 1 On-i:vai(VP) On:supp.(VP) This sort of non-local non-isomorphic transfer cannot be handled in a synchronous TAG that has an isomorphism restriction on derivation trees. On the other hand, we do not wish to return to the original non-local formulation of synchronous TAG (Shieber and Schabes, 1990) because the non-local inheritance of links on the derived tree is difficult to implement, and because the non-local formulation can recognize languages beyond the generative power of TAG. Rambow, Wier and Vijay-Shanker themselves introduce D-Tree Grammar (Rambow et al., 1995) and Candito and Kahane introduce the DTG variant Graph Adjunction Grammar (Candito and Kahane, 1998b) in order to solve this problem using a derivation process that mirrors composition more directly, but both involve potentially significantly greater recognition complexity than TAG. for &amp;quot;supposed to be able to fly&amp;quot; 2 Ove</context>
<context position="8711" citStr="Shieber and Schabes, 1990" startWordPosition="1379" endWordPosition="1382">1) and (2) to be isomorphic: 4:supposed-to 00:6-pressuposto-que 01:be-able-to 01:6-capaz-de 02:flY 02:voar even though their derivation trees are not. This is because the predicative auxiliary for é-capaz-de returns its predicate variable to the host tree for subsequent adjunctions, so the auxiliary tree for é-pressuposto-que can attach it as one of its arguments, just as if it had adjoined directly to the auxiliary, as supposed-to does in English. It is also important to note that Joshi and Vijay-Shanker&apos;s definition of TAG compositional semantics differs from that of Shieber 90 and Schabes (Shieber and Schabes, 1990) using Synchronous TAG, in that the former preserves the scope ordering of predicative adjunctions, which may be permuted in the latter, altering the meaning of the sentence.3 It is precisely this scope-preserving property we hope to exploit in our formulation of a dependency-based isomorphic synchronous TAG in the next two sections. However, as Josh i and Vijay-Shanker suggest, the proper treatment of synchronous translation to logical form may require a multicomponent Synchronous TAG analysis in order to handle quantifiers, which is beyond the scope of this paper. For this reason, we will fo</context>
</contexts>
<marker>Shieber, Schabes, 1990</marker>
<rawString>Stuart M. Shieber and Yves Schabes. 1990. Synchronous tree adjoining grammars. In Proceedings of the 13th International Conference on Computational Linguistics (COLING &apos;90), Helsinki, Finland, August.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
</authors>
<title>Restricting the weakgenerative capability of synchronous tree adjoining grammars.</title>
<date>1994</date>
<journal>Computational Intelligence,</journal>
<volume>10</volume>
<issue>4</issue>
<contexts>
<context position="1228" citStr="Shieber, 1994" startWordPosition="170" endWordPosition="171">ge. In this paper, we apply the Joshi and Vijay-Shanker conception of compositional semantics to the problem of preserving semantic dependencies in Synchronous TAG translation (Shieber and Schabes, 1990; Abeille et al., 1990). In particular, we describe an algorithm to obtain the semantic dependencies on a TAG parse forest and construct a target derivation forest with isomorphic or locally non-isomorphic dependencies in 0(n7) time. 1 Introduction The primary goal of this paper is to solve the problem of preserving semantic dependencies in Isomorphic Synchronous Tree Adjoining Grammar (ISTAG) (Shieber, 1994; Shieber and Schabes, 1990), a variant of Tree Adjoining Grammar (Joshi, 1985) in which source and target elementary trees are assembled into isomorphic derivations. The problem, first described in Rambow, Wier and Vijay-Shanker (Rambow et al., 1995), stems from the fact that the TAG derivation structure — even using a flat adjunction of modifiers (Schabes and Shieber, 1994) — deviates from the appropriate dependency *The author would like to thank Karin Kipper, Aravind Joshi, Martha Palmer, Norm Badler, and the anonymous reviewers for their valuable comments. This work was partially supporte</context>
<context position="5998" citStr="Shieber, 1994" startWordPosition="935" endWordPosition="936">the tree it substitutes into. Whenever an auxiliary tree is adjoined, the predicate variable of the tree it adjoins into is identified in the composed structure with one of its own argument variables. In cases of adjunction, an auxiliary tree&apos;s semantics can also specify which variable will become the predicate variable of the composed structure for use in subsequent adjunctions at higher adjunction sites: a modifier auxiliary will return the host tree&apos;s original predicate variable, and a predicative auxiliary will return its own predicate variable.2 Since the traversal must 2See (Schabes and Shieber, 1994) for definitions of modifier and predicative auxiliaries. a:fly a:voar :capaz(VP) /37,:press.(S) 1 1 [31. :able(VP) 1 89 VP Vo VP is Vo VP supposed Vo VP* to Vo Vo pressuposto Vo S* que VP VP Vo VP Vo VP be Vo VP 6 Vo VP able Vo VP* capaz Vo VP* de NP,I, VP NP,l, VP Vo Vo fly voar to Figure 2: Synchronous tree pairs for &amp;quot;supposed to be able to fly&amp;quot; proceed from the bottom up, the attachment of predicates to arguments is neither destructive nor underspecified at any stage in the interpretation. For example, assume the initial tree a:fly has a predicate variable .91, representing the situation o</context>
<context position="10033" citStr="Shieber, 1994" startWordPosition="1586" endWordPosition="1587">ructure captures a sentence&apos;s semantic dependencies, then in order to preserve semantic dependencies in synchronous TAG translation, we will need to obtain this structure from a source derivation and then construct a target derivation with an isomorphic structure. The first algorithm we present obtains semantic dependencies for derivations by keeping track of an additional field in each chart item during parsing, corresponding to the predicate variable from Section 2. Other than the additional field, the algorithm remains essentially the same as the parsing algorithm described in (Schabes and Shieber, 1994), so it can be applied as a transducer during recognition, or as a post-process on a derivation forest (Vijay-Shanker and Weir, 1993). Once the desired dependencies are obtained, the forest may be filtered to select a single most-preferred tree using statistics or rule-based selectional restrictions on those dependencies.4 For calculating dependencies, we define a function arg(777) to return the argument position associated with a substitution site or foot node 77 in elementary tree 7. Let a dependency be defined as a labeled arc (0,1,q,b), from predicate 0 to predicate 0 with label 1. • For e</context>
</contexts>
<marker>Shieber, 1994</marker>
<rawString>Stuart M. Shieber. 1994. Restricting the weakgenerative capability of synchronous tree adjoining grammars. Computational Intelligence, 10(4).</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Vijay-Shanker</author>
<author>D J Weir</author>
</authors>
<title>The use of shared forests in tree adjoining grammar parsing.</title>
<date>1993</date>
<booktitle>In Proceedings of EA CL &apos;93,</booktitle>
<pages>384--393</pages>
<contexts>
<context position="10166" citStr="Vijay-Shanker and Weir, 1993" startWordPosition="1607" endWordPosition="1610">G translation, we will need to obtain this structure from a source derivation and then construct a target derivation with an isomorphic structure. The first algorithm we present obtains semantic dependencies for derivations by keeping track of an additional field in each chart item during parsing, corresponding to the predicate variable from Section 2. Other than the additional field, the algorithm remains essentially the same as the parsing algorithm described in (Schabes and Shieber, 1994), so it can be applied as a transducer during recognition, or as a post-process on a derivation forest (Vijay-Shanker and Weir, 1993). Once the desired dependencies are obtained, the forest may be filtered to select a single most-preferred tree using statistics or rule-based selectional restrictions on those dependencies.4 For calculating dependencies, we define a function arg(777) to return the argument position associated with a substitution site or foot node 77 in elementary tree 7. Let a dependency be defined as a labeled arc (0,1,q,b), from predicate 0 to predicate 0 with label 1. • For each tree selected by 0, set the predicate variable of each anchor item to 0. 3See (Joshi and Vijay-Shanker, 1999) for a complete desc</context>
</contexts>
<marker>Vijay-Shanker, Weir, 1993</marker>
<rawString>K. Vijay-Shanker and D.J. Weir. 1993. The use of shared forests in tree adjoining grammar parsing. In Proceedings of EA CL &apos;93, pages 384-393.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>