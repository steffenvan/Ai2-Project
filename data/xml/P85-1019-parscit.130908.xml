<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.867506">
Semantic Caseframe Parsing and Syntactic Generality
</title>
<note confidence="0.704533">
Philip J. Hayes. Peggy M. Andersen. and Scott Safier
Carnegie Group Incorporated
Commerce Court at Station Square
Pittsburgh. PA 15219 USA
</note>
<sectionHeader confidence="0.958491" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.998996923076923">
We have implemented a restricted domain parser called
Plume. 7&amp;quot; Building on previous work at Carnegie-Mellon
University e.g. [4. 5, 91, Plume s approacri to parsing IS
based on semantic caseframe Instantiation This nas the
advantages of efficiency on grammatical Input, and
robustness in the face of ungrammatical input While Plume
is well adapted to simple declarative and imperative
utterances, it handles passives relative clauses and
interrogatives in an ad hoc manner leading to patchy
syntactic coverage This paper outlines Plume as it
currently exists and describes our detailed design for
extending Plume to handle passives relative clauses, and
interrogatives in a general manner
</bodyText>
<sectionHeader confidence="0.948792" genericHeader="method">
1. The Plume Parser
</sectionHeader>
<bodyText confidence="0.993869352941176">
Recent work at Carnegie-Mellon University e.g. 14. 5[ has
shown semantic caseframe instantiation to be a highly robust
and efficient method of parsing restricted domain input. In
this approach to parsing. a caseframe grammar contains the
domain-specific semantic information, and- the parsing
program contains general syntactic knowledge. Input is
mapped onto the grammar using this built-in syntactic
knowledge We have chosen this approach for Plume7m
commercial restricted domain parser. because of its
advantages in efficiency and robustness.
Let us take a simple example from a natural language
interface. called NLVMS. that we are developing under a
contract with Digital Equipment Corporation NLVMS is an
interface to Digital&apos;s VMS operating system for &apos;/AX
computers.2 The Plume grammar for this interface contains
the following semantic caseframe2 corresponding to the copy
command of VMS:
</bodyText>
<figure confidence="0.967310769230769">
(*copy*
:cf-type clausal
:header copy
:cases
(file-to-copy
:filler *file*
:positional Direct-Object)
(source
:filler *directory*
:marker from I out of)
(destination
:filler *file* I *directory*
:marker to I into I in I onto)
</figure>
<bodyText confidence="0.979226636363636">
This defines a caseframe. called &apos;copy with three cases:
file-to-copy, source. and destination The file-to-copy case is
filled by an obiect of type • file • and appears in the input
as a direct obiect Source is filled by a &apos;directory&apos; and
should appear in the input as a prepositional phrase
preceded or marked by the prepositions &amp;quot;from&apos; or &apos;out of&amp;quot;
Destination is filled by a file • or •directory • and is marked
by &amp;quot;to&amp;quot;. &amp;quot;into&amp;quot;. or &amp;quot;onto&amp;quot; Finally the copy command itself
is recognized by the header word indicated above (by
header) as &amp;quot;copy&amp;quot;.
Using this caseframe. Plume can parse inputs like:
</bodyText>
<footnote confidence="0.417184928571429">
I More prectsely. PlumeTM iS the nAme trie runanne Ivstem Copy too Oar out of [xf into (yr&apos;
associated Arlin Language Craft TM. an integrated envuonment in, Inc From [xJ to (yl copy too oar
Oevelopment of natural language interfaces r he Plume parser Nnich too oar copy from [xl to 1.y1
translates Engush input into casetrame instances. is a mator i:omponeni
ot this run-time System The other inaliar -omponent translates the
caSeframe instances into application specific ianguages. in adomon to
the Plume run-time system. Language Craft inc&apos;ucles grammar
development tools incluchng sum:hated editor .onct tracing and
Pertormance measurement mois eoln Plume Ina Language Craft are
products of Carnegie Groin) arm are ri•reritly m re-armied release
Plume .no Language Craft ire if aaernarks .arneote t3roup
incorporated
2VMS and VAX are trademarks or Digital Equipment Corporation
3ThiS iS 1 simplthed ...ersion ine a:et, tii .1..•■■ail,, 0 me grammar.
</footnote>
<page confidence="0.995587">
153
</page>
<bodyText confidence="0.944892434782608">
In essence. Plume&apos;s parsing algorithm is to find a caseframe
header. in this case &amp;quot;copy&amp;quot;. and use the associated
caseframe, &apos;copy&apos;. to guide the rest of the parse. Once
the caseframe has been identified. Plume looks for case
markers, and then parses the associated case filler directly
following the marker Plume also tries to parse positionally
specified cases, like direct object. in the usual position in
the sentence - immediately following the header for direct
object. Any input not accounted for at the end of this
procedure is matched against any unfilled CaSes, so that
cases that are supposed to be marked can be recognized
without their markers and positionally indicated cases can be
recognized out of their usual positions. This flexible.
interpretive style of matching caseframes against the input
allows Plume to deal with the kind of variation in word order
illustrated in the examples above.
The above examples implied there was some method to
recognize files and directories. They showed only atomic
file and directory descriptions. but Plume can also deal with
more complex obiect descriptions. In fact, in Plume
grammars. objects as well as actions can be described by
caseframes. For instance here is the caseframes used to
define a file for NLVMS.
</bodyText>
<figure confidence="0.980690846153846">
( *f i le*
:.cf-type nominal
:header file &apos;
!name ?(%period !extension)
:cases
(name
:assignedp !name)
(extension
:assignedp !extension
:marker written in
:adjective &lt;language&gt;
:filler &lt;language&gt;)
(creator
:filler *person*
:marker created by)
(directory
:filler *directory*
:marker in)
4 n rho? syntax used wen VMS. cnrectones are $nd.Cated Ov SQUare
nrackers.
autonlan, ally e.&apos;nqn.zes letenn.ners .01:1 n..aonners aSSCo71 at ed
■unnInal aierra■nes
This caseframe allows Plume to recognize file descriptions
like:6
100
100. bar
</figure>
<bodyText confidence="0.948356107142857">
The file created by John
The Fortran file in pt] created by John
The caseframe notation and parsing algorithm used here are
very similar to those described above for clause level input.
The significant differences are additions related to the
:adjective and :assignedp attributes of some of the cases
above. While Plume normally only looks for fillers after the
header in nominal caseframes an adjective attribute of a
slot tells Plume that the slot filler may appear before the
header.
An :assignedp attribute allows cases to be filled through
recognition of a header. This is generally useful for proper
names, such as foo and foo.bar. In the example above.
the second alternative header contains iwo &apos;,enables &apos;name
and &apos;extension. that can each match any single Nord. The
question mark indicates optionaiity. so that the header can
be either a single word or a word followed by a period and
another word. The first word is assigned to the /enable
&apos;name, and the second if it is mere to the /enable
&apos;extension if &apos;name or &apos;extension are matched while
recognizing a file header, their values are placed in the
name and extension cases of -fite•
With the above modifications Plume can parse nominal
caseframes using the same algorithm that it uses for clausal
caseframes that account for complete sentences. However
there are some interactions between the two levels of
parsing. In particular, there can be ambiguity about where
to attach marked cases. For instance. in:
</bodyText>
<subsubsectionHeader confidence="0.569195">
Copy the Fortran file in (xl to [yl
</subsubsectionHeader>
<bodyText confidence="0.997704777777778">
&amp;quot;in N.&amp;quot; could either fill the directory Case of the file
described as &amp;quot;the fortran file&apos; or could fill the destination
case of the whole copy command The second
interpretation does not work at the global level because the
only place to put &amp;quot;to bil&amp;quot; is in that same destination case
However, at the time the file description is parsed. this
information is not available, and so both possible
attachments must be considered In general. if Plume is
able to fill a case of a nominal caseframe from a
</bodyText>
<page confidence="0.998808">
154
</page>
<bodyText confidence="0.9932634">
prepositional phrase, it also splits off an alternative parse in
which that attachment is not made. When all input haS
been parsed. PluMe retains only those parses that succeed
at the global level, i.e.. consume all of the input. Others
are discarded.
The current implementation of Plume is based on the
nominal and clausal level caseframe instantiation algorithms
described above. Using these algorithms and a restricted
domain grammar of caseframes like the ones snown above.
Plume can parse a wide variety of imperative and
declarative sentences relevant to that domain. However.
there remain significant gaps in its coverage. Interrogatives
are not handled at all passives are covered only if they
are explicitly specified in the grammar and relative clauses
can only be handled by pretending they are a form of
prepositional phrase
The regular and predictable relationship between simple
statements, questions and relative clauses and between
active and passive sentences is ,vell known A parser which
purports to interpret a doinain specific language specification
using a built-in knowledge of syntax. should account for this
regularity in a general way The current implementation of
Plume has no mechanism for doing this. Each individual
possibility for questions. relative clauses and passives must
be explicitly specified in the grammar For Instance, to
handle reduced relative clauses as in &amp;quot;the file created by
Jim&amp;quot; &amp;quot;created by&amp;quot; is listed as a case marker (compound
preposition) in the creator slot of file. marking a description
of the creator To handle full relatives the case marker
must be Specified as something like &amp;quot;&apos;?twhich &lt;be &gt; )
created by&apos;&apos;.8 While this allows Plume to recognize the file
which was created by Jim&amp;quot;. &amp;quot;the file created by Jim&amp;quot;. or
even &amp;quot;the file created by Jim on Monday it breaks down
on something like &amp;quot;the file created on Monday by Jim&apos;
because the case marker &amp;quot;created by&apos; is no longer a unit.
Moreover using the current techniques. Plume s ability to
recognize the above inputs is completely unrelated to its
ability to recognize inputs like:
the file Jim created on Monoay
the person that the file was created by on Monday
the day on which Jim created me NIE
If an interface could recognize any of these examples It
might seem unreasonable to a user that it could not
recognize all of the others. Moreover given any of the
above examples. a user might reasonably expect recognition
of related sentence level inputs like
Create the tile on Monday&apos;
Jim created the tile on Monday
Did Jim create the tile on Monday.&apos;
Was the tile created by Jim on Monday&apos;
Who created the tile on Monday&apos;,
What day was the tile created on?
The current implementation of Plume has no means of
guaranteeing such regularity of coverage. Of course. this
problem of patchy syntactic coverage is not new for
restricted domain parsers. The lack of syntactic generality
of the original semantic grammar [31 for the Sophie system •
121 led to the concept of cascaded ATNs 001 and the
RUS parser (11. A progression with similar goals occurred
from the LIFER system 191 to TEAM [6] and KLAUS 171.
The basic obstacle to achieving syntactic generality in
these network-based approaches was the way syntactic and
Semantic information was mixed together in the grammar
networks. The solutions. therefore. rested on separating the
syntactic and semantic information. Plume already
incorporates just the separation of syntax and semantics
necessary for syntactic generality general syntactic
knowledge resides in the parser while semantic information
resides in the grammar This suggests that syntactic
generality in a system like Plume can be achieved by
■mOroying the parser s casetrame ■nstantiation algorithms
.vithout any maior changes to grammar content ,n terms of
the above examples Involving :reate • :1 suggests we can
use a single &apos;create&apos; casefraine to nandle all the exampleS
We simply need to provide suitable extensions to the
existing caseframe nstantiahon algorithms In the next
rhe current ,moiernentanon of Ph ”ne .:,,nta.ns a remo.)rarv rietn.)cl 01
■landfing ,,terrngatives. .-,,,,Vie&apos;&apos;&apos; ..aseliame
- 0. , ■•••-r:;
section we present a detailed design for such extensions
</bodyText>
<sectionHeader confidence="0.660773" genericHeader="method">
2. Providing Plume with Syntactic Generality
</sectionHeader>
<bodyText confidence="0.982971">
As described above. Plume can currently use clausal .
</bodyText>
<page confidence="0.996101">
155
</page>
<bodyText confidence="0.996645555555555">
caseframes only to recognize single clause imperative and
declarative utterances in the active voice This section
describes our design for extending Plume so that relative
and interrogative uses of clausal caseframes in passive as
well as active voice can also be recognized from the same
information.
We will present our general design by showing how it
operates for the following &apos;create caseframe in the context
of NLVMS:
</bodyText>
<figure confidence="0.990553538461538">
(*create*
:cf-type clausal
:header &lt;create&gt;
:cases
(creator
:filler *person*
:positional Subject)
(createe
:filler *file*
:positional Direct-Object)
(creation-date
:filler *date*
:marker on)
</figure>
<bodyText confidence="0.987780545454546">
Note that symbols in angle brackets represent non-terminals
in a context-free grammar (recognized by Plume using
pattern matching technigueSi in the caseframe definition
above &lt; create &gt; matches all morphological variants of the
verb &apos;create&apos; including &amp;quot;create &apos;creates &amp;quot;Created&amp;quot; and
&apos;creating&apos; ithough not compound lenses like ,s creating&apos; -
see below). Using the existing Plume Piould only allow
US to recognize simple imperatives and active leciaratives
iike•
Create to bar on Monday
Jim created to oar un Monday
</bodyText>
<subsectionHeader confidence="0.73711">
2.1 Passives
</subsectionHeader>
<bodyText confidence="0.990368523809524">
Plume recognizes passive sentences through its processing
of the /erb cluster e the main verb plus tne sequence of
modal and auxiliary ierb immediately preCeding it. Once
the main verb has been located a special verb cluster
processing mechanism reads the verb cluster and determines
from it whether the sentence is active or passive The
parser records this information in a special case called
&amp;quot;%voice&amp;quot;.
If a sentence is found to be active the standard parsing
algorithm described above is used if it is found to be
passive, the standard algorithm is used with the modification
that the parser looks for the direct object or the indirect
object I° in the subject position, and for the subject as an
optional marked case with the case marker &amp;quot;by&amp;quot;. Thus,
given the •create • caseframe above, the following passive
sentences could be handled as well as their active
counterparts.
Foo bar was created oy Jim
Fop Oar could have oeeh reared cli/ Jim
Foo oar is being created Jim
Foo bar was createo dn Monday
</bodyText>
<subsectionHeader confidence="0.563712">
2.2. Relative clauses
</subsectionHeader>
<bodyText confidence="0.956308">
The detailed design presented below allows Plume to use
the •create • caseframe to parse nominals like:
the file Jim created on Monday
the person mat the tile was created oy on Monday
the day on which Jim created the tile
To do this, we introduce the concept of a relative case A
relative case is a link back froni the caseframes for the
objects that fill the cases of a clausal caseframe to that
clausal caseframe. A grammar preprocessor generates a
relative case automatically from each case of a clausal
caseframe. associating It with the nominal caseframe that
fills the case in me clausal caseframe. Relative cases do
not need to be specified by the grammar writer. For
instance, a relative case is generated from the createe case
of &apos;create&apos; and included in the &apos;file&apos; caseframe. it looks
like this:
(*file*
(:relative-cf *create*
:relative-case-name createe
:marker &lt;create&gt;
</bodyText>
<footnote confidence="0.970426166666667">
9Ii also determines the tense ca the sentence and •vhetner s
affirmative or negative
i°Sn &apos;I mere .5 a Case •vith a positional •nairect.obieCt slot Me
)biect .s allowed to OaSSivize Ne •:aii thus iaiderstana ientences
•Mar,/ Nas tpven a booit &apos; ,foin a &apos;give&apos; .ase.isme bain
ire&apos;.nie,-1 and an ...direct thiect • ase
</footnote>
<page confidence="0.998575">
156
</page>
<bodyText confidence="0.97220146875">
Note that :marker is the same as :header of &apos;create&apos;
Similar relative cases are generated in the •person&apos;
caseframe for the creator caSe, and in the &apos;date&amp;quot;
caseframe for the creation-date caSe, differing only in
:relative-case-name.
Relative cases are used similarly to the ordinary marked
cases of nominal caseframes. In essence. if the parser IS
parsing a nominal caseframe &apos;and finds the marker of one
of its relative cases. then it tries to instantiate the :relative-
cf. It performs this instantiation in the same way as if the
relative-cf were a top-level clauSal caseframe and the word
that matched the header ..vere Its main verb. An important
difference is that it never tries to fill the case &amp;quot;those name
is given by relative-case-name. That case is filled by the
nominal caseframe which contains the relative case For
instance. suppose the parser is trying to process.
The file Jim created on Monday
And suppose that it has already located &amp;quot;file&apos; and used
that to determine it is instantiating a &apos;file&apos; nominal
caseframe It is able to match (against &amp;quot;created&amp;quot; i the
:marker of the relative caseframe of •flie • shown above. It
then tries to instantiate the relative.cf &apos;create&apos; using its
standard techniques except that it does not try to fill
createe. the case of &apos;create&apos; specified as the relative-case-
name. This instantiation succeeds with &amp;quot;Jim- going into
creator. and &amp;quot;on Monday&amp;quot; being used to fill creation-date
The parser then uses (a pointer to the nominal caseframe
currently being instantiated. &apos;file&apos; to fill createe. the
:relative-case-name case of •create&apos; and the newly created
instance of •create • is attached to this instance of •file • as
a modifier
More completely. Plume&apos;s algorithm for relative clauses is:
</bodyText>
<listItem confidence="0.846159941176471">
1. When processing a nominal caseframe. Plume scans
for the :markers of the relative cases of the nominal
caseframe at the same time as It scans for the
regular case markers of that nominal caseframe
2. If it finds a :marker of a relative case, it tries to
inst4ntiate the relative-cf lust as though it were the
top-level clausal casefrarne and the header were its
main verb, except that:
a. it never looks any further left in the inout than
the header of the nomiral caseframe or if it
has already parsed any other Oost-rominal
cases of the nominal caseframe no further left
than the right hand end of them
b. it consumes, but otherwise ignores any relative
pronouns who dyrti.m, which that; that
immediately precede the segment used to
instantiate the relative-of Tnis means that
</listItem>
<bodyText confidence="0.920324323529412">
words. including &amp;quot;that&amp;quot; will be accounted tor ri
the tile that Jim createc on Monday&amp;quot;
C. it does not try to fill the case specified by the
relative-case-name in the relative-cf: instead
this case is filled by (a pointer to) the original
nominal caseframe instance:
d. if the relative-case-name specifies a marked
case rather than a positional one in the
relative-cf then its case marker can be
consumed, but otherwise ignored, during
instantiation of the relative-cf This allows us
to deal with &amp;quot;on&apos; ;n &apos;tne cate Jim created the
tile on&amp;quot; or -the Care un which Jim created the
tile&apos;
3 Passive relative clauses le g. &amp;quot;the file that was
created on Monday&amp;quot;) can generally be handled using
the same mechanisms used for passives at the main
clause level However, in relative clauses. Passives
may sometimes be reduced by omitting the usual
auxiliary verb to be land the relative pronoun) as in:
the tile created on Monday
To account for such reduced relative clauses, the
verb cluster processor will produce appropriate
additional readings of the verb clusters in relative
clauses for which the relative pronoun is missing.
This may lead to multiple parses, including one for
the above example similar to the correct one for:
the tile John created on Monday
These ambiguities will be taken care of by Plume s
standard ambiguity reduction methods
2 3 Interrogatives
In addition to handling passives and &apos;elative :lauses,
also wish the Information in the &apos;c,eate • :aseframe to
hanale Interrogatives involving &amp;quot;create&apos; s,,ch as
</bodyText>
<footnote confidence="0.940399285714286">
21c1 Jim create the file. On It/Jun.11v
Was the tile created by Jim or,
Who created the tile on Vonitav‘
What day was tne tile createt.1
The primary difficulty for Plume :rim interrogatives is that. as
these examples show, the number of variations in standard
constituent order is much greater than for imperatives ano
</footnote>
<page confidence="0.996054">
157
</page>
<bodyText confidence="0.97794572">
declaratives. Interrogatives come in a wide variety of forms.
depending on whether the question is yes/no or wh: on
which auxiliary verb is used: on whether the voice is active
or passive: and for wh questions, on which case is queried.
On the other hand, apart from variations in the order and
placement of marked cases. there is only one standard
constituent order for imperatives and only two for
declaratives (corresponding to active and passive voice). We
have exploited this low variability by building knowledge of
the imperative and declarative order into Plume&apos;s parsing
algorithm. However this is impractical for the larger
number of variations associated with interrogatives.
Accordingly, we have designed a more data-driven approach.
This approach involves two passes through the input: the
first categorizes the input into one on several primary input
categories including yes-no questions, several kinds of wh-
questions, statements, or imperatives. The second pass
performs a detailed parse of the input based on the
classification made in the first pass. The rules used contain
basic syntactic information about English. and will remain
constant for any of Plume&apos;s restricted domain grammars of
semantic caseframes for English
The first level of processing involves an ordered set of
roo-level Patterns Each top-level pattern corresponds to one
of the primary input categories mentioned above. This
classificatory matching does not attempt to match every
word in the input sentence, but only to do the minimum
necessary to make the classification. Most of the relevant
information is found at the beginning of the inputs. In
particular, the top-level patterns make use of the fronted
auxiliary verb and wh-words in questions.
As well as classifying the input, this top-level match is
also used to determine the identity of the caseframe to be
instantiated This is important to do at this stage because
the detailed recognition in the second phase is heavily
dependent on the identity of this top-level caseframe The
special symbol. Sverb. that appears exactly once in all top-
level patterns, matches a header of any clausal caseframe
We call the caseframe whose header is matched by $verb
the primary caseframe for that input.
The second more detailed parsing phase is organized
relative to the primary caseframe. Associated with each top-
level pattern, there is a corresponding parse template. A
parse template specifies which parts of the primary
caseframe will be found in unusual positions and which
parts the default parsing process (the one for declaratives
and imperatives) can be used for.
A simplified example of a top-level pattern for a yes-no
question is: 11
&lt;aux&gt; r ($verb !! &lt;aux&gt; 1) (&amp;s Sverb) Vest
This top-level pattern will match inputs like, the following:
Did Jim create too?
Was too created by Jim?
The first element of the above top-level pattern is an
auxiliary verb, represented by the non-terminal &lt;aux&gt; ThiS
auxiliary is remembered and used by the verb cluster
processor (as though it were the firSt auxiliary in the cluster)
to determine tense and voice. According to the next part
of the pattern, some word that is not a verb or an auxiliary
must appear after the fronted auxiliary and before the main
verb ( is the negation operator. and !! marks a
disiunction). Next, the scanning operator &amp;s tells the
matcher to scan until it finds Svero. which matches the
.header of any clausal caseframe Finally, Srest matches
the remaining input,
If the top-level pattern successfully matches. Plume uses
the associated parse template to direct its more detailed
processing of the input. The goal of this second pass
through the input is to instantiate the caseframe
corresponding to the header matched by $verb in the top-
level pattern The concept of a kemel-casetrame is
important to this stage of processing. A kernel-caseframe
corresponds to that part of an input that can be processed
according to the algorithm already built into Plume for
declarative and imperative sentences.
</bodyText>
<sectionHeader confidence="0.781664" genericHeader="method">
? I
</sectionHeader>
<bodyText confidence="0.35374275">
ki ih5 attern. only toot:tuts where Me fronted auxiliary .s me first
word ,n !tie sentence are ailowect the more mthotett patter,&apos; &apos;hat ,s
actuante .&apos;ed by Plume allowS orepuSitionaily mail■ect :ases &apos;o ipbear
liralls as &apos;,reit
</bodyText>
<page confidence="0.995518">
158
</page>
<bodyText confidence="0.988688538461538">
The parse template associated with the above top-level
pattern for yes/no questions is:
Could match an obieCt query Or a marked case query.
including the following:
aux kernel-case frame
+ (query)
This template tells the parser that the input consists of the
auxiliary verb matched in the first pass followed by a
.kernel-caseframe. For example. in:
Old Jim Create fOO&amp;quot;
the auxiliary verb. &amp;quot;did&amp;quot;. appears first followed by a kernel-
caseframe. &apos;&apos;Jim create foo&amp;quot; Note how the kernel-
caseframe lookS exactly like a declarative sentence, and so
Can be parsed according to the usual declarative/imperative
parsing algorithm
In addition to specification of where to find components of
the primary caseframe. a parse template includes
annotations (indicated by a plus sign) In the above
template for yes/no questions. there is lust one annotation -
query. Some annotations, like this one indicate what type
of input has been found, while others direct the processing
of the parse template. Annotations of me first type record
which case is being queried in win questions. that is. which
case is associated with the wh word. VVh questions thus
include one of the following annotations* subiect-quety.
object-query. and marked-case-query Marked case queries
correspond to examples like:
On what day did Jim create too&amp;quot;
What day did Jim create too on&apos;
in which a case marked by a preposition is being asked
about. As illustrated here the case-marker in such queries
can either precede the wh word or appear somewhere .after
the verb. To deal with this, the parse template for marked
case queries has the annotation tloarind-case-marker. This
annotation is of the second type that is it affects the way
Plume processes the associated parse template.
Some top-level patterns result in two possibilities for parse
templates. For example. the following top-level pattern
&lt; tin-word&gt; &lt;aux &gt; (Sverta aux &gt; Svf,rb Srest
What did Jim create&amp;quot;
By whom was foo created912
Who was foo created by&apos;
These inputs cannot be satisfactorily discriminated by a top-
level pattern, so the above top-level pattern has two different
parse templates associated with it:
wh-oblect aux kernel-caseframe
+ ( obiect-query)
wh-marked-case-tiller aux kernel-case frame
+ ( marked-case-query floating-case-marker)
When the above top-level pattern matches. Plume tries to
Parse the input using both of these parse templates. In
general. only one will succeed in accounting for all the
input. so the ambiguity will be eliminated by the methods
already built into Plume.
The method of parsing interrogatives presented above
allows Plume to handle a wide variety of interrogatives in a
very general way using domain specific semantic caseframes.
The writer Of the Caseframes does not have to worry about
whether they will be used for imperative, declarative, or
interrogative sentences. (or in relative clauses). He is free
to concentrate on the domain-specific grammar. In addition.
the concept of the kernel-caseframe allows Plume to use
the same efficient caseframe-based parsing algorithm that it
used for declarative and imperative sentences to parse
maior subparts of questions.
</bodyText>
<sectionHeader confidence="0.992196" genericHeader="conclusions">
3. Conclusion
</sectionHeader>
<bodyText confidence="0.999224555555556">
Previous work (e.g. [4. 5. 3D ana experience ivith our
current implementation of Plume. Carnegie Group S semantic
caseframe parser. has snown semantic caseframe
instantiation to be an efficient aria highly robust method of
parsing restricted domain input However like other
methods of parsing heavily dependent on restricted domain
semantics these initial attempts at parsers based on
semantic caseframe instantiation suffer from patchy syntactic
coverage.
</bodyText>
<page confidence="0.995939">
159
</page>
<bodyText confidence="0.9999592">
After first describing the current implementation of Plume.
this paper presented a detailed design for endowing Plume
with much broader syntactic coverage including passives.
interrogatives, and relative clauses. Relative clauses are
accommodated through some grammar preprocessing and a
minor change in the processing of nominal caseframes.
Handling of interrogatives relies on a set of rules for
classifying inputs into one of a limited number of types.
Each of these types has one or more associated parse
templates which guide the subsequent detailed parse of the
sentence. As the final version of this paper is prepared
(late April. 1985). the handling of passives and interrogatives
has already been implemented in an internal development
version of Plume. and relative clauses are expected to follow
soon.
Though the above methods of incorporating syntactic
generality into Plume do not cover all of English syntax.
they show that a significant degree of syntactic generality
can be provided straightforwardly by a domain specific
parser driven from a semantic caseframe grammar
</bodyText>
<sectionHeader confidence="0.994351" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.9998405">
1. Bobrow. R J. The PIUS System BBN Report 3878.
Bolt. Beranek. and Newman. 1978
2. Brown. J. S. and Burton. R R Multiple
Representations of Knowledge for Tutorial Reasoning. In
Representation and Understanding. Bobrow. D. G. and
Collins, A.. Ed.. Academic Press. New York. 1975. PP.
311-349.
3. Burton, R. R. Semantic Grammar An Engineering
Technique for Constructing Natural Language Understanding
Systems. BBN Report 3453. Bolt. Beranek, and Newman.
Inc., Cambridge. Mass.. December. 1976.
4. Carbonell. J. G.. Boggs. W. M.. Mauldin, M. L.. and
Anick, P. G. The XCALIBUR Protect: A Natural Language
Interface to Expert Systems. Proc. Eighth Int. Jt. Conf . on
Artificial Intelligence. Karlsruhe. August. 1983.
5. Carbonell. J. G. and Hayes. P &amp;quot; Recovery Strategies
for Parsing Extragrammatical Language&apos;.Computational
Linguistics 10 (1984).
6. Grosz. B. J. TEAM: A Transportable Natural Language
Interface System. Proc. Conf on Applied Natural Language
Processing, Santa Monica. February 1983,
7. Haas. N. and Hendrix. G. G. An Approach to Acquiring
and Applying Knowledge Proc. National Conference of the
American Association for Artificial Intelligence. Stanford
University. August. 1980. pp. 235-239
8. Hayes, P J. and Carbonell. J G. Multi-Strategy
Parsing and its Role in Robust Man-Machine Communication.
Carnegie-Mellon University Computer Science Department.
May. 1981.
9. Hendrix. G. G. Human Engineering for Applied Natural
Language Processing. Proc Fifth Int. Jt. Conf on Artificiat
Intelligence. MIT. 1977. pp. 183-191
10. Woods. W. A. &apos;Cascaded ATN Grammars &apos; Amenc3n
Journal of Computational Linguistics 6. 1 (August 1980) 1-12
</reference>
<page confidence="0.997484">
160
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.011296">
<title confidence="0.999754">Semantic Caseframe Parsing and Syntactic Generality</title>
<author confidence="0.999958">Peggy M Andersen</author>
<affiliation confidence="0.999389">Carnegie Group Incorporated</affiliation>
<address confidence="0.8458565">Commerce Court at Station Square 15219 USA</address>
<abstract confidence="0.999291894557824">We have implemented a restricted domain parser called 7&amp;quot;Building on work at Carnegie-Mellon University e.g. [4. 5, 91, Plume s approacri to parsing IS based on semantic caseframe Instantiation This nas the advantages of efficiency on grammatical Input, and robustness in the face of ungrammatical input While Plume is well adapted to simple declarative and imperative utterances, it handles passives relative clauses and interrogatives in an ad hoc manner leading to patchy syntactic coverage This paper outlines Plume as it currently exists and describes our detailed design for extending Plume to handle passives relative clauses, and interrogatives in a general manner 1. The Plume Parser at Carnegie-Mellon University e.g. 5[ shown semantic caseframe instantiation to be a highly robust and efficient method of parsing restricted domain input. In this approach to parsing. a caseframe grammar contains the semantic information, the parsing program contains general syntactic knowledge. Input is mapped onto the grammar using this built-in syntactic We have chosen this approach for commercial restricted domain parser. because of its advantages in efficiency and robustness. Let us take a simple example from a natural language interface. called NLVMS. that we are developing under a contract with Digital Equipment Corporation NLVMS is an interface to Digital&apos;s VMS operating system for &apos;/AX The Plume grammar for this interface contains following semantic corresponding to the copy command of VMS: (*copy* :cf-type clausal :header copy :cases (file-to-copy :filler *file* :positional Direct-Object) (source :filler *directory* :marker from I out of) (destination :filler *file* I *directory* :marker to I into I in I onto) This defines a caseframe. called &apos;copy with three cases: file-to-copy, source. and destination The file-to-copy case is filled by an obiect of type • file • and appears in the input as a direct obiect Source is filled by a &apos;directory&apos; and should appear in the input as a prepositional phrase preceded or marked by the prepositions &amp;quot;from&apos; or &apos;out of&amp;quot; Destination is filled by a file • or •directory • and is marked by &amp;quot;to&amp;quot;. &amp;quot;into&amp;quot;. or &amp;quot;onto&amp;quot; Finally the copy command itself is recognized by the header word indicated above (by header) as &amp;quot;copy&amp;quot;. Using this caseframe. Plume can parse inputs like: IMore prectsely. the nAme trie runanne Ivstem Copy too Oar out of [xf into (yr&apos; From [xJ to (yl copy too oar oar copy from [xl to Arlin Language Craft an integrated envuonment of natural language interfaces r he Plume parser Nnich translates Engush input into casetrame instances. is a mator i:omponeni this run-time System The other inaliar translates the caSeframe instances into application specific ianguages. in adomon to the Plume run-time system. Language Craft inc&apos;ucles grammar development tools incluchng sum:hated editor .onct tracing and measurement mois Ina Language Craft are Carnegie Groin) arm are ri•reritly m re-armied release Plume .no Language Craft ire if aaernarks .arneote t3roup incorporated and VAX are trademarks or Digital Equipment iS 1 ...ersion ine tii 0 me grammar. 153 In essence. Plume&apos;s parsing algorithm is to find a caseframe header. in this case &amp;quot;copy&amp;quot;. and use the associated caseframe, &apos;copy&apos;. to guide the rest of the parse. Once the caseframe has been identified. Plume looks for case markers, and then parses the associated case filler directly following the marker Plume also tries to parse positionally specified cases, like direct object. in the usual position in the sentence immediately following the header for direct object. Any input not accounted for at the end of this procedure is matched against any unfilled CaSes, so that cases that are supposed to be marked can be recognized without their markers and positionally indicated cases can be recognized out of their usual positions. This flexible. interpretive style of matching caseframes against the input allows Plume to deal with the kind of variation in word order illustrated in the examples above. The above examples implied there was some method to recognize files and directories. They showed only atomic file and directory descriptions. but Plume can also deal with more complex obiect descriptions. In fact, in Plume grammars. objects as well as actions can be described by caseframes. For instance here is the caseframes used to define a file for NLVMS. le* :.cf-type nominal :header file &apos; !name ?(%period !extension) :cases (name :assignedp !name) (extension :assignedp !extension :marker written in :adjective &lt;language&gt; :filler &lt;language&gt;) (creator :filler *person* :marker created by) (directory 4n rho? syntax used wen VMS. cnrectones are $nd.Cated Ov SQUare nrackers. autonlan, ally e.&apos;nqn.zes letenn.ners .01:1 n..aonners aSSCo71 at ed ■unnInal aierra■nes This caseframe allows Plume to recognize file descriptions 100 100. bar file created The Fortran file in pt] created by John The caseframe notation and parsing algorithm used here are very similar to those described above for clause level input. The significant differences are additions related to the :adjective and :assignedp attributes of some of the cases While Plume normally only looks for fillers header in nominal caseframes an adjective attribute of a slot tells Plume that the slot filler may appear before the header. An :assignedp attribute allows cases to be filled through recognition of a header. This is generally useful for proper names, such as foo and foo.bar. In the example above. header iwo &apos;,enables &apos;name that can each match single Nord. The mark optionaiity. that the header can either a single word or a word followed by and word. The first word assigned to /enable the second if it mere to the /enable if &apos;name or are matched while file header, their values are placed extension cases the above modifications can parse nominal caseframes using the same algorithm that it uses for clausal caseframes that account for complete sentences. However are some the two levels of In particular, there can be ambiguity about where attach marked cases. For instance. Copy the Fortran file in (xl to [yl could either fill the directory Case of the file as &amp;quot;the fortran or could fill the destination of the whole copy command second does not at global place to put &amp;quot;to is in that destination However, at the time the file description is parsed. this information is not available, and so both possible must be considered In general. if Plume is able to fill a case of a nominal caseframe from a 154 prepositional phrase, it also splits off an alternative parse in which that attachment is not made. When all input haS been parsed. PluMe retains only those parses that succeed at the global level, i.e.. consume all of the input. Others are discarded. The current implementation of Plume is based on the nominal and clausal level caseframe instantiation algorithms described above. Using these algorithms and a restricted domain grammar of caseframes like the ones snown above. Plume can parse a wide variety of imperative and declarative sentences relevant to that domain. However. there remain significant gaps in its coverage. Interrogatives are not handled at all passives are covered only if they in the grammar and relative clauses can only be handled by pretending they are a form of prepositional phrase The regular and predictable relationship between simple statements, questions and relative clauses and between active and passive sentences is ,vell known A parser which purports to interpret a doinain specific language specification a built-in of should account in general The current implementation of has doing this. Each for relative clauses and passives must in the grammar For Instance, to clauses as in &amp;quot;the file created by Jim&amp;quot; &amp;quot;created by&amp;quot; is listed as a case marker (compound creator slot of file. marking a description of the creator To handle full relatives the case marker must be Specified as something like &amp;quot;&apos;?twhich &lt;be &gt; ) While this allows Plume to recognize the file was created Jim&amp;quot;. file created by Jim&amp;quot;. Jim on Monday it down something &amp;quot;the created on Monday by Jim&apos; the marker by&apos; is longer a unit. Moreover using the current techniques. Plume s ability to recognize the above inputs is completely unrelated to its to recognize inputs the file Jim created on Monoay the person that the file was created by on Monday day on which Jim created me an interface could recognize these examples It might seem unreasonable to a user that it could not recognize all of the others. Moreover given any of the examples. a user might reasonably expect of related sentence level inputs like Create the tile on Monday&apos; Jim created the tile on Monday Jim create the tile Was the tile created by Jim on Monday&apos; created the tile on What day was the tile created on? current implementation of Plume has no such regularity of coverage. Of course. this of patchy syntactic coverage not new domain parsers. of syntactic generality the original semantic [31 for the system • led to the concept of cascaded ATNs and the (11. A progression goals occurred the LIFER system 191 to TEAM and KLAUS 171. The basic obstacle to achieving syntactic generality in these network-based approaches was the way syntactic and mixed together in the grammar networks. The solutions. therefore. rested on separating the and semantic already just the separation of syntax and necessary for syntactic generality general syntactic knowledge resides in the parser while semantic information resides in the grammar This suggests that syntactic generality in a system like Plume can be achieved by ■mOroying the parser s casetrame ■nstantiation algorithms any to grammar content terms of above Involving • :1 suggests we can single &apos;create&apos; to nandle all the exampleS We simply need to provide suitable extensions to the existing caseframe nstantiahon algorithms In the next current ,moiernentanon ”ne .:,,nta.ns a remo.)rarv rietn.)cl landfing .-,,,,Vie&apos;&apos;&apos; - 0. , ■•••-r:; section we present a detailed design for such extensions 2. Providing Plume with Syntactic Generality described above. Plume currently use clausal . 155 caseframes only to recognize single clause imperative and declarative utterances in the active voice This section describes our design for extending Plume so that relative and interrogative uses of clausal caseframes in passive as well as active voice can also be recognized from the same information. We will present our general design by showing how it operates for the following &apos;create caseframe in the context of NLVMS: (*create* :cf-type clausal :header &lt;create&gt; :cases (creator :filler *person* :positional Subject) (createe :filler *file* :positional Direct-Object) (creation-date :filler *date* :marker on) Note that symbols in angle brackets represent non-terminals grammar (recognized by Plume technigueSi in the caseframe definition above &lt; create &gt; matches all morphological variants of the &amp;quot;create &apos;creates &amp;quot;Created&amp;quot; and ithough not compound lenses like creating&apos; see below). Using the existing Plume Piould only allow US to recognize simple imperatives and active leciaratives iike• Create to bar on Monday Jim created to oar un Monday Plume recognizes passive sentences through its processing /erb e the plus sequence of and auxiliary ierb preCeding Once main verb has been located verb cluster processing mechanism reads the verb cluster and determines from it whether the sentence is active or passive The parser records this information in a special case called &amp;quot;%voice&amp;quot;. If a sentence is found to be active the standard parsing algorithm described above is used if it is found to be the standard is used with the modification the parser looks for direct object or the indirect I°in the subject position, and for the subject as an marked with the case marker &amp;quot;by&amp;quot;. Thus, given the •create • caseframe above, the following passive sentences could be handled as well as their active counterparts. was created oy Jim Fop Oar could have oeeh reared cli/ Jim is being created Jim Foo bar was createo dn Monday 2.2. Relative clauses The detailed design presented below allows Plume to use •create • caseframe to parse nominals the file Jim created on Monday the person mat the tile was created oy on Monday the day on which Jim created the tile do this, we introduce the concept a case relative case is a link back froni the caseframes for the that fill the cases of a clausal caseframe to clausal caseframe. A grammar preprocessor generates a case automatically from each case of clausal associating It with the nominal caseframe fills the case in me clausal caseframe. Relative cases do not need to be specified by the grammar writer. For a relative case is generated case &apos;create&apos; and included in the &apos;file&apos; caseframe. it like this: (*file* (:relative-cf *create* :relative-case-name createe :marker &lt;create&gt; also determines the tense ca and •vhetner s affirmative or negative &apos;I mere .5 a Case •vith a positional •nairect.obieCt slot Me )biect .s allowed to OaSSivize Ne •:aii thus iaiderstana ientences • tpven a booit &apos; a .ase.isme bain an ...direct thiect • ase 156 that :marker is as :header of &apos;create&apos; Similar relative cases are generated in the •person&apos; caseframe for the creator caSe, and in the &apos;date&amp;quot; caseframe for the creation-date caSe, differing only in :relative-case-name. cases used similarly to the ordinary marked cases of nominal caseframes. In essence. if the parser IS parsing a nominal caseframe &apos;and finds the marker of one its relative cases. then it tries to instantiate the :relativecf. It performs this instantiation in the same way as if the relative-cf were a top-level clauSal caseframe and the word that matched the header ..vere Its main verb. An important difference is that it never tries to fill the case &amp;quot;those name is given by relative-case-name. That case is filled by the nominal caseframe which contains the relative case For instance. suppose the parser is trying to process. Jim created on Monday that it has already located &amp;quot;file&apos; used that to determine it is instantiating a &apos;file&apos; nominal caseframe It is able to match (against &amp;quot;created&amp;quot; i the :marker of the relative caseframe of •flie • shown above. It then tries to instantiate the relative.cf &apos;create&apos; using its techniques except that it does not try to the case of &apos;create&apos; specified as the relative-case- This instantiation succeeds with going into and Monday&amp;quot; being used to creation-date parser then uses (a the nominal caseframe currently being instantiated. &apos;file&apos; to fill createe. the case of •create&apos; the of •create • is attached to this instance of •file • a modifier Plume&apos;s for relative clauses is: When processing nominal caseframe. Plume scans for the :markers of the relative cases of the nominal caseframe at the same time as It scans for the regular case markers of that nominal caseframe If it a :marker of a relative case, it tries to inst4ntiate the relative-cf lust as though it were the top-level clausal casefrarne and the header were its main verb, except that: it never any further left in the inout than header of the nomiral or if already other Oost-rominal of nominal caseframe no further left right end of them it consumes, otherwise ignores any relative which that; immediately precede the segment used to relative-of means that including &amp;quot;that&amp;quot; will tor the tile that Jim createc on Monday&amp;quot; C. it does not try to fill the case specified by the relative-case-name in the relative-cf: instead this case is filled by (a pointer to) the original caseframe d. if the relative-case-name specifies a marked case rather than a positional one in the relative-cf then its case marker can be consumed, but otherwise ignored, during of the relative-cf allows us deal with &amp;quot;on&apos; ;n &apos;tne cate Jim created or Care un which Jim created the tile&apos; Passive clauses le g. that was created on Monday&amp;quot;) can generally be handled using the same mechanisms used for passives at the main level However, in relative Passives be reduced by omitting the usual verb to be the relative pronoun) as in: the tile created on Monday To account for such reduced relative clauses, the cluster processor produce appropriate readings of the verb clusters clauses for which the relative pronoun is missing. This may lead to multiple parses, including one for example similar to correct one for: the tile John created on Monday These ambiguities will be taken care of by Plume s standard ambiguity reduction methods 2 3 Interrogatives In addition to handling passives and &apos;elative :lauses, wish the Information the :aseframe to hanale Interrogatives involving &amp;quot;create&apos; s,,ch as 21c1 Jim create the file. On It/Jun.11v the tile created Who created the tile on Vonitav‘ What day was tne tile createt.1 primary difficulty :rim interrogatives is that. show, the number of variations standard order is greater for imperatives ano 157 come in a wide variety of forms. depending on whether the question is yes/no or wh: on which auxiliary verb is used: on whether the voice is active or passive: and for wh questions, on which case is queried. On the other hand, apart from variations in the order and placement of marked cases. there is only one standard constituent order for imperatives and only two for declaratives (corresponding to active and passive voice). We have exploited this low variability by building knowledge of the imperative and declarative order into Plume&apos;s parsing algorithm. However this is impractical for the larger number of variations associated with interrogatives. Accordingly, we have designed a more data-driven approach. This approach involves two passes through the input: the first categorizes the input into one on several primary input including yes-no questions, several kinds of whquestions, statements, or imperatives. The second pass performs a detailed parse of the input based on the made in pass. The rules used contain basic syntactic information about English. and will remain constant for any of Plume&apos;s restricted domain grammars of semantic caseframes for English of processing involves an ordered set Patterns pattern to one the primary categories mentioned above. to match in the but do the minimum make the classification. Most of relevant found at the beginning of the inputs. particular, the top-level patterns make use of the fronted verb and in questions. well as classifying input, match is used determine the identity of the caseframe to be is important to do at stage because detailed recognition in the second phase is on the identity of caseframe The special symbol. Sverb. that appears exactly once in all toplevel patterns, matches a header of any clausal caseframe We call the caseframe whose header is matched by $verb caseframe that input. The second more detailed parsing phase is organized to the primary caseframe. Associated with each toppattern, there is a corresponding template. A parse template specifies which parts of the primary caseframe will be found in unusual positions and which parts the default parsing process (the one for declaratives and imperatives) can be used for. A simplified example of a top-level pattern for a yes-no is: 11 !! &lt;aux&gt; 1) (&amp;s Sverb) Vest This top-level pattern will match inputs like, the following: Did Jim create too? Was too created by Jim? first element of the above pattern is an verb, represented by the non-terminal ThiS is remembered and used by the verb (as though it were the in the cluster) determine tense and voice. According to the part the pattern, some word that is not a verb or an after the fronted auxiliary and before main verb ( is the negation operator. and !! marks a Next, the scanning operator the to scan until it finds matches the of any clausal caseframe Finally, the remaining input, top-level pattern successfully matches. Plume uses associated parse template to more of the input. The goal of pass through the input is to instantiate the caseframe to the header matched by $verb in the toppattern The concept of a important to this stage of processing. A kernel-caseframe to that part of an input that be to the built into Plume declarative and imperative sentences. ? I ih5 attern. toot:tuts where Me auxiliary .s ,n !tie sentence ailowect the more mthotett .&apos;ed by Plume orepuSitionaily mail■ect :ases ipbear 158 The parse template associated with the above top-level pattern for yes/no questions is: Could match an obieCt query Or a marked case query. including the following: aux kernel-case frame + (query) This template tells the parser that the input consists of the auxiliary verb matched in the first pass followed by a .kernel-caseframe. For example. in: Old Jim Create fOO&amp;quot; auxiliary verb. &amp;quot;did&amp;quot;. appears first followed by a kernel- &apos;&apos;Jim create foo&amp;quot; Note how the caseframe lookS exactly like a declarative sentence, and so Can be parsed according to the usual declarative/imperative parsing algorithm In addition to specification of where to find components of the primary caseframe. a parse template includes annotations (indicated by a plus sign) In the above for yes/no questions. there is one annotation annotations, like this one indicate what type of input has been found, while others direct the processing the parse template. Annotations of record which case is being queried in win questions. that is. which case is associated with the wh word. VVh questions thus one of the following annotations* case queries correspond to examples like: On what day did Jim create too&amp;quot; What day did Jim create too on&apos; in which a case marked by a preposition is being asked about. As illustrated here the case-marker in such queries either precede the appear somewhere .after verb. To deal with the template for marked queries has the annotation is the second type that is it affects the way Plume processes the associated parse template. top-level patterns result in for parse For example. following top-level tin-word&gt; &lt;aux &gt; (Sverta aux &gt; What did Jim create&amp;quot; was foo Who was foo created by&apos; These inputs cannot be satisfactorily discriminated by a toplevel pattern, so the above top-level pattern has two different parse templates associated with it: wh-oblect aux kernel-caseframe + ( obiect-query) wh-marked-case-tiller aux kernel-case frame + ( marked-case-query floating-case-marker) When the above top-level pattern matches. Plume tries to Parse the input using both of these parse templates. In only one in accounting input. so the ambiguity will be eliminated by the methods built The method of parsing interrogatives presented above allows Plume to handle a wide variety of interrogatives in a way using specific semantic caseframes. writer Caseframes does not have to worry about whether they will be used for imperative, declarative, or interrogative sentences. (or in relative clauses). He is free to concentrate on the domain-specific grammar. In addition. concept of the allows Plume to same efficient caseframe-based parsing that it for declarative and imperative sentences parse maior subparts of questions. 3. Conclusion Previous work (e.g. [4. 5. 3D ana experience ivith our current implementation of Plume. Carnegie Group S semantic has snown semantic caseframe instantiation to be an efficient aria highly robust method of domain input However like other methods of parsing heavily dependent on restricted domain semantics these initial attempts at parsers based on semantic caseframe instantiation suffer from patchy syntactic coverage. 159 After first describing the current implementation of Plume. this paper presented a detailed design for endowing Plume with much broader syntactic coverage including passives. interrogatives, and relative clauses. Relative clauses are accommodated through some grammar preprocessing and a minor change in the processing of nominal caseframes. Handling of interrogatives relies on a set of rules for classifying inputs into one of a limited number of types. Each of these types has one or more associated parse templates which guide the subsequent detailed parse of the sentence. As the final version of this paper is prepared (late April. 1985). the handling of passives and interrogatives has already been implemented in an internal development version of Plume. and relative clauses are expected to follow soon. Though the above methods of incorporating syntactic generality into Plume do not cover all of English syntax. they show that a significant degree of syntactic generality can be provided straightforwardly by a domain specific parser driven from a semantic caseframe grammar</abstract>
<note confidence="0.759413944444444">References 1. Bobrow. R J. The PIUS System BBN Report 3878. Bolt. Beranek. and Newman. 1978 2. Brown. J. S. and Burton. R R Multiple Representations of Knowledge for Tutorial Reasoning. In and Understanding. Bobrow. G. Collins, A.. Ed.. Academic Press. New York. 1975. PP. 311-349. 3. Burton, R. R. Semantic Grammar An Engineering Technique for Constructing Natural Language Understanding Systems. BBN Report 3453. Bolt. Beranek, and Newman. Inc., Cambridge. Mass.. December. 1976. 4. Carbonell. J. G.. Boggs. W. M.. Mauldin, M. L.. and Anick, P. G. The XCALIBUR Protect: A Natural Language to Expert Systems. Proc. Eighth Conf . on Artificial Intelligence. Karlsruhe. August. 1983. 5. Carbonell. J. G. and Hayes. P &amp;quot; Recovery Strategies Parsing Extragrammatical 10 6. Grosz. B. J. TEAM: A Transportable Natural Language Interface System. Proc. Conf on Applied Natural Language Processing, Santa Monica. February 1983, 7. Haas. N. and Hendrix. G. G. An Approach to Acquiring and Applying Knowledge Proc. National Conference of the American Association for Artificial Intelligence. Stanford University. August. 1980. pp. 235-239 8. Hayes, P J. and Carbonell. J G. Multi-Strategy and its Role in Robust Man-Machine Carnegie-Mellon University Computer Science Department. May. 1981. 9. Hendrix. G. G. Human Engineering for Applied Natural Processing. Proc Fifth Int. Jt. on Intelligence. MIT. 1977. pp. 183-191 Woods. W. A. &apos;Cascaded ATN Grammars &apos; of Computational Linguistics 6. (August 1-12 160</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>R J</author>
</authors>
<title>The PIUS System</title>
<date>1978</date>
<tech>BBN Report</tech>
<marker>1.</marker>
<rawString>Bobrow. R J. The PIUS System BBN Report 3878. Bolt. Beranek. and Newman. 1978</rawString>
</citation>
<citation valid="true">
<authors>
<author>J S</author>
<author>R R Burton</author>
</authors>
<title>Multiple Representations of Knowledge for Tutorial Reasoning. In Representation</title>
<date>1975</date>
<pages>311--349</pages>
<publisher>Academic Press.</publisher>
<location>New York.</location>
<marker>2.</marker>
<rawString>Brown. J. S. and Burton. R R Multiple Representations of Knowledge for Tutorial Reasoning. In Representation and Understanding. Bobrow. D. G. and Collins, A.. Ed.. Academic Press. New York. 1975. PP. 311-349.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R R Burton</author>
</authors>
<title>Semantic Grammar An Engineering Technique for Constructing Natural Language Understanding Systems.</title>
<date>1976</date>
<tech>BBN Report</tech>
<publisher>Inc.,</publisher>
<location>Cambridge. Mass..</location>
<marker>3.</marker>
<rawString>Burton, R. R. Semantic Grammar An Engineering Technique for Constructing Natural Language Understanding Systems. BBN Report 3453. Bolt. Beranek, and Newman. Inc., Cambridge. Mass.. December. 1976.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J G Boggs W M Mauldin</author>
<author>M L</author>
<author>P G Anick</author>
</authors>
<title>The XCALIBUR Protect: A Natural Language Interface to Expert Systems.</title>
<date>1983</date>
<booktitle>Proc. Eighth Int. Jt. Conf . on Artificial Intelligence.</booktitle>
<location>Karlsruhe.</location>
<marker>4.</marker>
<rawString>Carbonell. J. G.. Boggs. W. M.. Mauldin, M. L.. and Anick, P. G. The XCALIBUR Protect: A Natural Language Interface to Expert Systems. Proc. Eighth Int. Jt. Conf . on Artificial Intelligence. Karlsruhe. August. 1983.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J G</author>
<author>P Hayes</author>
</authors>
<title>Recovery Strategies for Parsing Extragrammatical</title>
<date>1984</date>
<journal>Language&apos;.Computational Linguistics</journal>
<volume>10</volume>
<marker>5.</marker>
<rawString>Carbonell. J. G. and Hayes. P &amp;quot; Recovery Strategies for Parsing Extragrammatical Language&apos;.Computational Linguistics 10 (1984).</rawString>
</citation>
<citation valid="true">
<authors>
<author>B J</author>
</authors>
<title>TEAM: A Transportable Natural Language Interface System.</title>
<date>1983</date>
<booktitle>Proc. Conf on Applied Natural Language Processing,</booktitle>
<location>Santa Monica.</location>
<contexts>
<context position="10487" citStr="[6]" startWordPosition="1686" endWordPosition="1686">Jim created the tile on Monday Did Jim create the tile on Monday.&apos; Was the tile created by Jim on Monday&apos; Who created the tile on Monday&apos;, What day was the tile created on? The current implementation of Plume has no means of guaranteeing such regularity of coverage. Of course. this problem of patchy syntactic coverage is not new for restricted domain parsers. The lack of syntactic generality of the original semantic grammar [31 for the Sophie system • 121 led to the concept of cascaded ATNs 001 and the RUS parser (11. A progression with similar goals occurred from the LIFER system 191 to TEAM [6] and KLAUS 171. The basic obstacle to achieving syntactic generality in these network-based approaches was the way syntactic and Semantic information was mixed together in the grammar networks. The solutions. therefore. rested on separating the syntactic and semantic information. Plume already incorporates just the separation of syntax and semantics necessary for syntactic generality general syntactic knowledge resides in the parser while semantic information resides in the grammar This suggests that syntactic generality in a system like Plume can be achieved by ■mOroying the parser s casetram</context>
</contexts>
<marker>6.</marker>
<rawString>Grosz. B. J. TEAM: A Transportable Natural Language Interface System. Proc. Conf on Applied Natural Language Processing, Santa Monica. February 1983,</rawString>
</citation>
<citation valid="true">
<authors>
<author>N</author>
<author>G G Hendrix</author>
</authors>
<title>An Approach to Acquiring and Applying Knowledge</title>
<date>1980</date>
<booktitle>Proc. National Conference of the American Association for Artificial Intelligence.</booktitle>
<pages>235--239</pages>
<institution>Stanford University.</institution>
<marker>7.</marker>
<rawString>Haas. N. and Hendrix. G. G. An Approach to Acquiring and Applying Knowledge Proc. National Conference of the American Association for Artificial Intelligence. Stanford University. August. 1980. pp. 235-239</rawString>
</citation>
<citation valid="true">
<authors>
<author>J G</author>
</authors>
<title>Multi-Strategy Parsing and its Role in Robust Man-Machine Communication.</title>
<date>1981</date>
<institution>Carnegie-Mellon University Computer Science Department.</institution>
<marker>8.</marker>
<rawString>Hayes, P J. and Carbonell. J G. Multi-Strategy Parsing and its Role in Robust Man-Machine Communication. Carnegie-Mellon University Computer Science Department. May. 1981.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G G</author>
</authors>
<title>Human Engineering for Applied Natural Language Processing.</title>
<date>1977</date>
<booktitle>Proc Fifth Int. Jt. Conf on Artificiat Intelligence. MIT.</booktitle>
<pages>183--191</pages>
<marker>9.</marker>
<rawString>Hendrix. G. G. Human Engineering for Applied Natural Language Processing. Proc Fifth Int. Jt. Conf on Artificiat Intelligence. MIT. 1977. pp. 183-191</rawString>
</citation>
<citation valid="true">
<authors>
<author>W A</author>
</authors>
<title>Cascaded ATN Grammars &apos;</title>
<date>1980</date>
<journal>Amenc3n Journal of Computational Linguistics</journal>
<volume>6</volume>
<pages>1--12</pages>
<marker>10.</marker>
<rawString>Woods. W. A. &apos;Cascaded ATN Grammars &apos; Amenc3n Journal of Computational Linguistics 6. 1 (August 1980) 1-12</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>