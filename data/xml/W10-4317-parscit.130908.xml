<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.020288">
<title confidence="0.942478">
Dialogue Management Based on Entities and Constraints
</title>
<author confidence="0.95266">
Yushi Xu Stephanie Seneff
</author>
<affiliation confidence="0.6623145">
Spoken Language Systems Group
MIT Computer Science and Artificial Intelligence Laboratory
</affiliation>
<address confidence="0.525763">
United States
</address>
<email confidence="0.996464">
{yushixu, seneff}@csail.mit.edu
</email>
<sectionHeader confidence="0.993789" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999519461538461">
This paper introduces a new dialogue man-
agement framework for goal-directed conver-
sations. A declarative specification defines the
domain-specific elements and guides the di-
alogue manager, which communicates with the
knowledge sources to complete the specified
goal. The user is viewed as another knowledge
source. The dialogue manager finds the next
action by a mixture of rule-based reasoning
and a simple statistical model. Implementation
in the flight-reservation domain demonstrates
that the framework enables the developer to
easily build a conversational dialogue system.
</bodyText>
<sectionHeader confidence="0.998797" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.99994628125">
Conversational systems can be classified into
two distinct classes: goal-directed and casual
chatting. For goal-directed systems, the system is
usually more “knowledgeable” than the user, and
it attempts to satisfy user-specified goals. The
system’s conversational strategies seek the most
efficient path to reach closure and end the con-
versation (Smith, Hipp, &amp; Biermann, 1995).
An essential commonality among different
goal-directed applications is that, at the end of a
successful conversation, the system presents the
user with a “goal” entity, be it a flight itinerary, a
route path, or a shopping order. Different con-
versations result from different properties of the
goal entities and different constraints set by the
knowledge sources. The properties define the
necessary and/or relevant information, such as
flight numbers in the flight itinerary. Constraints
specify the means to obtain such information.
For examples fields “source”, “destination” and
“date” are required to search for a flight. Once
the properties and constraints are known, dialo-
gue rules can easily map to dialogue actions.
This paper introduces a dialogue management
framework for goal-directed conversation based
on entity and knowledge source specification.
The user is viewed as a collaborator with the di-
alogue manager, instead of a problem-raiser. The
dialogue manager follows a set of definitions and
constraints, and eventually realizes the goal enti-
ty. It also incorporates a simple statistical engine
to handle certain decisions.
</bodyText>
<sectionHeader confidence="0.999782" genericHeader="related work">
2 Related Work
</sectionHeader>
<bodyText confidence="0.999912357142857">
In recent years, statistical methods have gained
popularity in dialogue system research. Partially
Observable Markov decision processes have
been the focus of a number of papers (Levin,
Pieraccini, &amp; Eckert, 1997; Scheffler &amp; Young,
2001; Frampton &amp; Lemon, 2006; Williams &amp;
Young, 2007). These approaches turn the dialo-
gue interaction strategy into an optimization
problem. The dialogue manager selects actions
prescribed by the policy that maximizes the re-
ward function (Lemon &amp; Pietquin, 2007). This
machine learning formulation of the problem
automates system development, thus freeing the
developers from hand-coded rules.
Other researchers have continued research on
rule-based frameworks, in part because they are
easier to control and maintain. One common ap-
proach is to allow developers to specify the tasks,
either using a conditioned sequential script (Zue,
et al., 2000; Seneff, 2002), or using a task hie-
rarchy (Hochberg, Kambhatla, &amp; Roukos, 2002).
In (Bohus &amp; Rudnicky, 2003)’s work, a tree of
dialogue agents, each of which handles different
dialogue actions, is specified to control the di-
alogue progress. The knowledge has also been
specified either by first order logic (Bühler &amp;
Minker, 2005) or ontology information (Milward
&amp; Beveridge, 2004).
</bodyText>
<sectionHeader confidence="0.983903" genericHeader="method">
3 Dialogue Manager
</sectionHeader>
<bodyText confidence="0.413108">
Figure 1 illustrates the architecture of the pro-
posed dialogue management framework. Com-
</bodyText>
<subsubsectionHeader confidence="0.4873">
Proceedings of SIGDIAL 2010: the 11th Annual Meeting of the Special Interest Group on Discourse and Dialogue, pages 87–90,
</subsubsectionHeader>
<affiliation confidence="0.906952">
The University of Tokyo, September 24-25, 2010. p@c 2010 Association for Computational Linguistics
</affiliation>
<page confidence="0.999768">
87
</page>
<bodyText confidence="0.999962689655172">
munication with the dialogue manager (DM) is
via “E-forms” (Electronic forms), which consist
of language-independent key-value pairs. The
language understanding and language generation
components mediate between the DM and vari-
ous knowledge sources (KS), including the user,
to interpret the output from the KS and generate
input that the KS can understand. Each KS han-
dles one or more sub-domains. For example, a
date/time KS can resolve a date expression such
as “next Tuesday” to a unique date; a flight data-
base can provide flight information. The KSes
are provided by the developer. They can be local
(a library) or external (a separate executable).
Within this architecture, the user is viewed as
a special KS, who understands and speaks a nat-
ural language, so that the whole architecture is
completely DM-centered, as shown in Figure 1.
An external language understanding system
parses the original input into an E-form, and an
external language generation component con-
verts the output E-form into the desired natural
language. Each particular communication with
the user is analogous to other communications
with the various KSes. The user is always
ranked the lowest in the priority list of the KSes,
i.e., only when other knowledge sources cannot
provide the desired information does the DM try
to ask the user.
</bodyText>
<figureCaption confidence="0.998358">
Figure 1. System Framework.
</figureCaption>
<bodyText confidence="0.999762">
For example, in the flight reservation system,
suppose the DM first tries to determine the
source airport. If there exists a KS that contains
this user’s home airport information, the DM will
adopt it. If no other KS can provide the informa-
tion, the DM asks the user for the departure city.
</bodyText>
<subsectionHeader confidence="0.995006">
3.1 Entity-Based Specification
</subsectionHeader>
<bodyText confidence="0.99992003030303">
Our framework uses an entity-based declarative
domain specification. Instead of providing the
action sequence in the domain, the developer
provides the desired form of the goal entity, and
the relationships among all relevant entities.
The specification is decomposed into two parts.
The first part is the declaration of the knowledge
sources. Each KS may contain one or more sub-
domains, and an associated “nation” defines the
language processing parameters.
The second part is the entity type definition.
For a particular domain, there is one goal entity
type, and an arbitrary number of other entity
types, e.g., two entity types are defined in the
flight reservation system: “itinerary” and “flight.”
The definition of an entity type consists of a set
of members, including their names, types and
knowledge domain. A logical expression states
the conditions under which the entity can be re-
garded as completed; e.g., a completed itinerary
must contain one or more flights. The entity de-
finition can also include optional elements such
as comparative/superlative modifiers or custo-
mized command-action and task-action map-
pings, described in more detail later.
The entity-based specification has an advan-
tage over an action-based specification in two
aspects. First, it is easier to define all the entities
in a dialogue domain than to list all the possible
actions, so the specification is more compact and
readable. Secondly, the completion condition and
the KS’s constraints capture the underlying mo-
tivation of the dialogue actions.
</bodyText>
<figureCaption confidence="0.977341">
Figure 2. The Main Loop of the DM.
</figureCaption>
<subsectionHeader confidence="0.995394">
3.2 Dialogue Execution
</subsectionHeader>
<bodyText confidence="0.999590428571429">
Similar to the Information-State-Update (Larsson
&amp; Traum, 2000) idea, the DM maintains an in-
ternal state space with all up-to-date information
about the entities. It also keeps a task list tree
with a root task “complete goal.” In task execu-
tion, subtasks (child node) and/or subsequent
(right sibling node) tasks are issued. Each time
the left-most leaf task is executed, and when a
task is completed, the DM checks all tasks and
removes those that have been rendered obsolete.
Ten basic tasks are pre-defined in the DM,
including complete_entity, inquire_ks, and some
other tasks related to entity manipulation. A
complete_entity task evaluates the completion
</bodyText>
<figure confidence="0.997552458333333">
Language
Generation
Local KS External KS User
Domain Specification
Dialogue
Manager
Language
Understanding
E-form in
Extract
Information
User Command?
N
Y Issue New
Tasks
Retrieve Left-
Most Task
Execute Task
Remove
Obsolete Tasks
N
Pause?
Y
E-form out
</figure>
<page confidence="0.997319">
88
</page>
<bodyText confidence="0.9989417">
conditions and issues appropriate tasks if they
are unmet. An inquire_ks task handles communi-
cation with the KSes, and issues subtasks if the
query does not satisfy the constraints. A default
action associated with each task can be replaced
by customized task-action mappings if needed.
Figure 2 shows the main loop of the DM. The
process loops until a “pause” is signaled, which
indicates to await the user’s spoken response. An
example will be given in Section 4.
</bodyText>
<subsectionHeader confidence="0.999269">
3.3 Statistical Inference
</subsectionHeader>
<bodyText confidence="0.99998952">
To cope with situations that rules cannot handle
easily, the framework incorporates a simple sta-
tistical engine using a Space Vector Model. It is
designed only to support inference on specific
small problems, for example, to decide when to
ask the user for confirmation of a task. Models
are built for each of the inference problems. The
output label of a new data point is computed by
weighting the labels of all existing data by their
inverse distances to the new data point.
Equations (1) to (3) show the detailed math of
the computation, where x is the new data point
and dj is the j-th existing data point. α is a fading
coefficient which ranges from 0 and 1. β, a cor-
rection weight, has a higher value for data points
resulting from manual correction. δ(•) is 1 when
the two inputs are equal and 0 otherwise. sim(x,
d) defines the similarity between the new data
point and the existing data point. Function dis(•)
indicates the distance for a particular dimension,
which is specified by the developer. The weight
for each dimension wi is proportional to the
count of distinct values of the particular dimen-
sion c(Di) and the mutual information between
the dimension and the output label.
</bodyText>
<equation confidence="0.985799285714286">
f(x) = argmaxy ajl3jsim(x, di) • S(f(di), yI) (1)
ri �
1
� * d
�i�(�, d) = �✓�iwi • di�2(�i, di) (2)
S x=d
WI a c(DI)H(DI, f(D)) (3)
</equation>
<sectionHeader confidence="0.949552" genericHeader="method">
4 Implementation in Flight Domain
</sectionHeader>
<bodyText confidence="0.959234632653061">
The framework has been implemented in the
flight reservation domain. A grammar was used
to parse the user’s input, and a set of generation
rules was used to convert the DM’s output E-
form into natural language (Seneff, 2002). Two
local KSes are utilized: one resolves complex
date and time expressions, and one looks up air-
port/city codes. A local simulated flight DB will
be replaced by a real external one in the future.
Figure 3 illustrates the logic of the flight res-
ervation domain. The database has two alterna-
tive sets of conjunctive constraints “destination
&amp; source &amp; date” and “flight# &amp; date”. Two
entity types are defined. The itinerary entity type
contains a list of flights, a number of expected
flights and a price, with completion condition
“#flights &gt; 0”. The flight entity type contains
members: flight number, date, source, destination,
etc., with completion condition “flight# &amp; date”.
Table 1 illustrates dialogue planning. In the
execution of flight.complete_entity(), the DM
determines that it needs a flight number accord-
ing to the entity’s completion condition. Howev-
er, a destination is required to search the flight
DB. No other KS offers this information, so the
system turns to the user to ask for the destination.
The statistical engine currently supports infe-
rence for two problems: whether the execution of
a task requires the user’s confirmation, and
whether the pending list is in focus.
Several customized task actions were defined
for the domain. For example, after adding the
first flight, a customized task action will auto-
matically create a return flight with appropriate
source and destination, unless a one-way trip has
been indicated. The implementation of the cus-
tomized task actions required only about 550
lines of code.
User: I want a flight to Chicago
create itinerary
itinerary.complete_entity()
itinerary.add_entity(:flights)
create flight
flight.complete_entity()
flight.fill_attribute(flight#)
inquire_ks(flight_db, flight#)
flight.fill_attribute(destination)
inquire_ks(user, destination)
System: What city does the flight leave from?
</bodyText>
<tableCaption confidence="0.9952805">
Table 1. An example of the system&apos;s reasoning
process. Shaded lines denote statistical decisions.
</tableCaption>
<sectionHeader confidence="0.974994" genericHeader="method">
5. Preliminary Evaluation
</sectionHeader>
<bodyText confidence="0.999985416666667">
We conducted a preliminary evaluation with a
simulated flight database and a simulated user
model. The statistical inference model was
trained with 210 turns from 18 conversations. A
personality-based user simulator creates random
scenarios and simulates user utterances using a
probabilistic template-based method. In 50 con-
versations between the simulated user and the
DM, the average number of turns was 14.58,
with a high standard deviation of 8.2, due to the
variety of the scenario complexity and personali-
ties of the simulator users. Some simulated users
</bodyText>
<page confidence="0.999381">
89
</page>
<figureCaption confidence="0.998661">
Figure 3. Dialogue Logic for the Flight Booking Domain.
</figureCaption>
<bodyText confidence="0.999802846153846">
were intentionally designed to be very uncooper-
ative. The DM was able to handle these situa-
tions most of the time.
We examined all the simulated dialogues turn
by turn. For a total of 729 turns, the DM re-
sponded appropriately 92.2% of the time. One
third of the failed turns were due to parse failures.
Another third resulted from insufficient tutoring.
These situations were not well covered in the
tutoring phase, but can be easily fixed through a
few more manual corrections. The rest of the
errors came from various causes. Some were due
to defects in the simulator.
</bodyText>
<sectionHeader confidence="0.998494" genericHeader="conclusions">
6 Conclusions and Future Work
</sectionHeader>
<bodyText confidence="0.999968538461539">
We have introduced a framework for goal-based
dialogue planning. It treats the user as a know-
ledge source, so that the entire framework is
DM-centered. A declarative entity-based specifi-
cation encodes the domain logic simply and
clearly. Customized task actions handle any do-
main-dependent computations, which are kept at
a minimum. A simple statistical engine built into
the framework offers more flexibility.
In the future, we will integrate the dialogue
manager into a speech-enabled framework, and
build spoken dialogue systems for flight reserva-
tions and other domains of interest.
</bodyText>
<sectionHeader confidence="0.99767" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.9984815">
This research is funded by Quanta Computers,
Inc., through the T-Party project.
</bodyText>
<sectionHeader confidence="0.99898" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999561">
Bohus, D., &amp; Rudnicky, A. I. (2003). RavenClaw: Dialog
Management Using Hierarchical Task Decomposition
and an Expectation Agenda. Proc. Eurospeech. Geneva,
Switzerland.
Bühler, D., &amp; Minker, W. (2005). A REASONING
COMPONENT FOR INFORMATION-SEEKING AND
PLANNING DIALOGUES. Spoken Multimodal
Human-Computer Dialogue in Mobile Environments ,
28, 77-91.
Frampton, M., &amp; Lemon, O. (2006). Learning more
effective dialogue strategies using limited dialogue
move features. Proc. ACL, (pp. 185 - 192 ). Sidney,
Australia.
Hochberg, J., Kambhatla, N., &amp; Roukos, S. (2002). A
flexible framework for developing mixed-initiative
dialog systems. Proc. the 3rd SIGdial workshop on
Discourse and dialogue , (pp. 60-63). Philadelphia,
Pennsylvania .
Larsson, S., &amp; Traum, D. (2000). Information state and
dialogue management in the TRINDI dialogue move
engine toolkit. Natural Language Engineering , 6 (3-4),
323-340.
Lemon, O., &amp; Pietquin, O. (2007). Machine learning for
spoken dialog systems. Proc. INTERSPEECH 2007,
(pp. 2685–2688 ). Antwerp, Belgium.
Levin, E., Pieraccini, R., &amp; Eckert, W. (1997). Learning
Dialogue Strategies within the Markov Decision Process
Framework. Proc. ASRU 1997. Santa Barbara, USA.
Milward, D., &amp; Beveridge, M. (2004). Ontologies and the
Structure of Dialogue. Proc. of the Eighth Workshop on
the Semantics and Pragmatics of Dialogue, (pp. 69-76).
Barcelona, Spain.
Scheffler, K., &amp; Young, S. (2001). Corpus-based dialogue
simulation for automatic strategy learning and
evaluation. Proc. NAACL Workshop on Adaptation in
Dialogue. Pittsburgh, USA.
Seneff, S. (2002). Response Planning and Generation in the
Mercury Flight Reservation System. Computer Speech
and Language , 16, 283-312.
Smith, R. W., Hipp, D. R., &amp; Biermann, A. W. (1995). An
architecture for voice dialog systems based on prolog-
style theorem proving. Computational Linguistics , 21
(3), 281-320.
Williams, J. D., &amp; Young, S. (2007). Partially observable
Markov decision processes for spoken dialog systems.
Computer Speech &amp; Language , 21 (2), 393-422.
Zue, V., Seneff, S., Glass, J., Polifroni, J., Pao, C., Hazen,
T. J., et al. (2000). JUPITER: a telephone-based
conversational interface for weather information. IEEE
Transactions on Speech and Audio Processing , 8 (1),
85-96.
</reference>
<page confidence="0.998594">
90
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.789466">
<title confidence="0.999677">Dialogue Management Based on Entities and Constraints</title>
<author confidence="0.995646">Yushi Xu Stephanie Seneff</author>
<affiliation confidence="0.932501">Spoken Language Systems Group MIT Computer Science and Artificial Intelligence United States</affiliation>
<email confidence="0.998828">yushixu@csail.mit.edu</email>
<email confidence="0.998828">seneff@csail.mit.edu</email>
<abstract confidence="0.999336285714286">This paper introduces a new dialogue management framework for goal-directed conversations. A declarative specification defines the domain-specific elements and guides the dialogue manager, which communicates with the knowledge sources to complete the specified goal. The user is viewed as another knowledge source. The dialogue manager finds the next action by a mixture of rule-based reasoning and a simple statistical model. Implementation in the flight-reservation domain demonstrates that the framework enables the developer to easily build a conversational dialogue system.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>D Bohus</author>
<author>A I Rudnicky</author>
</authors>
<title>RavenClaw: Dialog Management Using Hierarchical Task Decomposition and an Expectation Agenda.</title>
<date>2003</date>
<booktitle>Proc. Eurospeech.</booktitle>
<location>Geneva, Switzerland.</location>
<contexts>
<context position="3344" citStr="Bohus &amp; Rudnicky, 2003" startWordPosition="484" endWordPosition="487">roblem. The dialogue manager selects actions prescribed by the policy that maximizes the reward function (Lemon &amp; Pietquin, 2007). This machine learning formulation of the problem automates system development, thus freeing the developers from hand-coded rules. Other researchers have continued research on rule-based frameworks, in part because they are easier to control and maintain. One common approach is to allow developers to specify the tasks, either using a conditioned sequential script (Zue, et al., 2000; Seneff, 2002), or using a task hierarchy (Hochberg, Kambhatla, &amp; Roukos, 2002). In (Bohus &amp; Rudnicky, 2003)’s work, a tree of dialogue agents, each of which handles different dialogue actions, is specified to control the dialogue progress. The knowledge has also been specified either by first order logic (Bühler &amp; Minker, 2005) or ontology information (Milward &amp; Beveridge, 2004). 3 Dialogue Manager Figure 1 illustrates the architecture of the proposed dialogue management framework. ComProceedings of SIGDIAL 2010: the 11th Annual Meeting of the Special Interest Group on Discourse and Dialogue, pages 87–90, The University of Tokyo, September 24-25, 2010. p@c 2010 Association for Computational Linguis</context>
</contexts>
<marker>Bohus, Rudnicky, 2003</marker>
<rawString>Bohus, D., &amp; Rudnicky, A. I. (2003). RavenClaw: Dialog Management Using Hierarchical Task Decomposition and an Expectation Agenda. Proc. Eurospeech. Geneva, Switzerland.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Bühler</author>
<author>W Minker</author>
</authors>
<date>2005</date>
<booktitle>A REASONING COMPONENT FOR INFORMATION-SEEKING AND PLANNING DIALOGUES. Spoken Multimodal Human-Computer Dialogue in Mobile Environments ,</booktitle>
<volume>28</volume>
<pages>77--91</pages>
<contexts>
<context position="3566" citStr="Bühler &amp; Minker, 2005" startWordPosition="520" endWordPosition="523">the developers from hand-coded rules. Other researchers have continued research on rule-based frameworks, in part because they are easier to control and maintain. One common approach is to allow developers to specify the tasks, either using a conditioned sequential script (Zue, et al., 2000; Seneff, 2002), or using a task hierarchy (Hochberg, Kambhatla, &amp; Roukos, 2002). In (Bohus &amp; Rudnicky, 2003)’s work, a tree of dialogue agents, each of which handles different dialogue actions, is specified to control the dialogue progress. The knowledge has also been specified either by first order logic (Bühler &amp; Minker, 2005) or ontology information (Milward &amp; Beveridge, 2004). 3 Dialogue Manager Figure 1 illustrates the architecture of the proposed dialogue management framework. ComProceedings of SIGDIAL 2010: the 11th Annual Meeting of the Special Interest Group on Discourse and Dialogue, pages 87–90, The University of Tokyo, September 24-25, 2010. p@c 2010 Association for Computational Linguistics 87 munication with the dialogue manager (DM) is via “E-forms” (Electronic forms), which consist of language-independent key-value pairs. The language understanding and language generation components mediate between th</context>
</contexts>
<marker>Bühler, Minker, 2005</marker>
<rawString>Bühler, D., &amp; Minker, W. (2005). A REASONING COMPONENT FOR INFORMATION-SEEKING AND PLANNING DIALOGUES. Spoken Multimodal Human-Computer Dialogue in Mobile Environments , 28, 77-91.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Frampton</author>
<author>O Lemon</author>
</authors>
<title>Learning more effective dialogue strategies using limited dialogue move features.</title>
<date>2006</date>
<booktitle>Proc. ACL,</booktitle>
<pages>185--192</pages>
<publisher>Sidney, Australia.</publisher>
<contexts>
<context position="2616" citStr="Frampton &amp; Lemon, 2006" startWordPosition="374" endWordPosition="377">d conversation based on entity and knowledge source specification. The user is viewed as a collaborator with the dialogue manager, instead of a problem-raiser. The dialogue manager follows a set of definitions and constraints, and eventually realizes the goal entity. It also incorporates a simple statistical engine to handle certain decisions. 2 Related Work In recent years, statistical methods have gained popularity in dialogue system research. Partially Observable Markov decision processes have been the focus of a number of papers (Levin, Pieraccini, &amp; Eckert, 1997; Scheffler &amp; Young, 2001; Frampton &amp; Lemon, 2006; Williams &amp; Young, 2007). These approaches turn the dialogue interaction strategy into an optimization problem. The dialogue manager selects actions prescribed by the policy that maximizes the reward function (Lemon &amp; Pietquin, 2007). This machine learning formulation of the problem automates system development, thus freeing the developers from hand-coded rules. Other researchers have continued research on rule-based frameworks, in part because they are easier to control and maintain. One common approach is to allow developers to specify the tasks, either using a conditioned sequential script</context>
</contexts>
<marker>Frampton, Lemon, 2006</marker>
<rawString>Frampton, M., &amp; Lemon, O. (2006). Learning more effective dialogue strategies using limited dialogue move features. Proc. ACL, (pp. 185 - 192 ). Sidney, Australia.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Hochberg</author>
<author>N Kambhatla</author>
<author>S Roukos</author>
</authors>
<title>A flexible framework for developing mixed-initiative dialog systems.</title>
<date>2002</date>
<booktitle>Proc. the 3rd SIGdial workshop on Discourse and dialogue ,</booktitle>
<pages>60--63</pages>
<location>Philadelphia, Pennsylvania .</location>
<contexts>
<context position="3314" citStr="Hochberg, Kambhatla, &amp; Roukos, 2002" startWordPosition="478" endWordPosition="482">nteraction strategy into an optimization problem. The dialogue manager selects actions prescribed by the policy that maximizes the reward function (Lemon &amp; Pietquin, 2007). This machine learning formulation of the problem automates system development, thus freeing the developers from hand-coded rules. Other researchers have continued research on rule-based frameworks, in part because they are easier to control and maintain. One common approach is to allow developers to specify the tasks, either using a conditioned sequential script (Zue, et al., 2000; Seneff, 2002), or using a task hierarchy (Hochberg, Kambhatla, &amp; Roukos, 2002). In (Bohus &amp; Rudnicky, 2003)’s work, a tree of dialogue agents, each of which handles different dialogue actions, is specified to control the dialogue progress. The knowledge has also been specified either by first order logic (Bühler &amp; Minker, 2005) or ontology information (Milward &amp; Beveridge, 2004). 3 Dialogue Manager Figure 1 illustrates the architecture of the proposed dialogue management framework. ComProceedings of SIGDIAL 2010: the 11th Annual Meeting of the Special Interest Group on Discourse and Dialogue, pages 87–90, The University of Tokyo, September 24-25, 2010. p@c 2010 Associa</context>
</contexts>
<marker>Hochberg, Kambhatla, Roukos, 2002</marker>
<rawString>Hochberg, J., Kambhatla, N., &amp; Roukos, S. (2002). A flexible framework for developing mixed-initiative dialog systems. Proc. the 3rd SIGdial workshop on Discourse and dialogue , (pp. 60-63). Philadelphia, Pennsylvania .</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Larsson</author>
<author>D Traum</author>
</authors>
<title>Information state and dialogue management in the TRINDI dialogue move engine toolkit.</title>
<date>2000</date>
<journal>Natural Language Engineering ,</journal>
<volume>6</volume>
<pages>3--4</pages>
<contexts>
<context position="7284" citStr="Larsson &amp; Traum, 2000" startWordPosition="1105" endWordPosition="1108"> as comparative/superlative modifiers or customized command-action and task-action mappings, described in more detail later. The entity-based specification has an advantage over an action-based specification in two aspects. First, it is easier to define all the entities in a dialogue domain than to list all the possible actions, so the specification is more compact and readable. Secondly, the completion condition and the KS’s constraints capture the underlying motivation of the dialogue actions. Figure 2. The Main Loop of the DM. 3.2 Dialogue Execution Similar to the Information-State-Update (Larsson &amp; Traum, 2000) idea, the DM maintains an internal state space with all up-to-date information about the entities. It also keeps a task list tree with a root task “complete goal.” In task execution, subtasks (child node) and/or subsequent (right sibling node) tasks are issued. Each time the left-most leaf task is executed, and when a task is completed, the DM checks all tasks and removes those that have been rendered obsolete. Ten basic tasks are pre-defined in the DM, including complete_entity, inquire_ks, and some other tasks related to entity manipulation. A complete_entity task evaluates the completion L</context>
</contexts>
<marker>Larsson, Traum, 2000</marker>
<rawString>Larsson, S., &amp; Traum, D. (2000). Information state and dialogue management in the TRINDI dialogue move engine toolkit. Natural Language Engineering , 6 (3-4), 323-340.</rawString>
</citation>
<citation valid="true">
<authors>
<author>O Lemon</author>
<author>O Pietquin</author>
</authors>
<title>Machine learning for spoken dialog systems.</title>
<date>2007</date>
<booktitle>Proc. INTERSPEECH 2007,</booktitle>
<pages>2685--2688</pages>
<location>Antwerp, Belgium.</location>
<contexts>
<context position="2850" citStr="Lemon &amp; Pietquin, 2007" startWordPosition="409" endWordPosition="412">entually realizes the goal entity. It also incorporates a simple statistical engine to handle certain decisions. 2 Related Work In recent years, statistical methods have gained popularity in dialogue system research. Partially Observable Markov decision processes have been the focus of a number of papers (Levin, Pieraccini, &amp; Eckert, 1997; Scheffler &amp; Young, 2001; Frampton &amp; Lemon, 2006; Williams &amp; Young, 2007). These approaches turn the dialogue interaction strategy into an optimization problem. The dialogue manager selects actions prescribed by the policy that maximizes the reward function (Lemon &amp; Pietquin, 2007). This machine learning formulation of the problem automates system development, thus freeing the developers from hand-coded rules. Other researchers have continued research on rule-based frameworks, in part because they are easier to control and maintain. One common approach is to allow developers to specify the tasks, either using a conditioned sequential script (Zue, et al., 2000; Seneff, 2002), or using a task hierarchy (Hochberg, Kambhatla, &amp; Roukos, 2002). In (Bohus &amp; Rudnicky, 2003)’s work, a tree of dialogue agents, each of which handles different dialogue actions, is specified to cont</context>
</contexts>
<marker>Lemon, Pietquin, 2007</marker>
<rawString>Lemon, O., &amp; Pietquin, O. (2007). Machine learning for spoken dialog systems. Proc. INTERSPEECH 2007, (pp. 2685–2688 ). Antwerp, Belgium.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Levin</author>
<author>R Pieraccini</author>
<author>W Eckert</author>
</authors>
<date>1997</date>
<booktitle>Learning Dialogue Strategies within the Markov Decision Process Framework. Proc. ASRU</booktitle>
<location>Santa Barbara, USA.</location>
<contexts>
<context position="2567" citStr="Levin, Pieraccini, &amp; Eckert, 1997" startWordPosition="365" endWordPosition="369"> introduces a dialogue management framework for goal-directed conversation based on entity and knowledge source specification. The user is viewed as a collaborator with the dialogue manager, instead of a problem-raiser. The dialogue manager follows a set of definitions and constraints, and eventually realizes the goal entity. It also incorporates a simple statistical engine to handle certain decisions. 2 Related Work In recent years, statistical methods have gained popularity in dialogue system research. Partially Observable Markov decision processes have been the focus of a number of papers (Levin, Pieraccini, &amp; Eckert, 1997; Scheffler &amp; Young, 2001; Frampton &amp; Lemon, 2006; Williams &amp; Young, 2007). These approaches turn the dialogue interaction strategy into an optimization problem. The dialogue manager selects actions prescribed by the policy that maximizes the reward function (Lemon &amp; Pietquin, 2007). This machine learning formulation of the problem automates system development, thus freeing the developers from hand-coded rules. Other researchers have continued research on rule-based frameworks, in part because they are easier to control and maintain. One common approach is to allow developers to specify the ta</context>
</contexts>
<marker>Levin, Pieraccini, Eckert, 1997</marker>
<rawString>Levin, E., Pieraccini, R., &amp; Eckert, W. (1997). Learning Dialogue Strategies within the Markov Decision Process Framework. Proc. ASRU 1997. Santa Barbara, USA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Milward</author>
<author>M Beveridge</author>
</authors>
<title>Ontologies and the Structure of Dialogue.</title>
<date>2004</date>
<booktitle>Proc. of the Eighth Workshop on the Semantics and Pragmatics of Dialogue,</booktitle>
<pages>69--76</pages>
<location>Barcelona,</location>
<contexts>
<context position="3618" citStr="Milward &amp; Beveridge, 2004" startWordPosition="527" endWordPosition="530">archers have continued research on rule-based frameworks, in part because they are easier to control and maintain. One common approach is to allow developers to specify the tasks, either using a conditioned sequential script (Zue, et al., 2000; Seneff, 2002), or using a task hierarchy (Hochberg, Kambhatla, &amp; Roukos, 2002). In (Bohus &amp; Rudnicky, 2003)’s work, a tree of dialogue agents, each of which handles different dialogue actions, is specified to control the dialogue progress. The knowledge has also been specified either by first order logic (Bühler &amp; Minker, 2005) or ontology information (Milward &amp; Beveridge, 2004). 3 Dialogue Manager Figure 1 illustrates the architecture of the proposed dialogue management framework. ComProceedings of SIGDIAL 2010: the 11th Annual Meeting of the Special Interest Group on Discourse and Dialogue, pages 87–90, The University of Tokyo, September 24-25, 2010. p@c 2010 Association for Computational Linguistics 87 munication with the dialogue manager (DM) is via “E-forms” (Electronic forms), which consist of language-independent key-value pairs. The language understanding and language generation components mediate between the DM and various knowledge sources (KS), including t</context>
</contexts>
<marker>Milward, Beveridge, 2004</marker>
<rawString>Milward, D., &amp; Beveridge, M. (2004). Ontologies and the Structure of Dialogue. Proc. of the Eighth Workshop on the Semantics and Pragmatics of Dialogue, (pp. 69-76). Barcelona, Spain.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Scheffler</author>
<author>S Young</author>
</authors>
<title>Corpus-based dialogue simulation for automatic strategy learning and evaluation.</title>
<date>2001</date>
<booktitle>Proc. NAACL Workshop on Adaptation in Dialogue.</booktitle>
<location>Pittsburgh, USA.</location>
<contexts>
<context position="2592" citStr="Scheffler &amp; Young, 2001" startWordPosition="370" endWordPosition="373">ramework for goal-directed conversation based on entity and knowledge source specification. The user is viewed as a collaborator with the dialogue manager, instead of a problem-raiser. The dialogue manager follows a set of definitions and constraints, and eventually realizes the goal entity. It also incorporates a simple statistical engine to handle certain decisions. 2 Related Work In recent years, statistical methods have gained popularity in dialogue system research. Partially Observable Markov decision processes have been the focus of a number of papers (Levin, Pieraccini, &amp; Eckert, 1997; Scheffler &amp; Young, 2001; Frampton &amp; Lemon, 2006; Williams &amp; Young, 2007). These approaches turn the dialogue interaction strategy into an optimization problem. The dialogue manager selects actions prescribed by the policy that maximizes the reward function (Lemon &amp; Pietquin, 2007). This machine learning formulation of the problem automates system development, thus freeing the developers from hand-coded rules. Other researchers have continued research on rule-based frameworks, in part because they are easier to control and maintain. One common approach is to allow developers to specify the tasks, either using a condi</context>
</contexts>
<marker>Scheffler, Young, 2001</marker>
<rawString>Scheffler, K., &amp; Young, S. (2001). Corpus-based dialogue simulation for automatic strategy learning and evaluation. Proc. NAACL Workshop on Adaptation in Dialogue. Pittsburgh, USA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Seneff</author>
</authors>
<title>Response Planning and Generation in the Mercury Flight Reservation System.</title>
<date>2002</date>
<journal>Computer Speech and Language ,</journal>
<volume>16</volume>
<pages>283--312</pages>
<contexts>
<context position="3250" citStr="Seneff, 2002" startWordPosition="470" endWordPosition="471">007). These approaches turn the dialogue interaction strategy into an optimization problem. The dialogue manager selects actions prescribed by the policy that maximizes the reward function (Lemon &amp; Pietquin, 2007). This machine learning formulation of the problem automates system development, thus freeing the developers from hand-coded rules. Other researchers have continued research on rule-based frameworks, in part because they are easier to control and maintain. One common approach is to allow developers to specify the tasks, either using a conditioned sequential script (Zue, et al., 2000; Seneff, 2002), or using a task hierarchy (Hochberg, Kambhatla, &amp; Roukos, 2002). In (Bohus &amp; Rudnicky, 2003)’s work, a tree of dialogue agents, each of which handles different dialogue actions, is specified to control the dialogue progress. The knowledge has also been specified either by first order logic (Bühler &amp; Minker, 2005) or ontology information (Milward &amp; Beveridge, 2004). 3 Dialogue Manager Figure 1 illustrates the architecture of the proposed dialogue management framework. ComProceedings of SIGDIAL 2010: the 11th Annual Meeting of the Special Interest Group on Discourse and Dialogue, pages 87–90, </context>
<context position="10213" citStr="Seneff, 2002" startWordPosition="1606" endWordPosition="1607">which is specified by the developer. The weight for each dimension wi is proportional to the count of distinct values of the particular dimension c(Di) and the mutual information between the dimension and the output label. f(x) = argmaxy ajl3jsim(x, di) • S(f(di), yI) (1) ri � 1 � * d �i�(�, d) = �✓�iwi • di�2(�i, di) (2) S x=d WI a c(DI)H(DI, f(D)) (3) 4 Implementation in Flight Domain The framework has been implemented in the flight reservation domain. A grammar was used to parse the user’s input, and a set of generation rules was used to convert the DM’s output Eform into natural language (Seneff, 2002). Two local KSes are utilized: one resolves complex date and time expressions, and one looks up airport/city codes. A local simulated flight DB will be replaced by a real external one in the future. Figure 3 illustrates the logic of the flight reservation domain. The database has two alternative sets of conjunctive constraints “destination &amp; source &amp; date” and “flight# &amp; date”. Two entity types are defined. The itinerary entity type contains a list of flights, a number of expected flights and a price, with completion condition “#flights &gt; 0”. The flight entity type contains members: flight num</context>
</contexts>
<marker>Seneff, 2002</marker>
<rawString>Seneff, S. (2002). Response Planning and Generation in the Mercury Flight Reservation System. Computer Speech and Language , 16, 283-312.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R W Smith</author>
<author>D R Hipp</author>
<author>A W Biermann</author>
</authors>
<title>An architecture for voice dialog systems based on prologstyle theorem proving.</title>
<date>1995</date>
<booktitle>Computational Linguistics ,</booktitle>
<volume>21</volume>
<issue>3</issue>
<pages>281--320</pages>
<contexts>
<context position="1196" citStr="Smith, Hipp, &amp; Biermann, 1995" startWordPosition="160" endWordPosition="164">the next action by a mixture of rule-based reasoning and a simple statistical model. Implementation in the flight-reservation domain demonstrates that the framework enables the developer to easily build a conversational dialogue system. 1 Introduction Conversational systems can be classified into two distinct classes: goal-directed and casual chatting. For goal-directed systems, the system is usually more “knowledgeable” than the user, and it attempts to satisfy user-specified goals. The system’s conversational strategies seek the most efficient path to reach closure and end the conversation (Smith, Hipp, &amp; Biermann, 1995). An essential commonality among different goal-directed applications is that, at the end of a successful conversation, the system presents the user with a “goal” entity, be it a flight itinerary, a route path, or a shopping order. Different conversations result from different properties of the goal entities and different constraints set by the knowledge sources. The properties define the necessary and/or relevant information, such as flight numbers in the flight itinerary. Constraints specify the means to obtain such information. For examples fields “source”, “destination” and “date” are req</context>
</contexts>
<marker>Smith, Hipp, Biermann, 1995</marker>
<rawString>Smith, R. W., Hipp, D. R., &amp; Biermann, A. W. (1995). An architecture for voice dialog systems based on prologstyle theorem proving. Computational Linguistics , 21 (3), 281-320.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J D Williams</author>
<author>S Young</author>
</authors>
<title>Partially observable Markov decision processes for spoken dialog systems.</title>
<date>2007</date>
<journal>Computer Speech &amp; Language ,</journal>
<volume>21</volume>
<issue>2</issue>
<pages>393--422</pages>
<contexts>
<context position="2641" citStr="Williams &amp; Young, 2007" startWordPosition="378" endWordPosition="381">entity and knowledge source specification. The user is viewed as a collaborator with the dialogue manager, instead of a problem-raiser. The dialogue manager follows a set of definitions and constraints, and eventually realizes the goal entity. It also incorporates a simple statistical engine to handle certain decisions. 2 Related Work In recent years, statistical methods have gained popularity in dialogue system research. Partially Observable Markov decision processes have been the focus of a number of papers (Levin, Pieraccini, &amp; Eckert, 1997; Scheffler &amp; Young, 2001; Frampton &amp; Lemon, 2006; Williams &amp; Young, 2007). These approaches turn the dialogue interaction strategy into an optimization problem. The dialogue manager selects actions prescribed by the policy that maximizes the reward function (Lemon &amp; Pietquin, 2007). This machine learning formulation of the problem automates system development, thus freeing the developers from hand-coded rules. Other researchers have continued research on rule-based frameworks, in part because they are easier to control and maintain. One common approach is to allow developers to specify the tasks, either using a conditioned sequential script (Zue, et al., 2000; Sene</context>
</contexts>
<marker>Williams, Young, 2007</marker>
<rawString>Williams, J. D., &amp; Young, S. (2007). Partially observable Markov decision processes for spoken dialog systems. Computer Speech &amp; Language , 21 (2), 393-422.</rawString>
</citation>
<citation valid="true">
<authors>
<author>V Zue</author>
<author>S Seneff</author>
<author>J Glass</author>
<author>J Polifroni</author>
<author>C Pao</author>
<author>T J Hazen</author>
</authors>
<title>JUPITER: a telephone-based conversational interface for weather information.</title>
<date>2000</date>
<booktitle>IEEE Transactions on Speech and Audio Processing ,</booktitle>
<volume>8</volume>
<issue>1</issue>
<pages>85--96</pages>
<contexts>
<context position="3235" citStr="Zue, et al., 2000" startWordPosition="466" endWordPosition="469">Williams &amp; Young, 2007). These approaches turn the dialogue interaction strategy into an optimization problem. The dialogue manager selects actions prescribed by the policy that maximizes the reward function (Lemon &amp; Pietquin, 2007). This machine learning formulation of the problem automates system development, thus freeing the developers from hand-coded rules. Other researchers have continued research on rule-based frameworks, in part because they are easier to control and maintain. One common approach is to allow developers to specify the tasks, either using a conditioned sequential script (Zue, et al., 2000; Seneff, 2002), or using a task hierarchy (Hochberg, Kambhatla, &amp; Roukos, 2002). In (Bohus &amp; Rudnicky, 2003)’s work, a tree of dialogue agents, each of which handles different dialogue actions, is specified to control the dialogue progress. The knowledge has also been specified either by first order logic (Bühler &amp; Minker, 2005) or ontology information (Milward &amp; Beveridge, 2004). 3 Dialogue Manager Figure 1 illustrates the architecture of the proposed dialogue management framework. ComProceedings of SIGDIAL 2010: the 11th Annual Meeting of the Special Interest Group on Discourse and Dialogue</context>
</contexts>
<marker>Zue, Seneff, Glass, Polifroni, Pao, Hazen, 2000</marker>
<rawString>Zue, V., Seneff, S., Glass, J., Polifroni, J., Pao, C., Hazen, T. J., et al. (2000). JUPITER: a telephone-based conversational interface for weather information. IEEE Transactions on Speech and Audio Processing , 8 (1), 85-96.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>