<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.008975">
<title confidence="0.995681">
Maximizing Top-down Constraints for Unification-based Systems
</title>
<author confidence="0.997709">
Noriko Tomuro
</author>
<affiliation confidence="0.9913175">
School of Computer Science, Telecommunications and Information Systems
DePaul University
</affiliation>
<address confidence="0.4160835">
Chicago, IL 60604
cphdnt Oted. cs. depaul.edu
</address>
<sectionHeader confidence="0.881975" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999650857142857">
A left-corner parsing algorithm with top-
down filtering has been reported to show
very efficient performance for unification-
based systems. However, due to the non-
termination of parsing with left-recursive
grammars, top-down constraints must be
weakened. In this paper, a general method
of maximizing top-down constraints is pro-
posed. The method provides a procedure
to dynamically compute *restrictor*, a
minimum set of features involved in an in-
finite loop for every propagation path; thus
top-down constraints are maximally prop-
agated.
</bodyText>
<sectionHeader confidence="0.996293" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.9999782">
A left-corner parsing algorithm with top-down filter-
ing has been reported to show very efficient perfor-
mance for unification-based systems (Carroll, 1994).
In particular, top-down filtering seems to be very ef-
fective in increasing parse efficiency (Shann, 1991).
Ideally all top-down expectation should be propa-
gated down to the input word so that unsuccess-
ful rule applications are pruned at the earliest time.
However, in the context of unification-based parsing,
left-recursive grammars have the formal power of a
Turing machine, therefore detection of all infinite
loops due to left-recursion is impossible (Shieber,
1992). So, top-down constraints must be weakened
in order for parsing to be guaranteed to terminate.
In order to solve the nontermination problem,
Shieber (1985) proposes restrictor, a statically pre-
defined set of features to consider in propagation,
and restriction, a filtering function which removes
the features not in restrictor from top-down expec-
tation. However, not only does this approach fail to
provide a method to automatically generate the re-
strictor set, it may weaken the predicative power of
top-down expectation more than necessary: a glob-
ally defined restrictor can only specify the least com-
mon features for all propagation paths.
In this paper, a general method of maximizing
top-down constraints is proposed. The method
provides a procedure to dynamically compute
*restrictor*, a minimum set of features involved in
an infinite loop, for every propagation path. Fea-
tures in this set are selected by the detection func-
tion, and will be ignored in top-down propagation.
Using *restrictor*, only the relevant features par-
ticular to the propagation path are ignored, thus
top-down constraints are maximally propagated.
</bodyText>
<sectionHeader confidence="0.804546" genericHeader="introduction">
2 Notation
</sectionHeader>
<bodyText confidence="0.99969105">
We use notation from the PATR-II formalism
(Shieber, 1986) and (Shieber, 1992). Directed
acyclic graphs (dags) are adopted as the representa-
tion model. The symbol = is used to represent the
equality relation in the unification equations, and
the symbol • used in the form of pl • p2 represents
the path concatenation of pl and p2.
The subsumption relation is defined as &amp;quot;Dag D
subsumes dag D&apos; if D is more general than D&apos; .&amp;quot;
The unification of D and D&apos; is notated by D U D&apos; .
The extraction function D/p1 extracts the subdag
under path pl for a given D, and the embedding
function D\ pl injects D into the enclosing dag D&apos;
such that D&apos;/pl = D. The filtering function p is
similar to (Shieber, 1992): p(D) returns a copy of D
in which some features may be removed. Note that
in this paper *restrictor* specifies the features to
be removed by p, whereas in (Shieber, 1985, 1992)
restrictor specifies the features to be retained by re-
striction which is equivalent to p.
</bodyText>
<sectionHeader confidence="0.996554" genericHeader="method">
3 Top-down Propagation
</sectionHeader>
<bodyText confidence="0.998855555555555">
Top-down propagation can be precomputed to form
a reachability table. Each entry in the table is a
compiled dag which represents the relation between
a non-terminal category and a rule used to rewrite
the constituents in the reachability relation (i.e., re-
flexive, transitive closure of the left-corner path).
For example, consider the following fragment of
a grammar used in the syntax/semantics integrated
system called LINK (Lytinen, 1992):
</bodyText>
<page confidence="0.890902">
381
</page>
<equation confidence="0.702362">
D(1) D(2) D(3) D(4)
</equation>
<figureCaption confidence="0.906479">
Figure 1: DAGs used in the example
</figureCaption>
<equation confidence="0.964164333333333">
rl : NP0 -- NPi POS NP2
(NP0 head) = (N P2 head)
(NP0 head sem owner) = (NIA head sem)
</equation>
<bodyText confidence="0.983620514285715">
(This rule is used to parse phrases such as &amp;quot;Kris&apos;s
desk&amp;quot;.)
The dag D(1) in Figure l&apos; represents the initial
application of rl to the category NP. Note that
the subdag under the lc arc is the rule used to
rewrite the constituent on the left-corner path, and
the paths from the top node represent which top-
down constraints are propagated to the lower level.
Top-down propagation works as follows: given a
dag D that represents a reachability relation and
a rule dag R whose left-hand side category (i.e.,
root) is the same as D&apos;s left-corner category (i.e.,
under its (lc 1) path), the resulting dag is D1 =
p(D&apos;) U (Ft\lc), where D&apos; is a copy of D in which
all the numbered arcs and lc arc are deleted and
the subdag which used to be under the (lc 1) path
is promoted to lie under the lc arc. Dags after the
next two recursive applications of rl (D(2) and D(3)
respectively2) are shown in Figure 1.
Notice the filtering function p is applied only to
D&apos;. In the case when p(D1) = nil, the top node in
D1 will have no connections to the rule dag under
the lc arc. This means no top-down constraints are
propagated to the lower level, therefore the parsing
becomes pure bottom-up.
In many unification-based systems, subsumption
is used to avoid redundancy: a dag is recorded in
the table if it is not subsumed by any other one.
Therefore, if a newly created dag is incompatible
or more general than existing dags, rule application
continues. In the above example, D(2) is incompat-
ible with D(1) and therefore gets entered into the
table. The owner arc keeps extending in the subse-
quent recursive applications (as in D(3)), thus the
propagation goes into an infinite loop.
</bodyText>
<footnote confidence="0.99336">
1Category symbols are directly indicated in the dag
nodes for simplicity.
2In this case, p is assumed to be an identity function.
</footnote>
<subsectionHeader confidence="0.984609">
3.1 Proposed Method
</subsectionHeader>
<bodyText confidence="0.999984290322581">
Let A be a dag created by the first application of
the rule R and B be a dag created by the second
application during the top-down propagation.3 In
the proposed method, A and B are first checked for
subsumption. If B is subsumed by A, the propaga-
tion for this path terminates. Otherwise a possible
loop is detected. The detection function (described
in the next subsection) is called on A and B and
selected features are added to the *restrictor* set.4
Then, using the updated *restrictor*, propagation
is re-done from A.
When R is applied again yielding B&apos;, while B&apos;
is not subsumed by A, the following process is re-
peated: if B&apos; is incompatible with A, the detection
function is called on A and B&apos; and propagation is re-
done from A. If B&apos; is more general than A, then A
is replaced by B&apos; (thereby keeping the most general
dag for the path) and propagation is re-done from
B&apos;. Otherwise the process stops for this propagation
path. Thus, the propagation will terminate when
enough features are detected, or when *restrictor*
includes all the (finite number of) features in the
grammar.5
In the example, when the detection function is
called on D(1) and D(2) after the first recursive ap-
plication, the feature owner is selected and added to
*restrictor*. After the propagation is re-done from
D(1), the resulting dag D(4) becomes more general
than D(1).6 Then D(1) is replaced by D(4), and
the propagation is re-done once again. This time
it results the same D(4), therefore the propagation
</bodyText>
<footnote confidence="0.955464222222222">
&apos;In the case of indirect recursion, there are some in-
tervening rule applications between A and B.
4A separate *restrictor* must be kept for each prop-
agation path.
In reality, category feature will never be in
*restrictor* because the same rule R is applied to derive
both A and B&apos;.
6 Remember D(4) ------ p(D(1)&apos;) LI (r1 \ 1c) where p filters
out owner arc.
</footnote>
<page confidence="0.996374">
382
</page>
<bodyText confidence="0.743435">
terminates.
</bodyText>
<subsectionHeader confidence="0.987756">
3.2 Detection Function
</subsectionHeader>
<bodyText confidence="0.999774555555555">
The detection function compares two dags X and Y
by checking every constraint (unification equation)
x in X with any inconsistent or more general con-
straint y in Y. If such a constraint is found, the
function selects a path in x or y and detects its last
arc/feature as being involved in the possible loop.7
If x is the path constraint pl = p2 where pl and
p2 are paths of length &gt; 1, features may be detected
in the following cases:8
</bodyText>
<listItem confidence="0.9813679375">
• (case 1) If both pl and p2 exist in Y, and there
exists a more general constraint y in Y in the
form pl p3 p2 •p3 (length of p3 is also &gt; 1),
the path p3 is selected;
• (case 2) If both pl and p2 exist in Y, but the
subdag under pl and the subdag under p2 do
not unify, or if neither pl nor p2 exists in Y,
whichever of pl or p2 does not contain the lc
arc, or either if they both contain the lc arc, is
selected; and
• (case 3) If either pl or p2 does not exist in Y,
the one which does not exist in Y is selected.
If x is the constant constraint pl c (where c is
some constant), features may be detected in the fol-
lowing cases:
• (case 4) If there exists an incompatible con-
</listItem>
<bodyText confidence="0.798658">
straint y of the form pl = d where d c in
Y, or if there is no path pl in Y, pl is selected;
and
</bodyText>
<listItem confidence="0.99808">
• (case 5) If there exists an incompatible con-
</listItem>
<bodyText confidence="0.8190145">
straint y of the form pl • p2 c, then p2 is
selected.
</bodyText>
<sectionHeader confidence="0.999129" genericHeader="related work">
4 Related Work
</sectionHeader>
<bodyText confidence="0.999967294117647">
A similar solution to the nontermination problem
with unification grammars in Prolog is proposed in
(Samuelsson, 1993). In this method, an operation
called anti-unification (often referred to as general-
ization as the counterpart of unification) is applied
to the root and leaf terms of a cyclic propagation,
and the resulting term is stored in the reachablity
table as the result of applying restriction on both
terms. Another approach taken in (Haas, 1989)
eliminates the cyclic propagation by replacing the
features in the root and leaf terms with new vari-
ables.
The method proposed in this paper is more gen-
eral than the above approaches: if the selection or-
dering is imposed in the detection function, features
in *restrictor* can be collected incrementally as the
cyclic propagations are repeated. Thus, this method
</bodyText>
<footnote confidence="0.920994">
7This scheme may be rather conservative.
8Note the cases in this section do not represent all
possible situations.
</footnote>
<bodyText confidence="0.86817">
is able to create a less restrictive *restrictor* than
these other approaches.
</bodyText>
<sectionHeader confidence="0.958085" genericHeader="conclusions">
5 Discussion and Future Work
</sectionHeader>
<bodyText confidence="0.999986782608696">
The proposed method has an obvious difficulty:
the complexity caused by the repeated propaga-
tions could become overwhelming for some gram-
mars. However, in the experiment on LINK sys-
tem using a fairly broad grammar (over 130 rules),
precompilation terminated with only a marginally
longer processing time.
In the experiment, all features (around 40 syntac-
tic/semantic features) except for one in the example
in this paper were able to be used in propagation.
In the preliminary analysis, the number of edges en-
tered into the chart has decreased by 30% compared
to when only the category feature (i.e., context-free
backbone) was used in propagation.
For future work, we intend to apply the proposed
method to other grammars. By doing the empiri-
cal analysis of precompilation and parse efficiency
for different grammars, we will be able to conclude
the practical applicability of the proposed method.
We also indend to do more exhaustive case analysis
and investigate the selection ordering of the detec-
tion function. Although the current definition covers
most cases, it is by no means complete.
</bodyText>
<sectionHeader confidence="0.998067" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999626066666667">
Carroll, J. (1994). Relating complexity to practical
performance in parsing with wide-coverage uni-
fication grammars. In Proceedings of the 32nd
Annual Meeting of the Association for Computa-
tional Linguistics, pp. 287-293.
Haas, A. (1989). A parsing algorithm for unification
grammar, Computational Linguistics, 15(4), pp.
219-232.
Lytinen, S. (1992). A unification-based, integrated
natural language processing system. Computers
and Mathematics with Applications, 23(6-9), pp.
403-418.
Samuelsson, C. (1993). Avoiding non-termination
in unification grammars. In Proceedings of Natu-
ral Language Understanding and Logic Program-
ming IV, Nara, Japan.
Shann, P. (1991). Experiments with GLR and chart
parsing. In Tomita, M. Generalized LR Parsing.
Boston: Kluwer Academic Publishers, p. 17-34.
Shieber, S. (1985). Using restriction to extend
parsing algorithms for complex-feature-based for-
malisms. In Proceedings of the 23rd Annual
Meeting of the Association for Computational
Linguistics, Chicago, IL, pp. 145-152.
Shieber, S. (1986). An Introduction to Unification-
Based Approaches to Grammar. Stanford, CA:
Center for the Study of Language and Informa-
tion.
Shieber, S. (1992). Constraint-based Grammar For-
malisms. Cambridge, MA: MIT Press.
</reference>
<page confidence="0.999364">
383
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.792702">
<title confidence="0.999989">Maximizing Top-down Constraints for Unification-based Systems</title>
<author confidence="0.98414">Noriko Tomuro</author>
<affiliation confidence="0.999547">School of Computer Science, Telecommunications and Information Systems DePaul University</affiliation>
<address confidence="0.999724">Chicago, IL 60604</address>
<email confidence="0.978404">cphdntOted.cs.depaul.edu</email>
<abstract confidence="0.9881906">A left-corner parsing algorithm with topdown filtering has been reported to show very efficient performance for unificationbased systems. However, due to the nontermination of parsing with left-recursive grammars, top-down constraints must be weakened. In this paper, a general method of maximizing top-down constraints is proposed. The method provides a procedure dynamically compute minimum set of features involved in an infinite loop for every propagation path; thus top-down constraints are maximally propagated.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>J Carroll</author>
</authors>
<title>Relating complexity to practical performance in parsing with wide-coverage unification grammars.</title>
<date>1994</date>
<booktitle>In Proceedings of the 32nd Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>287--293</pages>
<contexts>
<context position="926" citStr="Carroll, 1994" startWordPosition="128" endWordPosition="129">ent performance for unificationbased systems. However, due to the nontermination of parsing with left-recursive grammars, top-down constraints must be weakened. In this paper, a general method of maximizing top-down constraints is proposed. The method provides a procedure to dynamically compute *restrictor*, a minimum set of features involved in an infinite loop for every propagation path; thus top-down constraints are maximally propagated. 1 Introduction A left-corner parsing algorithm with top-down filtering has been reported to show very efficient performance for unification-based systems (Carroll, 1994). In particular, top-down filtering seems to be very effective in increasing parse efficiency (Shann, 1991). Ideally all top-down expectation should be propagated down to the input word so that unsuccessful rule applications are pruned at the earliest time. However, in the context of unification-based parsing, left-recursive grammars have the formal power of a Turing machine, therefore detection of all infinite loops due to left-recursion is impossible (Shieber, 1992). So, top-down constraints must be weakened in order for parsing to be guaranteed to terminate. In order to solve the nontermina</context>
</contexts>
<marker>Carroll, 1994</marker>
<rawString>Carroll, J. (1994). Relating complexity to practical performance in parsing with wide-coverage unification grammars. In Proceedings of the 32nd Annual Meeting of the Association for Computational Linguistics, pp. 287-293.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Haas</author>
</authors>
<title>A parsing algorithm for unification grammar,</title>
<date>1989</date>
<journal>Computational Linguistics,</journal>
<volume>15</volume>
<issue>4</issue>
<pages>219--232</pages>
<contexts>
<context position="9608" citStr="Haas, 1989" startWordPosition="1667" endWordPosition="1668">s no path pl in Y, pl is selected; and • (case 5) If there exists an incompatible constraint y of the form pl • p2 c, then p2 is selected. 4 Related Work A similar solution to the nontermination problem with unification grammars in Prolog is proposed in (Samuelsson, 1993). In this method, an operation called anti-unification (often referred to as generalization as the counterpart of unification) is applied to the root and leaf terms of a cyclic propagation, and the resulting term is stored in the reachablity table as the result of applying restriction on both terms. Another approach taken in (Haas, 1989) eliminates the cyclic propagation by replacing the features in the root and leaf terms with new variables. The method proposed in this paper is more general than the above approaches: if the selection ordering is imposed in the detection function, features in *restrictor* can be collected incrementally as the cyclic propagations are repeated. Thus, this method 7This scheme may be rather conservative. 8Note the cases in this section do not represent all possible situations. is able to create a less restrictive *restrictor* than these other approaches. 5 Discussion and Future Work The proposed </context>
</contexts>
<marker>Haas, 1989</marker>
<rawString>Haas, A. (1989). A parsing algorithm for unification grammar, Computational Linguistics, 15(4), pp. 219-232.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Lytinen</author>
</authors>
<title>A unification-based, integrated natural language processing system.</title>
<date>1992</date>
<journal>Computers and Mathematics with Applications,</journal>
<volume>23</volume>
<issue>6</issue>
<pages>403--418</pages>
<contexts>
<context position="3972" citStr="Lytinen, 1992" startWordPosition="622" endWordPosition="623">tures to be removed by p, whereas in (Shieber, 1985, 1992) restrictor specifies the features to be retained by restriction which is equivalent to p. 3 Top-down Propagation Top-down propagation can be precomputed to form a reachability table. Each entry in the table is a compiled dag which represents the relation between a non-terminal category and a rule used to rewrite the constituents in the reachability relation (i.e., reflexive, transitive closure of the left-corner path). For example, consider the following fragment of a grammar used in the syntax/semantics integrated system called LINK (Lytinen, 1992): 381 D(1) D(2) D(3) D(4) Figure 1: DAGs used in the example rl : NP0 -- NPi POS NP2 (NP0 head) = (N P2 head) (NP0 head sem owner) = (NIA head sem) (This rule is used to parse phrases such as &amp;quot;Kris&apos;s desk&amp;quot;.) The dag D(1) in Figure l&apos; represents the initial application of rl to the category NP. Note that the subdag under the lc arc is the rule used to rewrite the constituent on the left-corner path, and the paths from the top node represent which topdown constraints are propagated to the lower level. Top-down propagation works as follows: given a dag D that represents a reachability relation an</context>
</contexts>
<marker>Lytinen, 1992</marker>
<rawString>Lytinen, S. (1992). A unification-based, integrated natural language processing system. Computers and Mathematics with Applications, 23(6-9), pp. 403-418.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Samuelsson</author>
</authors>
<title>Avoiding non-termination in unification grammars.</title>
<date>1993</date>
<booktitle>In Proceedings of Natural Language Understanding and Logic Programming IV,</booktitle>
<location>Nara, Japan.</location>
<contexts>
<context position="9269" citStr="Samuelsson, 1993" startWordPosition="1612" endWordPosition="1613">the lc arc, is selected; and • (case 3) If either pl or p2 does not exist in Y, the one which does not exist in Y is selected. If x is the constant constraint pl c (where c is some constant), features may be detected in the following cases: • (case 4) If there exists an incompatible constraint y of the form pl = d where d c in Y, or if there is no path pl in Y, pl is selected; and • (case 5) If there exists an incompatible constraint y of the form pl • p2 c, then p2 is selected. 4 Related Work A similar solution to the nontermination problem with unification grammars in Prolog is proposed in (Samuelsson, 1993). In this method, an operation called anti-unification (often referred to as generalization as the counterpart of unification) is applied to the root and leaf terms of a cyclic propagation, and the resulting term is stored in the reachablity table as the result of applying restriction on both terms. Another approach taken in (Haas, 1989) eliminates the cyclic propagation by replacing the features in the root and leaf terms with new variables. The method proposed in this paper is more general than the above approaches: if the selection ordering is imposed in the detection function, features in </context>
</contexts>
<marker>Samuelsson, 1993</marker>
<rawString>Samuelsson, C. (1993). Avoiding non-termination in unification grammars. In Proceedings of Natural Language Understanding and Logic Programming IV, Nara, Japan.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Shann</author>
</authors>
<title>Experiments with GLR and chart parsing.</title>
<date>1991</date>
<booktitle>In Tomita, M. Generalized LR Parsing.</booktitle>
<pages>17--34</pages>
<publisher>Kluwer Academic Publishers,</publisher>
<location>Boston:</location>
<contexts>
<context position="1033" citStr="Shann, 1991" startWordPosition="144" endWordPosition="145">ve grammars, top-down constraints must be weakened. In this paper, a general method of maximizing top-down constraints is proposed. The method provides a procedure to dynamically compute *restrictor*, a minimum set of features involved in an infinite loop for every propagation path; thus top-down constraints are maximally propagated. 1 Introduction A left-corner parsing algorithm with top-down filtering has been reported to show very efficient performance for unification-based systems (Carroll, 1994). In particular, top-down filtering seems to be very effective in increasing parse efficiency (Shann, 1991). Ideally all top-down expectation should be propagated down to the input word so that unsuccessful rule applications are pruned at the earliest time. However, in the context of unification-based parsing, left-recursive grammars have the formal power of a Turing machine, therefore detection of all infinite loops due to left-recursion is impossible (Shieber, 1992). So, top-down constraints must be weakened in order for parsing to be guaranteed to terminate. In order to solve the nontermination problem, Shieber (1985) proposes restrictor, a statically predefined set of features to consider in pr</context>
</contexts>
<marker>Shann, 1991</marker>
<rawString>Shann, P. (1991). Experiments with GLR and chart parsing. In Tomita, M. Generalized LR Parsing. Boston: Kluwer Academic Publishers, p. 17-34.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Shieber</author>
</authors>
<title>Using restriction to extend parsing algorithms for complex-feature-based formalisms.</title>
<date>1985</date>
<booktitle>In Proceedings of the 23rd Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>145--152</pages>
<location>Chicago, IL,</location>
<contexts>
<context position="1554" citStr="Shieber (1985)" startWordPosition="223" endWordPosition="224">r, top-down filtering seems to be very effective in increasing parse efficiency (Shann, 1991). Ideally all top-down expectation should be propagated down to the input word so that unsuccessful rule applications are pruned at the earliest time. However, in the context of unification-based parsing, left-recursive grammars have the formal power of a Turing machine, therefore detection of all infinite loops due to left-recursion is impossible (Shieber, 1992). So, top-down constraints must be weakened in order for parsing to be guaranteed to terminate. In order to solve the nontermination problem, Shieber (1985) proposes restrictor, a statically predefined set of features to consider in propagation, and restriction, a filtering function which removes the features not in restrictor from top-down expectation. However, not only does this approach fail to provide a method to automatically generate the restrictor set, it may weaken the predicative power of top-down expectation more than necessary: a globally defined restrictor can only specify the least common features for all propagation paths. In this paper, a general method of maximizing top-down constraints is proposed. The method provides a procedure</context>
<context position="3409" citStr="Shieber, 1985" startWordPosition="536" endWordPosition="537">sed in the form of pl • p2 represents the path concatenation of pl and p2. The subsumption relation is defined as &amp;quot;Dag D subsumes dag D&apos; if D is more general than D&apos; .&amp;quot; The unification of D and D&apos; is notated by D U D&apos; . The extraction function D/p1 extracts the subdag under path pl for a given D, and the embedding function D\ pl injects D into the enclosing dag D&apos; such that D&apos;/pl = D. The filtering function p is similar to (Shieber, 1992): p(D) returns a copy of D in which some features may be removed. Note that in this paper *restrictor* specifies the features to be removed by p, whereas in (Shieber, 1985, 1992) restrictor specifies the features to be retained by restriction which is equivalent to p. 3 Top-down Propagation Top-down propagation can be precomputed to form a reachability table. Each entry in the table is a compiled dag which represents the relation between a non-terminal category and a rule used to rewrite the constituents in the reachability relation (i.e., reflexive, transitive closure of the left-corner path). For example, consider the following fragment of a grammar used in the syntax/semantics integrated system called LINK (Lytinen, 1992): 381 D(1) D(2) D(3) D(4) Figure 1: D</context>
</contexts>
<marker>Shieber, 1985</marker>
<rawString>Shieber, S. (1985). Using restriction to extend parsing algorithms for complex-feature-based formalisms. In Proceedings of the 23rd Annual Meeting of the Association for Computational Linguistics, Chicago, IL, pp. 145-152.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Shieber</author>
</authors>
<title>An Introduction to UnificationBased Approaches to Grammar. Stanford, CA: Center for the Study of Language and Information.</title>
<date>1986</date>
<contexts>
<context position="2598" citStr="Shieber, 1986" startWordPosition="384" endWordPosition="385">ecify the least common features for all propagation paths. In this paper, a general method of maximizing top-down constraints is proposed. The method provides a procedure to dynamically compute *restrictor*, a minimum set of features involved in an infinite loop, for every propagation path. Features in this set are selected by the detection function, and will be ignored in top-down propagation. Using *restrictor*, only the relevant features particular to the propagation path are ignored, thus top-down constraints are maximally propagated. 2 Notation We use notation from the PATR-II formalism (Shieber, 1986) and (Shieber, 1992). Directed acyclic graphs (dags) are adopted as the representation model. The symbol = is used to represent the equality relation in the unification equations, and the symbol • used in the form of pl • p2 represents the path concatenation of pl and p2. The subsumption relation is defined as &amp;quot;Dag D subsumes dag D&apos; if D is more general than D&apos; .&amp;quot; The unification of D and D&apos; is notated by D U D&apos; . The extraction function D/p1 extracts the subdag under path pl for a given D, and the embedding function D\ pl injects D into the enclosing dag D&apos; such that D&apos;/pl = D. The filtering </context>
</contexts>
<marker>Shieber, 1986</marker>
<rawString>Shieber, S. (1986). An Introduction to UnificationBased Approaches to Grammar. Stanford, CA: Center for the Study of Language and Information.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Shieber</author>
</authors>
<title>Constraint-based Grammar Formalisms.</title>
<date>1992</date>
<publisher>MIT Press.</publisher>
<location>Cambridge, MA:</location>
<contexts>
<context position="1398" citStr="Shieber, 1992" startWordPosition="199" endWordPosition="200">r parsing algorithm with top-down filtering has been reported to show very efficient performance for unification-based systems (Carroll, 1994). In particular, top-down filtering seems to be very effective in increasing parse efficiency (Shann, 1991). Ideally all top-down expectation should be propagated down to the input word so that unsuccessful rule applications are pruned at the earliest time. However, in the context of unification-based parsing, left-recursive grammars have the formal power of a Turing machine, therefore detection of all infinite loops due to left-recursion is impossible (Shieber, 1992). So, top-down constraints must be weakened in order for parsing to be guaranteed to terminate. In order to solve the nontermination problem, Shieber (1985) proposes restrictor, a statically predefined set of features to consider in propagation, and restriction, a filtering function which removes the features not in restrictor from top-down expectation. However, not only does this approach fail to provide a method to automatically generate the restrictor set, it may weaken the predicative power of top-down expectation more than necessary: a globally defined restrictor can only specify the leas</context>
<context position="2618" citStr="Shieber, 1992" startWordPosition="387" endWordPosition="388">on features for all propagation paths. In this paper, a general method of maximizing top-down constraints is proposed. The method provides a procedure to dynamically compute *restrictor*, a minimum set of features involved in an infinite loop, for every propagation path. Features in this set are selected by the detection function, and will be ignored in top-down propagation. Using *restrictor*, only the relevant features particular to the propagation path are ignored, thus top-down constraints are maximally propagated. 2 Notation We use notation from the PATR-II formalism (Shieber, 1986) and (Shieber, 1992). Directed acyclic graphs (dags) are adopted as the representation model. The symbol = is used to represent the equality relation in the unification equations, and the symbol • used in the form of pl • p2 represents the path concatenation of pl and p2. The subsumption relation is defined as &amp;quot;Dag D subsumes dag D&apos; if D is more general than D&apos; .&amp;quot; The unification of D and D&apos; is notated by D U D&apos; . The extraction function D/p1 extracts the subdag under path pl for a given D, and the embedding function D\ pl injects D into the enclosing dag D&apos; such that D&apos;/pl = D. The filtering function p is simila</context>
</contexts>
<marker>Shieber, 1992</marker>
<rawString>Shieber, S. (1992). Constraint-based Grammar Formalisms. Cambridge, MA: MIT Press.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>