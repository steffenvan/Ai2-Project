<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000005">
<title confidence="0.9990345">
Axiomatization of Restricted Non-Projective Dependency Trees through
Finite-State Constraints that Analyse Crossing Bracketings
</title>
<author confidence="0.979295">
Anssi YLI-JYRA¨
</author>
<affiliation confidence="0.990111">
Department of General Linguistics, P.O. Box 9, FIN-00014 University of Helsinki
</affiliation>
<email confidence="0.986067">
anssi.yli-jyra@helsinki.fi
</email>
<sectionHeader confidence="0.993628" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999972727272727">
In this paper, a representation for syntactic depen-
dency trees (D-trees) is defined through a finite set
of axioms. The axiomatized representation consti-
tutes a string that can encode non-projective D-trees
of restricted structural complexity. Upper-bounds
for the structural complexity of these D-trees are
fixed through the following new parameters: proper
embracement depth , nested crossing depth , and
non-projectivity depth .
In the representation, syntactic dependencies be-
tween words are indicated with pairs of brackets.
When the brackets indicate dependencies that cross
each other, the crossing pairs of brackets are dis-
tinguished by assigning separate colors to each of
them. These colors are allocated in a way (Yli-Jyr¨a
and Nyk¨anen, 2004) that ensures a unique repre-
sentation for each D-tree, and entails that languages
whose nested crossing depth is not bounded cannot
be captured using a fixed number of colors.
Although the axiomatization is finite, it ensures
that the represented dependency structures are trees.
This is possible because the described D-trees have
bounded non-projectivity depth. The axioms are
also regular because proper embracement depth of
represented D-trees is bounded.
Our representation suggests that extra strong gen-
erative power can be squeezed out of finite-state
equivalent grammars. Bracketed D-tree representa-
tions (cf. annotated sentences) are structural de-
scriptions that are assigned to their subsequences
(cf. generated strings or yields of trees) where
brackets and other special-purpose characters have
been omitted.
</bodyText>
<sectionHeader confidence="0.998825" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.998813583333333">
Recently, many dependency syntactic parsers using
finite-state machines (FSMs) have been presented
(Kahane et al., 1998; Elworthy, 2000; Nasr et al.,
2002; Oflazer, 2003; Yli-Jyr¨a, 2004a). This arti-
cle shows that a finite-state equivalent grammatical
system is capable of assigning even non-projective
syntactic dependency trees — or their representa-
tions — to terminal strings. An appropriate repre-
sentation is conveniently defined through a set of
axioms presented in this work. The complexity of
the structures assigned is bounded by some special
parameters.
</bodyText>
<subsectionHeader confidence="0.98036">
1.1 Motivation
</subsectionHeader>
<bodyText confidence="0.999784617021277">
We argue that the possibilities of FSMs have not
been fully exploited in dependency syntax. So
far, almost all the dependency parsers that use
FSMs take them merely as subroutines in a sys-
tem whose generative power exceeds regular lan-
guages. Although there are some pure finite-state
approaches to surface syntactic parsing (Krauwer
and des Tombe, 1981; Abney, 1996; Koskenniemi,
1997; Yli-Jyr¨a, 2004a) there seems to be a lack of a
pure finite-state approach that is capable of assign-
ing non-projective dependency structures to the in-
put strings.
The applicability of finite-state systems to natural
language syntax has been questioned since Chom-
sky (1957), who suggested that center embedding
in natural language is unbounded. In contrast to
this view, a recent corpus-based study (Karlsson, in
print) suggests an opposite generalisation according
to which there is an absolute limit (2 – 3) on center-
embedding of subordinate clauses in matrix clauses,
on top of which there are also category restrictions
on which type of center-embeddings are allowed at
each embedding level. Although such limits may
lack some mathematical elegancy, they may entail
some other kind of mathematical beauty (e.g. the
closure properties of regular languages) and, more-
over, new possibilities in the framework of param-
eterized complexity can become available. In nat-
ural language engineering, where ambiguity gener-
ated by a syntactic parser can be very high, limits
on syntactic complexity may resolve some ambigu-
ity and reduce the number of non-typical analyses
generated by the parser. Several such limits on the
complexity of D-trees are proposed in this paper.
To facilitate implementation of a non-projective
dependency grammar with FSMs, this paper intro-
duces a suitable string representation. This repre-
sentation is inspired by Colored Non-Projective De-
pendency Grammar (Yli-Jyr¨a and Nyk¨anen, 2004),
where multiple index pushdowns are used to store
symbols for dependency links. The axiomatiza-
tion deals with crossing dependencies and enforces
acyclicity of the represented dependency graph. It
involves several extensions that are not present in
earlier encoding schemes where dependencies are
also indicated through matching pairs of symbols
(Oflazer, 2003; Yli-Jyr¨a, 2004a).
</bodyText>
<subsectionHeader confidence="0.995794">
1.2 Non-Projective Dependency Trees
</subsectionHeader>
<bodyText confidence="0.996324222222222">
In dependency syntax, the analysis of a sentence is
given as a dependency tree (D-tree) whose nodes
correspond — as assumed in this paper — to the
words of the analyzed sentence. A D-tree consists
of dependency links (directed arcs) drawn above the
sentence — and implicitly, of the sentence itself.
The D-tree shows which words are related to which
words and in what way. Figure 1 gives an example
of a D-tree.
</bodyText>
<figureCaption confidence="0.9983895">
Figure 1: This tree analyses the Latin sentence
“Ultima Cumaei venit iam carminis aetas” (Vergil:
Eclogues IV.4) that means “The last era of the
Cumean song has now arrived”. The analysis is
adapted from Covington (1990). We added the
sentence-initial node ( ) and the arc labels.
</figureCaption>
<bodyText confidence="0.990908857142857">
The graphical representation for the D-tree is in-
terpreted as follows. If is a (directed) arc
between two nodes, we will say that depends im-
mediately on (or, conversely, governs im-
mediately), and that is an immediate syntactic
dependent of (and is the immediate syntactic
governor of ). (Mel’ˇcuk 1988.)
In each D-tree, there is a unique non-governed
node. For this purpose, we have reserved an ex-
ternal wall node ( ) that is placed on the left of
the sentence, while the words in the sentence are
always governed by exactly one node. A D-tree is
non-projective, if some of the arcs cross each other
when the tree is drawn above the sentence.
</bodyText>
<subsectionHeader confidence="0.969224">
1.3 The New Representation
</subsectionHeader>
<bodyText confidence="0.9684820625">
The string representation (Figure 2) for a D-tree
consists of overlapping views — string subse-
quences — that realize different aspects of the D-
tree encoding. For example, substrings delimited
by a pair or boundary symbols (#) are called nodes
in the string representation. The first node corre-
sponds to the wall ( ) and the other nodes contain
single word tokens of the sentence:
# # Ultima # Cumaei # venit # iam # carminis # aetas #
For any given D-tree there is a unique way to assign
colors to its arcs. When the coloring is done, the re-
sult is a colored D-tree. At each node of the colored
D-tree, there is a unique active color that is used
for the arcs that connect the node to the right. In
the string representation this is indicated by special
tokens , as follows:
</bodyText>
<equation confidence="0.851634">
# 1 # # # # # # 1 #
</equation>
<bodyText confidence="0.752466">
The arcs are encoded with separate pairs of brackets
as follows:
</bodyText>
<equation confidence="0.999337428571429">
# [ # # # ] # # # #
# # [ # # # # # ] #
# # # [ # # # ] # #
# # # # [ # # # ] #
# # # # [ # # # #
# # # # # # # ] #
Each substring [ ] , [ , and ] ,
</equation>
<bodyText confidence="0.9998304">
where the intervening string has a balanced
bracketing w.r.t. [ ] -brackets, corresponds to an
arc between two nodes in the D-tree. When these
subsequences are put on top of each other we obtain
the following combination:
</bodyText>
<equation confidence="0.902418">
# [ # [ # [ # ] [ # # ] # ] ] #
For each arc in Figure 1, there is a label
</equation>
<bodyText confidence="0.9933695">
that tells how depends on . These labels are
attached to the brackets as follows:
</bodyText>
<equation confidence="0.988768">
# [ pred # [ attr # [ attr # pred ] [
subj adv # adv # attr ] gntv # gntv subj
] attr ] #.
</equation>
<bodyText confidence="0.976895666666667">
The direction of each arc is indicated by adding an
over-line to the dependent-side labels:
[ attr [ attr pred ] adv gntv subj ] .
The non-projectivity depth of an arc measures its
specially defined distance from the wall node .
In each node, the non-projectivity depth of an out-
going arc is greater (or equal) than the depth of the
incoming arc. The depth of arcs is indicated as fol-
lows:
</bodyText>
<equation confidence="0.929169">
# [ 0 # [ 1 # [ 0 # 0 ] [ 0 0 # 0
# 0 ] 0 # 0 0 ] 1 ] #.
</equation>
<bodyText confidence="0.997405333333333">
When we combine all these views, we obtain a
string that represents the D-tree of Figure 1. This
string is shown in Figure 2.
</bodyText>
<figureCaption confidence="0.991216">
Figure 2: A string representation for a D-tree.
</figureCaption>
<sectionHeader confidence="0.980027" genericHeader="introduction">
2 Prerequisites
</sectionHeader>
<bodyText confidence="0.999976666666667">
We are going to define the string representation for
D-trees with axioms that are given as extended reg-
ular expressions. The intersection of the languages
described by these axioms is the set of valid repre-
sentations. In the following, we define the alphabets
and regular expressions used in the axioms.
Assume that is the set of category labels for
the arcs, and that , , and are the parameters
specifying upper bounds respectively for the proper
bracketing depth, nested crossing depth, and non-
projectivity depth. These depth measures will be
precisely defined in an appropriate context.
</bodyText>
<subsectionHeader confidence="0.968229">
2.1 Alphabets
</subsectionHeader>
<bodyText confidence="0.998689583333333">
In Figure 2, several different kinds of symbols are
involved. They belong to the following alphabets:
the sets , , ,consisting respec-
tively of brackets [ ] , ,
the color selectors ,
the dependent labels
,
the governor labels ,
the set of word tokens , and
the set of special symbols # .
The union of these alphabets is denoted as . The
union of the alphabets and is .
</bodyText>
<subsectionHeader confidence="0.994119">
2.2 Regular Expressions
</subsectionHeader>
<bodyText confidence="0.985819333333333">
Let and be sets of strings, and a positive inte-
ger. In the axioms we will use the following regular
operations: Kleene’s closure ( ), finite iteration
</bodyText>
<equation confidence="0.7319965">
( ), concatenation ( ), asymmetric difference
( ), union ( ), and intersection ( ) —
</equation>
<bodyText confidence="0.972460555555556">
with this precedence order. The semantics of these
operations is defined in the usual way. Parenthesis
( ) is used for grouping. The boxed dot denotes
the language
subset of and each context ,, is of
the form , where . The opera-
tion is expressed using a notation
and it defines the set of all strings such that,
for every possible and , for which
, there exists some context ,
, where both and .
The axioms in this paper produce a set of quite
small automata and the satisfiability and usability
of this lazy finite-state system for choosing a rep-
resentation has been tested with real D-trees. (Af-
ter these tests, the axioms presented here have un-
dergone some editing that hopefully have not intro-
duced typos or bugs.)
</bodyText>
<subsectionHeader confidence="0.997419">
2.3 The Basic Structure
</subsectionHeader>
<bodyText confidence="0.99205337037037">
Axiom 1. (a) The string begins and ends with a
node boundary (#). (b) Between each two bound-
aries there exists at least one word token or the wall
. (c) Two tokens
are always separated by a node boundary.
Axiom 2. (a) There are no two similar square
brackets in a node. (b) The color indices of
closing brackets increase monotonically when we
move from a right bracket towards the closest node
boundary (#) on the left.
Axiom 3. (a) All the labels belong to some
surrounding bracket. (b) Each left (right) bracket
has some label that is attached to it.
Axiom 4. (a) Angle brackets do not have
more than one label attached to them. (b) Within
each node, no angle bracket ( ) occurs inside a
square bracket [ (] ) having the same color .
Axiom 5. (a) The wall ( ) and all the word tokens
occur before a color selector . (b) All
the color selectors occur after a word token
or the wall.
Axiom 6. (a) There is one and only one ungoverned
node. (b) All other nodes are governed by some
node. (c) No node depends immediately on more
than one other node. (d) No node depends on itself.
These axioms are presented more formally as the
following regular expressions:
</bodyText>
<equation confidence="0.955348538461539">
# #
# # (1b)
(1c)
[ [ ] ] (2a)
✓ ]
# [ pred,0
# Ultima [ attr,1
# Cumaei [ attr,0
# pred,0 ] venit [ subj,0 adv,0
# adv,0 iam
# attr,0 ] carminis gntv,0
# gntv,0 subj,0 ] attr,1 ] aetas #
# .
</equation>
<bodyText confidence="0.9202295">
A context restriction of a center in contexts
is a regular operation where is a
</bodyText>
<equation confidence="0.679438">
(1a)
# (2b)
</equation>
<bodyText confidence="0.57237125">
We define first, for each color ,
in
such a way that it essentially deletes all the other
symbols except the brackets [ and ] , and the
</bodyText>
<figure confidence="0.9879935">
regular languages [ ] ,
the following way:
a string homomorphism
[ ]
in
if
[ ] if
where ] ]
(4a)
] [ (4b)
Some auxiliary languages are defined as follows:
3 Proper Embracement Depth
</figure>
<bodyText confidence="0.879361764705882">
In the context of D-trees, a counterpart notion for
center-embedding of constituent trees is needed. We
say that an arc properly embraces an-
other arc , if and only if
and
,
where is the linear precedence order among the
nodes. The proper embracement depth of a col-
ored D-tree is the maximum number of arcs
, , ,where all the arcs
have the same color and each ,
, properly embraces . This mea-
sure is applied to a D-tree in the Figure 3. Note
that proper embracement does not generally imply
that the arcs belong to a common path: in Figure
1 the arc aetas Ultima embraces properly the arc
carminis Cumaei.
</bodyText>
<figureCaption confidence="0.9973425">
Figure 3: The proper embracement depth of this
clause is 3.
</figureCaption>
<bodyText confidence="0.967962083333333">
An arc that shares a node with another
arc does not properly embrace the later.
If they overlap each other, the shorter of these arcs
will be represented with a pair of an angle bracket
and a square bracket as shown in Figure 2, unless the
longer arc is already presented by an angle bracket.
Thus, the maximum number of nested square brack-
ets needed corresponds to the proper embracement
depth of the colored D-tree.
In our representation, the proper embracement
depth of trees is bounded by a fixed parameter .
This allows defining finite-state constraints that de-
fine bracketings up to a bounded number of nested
square brackets. In the following, we will give ax-
ioms that check that brackets for each color are bal-
anced and do not exceed the proper embracement
depth .
Axiom 7. The [ ] -bracketings must be balanced
and the number of nested brackets is bounded.
Axiom 8. (a+b) Left (right) angle brackets match
with a square bracket. (c) The arcs indicated with
angle-square bracket pairs do not cross each other
as in [ ] .
These axioms are given more formally as follows:
</bodyText>
<equation confidence="0.994461">
(7)
] (8a)
[ (8b)
(8b)
</equation>
<bodyText confidence="0.997096">
where
</bodyText>
<sectionHeader confidence="0.997922" genericHeader="method">
4 Nested Crossing Depth
</sectionHeader>
<bodyText confidence="0.9915755">
We added colors to brackets because crossing
brackets have to be separated by some means.
Unfortunately, assigning colors to brackets entails
new problems:
</bodyText>
<listItem confidence="0.8857745">
1. We can represent non-projective trees that are
not typical for natural language. In particular,
we conjecture that although we bound the
number of colors available, there is a set of
</listItem>
<bodyText confidence="0.986066">
colored trees (in the limit ) that gives
structural descriptions for the Bach language
(cf. Joshi 1985), the strings of which consist of
an equal number of a’s, b’s and c’s.
</bodyText>
<listItem confidence="0.9365755">
2. In parsing, the colors must be selected in one
way or in another and this results normally into
an ambiguity where there are many colorings
available. Thus, we need a discipline that
tells how to assign colors to the arcs in an
unambiguous way.
</listItem>
<bodyText confidence="0.999661220779221">
The first problem could be addressed e.g. by com-
bining a constituent-based structure (topological
fields etc.) with the dependency syntax. In our
representation for D-trees, we need however a so-
lution that addresses both of these problems. Such
a solution has been developed recently and pre-
sented in many ways: by means of constraints (Yli-
Jyr¨a, 2003a), through an informal algorithm (Yli-
Jyr¨a, 2004b), and very formally as a special index
storage type used in Colored Non-projective De-
pendency Grammar (Yli-Jyr¨a and Nyk¨anen, 2004).
We conjecture, however, that there is no essential
differences in the allocation disciplines defined in
these works. In the following, we will adapt the
constraint-based definition (Yli-Jyr¨a, 2003a) to the
allocation of colors of brackets:
.
An effect of this axiom can be seen in Figure 2,
where a new color is selected after venit although
the color is no more in use. The reason is that
there is a bracket [ that is still open at that position.
Axiom 10 (Left conjoin). All the opening brackets
belonging to the same node have the same color.
This axiom corresponds intuitively to the fact
that there is no need to give different colors to arcs
that do not cross each other.
Axiom 11 (Continuous tiling). A position cannot
contain colored bracket [ , where , if, on
the left, there are no other brackets [ (of the same
color) that remain opened at the position, except if
there is, on the left, another bracket [ with
(of the preceding color) that remains open at this
position but will be matched with with a bracket
or ] that occurs before the bracket [ of the current
position is closed with ] .
This axiom corresponds to the fact that when a
new color is introduced at some position (Figure
2), this is done due to a danger of having crossing
brackets with the same color.
The actual effect of these three axioms is that for
each D-tree there remains a unique way to assign
colors, square brackets, and angle brackets to the
arcs. The nested crossing depth of a D-tree is
the number of colors in a colored D-tree that con-
forms Axioms 9 – 11. In our representation, the
nested crossing depth (i.e. the number of colors) is
bounded.
Bounded nested crossing depth has considerable
linguistic relevance. The length of the longest chain
( ) of crossing edges is a lower bound
for the nested crossing depth, but such chains are
typically very short in natural language sentences.
The possible upper bound for the nested crossing
depth has been studied experimentally (Yli-Jyr¨a,
2003a; Yli-Jyr¨a, 2004b) with the result that in non-
projective D-trees of some 700 Danish sentences,
the number of required colors is pretty low ( – ).
A few interesting exceptions) actually contained a
chain of up to five crossing dependencies. Such
complex examples seem to be successful combina-
tions of non-local dependencies, and it may be very
difficult to generalize what is possible and what is
not. Nevertheless, we conjecture that D-trees of the
Bach (or MIX) language (cf. Joshi 1985) are not
captured in our system when the number colors is
fixed, because Colored Non-Projective Dependency
Grammar (Yli-Jyr¨a and Nyk¨anen, 2004) is a linear
context-free rewriting system.
In order to facilitate formalization of Axiom 11,
we use of color selectors and the following axiom:
,
indicates that there is a left bracket [ that has not
yet been closed. (b) Color selector indicates that
no bracket [ is open at that position.
If we assume also a bound for the proper em-
bracement depth, we can present the above axioms
more formally as follows:
</bodyText>
<equation confidence="0.998146">
[ [ ] (9)
[ [ # (10)
[ ] (11)
_ ✓ ] _ _
[ (12a)
(12b)
</equation>
<bodyText confidence="0.997232">
where
</bodyText>
<sectionHeader confidence="0.995474" genericHeader="method">
5 Subcategorization
</sectionHeader>
<bodyText confidence="0.999967842105263">
We have seen in Section 3 that angle brackets are
used when several overlapping arcs share a common
node. This corresponds to use of reduced bracket-
ing for initial and final embedding in some systems
(Krauwer and des Tombe, 1981; Yli-Jyr¨a, 2003b),
and it facilitates linguistically appropriate bracket-
ing with FSMs.
Our axiomatization (Section 6 in particular) re-
quires that information about the labels and direc-
tions on the arcs of the node are locally present both
in the dependent and the governor nodes. Unfortu-
nately, this kind of duplication of the labeling in-
formation cannot be captured with regular axioms
unless there is a limit on the amount of information
that is duplicated. A solution would be to assign
each square bracket an unsaturated subcategoriza-
tion frame with a symbol that indicates a state in a
special subcategorization automaton. The automata
could be simulated by propagating — by means of
</bodyText>
<construct confidence="0.3625925">
le.g. “Det har b˚ade noget med stolene og bordet
at gøre — og pladsen udenom.”
</construct>
<figureCaption confidence="0.631705">
Axiom 9 (Plane locking). If a bracket [ is still
open at a string position, the position cannot contain
a bracket [ for which
</figureCaption>
<bodyText confidence="0.976575">
Axiom 12. (a) Color selector , where
declarative constraints — the state information of
each square bracket to the first angle bracket, and
then further from one angle bracket to another. We
have chosen, however, a more restricted approach
for brevity, although we do not argue that it is the
most elegant and general solution. This approach is
presented in the sequel.
and and describe what is inside the [ ] -
square brackets, when the th label of the left
and right square bracket, respectively, has a match-
ing label. These languages are defined as
where
</bodyText>
<figureCaption confidence="0.99968325">
Figure 4: Angle brackets are used for non-proper
embraced bracketing. The additional labels of the
square bracket correspond to the labels attached to
angle brackets.
</figureCaption>
<bodyText confidence="0.99884908">
We assume that the number of left or right arcs
per color is bounded by an integer . Thus, at most
labels can be associated with one square bracket.
The label that is nearest to the opening (closing)
square bracket corresponds to the label that is near-
est to the corresponding closing (opening) square
bracket. Each additional label of the square bracket
corresponds to a label of an angle bracket (Figure
4).
We will now give axioms that check that the la-
bels of square brackets corresponds to the labels of
the matching square and angle brackets:
Axiom 13. (a)+(b) The number of left (right) angle
brackets matching each right (left) square bracket is
determined by the number of labels associated with
the right (left) square bracket.
Axiom 14. (a) Every label of the right square
brackets has a corresponding bracket with a corre-
sponding label. (b) Every label of the left square
brackets has a corresponding bracket with a corre-
sponding label.
These axiom are formulated as follows:
is a language whose strings contain just matching
pairs of labels and everything that can come be-
tween them.
</bodyText>
<sectionHeader confidence="0.997756" genericHeader="method">
6 Non-Projectivity Depth
</sectionHeader>
<bodyText confidence="0.997552571428571">
The arcs in dependency trees constitute, by the def-
inition of trees, an acyclic graph — our discussion
assumes that there are no secondary links in D-trees.
In the axiomatization of the string representation,
we have to enforce acyclicity by some constraints.
Procedurally the acyclicity could be decided, for ex-
ample, by trying to arrange the nodes into an order
where the arcs go from the left to the right (topolog-
ical sorting). Corresponding declarative solutions
would be e.g. (i) to use set constraints (Duchier,
1999) or (ii) to attach each node an integer that in-
creases strictly in the nodes reached by the outgoing
arcs of the node. Both of these solutions are prob-
lematic because the number of reached nodes is, in
practice, unbounded. An alternative solution that
is adopted her is to use a monotonically increasing
counter that is incremented only at certain critical
positions. For technical reasons, we attach such a
counter to arcs and brackets rather than to the nodes
— this change is not mathematically significant.
Let be the linear precedence relation over the
nodes. A node in a D-tree is an articulation node
if no arcs are passing it and the arcs coming into
it are on the opposite side than the arcs going out
from it. A chain of colored arcs
,
or (iii) . The non-projectivity depth of
a (colored dependency) path that does not contain
an articulation node is the number of critical nodes
visited by it. The maximum depth of such paths in
a D-tree is the non-projectivity depth of the D-tree.
Incrementing counters only at the critical posi-
tions has an important advantage over the other so-
lutions mentioned: projective trees do not contain
any critical positions, and in non-projective trees of
</bodyText>
<equation confidence="0.97816875">
[ ] if
[ ] if
[ ] if
[ ] if
</equation>
<bodyText confidence="0.946702333333333">
where
] [ (13a)
[ ] (13b)
where
,
, , ,where is
the color of an arc , is called a colored
dependency path. Anode ,, is critical
if either (i)
, (ii)
natural language sentences we probably need only
very small numbers. If the counter is incremented
several times, the path can be very “unnatural” as
shown in Figure 5. We conjecture that if a de-
.
Axiom 16. (a) There are no labels and
, where , that are attached
to closing brackets in this order. (b) There are no
labels and , where ,
that are attached to opening brackets in this order.
(c) There are no labels and ,
where , that are attached respectively to a
closing bracket and an opening bracket so that the
color index of the closing bracket is smaller than
that of the opening bracket.
Axiom 17. There is no label ,,
that is attached to an opening bracket, if on the left
of the label there is no , or on the right
of the label there is no label .
Axiom 18. There is no label ,,
that is attached to a closing bracket with color
, if on the right of the label there no label
, or on the left of the label there is no
label , or there is no label
that is attached to an opening bracket with a color
greater than .
Axiom 19. In articulation nodes, the counters of the
outgoing arc labels must be zero.
More formally these are given as follows:
</bodyText>
<sectionHeader confidence="0.9918305" genericHeader="method">
7 Colored Non-projective Dependency
Grammar
</sectionHeader>
<bodyText confidence="0.913021217391304">
A new grammatical framework, called Colored
Non-projective Dependency Grammar (CNDG)
(Yli-Jyr¨a and Nyk¨anen, 2004), has been developed
on the top of the bounded nested crossing depth
and bounded non-projectivity depth using a care-
fully designed linear context free rewriting system.
A regular approximation for such a grammar is ob-
tained by compiling the colored dependency rules
to constraints that specify local subcategorization
features (labels and bracket colors) within the node
boundaries. The current axioms will take care of the
non-local structure of the described D-trees.
Example 1. The following set of rules describes the
dependency tree shown in Figure 1:
pred
venit pred adv subj
aetas attr subj gntv
iam adv
ultima attr
Cumaei attr
carminis attr gntv
When the second and the third rule, for example, are
compiled, we obtain the following two constraints:
</bodyText>
<figure confidence="0.9405687">
pred # ] venit [ subj [ adv #
subj # gntv ] ] attr ] aetas #
0 6
4 2 3
1
0 4 5
[ (16c)
# ✓]
where
and [
</figure>
<figureCaption confidence="0.999957">
Figure 5: The growth of the non-projectivity depth.
</figureCaption>
<bodyText confidence="0.893103857142857">
pendency path is acyclic, we cannot increment the
counters at every critical position. In other words,
assigning depths to the arcs of a D-graph excludes
the alternative that the graph would be cyclic.
In our representation, there is a fixed upper bound
for the non-projectivity depth. Based on it, we can
define, for all , the sets
</bodyText>
<sectionHeader confidence="0.485413" genericHeader="method">
, and
</sectionHeader>
<bodyText confidence="0.9956183">
. The second component of each label is
the non-projectivity depth counter. The incremen-
tation of these counters in critical nodes gives rise
to the following axioms. They constrain nodes i.e.
substrings occurring between two word boundaries:
Axiom 15. (a) In nodes that are not articulation
nodes, there is no label , where ,
if there is a label , . (b) There is
no label , where , if there is no
label
</bodyText>
<sectionHeader confidence="0.997318" genericHeader="method">
8 Further Work
</sectionHeader>
<bodyText confidence="0.999988368421053">
In the future, the current axiomatization should be
extended to allow free dependents, and to include
rules without colors and arc order. Furthermore, ef-
ficient methods for applying the axioms should be
developed and a standard finite-state parser using
these axioms should be specified.
The approach could be extended with a multi-
tiered approach where different kinds of bracketed
strings (including e.g. P-markers) are processed
with a multi-tape finite automaton. We could also
use weighted automata to improve the ranking of
alternative analyses.
We would like to develop full scale grammars and
to evaluate the presented representation properly in
practical setting. Possibilities to induce a grammar
automatically from a treebank could be examined.
The proposed complexity bounds could be applied
also to treebank validation and more generally in
linguistic studies of natural language complexity.
</bodyText>
<sectionHeader confidence="0.997572" genericHeader="conclusions">
9 Conclusion
</sectionHeader>
<bodyText confidence="0.9999425">
In this article, we have proposed a new representa-
tion for restricted non-projective dependency trees:
The representation combines both dependency and
linearization into a single string structure, and it
gives a realistic basis for non-projective finite-state
dependency parsers. The complexity measures used
here may be of interest in different areas of linguis-
tics.
</bodyText>
<sectionHeader confidence="0.996337" genericHeader="acknowledgments">
10 Acknowledgements
</sectionHeader>
<bodyText confidence="0.9998638">
This work was funded by NorFA under the author’s
personal Ph.D. scholarship (ref.nr. 010529). The
author is grateful to the anonymous referees for in-
sightful comments on an earlier version of this pa-
per.
</bodyText>
<sectionHeader confidence="0.999257" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999750409090909">
Steven Abney. 1996. Partial parsing via finite state
cascades. In Proceedings of the ESSLLI’96 Ro-
bust Parsing Workshop.
Noam Chomsky. 1957. Syntactic Structures. Mou-
ton, The Hague.
Michael A. Covington. 1990. Technical correspon-
dence. Computational Linguistics, 16(4).
Denys Duchier. 1999. Set constraints in computa-
tional linguistics – solving tree descriptions. In
Workshop on Declarative Programming with Sets
(DPS’99), pages 91–98, Paris.
David Elworthy. 2000. A finite state parser with
dependency structure output. In Proceedings of
International Workshop on Parsing Technologies.
Sylvain Kahane, Alexis Nasr, and Owen Ram-
bow. 1998. Pseudo-projectivity: A polynomially
parsable non-projective dependency grammar. In
COLING-ACL’98, volume I, pages 646–652.
Fred Karlsson. (in print). Limits of clausal embed-
ding complexity in Standard Average European.
Manuscript. Department of General Linguistics,
University of Helsinki, April 2004.
Kimmo Koskenniemi. 1997. Representations and
finite-state components in natural language. In
E. Roche and Y. Schabes, editors, Finite-state
language processing, pages 99–116. A Bradford
Book, MIT Press, Cambridge, MA.
Steven Krauwer and Louis des Tombe. 1981.
Transducers and grammars as theories of lan-
guage. Theoretical Linguistics, 8:173–202.
Igor A. Mel’ˇcuk. 1988. Dependency Syntax: The-
ory and Practice. State University of New York
Press, Albany.
Alexis Nasr, Owen Rambow, John Chen, and Srini-
vas Bangalore. 2002. Context-free parsing of
a tree adjoining grammar using finite-state ma-
chines. In Proceedings of TAG+6, pages 100–
105, Universit´a di Venezia.
Kemal Oflazer. 2003. Dependency parsing with
an extended finite-state approach. Computational
Linguistics, 29(4).
Anssi Yli-Jyr¨a and Matti Nyk¨anen. 2004. A hierar-
chy of mildly context sensitive dependency gram-
mars. In Formal Grammar (FGNancy), Nancy,
France, August.
Anssi Yli-Jyr¨a. 2003a. Multiplanarity - a model for
dependency structures in treebanks. In The Sec-
ond Workshop on Treebanks and Linguistic The-
ories, V¨axj¨o, Sweden, 14-15 November.
Anssi Yli-Jyr¨a. 2003b. Regular approximations
through labeled bracketing. In Gerhard J¨ager,
Paola Monachesi, Gerald Penn, and Shuly Wint-
ner, editors, Proceedings of Formal Grammar
2003, pages 189–201, Vienna.
Anssi Yli-Jyr¨a. 2004a. Approximating dependency
grammars through intersection of regular string
languages. Ninth International Conference on
Implementation and Application of Automata
(CIAA), July.
Anssi Yli-Jyr¨a. 2004b. Coping with dependencies
and word order or how to put Arthur’s court into
a castle. In H. Holmboe, editor, Nordisk Sprogte-
knologi 2003. ˚Arbog for Nordisk Sprogteknolo-
gisk Forskningsprogram 2000-2004, pages 123–
137. Museum Tusculanums Forlag, Københavns
Universitet.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.303827">
<title confidence="0.99464">Axiomatization of Restricted Non-Projective Dependency Trees</title>
<author confidence="0.407442">Finite-State Constraints that Analyse Crossing Bracketings</author>
<affiliation confidence="0.681292">Department of General Linguistics, P.O. Box 9, FIN-00014 University of</affiliation>
<email confidence="0.676972">anssi.yli-jyra@helsinki.fi</email>
<abstract confidence="0.998623617647059">In this paper, a representation for syntactic dependency trees (D-trees) is defined through a finite set of axioms. The axiomatized representation constitutes a string that can encode non-projective D-trees of restricted structural complexity. Upper-bounds for the structural complexity of these D-trees are through the following new parameters: depth crossing depth and depth In the representation, syntactic dependencies between words are indicated with pairs of brackets. When the brackets indicate dependencies that cross each other, the crossing pairs of brackets are distinguished by assigning separate colors to each of them. These colors are allocated in a way (Yli-Jyr¨a and Nyk¨anen, 2004) that ensures a unique representation for each D-tree, and entails that languages crossing depth not bounded cannot be captured using a fixed number of colors. Although the axiomatization is finite, it ensures that the represented dependency structures are trees. This is possible because the described D-trees have The axioms are regular because embracement depth represented D-trees is bounded. Our representation suggests that extra strong generative power can be squeezed out of finite-state equivalent grammars. Bracketed D-tree representasentences) are structural descriptions that are assigned to their subsequences strings or yields of trees) where brackets and other special-purpose characters have been omitted.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Steven Abney</author>
</authors>
<title>Partial parsing via finite state cascades.</title>
<date>1996</date>
<booktitle>In Proceedings of the ESSLLI’96 Robust Parsing Workshop.</booktitle>
<contexts>
<context position="2793" citStr="Abney, 1996" startWordPosition="401" endWordPosition="402">or their representations — to terminal strings. An appropriate representation is conveniently defined through a set of axioms presented in this work. The complexity of the structures assigned is bounded by some special parameters. 1.1 Motivation We argue that the possibilities of FSMs have not been fully exploited in dependency syntax. So far, almost all the dependency parsers that use FSMs take them merely as subroutines in a system whose generative power exceeds regular languages. Although there are some pure finite-state approaches to surface syntactic parsing (Krauwer and des Tombe, 1981; Abney, 1996; Koskenniemi, 1997; Yli-Jyr¨a, 2004a) there seems to be a lack of a pure finite-state approach that is capable of assigning non-projective dependency structures to the input strings. The applicability of finite-state systems to natural language syntax has been questioned since Chomsky (1957), who suggested that center embedding in natural language is unbounded. In contrast to this view, a recent corpus-based study (Karlsson, in print) suggests an opposite generalisation according to which there is an absolute limit (2 – 3) on centerembedding of subordinate clauses in matrix clauses, on top of</context>
</contexts>
<marker>Abney, 1996</marker>
<rawString>Steven Abney. 1996. Partial parsing via finite state cascades. In Proceedings of the ESSLLI’96 Robust Parsing Workshop.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Noam Chomsky</author>
</authors>
<title>Syntactic Structures.</title>
<date>1957</date>
<publisher>Mouton, The Hague.</publisher>
<contexts>
<context position="3086" citStr="Chomsky (1957)" startWordPosition="445" endWordPosition="447"> not been fully exploited in dependency syntax. So far, almost all the dependency parsers that use FSMs take them merely as subroutines in a system whose generative power exceeds regular languages. Although there are some pure finite-state approaches to surface syntactic parsing (Krauwer and des Tombe, 1981; Abney, 1996; Koskenniemi, 1997; Yli-Jyr¨a, 2004a) there seems to be a lack of a pure finite-state approach that is capable of assigning non-projective dependency structures to the input strings. The applicability of finite-state systems to natural language syntax has been questioned since Chomsky (1957), who suggested that center embedding in natural language is unbounded. In contrast to this view, a recent corpus-based study (Karlsson, in print) suggests an opposite generalisation according to which there is an absolute limit (2 – 3) on centerembedding of subordinate clauses in matrix clauses, on top of which there are also category restrictions on which type of center-embeddings are allowed at each embedding level. Although such limits may lack some mathematical elegancy, they may entail some other kind of mathematical beauty (e.g. the closure properties of regular languages) and, moreover</context>
</contexts>
<marker>Chomsky, 1957</marker>
<rawString>Noam Chomsky. 1957. Syntactic Structures. Mouton, The Hague.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael A Covington</author>
</authors>
<date>1990</date>
<booktitle>Technical correspondence. Computational Linguistics,</booktitle>
<volume>16</volume>
<issue>4</issue>
<contexts>
<context position="5369" citStr="Covington (1990)" startWordPosition="800" endWordPosition="801">ntax, the analysis of a sentence is given as a dependency tree (D-tree) whose nodes correspond — as assumed in this paper — to the words of the analyzed sentence. A D-tree consists of dependency links (directed arcs) drawn above the sentence — and implicitly, of the sentence itself. The D-tree shows which words are related to which words and in what way. Figure 1 gives an example of a D-tree. Figure 1: This tree analyses the Latin sentence “Ultima Cumaei venit iam carminis aetas” (Vergil: Eclogues IV.4) that means “The last era of the Cumean song has now arrived”. The analysis is adapted from Covington (1990). We added the sentence-initial node ( ) and the arc labels. The graphical representation for the D-tree is interpreted as follows. If is a (directed) arc between two nodes, we will say that depends immediately on (or, conversely, governs immediately), and that is an immediate syntactic dependent of (and is the immediate syntactic governor of ). (Mel’ˇcuk 1988.) In each D-tree, there is a unique non-governed node. For this purpose, we have reserved an external wall node ( ) that is placed on the left of the sentence, while the words in the sentence are always governed by exactly one node. A D-</context>
</contexts>
<marker>Covington, 1990</marker>
<rawString>Michael A. Covington. 1990. Technical correspondence. Computational Linguistics, 16(4).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Denys Duchier</author>
</authors>
<title>Set constraints in computational linguistics – solving tree descriptions.</title>
<date>1999</date>
<booktitle>In Workshop on Declarative Programming with Sets (DPS’99),</booktitle>
<pages>91--98</pages>
<location>Paris.</location>
<contexts>
<context position="21651" citStr="Duchier, 1999" startWordPosition="3785" endWordPosition="3786">ching pairs of labels and everything that can come between them. 6 Non-Projectivity Depth The arcs in dependency trees constitute, by the definition of trees, an acyclic graph — our discussion assumes that there are no secondary links in D-trees. In the axiomatization of the string representation, we have to enforce acyclicity by some constraints. Procedurally the acyclicity could be decided, for example, by trying to arrange the nodes into an order where the arcs go from the left to the right (topological sorting). Corresponding declarative solutions would be e.g. (i) to use set constraints (Duchier, 1999) or (ii) to attach each node an integer that increases strictly in the nodes reached by the outgoing arcs of the node. Both of these solutions are problematic because the number of reached nodes is, in practice, unbounded. An alternative solution that is adopted her is to use a monotonically increasing counter that is incremented only at certain critical positions. For technical reasons, we attach such a counter to arcs and brackets rather than to the nodes — this change is not mathematically significant. Let be the linear precedence relation over the nodes. A node in a D-tree is an articulati</context>
</contexts>
<marker>Duchier, 1999</marker>
<rawString>Denys Duchier. 1999. Set constraints in computational linguistics – solving tree descriptions. In Workshop on Declarative Programming with Sets (DPS’99), pages 91–98, Paris.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Elworthy</author>
</authors>
<title>A finite state parser with dependency structure output.</title>
<date>2000</date>
<booktitle>In Proceedings of International Workshop on Parsing Technologies.</booktitle>
<contexts>
<context position="1985" citStr="Elworthy, 2000" startWordPosition="276" endWordPosition="277">depth. The axioms are also regular because proper embracement depth of represented D-trees is bounded. Our representation suggests that extra strong generative power can be squeezed out of finite-state equivalent grammars. Bracketed D-tree representations (cf. annotated sentences) are structural descriptions that are assigned to their subsequences (cf. generated strings or yields of trees) where brackets and other special-purpose characters have been omitted. 1 Introduction Recently, many dependency syntactic parsers using finite-state machines (FSMs) have been presented (Kahane et al., 1998; Elworthy, 2000; Nasr et al., 2002; Oflazer, 2003; Yli-Jyr¨a, 2004a). This article shows that a finite-state equivalent grammatical system is capable of assigning even non-projective syntactic dependency trees — or their representations — to terminal strings. An appropriate representation is conveniently defined through a set of axioms presented in this work. The complexity of the structures assigned is bounded by some special parameters. 1.1 Motivation We argue that the possibilities of FSMs have not been fully exploited in dependency syntax. So far, almost all the dependency parsers that use FSMs take them</context>
</contexts>
<marker>Elworthy, 2000</marker>
<rawString>David Elworthy. 2000. A finite state parser with dependency structure output. In Proceedings of International Workshop on Parsing Technologies.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Sylvain Kahane</author>
<author>Alexis Nasr</author>
<author>Owen Rambow</author>
</authors>
<title>Pseudo-projectivity: A polynomially parsable non-projective dependency grammar.</title>
<date>1998</date>
<booktitle>In COLING-ACL’98, volume I,</booktitle>
<pages>646--652</pages>
<contexts>
<context position="1969" citStr="Kahane et al., 1998" startWordPosition="272" endWordPosition="275">ded non-projectivity depth. The axioms are also regular because proper embracement depth of represented D-trees is bounded. Our representation suggests that extra strong generative power can be squeezed out of finite-state equivalent grammars. Bracketed D-tree representations (cf. annotated sentences) are structural descriptions that are assigned to their subsequences (cf. generated strings or yields of trees) where brackets and other special-purpose characters have been omitted. 1 Introduction Recently, many dependency syntactic parsers using finite-state machines (FSMs) have been presented (Kahane et al., 1998; Elworthy, 2000; Nasr et al., 2002; Oflazer, 2003; Yli-Jyr¨a, 2004a). This article shows that a finite-state equivalent grammatical system is capable of assigning even non-projective syntactic dependency trees — or their representations — to terminal strings. An appropriate representation is conveniently defined through a set of axioms presented in this work. The complexity of the structures assigned is bounded by some special parameters. 1.1 Motivation We argue that the possibilities of FSMs have not been fully exploited in dependency syntax. So far, almost all the dependency parsers that us</context>
</contexts>
<marker>Kahane, Nasr, Rambow, 1998</marker>
<rawString>Sylvain Kahane, Alexis Nasr, and Owen Rambow. 1998. Pseudo-projectivity: A polynomially parsable non-projective dependency grammar. In COLING-ACL’98, volume I, pages 646–652.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fred Karlsson</author>
</authors>
<title>(in print). Limits of clausal embedding complexity in Standard Average</title>
<date>2004</date>
<institution>European. Manuscript. Department of General Linguistics, University of Helsinki,</institution>
<marker>Karlsson, 2004</marker>
<rawString>Fred Karlsson. (in print). Limits of clausal embedding complexity in Standard Average European. Manuscript. Department of General Linguistics, University of Helsinki, April 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kimmo Koskenniemi</author>
</authors>
<title>Representations and finite-state components in natural language.</title>
<date>1997</date>
<booktitle>Finite-state language processing,</booktitle>
<pages>99--116</pages>
<editor>In E. Roche and Y. Schabes, editors,</editor>
<publisher>A Bradford Book, MIT Press,</publisher>
<location>Cambridge, MA.</location>
<contexts>
<context position="2812" citStr="Koskenniemi, 1997" startWordPosition="403" endWordPosition="404">esentations — to terminal strings. An appropriate representation is conveniently defined through a set of axioms presented in this work. The complexity of the structures assigned is bounded by some special parameters. 1.1 Motivation We argue that the possibilities of FSMs have not been fully exploited in dependency syntax. So far, almost all the dependency parsers that use FSMs take them merely as subroutines in a system whose generative power exceeds regular languages. Although there are some pure finite-state approaches to surface syntactic parsing (Krauwer and des Tombe, 1981; Abney, 1996; Koskenniemi, 1997; Yli-Jyr¨a, 2004a) there seems to be a lack of a pure finite-state approach that is capable of assigning non-projective dependency structures to the input strings. The applicability of finite-state systems to natural language syntax has been questioned since Chomsky (1957), who suggested that center embedding in natural language is unbounded. In contrast to this view, a recent corpus-based study (Karlsson, in print) suggests an opposite generalisation according to which there is an absolute limit (2 – 3) on centerembedding of subordinate clauses in matrix clauses, on top of which there are al</context>
</contexts>
<marker>Koskenniemi, 1997</marker>
<rawString>Kimmo Koskenniemi. 1997. Representations and finite-state components in natural language. In E. Roche and Y. Schabes, editors, Finite-state language processing, pages 99–116. A Bradford Book, MIT Press, Cambridge, MA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Steven Krauwer</author>
<author>Louis des Tombe</author>
</authors>
<title>Transducers and grammars as theories of language. Theoretical Linguistics,</title>
<date>1981</date>
<pages>8--173</pages>
<marker>Krauwer, Tombe, 1981</marker>
<rawString>Steven Krauwer and Louis des Tombe. 1981. Transducers and grammars as theories of language. Theoretical Linguistics, 8:173–202.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Igor A Mel’ˇcuk</author>
</authors>
<title>Dependency Syntax: Theory and Practice.</title>
<date>1988</date>
<publisher>State University of New York Press,</publisher>
<location>Albany.</location>
<marker>Mel’ˇcuk, 1988</marker>
<rawString>Igor A. Mel’ˇcuk. 1988. Dependency Syntax: Theory and Practice. State University of New York Press, Albany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alexis Nasr</author>
<author>Owen Rambow</author>
<author>John Chen</author>
<author>Srinivas Bangalore</author>
</authors>
<title>Context-free parsing of a tree adjoining grammar using finite-state machines.</title>
<date>2002</date>
<booktitle>In Proceedings of TAG+6,</booktitle>
<pages>100--105</pages>
<institution>Universit´a di Venezia.</institution>
<contexts>
<context position="2004" citStr="Nasr et al., 2002" startWordPosition="278" endWordPosition="281">s are also regular because proper embracement depth of represented D-trees is bounded. Our representation suggests that extra strong generative power can be squeezed out of finite-state equivalent grammars. Bracketed D-tree representations (cf. annotated sentences) are structural descriptions that are assigned to their subsequences (cf. generated strings or yields of trees) where brackets and other special-purpose characters have been omitted. 1 Introduction Recently, many dependency syntactic parsers using finite-state machines (FSMs) have been presented (Kahane et al., 1998; Elworthy, 2000; Nasr et al., 2002; Oflazer, 2003; Yli-Jyr¨a, 2004a). This article shows that a finite-state equivalent grammatical system is capable of assigning even non-projective syntactic dependency trees — or their representations — to terminal strings. An appropriate representation is conveniently defined through a set of axioms presented in this work. The complexity of the structures assigned is bounded by some special parameters. 1.1 Motivation We argue that the possibilities of FSMs have not been fully exploited in dependency syntax. So far, almost all the dependency parsers that use FSMs take them merely as subrouti</context>
</contexts>
<marker>Nasr, Rambow, Chen, Bangalore, 2002</marker>
<rawString>Alexis Nasr, Owen Rambow, John Chen, and Srinivas Bangalore. 2002. Context-free parsing of a tree adjoining grammar using finite-state machines. In Proceedings of TAG+6, pages 100– 105, Universit´a di Venezia.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kemal Oflazer</author>
</authors>
<title>Dependency parsing with an extended finite-state approach.</title>
<date>2003</date>
<journal>Computational Linguistics,</journal>
<volume>29</volume>
<issue>4</issue>
<contexts>
<context position="2019" citStr="Oflazer, 2003" startWordPosition="282" endWordPosition="283">because proper embracement depth of represented D-trees is bounded. Our representation suggests that extra strong generative power can be squeezed out of finite-state equivalent grammars. Bracketed D-tree representations (cf. annotated sentences) are structural descriptions that are assigned to their subsequences (cf. generated strings or yields of trees) where brackets and other special-purpose characters have been omitted. 1 Introduction Recently, many dependency syntactic parsers using finite-state machines (FSMs) have been presented (Kahane et al., 1998; Elworthy, 2000; Nasr et al., 2002; Oflazer, 2003; Yli-Jyr¨a, 2004a). This article shows that a finite-state equivalent grammatical system is capable of assigning even non-projective syntactic dependency trees — or their representations — to terminal strings. An appropriate representation is conveniently defined through a set of axioms presented in this work. The complexity of the structures assigned is bounded by some special parameters. 1.1 Motivation We argue that the possibilities of FSMs have not been fully exploited in dependency syntax. So far, almost all the dependency parsers that use FSMs take them merely as subroutines in a system</context>
<context position="4680" citStr="Oflazer, 2003" startWordPosition="685" endWordPosition="686">his paper. To facilitate implementation of a non-projective dependency grammar with FSMs, this paper introduces a suitable string representation. This representation is inspired by Colored Non-Projective Dependency Grammar (Yli-Jyr¨a and Nyk¨anen, 2004), where multiple index pushdowns are used to store symbols for dependency links. The axiomatization deals with crossing dependencies and enforces acyclicity of the represented dependency graph. It involves several extensions that are not present in earlier encoding schemes where dependencies are also indicated through matching pairs of symbols (Oflazer, 2003; Yli-Jyr¨a, 2004a). 1.2 Non-Projective Dependency Trees In dependency syntax, the analysis of a sentence is given as a dependency tree (D-tree) whose nodes correspond — as assumed in this paper — to the words of the analyzed sentence. A D-tree consists of dependency links (directed arcs) drawn above the sentence — and implicitly, of the sentence itself. The D-tree shows which words are related to which words and in what way. Figure 1 gives an example of a D-tree. Figure 1: This tree analyses the Latin sentence “Ultima Cumaei venit iam carminis aetas” (Vergil: Eclogues IV.4) that means “The la</context>
</contexts>
<marker>Oflazer, 2003</marker>
<rawString>Kemal Oflazer. 2003. Dependency parsing with an extended finite-state approach. Computational Linguistics, 29(4).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Anssi Yli-Jyr¨a</author>
<author>Matti Nyk¨anen</author>
</authors>
<title>A hierarchy of mildly context sensitive dependency grammars.</title>
<date>2004</date>
<booktitle>In Formal Grammar (FGNancy),</booktitle>
<location>Nancy, France,</location>
<marker>Yli-Jyr¨a, Nyk¨anen, 2004</marker>
<rawString>Anssi Yli-Jyr¨a and Matti Nyk¨anen. 2004. A hierarchy of mildly context sensitive dependency grammars. In Formal Grammar (FGNancy), Nancy, France, August.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Anssi Yli-Jyr¨a</author>
</authors>
<title>Multiplanarity - a model for dependency structures in treebanks.</title>
<date>2003</date>
<booktitle>In The Second Workshop on Treebanks and Linguistic Theories,</booktitle>
<pages>14--15</pages>
<location>V¨axj¨o,</location>
<marker>Yli-Jyr¨a, 2003</marker>
<rawString>Anssi Yli-Jyr¨a. 2003a. Multiplanarity - a model for dependency structures in treebanks. In The Second Workshop on Treebanks and Linguistic Theories, V¨axj¨o, Sweden, 14-15 November.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Anssi Yli-Jyr¨a</author>
</authors>
<title>Regular approximations through labeled bracketing.</title>
<date>2003</date>
<booktitle>Proceedings of Formal Grammar</booktitle>
<pages>189--201</pages>
<editor>In Gerhard J¨ager, Paola Monachesi, Gerald Penn, and Shuly Wintner, editors,</editor>
<location>Vienna.</location>
<marker>Yli-Jyr¨a, 2003</marker>
<rawString>Anssi Yli-Jyr¨a. 2003b. Regular approximations through labeled bracketing. In Gerhard J¨ager, Paola Monachesi, Gerald Penn, and Shuly Wintner, editors, Proceedings of Formal Grammar 2003, pages 189–201, Vienna.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Anssi Yli-Jyr¨a</author>
</authors>
<title>Approximating dependency grammars through intersection of regular string languages.</title>
<date>2004</date>
<booktitle>Ninth International Conference on Implementation and Application of Automata (CIAA),</booktitle>
<marker>Yli-Jyr¨a, 2004</marker>
<rawString>Anssi Yli-Jyr¨a. 2004a. Approximating dependency grammars through intersection of regular string languages. Ninth International Conference on Implementation and Application of Automata (CIAA), July.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Anssi Yli-Jyr¨a</author>
</authors>
<title>Coping with dependencies and word order or how to put Arthur’s court into a castle. In</title>
<date>2004</date>
<booktitle>Nordisk Sprogteknologi 2003. ˚Arbog for Nordisk Sprogteknologisk Forskningsprogram 2000-2004,</booktitle>
<pages>123--137</pages>
<editor>H. Holmboe, editor,</editor>
<institution>Museum Tusculanums Forlag, Københavns Universitet.</institution>
<marker>Yli-Jyr¨a, 2004</marker>
<rawString>Anssi Yli-Jyr¨a. 2004b. Coping with dependencies and word order or how to put Arthur’s court into a castle. In H. Holmboe, editor, Nordisk Sprogteknologi 2003. ˚Arbog for Nordisk Sprogteknologisk Forskningsprogram 2000-2004, pages 123– 137. Museum Tusculanums Forlag, Københavns Universitet.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>