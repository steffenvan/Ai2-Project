<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000241">
<title confidence="0.660367">
SEMANTICS OF TEMPORAL QUERIES AND TEMPORAL DATA
</title>
<author confidence="0.743887">
Carole D. Hafner
</author>
<affiliation confidence="0.793097">
College of Computer Science
Northeastern University
</affiliation>
<sectionHeader confidence="0.789173" genericHeader="abstract">
Boston, MA 02115
Abstract
</sectionHeader>
<bodyText confidence="0.9913965">
This paper analyzes the requirements for adding a
temporal reasoning component to a natural language
database query system, and proposes a computational
model that satisfies those requirements. A prelim-
inary implementation in Prolog is used to generate
examples of the model&apos;s capabilities.
I. Introduction
A major area of weakness In natural language (NL)
interfaces is the lack of ability to understand and
answer queries involving time. Although there is
growing recognition of the importance of temporal
semantics among database theoreticians (see, for
example, Codd [61, Anderson (21, Clifford and Warren
(41, Snodgrass (151), existing database management
systems offer little or no support for the
manipulation of time data. Furthermore (as we will
see In the next Section), there is no consensus among
researchers about how such capabilities should work.
Thus, the developer of a NL interface who wants to
support time-related queries cannot look to an
underlying DBMS for help.
Currently available NL systems such as Intellect [81
have not attempted to support temporal queries,
except in a trivial sense. In intellect, users can ask
to retrieve date attributes (e.g., &apos;When was Smith
hiredr) or enter restrictions based on the value of a
date attribute (e.g., list the employees hired after
Jan 1, 19841; but more complex questions, such as
&apos;How long has it been since Smith received a raiser
or &apos;What projects did Jones work on last January?&amp;quot;,
are not understood This is a serious practical
limitation, since the intended users of NL systems are
executives and other professionals who will require
more sophisticated temporal capabilities.
This report describes a model of temporal
reasoning that is designed to be incorporated into a
NL query system. We assume that a syntactic
component could be developed to translate explicit
temporal references in English (e.g., two years ago&apos;)
into logical representations, and restrict our
attention to the conceptual framework (including both
knowledge structures and rules of inference)
underlying such representations. Section 2 analyzes
the requirements that the temporal model must
satisfy: first describing some of the issues that arise
in trying to model time in a computer, then defining
four basic semantic relationships that are expressed
by time attributes in databases, and finally analyzing
the capabilites required to interpret a variety of
temporal queries. Based on this analysis, a
computational model is described that satisfies many
of the requirements for understanding and answering
time-related database queries, and examples are
presented that illustrate the model&apos;s capabiltties.
2. Modeling Temporal Knowledge
Modeling time, despite its obvious importance, has
proved an elusive goal for artificial intelligence (Al).
One of the first formal proposals for representing
time-dependent knowledge in Al systems was the
&apos;situation calculus described by McCarthy and Hayes
[11]. That proposal created a paradigm for temporal
reasoning based on the notion of an infinite collection
of states, each representing a single instant of time.
Propositions are defined as being either true or false
in a particular state, and predicates such as &apos;before
(s 1 , s2) can be defined to order the states
temporally. This approach was used by Bruce (31 in
modeling the meaning of tensed verb phrases in
English, and It has been refined and extended by
McDermott [ I 31.
</bodyText>
<page confidence="0.975628">
1
</page>
<bodyText confidence="0.996720931034483">
State space models describe time as being similar
to the real number line, with branches for alternative
pasts and hypothetical futures. Although this
approach is intuitively appealing, there are many
unsolved problems from both the logical and the
linguistic points of view. A few of the current
problems in temporal semantics are very briefly
described below:
a Non-monotonic reasoning. In a system for
automated reasoning, conclusions are drawn on the
basis of current facts. *ben a fact that was true
becomes false at a later time, conclusions that were
based on that fact may (or may not) have to be
revised. This problem, which is viewed by many as
the current issue in common sense reasoning, has
been studied extensively by Doyle [71, Moore (141. and
McDermott [131, and continues to occupy the attention
of John McCarthy [121
b. Representation of intervals and processes.
Another problem for temporal logic is the
representation of events that occur over intervals of
time. Allen [11 points out that even events which
seem to be instantaneous, such as a light coming on,
cause problems for the state space model, since at
the instant that this event occurs It is impossible to
say that either the light is on or the light is not on
is true. As a result, Allen chooses a representation of
time that uses intervals as the primitive objects
instead of instantaneous states.
</bodyText>
<listItem confidence="0.8715975">
c. Temporal distance. Neither the state space model
nor the interval model offers a convincing notion of
temporal distance. Yet, the ability of a system to
understand how long an event took or how much time
separated two events is an integral part of temporal
reasoning.
d. Periodicity of time. There are many periodic events
that affect the way we think and talk about time -
such as day and night, the days of the week, etc.
McDermott 1131shows how his tempo&apos; al logic can
describe periodic events, and Anderson [21 includes a
representation of periodic data in her model of
temporal database semantics. However, reasoning
about periodic time structures is still a relatively
unexplored issue.
e. Vagueness and uncertainty. People are able to
reason about events whose temporal parameters are
not known exactly - in fact, almost all temporal
</listItem>
<bodyText confidence="0.965001355555556">
descriptions incorporate some vagueness. The most
direct treatment of this phenomenon was a system by
Kahn and Gorry [91, which attached a -fuzz factor&amp;quot; to
temporal descriptions. However, Kahn and Gorry
recognized that this approach was very crude and
more sophisticated techniques were needed.
f. Complex event structures. The situation calculus is
not easily adapted to descriptions of complex acts
such as running as race, simultaneous events such as
hiding something from someone by standing in front
of it while that person is in the room (an example
dis- cussed by Allen [I]), or &amp;quot;non-events&apos; such as
waiting.
9. Metaphorical time descriptions. In naturally
occuring NI dialogues, time descriptions are
frequently metaphoric. Lakoff and Johnson [101 have
shown that at least three metaphors are used to
describe time in English: time as a path, time as a
resource, and time as a moving object. Al models
have yet to adequately deal with any of these
metaphors.
Considering all of these complex issues (and there
are others not mentioned here), It is not surprising
that general temporal capabilities are not found in
applied Al systems. However, in the domain of NL
query systems, it may be possible to ignore many of
these problems and still produce a useful system. The
reason for this is, in the world models of computer
databases, most of the complexity and ambiguity has
already been &apos;modeled our. Furthermore, current NI
interfaces only work well on a subclass of databases:
those that conform to a simple entity-attribute-rela-
tionsnip model of reality.
The research described in this paper has focused on
the design of 3 temporal component for a NL database
query system. This has led to a model of time that
corresponds to the structure of time attributes in
databases: i.e., a domain of discrete units
representing intervals of equal length. (Whether these
its are seconds, minutes, days, or years may vary
from cne database to another.) The description of the
model presented in Section 3 assumes that the basic
temporal units are days, in order to make the model
more Intuitively meaningful; however, the model can
be easily adapted to time units of other sizes.
</bodyText>
<page confidence="0.958008">
2
</page>
<subsectionHeader confidence="0.992436">
2.1 Analysis of Time Attributes in Databases
</subsectionHeader>
<bodyText confidence="0.999903583333333">
The primary role of time information in databases
is to record the fact that a specific event occurred at
a specific time. (It is also possible to represent
times in the future, when an event is scheduled to
occur, e.g., the date when a lease is due to expire.)
Having said this, there are still different ways in
which time attributes may be semantically related to
the entities in the database, and these require
different inferences to be made in translating NI
queries into the framework of the data model. The
following categories of time attributes are
frequently observed in &amp;quot;real world databases:
</bodyText>
<listItem confidence="0.9626898">
1. Time attributes describing individuals
2. Time of a &apos;transaction&apos;
3. Time when an attribute or relationship changed
4 The time of transition from one stage of a
process to the next.
</listItem>
<bodyText confidence="0.999928956521739">
The first two categories are quite straightforward.
Time attributes of individuals appear In &apos;entity&apos;
relations, as shown In Figure la; they describe the
occurrence of a significant event for each individual,
such as an employees date of birth or the date when
the employee was hired. This type of temporal
attribute has a unique (and usually unchanging) value
for each individual.
The term &amp;quot;transaction&amp;quot; is used here to describe an
event (usually involving several types of entities)
that does not change the status of the participants,
other than the fact that they participated in the
event. For example, the date of each treatment (an
X-ray, a therapy session, or a surgical procedure)
given to a patient by a doctor would be recorded in a
medical records database, as shown in Figure lb.
Attributes in the third category record the time at
which some other attribute or relationship changed.
Databases containing this type of information are
called &apos;historical databases&amp;quot;, in contrast to the more
traditional &amp;quot;operational&apos; databases, which only record
a &apos;snapshot&apos; of the current state of the world. The
salary history and student records databases shown in
</bodyText>
<figure confidence="0.997881133333333">
la. Time Attributes Decribing Individuals
Emplouee Database
Emp_10 I Name Address I Elirth_Date Hire_Date
lb. Time of a Transaction
Medical Records Database
Patient Doctor &apos;Procedure
I 1 Date
lc. Time When an Attribute or Relationship Changed
Salary History Database
Emp_ID 1Salary IDate
Student Records Database IDegree I Date
Student_ID I Subject
id. Time of a Process Transition
Publication Database
Doc_ID I Author ISub_Date IDisp_Date IRev_Date IPub_Date
</figure>
<figureCaption confidence="0.999943">
Figure 1. Examples of Temporal Attributes
</figureCaption>
<page confidence="0.986324">
3
</page>
<listItem confidence="0.996416555555556">
1. Which doctors performed operations on June 15, 1983?
2. How many people received PhD&apos;s in Math last month?
3. What percent of the employees got raises in the 4th quarter of 1984?
4. Did any authors have more than one paper waiting for publication on Jan 1?
5. How much was Jones making in September of 1984?
6. How long has Green worked here?
7. What was the average review time for papers submitted in 1983?
8. Which patients received operations on each day last week?
9. How many Ph. D&apos;s were granted to women during each of the past 10 years?
</listItem>
<figureCaption confidence="0.999193">
Figure 2. Examples of Temporal Queries
</figureCaption>
<bodyText confidence="0.99840431147541">
Figure lc are examples of this type of temporal data
Within this category, we must recognize a further
distinction between exclusive attributes such as
salary and non-exclusive attributes such as degree.
When a new salary is entered for an employee, the
previous salary is no longer valid; but when a new
degree is entered, it Is added to the individual&apos;s
previous degrees.
The last category of temporal data is used to
record fixed sequences of events that occur in various
actiivies. For example, the publication database of
Figure Id records the life-cycle stages of papers
submitted to a scientific journal: the date the paper
was received, the date it was accepted (or rejected),
the date the revised version was received, and the
date that is it scheduled to be published. We can view
this sequence as a process with several stages
(under review&apos;, &amp;quot;being revised&amp;quot;, &apos;awaiting
publication&amp;quot;), where each temporal attribute
represents the time of transition from one stage to
the next.
22. Analysis of Temporal Queries
This section considers four types of queries
Involving temporal data, and briefly outlines the
capabilites that a temporal knowledge model must
have in order to understand and answer queries of
each type.
Queries 1-3 in Figure 2 are examples of time
restriction aueries, which retrieve data about
individuals or events whose dates fail into a
particular interval of time. Current database systems
already support time restrictions, such as Query 1,
that use simple, absolute time references. Queries
such as (2), which use relative time references, and
(3) which refer to intervals not directly represented
in the database, require a more elaborate model of
time structures than current systems provide. The
time domain model described In Section 3.1 can
support queries of this type.
The second type of query asks about the
state-of-the-world on a given date (Query 4) or
during an interval of time (Query 5). Understanding
and answering these queries requires rules for
deducing the situation at a given time, as a result of
the occurrence (or non-occurrence) of events before
that time. For example, Query 5 asks about Jones&apos;
salary in September of 1978; however, there may not
be an entry for Jones in the salary history file during
that period. The system must know that the correct
salary can be retrieved from the most recent salary
change entered for Jones before that date. Section
3.2 describes an event model that can represent this
type of knowledge.
Another type of query asks about the length of time
that a situation has existed (Query 6), or about the
duration of one stage of a process (Query 7). These
queries require functions to compute and compare
lengths of time, and rules for deducing the starting
and ending times of states-of-the-world based on the
events that trigger them. Section 3.3 shows how the
proposed temporal model handles this type of query.
</bodyText>
<page confidence="0.987946">
4
</page>
<bodyText confidence="0.999858727272727">
The last type of query is the periodic query, which
asks for objects to be grouped according to one or
more attributes. High-level data languages and
current NL interfaces are generally able to handle this
type of request when it refers directly to the value of
an attribute (e.g., Query 8), but not when it requires
information to be grouped by time period, as in Query
9. To anwer periodic queries requires a formal
representation for descriptions such as each of the
past 5 years; the &apos;periodic descriptors&amp;quot; defined in
Section 3.1 satisfy this requirement
</bodyText>
<listItem confidence="0.723977">
3. A Temporal Reasoning Model for Databases
</listItem>
<bodyText confidence="0.9990395">
In this section, a temporal reasoning model is
proposed that can interpret the types of queries
described in Section 2.2. The model, which is
expressed as a collection of predicates and rules
written in Prolog (51, consists of the following
components:
</bodyText>
<listItem confidence="0.476959666666667">
1. A time domain model for representing units (days),
intervals, lengths of time, calendar structures, and
a variety of relative time descriptions.
2. An event model for representing and reasoning
about the temporal relationships among events,
situations, and processes in the application domain.
</listItem>
<subsectionHeader confidence="0.919423">
3.1 Time Domain Model
</subsectionHeader>
<bodyText confidence="0.999888833333333">
The basic structures of the time domain model are
days, intervals calendars, and periodic descriptors.
The days (0, DI, 02.. ) form a totally ordered set,
with a &apos;distance function representing the number of
days between two days. The distance function
satisfies the laws of addition, i.e.:
</bodyText>
<listItem confidence="0.97901025">
1) distance ( D1 , D2 ) - 0 (--&gt; Dl •D
2) distance ( Dl , 02) - - distance ( D2 , Dl)
3) distance ( DI , D2 ) • distance ( 02 , 03 ) -
distance ( DI , D3 )
</listItem>
<bodyText confidence="0.889485">
Intervals (I, 11,12 ..) are ordered pairs of days
(Os, Del such that distance (Os, De) &gt;- 0. If an
interval I (Ds , Del then:
</bodyText>
<listItem confidence="0.96705175">
4) start ( I ) - Ds
5) end ( 1 ) - De
6) length( I ) - distance ( start (I) , end ( I )) • 1
7) during( D, 1) -&amp;quot;true &lt;--
</listItem>
<bodyText confidence="0.9948867">
distance ( start(1) , D) 0 and
distance ( D , end(I)) &gt;- 0
Other temporal relations, such as &apos;before (DI, D2)&amp;quot;,
&amp;quot;afterID I, D2)&amp;quot;, and interval relations such as those
described by Allen (11, can be defined using the
&apos;distance&apos; function in an equally straightforward
manner. Also included in the model is a function
&amp;quot;today&apos; of no arguments whose value is always the
current day.
Formulas (1-7) are repeated below in Prolog notation:
</bodyText>
<listItem confidence="0.9945089">
1) distance(D1,D2,0) :- DI 02.
2) distance(D1, D2. Y) distance(D2, Dl, X) , Y - -X.
3) distance(D1, 03, Z) distance(D1, D2, X),
distance(D2, 03, Y), Z-X+Y.
4) start(I,Ds).
5) end(I,De).
6) length(i , Y):- distance(start(I), end(I), X) ,
Y - X+ 1.
7) during (D, I) distance(start(I), D , X) , X &gt;- 0,
distance (0, end(I), Y), Y &gt;- 0.
</listItem>
<bodyText confidence="0.937829318181818">
Examples of some natural language concepts:
n_days_.ago (N, D) today(DT) , distance(D, DT, N).
n_daya_frorn_now (N. D) .-
today(DT) , distance (DT, D, N).
the_past_n_days (N, I) :-
today(DT), end(1,DT), length(I,N).
the_next_n_days (N, I) :-
today(DT), start(1,0T), length(1,N).
the_day_before_yesterday (0) n_days_ago(2 , 0).
A calendar is a structure for representing
sequences of intervals, such as weeks, months, and
years. We will consider only &apos;complete&apos; calendars,
which cover all the days, although It would be useful
to define incomplete calendars to represent concepts
such as &apos;wort weeks&amp;quot; which exclude some days. A
calendar (CAL) is a totally ordered set of interval
descriptors called &apos;calendar elements&apos; (CE, CEI, CE2.
.). The following predicates are defined for calendars:
distcal(CAL, CEI, CE2, N). This is like the distance
function for days. It is true if CE2 is N calendar
elements after CE1. For example-. distcal(year,
1983, 1985,2) Is true.
</bodyText>
<page confidence="0.985033">
5
</page>
<bodyText confidence="0.999421637681159">
getcal(CAL, CE, U. This predicate is true if I is the
interval represented by the calendar element CE.
For example: getcal(year, 1983, jan011983,
dec311983) ) is true.
incal(CAL, D, CE , N). This predicate is true if D is the
Nth day of calendar element CE. It is used to map a
day into the calendar element to which it belongs.
For example: incal(month, jan121983 , ( jan,I983) ,
121) is true.
Calendars satisfy the well-formedness rules that
we would expect; for example, for each day 0 and each
calendar CAL, there is at most one (for complete
calendars, exactly one) calendar element CE and
positive integer N such that incal (CAL, D, CE, N) is
true. Also, if CEI is before CE2, then each day in CE1
is before each day in CE2. And, for complete
calendars, if CE I immediately precedes CE2, then the
last day of CEI immediately precedes the first day of
CE2.
Although the representation of calendar elements
Is arbitrary, we have chosen conventions that are both
meaningful to the programmer and useful to the
implementation. The simplest calendars are those
such as year, containing named elements that occur
only once. Years are simply represented as atoms
corresponding to their names. Cyclic calendars are
those that cycle within another calendar, such as the
calendars for &amp;quot;month and &apos;quarter&apos;. The elements of
these calendars are represented as 2-tuples, for
example: distcal(month, Edec,19831 , ( jan, I 9841 , 1) is
true. The calendar for weeks presents the most
difficult problem for the time domain model, since
weeks are not usually identified by name. We have
defined the week calendar so that all weeks begin on
Sunday and end on Saturday, with each element of the
calendar equal to the interval it represents. While
this is not an entirely satisfactory solution, it allows
a number of useful &apos;weekly&apos; computations.
More examples of natural language concepts.
from_cel_to_ce2(CAL, CEI, CE2, 1) :-
I. from January, 1963 to July, 1985 .1
getcal(CAL, CE 1, 11) , getcal(CAL, CE2, 12) ,
start(I1 , 5), end (12 , E) , start(&apos; , 5), enal , E).
n_cal_elts_ago(CAL, N, D) :-
I. three weeks ago *1
today(DT) , incal(CAL, DT, CE1, X) ,
distcal(CAL, CE2, CE), N) , Incal(CAL, 0, CE2, X).
The last structure in the time domain model is the
periodic descriptor (PO), used for representing
expressions such as each of the past 5 years&apos; or
each month in 1983. Periodic descriptors are
3-tuples consisting of a calendar (to define the size
of each period), a starting element from that calendar
(to define the first period), and either an ending
element from that calendar (to define the last period)
or an integer (to define how many periods are to be
computed). Periodic descriptors can run either
forward or backward in time, as shown by the
following example:
eactt_of_the_pas t_n_ca l_e I t s(CAL,N, PD) -
PD - (CAL, CEP, MI, today(DT), incal(CAL, DT, CET, _) ,
distcal(CAL, CEP, CET, I), M Is -N.
To interpret a query containing a periodic descrip-
tor, the NL interface must first expand the structure
Into a list of intervals (this must wait until
execution time in order to ensure the right value for
&apos;today&apos;) and then perform an iterative execution of
the query , restricting it in turn to each interval in
the list.
</bodyText>
<subsectionHeader confidence="0.699379">
3.2. Event Model
</subsectionHeader>
<bodyText confidence="0.9999328">
In the event model, each type of event is
represented by a unique predicate, as are the
situations and process stages that are signified by
events. For example, the event of a person receiving a
degree is represented by: awarded(Person, Subject,
Degree). The situation of having the degree is
represented by: holds(Person, Subject, Degree). While
the &amp;quot;awarded&apos; predicate is true only on the date the
degree was received, the &apos;holds&apos; predicate is true on
that aate and all future dates. Below we define a
straightforward approach to representing this type of
know ledge.
Five basic temporal predicates are introduced to
relate events and situations of the application model
to elements of the time domain model.
</bodyText>
<page confidence="0.99856">
6
</page>
<bodyText confidence="0.9997148125">
timeof(E, 0) - succeeds whenever an event that
matches E occcurs in the database with a time that
matches D. This is the basic assertion that relates
events to their times of occurrence.
nextof(E, T, D) - asserts that D is the next time of
occurrence of event E after time T.
nextof(E, T, D) timeof(E, 0) , before(T, 0),
not (timeof (E, X), before (T, X), before (X, 0).
startof(S, D) - defines the time when a situation or
process stage begins to be true, based on the
occurrence of the event that triggers it Rules of
this sort are part of the knowledge base of each
application, for example:
startof (holds(Person, Subject, Degree), Date) :-
timeof (awarded( Person, Subject, Degree) , Date).
endof(S, D) - defines the time when a situation ceases
to be true. For an exclusive attribute such as
salary( jones, 40000), the &apos;end-or a situation is the
&apos;next-or the same kind of event that triggered the
situation (ie., when Jones gets a new salary then
salary( jones,40000) is no longer true). For other
kinds of situations, a specific &apos;termination is
required to signify the ending; e.g., a publication
ceases to be &apos;under review&apos; when it Is accepted.
trueon(S, D) - succeeds If situation S Is true at time
D. Given the predicates described above, the
definition of trueon might be:
trueon(S, 0) startof (S, A), not (after(A,D)),
not (endof(S, 8), before (B, D)).
This rule asserts that situation S is true at time D
if S began at a time before (or equal to) D, and did
not end at a time before D.
</bodyText>
<subsectionHeader confidence="0.93336">
3.3. An Example Query
</subsectionHeader>
<bodyText confidence="0.987144">
We can now bring the two parts of the model
together to describe how a temporal query is
represented and interpreted using the predicates and
rules defined above. We will consider the following
query, addressed to the salary history database:
Which employees are making at least twice as much
now as they made 5 years ago.
For experimental purposes, we have defined our
database as a collection of Prolog facts, as proposed
by Warren(161; thus, the database can be queried
directly in Prolog. We have also defined the &apos;days&apos;,
which are the primitive elements of the time domain
model, to have names such as jan011982 or
jul041776; these names appear in the database as the
values of temporal attributes, as shown below:
salhistory( Jones, 30000, jan011983).
salhistory(smith, 42000, janI51983).
Each of the event-model predicates described in the
previous section has also been created, with
&apos;newsalary(EMPID, sax substituted for E and
&apos;makes(EMPID, sAu- substituted for S. For example:
</bodyText>
<reference confidence="0.767071">
timeof(newsalary(EMPID, SAL), D) :-
salhistory(EMPID, SAL, 0).
startof(makes(EMPID, SAL), D) :-
timeof(newsalary(EMPID, SAL), DX
endof(makes(EMPIO, SAL), 02) :-
timeof(newsalary(EMPID,SAL), 0),
nextoanewsalary(EMPID,SAL2), D, 02),
SAL SAL2
trueon(makes(EMPID, SAL), D) :-
startof(makes(EMPID,SAL), D.
trueon(makes(EMP1D, SAL), D):-
startaf(makes(EMPID, SAL), Dl). before(D 1 ,D),
not (endaf( makes(MPID, SAL). D2), be(ore(D2, D)).
We can now express the sample query in Prolog:
result(EMP1D, SAL, OLDSAL) .-
today(DT) ,
trueon(makes(EMPID, SAL), DT),
n_caLeits_ago(year, 5, DFYA) ,
trueon(makes(BIPID, OLDSAL), DYFA),
SAL &gt;- 2 *OLDSAL.
</reference>
<bodyText confidence="0.997360416666667">
This Prolog rule would be the desired output of the
linguistic component of 3 NI query system.
Paraphrased in English, it says: retrieve all triples of
employee id, current salary, and old salary, such that
the employee makes the current salary today, the
employee made the old salary five years ago, and the
current salary is greater than or equal to two times
the old salary. If we expand all of the Prolog rules
that would be invoked in answering this query, leaving
only database access commands, arithmetic tests, and
computations of the &amp;quot;distance&amp;quot; function, the complete
translation would be:
</bodyText>
<page confidence="0.99775">
7
</page>
<reference confidence="0.994411739130435">
result(EMPID, SAL, OLDSAL):-
today(DT) ,
salhistory(EMPID, SAL, 0),
distance(D, DT, X1),
X1 &gt;- 0 ,
not(salhistory (EMP1D, SAL2, D2),
distance(D, 02, X2),
X2&gt; 0,
distance (02, DT, X3),
X3 &gt;- 0,
SAL -- SAL2),
incal(year, DT, YR I , Y) ,
distcal (year, YR 1, YFYA, -5),
incal(year, DFYA, YFYA, Y) ,
salhistory (EMPID , OLDSAL, 03),
distance (D3, DYFA, X4),
X4 &gt;- 0,
not(salhistory(EMP1D, OLDSAL2,04),
distance(D3, D4, X5),
X4&gt; 0,
distanceD4, DYFA, X5),
X5 &apos;-0.
OLDSAL1 OLDSAL2).
</reference>
<sectionHeader confidence="0.84769" genericHeader="introduction">
4. Conclusions
</sectionHeader>
<bodyText confidence="0.969895888888889">
This paper has proposed a temporal reasoning model
based on the use of time attributes in databases, and
the types of queries that we would expect in
-real-world&amp;quot; applications. The model includes
constructs for representing events, situations, and
processes that are similar to those found in other
temporal reasoning models. It also addresses some
issues of particular importance for NI query systems,
which are not addressed by other recent work in
</bodyText>
<reference confidence="0.975218121212122">
temporal reasoning, including:
1. Representing the time between two points, and the
lengths of intervals.
2. &apos;Representing weeks, months, years, and other
atandard calendar atructurea.
3. Representing information relative to &apos;today&amp;quot; , this
month&amp;quot;, etc.
4. Representing periodic time descriptions.
The use of discrete, calendar-like structures as a
basis for representing time in a computer is a
simplification that is compatible with the discrete
representation of information in databases.
Hopefully, this simplification will make it easier to
program the model and to integrate it into a
state-of-the-art NL query system.
5. References
1. Allen, J. F., &apos;Towards a General Theory of Action
and Time. Artificial Intelligence, Vol. 23, No. 2
(1984) 123-154
2. Anderson, T. L., &apos;Modeling Time at the Conceptual
Level. In P. Scheuermann, ed., improving Database
Usability and Responsiveness, pp 273-297.
Jerusalem: Academic Press, 1982.
3. Bruce, B., &apos;A Model for Temporal Reference and its
Application in a Question Answering System.&apos;
Artificial Intelligence, Vol 3, No. 1(1972), 1-25.
4 Clifford, J. and D. S. Warren, &amp;quot;Formal Semantics for
Time in Databases.&apos; ACM TODS Vol. 8, No. 2 (1983)
214-254.
5. Clocksin, W.F. and C. 5. Mellish, Programming in
Prolog. Berlin: Springer-Verlag, 1981.
6. Codd, E. F., &apos;Extending the Database Relational Model
to Capture More Meaning.&apos; AO TODS Vol. 4, No. 4
(1979) 397-434.
7. Doyle, J., °A Truth Maintenance System.&apos; Artificial
intelligence, Vol. 12, No. 3(1979), 231-272.
8. INTELLECT Reference Manual, INTELLECT LEX Utility
Reference, Program Offerings LY20-9083-0 and
LY20-9082-0, IBM Corp., 1983.
9. Kahn, K. and G. A Gorry, Tlechanizing Temporal
Knowledge.&apos; Artificial Intelligence, Vol 9(1977),
87-108.
10. Lakoff, G., and M. Johnson, Metaphors We Live By.
The University of Chicago Press, Chicago ILL (1980).
II. McCarthy, J. and P. J. Hayes, Some Philosophical
Problems from the Standpoint of Artificial
Intelligence.&apos; In B. Meltzer and D. Michie, eds.,
Machine Intelligence 4. American Elsevier, New York
(1969).
12. McCarthy, J., &amp;quot;What is Common Sense?&apos;
Presidential Address at the National Conference on
Artificial Intelligence (AAAI-84), Austin, TX (1984).
13. McDermott, D., &apos;A Temporal Logic for Reasoning
About Processes and Plans.&apos; Cognitive Science, Vol.
6(1982)101-155.
14. Moore, R. C., -Semantical Considerations on
Nonmonotonic Logic.&apos; Artificial Intelligence, Vol.
25, No. 1 (1983), 75-94.
15. Snodgrass, R., The Temporal Query Language
TOuel.&apos; In Proc. 3rd ACM SIGMOD Symp. on Principles
of Database Systems, Waterloo, ONT (1984).
16. Warren, D. H. D., &apos;Efficient Processing of
Interactive Relational Database Queries Expressed
In Logic.&apos; In Proc. 7th Conf. on Very Large
Databases, pp. 272-281. IEEE Computer Society
(1981).
</reference>
<page confidence="0.998494">
8
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.990227">
<title confidence="0.994571">SEMANTICS OF TEMPORAL QUERIES AND TEMPORAL DATA</title>
<author confidence="0.999947">Carole D Hafner</author>
<affiliation confidence="0.999866">College of Computer Science Northeastern University</affiliation>
<address confidence="0.999924">Boston, MA 02115</address>
<abstract confidence="0.999426285714286">This paper analyzes the requirements for adding a temporal reasoning component to a natural language database query system, and proposes a computational model that satisfies those requirements. A preliminary implementation in Prolog is used to generate examples of the model&apos;s capabilities.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<authors>
<author>-salhistory startof</author>
<author>D -timeof</author>
<author>DX endof</author>
</authors>
<title>before(D 1 ,D), not (endaf( makes(MPID, SAL). D2), be(ore(D2, D)). We can now express the sample query in</title>
<booktitle>nextoanewsalary(EMPID,SAL2), D, 02), SAL SAL2</booktitle>
<volume>02</volume>
<marker>startof, -timeof, endof, </marker>
<rawString> timeof(newsalary(EMPID, SAL), D) :-salhistory(EMPID, SAL, 0). startof(makes(EMPID, SAL), D) :-timeof(newsalary(EMPID, SAL), DX endof(makes(EMPIO, SAL), 02) :-timeof(newsalary(EMPID,SAL), 0), nextoanewsalary(EMPID,SAL2), D, 02), SAL SAL2 trueon(makes(EMPID, SAL), D) :-startof(makes(EMPID,SAL), D. trueon(makes(EMP1D, SAL), D):-startaf(makes(EMPID, SAL), Dl). before(D 1 ,D), not (endaf( makes(MPID, SAL). D2), be(ore(D2, D)). We can now express the sample query in Prolog: result(EMP1D, SAL, OLDSAL) .-today(DT) , trueon(makes(EMPID, SAL), DT), n_caLeits_ago(year, 5, DFYA) , trueon(makes(BIPID, OLDSAL), DYFA), SAL &gt;- 2 *OLDSAL. result(EMPID, SAL, OLDSAL):-today(DT) , salhistory(EMPID, SAL, 0), distance(D, DT, X1), X1 &gt;- 0 , not(salhistory (EMP1D, SAL2, D2), distance(D, 02, X2), X2&gt; 0, distance (02, DT, X3), X3 &gt;- 0, SAL -- SAL2), incal(year, DT, YR I , Y) , distcal (year, YR 1, YFYA, -5), incal(year, DFYA, YFYA, Y) , salhistory (EMPID , OLDSAL, 03), distance (D3, DYFA, X4), X4 &gt;- 0, not(salhistory(EMP1D, OLDSAL2,04), distance(D3, D4, X5), X4&gt; 0, distanceD4, DYFA, X5), X5 &apos;-0. OLDSAL1 OLDSAL2). temporal reasoning, including:</rawString>
</citation>
<citation valid="false">
<title>Representing the time between two points, and the lengths of intervals.</title>
<contexts>
<context position="15858" citStr="(1)" startWordPosition="2618" endWordPosition="2618">s (0, DI, 02.. ) form a totally ordered set, with a &apos;distance function representing the number of days between two days. The distance function satisfies the laws of addition, i.e.: 1) distance ( D1 , D2 ) - 0 (--&gt; Dl •D 2) distance ( Dl , 02) - - distance ( D2 , Dl) 3) distance ( DI , D2 ) • distance ( 02 , 03 ) - distance ( DI , D3 ) Intervals (I, 11,12 ..) are ordered pairs of days (Os, Del such that distance (Os, De) &gt;- 0. If an interval I (Ds , Del then: 4) start ( I ) - Ds 5) end ( 1 ) - De 6) length( I ) - distance ( start (I) , end ( I )) • 1 7) during( D, 1) -&amp;quot;true &lt;-- distance ( start(1) , D) 0 and distance ( D , end(I)) &gt;- 0 Other temporal relations, such as &apos;before (DI, D2)&amp;quot;, &amp;quot;afterID I, D2)&amp;quot;, and interval relations such as those described by Allen (11, can be defined using the &apos;distance&apos; function in an equally straightforward manner. Also included in the model is a function &amp;quot;today&apos; of no arguments whose value is always the current day. Formulas (1-7) are repeated below in Prolog notation: 1) distance(D1,D2,0) :- DI 02. 2) distance(D1, D2. Y) distance(D2, Dl, X) , Y - -X. 3) distance(D1, 03, Z) distance(D1, D2, X), distance(D2, 03, Y), Z-X+Y. 4) start(I,Ds). 5) end(I,De). 6</context>
</contexts>
<marker>1.</marker>
<rawString>Representing the time between two points, and the lengths of intervals.</rawString>
</citation>
<citation valid="false">
<title>Representing weeks, months, years, and other atandard calendar atructurea.</title>
<contexts>
<context position="12600" citStr="(2)" startWordPosition="2039" endWordPosition="2039">resents the time of transition from one stage to the next. 22. Analysis of Temporal Queries This section considers four types of queries Involving temporal data, and briefly outlines the capabilites that a temporal knowledge model must have in order to understand and answer queries of each type. Queries 1-3 in Figure 2 are examples of time restriction aueries, which retrieve data about individuals or events whose dates fail into a particular interval of time. Current database systems already support time restrictions, such as Query 1, that use simple, absolute time references. Queries such as (2), which use relative time references, and (3) which refer to intervals not directly represented in the database, require a more elaborate model of time structures than current systems provide. The time domain model described In Section 3.1 can support queries of this type. The second type of query asks about the state-of-the-world on a given date (Query 4) or during an interval of time (Query 5). Understanding and answering these queries requires rules for deducing the situation at a given time, as a result of the occurrence (or non-occurrence) of events before that time. For example, Query 5 </context>
</contexts>
<marker>2.</marker>
<rawString>&apos;Representing weeks, months, years, and other atandard calendar atructurea.</rawString>
</citation>
<citation valid="false">
<title>Representing information relative to &apos;today&amp;quot; , this month&amp;quot;,</title>
<pages>etc.</pages>
<contexts>
<context position="12645" citStr="(3)" startWordPosition="2046" endWordPosition="2046"> to the next. 22. Analysis of Temporal Queries This section considers four types of queries Involving temporal data, and briefly outlines the capabilites that a temporal knowledge model must have in order to understand and answer queries of each type. Queries 1-3 in Figure 2 are examples of time restriction aueries, which retrieve data about individuals or events whose dates fail into a particular interval of time. Current database systems already support time restrictions, such as Query 1, that use simple, absolute time references. Queries such as (2), which use relative time references, and (3) which refer to intervals not directly represented in the database, require a more elaborate model of time structures than current systems provide. The time domain model described In Section 3.1 can support queries of this type. The second type of query asks about the state-of-the-world on a given date (Query 4) or during an interval of time (Query 5). Understanding and answering these queries requires rules for deducing the situation at a given time, as a result of the occurrence (or non-occurrence) of events before that time. For example, Query 5 asks about Jones&apos; salary in September of 1978</context>
</contexts>
<marker>3.</marker>
<rawString>Representing information relative to &apos;today&amp;quot; , this month&amp;quot;, etc.</rawString>
</citation>
<citation valid="false">
<title>Representing periodic time descriptions. The use of discrete, calendar-like structures as a basis for representing time in a computer is a simplification that is compatible with the discrete representation of information in databases. Hopefully, this simplification will make it easier to program the model and to integrate it into a state-of-the-art NL query system.</title>
<marker>4.</marker>
<rawString>Representing periodic time descriptions. The use of discrete, calendar-like structures as a basis for representing time in a computer is a simplification that is compatible with the discrete representation of information in databases. Hopefully, this simplification will make it easier to program the model and to integrate it into a state-of-the-art NL query system.</rawString>
</citation>
<citation valid="false">
<institution>References</institution>
<marker>5.</marker>
<rawString>References</rawString>
</citation>
<citation valid="true">
<authors>
<author>J F Allen</author>
</authors>
<title>Towards a General Theory of Action and Time.</title>
<date>1984</date>
<journal>Artificial Intelligence,</journal>
<volume>23</volume>
<pages>123--154</pages>
<contexts>
<context position="15858" citStr="(1)" startWordPosition="2618" endWordPosition="2618">s (0, DI, 02.. ) form a totally ordered set, with a &apos;distance function representing the number of days between two days. The distance function satisfies the laws of addition, i.e.: 1) distance ( D1 , D2 ) - 0 (--&gt; Dl •D 2) distance ( Dl , 02) - - distance ( D2 , Dl) 3) distance ( DI , D2 ) • distance ( 02 , 03 ) - distance ( DI , D3 ) Intervals (I, 11,12 ..) are ordered pairs of days (Os, Del such that distance (Os, De) &gt;- 0. If an interval I (Ds , Del then: 4) start ( I ) - Ds 5) end ( 1 ) - De 6) length( I ) - distance ( start (I) , end ( I )) • 1 7) during( D, 1) -&amp;quot;true &lt;-- distance ( start(1) , D) 0 and distance ( D , end(I)) &gt;- 0 Other temporal relations, such as &apos;before (DI, D2)&amp;quot;, &amp;quot;afterID I, D2)&amp;quot;, and interval relations such as those described by Allen (11, can be defined using the &apos;distance&apos; function in an equally straightforward manner. Also included in the model is a function &amp;quot;today&apos; of no arguments whose value is always the current day. Formulas (1-7) are repeated below in Prolog notation: 1) distance(D1,D2,0) :- DI 02. 2) distance(D1, D2. Y) distance(D2, Dl, X) , Y - -X. 3) distance(D1, 03, Z) distance(D1, D2, X), distance(D2, 03, Y), Z-X+Y. 4) start(I,Ds). 5) end(I,De). 6</context>
</contexts>
<marker>1.</marker>
<rawString>Allen, J. F., &apos;Towards a General Theory of Action and Time. Artificial Intelligence, Vol. 23, No. 2 (1984) 123-154</rawString>
</citation>
<citation valid="true">
<authors>
<author>T L Anderson</author>
</authors>
<title>Modeling Time at the Conceptual Level. In</title>
<date>1982</date>
<booktitle>improving Database Usability and Responsiveness,</booktitle>
<pages>273--297</pages>
<editor>P. Scheuermann, ed.,</editor>
<publisher>Academic Press,</publisher>
<location>Jerusalem:</location>
<contexts>
<context position="12600" citStr="(2)" startWordPosition="2039" endWordPosition="2039">resents the time of transition from one stage to the next. 22. Analysis of Temporal Queries This section considers four types of queries Involving temporal data, and briefly outlines the capabilites that a temporal knowledge model must have in order to understand and answer queries of each type. Queries 1-3 in Figure 2 are examples of time restriction aueries, which retrieve data about individuals or events whose dates fail into a particular interval of time. Current database systems already support time restrictions, such as Query 1, that use simple, absolute time references. Queries such as (2), which use relative time references, and (3) which refer to intervals not directly represented in the database, require a more elaborate model of time structures than current systems provide. The time domain model described In Section 3.1 can support queries of this type. The second type of query asks about the state-of-the-world on a given date (Query 4) or during an interval of time (Query 5). Understanding and answering these queries requires rules for deducing the situation at a given time, as a result of the occurrence (or non-occurrence) of events before that time. For example, Query 5 </context>
</contexts>
<marker>2.</marker>
<rawString>Anderson, T. L., &apos;Modeling Time at the Conceptual Level. In P. Scheuermann, ed., improving Database Usability and Responsiveness, pp 273-297. Jerusalem: Academic Press, 1982.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Bruce</author>
</authors>
<title>A Model for Temporal Reference and its Application in a Question Answering System.&apos;</title>
<date>1983</date>
<journal>Artificial Intelligence,</journal>
<volume>1</volume>
<issue>1972</issue>
<pages>1--25</pages>
<contexts>
<context position="12645" citStr="(3)" startWordPosition="2046" endWordPosition="2046"> to the next. 22. Analysis of Temporal Queries This section considers four types of queries Involving temporal data, and briefly outlines the capabilites that a temporal knowledge model must have in order to understand and answer queries of each type. Queries 1-3 in Figure 2 are examples of time restriction aueries, which retrieve data about individuals or events whose dates fail into a particular interval of time. Current database systems already support time restrictions, such as Query 1, that use simple, absolute time references. Queries such as (2), which use relative time references, and (3) which refer to intervals not directly represented in the database, require a more elaborate model of time structures than current systems provide. The time domain model described In Section 3.1 can support queries of this type. The second type of query asks about the state-of-the-world on a given date (Query 4) or during an interval of time (Query 5). Understanding and answering these queries requires rules for deducing the situation at a given time, as a result of the occurrence (or non-occurrence) of events before that time. For example, Query 5 asks about Jones&apos; salary in September of 1978</context>
</contexts>
<marker>3.</marker>
<rawString>Bruce, B., &apos;A Model for Temporal Reference and its Application in a Question Answering System.&apos; Artificial Intelligence, Vol 3, No. 1(1972), 1-25. 4 Clifford, J. and D. S. Warren, &amp;quot;Formal Semantics for Time in Databases.&apos; ACM TODS Vol. 8, No. 2 (1983) 214-254.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W F Clocksin</author>
<author>C</author>
</authors>
<date>1981</date>
<booktitle>Programming in Prolog.</booktitle>
<publisher>Springer-Verlag,</publisher>
<location>Berlin:</location>
<marker>5.</marker>
<rawString>Clocksin, W.F. and C. 5. Mellish, Programming in Prolog. Berlin: Springer-Verlag, 1981.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E F Codd</author>
</authors>
<title>Extending the Database Relational Model to Capture More Meaning.&apos;</title>
<date>1979</date>
<journal>AO TODS</journal>
<volume>4</volume>
<pages>397--434</pages>
<marker>6.</marker>
<rawString>Codd, E. F., &apos;Extending the Database Relational Model to Capture More Meaning.&apos; AO TODS Vol. 4, No. 4 (1979) 397-434.</rawString>
</citation>
<citation valid="false">
<authors>
<author>J Doyle</author>
</authors>
<title>A Truth Maintenance System.&apos;</title>
<journal>Artificial intelligence,</journal>
<volume>3</volume>
<issue>1979</issue>
<pages>231--272</pages>
<marker>7.</marker>
<rawString>Doyle, J., °A Truth Maintenance System.&apos; Artificial intelligence, Vol. 12, No. 3(1979), 231-272.</rawString>
</citation>
<citation valid="true">
<authors>
<author>INTELLECT Reference Manual</author>
</authors>
<date>1983</date>
<booktitle>INTELLECT LEX Utility Reference, Program Offerings LY20-9083-0 and LY20-9082-0, IBM Corp.,</booktitle>
<marker>8.</marker>
<rawString>INTELLECT Reference Manual, INTELLECT LEX Utility Reference, Program Offerings LY20-9083-0 and LY20-9082-0, IBM Corp., 1983.</rawString>
</citation>
<citation valid="false">
<authors>
<author>K Kahn</author>
<author>G</author>
</authors>
<title>A Gorry, Tlechanizing Temporal Knowledge.&apos;</title>
<journal>Artificial Intelligence, Vol</journal>
<volume>9</volume>
<issue>1977</issue>
<pages>87--108</pages>
<marker>9.</marker>
<rawString>Kahn, K. and G. A Gorry, Tlechanizing Temporal Knowledge.&apos; Artificial Intelligence, Vol 9(1977), 87-108.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Lakoff</author>
<author>M Johnson</author>
</authors>
<title>Metaphors We Live By. The University of Chicago Press,</title>
<date>1980</date>
<journal>Machine Intelligence</journal>
<booktitle>Some Philosophical Problems from the Standpoint of Artificial Intelligence.&apos; In</booktitle>
<volume>4</volume>
<editor>II. McCarthy, J. and P. J. Hayes,</editor>
<publisher>American Elsevier,</publisher>
<location>Chicago ILL</location>
<marker>10.</marker>
<rawString>Lakoff, G., and M. Johnson, Metaphors We Live By. The University of Chicago Press, Chicago ILL (1980). II. McCarthy, J. and P. J. Hayes, Some Philosophical Problems from the Standpoint of Artificial Intelligence.&apos; In B. Meltzer and D. Michie, eds., Machine Intelligence 4. American Elsevier, New York (1969).</rawString>
</citation>
<citation valid="true">
<authors>
<author>J McCarthy</author>
</authors>
<title>What is Common Sense?&apos;</title>
<date>1984</date>
<booktitle>Presidential Address at the National Conference on Artificial Intelligence (AAAI-84),</booktitle>
<location>Austin, TX</location>
<marker>12.</marker>
<rawString>McCarthy, J., &amp;quot;What is Common Sense?&apos; Presidential Address at the National Conference on Artificial Intelligence (AAAI-84), Austin, TX (1984).</rawString>
</citation>
<citation valid="false">
<authors>
<author>D McDermott</author>
</authors>
<title>A Temporal Logic for Reasoning About Processes and Plans.&apos;</title>
<journal>Cognitive Science,</journal>
<volume>Vol.</volume>
<pages>6--1982</pages>
<marker>13.</marker>
<rawString>McDermott, D., &apos;A Temporal Logic for Reasoning About Processes and Plans.&apos; Cognitive Science, Vol. 6(1982)101-155.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R C Moore</author>
</authors>
<title>Semantical Considerations on Nonmonotonic Logic.&apos;</title>
<date>1983</date>
<journal>Artificial Intelligence,</journal>
<volume>25</volume>
<pages>75--94</pages>
<marker>14.</marker>
<rawString>Moore, R. C., -Semantical Considerations on Nonmonotonic Logic.&apos; Artificial Intelligence, Vol. 25, No. 1 (1983), 75-94.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Snodgrass</author>
</authors>
<title>The Temporal Query Language TOuel.&apos;</title>
<date>1984</date>
<booktitle>In Proc. 3rd ACM SIGMOD Symp. on Principles of Database Systems,</booktitle>
<location>Waterloo, ONT</location>
<marker>15.</marker>
<rawString>Snodgrass, R., The Temporal Query Language TOuel.&apos; In Proc. 3rd ACM SIGMOD Symp. on Principles of Database Systems, Waterloo, ONT (1984).</rawString>
</citation>
<citation valid="true">
<authors>
<author>D H D Warren</author>
</authors>
<title>Efficient Processing of Interactive Relational Database Queries Expressed In Logic.&apos;</title>
<date>1981</date>
<booktitle>In Proc. 7th Conf. on Very Large Databases,</booktitle>
<pages>272--281</pages>
<publisher>IEEE Computer Society</publisher>
<marker>16.</marker>
<rawString>Warren, D. H. D., &apos;Efficient Processing of Interactive Relational Database Queries Expressed In Logic.&apos; In Proc. 7th Conf. on Very Large Databases, pp. 272-281. IEEE Computer Society (1981).</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>