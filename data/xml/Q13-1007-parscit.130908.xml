<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000006">
<title confidence="0.991923">
An HDP Model for Inducing Combinatory Categorial Grammars
</title>
<author confidence="0.996573">
Yonatan Bisk and Julia Hockenmaier
</author>
<affiliation confidence="0.998086">
Department of Computer Science
The University of Illinois at Urbana-Champaign
</affiliation>
<address confidence="0.843261">
201 N Goodwin Ave Urbana, IL 61801
</address>
<email confidence="0.999207">
{bisk1,juliahmr}@illinois.edu
</email>
<sectionHeader confidence="0.998601" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.997576333333333">
We introduce a novel nonparametric Bayesian
model for the induction of Combinatory Cat-
egorial Grammars from POS-tagged text. It
achieves state of the art performance on a
number of languages, and induces linguisti-
cally plausible lexicons.
</bodyText>
<sectionHeader confidence="0.999388" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999936379310345">
What grammatical representation is appropriate for
unsupervised grammar induction? Initial attempts
with context-free grammars (CFGs) were not very
successful (Carroll and Charniak, 1992; Charniak,
1993). One reason may be that CFGs require the
specification of a finite inventory of nonterminal cat-
egories and rewrite rules, but unless one adopts lin-
guistic principles such as X-bar theory (Jackendoff,
1977), these nonterminals are essentially arbitrary
labels that can be combined in arbitrary ways. While
further CFG-based approaches have been proposed
(Clark, 2001; Kurihara and Sato, 2004), most re-
cent work has followed Klein and Manning (2004)
in developing models for the induction of projec-
tive dependency grammars. It has been shown that
more sophisticated probability models (Headden III
et al., 2009; Gillenwater et al., 2011; Cohen and
Smith, 2010) and learning regimes (Spitkovsky et
al., 2010), as well as the incorporation of prior lin-
guistic knowledge (Cohen and Smith, 2009; Berg-
Kirkpatrick and Klein, 2010; Naseem et al., 2010)
can lead to significant improvement over Klein and
Manning’s baseline model. The use of dependency
grammars circumvents the question of how to obtain
an appropriate inventory of categories, since depen-
dency parses are simply defined by unlabeled edges
between the lexical items in the sentence. But de-
pendency grammars make it also difficult to cap-
ture non-local structures, and Blunsom and Cohn
(2010) show that it may be advantageous to refor-
mulate the underlying dependency grammar in terms
of a tree-substitution grammar (TSG) which pairs
words with treelets that specify the number of left
and right dependents they have. In this paper, we
explore yet another option: instead of dependency
grammars, we use Combinatory Categorial Gram-
mar (CCG, Steedman (1996; 2000)), a linguistically
expressive formalism that pairs lexical items with
rich categories that capture all language-specific in-
formation. This may seem a puzzling choice, since
CCG requires a significantly larger inventory of cat-
egories than is commonly assumed for CFGs. How-
ever, unlike CFG nonterminals, CCG categories are
not arbitrary symbols: they encode, and are deter-
mined by, the basic word order of the language and
the number of arguments each word takes. CCG is
very similar to TSG in that it also pairs lexical items
with rich items that capture all language-specific in-
formation. Like TSG and projective dependency
grammars, we restrict ourselves to a weakly context-
free fragment of CCG. But while TSG does not dis-
tinguish between argument and modifier dependen-
cies, CCG makes an explicit distinction between the
two. And while the elementary trees of Blunsom
and Cohn (2010)’s TSG and their internal nodel la-
bels have no obvious linguistic interpretation, the
syntactic behavior of any CCG constituent can be
directly inferred from its category. To see whether
</bodyText>
<page confidence="0.991133">
75
</page>
<note confidence="0.4041608">
Transactions of the Association for Computational Linguistics, 1 (2013) 75–88. Action Editor: Sharon Goldwater.
Submitted 11/2012; Revised 1/2013; Published 3/2013. c�2013 Association for Computational Linguistics.
N: {he, girl, lunch,...} N/N: {good, the, eating, ...}
S\N: {sleeps, ate, eating, ...} (S\N)/N: {sees, ate, ...}
S\S: {quickly, today...} (S\N)/(S\N): {good, the, ...}
</note>
<bodyText confidence="0.9997215">
the algorithm has identified the basic syntactic prop-
erties of the language, it is hence sufficient to in-
spect the induced lexicon. Conversely, Boonkwan
and Steedman (2011) show that knowledge of these
basic syntactic properties makes it very easy to cre-
ate a language-specific lexicon for accurate unsu-
pervised CCG parsing. We have recently proposed
an algorithm for inducing CCGs (Bisk and Hocken-
maier, 2012b) that has been shown to be competitive
with other approaches even when paired with a very
simple probability model (Gelling et al., 2012). In
this paper, we pair this induction algorithm with a
novel nonparametric Bayesian model that is based
on a different factorization of CCG derivations, and
show that it outperforms our original model and
many other approaches on a large number of lan-
guages. Our results indicate that the use of CCG
yields grammars that are significantly more robust
when dealing with longer sentences than most de-
pendency grammar-based approaches.
</bodyText>
<sectionHeader confidence="0.995991" genericHeader="introduction">
2 Combinatory Categorial Grammar
</sectionHeader>
<bodyText confidence="0.998976342105263">
Combinatory Categorial Grammar (Steedman,
2000) is a linguistically expressive, lexicalized
grammar formalism that associates rich syntactic
types with words and constituents. For simplicity,
we restrict ourselves to the standard two atomic
types S (sentences) and N (encompassing both
nouns and noun phrases) from which we recursively
build categories. Complex categories are of the
form X/Y or X\Y, and represent functions which
return a result of type X when combined with an
argument of type Y. The directionality of the slash
indicates whether the argument precedes or follows
the functor. We write X|Y when the direction of the
slash does not matter.
The CCG lexicon encodes all language-specific
information. It pairs every word with a set of cate-
gories that define both its specific syntactic behavior
as well as the overall word order of the language:
To draw a simple contrast, in Spanish we would
expect adjectives to take the category N\N because
Spanish word ordering dictates that the adjective fol-
low the noun. The lexical categories also capture
word-word dependencies: head-argument relations
are captured by the lexical category of the head (e.g.
(S\N)/N), whereas head-modifier relations are cap-
tured by the lexical category of the modifier, which
is of the form X\X or X/X, and may take further
arguments of its own. Our goal will be to automati-
cally learn these types of lexicons for a language. In
Figure 3, we juxtapose several such lexicons which
were automatically discovered by our system.
The rules of CCG are defined by a small set of
of combinatory rules, which are traditionally writ-
ten as schemas that define how constituents can be
combined in a bottom-up fashion (although genera-
tive probability models for CCG view them in a top-
down manner, akin to CFG rules). The first, and
most obvious, of these rules is function application:
</bodyText>
<equation confidence="0.9998305">
X/Y Y X (BO)
Y X\Y X (BO)
</equation>
<bodyText confidence="0.999990181818182">
Here the functor X/Y or X\Y is applied to an
argument Y resulting in X. While standard CCG
has a number of additional combinatory rules (type-
raising, generalized variants of composition and
substitution) that increase its generative capacity be-
yond context-free grammars and allow an elegant
treatment of non-local dependencies arising in ex-
traction, coordination and scrambling, we follow
Bisk and Hockenmaier (2012b) and use a restricted
fragment, without type-raising, that allows only ba-
sic composition and is context-free:
</bodyText>
<equation confidence="0.999207">
X/Y Y/Z X/Z (BX&gt; )
X/Y Y\Z X\Z (BX1&gt;)
Y\Z X\Y X\Z (BX&lt; )
Y/Z X\Y X/Z (BX1&lt;)
</equation>
<bodyText confidence="0.99990325">
The superscript 1 denotes the arity of the compo-
sition which is too low to recover non-projective de-
pendencies, and our grammar is thus weakly equiva-
lent to the dependency grammar representations that
are commonly used for grammar induction. The
main role of composition in our fragment is that it
allows sentential and verb modifiers to both take cat-
egories of the form S\S and S/S. Composition in-
</bodyText>
<page confidence="0.970868">
76
</page>
<bodyText confidence="0.9912242">
troduces spurious ambiguities, which we eliminate
by using Eisner (1996)’s normal form.1
Coordinating conjunctions have a special cate-
gory conj, and we binarize coordination as follows
(Hockenmaier and Steedman, 2007):
</bodyText>
<equation confidence="0.995504">
X X[conj] ⇒&amp;1 X (&amp;1)
conj X ⇒&amp;2 X[conj] (&amp;2)
</equation>
<sectionHeader confidence="0.993322" genericHeader="method">
3 Category induction
</sectionHeader>
<bodyText confidence="0.9999175">
Unlike dependency grammars, CCG requires an in-
ventory of lexical categories. Given a set of lexical
categories, the combinatory rules define the set of
parses for each sentence. We follow the algorithm
proposed by Bisk and Hockenmaier (2012b) to au-
tomatically induce these categories. The lexicon is
initialized by pairing all nominal tags (nouns, pro-
nouns and determiners) with the category N, all verb
tags with the category S, and coordinating conjunc-
tions with the category conj:
</bodyText>
<sectionHeader confidence="0.715194" genericHeader="method">
CONJ conj
DET, NOUN, NUM, PRON N
VERB S
</sectionHeader>
<bodyText confidence="0.981942095238095">
Although our lexicons are defined over corpus-
specific POS tags, we use a slightly modified version
of Petrov et al. (2012)’s Universal POS tagset to cat-
egorize them into these broad classes. The primary
changes we make to their mappings are the addition
of a distinction (where possible) between subordi-
nating and coordinating conjunctions and between
main and auxiliary verbs2.
Since the initial lexicon consists only of atomic
categories, it cannot parse any complex sentences:
The man ate quickly
DT NNS VBD RB
- N S -
Complex lexical categories are induced by con-
sidering the local context in which tokens appear.
Given an input sentence, and a current lexicon which
assigns categories to at least some of the tokens in
the sentence, we apply the following two rules to
add new categories to the lexicon: The argument
rule allows any lexical tokens that have categories
other than N and conj to take immediately adjacent
</bodyText>
<footnote confidence="0.991094333333333">
1The normal-form of Hockenmaier and Bisk (2010) is not
required for this fragment of CCG.
2This distinction was suggested by the authors (p.c.)
</footnote>
<bodyText confidence="0.99225">
Ns as arguments. The modifier rule allows any to-
ken (other than coordinating conjunctions that ap-
pear in the middle of sentences) to modify an imme-
diate neighbor that has the category S or N or is a
modifier (S|S or N|N) itself.
</bodyText>
<table confidence="0.94401225">
The man ate quickly
DT NNS VBD RB
N/N N, S/S S, N\N S\S
S\N
</table>
<bodyText confidence="0.74060925">
These rules can be applied iteratively to form
more complex categories. We restrict lexical cate-
gories to a maximal arity of 2, and disallow the cat-
egory (S/N)\N, since it is equivalent to (S\N)/N.
</bodyText>
<table confidence="0.9176995">
The man ate quickly
DT NNS VBD RB
N/N, N, S/S S, N\N, S\S,
(S/S)/(S/S) (N\N)/(N\N) S\N (N\N)\(N\N)
(N/N)\(N/N) (S/S)\(S/S)
(S\S)/(S\S)
</table>
<bodyText confidence="0.9994676">
The resultant, overly general, lexicon is then used
to parse the training data. Each complete parse has
to be of category S or N, with the constraint that
sentences that contain a main verb can only form
parses of category S.
</bodyText>
<sectionHeader confidence="0.979406" genericHeader="method">
4 A new probability model for CCG
</sectionHeader>
<bodyText confidence="0.999903823529412">
Generative models define the probability of a parse
tree T as the product of individual rule probabili-
ties. Our previous work (Bisk and Hockenmaier,
2012b) uses the most basic model of Hockenmaier
and Steedman (2002), which first generates the head
direction (left, right, unary, or lexical), followed by
the head category, and finally the sister category. 3
This factorization does not take advantage of the
unique functional nature of CCG. We therefore in-
troduce a new factorization we call the Argument
Model. It exploits the fact that CCG imposes strong
constraints on a category’s left and right children,
since these must combine to create the parent type
via one of the combinators. In practice this means
that given the parent X/Z, the choice of combinator4
c and an argument Y we can uniquely determine the
categories of the left and right children:
</bodyText>
<footnote confidence="0.9966476">
3Huang et al. (2012) present a (deficient) variant and
Bayesian extension of the Bisk and Hockenmaier (2012b)
model without k-best smoothing that both underperform our
published results.
4If X is an atomic category, only application is possible.
</footnote>
<page confidence="0.975612">
77
</page>
<equation confidence="0.990565333333333">
Parent c ⇒ Left Right
X/Z B0 (X/Z)/Y Y
&gt;
B0 Y (X/Z)\Y
&lt;
B1 X/Y Y/Z
&gt;
B1 Y/Z X\Y
&lt;
</equation>
<bodyText confidence="0.94521">
and correspondingly for X\Z:
</bodyText>
<equation confidence="0.990367444444444">
Parent c ⇒ Left Right
X\Z B0 (X\Z)/Y Y
&gt;
B0 Y (X\Z)\Y
&lt;
B1 X/Y Y\Z
&gt;
B1 Y\Z X\Y
&lt;
</equation>
<bodyText confidence="0.999971666666667">
While type-changing and raising are not used in
this work the model’s treatment of root productions
extends easily to handle these other unary cases. We
simply treat the argument Y as the unary outcome so
that the parent, combinator and argument uniquely
specify every detail of the unary rule:
</bodyText>
<equation confidence="0.968679">
Parent c ⇒ Y
TOP TOP E {S, N}
S/(S\N) T&lt; N
S\(S/N) T&gt; N
</equation>
<bodyText confidence="0.999882666666667">
We still distinguish the same rule types as before
(lexical, unary, binary with head left/right), leading
us to the following model definition:
</bodyText>
<equation confidence="0.43496325">
Given: P := X/Z
where type(t) E {Left,Right,Unary,Lex}
�p(w|P,t) Lex
p(Y|P, t) x p(c|P, t, Y) o.w.
</equation>
<subsectionHeader confidence="0.563925">
Argument Combinator
</subsectionHeader>
<bodyText confidence="0.999887">
Note that this model generates only one CCG cat-
egory but uniquely defines the two children of a par-
ent node. We will see below that this greatly simpli-
fies the development of non-parametric extensions.
</bodyText>
<sectionHeader confidence="0.959435" genericHeader="method">
5 HDP-CCG: a nonparametric model
</sectionHeader>
<bodyText confidence="0.982869724137931">
Simple generative models such as PCFGs or Bisk
and Hockenmaier (2012b)’s CCG model are not
robust in the face of sparsity, since they assign
zero probability to any unseen event. Sparsity is
a particular problem for formalisms like CCG that
have a rich inventory of object types. Nonpara-
metric Bayesian models, e.g. Dirichlet Processes
(Teh, 2010) or their hierarchical variants (Teh et
al., 2006) and generalizations (Teh, 2006) overcome
this problem in a very elegant manner, and are used
by many state-of-the-art grammar induction systems
(Naseem et al., 2010; Blunsom and Cohn, 2010;
Boonkwan and Steedman, 2011). They also im-
pose a rich-getting-richer behavior that seems to be
advantageous in many modeling applications. By
contrast, Bisk and Hockenmaier (2012b) propose a
weighted top-k scheme to address these issues in an
ad-hoc manner.
The argument model introduced above lends it-
self particularly well to nonparametric extensions
such as the standard Hierarchical Dirichlet Pro-
cesses (HDP). In this work the size of the grammar
and the number of productions are fixed and small,
but we present the formulation as infinite to allow for
easy extension in the future. Specifically, this frame-
work allows for extensions which grow the grammar
during parsing/training or fully lexicalize the pro-
ductions. Additionally, while our current work uses
only a restricted fragment of CCG that has only a
finite set of categories, the literature’s generalized
variants of composition make it possible to gener-
ate categories of unbounded arity. We therefore be-
lieve that this is a very natural probabilistic frame-
work for CCG, since HDPs make it possible to con-
sider a potentially infinite set of categories that can
instantiate the Y slot, while allowing the model to
capture language-specific preferences for the set of
categories that can appear in this position.
The HDP-CCG model In Bayesian models,
multinomials are drawn from a corresponding n-
dimensional Dirichlet distribution. The Dirichlet
Process (DP) generalizes the Dirichlet distribution
to an infinite number of possible outcomes, allowing
us to deal with a potentially infinite set of categories
or words. DPs are defined in terms of a base dis-
tribution H that corresponds to the mean of the DP,
and a concentration or shape parameter α. In a Hi-
erarchical Dirichlet Process (Teh et al., 2006), there
is a hierarchy of DPs, such that the base distribution
of a DP at level n is a DP at level n − 1.
The HDP-CCG (Figure 1) is a reformulation of
the Argument Model introduced above in terms of
Hierarchical Dirichlet Processes.5 At the heart of
the model is a distribution over CCG categories. By
combining a stick breaking process with a multino-
mial over categories we can define a DP over CCG
5An alternative HDP model for semantic parsing with CCG
is proposed by Kwiatkowski et al. (2012).
</bodyText>
<equation confidence="0.628944">
p(t|P) x
</equation>
<page confidence="0.731844">
78
</page>
<figure confidence="0.895141076923077">
βY
βL
z ∞
y
φY
φL
θT
θC
∞
zi
yi ci
zL(i) zR(i)
xL(i) xR(i)
</figure>
<bodyText confidence="0.999187333333333">
Because we are working with CCG, the
parent zi, argument yi and combinator ci
uniquely define the two children categories
(zL(i), zR(i)). The dashed arrows here rep-
resent the deterministic process used to
generate these two categories.
</bodyText>
<figure confidence="0.910833952380952">
HDP-CCG
1) Draw global parameters
Define MLE root parameter θTOP
Draw top-level symbol weights βY — GEM(αY )
Draw top-level lexical weights βL — GEM(αL)
For each grammar symbol z E {1, 2, ...}:
Define MLE rule type parameters θTz
Draw argument parameters φYz — DP(αY, βY )
Draw lexical emission parameters φLz — DP(αL, βL)
For each grammar symbol y E {1, 2, ...}:
Define MLE combinator parameters θC z,y
2) For each parse tree:
Generate root node zTOP — Binomial(θTOP)
For each node i in the parse tree:
Choose rule type ti — Multinomial(θTzi)
If ti == Lex:
Emit terminal symbol xi — Multinomial(φLzi)
If ti == Left/Right/Unary:
Generate argument category yi — Multinomial(φz )
Generate combinator ci — Multinomial(θu,yi)
Deterministically create zL(i) (and zR(i) if binary)
</figure>
<figureCaption confidence="0.999844">
Figure 1: The HDP-CCG has two base distributions, one over the space of categories and the other over
</figureCaption>
<bodyText confidence="0.995005444444445">
words (or tags). For every grammar symbol, an argument distribution and emission distribution is drawn
from the corresponding Dirichlet Processes. In addition, there are several MLE distributions tied to a given
symbol for generating rule types, combinators and lexical tokens.
categories whose stick weights (βY ) correspond to
the frequency of the category in the corpus. Next we
build the hierarchical component of our model by
choosing an argument distribution (φY ), again over
the space of categories, for every parent X/Z. This
argument distribution is drawn from the previously
defined base DP, allowing for an important level of
parameter tying across all argument distributions.
While the base DP does define the mean around
which all argument distributions are drawn, we also
require a notion of variance or precision which de-
termines how similar individual draws will be. This
precision is determined by the magnitude of the hy-
perparameter αY . This hierarchy is paralleled for
lexical productions which are drawn from a unigram
base DP over terminal symbols controlled by αL.
For simplicity we use the same scheme for setting
the values for αL as αY . We present experimen-
tal results in which we vary the value of αY as a
function of the number of outcomes allowed by the
grammar for argument categories or the corpus in
the case of terminal symbols. Specifically, we set
αY = np for conditioning contexts with n out-
comes. Since Liang et al. (2009) found that the ideal
value for alpha appears to be superlinear but sub-
quadratic in n, we present results where p takes the
values 0, 1.0, 1.5, and 2.0 to explore the range from
uniform to quadratic. This setting for α is the only
free parameter in the model. By controlling preci-
sion we can tell the model to what extent global cor-
pus statistics should be trusted. We believe this has
a similar effect to Bisk and Hockenmaier (2012b)’s
top-k upweighting and smoothing scheme.
One advantage of the argument model is that it
only requires a single distribution over categories for
each binary tree. In contrast to similar proposals for
CFGs (Liang et al., 2007), which impose no formal
restrictions on the nonterminals X, Y, Z that can ap-
pear in a rewrite rule X -+ Y Z, this greatly sim-
plifies the modeling problem (yielding effectively a
model that is more akin to nonparametric HMMs),
since it avoids the need to capture correlations be-
</bodyText>
<page confidence="0.993173">
79
</page>
<bodyText confidence="0.999145966666667">
tween different base distributions for Y and Z.
Variational Inference HDPs need to be estimated
with approximate techniques. As an alternative to
Gibbs sampling (Teh et al., 2006), which is exact,
but typically very slow and has no clear convergence
criteria, variational inference algorithms (Bishop,
2006; Blei and Jordan, 2004) estimate the parame-
ters of a truncated model to maximize a lower bound
of the likelihood of the actual model. This allows for
factorization of the model and a training procedure
analogous to the Inside-Outside algorithm (Lari and
Young, 1991), allowing training to run very quickly
and in a trivially parallelizable manner.
To initialize the base DP’s stick weights, we fol-
low the example of Kurihara et al. (2007) and use
an MLE model initialized with uniform distributions
to compute global counts for the categories in our
grammar. When normalized these provide a better
initialization than a uniform set of weights. Updates
to the distributions are then performed in a coordi-
nate descent manner which includes re-estimation of
the base DPs.
In variational inference, multinomial weights W
take the place of probabilities. The weights for an
outcome Y with conditioning variable P are com-
puted by summing pseudocounts with a scaled mean
vector from the base DP. The computation involves
moving in the direction of the gradient of the Dirich-
let distribution which results in the following differ-
ence of Digammas (Ψ):
</bodyText>
<equation confidence="0.9996895">
Wp(Y) = Ψ(C(P, Y ) + αPoY )
− Ψ(C(P, ∗) + αP)
</equation>
<bodyText confidence="0.999953">
Importantly, the Digamma and multinomial
weights comprise a righ-get-richer scheme, biasing
the model against rare outcomes. In addition, since
variational inference is done by coordinate descent,
it is trivially parallelizeable. In practice, training and
testing our models on the corpora containing sen-
tences up to length 15 used in this paper takes be-
tween one minute to at most three hours on a single
12-core machine depending on their size.
</bodyText>
<sectionHeader confidence="0.999548" genericHeader="evaluation">
6 Evaluation
</sectionHeader>
<bodyText confidence="0.99996842">
As is standard for this task, we evaluate our systems
against a number of different dependency treebanks,
and measure performance in terms of the accuracy of
directed dependencies (i.e. the percentage of words
in the test corpus that are correctly attached). We use
the data from the PASCAL challenge for grammar
induction (Gelling et al., 2012), the data from the
CoNLL-X shared task (Buchholz and Marsi, 2006)
and Goldberg (2011)’s Hebrew corpus.
Converting CCG derivations into dependencies is
mostly straightforward, since the CCG derivation
identifies the root word of each sentence, and head-
argument and head-modifier dependencies are easily
read off of CCG derivations, since the lexicon de-
fines them explicitly. Unlike dependency grammar,
CCG is designed to recover non-local dependencies
that arise in control and binding constructions as
well as in wh-extraction and non-standard coordi-
nation, but since this requires re-entrancies, or co-
indexation of arguments (Hockenmaier and Steed-
man, 2007), within the lexical categories that trigger
these constructions, our current system returns only
local dependencies. But since dependency gram-
mars also captures only local dependencies, this has
no negative influence on our current evaluation.
However, a direct comparison between depen-
dency treebanks and dependencies produced by
CCG is more difficult (Clark and Curran, 2007),
since dependency grammars allow considerable
freedom in how to analyze specific constructions
such as verb clusters (which verb is the head?)
prepositional phrases and particles (is the head the
noun or the preposition/particle?), subordinating
conjunctions (is the conjunction a dependent of the
head of the main clause and the head of the embed-
ded clause a dependent of the conjunction, or vice
versa?) and this is reflected in the fact that the tree-
banks we consider often apply different conventions
for these cases. Although remedying this issue is
beyond the scope of this work, these discrepancies
very much hint at the need for a better mechanism to
evaluate linguistically equivalent structures or tree-
bank standardization.
The most problematic construction is coordina-
tion. In standard CCG-to-dependency schemes, both
conjuncts are independent, and the conjunction itself
is not attached to the dependency graph, whereas de-
pendency grammars have to stipulate that either one
of the conjuncts or the conjunction itself is the head,
with multiple possibilities of where the remaining
</bodyText>
<page confidence="0.985504">
80
</page>
<bodyText confidence="0.999947875">
constituents attach. In addition to the standard CCG
scheme, we have identified five main styles of con-
junction in our data (Figure 2), although several cor-
pora distinguish multiple types of coordinating con-
junctions which use different styles (not all shown
here). Since our system has explicit rules for coordi-
nation, we transform its output into the desired target
representation that is specific to each language.
</bodyText>
<sectionHeader confidence="0.999397" genericHeader="evaluation">
7 Experiments
</sectionHeader>
<bodyText confidence="0.999843466666667">
We evaluate our system on 13 different languages.
In each case, we follow the test and training regimes
that were used to obtain previously published results
in order to allow a direct comparison. We com-
pare our system to the results presented at the PAS-
CAL Challenge on Grammar Induction (Gelling et
al., 2012)6, as well as to Gillenwater et al. (2011)
and Naseem et al. (2012). We use Nivre (2006)’s
Penn2Malt implementation of Collins (2003)’s head
rules to translate the WSJ Penn Treebank (Marcus
et al., 1993) into dependencies. Finally, when train-
ing the MLE version of our model we use a simple
smoothing scheme which defines a small rule proba-
bility (e−15) to prevent any rule used during training
from going to zero.
</bodyText>
<subsectionHeader confidence="0.651601">
7.1 PASCAL Challenge on Grammar
Induction
</subsectionHeader>
<bodyText confidence="0.9999518">
In Table 1, we compare the performance of the ba-
sic Argument model (MLE), of our HDP model with
four different settings of the hyperparameters (as ex-
plained above) and of the systems presented in the
PASCAL Challenge on Grammar Induction (Gelling
et al., 2012). The systems in this competition were
instructed to train over the full dataset, including the
unlabelled test data, and include Bisk and Hocken-
maier (2012a)’s CCG-based system (BH) to Cohn et
al. (2010)’s reimplementation of Klein and Manning
(2004)’s DMV model in a tree-substitution gram-
mar framework (BC), as well as three other de-
pendency based systems which either incorporate
Naseem et al. (2010)’s rules in a deterministic fash-
ion (Søgaard, 2012), rely on extensive tuning on
</bodyText>
<footnote confidence="0.7892316">
6Numbers are from personal correspondence with the orga-
nizers. The previously published numbers are not comparable
to literature due to an error in the evaluation. http://wiki.
cs.ox.ac.uk/InducingLinguisticStructure/
ResultsDepComparable
</footnote>
<bodyText confidence="0.999970486486486">
the development set (Tu, 2012) or incorporate mil-
lions of additional tokens from Wikipedia to esti-
mate model parameters (Marecek and Zabokrtsky,
2012). We ignore punctuation for all experiments
reported in this paper, but since the training data
(but not the evaluation) includes punctuation marks,
participants were free to choose whether to include
punctuation or ignore it.
While BH is the only other system with directly
interpretable linguistic output, we also include a di-
rect comparison with BC, whose TSG representa-
tion is equally expressive to ours. Finally we present
a row with the maximum performance among the
other three models. As we have no knowledge of
how much data was used in the training of other sys-
tems we simply present results for systems trained
on length 15 (not including punctuation) sentences
and then evaluated at lengths 10 and 15.
The MLE version of our model shows rather vari-
able performance: although its results are particu-
larly bad on Basque (Eu), it outperforms both BH
and BC on some other settings. By contrast, the
HDP system is always better than the MLE model.
It outperforms all other systems on half of the cor-
pora. On average, it outperforms BH and BC by
10.3% and 9.3% on length 10, or 9.7% and 7.8 %
on length 15 respectively. The main reason why our
system does not outperform BC by an even higher
margin is the very obvious 11.4%/11.5% deficit on
Slovene. However, the Slovene dependency tree-
bank seems to follow a substantially different anno-
tation scheme. In particular, the gold standard an-
notation of the 1,000 sentences in the Slovene de-
velopment set treats many of them as consisting of
independent sentences (often separated by punctua-
tion marks that our system has no access to), so that
the average number of roots per sentence is 2.7:
</bodyText>
<equation confidence="0.7191925">
verjeti ti , je mehko rekla
believe I , ” is soft said
</equation>
<bodyText confidence="0.999827">
When our system is presented with these short
components in isolation, it oftentimes analyzes them
correctly, but since it has to return a tree with a sin-
gle root, its performance degrades substantially.
We believe the HDP performs so well as com-
pared to the MLE model because of the influence
of the shared base distribution, which allows the
</bodyText>
<figure confidence="0.685219857142857">
GG
81
PASCAL
This work
Ar, Eu, Cs, Nl,
WSJ, Ch, He Da, He Es, Bg, De, Pt Sv, Sl Ja
noun conj noun noun conj noun noun conj noun noun conj noun noun conj noun
</figure>
<figureCaption confidence="0.95956275">
Figure 2: In the treebanks used for evaluation different standards exist for annotating coordination. While
not exhaustive, this table demonstrates five of the most common schemes used in the literature. Syntactically
these are identical and traditionally CCG draws arcs only to the arguments without attaching the conjunction.
For the purposes of comparison with the literature we have implemented these five translation schemes.
</figureCaption>
<table confidence="0.999606083333333">
Arabic Danish Slovene Swedish Dutch Basque Portuguese WSJ Childes Czech
#Tokens 5,470 25,341 54,032 61,877 78,737 81,345 158,648 163,727 290,604 436,126
# Tags 20 24 36 30 304 14 23 36 69 62
BC 60.8/58.4 44.7/39.4 62.6/57.9 63.2/56.6 51.8/52.0 53.0/48.9 52.4/50.2 68.6/63.3 47.4/46.1 47.9/43.1
Max 67.2/66.8 60.1/56.0 65.6/61.8 72.8/63.4 51.1/47.6 53.7/47.8 67.0/61.8 71.2/64.8 56.0/54.5 58.3/54.4
BH 41.6/43.7 46.4/43.8 49.6/43.9 63.7/57.0 49.7/43.6 45.1/39.6 70.8/67.2 68.2/59.6 61.4/59.8 45.0/38.9
MLE 41.6/42.9 43.4/39.2 46.1/41.1 70.1/59.7 52.2/47.2 29.6/26.5 62.2/59.7 59.5/52.4 53.3/51.9 50.5/45.8
HDP0.0 48.0/50.0 63.9/58.5 44.8/39.8 67.6/62.1 45.0/33.9 41.6/39.1 71.0/66.0 59.8/52.9 56.3/55.2 54.0/49.0
HDP1.0 45.6/47.1 45.7/42.3 53.9/46.9 74.5/66.9 58.5/54.4 50.1/44.6 65.1/60.6 64.3/56.5 71.5/70.3 55.8/50.7
HDP1.5 49.6/50.4 58.7/54.4 53.2/48.2 74.3/67.1 57.4/54.5 50.6/45.0 70.0/64.7 65.5/57.2 69.6/68.6 55.6/50.3
HDP2.0 66.4/65.1 56.5/49.5 54.2/46.4 71.6/64.1 51.7/48.3 49.4/43.3 76.3/70.5 70.7/62.9 74.1/73.3 54.4/48.5
+/− -0.8/-1.7 +3.8/+2.5 -11.4/-15.4 +1.7/+3.5 +6.7/+2.4 -3.1/-3.9 +5.5/+3.3 -0.5/-1.9 +12.7/+13.5 -2.5/-3.7
</table>
<tableCaption confidence="0.997183">
Table 1: A comparison of the basic Argument model (MLE) and four hyper-parameter settings of the HDP-
</tableCaption>
<bodyText confidence="0.984974866666667">
CCG against two syntactic formalisms that participated in the PASCAL Challenge (Gelling et al., 2012),
BH (Bisk and Hockenmaier, 2012a) and BC (Blunsom and Cohn, 2010), in addition to a max over all other
participants. We trained on length 15 data (punctuation removed), including the test data as recommended
by the organizers. The last row indicates the difference between our best system and the competition.
global category distribution to influence each of the
more specific distributions. Further, it provides a
very simple knob in the choice of hyperparame-
ters, which has a substantial effect on performance.
A side effect of the hyperparameters is that their
strength also determines the rate of convergence.
This may be one of the reasons for the high vari-
ance seen in the four settings tested, although we
note that since our initialization is always uniform,
and not random, consecutive runs do not introduce
variance in the model’s performance.
</bodyText>
<subsectionHeader confidence="0.995404">
7.2 Comparison with systems that capture
linguistic constraints
</subsectionHeader>
<bodyText confidence="0.99947435">
Since our induction algorithm is based on the knowl-
edge of which POS tags are nouns and verbs, we
compare in Table 2 our system to Naseem et al.
(2010), who present a nonparametric dependency
model that incorporates thirteen universal linguistic
constraints. Three of these constraints correspond
to our rules that verbs are the roots of sentences and
may take nouns as dependents, but the other ten con-
straints (e.g. that adjectives modify nouns, adverbs
modify adjectives or verbs, etc.) have no equivalent
in our system. Although our system has less prior
knowledge, it still performs competitively.
On the WSJ, Naseem et al. demonstrate the im-
portance and effect of the specific choice of syntactic
rules by comparing the performance of their system
with hand crafted universal rules (71.9), with En-
glish specific rules (73.8), and with rules proposed
by Druck et al. (2009) (64.9). The performance of
Naseem et al.’s system drops very significantly as
sentence length (and presumable parse complexity)
</bodyText>
<page confidence="0.99526">
82
</page>
<table confidence="0.998018">
Sl Es Da Pt Sv
∼#Tokens 3.8K 4.2K 9.5K 15K 24K
N10 50.9 67.2 51.9 71.5 63.3
HDP 56.6 62.1 51.5 74.7 69.8
</table>
<tableCaption confidence="0.992489">
Table 2: A comparison of our system with Naseem
</tableCaption>
<bodyText confidence="0.8686514">
et al. (2010), both trained and tested on the length 10
training data from the CoNLL-X Shared Task.
increases, whereas our system shows significantly
less decline, and outperforms their universal system
by a significant margin.7
</bodyText>
<table confidence="0.998666">
&lt; 10 &lt; 20
Naseem Universal Rules 71.9 50.4
Naseem English Rules 73.8 66.1
HDP-CCG 68.2 64.2
HDP-CCG (train ≤ 20) 71.9
</table>
<bodyText confidence="0.999905">
In contrast to Spitkovsky et al. (2010), who reported
that performance of their dependency based system
degrades when trained on longer sentences, our per-
formance on length 10 sentences increases to 71.9
when we train on sentences up to length 20.
Another system that is also based on CCG, but
captures significantly more linguistic knowledge
than ours, was presented by Boonkwan and Steed-
man (2011), who achieve an accuracy of 74.5 on
WSJ10 section 23 (trained on sections 02-22). Us-
ing the same settings, our system achieves an accu-
racy of 68.4. Unlike our approach, Boonkwan and
Steedman do not automatically induce an appropri-
ate inventory of lexical category, but use an exten-
sive questionnaire that defines prototype categories
for various syntactic constructions, and requires sig-
nificant manual engineering of which POS tags are
mapped to what categories to generate a language-
specific lexicon. However, their performance de-
grades significantly when only a subset of the ques-
tions are considered. Using only the first 14 ques-
tions, covering facts about the ordering of subjects,
verbs and objects, adjectives, adverbs, auxiliaries,
adpositions, possessives and relative markers, they
achieve an accuracy of 68.2, which is almost iden-
</bodyText>
<footnote confidence="0.987954333333333">
7Our earlier generative model showed similar behavior, al-
though the results in Bisk and Hockenmaier (2012b) are not
directly comparable due to differences in the data.
</footnote>
<table confidence="0.99826025">
Sl Es Da Pt Sv
#Tokens 3,857 4,230 9,549 15,015 24,021
G10 51.2 62.4 47.2 54.3 48.6
HDP 57.9 65.4 49.3 73.5 73.2
Bg WSJ Nl Ja De
#Tokens 38,220 42,442 43,405 43,501 77,705
G10 59.8 64.4 47.5 60.2 47.4
HDP 66.1 70.3 56.2 64.1 68.4
</table>
<tableCaption confidence="0.996593">
Table 3: A comparison of our system with Gillenwa-
</tableCaption>
<bodyText confidence="0.9183658">
ter et al. (2010), both trained on the length 10 train-
ing data, and tested on the length 10 test data, from
the CoNLL-X Shared task.
tical to ours, even though we use significantly less
initial knowledge. However, the lexicons we present
below indicate that we are in fact learning many of
the very exact details that in their system are con-
structed by hand. The remaining 14 questions in
Boonkwan and Steedman’s questionnaire cover less
frequent phenomena such as the order of negative
markers, dative shift, and pro-drop. The obvious ad-
vantage of this approach is that this allows them to
define a much more fine-grained inventory of lexical
categories than our system can automatically induce.
We also stipulate that for certain languages knowl-
edge of pro-drop could play a significant role in the
success of their approach: if complete sentences are
allowed to be of the form S\N or S/N, the same lex-
ical category can be used for the verb regardless of
whether the subject is present or has been dropped.
</bodyText>
<subsectionHeader confidence="0.998884">
7.3 Additional Languages
</subsectionHeader>
<bodyText confidence="0.999113857142857">
In order to provide results on additional languages,
we present in Table 3 a comparison to the work of
Gillenwater et al. (2010) (G10), using the ConLL-X
Shared Task data (Buchholz and Marsi, 2006). Fol-
lowing Gillenwater et al., we train only on sentences
of length 10 from the training set and evaluate on the
test set. Since this is a different training regime, and
these corpora differ for many languages from that of
the PASCAL challenge, numbers from Table 1 can-
not be compared directly with those in Table 3. We
have also applied our model to Goldberg (2011)’s
Hebrew corpus, where it achieves an accuracy of
62.1 (trained and tested on all sentences length 10;
7,253) and 59.6 (length 15; 21,422 tokens).
</bodyText>
<page confidence="0.996519">
83
</page>
<table confidence="0.9963455">
Arabic % Swedish % WSJ % Childes % Japanese % Czech %
VERB (S\N)/N 56 S 45 S\N 52 S/N 44 S 84 S 26
(S/N)/N 29 S\N 20 (S\N)/N 19 S 37 S\N 25
ADP N\N 68 (S\S)/N 49 (S\S)/N 46 (S\S)/N 45 (S/S)\N 44 (S\S)/N 42
N/N 21 (N\N)/N 25 (N\N)/N 20 N/N 25 N\N 23 (S/S)/N 26
NOUN N\N 50 N 91 N 79 N 89 N 73 N 74
N 35 N/N 12
ADJ N\N 82 N/N 50 N/N 70 N/N 46 S/S 64 N/N 55
</table>
<figureCaption confidence="0.991245">
Figure 3: Partial lexicons demonstrating language specific knowledge learned automatically for five lan-
guages. For ease of comparison between languages, we use the universal tag label (Verb, Adposition, Noun
and Adjective). Shown are the most common categories and the fraction of occurrences of the tag that are
assigned this category (according to the Viterbi parses).
</figureCaption>
<sectionHeader confidence="0.958436" genericHeader="conclusions">
8 The Induced Lexicons 9 Conclusions
</sectionHeader>
<bodyText confidence="0.999990870370371">
Since our approach is based on a lexicalized for-
malism such as CCG, our system automatically in-
duces lexicons that pair words (or, in our case, POS-
tags) with language-specific categories that capture
their syntactic behavior. If our approach is success-
ful, it should learn the basic syntactic properties of
each language, which will be reflected in the corre-
sponding lexicon. In Figure 3 one sees how verbs
subcategorize differently, how word ordering differs
by language, and how the attachment structures of
prepositions are automatically discovered and differ
across languages. In Arabic, for example, the sys-
tem learns that word order is variable and therefore
the verb must allow for both SVO and VOS style
constructions. We generally learn that adpositions
(prepositions or postpositions) take nouns as argu-
ments. In Czech, PPs can appear before and after the
verb, leading to two different categories ((S\S)/N
and (S/S)/N). Japanese has postpositions that ap-
pear in preverbal position ((S/S)\N), but when this
category is assigned to nominal particles that cor-
respond to case markers, it effectively absorbs the
noun, leading to a preference for verbs that do not
take any arguments (S), and to a misanalysis of ad-
jectives as verb modifiers (S/S). Our lexicons also
reflect differences in style: while Childes and the
WSJ are both English, they represent very different
registers. We learn that subjects are mostly absent in
the informal speech and child-directed instructions
contained in Childes, while effectively mandatory in
the Wall Street Journal.
This paper has introduced a novel factorization for
CCG models and showed how when combined with
non-parametric Bayesian statistics it can compete
with every other grammar induction system cur-
rently available, including those that capture a sig-
nificant amount of prior linguistic knowledge. The
use of a powerful syntactic formalism proves ben-
eficial both in terms of requiring very limited uni-
versal knowledge and robustness at longer sentence
lengths. Unlike standard grammar induction sys-
tems that are based on dependency grammar, our
system returns linguistically interpretable lexicons
for each language that demonstrate it has discov-
ered their basic word order. Of particular note is the
simplicity of the model both algorithmically and in
terms of implementation. By not faltering on longer
sentences or requiring extensive tuning, the system
can be easily and quickly deployed on a new lan-
guage and return state of the art performance and
easily interpretable lexicons. In this paper, we have
applied this model only to a restricted fragment of
CCG, but future work will address the impact of lex-
icalization and the inclusion of richer combinators.
</bodyText>
<sectionHeader confidence="0.99482" genericHeader="acknowledgments">
10 Acknowledgements
</sectionHeader>
<bodyText confidence="0.953478666666667">
This work is supported by NSF CAREER award
1053856 (Bayesian Models for Lexicalized Gram-
mars).
</bodyText>
<page confidence="0.997874">
84
</page>
<sectionHeader confidence="0.996316" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999350330188679">
Taylor Berg-Kirkpatrick and Dan Klein. 2010. Phyloge-
netic Grammar Induction. In Proceedings of the 48th
Annual Meeting of the Association for Computational
Linguistics, pages 1288–1297, Uppsala, Sweden, July.
Christopher Bishop. 2006. Pattern Recognition and Ma-
chine Learning. Springer-Verlag, August.
Yonatan Bisk and Julia Hockenmaier. 2012a. Induction
of Linguistic Structure with Combinatory Categorial
Grammars. In NAACL HLT Workshop on Induction of
Linguistic Structure, pages 90–95, Montr´eal, Canada,
June.
Yonatan Bisk and Julia Hockenmaier. 2012b. Simple
Robust Grammar Induction with Combinatory Cate-
gorial Grammars. In Proceedings of the Twenty-Sixth
Conference on Artificial Intelligence (AAAI-12), pages
1643–1649, Toronto, Canada, July.
David M Blei and Michael I Jordan. 2004. Variational
Methods for the Dirichlet Process. In Proceedings of
the Twenty-First International Conference on Machine
Learning (ICML 2004), Banff, Alberta, Canada, July.
Phil Blunsom and Trevor Cohn. 2010. Unsupervised
Induction of Tree Substitution Grammars for Depen-
dency Parsing. Proceedings of the 2010 Conference
on Empirical Methods of Natural Language Process-
ing, pages 1204–1213, October.
Prachya Boonkwan and Mark Steedman. 2011. Gram-
mar Induction from Text Using Small Syntactic Proto-
types. In Proceedings of 5th International Joint Con-
ference on Natural Language Processing, pages 438–
446, Chiang Mai, Thailand, November.
Sabine Buchholz and Erwin Marsi. 2006. CoNLL-X
Shared Task on Multilingual Dependency Parsing. In
Proceedings of the 10th Conference on Computational
Natural Language Learning (CoNLL-X), pages 149–
164, New York City, June.
Glenn Carroll and Eugene Charniak. 1992. Two Exper-
iments on Learning Probabilistic Dependency Gram-
mars from Corpora. Working Notes of the Workshop
Statistically-Based NLP Techniques, pages 1–13.
Eugene Charniak. 1993. Statistical Language Learning.
The MIT Press, Cambridge, Massachusetts.
Stephen Clark and James R Curran. 2007. Formalism-
Independent Parser Evaluation with CCG and Dep-
Bank. In Proceedings of the 45th Annual Meeting of
the Association of Computational Linguistics, pages
248–255, Prague, Czech Republic, June.
Alex Clark. 2001. Unsupervised Language Acquisition:
Theory and Practice. Ph.D. thesis, University of Sus-
sex, September.
Shay B Cohen and Noah A Smith. 2009. Variational
Inference for Grammar Induction with Prior Knowl-
edge. Proceedings of the ACL-IJCNLP 2009 Confer-
ence Short Papers, pages 1–4.
Shay B Cohen and Noah A Smith. 2010. Covariance
in Unsupervised Learning of Probabilistic Grammars.
The Journal of Machine Learning Research, pages
3117–3151, November.
Trevor Cohn, Phil Blunsom, and Sharon Goldwater.
2010. Inducing Tree-Substitution Grammars. The
Journal of Machine Learning Research, 11:3053–
3096, November.
Michael Collins. 2003. Head-Driven Statistical Mod-
els for Natural Language Parsing. Computational Lin-
guistics, 29(4):589–637, December.
Gregory Druck, Gideon Mann, and Andrew McCal-
lum. 2009. Semi-supervised Learning of Dependency
Parsers using Generalized Expectation Criteria. In
Proceedings of the Joint Conference of the 47th An-
nual Meeting of the ACL and the 4th International
Joint Conference on Natural Language Processing of
the AFNLP, pages 360–368, Suntec, Singapore, Au-
gust.
Jason Eisner. 1996. Efficient Normal-Form Parsing for
Combinatory Categorial Grammar. In Proceedings of
the 34th Annual Meeting of the Association for Com-
putational Linguistics, pages 79–86, Santa Cruz, Cali-
fornia, USA, June.
Douwe Gelling, Trevor Cohn, Phil Blunsom, and Jo˜ao V
Graca. 2012. The PASCAL Challenge on Grammar
Induction. In NAACL HLT Workshop on Induction of
Linguistic Structure, pages 64–80, Montr´eal, Canada,
June.
Jennifer Gillenwater, Kuzman Ganchev, Jo˜ao V Graca,
Fernando Pereira, and Ben Taskar. 2010. Sparsity in
Dependency Grammar Induction. In Proceedings of
the 48th Annual Meeting of the Association for Com-
putational Linguistics, pages 194–199, Uppsala, Swe-
den, July.
Jennifer Gillenwater, Kuzman Ganchev, Jo˜ao V Graca,
Fernando Pereira, and Ben Taskar. 2011. Posterior
Sparsity in Unsupervised Dependency Parsing. The
Journal of Machine Learning Research, 12:455–490,
February.
Yoav Goldberg. 2011. Automatic Syntactic Processing of
Modern Hebrew. Ph.D. thesis, Ben-Gurion University
of the Negev, November.
William P Headden III, Mark Johnson, and David Mc-
Closky. 2009. Improving Unsupervised Dependency
Parsing with Richer Contexts and Smoothing. In Pro-
ceedings of Human Language Technologies: The 2009
Annual Conference of the North American Chapter of
the Association for Computational Linguistics, pages
101–109, Boulder, Colorado, June.
Julia Hockenmaier and Yonatan Bisk. 2010. Normal-
form parsing for Combinatory Categorial Grammars
with generalized composition and type-raising. In
</reference>
<page confidence="0.993654">
85
</page>
<reference confidence="0.999201556603774">
Proceedings of the 23rd International Conference on
Computational Linguistics (Coling 2010), pages 465–
473, Beijing, China, August. Coling 2010 Organizing
Committee.
Julia Hockenmaier and Mark Steedman. 2002. Gener-
ative Models for Statistical Parsing with Combinatory
Categorial Grammar. In Proceedings of 40th Annual
Meeting of the Association for Computational Lin-
guistics, pages 335–342, Philadelphia, Pennsylvania,
USA, July.
Julia Hockenmaier and Mark Steedman. 2007. CCG-
bank: A Corpus of CCG Derivations and Dependency
Structures Extracted from the Penn Treebank. Com-
putational Linguistics, 33(3):355–396, September.
Yun Huang, Min Zhang, and Chew Lim Tan. 2012.
Improved Combinatory Categorial Grammar Induc-
tion with Boundary Words and Bayesian Inference.
In Proceedings of the 24rd International Conference
on Computational Linguistics (Coling 2012), Mumbai,
India, December.
Ray Jackendoff. 1977. X-Bar Syntax: A Study of Phrase
Structure. The MIT Press.
Dan Klein and Christopher D Manning. 2004. Corpus-
Based Induction of Syntactic Structure: Models of De-
pendency and Constituency. In Proceedings of the
42nd Meeting of the Association for Computational
Linguistics (ACL’04), Main Volume, pages 478–485,
Barcelona, Spain, July.
Kenichi Kurihara and Taisuke Sato. 2004. An Appli-
cation of the Variational Bayesian Approach to Prob-
abilistic Context-Free Grammars. International Joint
Conference on Natural Language Language Process-
ing Workshop Beyond Shallow Analyses, March.
Kenichi Kurihara, Max Welling, and Yee-Whye Teh.
2007. Collapsed Variational Dirichlet Process Mix-
ture Models. In Proceedings of the 20th International
Joint Conference on Artificial Intelligence (IJCAI07),
pages 2796–2801, Hyderabad, India, January.
Tom Kwiatkowski, Sharon Goldwater, Luke Zettlemoyer,
and Mark Steedman. 2012. A probabilistic model of
syntactic and semantic acquisition from child-directed
utterances and their meanings. In Proceedings of the
13th Conference of the European Chapter of the As-
sociation for Computational Linguistics, pages 234–
244, Avignon, France, April. Association for Compu-
tational Linguistics.
Karim Lari and Steve J Young. 1991. Applications
of stochastic context-free grammars using the Inside-
Outside algorithm. Computer speech &amp; language,
5(3):237–257, January.
Percy Liang, Slav Petrov, Michael I Jordan, and Dan
Klein. 2007. The Infinite PCFG Using Hierarchical
Dirichlet Processes. In Proceedings of the 2007 Joint
Conference on Empirical Methods in Natural Lan-
guage Processing and Computational Natural Lan-
guage Learning (EMNLP-CoNLL), pages 688–697,
Prague, Czech Republic.
Percy Liang, Michael I Jordan, and Dan Klein. 2009.
Probabilistic Grammars and Hierarchical Dirichlet
Processes. In The Oxford Handbook of Applied
Bayesian Analysis. Oxford University Press.
Mitchell P Marcus, Beatrice Santorini, and Mary Ann
Marcinkiewicz. 1993. Building a Large Annotated
Corpus of English: The Penn Treebank. Computa-
tional Linguistics, 19(2):313–330, June.
David Marecek and Zdenek Zabokrtsky. 2012. Unsu-
pervised Dependency Parsing using Reducibility and
Fertility features. In NAACL HLT Workshop on Induc-
tion of Linguistic Structure, pages 84–89, Montr´eal,
Canada, June.
Tahira Naseem, Harr Chen, Regina Barzilay, and Mark
Johnson. 2010. Using Universal Linguistic Knowl-
edge to Guide Grammar Induction. In Proceedings of
the 2010 Conference on Empirical Methods in Natural
Language Processing, pages 1234–1244, Cambridge,
MA, October.
Tahira Naseem, Regina Barzilay, and Amir Globerson.
2012. Selective Sharing for Multilingual Dependency
Parsing. In Proceedings of the 50th Annual Meeting
of the Association for Computational Linguistics (Vol-
ume 1: Long Papers), pages 629–637, Jeju, Republic
of Korea, July.
Joakim Nivre. 2006. Inductive Dependency Parsing.
Springer.
Slav Petrov, Dipanjan Das, and Ryan McDonald. 2012.
A Universal Part-of-Speech Tagset. In Proceedings
of the 8th International Conference on Language Re-
sources and Evaluation (LREC-2012), pages 2089–
2096, Istanbul, Turkey, May.
Anders Søgaard. 2012. Two baselines for unsuper-
vised dependency parsing. In NAACL HLT Work-
shop on Induction of Linguistic Structure, pages 81–
83, Montr´eal, Canada, June.
Valentin I Spitkovsky, Hiyan Alshawi, and Daniel Juraf-
sky. 2010. From Baby Steps to Leapfrog: How “Less
is More” in Unsupervised Dependency Parsing. In Hu-
man Language Technologies: The 2010 Annual Con-
ference of the North American Chapter of the Associ-
ation for Computational Linguistics, pages 751–759,
Los Angeles, California, June.
Mark Steedman. 1996. Surface Structure and Interpre-
tation. The MIT Press, January.
Mark Steedman. 2000. The Syntactic Process. The MIT
Press, September.
Yee-Whye Teh, Michael I Jordan, Matthew J Beal, and
David M Blei. 2006. Hierarchical Dirichlet Pro-
</reference>
<page confidence="0.969305">
86
</page>
<reference confidence="0.999098714285714">
cesses. Journal of the American Statistical Associa-
tion, 101(476):1566–1581.
Yee-Whye Teh. 2006. A Hierarchical Bayesian Lan-
guage Model based on Pitman-Yor Processes. In Pro-
ceedings of the 21st International Conference on Com-
putational Linguistics and 44th Annual Meeting of
the Association for Computational Linguistics, pages
985–992, Sydney, Australia, July.
Yee-Whye Teh. 2010. Dirichlet Process. In Encyclope-
dia of Machine Learning, pages 280–287. Springer.
Kewei Tu. 2012. Combining the Sparsity and Unambi-
guity Biases for Grammar Induction. In NAACL HLT
Workshop on Induction of Linguistic Structure, pages
105–110, Montr´eal, Canada, June.
</reference>
<page confidence="0.9997035">
87
88
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.955147">
<title confidence="0.999324">An HDP Model for Inducing Combinatory Categorial Grammars</title>
<author confidence="0.972196">Bisk</author>
<affiliation confidence="0.9986265">Department of Computer The University of Illinois at</affiliation>
<address confidence="0.993686">201 N Goodwin Ave Urbana, IL</address>
<abstract confidence="0.998749428571429">We introduce a novel nonparametric Bayesian model for the induction of Combinatory Categorial Grammars from POS-tagged text. It achieves state of the art performance on a number of languages, and induces linguistically plausible lexicons.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Taylor Berg-Kirkpatrick</author>
<author>Dan Klein</author>
</authors>
<title>Phylogenetic Grammar Induction.</title>
<date>2010</date>
<booktitle>In Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>1288--1297</pages>
<location>Uppsala, Sweden,</location>
<marker>Berg-Kirkpatrick, Klein, 2010</marker>
<rawString>Taylor Berg-Kirkpatrick and Dan Klein. 2010. Phylogenetic Grammar Induction. In Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics, pages 1288–1297, Uppsala, Sweden, July.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Christopher Bishop</author>
</authors>
<date>2006</date>
<booktitle>Pattern Recognition and Machine Learning.</booktitle>
<publisher>Springer-Verlag,</publisher>
<contexts>
<context position="19341" citStr="Bishop, 2006" startWordPosition="3173" endWordPosition="3174">CFGs (Liang et al., 2007), which impose no formal restrictions on the nonterminals X, Y, Z that can appear in a rewrite rule X -+ Y Z, this greatly simplifies the modeling problem (yielding effectively a model that is more akin to nonparametric HMMs), since it avoids the need to capture correlations be79 tween different base distributions for Y and Z. Variational Inference HDPs need to be estimated with approximate techniques. As an alternative to Gibbs sampling (Teh et al., 2006), which is exact, but typically very slow and has no clear convergence criteria, variational inference algorithms (Bishop, 2006; Blei and Jordan, 2004) estimate the parameters of a truncated model to maximize a lower bound of the likelihood of the actual model. This allows for factorization of the model and a training procedure analogous to the Inside-Outside algorithm (Lari and Young, 1991), allowing training to run very quickly and in a trivially parallelizable manner. To initialize the base DP’s stick weights, we follow the example of Kurihara et al. (2007) and use an MLE model initialized with uniform distributions to compute global counts for the categories in our grammar. When normalized these provide a better i</context>
</contexts>
<marker>Bishop, 2006</marker>
<rawString>Christopher Bishop. 2006. Pattern Recognition and Machine Learning. Springer-Verlag, August.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yonatan Bisk</author>
<author>Julia Hockenmaier</author>
</authors>
<title>Induction of Linguistic Structure with Combinatory Categorial Grammars.</title>
<date>2012</date>
<booktitle>In NAACL HLT Workshop on Induction of Linguistic Structure,</booktitle>
<pages>90--95</pages>
<location>Montr´eal, Canada,</location>
<contexts>
<context position="4184" citStr="Bisk and Hockenmaier, 2012" startWordPosition="630" endWordPosition="634">�2013 Association for Computational Linguistics. N: {he, girl, lunch,...} N/N: {good, the, eating, ...} S\N: {sleeps, ate, eating, ...} (S\N)/N: {sees, ate, ...} S\S: {quickly, today...} (S\N)/(S\N): {good, the, ...} the algorithm has identified the basic syntactic properties of the language, it is hence sufficient to inspect the induced lexicon. Conversely, Boonkwan and Steedman (2011) show that knowledge of these basic syntactic properties makes it very easy to create a language-specific lexicon for accurate unsupervised CCG parsing. We have recently proposed an algorithm for inducing CCGs (Bisk and Hockenmaier, 2012b) that has been shown to be competitive with other approaches even when paired with a very simple probability model (Gelling et al., 2012). In this paper, we pair this induction algorithm with a novel nonparametric Bayesian model that is based on a different factorization of CCG derivations, and show that it outperforms our original model and many other approaches on a large number of languages. Our results indicate that the use of CCG yields grammars that are significantly more robust when dealing with longer sentences than most dependency grammar-based approaches. 2 Combinatory Categorial G</context>
<context position="7097" citStr="Bisk and Hockenmaier (2012" startWordPosition="1101" endWordPosition="1104">ttom-up fashion (although generative probability models for CCG view them in a topdown manner, akin to CFG rules). The first, and most obvious, of these rules is function application: X/Y Y X (BO) Y X\Y X (BO) Here the functor X/Y or X\Y is applied to an argument Y resulting in X. While standard CCG has a number of additional combinatory rules (typeraising, generalized variants of composition and substitution) that increase its generative capacity beyond context-free grammars and allow an elegant treatment of non-local dependencies arising in extraction, coordination and scrambling, we follow Bisk and Hockenmaier (2012b) and use a restricted fragment, without type-raising, that allows only basic composition and is context-free: X/Y Y/Z X/Z (BX&gt; ) X/Y Y\Z X\Z (BX1&gt;) Y\Z X\Y X\Z (BX&lt; ) Y/Z X\Y X/Z (BX1&lt;) The superscript 1 denotes the arity of the composition which is too low to recover non-projective dependencies, and our grammar is thus weakly equivalent to the dependency grammar representations that are commonly used for grammar induction. The main role of composition in our fragment is that it allows sentential and verb modifiers to both take categories of the form S\S and S/S. Composition in76 troduces sp</context>
<context position="10599" citStr="Bisk and Hockenmaier, 2012" startWordPosition="1697" endWordPosition="1700">y of 2, and disallow the category (S/N)\N, since it is equivalent to (S\N)/N. The man ate quickly DT NNS VBD RB N/N, N, S/S S, N\N, S\S, (S/S)/(S/S) (N\N)/(N\N) S\N (N\N)\(N\N) (N/N)\(N/N) (S/S)\(S/S) (S\S)/(S\S) The resultant, overly general, lexicon is then used to parse the training data. Each complete parse has to be of category S or N, with the constraint that sentences that contain a main verb can only form parses of category S. 4 A new probability model for CCG Generative models define the probability of a parse tree T as the product of individual rule probabilities. Our previous work (Bisk and Hockenmaier, 2012b) uses the most basic model of Hockenmaier and Steedman (2002), which first generates the head direction (left, right, unary, or lexical), followed by the head category, and finally the sister category. 3 This factorization does not take advantage of the unique functional nature of CCG. We therefore introduce a new factorization we call the Argument Model. It exploits the fact that CCG imposes strong constraints on a category’s left and right children, since these must combine to create the parent type via one of the combinators. In practice this means that given the parent X/Z, the choice of</context>
<context position="12664" citStr="Bisk and Hockenmaier (2012" startWordPosition="2056" endWordPosition="2059">le: Parent c ⇒ Y TOP TOP E {S, N} S/(S\N) T&lt; N S\(S/N) T&gt; N We still distinguish the same rule types as before (lexical, unary, binary with head left/right), leading us to the following model definition: Given: P := X/Z where type(t) E {Left,Right,Unary,Lex} �p(w|P,t) Lex p(Y|P, t) x p(c|P, t, Y) o.w. Argument Combinator Note that this model generates only one CCG category but uniquely defines the two children of a parent node. We will see below that this greatly simplifies the development of non-parametric extensions. 5 HDP-CCG: a nonparametric model Simple generative models such as PCFGs or Bisk and Hockenmaier (2012b)’s CCG model are not robust in the face of sparsity, since they assign zero probability to any unseen event. Sparsity is a particular problem for formalisms like CCG that have a rich inventory of object types. Nonparametric Bayesian models, e.g. Dirichlet Processes (Teh, 2010) or their hierarchical variants (Teh et al., 2006) and generalizations (Teh, 2006) overcome this problem in a very elegant manner, and are used by many state-of-the-art grammar induction systems (Naseem et al., 2010; Blunsom and Cohn, 2010; Boonkwan and Steedman, 2011). They also impose a rich-getting-richer behavior th</context>
<context position="18526" citStr="Bisk and Hockenmaier (2012" startWordPosition="3038" endWordPosition="3041">es allowed by the grammar for argument categories or the corpus in the case of terminal symbols. Specifically, we set αY = np for conditioning contexts with n outcomes. Since Liang et al. (2009) found that the ideal value for alpha appears to be superlinear but subquadratic in n, we present results where p takes the values 0, 1.0, 1.5, and 2.0 to explore the range from uniform to quadratic. This setting for α is the only free parameter in the model. By controlling precision we can tell the model to what extent global corpus statistics should be trusted. We believe this has a similar effect to Bisk and Hockenmaier (2012b)’s top-k upweighting and smoothing scheme. One advantage of the argument model is that it only requires a single distribution over categories for each binary tree. In contrast to similar proposals for CFGs (Liang et al., 2007), which impose no formal restrictions on the nonterminals X, Y, Z that can appear in a rewrite rule X -+ Y Z, this greatly simplifies the modeling problem (yielding effectively a model that is more akin to nonparametric HMMs), since it avoids the need to capture correlations be79 tween different base distributions for Y and Z. Variational Inference HDPs need to be estim</context>
<context position="25086" citStr="Bisk and Hockenmaier (2012" startWordPosition="4085" endWordPosition="4089">he MLE version of our model we use a simple smoothing scheme which defines a small rule probability (e−15) to prevent any rule used during training from going to zero. 7.1 PASCAL Challenge on Grammar Induction In Table 1, we compare the performance of the basic Argument model (MLE), of our HDP model with four different settings of the hyperparameters (as explained above) and of the systems presented in the PASCAL Challenge on Grammar Induction (Gelling et al., 2012). The systems in this competition were instructed to train over the full dataset, including the unlabelled test data, and include Bisk and Hockenmaier (2012a)’s CCG-based system (BH) to Cohn et al. (2010)’s reimplementation of Klein and Manning (2004)’s DMV model in a tree-substitution grammar framework (BC), as well as three other dependency based systems which either incorporate Naseem et al. (2010)’s rules in a deterministic fashion (Søgaard, 2012), rely on extensive tuning on 6Numbers are from personal correspondence with the organizers. The previously published numbers are not comparable to literature due to an error in the evaluation. http://wiki. cs.ox.ac.uk/InducingLinguisticStructure/ ResultsDepComparable the development set (Tu, 2012) o</context>
<context position="29812" citStr="Bisk and Hockenmaier, 2012" startWordPosition="4811" endWordPosition="4814"> 74.5/66.9 58.5/54.4 50.1/44.6 65.1/60.6 64.3/56.5 71.5/70.3 55.8/50.7 HDP1.5 49.6/50.4 58.7/54.4 53.2/48.2 74.3/67.1 57.4/54.5 50.6/45.0 70.0/64.7 65.5/57.2 69.6/68.6 55.6/50.3 HDP2.0 66.4/65.1 56.5/49.5 54.2/46.4 71.6/64.1 51.7/48.3 49.4/43.3 76.3/70.5 70.7/62.9 74.1/73.3 54.4/48.5 +/− -0.8/-1.7 +3.8/+2.5 -11.4/-15.4 +1.7/+3.5 +6.7/+2.4 -3.1/-3.9 +5.5/+3.3 -0.5/-1.9 +12.7/+13.5 -2.5/-3.7 Table 1: A comparison of the basic Argument model (MLE) and four hyper-parameter settings of the HDPCCG against two syntactic formalisms that participated in the PASCAL Challenge (Gelling et al., 2012), BH (Bisk and Hockenmaier, 2012a) and BC (Blunsom and Cohn, 2010), in addition to a max over all other participants. We trained on length 15 data (punctuation removed), including the test data as recommended by the organizers. The last row indicates the difference between our best system and the competition. global category distribution to influence each of the more specific distributions. Further, it provides a very simple knob in the choice of hyperparameters, which has a substantial effect on performance. A side effect of the hyperparameters is that their strength also determines the rate of convergence. This may be one </context>
<context position="33556" citStr="Bisk and Hockenmaier (2012" startWordPosition="5415" endWordPosition="5418">pe categories for various syntactic constructions, and requires significant manual engineering of which POS tags are mapped to what categories to generate a languagespecific lexicon. However, their performance degrades significantly when only a subset of the questions are considered. Using only the first 14 questions, covering facts about the ordering of subjects, verbs and objects, adjectives, adverbs, auxiliaries, adpositions, possessives and relative markers, they achieve an accuracy of 68.2, which is almost iden7Our earlier generative model showed similar behavior, although the results in Bisk and Hockenmaier (2012b) are not directly comparable due to differences in the data. Sl Es Da Pt Sv #Tokens 3,857 4,230 9,549 15,015 24,021 G10 51.2 62.4 47.2 54.3 48.6 HDP 57.9 65.4 49.3 73.5 73.2 Bg WSJ Nl Ja De #Tokens 38,220 42,442 43,405 43,501 77,705 G10 59.8 64.4 47.5 60.2 47.4 HDP 66.1 70.3 56.2 64.1 68.4 Table 3: A comparison of our system with Gillenwater et al. (2010), both trained on the length 10 training data, and tested on the length 10 test data, from the CoNLL-X Shared task. tical to ours, even though we use significantly less initial knowledge. However, the lexicons we present below indicate that </context>
</contexts>
<marker>Bisk, Hockenmaier, 2012</marker>
<rawString>Yonatan Bisk and Julia Hockenmaier. 2012a. Induction of Linguistic Structure with Combinatory Categorial Grammars. In NAACL HLT Workshop on Induction of Linguistic Structure, pages 90–95, Montr´eal, Canada, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yonatan Bisk</author>
<author>Julia Hockenmaier</author>
</authors>
<title>Simple Robust Grammar Induction with Combinatory Categorial Grammars.</title>
<date>2012</date>
<booktitle>In Proceedings of the Twenty-Sixth Conference on Artificial Intelligence (AAAI-12),</booktitle>
<pages>1643--1649</pages>
<location>Toronto, Canada,</location>
<contexts>
<context position="4184" citStr="Bisk and Hockenmaier, 2012" startWordPosition="630" endWordPosition="634">�2013 Association for Computational Linguistics. N: {he, girl, lunch,...} N/N: {good, the, eating, ...} S\N: {sleeps, ate, eating, ...} (S\N)/N: {sees, ate, ...} S\S: {quickly, today...} (S\N)/(S\N): {good, the, ...} the algorithm has identified the basic syntactic properties of the language, it is hence sufficient to inspect the induced lexicon. Conversely, Boonkwan and Steedman (2011) show that knowledge of these basic syntactic properties makes it very easy to create a language-specific lexicon for accurate unsupervised CCG parsing. We have recently proposed an algorithm for inducing CCGs (Bisk and Hockenmaier, 2012b) that has been shown to be competitive with other approaches even when paired with a very simple probability model (Gelling et al., 2012). In this paper, we pair this induction algorithm with a novel nonparametric Bayesian model that is based on a different factorization of CCG derivations, and show that it outperforms our original model and many other approaches on a large number of languages. Our results indicate that the use of CCG yields grammars that are significantly more robust when dealing with longer sentences than most dependency grammar-based approaches. 2 Combinatory Categorial G</context>
<context position="7097" citStr="Bisk and Hockenmaier (2012" startWordPosition="1101" endWordPosition="1104">ttom-up fashion (although generative probability models for CCG view them in a topdown manner, akin to CFG rules). The first, and most obvious, of these rules is function application: X/Y Y X (BO) Y X\Y X (BO) Here the functor X/Y or X\Y is applied to an argument Y resulting in X. While standard CCG has a number of additional combinatory rules (typeraising, generalized variants of composition and substitution) that increase its generative capacity beyond context-free grammars and allow an elegant treatment of non-local dependencies arising in extraction, coordination and scrambling, we follow Bisk and Hockenmaier (2012b) and use a restricted fragment, without type-raising, that allows only basic composition and is context-free: X/Y Y/Z X/Z (BX&gt; ) X/Y Y\Z X\Z (BX1&gt;) Y\Z X\Y X\Z (BX&lt; ) Y/Z X\Y X/Z (BX1&lt;) The superscript 1 denotes the arity of the composition which is too low to recover non-projective dependencies, and our grammar is thus weakly equivalent to the dependency grammar representations that are commonly used for grammar induction. The main role of composition in our fragment is that it allows sentential and verb modifiers to both take categories of the form S\S and S/S. Composition in76 troduces sp</context>
<context position="10599" citStr="Bisk and Hockenmaier, 2012" startWordPosition="1697" endWordPosition="1700">y of 2, and disallow the category (S/N)\N, since it is equivalent to (S\N)/N. The man ate quickly DT NNS VBD RB N/N, N, S/S S, N\N, S\S, (S/S)/(S/S) (N\N)/(N\N) S\N (N\N)\(N\N) (N/N)\(N/N) (S/S)\(S/S) (S\S)/(S\S) The resultant, overly general, lexicon is then used to parse the training data. Each complete parse has to be of category S or N, with the constraint that sentences that contain a main verb can only form parses of category S. 4 A new probability model for CCG Generative models define the probability of a parse tree T as the product of individual rule probabilities. Our previous work (Bisk and Hockenmaier, 2012b) uses the most basic model of Hockenmaier and Steedman (2002), which first generates the head direction (left, right, unary, or lexical), followed by the head category, and finally the sister category. 3 This factorization does not take advantage of the unique functional nature of CCG. We therefore introduce a new factorization we call the Argument Model. It exploits the fact that CCG imposes strong constraints on a category’s left and right children, since these must combine to create the parent type via one of the combinators. In practice this means that given the parent X/Z, the choice of</context>
<context position="12664" citStr="Bisk and Hockenmaier (2012" startWordPosition="2056" endWordPosition="2059">le: Parent c ⇒ Y TOP TOP E {S, N} S/(S\N) T&lt; N S\(S/N) T&gt; N We still distinguish the same rule types as before (lexical, unary, binary with head left/right), leading us to the following model definition: Given: P := X/Z where type(t) E {Left,Right,Unary,Lex} �p(w|P,t) Lex p(Y|P, t) x p(c|P, t, Y) o.w. Argument Combinator Note that this model generates only one CCG category but uniquely defines the two children of a parent node. We will see below that this greatly simplifies the development of non-parametric extensions. 5 HDP-CCG: a nonparametric model Simple generative models such as PCFGs or Bisk and Hockenmaier (2012b)’s CCG model are not robust in the face of sparsity, since they assign zero probability to any unseen event. Sparsity is a particular problem for formalisms like CCG that have a rich inventory of object types. Nonparametric Bayesian models, e.g. Dirichlet Processes (Teh, 2010) or their hierarchical variants (Teh et al., 2006) and generalizations (Teh, 2006) overcome this problem in a very elegant manner, and are used by many state-of-the-art grammar induction systems (Naseem et al., 2010; Blunsom and Cohn, 2010; Boonkwan and Steedman, 2011). They also impose a rich-getting-richer behavior th</context>
<context position="18526" citStr="Bisk and Hockenmaier (2012" startWordPosition="3038" endWordPosition="3041">es allowed by the grammar for argument categories or the corpus in the case of terminal symbols. Specifically, we set αY = np for conditioning contexts with n outcomes. Since Liang et al. (2009) found that the ideal value for alpha appears to be superlinear but subquadratic in n, we present results where p takes the values 0, 1.0, 1.5, and 2.0 to explore the range from uniform to quadratic. This setting for α is the only free parameter in the model. By controlling precision we can tell the model to what extent global corpus statistics should be trusted. We believe this has a similar effect to Bisk and Hockenmaier (2012b)’s top-k upweighting and smoothing scheme. One advantage of the argument model is that it only requires a single distribution over categories for each binary tree. In contrast to similar proposals for CFGs (Liang et al., 2007), which impose no formal restrictions on the nonterminals X, Y, Z that can appear in a rewrite rule X -+ Y Z, this greatly simplifies the modeling problem (yielding effectively a model that is more akin to nonparametric HMMs), since it avoids the need to capture correlations be79 tween different base distributions for Y and Z. Variational Inference HDPs need to be estim</context>
<context position="25086" citStr="Bisk and Hockenmaier (2012" startWordPosition="4085" endWordPosition="4089">he MLE version of our model we use a simple smoothing scheme which defines a small rule probability (e−15) to prevent any rule used during training from going to zero. 7.1 PASCAL Challenge on Grammar Induction In Table 1, we compare the performance of the basic Argument model (MLE), of our HDP model with four different settings of the hyperparameters (as explained above) and of the systems presented in the PASCAL Challenge on Grammar Induction (Gelling et al., 2012). The systems in this competition were instructed to train over the full dataset, including the unlabelled test data, and include Bisk and Hockenmaier (2012a)’s CCG-based system (BH) to Cohn et al. (2010)’s reimplementation of Klein and Manning (2004)’s DMV model in a tree-substitution grammar framework (BC), as well as three other dependency based systems which either incorporate Naseem et al. (2010)’s rules in a deterministic fashion (Søgaard, 2012), rely on extensive tuning on 6Numbers are from personal correspondence with the organizers. The previously published numbers are not comparable to literature due to an error in the evaluation. http://wiki. cs.ox.ac.uk/InducingLinguisticStructure/ ResultsDepComparable the development set (Tu, 2012) o</context>
<context position="29812" citStr="Bisk and Hockenmaier, 2012" startWordPosition="4811" endWordPosition="4814"> 74.5/66.9 58.5/54.4 50.1/44.6 65.1/60.6 64.3/56.5 71.5/70.3 55.8/50.7 HDP1.5 49.6/50.4 58.7/54.4 53.2/48.2 74.3/67.1 57.4/54.5 50.6/45.0 70.0/64.7 65.5/57.2 69.6/68.6 55.6/50.3 HDP2.0 66.4/65.1 56.5/49.5 54.2/46.4 71.6/64.1 51.7/48.3 49.4/43.3 76.3/70.5 70.7/62.9 74.1/73.3 54.4/48.5 +/− -0.8/-1.7 +3.8/+2.5 -11.4/-15.4 +1.7/+3.5 +6.7/+2.4 -3.1/-3.9 +5.5/+3.3 -0.5/-1.9 +12.7/+13.5 -2.5/-3.7 Table 1: A comparison of the basic Argument model (MLE) and four hyper-parameter settings of the HDPCCG against two syntactic formalisms that participated in the PASCAL Challenge (Gelling et al., 2012), BH (Bisk and Hockenmaier, 2012a) and BC (Blunsom and Cohn, 2010), in addition to a max over all other participants. We trained on length 15 data (punctuation removed), including the test data as recommended by the organizers. The last row indicates the difference between our best system and the competition. global category distribution to influence each of the more specific distributions. Further, it provides a very simple knob in the choice of hyperparameters, which has a substantial effect on performance. A side effect of the hyperparameters is that their strength also determines the rate of convergence. This may be one </context>
<context position="33556" citStr="Bisk and Hockenmaier (2012" startWordPosition="5415" endWordPosition="5418">pe categories for various syntactic constructions, and requires significant manual engineering of which POS tags are mapped to what categories to generate a languagespecific lexicon. However, their performance degrades significantly when only a subset of the questions are considered. Using only the first 14 questions, covering facts about the ordering of subjects, verbs and objects, adjectives, adverbs, auxiliaries, adpositions, possessives and relative markers, they achieve an accuracy of 68.2, which is almost iden7Our earlier generative model showed similar behavior, although the results in Bisk and Hockenmaier (2012b) are not directly comparable due to differences in the data. Sl Es Da Pt Sv #Tokens 3,857 4,230 9,549 15,015 24,021 G10 51.2 62.4 47.2 54.3 48.6 HDP 57.9 65.4 49.3 73.5 73.2 Bg WSJ Nl Ja De #Tokens 38,220 42,442 43,405 43,501 77,705 G10 59.8 64.4 47.5 60.2 47.4 HDP 66.1 70.3 56.2 64.1 68.4 Table 3: A comparison of our system with Gillenwater et al. (2010), both trained on the length 10 training data, and tested on the length 10 test data, from the CoNLL-X Shared task. tical to ours, even though we use significantly less initial knowledge. However, the lexicons we present below indicate that </context>
</contexts>
<marker>Bisk, Hockenmaier, 2012</marker>
<rawString>Yonatan Bisk and Julia Hockenmaier. 2012b. Simple Robust Grammar Induction with Combinatory Categorial Grammars. In Proceedings of the Twenty-Sixth Conference on Artificial Intelligence (AAAI-12), pages 1643–1649, Toronto, Canada, July.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David M Blei</author>
<author>Michael I Jordan</author>
</authors>
<title>Variational Methods for the Dirichlet Process.</title>
<date>2004</date>
<booktitle>In Proceedings of the Twenty-First International Conference on Machine Learning (ICML 2004),</booktitle>
<location>Banff, Alberta, Canada,</location>
<contexts>
<context position="19365" citStr="Blei and Jordan, 2004" startWordPosition="3175" endWordPosition="3178"> al., 2007), which impose no formal restrictions on the nonterminals X, Y, Z that can appear in a rewrite rule X -+ Y Z, this greatly simplifies the modeling problem (yielding effectively a model that is more akin to nonparametric HMMs), since it avoids the need to capture correlations be79 tween different base distributions for Y and Z. Variational Inference HDPs need to be estimated with approximate techniques. As an alternative to Gibbs sampling (Teh et al., 2006), which is exact, but typically very slow and has no clear convergence criteria, variational inference algorithms (Bishop, 2006; Blei and Jordan, 2004) estimate the parameters of a truncated model to maximize a lower bound of the likelihood of the actual model. This allows for factorization of the model and a training procedure analogous to the Inside-Outside algorithm (Lari and Young, 1991), allowing training to run very quickly and in a trivially parallelizable manner. To initialize the base DP’s stick weights, we follow the example of Kurihara et al. (2007) and use an MLE model initialized with uniform distributions to compute global counts for the categories in our grammar. When normalized these provide a better initialization than a uni</context>
</contexts>
<marker>Blei, Jordan, 2004</marker>
<rawString>David M Blei and Michael I Jordan. 2004. Variational Methods for the Dirichlet Process. In Proceedings of the Twenty-First International Conference on Machine Learning (ICML 2004), Banff, Alberta, Canada, July.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Phil Blunsom</author>
<author>Trevor Cohn</author>
</authors>
<title>Unsupervised Induction of Tree Substitution Grammars for Dependency Parsing.</title>
<date>2010</date>
<booktitle>Proceedings of the 2010 Conference on Empirical Methods of Natural Language Processing,</booktitle>
<pages>1204--1213</pages>
<contexts>
<context position="1949" citStr="Blunsom and Cohn (2010)" startWordPosition="286" endWordPosition="289">t al., 2011; Cohen and Smith, 2010) and learning regimes (Spitkovsky et al., 2010), as well as the incorporation of prior linguistic knowledge (Cohen and Smith, 2009; BergKirkpatrick and Klein, 2010; Naseem et al., 2010) can lead to significant improvement over Klein and Manning’s baseline model. The use of dependency grammars circumvents the question of how to obtain an appropriate inventory of categories, since dependency parses are simply defined by unlabeled edges between the lexical items in the sentence. But dependency grammars make it also difficult to capture non-local structures, and Blunsom and Cohn (2010) show that it may be advantageous to reformulate the underlying dependency grammar in terms of a tree-substitution grammar (TSG) which pairs words with treelets that specify the number of left and right dependents they have. In this paper, we explore yet another option: instead of dependency grammars, we use Combinatory Categorial Grammar (CCG, Steedman (1996; 2000)), a linguistically expressive formalism that pairs lexical items with rich categories that capture all language-specific information. This may seem a puzzling choice, since CCG requires a significantly larger inventory of categorie</context>
<context position="3202" citStr="Blunsom and Cohn (2010)" startWordPosition="486" endWordPosition="489"> CFGs. However, unlike CFG nonterminals, CCG categories are not arbitrary symbols: they encode, and are determined by, the basic word order of the language and the number of arguments each word takes. CCG is very similar to TSG in that it also pairs lexical items with rich items that capture all language-specific information. Like TSG and projective dependency grammars, we restrict ourselves to a weakly contextfree fragment of CCG. But while TSG does not distinguish between argument and modifier dependencies, CCG makes an explicit distinction between the two. And while the elementary trees of Blunsom and Cohn (2010)’s TSG and their internal nodel labels have no obvious linguistic interpretation, the syntactic behavior of any CCG constituent can be directly inferred from its category. To see whether 75 Transactions of the Association for Computational Linguistics, 1 (2013) 75–88. Action Editor: Sharon Goldwater. Submitted 11/2012; Revised 1/2013; Published 3/2013. c�2013 Association for Computational Linguistics. N: {he, girl, lunch,...} N/N: {good, the, eating, ...} S\N: {sleeps, ate, eating, ...} (S\N)/N: {sees, ate, ...} S\S: {quickly, today...} (S\N)/(S\N): {good, the, ...} the algorithm has identifie</context>
<context position="13182" citStr="Blunsom and Cohn, 2010" startWordPosition="2138" endWordPosition="2141">s. 5 HDP-CCG: a nonparametric model Simple generative models such as PCFGs or Bisk and Hockenmaier (2012b)’s CCG model are not robust in the face of sparsity, since they assign zero probability to any unseen event. Sparsity is a particular problem for formalisms like CCG that have a rich inventory of object types. Nonparametric Bayesian models, e.g. Dirichlet Processes (Teh, 2010) or their hierarchical variants (Teh et al., 2006) and generalizations (Teh, 2006) overcome this problem in a very elegant manner, and are used by many state-of-the-art grammar induction systems (Naseem et al., 2010; Blunsom and Cohn, 2010; Boonkwan and Steedman, 2011). They also impose a rich-getting-richer behavior that seems to be advantageous in many modeling applications. By contrast, Bisk and Hockenmaier (2012b) propose a weighted top-k scheme to address these issues in an ad-hoc manner. The argument model introduced above lends itself particularly well to nonparametric extensions such as the standard Hierarchical Dirichlet Processes (HDP). In this work the size of the grammar and the number of productions are fixed and small, but we present the formulation as infinite to allow for easy extension in the future. Specifical</context>
<context position="29846" citStr="Blunsom and Cohn, 2010" startWordPosition="4817" endWordPosition="4820">0.6 64.3/56.5 71.5/70.3 55.8/50.7 HDP1.5 49.6/50.4 58.7/54.4 53.2/48.2 74.3/67.1 57.4/54.5 50.6/45.0 70.0/64.7 65.5/57.2 69.6/68.6 55.6/50.3 HDP2.0 66.4/65.1 56.5/49.5 54.2/46.4 71.6/64.1 51.7/48.3 49.4/43.3 76.3/70.5 70.7/62.9 74.1/73.3 54.4/48.5 +/− -0.8/-1.7 +3.8/+2.5 -11.4/-15.4 +1.7/+3.5 +6.7/+2.4 -3.1/-3.9 +5.5/+3.3 -0.5/-1.9 +12.7/+13.5 -2.5/-3.7 Table 1: A comparison of the basic Argument model (MLE) and four hyper-parameter settings of the HDPCCG against two syntactic formalisms that participated in the PASCAL Challenge (Gelling et al., 2012), BH (Bisk and Hockenmaier, 2012a) and BC (Blunsom and Cohn, 2010), in addition to a max over all other participants. We trained on length 15 data (punctuation removed), including the test data as recommended by the organizers. The last row indicates the difference between our best system and the competition. global category distribution to influence each of the more specific distributions. Further, it provides a very simple knob in the choice of hyperparameters, which has a substantial effect on performance. A side effect of the hyperparameters is that their strength also determines the rate of convergence. This may be one of the reasons for the high varian</context>
</contexts>
<marker>Blunsom, Cohn, 2010</marker>
<rawString>Phil Blunsom and Trevor Cohn. 2010. Unsupervised Induction of Tree Substitution Grammars for Dependency Parsing. Proceedings of the 2010 Conference on Empirical Methods of Natural Language Processing, pages 1204–1213, October.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Prachya Boonkwan</author>
<author>Mark Steedman</author>
</authors>
<title>Grammar Induction from Text Using Small Syntactic Prototypes.</title>
<date>2011</date>
<booktitle>In Proceedings of 5th International Joint Conference on Natural Language Processing,</booktitle>
<pages>438--446</pages>
<location>Chiang Mai, Thailand,</location>
<contexts>
<context position="3947" citStr="Boonkwan and Steedman (2011)" startWordPosition="593" endWordPosition="596">onstituent can be directly inferred from its category. To see whether 75 Transactions of the Association for Computational Linguistics, 1 (2013) 75–88. Action Editor: Sharon Goldwater. Submitted 11/2012; Revised 1/2013; Published 3/2013. c�2013 Association for Computational Linguistics. N: {he, girl, lunch,...} N/N: {good, the, eating, ...} S\N: {sleeps, ate, eating, ...} (S\N)/N: {sees, ate, ...} S\S: {quickly, today...} (S\N)/(S\N): {good, the, ...} the algorithm has identified the basic syntactic properties of the language, it is hence sufficient to inspect the induced lexicon. Conversely, Boonkwan and Steedman (2011) show that knowledge of these basic syntactic properties makes it very easy to create a language-specific lexicon for accurate unsupervised CCG parsing. We have recently proposed an algorithm for inducing CCGs (Bisk and Hockenmaier, 2012b) that has been shown to be competitive with other approaches even when paired with a very simple probability model (Gelling et al., 2012). In this paper, we pair this induction algorithm with a novel nonparametric Bayesian model that is based on a different factorization of CCG derivations, and show that it outperforms our original model and many other approa</context>
<context position="13212" citStr="Boonkwan and Steedman, 2011" startWordPosition="2142" endWordPosition="2145">etric model Simple generative models such as PCFGs or Bisk and Hockenmaier (2012b)’s CCG model are not robust in the face of sparsity, since they assign zero probability to any unseen event. Sparsity is a particular problem for formalisms like CCG that have a rich inventory of object types. Nonparametric Bayesian models, e.g. Dirichlet Processes (Teh, 2010) or their hierarchical variants (Teh et al., 2006) and generalizations (Teh, 2006) overcome this problem in a very elegant manner, and are used by many state-of-the-art grammar induction systems (Naseem et al., 2010; Blunsom and Cohn, 2010; Boonkwan and Steedman, 2011). They also impose a rich-getting-richer behavior that seems to be advantageous in many modeling applications. By contrast, Bisk and Hockenmaier (2012b) propose a weighted top-k scheme to address these issues in an ad-hoc manner. The argument model introduced above lends itself particularly well to nonparametric extensions such as the standard Hierarchical Dirichlet Processes (HDP). In this work the size of the grammar and the number of productions are fixed and small, but we present the formulation as infinite to allow for easy extension in the future. Specifically, this framework allows for </context>
<context position="32609" citStr="Boonkwan and Steedman (2011)" startWordPosition="5268" endWordPosition="5272"> our system shows significantly less decline, and outperforms their universal system by a significant margin.7 &lt; 10 &lt; 20 Naseem Universal Rules 71.9 50.4 Naseem English Rules 73.8 66.1 HDP-CCG 68.2 64.2 HDP-CCG (train ≤ 20) 71.9 In contrast to Spitkovsky et al. (2010), who reported that performance of their dependency based system degrades when trained on longer sentences, our performance on length 10 sentences increases to 71.9 when we train on sentences up to length 20. Another system that is also based on CCG, but captures significantly more linguistic knowledge than ours, was presented by Boonkwan and Steedman (2011), who achieve an accuracy of 74.5 on WSJ10 section 23 (trained on sections 02-22). Using the same settings, our system achieves an accuracy of 68.4. Unlike our approach, Boonkwan and Steedman do not automatically induce an appropriate inventory of lexical category, but use an extensive questionnaire that defines prototype categories for various syntactic constructions, and requires significant manual engineering of which POS tags are mapped to what categories to generate a languagespecific lexicon. However, their performance degrades significantly when only a subset of the questions are consid</context>
</contexts>
<marker>Boonkwan, Steedman, 2011</marker>
<rawString>Prachya Boonkwan and Mark Steedman. 2011. Grammar Induction from Text Using Small Syntactic Prototypes. In Proceedings of 5th International Joint Conference on Natural Language Processing, pages 438– 446, Chiang Mai, Thailand, November.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Sabine Buchholz</author>
<author>Erwin Marsi</author>
</authors>
<title>CoNLL-X Shared Task on Multilingual Dependency Parsing.</title>
<date>2006</date>
<booktitle>In Proceedings of the 10th Conference on Computational Natural Language Learning (CoNLL-X),</booktitle>
<pages>149--164</pages>
<location>New York City,</location>
<contexts>
<context position="21402" citStr="Buchholz and Marsi, 2006" startWordPosition="3509" endWordPosition="3512">ining and testing our models on the corpora containing sentences up to length 15 used in this paper takes between one minute to at most three hours on a single 12-core machine depending on their size. 6 Evaluation As is standard for this task, we evaluate our systems against a number of different dependency treebanks, and measure performance in terms of the accuracy of directed dependencies (i.e. the percentage of words in the test corpus that are correctly attached). We use the data from the PASCAL challenge for grammar induction (Gelling et al., 2012), the data from the CoNLL-X shared task (Buchholz and Marsi, 2006) and Goldberg (2011)’s Hebrew corpus. Converting CCG derivations into dependencies is mostly straightforward, since the CCG derivation identifies the root word of each sentence, and headargument and head-modifier dependencies are easily read off of CCG derivations, since the lexicon defines them explicitly. Unlike dependency grammar, CCG is designed to recover non-local dependencies that arise in control and binding constructions as well as in wh-extraction and non-standard coordination, but since this requires re-entrancies, or coindexation of arguments (Hockenmaier and Steedman, 2007), withi</context>
<context position="35129" citStr="Buchholz and Marsi, 2006" startWordPosition="5691" endWordPosition="5694">ore fine-grained inventory of lexical categories than our system can automatically induce. We also stipulate that for certain languages knowledge of pro-drop could play a significant role in the success of their approach: if complete sentences are allowed to be of the form S\N or S/N, the same lexical category can be used for the verb regardless of whether the subject is present or has been dropped. 7.3 Additional Languages In order to provide results on additional languages, we present in Table 3 a comparison to the work of Gillenwater et al. (2010) (G10), using the ConLL-X Shared Task data (Buchholz and Marsi, 2006). Following Gillenwater et al., we train only on sentences of length 10 from the training set and evaluate on the test set. Since this is a different training regime, and these corpora differ for many languages from that of the PASCAL challenge, numbers from Table 1 cannot be compared directly with those in Table 3. We have also applied our model to Goldberg (2011)’s Hebrew corpus, where it achieves an accuracy of 62.1 (trained and tested on all sentences length 10; 7,253) and 59.6 (length 15; 21,422 tokens). 83 Arabic % Swedish % WSJ % Childes % Japanese % Czech % VERB (S\N)/N 56 S 45 S\N 52 </context>
</contexts>
<marker>Buchholz, Marsi, 2006</marker>
<rawString>Sabine Buchholz and Erwin Marsi. 2006. CoNLL-X Shared Task on Multilingual Dependency Parsing. In Proceedings of the 10th Conference on Computational Natural Language Learning (CoNLL-X), pages 149– 164, New York City, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Glenn Carroll</author>
<author>Eugene Charniak</author>
</authors>
<date>1992</date>
<booktitle>Two Experiments on Learning Probabilistic Dependency Grammars from Corpora. Working Notes of the Workshop Statistically-Based NLP Techniques,</booktitle>
<pages>1--13</pages>
<contexts>
<context position="685" citStr="Carroll and Charniak, 1992" startWordPosition="89" endWordPosition="92">onatan Bisk and Julia Hockenmaier Department of Computer Science The University of Illinois at Urbana-Champaign 201 N Goodwin Ave Urbana, IL 61801 {bisk1,juliahmr}@illinois.edu Abstract We introduce a novel nonparametric Bayesian model for the induction of Combinatory Categorial Grammars from POS-tagged text. It achieves state of the art performance on a number of languages, and induces linguistically plausible lexicons. 1 Introduction What grammatical representation is appropriate for unsupervised grammar induction? Initial attempts with context-free grammars (CFGs) were not very successful (Carroll and Charniak, 1992; Charniak, 1993). One reason may be that CFGs require the specification of a finite inventory of nonterminal categories and rewrite rules, but unless one adopts linguistic principles such as X-bar theory (Jackendoff, 1977), these nonterminals are essentially arbitrary labels that can be combined in arbitrary ways. While further CFG-based approaches have been proposed (Clark, 2001; Kurihara and Sato, 2004), most recent work has followed Klein and Manning (2004) in developing models for the induction of projective dependency grammars. It has been shown that more sophisticated probability models</context>
</contexts>
<marker>Carroll, Charniak, 1992</marker>
<rawString>Glenn Carroll and Eugene Charniak. 1992. Two Experiments on Learning Probabilistic Dependency Grammars from Corpora. Working Notes of the Workshop Statistically-Based NLP Techniques, pages 1–13.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Eugene Charniak</author>
</authors>
<title>Statistical Language Learning.</title>
<date>1993</date>
<publisher>The MIT Press,</publisher>
<location>Cambridge, Massachusetts.</location>
<contexts>
<context position="702" citStr="Charniak, 1993" startWordPosition="93" endWordPosition="94">maier Department of Computer Science The University of Illinois at Urbana-Champaign 201 N Goodwin Ave Urbana, IL 61801 {bisk1,juliahmr}@illinois.edu Abstract We introduce a novel nonparametric Bayesian model for the induction of Combinatory Categorial Grammars from POS-tagged text. It achieves state of the art performance on a number of languages, and induces linguistically plausible lexicons. 1 Introduction What grammatical representation is appropriate for unsupervised grammar induction? Initial attempts with context-free grammars (CFGs) were not very successful (Carroll and Charniak, 1992; Charniak, 1993). One reason may be that CFGs require the specification of a finite inventory of nonterminal categories and rewrite rules, but unless one adopts linguistic principles such as X-bar theory (Jackendoff, 1977), these nonterminals are essentially arbitrary labels that can be combined in arbitrary ways. While further CFG-based approaches have been proposed (Clark, 2001; Kurihara and Sato, 2004), most recent work has followed Klein and Manning (2004) in developing models for the induction of projective dependency grammars. It has been shown that more sophisticated probability models (Headden III et </context>
</contexts>
<marker>Charniak, 1993</marker>
<rawString>Eugene Charniak. 1993. Statistical Language Learning. The MIT Press, Cambridge, Massachusetts.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stephen Clark</author>
<author>James R Curran</author>
</authors>
<title>FormalismIndependent Parser Evaluation with CCG and DepBank.</title>
<date>2007</date>
<booktitle>In Proceedings of the 45th Annual Meeting of the Association of Computational Linguistics,</booktitle>
<pages>248--255</pages>
<location>Prague, Czech Republic,</location>
<contexts>
<context position="22373" citStr="Clark and Curran, 2007" startWordPosition="3648" endWordPosition="3651">ned to recover non-local dependencies that arise in control and binding constructions as well as in wh-extraction and non-standard coordination, but since this requires re-entrancies, or coindexation of arguments (Hockenmaier and Steedman, 2007), within the lexical categories that trigger these constructions, our current system returns only local dependencies. But since dependency grammars also captures only local dependencies, this has no negative influence on our current evaluation. However, a direct comparison between dependency treebanks and dependencies produced by CCG is more difficult (Clark and Curran, 2007), since dependency grammars allow considerable freedom in how to analyze specific constructions such as verb clusters (which verb is the head?) prepositional phrases and particles (is the head the noun or the preposition/particle?), subordinating conjunctions (is the conjunction a dependent of the head of the main clause and the head of the embedded clause a dependent of the conjunction, or vice versa?) and this is reflected in the fact that the treebanks we consider often apply different conventions for these cases. Although remedying this issue is beyond the scope of this work, these discrep</context>
</contexts>
<marker>Clark, Curran, 2007</marker>
<rawString>Stephen Clark and James R Curran. 2007. FormalismIndependent Parser Evaluation with CCG and DepBank. In Proceedings of the 45th Annual Meeting of the Association of Computational Linguistics, pages 248–255, Prague, Czech Republic, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alex Clark</author>
</authors>
<title>Unsupervised Language Acquisition: Theory and Practice.</title>
<date>2001</date>
<tech>Ph.D. thesis,</tech>
<institution>University of Sussex,</institution>
<contexts>
<context position="1068" citStr="Clark, 2001" startWordPosition="148" endWordPosition="149">ically plausible lexicons. 1 Introduction What grammatical representation is appropriate for unsupervised grammar induction? Initial attempts with context-free grammars (CFGs) were not very successful (Carroll and Charniak, 1992; Charniak, 1993). One reason may be that CFGs require the specification of a finite inventory of nonterminal categories and rewrite rules, but unless one adopts linguistic principles such as X-bar theory (Jackendoff, 1977), these nonterminals are essentially arbitrary labels that can be combined in arbitrary ways. While further CFG-based approaches have been proposed (Clark, 2001; Kurihara and Sato, 2004), most recent work has followed Klein and Manning (2004) in developing models for the induction of projective dependency grammars. It has been shown that more sophisticated probability models (Headden III et al., 2009; Gillenwater et al., 2011; Cohen and Smith, 2010) and learning regimes (Spitkovsky et al., 2010), as well as the incorporation of prior linguistic knowledge (Cohen and Smith, 2009; BergKirkpatrick and Klein, 2010; Naseem et al., 2010) can lead to significant improvement over Klein and Manning’s baseline model. The use of dependency grammars circumvents t</context>
</contexts>
<marker>Clark, 2001</marker>
<rawString>Alex Clark. 2001. Unsupervised Language Acquisition: Theory and Practice. Ph.D. thesis, University of Sussex, September.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Shay B Cohen</author>
<author>Noah A Smith</author>
</authors>
<title>Variational Inference for Grammar Induction with Prior Knowledge.</title>
<date>2009</date>
<booktitle>Proceedings of the ACL-IJCNLP 2009 Conference Short Papers,</booktitle>
<pages>1--4</pages>
<contexts>
<context position="1491" citStr="Cohen and Smith, 2009" startWordPosition="214" endWordPosition="217">uch as X-bar theory (Jackendoff, 1977), these nonterminals are essentially arbitrary labels that can be combined in arbitrary ways. While further CFG-based approaches have been proposed (Clark, 2001; Kurihara and Sato, 2004), most recent work has followed Klein and Manning (2004) in developing models for the induction of projective dependency grammars. It has been shown that more sophisticated probability models (Headden III et al., 2009; Gillenwater et al., 2011; Cohen and Smith, 2010) and learning regimes (Spitkovsky et al., 2010), as well as the incorporation of prior linguistic knowledge (Cohen and Smith, 2009; BergKirkpatrick and Klein, 2010; Naseem et al., 2010) can lead to significant improvement over Klein and Manning’s baseline model. The use of dependency grammars circumvents the question of how to obtain an appropriate inventory of categories, since dependency parses are simply defined by unlabeled edges between the lexical items in the sentence. But dependency grammars make it also difficult to capture non-local structures, and Blunsom and Cohn (2010) show that it may be advantageous to reformulate the underlying dependency grammar in terms of a tree-substitution grammar (TSG) which pairs w</context>
</contexts>
<marker>Cohen, Smith, 2009</marker>
<rawString>Shay B Cohen and Noah A Smith. 2009. Variational Inference for Grammar Induction with Prior Knowledge. Proceedings of the ACL-IJCNLP 2009 Conference Short Papers, pages 1–4.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Shay B Cohen</author>
<author>Noah A Smith</author>
</authors>
<title>Covariance in Unsupervised Learning of Probabilistic Grammars.</title>
<date>2010</date>
<journal>The Journal of Machine Learning Research,</journal>
<pages>3117--3151</pages>
<contexts>
<context position="1361" citStr="Cohen and Smith, 2010" startWordPosition="193" endWordPosition="196"> the specification of a finite inventory of nonterminal categories and rewrite rules, but unless one adopts linguistic principles such as X-bar theory (Jackendoff, 1977), these nonterminals are essentially arbitrary labels that can be combined in arbitrary ways. While further CFG-based approaches have been proposed (Clark, 2001; Kurihara and Sato, 2004), most recent work has followed Klein and Manning (2004) in developing models for the induction of projective dependency grammars. It has been shown that more sophisticated probability models (Headden III et al., 2009; Gillenwater et al., 2011; Cohen and Smith, 2010) and learning regimes (Spitkovsky et al., 2010), as well as the incorporation of prior linguistic knowledge (Cohen and Smith, 2009; BergKirkpatrick and Klein, 2010; Naseem et al., 2010) can lead to significant improvement over Klein and Manning’s baseline model. The use of dependency grammars circumvents the question of how to obtain an appropriate inventory of categories, since dependency parses are simply defined by unlabeled edges between the lexical items in the sentence. But dependency grammars make it also difficult to capture non-local structures, and Blunsom and Cohn (2010) show that i</context>
</contexts>
<marker>Cohen, Smith, 2010</marker>
<rawString>Shay B Cohen and Noah A Smith. 2010. Covariance in Unsupervised Learning of Probabilistic Grammars. The Journal of Machine Learning Research, pages 3117–3151, November.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Trevor Cohn</author>
<author>Phil Blunsom</author>
<author>Sharon Goldwater</author>
</authors>
<title>Inducing Tree-Substitution Grammars.</title>
<date>2010</date>
<journal>The Journal of Machine Learning Research,</journal>
<volume>11</volume>
<pages>3096</pages>
<contexts>
<context position="25134" citStr="Cohn et al. (2010)" startWordPosition="4094" endWordPosition="4097">heme which defines a small rule probability (e−15) to prevent any rule used during training from going to zero. 7.1 PASCAL Challenge on Grammar Induction In Table 1, we compare the performance of the basic Argument model (MLE), of our HDP model with four different settings of the hyperparameters (as explained above) and of the systems presented in the PASCAL Challenge on Grammar Induction (Gelling et al., 2012). The systems in this competition were instructed to train over the full dataset, including the unlabelled test data, and include Bisk and Hockenmaier (2012a)’s CCG-based system (BH) to Cohn et al. (2010)’s reimplementation of Klein and Manning (2004)’s DMV model in a tree-substitution grammar framework (BC), as well as three other dependency based systems which either incorporate Naseem et al. (2010)’s rules in a deterministic fashion (Søgaard, 2012), rely on extensive tuning on 6Numbers are from personal correspondence with the organizers. The previously published numbers are not comparable to literature due to an error in the evaluation. http://wiki. cs.ox.ac.uk/InducingLinguisticStructure/ ResultsDepComparable the development set (Tu, 2012) or incorporate millions of additional tokens from</context>
</contexts>
<marker>Cohn, Blunsom, Goldwater, 2010</marker>
<rawString>Trevor Cohn, Phil Blunsom, and Sharon Goldwater. 2010. Inducing Tree-Substitution Grammars. The Journal of Machine Learning Research, 11:3053– 3096, November.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Collins</author>
</authors>
<title>Head-Driven Statistical Models for Natural Language Parsing.</title>
<date>2003</date>
<journal>Computational Linguistics,</journal>
<volume>29</volume>
<issue>4</issue>
<contexts>
<context position="24346" citStr="Collins (2003)" startWordPosition="3963" endWordPosition="3964">e). Since our system has explicit rules for coordination, we transform its output into the desired target representation that is specific to each language. 7 Experiments We evaluate our system on 13 different languages. In each case, we follow the test and training regimes that were used to obtain previously published results in order to allow a direct comparison. We compare our system to the results presented at the PASCAL Challenge on Grammar Induction (Gelling et al., 2012)6, as well as to Gillenwater et al. (2011) and Naseem et al. (2012). We use Nivre (2006)’s Penn2Malt implementation of Collins (2003)’s head rules to translate the WSJ Penn Treebank (Marcus et al., 1993) into dependencies. Finally, when training the MLE version of our model we use a simple smoothing scheme which defines a small rule probability (e−15) to prevent any rule used during training from going to zero. 7.1 PASCAL Challenge on Grammar Induction In Table 1, we compare the performance of the basic Argument model (MLE), of our HDP model with four different settings of the hyperparameters (as explained above) and of the systems presented in the PASCAL Challenge on Grammar Induction (Gelling et al., 2012). The systems in</context>
</contexts>
<marker>Collins, 2003</marker>
<rawString>Michael Collins. 2003. Head-Driven Statistical Models for Natural Language Parsing. Computational Linguistics, 29(4):589–637, December.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gregory Druck</author>
<author>Gideon Mann</author>
<author>Andrew McCallum</author>
</authors>
<title>Semi-supervised Learning of Dependency Parsers using Generalized Expectation Criteria.</title>
<date>2009</date>
<booktitle>In Proceedings of the Joint Conference of the 47th Annual Meeting of the ACL and the 4th International Joint Conference on Natural Language Processing of the AFNLP,</booktitle>
<pages>360--368</pages>
<location>Suntec, Singapore,</location>
<contexts>
<context position="31578" citStr="Druck et al. (2009)" startWordPosition="5096" endWordPosition="5099">Three of these constraints correspond to our rules that verbs are the roots of sentences and may take nouns as dependents, but the other ten constraints (e.g. that adjectives modify nouns, adverbs modify adjectives or verbs, etc.) have no equivalent in our system. Although our system has less prior knowledge, it still performs competitively. On the WSJ, Naseem et al. demonstrate the importance and effect of the specific choice of syntactic rules by comparing the performance of their system with hand crafted universal rules (71.9), with English specific rules (73.8), and with rules proposed by Druck et al. (2009) (64.9). The performance of Naseem et al.’s system drops very significantly as sentence length (and presumable parse complexity) 82 Sl Es Da Pt Sv ∼#Tokens 3.8K 4.2K 9.5K 15K 24K N10 50.9 67.2 51.9 71.5 63.3 HDP 56.6 62.1 51.5 74.7 69.8 Table 2: A comparison of our system with Naseem et al. (2010), both trained and tested on the length 10 training data from the CoNLL-X Shared Task. increases, whereas our system shows significantly less decline, and outperforms their universal system by a significant margin.7 &lt; 10 &lt; 20 Naseem Universal Rules 71.9 50.4 Naseem English Rules 73.8 66.1 HDP-CCG 68.2</context>
</contexts>
<marker>Druck, Mann, McCallum, 2009</marker>
<rawString>Gregory Druck, Gideon Mann, and Andrew McCallum. 2009. Semi-supervised Learning of Dependency Parsers using Generalized Expectation Criteria. In Proceedings of the Joint Conference of the 47th Annual Meeting of the ACL and the 4th International Joint Conference on Natural Language Processing of the AFNLP, pages 360–368, Suntec, Singapore, August.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jason Eisner</author>
</authors>
<title>Efficient Normal-Form Parsing for Combinatory Categorial Grammar.</title>
<date>1996</date>
<booktitle>In Proceedings of the 34th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>79--86</pages>
<location>Santa Cruz, California, USA,</location>
<contexts>
<context position="7758" citStr="Eisner (1996)" startWordPosition="1216" endWordPosition="1217">aising, that allows only basic composition and is context-free: X/Y Y/Z X/Z (BX&gt; ) X/Y Y\Z X\Z (BX1&gt;) Y\Z X\Y X\Z (BX&lt; ) Y/Z X\Y X/Z (BX1&lt;) The superscript 1 denotes the arity of the composition which is too low to recover non-projective dependencies, and our grammar is thus weakly equivalent to the dependency grammar representations that are commonly used for grammar induction. The main role of composition in our fragment is that it allows sentential and verb modifiers to both take categories of the form S\S and S/S. Composition in76 troduces spurious ambiguities, which we eliminate by using Eisner (1996)’s normal form.1 Coordinating conjunctions have a special category conj, and we binarize coordination as follows (Hockenmaier and Steedman, 2007): X X[conj] ⇒&amp;1 X (&amp;1) conj X ⇒&amp;2 X[conj] (&amp;2) 3 Category induction Unlike dependency grammars, CCG requires an inventory of lexical categories. Given a set of lexical categories, the combinatory rules define the set of parses for each sentence. We follow the algorithm proposed by Bisk and Hockenmaier (2012b) to automatically induce these categories. The lexicon is initialized by pairing all nominal tags (nouns, pronouns and determiners) with the cate</context>
</contexts>
<marker>Eisner, 1996</marker>
<rawString>Jason Eisner. 1996. Efficient Normal-Form Parsing for Combinatory Categorial Grammar. In Proceedings of the 34th Annual Meeting of the Association for Computational Linguistics, pages 79–86, Santa Cruz, California, USA, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Douwe Gelling</author>
<author>Trevor Cohn</author>
<author>Phil Blunsom</author>
<author>Jo˜ao V Graca</author>
</authors>
<title>The PASCAL Challenge on Grammar Induction.</title>
<date>2012</date>
<booktitle>In NAACL HLT Workshop on Induction of Linguistic Structure,</booktitle>
<pages>64--80</pages>
<location>Montr´eal, Canada,</location>
<contexts>
<context position="4323" citStr="Gelling et al., 2012" startWordPosition="654" endWordPosition="657"> {sees, ate, ...} S\S: {quickly, today...} (S\N)/(S\N): {good, the, ...} the algorithm has identified the basic syntactic properties of the language, it is hence sufficient to inspect the induced lexicon. Conversely, Boonkwan and Steedman (2011) show that knowledge of these basic syntactic properties makes it very easy to create a language-specific lexicon for accurate unsupervised CCG parsing. We have recently proposed an algorithm for inducing CCGs (Bisk and Hockenmaier, 2012b) that has been shown to be competitive with other approaches even when paired with a very simple probability model (Gelling et al., 2012). In this paper, we pair this induction algorithm with a novel nonparametric Bayesian model that is based on a different factorization of CCG derivations, and show that it outperforms our original model and many other approaches on a large number of languages. Our results indicate that the use of CCG yields grammars that are significantly more robust when dealing with longer sentences than most dependency grammar-based approaches. 2 Combinatory Categorial Grammar Combinatory Categorial Grammar (Steedman, 2000) is a linguistically expressive, lexicalized grammar formalism that associates rich s</context>
<context position="21336" citStr="Gelling et al., 2012" startWordPosition="3498" endWordPosition="3501">ate descent, it is trivially parallelizeable. In practice, training and testing our models on the corpora containing sentences up to length 15 used in this paper takes between one minute to at most three hours on a single 12-core machine depending on their size. 6 Evaluation As is standard for this task, we evaluate our systems against a number of different dependency treebanks, and measure performance in terms of the accuracy of directed dependencies (i.e. the percentage of words in the test corpus that are correctly attached). We use the data from the PASCAL challenge for grammar induction (Gelling et al., 2012), the data from the CoNLL-X shared task (Buchholz and Marsi, 2006) and Goldberg (2011)’s Hebrew corpus. Converting CCG derivations into dependencies is mostly straightforward, since the CCG derivation identifies the root word of each sentence, and headargument and head-modifier dependencies are easily read off of CCG derivations, since the lexicon defines them explicitly. Unlike dependency grammar, CCG is designed to recover non-local dependencies that arise in control and binding constructions as well as in wh-extraction and non-standard coordination, but since this requires re-entrancies, or</context>
<context position="24213" citStr="Gelling et al., 2012" startWordPosition="3939" endWordPosition="3942">a (Figure 2), although several corpora distinguish multiple types of coordinating conjunctions which use different styles (not all shown here). Since our system has explicit rules for coordination, we transform its output into the desired target representation that is specific to each language. 7 Experiments We evaluate our system on 13 different languages. In each case, we follow the test and training regimes that were used to obtain previously published results in order to allow a direct comparison. We compare our system to the results presented at the PASCAL Challenge on Grammar Induction (Gelling et al., 2012)6, as well as to Gillenwater et al. (2011) and Naseem et al. (2012). We use Nivre (2006)’s Penn2Malt implementation of Collins (2003)’s head rules to translate the WSJ Penn Treebank (Marcus et al., 1993) into dependencies. Finally, when training the MLE version of our model we use a simple smoothing scheme which defines a small rule probability (e−15) to prevent any rule used during training from going to zero. 7.1 PASCAL Challenge on Grammar Induction In Table 1, we compare the performance of the basic Argument model (MLE), of our HDP model with four different settings of the hyperparameters </context>
<context position="29780" citStr="Gelling et al., 2012" startWordPosition="4806" endWordPosition="4809">.6/47.1 45.7/42.3 53.9/46.9 74.5/66.9 58.5/54.4 50.1/44.6 65.1/60.6 64.3/56.5 71.5/70.3 55.8/50.7 HDP1.5 49.6/50.4 58.7/54.4 53.2/48.2 74.3/67.1 57.4/54.5 50.6/45.0 70.0/64.7 65.5/57.2 69.6/68.6 55.6/50.3 HDP2.0 66.4/65.1 56.5/49.5 54.2/46.4 71.6/64.1 51.7/48.3 49.4/43.3 76.3/70.5 70.7/62.9 74.1/73.3 54.4/48.5 +/− -0.8/-1.7 +3.8/+2.5 -11.4/-15.4 +1.7/+3.5 +6.7/+2.4 -3.1/-3.9 +5.5/+3.3 -0.5/-1.9 +12.7/+13.5 -2.5/-3.7 Table 1: A comparison of the basic Argument model (MLE) and four hyper-parameter settings of the HDPCCG against two syntactic formalisms that participated in the PASCAL Challenge (Gelling et al., 2012), BH (Bisk and Hockenmaier, 2012a) and BC (Blunsom and Cohn, 2010), in addition to a max over all other participants. We trained on length 15 data (punctuation removed), including the test data as recommended by the organizers. The last row indicates the difference between our best system and the competition. global category distribution to influence each of the more specific distributions. Further, it provides a very simple knob in the choice of hyperparameters, which has a substantial effect on performance. A side effect of the hyperparameters is that their strength also determines the rate </context>
</contexts>
<marker>Gelling, Cohn, Blunsom, Graca, 2012</marker>
<rawString>Douwe Gelling, Trevor Cohn, Phil Blunsom, and Jo˜ao V Graca. 2012. The PASCAL Challenge on Grammar Induction. In NAACL HLT Workshop on Induction of Linguistic Structure, pages 64–80, Montr´eal, Canada, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jennifer Gillenwater</author>
<author>Kuzman Ganchev</author>
<author>Jo˜ao V Graca</author>
<author>Fernando Pereira</author>
<author>Ben Taskar</author>
</authors>
<title>Sparsity in Dependency Grammar Induction.</title>
<date>2010</date>
<booktitle>In Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>194--199</pages>
<location>Uppsala, Sweden,</location>
<contexts>
<context position="33915" citStr="Gillenwater et al. (2010)" startWordPosition="5483" endWordPosition="5487">jects, verbs and objects, adjectives, adverbs, auxiliaries, adpositions, possessives and relative markers, they achieve an accuracy of 68.2, which is almost iden7Our earlier generative model showed similar behavior, although the results in Bisk and Hockenmaier (2012b) are not directly comparable due to differences in the data. Sl Es Da Pt Sv #Tokens 3,857 4,230 9,549 15,015 24,021 G10 51.2 62.4 47.2 54.3 48.6 HDP 57.9 65.4 49.3 73.5 73.2 Bg WSJ Nl Ja De #Tokens 38,220 42,442 43,405 43,501 77,705 G10 59.8 64.4 47.5 60.2 47.4 HDP 66.1 70.3 56.2 64.1 68.4 Table 3: A comparison of our system with Gillenwater et al. (2010), both trained on the length 10 training data, and tested on the length 10 test data, from the CoNLL-X Shared task. tical to ours, even though we use significantly less initial knowledge. However, the lexicons we present below indicate that we are in fact learning many of the very exact details that in their system are constructed by hand. The remaining 14 questions in Boonkwan and Steedman’s questionnaire cover less frequent phenomena such as the order of negative markers, dative shift, and pro-drop. The obvious advantage of this approach is that this allows them to define a much more fine-gr</context>
</contexts>
<marker>Gillenwater, Ganchev, Graca, Pereira, Taskar, 2010</marker>
<rawString>Jennifer Gillenwater, Kuzman Ganchev, Jo˜ao V Graca, Fernando Pereira, and Ben Taskar. 2010. Sparsity in Dependency Grammar Induction. In Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics, pages 194–199, Uppsala, Sweden, July.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jennifer Gillenwater</author>
<author>Kuzman Ganchev</author>
<author>Jo˜ao V Graca</author>
<author>Fernando Pereira</author>
<author>Ben Taskar</author>
</authors>
<title>Posterior Sparsity in Unsupervised Dependency Parsing.</title>
<date>2011</date>
<journal>The Journal of Machine Learning Research,</journal>
<pages>12--455</pages>
<contexts>
<context position="1337" citStr="Gillenwater et al., 2011" startWordPosition="189" endWordPosition="192">n may be that CFGs require the specification of a finite inventory of nonterminal categories and rewrite rules, but unless one adopts linguistic principles such as X-bar theory (Jackendoff, 1977), these nonterminals are essentially arbitrary labels that can be combined in arbitrary ways. While further CFG-based approaches have been proposed (Clark, 2001; Kurihara and Sato, 2004), most recent work has followed Klein and Manning (2004) in developing models for the induction of projective dependency grammars. It has been shown that more sophisticated probability models (Headden III et al., 2009; Gillenwater et al., 2011; Cohen and Smith, 2010) and learning regimes (Spitkovsky et al., 2010), as well as the incorporation of prior linguistic knowledge (Cohen and Smith, 2009; BergKirkpatrick and Klein, 2010; Naseem et al., 2010) can lead to significant improvement over Klein and Manning’s baseline model. The use of dependency grammars circumvents the question of how to obtain an appropriate inventory of categories, since dependency parses are simply defined by unlabeled edges between the lexical items in the sentence. But dependency grammars make it also difficult to capture non-local structures, and Blunsom and</context>
<context position="24255" citStr="Gillenwater et al. (2011)" startWordPosition="3947" endWordPosition="3950"> distinguish multiple types of coordinating conjunctions which use different styles (not all shown here). Since our system has explicit rules for coordination, we transform its output into the desired target representation that is specific to each language. 7 Experiments We evaluate our system on 13 different languages. In each case, we follow the test and training regimes that were used to obtain previously published results in order to allow a direct comparison. We compare our system to the results presented at the PASCAL Challenge on Grammar Induction (Gelling et al., 2012)6, as well as to Gillenwater et al. (2011) and Naseem et al. (2012). We use Nivre (2006)’s Penn2Malt implementation of Collins (2003)’s head rules to translate the WSJ Penn Treebank (Marcus et al., 1993) into dependencies. Finally, when training the MLE version of our model we use a simple smoothing scheme which defines a small rule probability (e−15) to prevent any rule used during training from going to zero. 7.1 PASCAL Challenge on Grammar Induction In Table 1, we compare the performance of the basic Argument model (MLE), of our HDP model with four different settings of the hyperparameters (as explained above) and of the systems pr</context>
</contexts>
<marker>Gillenwater, Ganchev, Graca, Pereira, Taskar, 2011</marker>
<rawString>Jennifer Gillenwater, Kuzman Ganchev, Jo˜ao V Graca, Fernando Pereira, and Ben Taskar. 2011. Posterior Sparsity in Unsupervised Dependency Parsing. The Journal of Machine Learning Research, 12:455–490, February.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yoav Goldberg</author>
</authors>
<title>Automatic Syntactic Processing of Modern Hebrew.</title>
<date>2011</date>
<tech>Ph.D. thesis,</tech>
<institution>Ben-Gurion University of the Negev,</institution>
<contexts>
<context position="21422" citStr="Goldberg (2011)" startWordPosition="3514" endWordPosition="3515">n the corpora containing sentences up to length 15 used in this paper takes between one minute to at most three hours on a single 12-core machine depending on their size. 6 Evaluation As is standard for this task, we evaluate our systems against a number of different dependency treebanks, and measure performance in terms of the accuracy of directed dependencies (i.e. the percentage of words in the test corpus that are correctly attached). We use the data from the PASCAL challenge for grammar induction (Gelling et al., 2012), the data from the CoNLL-X shared task (Buchholz and Marsi, 2006) and Goldberg (2011)’s Hebrew corpus. Converting CCG derivations into dependencies is mostly straightforward, since the CCG derivation identifies the root word of each sentence, and headargument and head-modifier dependencies are easily read off of CCG derivations, since the lexicon defines them explicitly. Unlike dependency grammar, CCG is designed to recover non-local dependencies that arise in control and binding constructions as well as in wh-extraction and non-standard coordination, but since this requires re-entrancies, or coindexation of arguments (Hockenmaier and Steedman, 2007), within the lexical catego</context>
<context position="35496" citStr="Goldberg (2011)" startWordPosition="5759" endWordPosition="5760">sent or has been dropped. 7.3 Additional Languages In order to provide results on additional languages, we present in Table 3 a comparison to the work of Gillenwater et al. (2010) (G10), using the ConLL-X Shared Task data (Buchholz and Marsi, 2006). Following Gillenwater et al., we train only on sentences of length 10 from the training set and evaluate on the test set. Since this is a different training regime, and these corpora differ for many languages from that of the PASCAL challenge, numbers from Table 1 cannot be compared directly with those in Table 3. We have also applied our model to Goldberg (2011)’s Hebrew corpus, where it achieves an accuracy of 62.1 (trained and tested on all sentences length 10; 7,253) and 59.6 (length 15; 21,422 tokens). 83 Arabic % Swedish % WSJ % Childes % Japanese % Czech % VERB (S\N)/N 56 S 45 S\N 52 S/N 44 S 84 S 26 (S/N)/N 29 S\N 20 (S\N)/N 19 S 37 S\N 25 ADP N\N 68 (S\S)/N 49 (S\S)/N 46 (S\S)/N 45 (S/S)\N 44 (S\S)/N 42 N/N 21 (N\N)/N 25 (N\N)/N 20 N/N 25 N\N 23 (S/S)/N 26 NOUN N\N 50 N 91 N 79 N 89 N 73 N 74 N 35 N/N 12 ADJ N\N 82 N/N 50 N/N 70 N/N 46 S/S 64 N/N 55 Figure 3: Partial lexicons demonstrating language specific knowledge learned automatically for</context>
</contexts>
<marker>Goldberg, 2011</marker>
<rawString>Yoav Goldberg. 2011. Automatic Syntactic Processing of Modern Hebrew. Ph.D. thesis, Ben-Gurion University of the Negev, November.</rawString>
</citation>
<citation valid="true">
<authors>
<author>William P Headden Mark Johnson</author>
<author>David McClosky</author>
</authors>
<title>Improving Unsupervised Dependency Parsing with Richer Contexts and Smoothing.</title>
<date>2009</date>
<booktitle>In Proceedings of Human Language Technologies: The 2009 Annual Conference of the North American Chapter of the Association for Computational Linguistics,</booktitle>
<pages>101--109</pages>
<location>Boulder, Colorado,</location>
<marker>Johnson, McClosky, 2009</marker>
<rawString>William P Headden III, Mark Johnson, and David McClosky. 2009. Improving Unsupervised Dependency Parsing with Richer Contexts and Smoothing. In Proceedings of Human Language Technologies: The 2009 Annual Conference of the North American Chapter of the Association for Computational Linguistics, pages 101–109, Boulder, Colorado, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Julia Hockenmaier</author>
<author>Yonatan Bisk</author>
</authors>
<title>Normalform parsing for Combinatory Categorial Grammars with generalized composition and type-raising.</title>
<date>2010</date>
<journal>Organizing Committee.</journal>
<booktitle>In Proceedings of the 23rd International Conference on Computational Linguistics (Coling</booktitle>
<pages>465--473</pages>
<location>Beijing, China,</location>
<contexts>
<context position="9467" citStr="Hockenmaier and Bisk (2010)" startWordPosition="1495" endWordPosition="1498">etween main and auxiliary verbs2. Since the initial lexicon consists only of atomic categories, it cannot parse any complex sentences: The man ate quickly DT NNS VBD RB - N S - Complex lexical categories are induced by considering the local context in which tokens appear. Given an input sentence, and a current lexicon which assigns categories to at least some of the tokens in the sentence, we apply the following two rules to add new categories to the lexicon: The argument rule allows any lexical tokens that have categories other than N and conj to take immediately adjacent 1The normal-form of Hockenmaier and Bisk (2010) is not required for this fragment of CCG. 2This distinction was suggested by the authors (p.c.) Ns as arguments. The modifier rule allows any token (other than coordinating conjunctions that appear in the middle of sentences) to modify an immediate neighbor that has the category S or N or is a modifier (S|S or N|N) itself. The man ate quickly DT NNS VBD RB N/N N, S/S S, N\N S\S S\N These rules can be applied iteratively to form more complex categories. We restrict lexical categories to a maximal arity of 2, and disallow the category (S/N)\N, since it is equivalent to (S\N)/N. The man ate quic</context>
</contexts>
<marker>Hockenmaier, Bisk, 2010</marker>
<rawString>Julia Hockenmaier and Yonatan Bisk. 2010. Normalform parsing for Combinatory Categorial Grammars with generalized composition and type-raising. In Proceedings of the 23rd International Conference on Computational Linguistics (Coling 2010), pages 465– 473, Beijing, China, August. Coling 2010 Organizing Committee.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Julia Hockenmaier</author>
<author>Mark Steedman</author>
</authors>
<title>Generative Models for Statistical Parsing with Combinatory Categorial Grammar.</title>
<date>2002</date>
<booktitle>In Proceedings of 40th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>335--342</pages>
<location>Philadelphia, Pennsylvania, USA,</location>
<contexts>
<context position="10662" citStr="Hockenmaier and Steedman (2002)" startWordPosition="1707" endWordPosition="1710">ivalent to (S\N)/N. The man ate quickly DT NNS VBD RB N/N, N, S/S S, N\N, S\S, (S/S)/(S/S) (N\N)/(N\N) S\N (N\N)\(N\N) (N/N)\(N/N) (S/S)\(S/S) (S\S)/(S\S) The resultant, overly general, lexicon is then used to parse the training data. Each complete parse has to be of category S or N, with the constraint that sentences that contain a main verb can only form parses of category S. 4 A new probability model for CCG Generative models define the probability of a parse tree T as the product of individual rule probabilities. Our previous work (Bisk and Hockenmaier, 2012b) uses the most basic model of Hockenmaier and Steedman (2002), which first generates the head direction (left, right, unary, or lexical), followed by the head category, and finally the sister category. 3 This factorization does not take advantage of the unique functional nature of CCG. We therefore introduce a new factorization we call the Argument Model. It exploits the fact that CCG imposes strong constraints on a category’s left and right children, since these must combine to create the parent type via one of the combinators. In practice this means that given the parent X/Z, the choice of combinator4 c and an argument Y we can uniquely determine the </context>
</contexts>
<marker>Hockenmaier, Steedman, 2002</marker>
<rawString>Julia Hockenmaier and Mark Steedman. 2002. Generative Models for Statistical Parsing with Combinatory Categorial Grammar. In Proceedings of 40th Annual Meeting of the Association for Computational Linguistics, pages 335–342, Philadelphia, Pennsylvania, USA, July.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Julia Hockenmaier</author>
<author>Mark Steedman</author>
</authors>
<title>CCGbank: A Corpus of CCG Derivations and Dependency Structures Extracted from the Penn Treebank.</title>
<date>2007</date>
<journal>Computational Linguistics,</journal>
<volume>33</volume>
<issue>3</issue>
<contexts>
<context position="7903" citStr="Hockenmaier and Steedman, 2007" startWordPosition="1234" endWordPosition="1237">Y X/Z (BX1&lt;) The superscript 1 denotes the arity of the composition which is too low to recover non-projective dependencies, and our grammar is thus weakly equivalent to the dependency grammar representations that are commonly used for grammar induction. The main role of composition in our fragment is that it allows sentential and verb modifiers to both take categories of the form S\S and S/S. Composition in76 troduces spurious ambiguities, which we eliminate by using Eisner (1996)’s normal form.1 Coordinating conjunctions have a special category conj, and we binarize coordination as follows (Hockenmaier and Steedman, 2007): X X[conj] ⇒&amp;1 X (&amp;1) conj X ⇒&amp;2 X[conj] (&amp;2) 3 Category induction Unlike dependency grammars, CCG requires an inventory of lexical categories. Given a set of lexical categories, the combinatory rules define the set of parses for each sentence. We follow the algorithm proposed by Bisk and Hockenmaier (2012b) to automatically induce these categories. The lexicon is initialized by pairing all nominal tags (nouns, pronouns and determiners) with the category N, all verb tags with the category S, and coordinating conjunctions with the category conj: CONJ conj DET, NOUN, NUM, PRON N VERB S Although</context>
<context position="21995" citStr="Hockenmaier and Steedman, 2007" startWordPosition="3593" endWordPosition="3597">shared task (Buchholz and Marsi, 2006) and Goldberg (2011)’s Hebrew corpus. Converting CCG derivations into dependencies is mostly straightforward, since the CCG derivation identifies the root word of each sentence, and headargument and head-modifier dependencies are easily read off of CCG derivations, since the lexicon defines them explicitly. Unlike dependency grammar, CCG is designed to recover non-local dependencies that arise in control and binding constructions as well as in wh-extraction and non-standard coordination, but since this requires re-entrancies, or coindexation of arguments (Hockenmaier and Steedman, 2007), within the lexical categories that trigger these constructions, our current system returns only local dependencies. But since dependency grammars also captures only local dependencies, this has no negative influence on our current evaluation. However, a direct comparison between dependency treebanks and dependencies produced by CCG is more difficult (Clark and Curran, 2007), since dependency grammars allow considerable freedom in how to analyze specific constructions such as verb clusters (which verb is the head?) prepositional phrases and particles (is the head the noun or the preposition/p</context>
</contexts>
<marker>Hockenmaier, Steedman, 2007</marker>
<rawString>Julia Hockenmaier and Mark Steedman. 2007. CCGbank: A Corpus of CCG Derivations and Dependency Structures Extracted from the Penn Treebank. Computational Linguistics, 33(3):355–396, September.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yun Huang</author>
<author>Min Zhang</author>
<author>Chew Lim Tan</author>
</authors>
<title>Improved Combinatory Categorial Grammar Induction with Boundary Words and Bayesian Inference.</title>
<date>2012</date>
<booktitle>In Proceedings of the 24rd International Conference on Computational Linguistics (Coling 2012),</booktitle>
<location>Mumbai, India,</location>
<contexts>
<context position="11325" citStr="Huang et al. (2012)" startWordPosition="1818" endWordPosition="1821">left, right, unary, or lexical), followed by the head category, and finally the sister category. 3 This factorization does not take advantage of the unique functional nature of CCG. We therefore introduce a new factorization we call the Argument Model. It exploits the fact that CCG imposes strong constraints on a category’s left and right children, since these must combine to create the parent type via one of the combinators. In practice this means that given the parent X/Z, the choice of combinator4 c and an argument Y we can uniquely determine the categories of the left and right children: 3Huang et al. (2012) present a (deficient) variant and Bayesian extension of the Bisk and Hockenmaier (2012b) model without k-best smoothing that both underperform our published results. 4If X is an atomic category, only application is possible. 77 Parent c ⇒ Left Right X/Z B0 (X/Z)/Y Y &gt; B0 Y (X/Z)\Y &lt; B1 X/Y Y/Z &gt; B1 Y/Z X\Y &lt; and correspondingly for X\Z: Parent c ⇒ Left Right X\Z B0 (X\Z)/Y Y &gt; B0 Y (X\Z)\Y &lt; B1 X/Y Y\Z &gt; B1 Y\Z X\Y &lt; While type-changing and raising are not used in this work the model’s treatment of root productions extends easily to handle these other unary cases. We simply treat the argument</context>
</contexts>
<marker>Huang, Zhang, Tan, 2012</marker>
<rawString>Yun Huang, Min Zhang, and Chew Lim Tan. 2012. Improved Combinatory Categorial Grammar Induction with Boundary Words and Bayesian Inference. In Proceedings of the 24rd International Conference on Computational Linguistics (Coling 2012), Mumbai, India, December.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ray Jackendoff</author>
</authors>
<title>X-Bar Syntax: A Study of Phrase Structure.</title>
<date>1977</date>
<publisher>The MIT Press.</publisher>
<contexts>
<context position="908" citStr="Jackendoff, 1977" startWordPosition="126" endWordPosition="127">del for the induction of Combinatory Categorial Grammars from POS-tagged text. It achieves state of the art performance on a number of languages, and induces linguistically plausible lexicons. 1 Introduction What grammatical representation is appropriate for unsupervised grammar induction? Initial attempts with context-free grammars (CFGs) were not very successful (Carroll and Charniak, 1992; Charniak, 1993). One reason may be that CFGs require the specification of a finite inventory of nonterminal categories and rewrite rules, but unless one adopts linguistic principles such as X-bar theory (Jackendoff, 1977), these nonterminals are essentially arbitrary labels that can be combined in arbitrary ways. While further CFG-based approaches have been proposed (Clark, 2001; Kurihara and Sato, 2004), most recent work has followed Klein and Manning (2004) in developing models for the induction of projective dependency grammars. It has been shown that more sophisticated probability models (Headden III et al., 2009; Gillenwater et al., 2011; Cohen and Smith, 2010) and learning regimes (Spitkovsky et al., 2010), as well as the incorporation of prior linguistic knowledge (Cohen and Smith, 2009; BergKirkpatrick</context>
</contexts>
<marker>Jackendoff, 1977</marker>
<rawString>Ray Jackendoff. 1977. X-Bar Syntax: A Study of Phrase Structure. The MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dan Klein</author>
<author>Christopher D Manning</author>
</authors>
<title>CorpusBased Induction of Syntactic Structure: Models of Dependency and Constituency.</title>
<date>2004</date>
<booktitle>In Proceedings of the 42nd Meeting of the Association for Computational Linguistics (ACL’04), Main Volume,</booktitle>
<pages>478--485</pages>
<location>Barcelona, Spain,</location>
<contexts>
<context position="1150" citStr="Klein and Manning (2004)" startWordPosition="160" endWordPosition="163">tion is appropriate for unsupervised grammar induction? Initial attempts with context-free grammars (CFGs) were not very successful (Carroll and Charniak, 1992; Charniak, 1993). One reason may be that CFGs require the specification of a finite inventory of nonterminal categories and rewrite rules, but unless one adopts linguistic principles such as X-bar theory (Jackendoff, 1977), these nonterminals are essentially arbitrary labels that can be combined in arbitrary ways. While further CFG-based approaches have been proposed (Clark, 2001; Kurihara and Sato, 2004), most recent work has followed Klein and Manning (2004) in developing models for the induction of projective dependency grammars. It has been shown that more sophisticated probability models (Headden III et al., 2009; Gillenwater et al., 2011; Cohen and Smith, 2010) and learning regimes (Spitkovsky et al., 2010), as well as the incorporation of prior linguistic knowledge (Cohen and Smith, 2009; BergKirkpatrick and Klein, 2010; Naseem et al., 2010) can lead to significant improvement over Klein and Manning’s baseline model. The use of dependency grammars circumvents the question of how to obtain an appropriate inventory of categories, since depende</context>
<context position="25181" citStr="Klein and Manning (2004)" startWordPosition="4100" endWordPosition="4103">ty (e−15) to prevent any rule used during training from going to zero. 7.1 PASCAL Challenge on Grammar Induction In Table 1, we compare the performance of the basic Argument model (MLE), of our HDP model with four different settings of the hyperparameters (as explained above) and of the systems presented in the PASCAL Challenge on Grammar Induction (Gelling et al., 2012). The systems in this competition were instructed to train over the full dataset, including the unlabelled test data, and include Bisk and Hockenmaier (2012a)’s CCG-based system (BH) to Cohn et al. (2010)’s reimplementation of Klein and Manning (2004)’s DMV model in a tree-substitution grammar framework (BC), as well as three other dependency based systems which either incorporate Naseem et al. (2010)’s rules in a deterministic fashion (Søgaard, 2012), rely on extensive tuning on 6Numbers are from personal correspondence with the organizers. The previously published numbers are not comparable to literature due to an error in the evaluation. http://wiki. cs.ox.ac.uk/InducingLinguisticStructure/ ResultsDepComparable the development set (Tu, 2012) or incorporate millions of additional tokens from Wikipedia to estimate model parameters (Marece</context>
</contexts>
<marker>Klein, Manning, 2004</marker>
<rawString>Dan Klein and Christopher D Manning. 2004. CorpusBased Induction of Syntactic Structure: Models of Dependency and Constituency. In Proceedings of the 42nd Meeting of the Association for Computational Linguistics (ACL’04), Main Volume, pages 478–485, Barcelona, Spain, July.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenichi Kurihara</author>
<author>Taisuke Sato</author>
</authors>
<title>An Application of the Variational Bayesian Approach to Probabilistic Context-Free Grammars.</title>
<date>2004</date>
<booktitle>International Joint Conference on Natural Language Language Processing Workshop Beyond Shallow Analyses,</booktitle>
<contexts>
<context position="1094" citStr="Kurihara and Sato, 2004" startWordPosition="150" endWordPosition="153">ble lexicons. 1 Introduction What grammatical representation is appropriate for unsupervised grammar induction? Initial attempts with context-free grammars (CFGs) were not very successful (Carroll and Charniak, 1992; Charniak, 1993). One reason may be that CFGs require the specification of a finite inventory of nonterminal categories and rewrite rules, but unless one adopts linguistic principles such as X-bar theory (Jackendoff, 1977), these nonterminals are essentially arbitrary labels that can be combined in arbitrary ways. While further CFG-based approaches have been proposed (Clark, 2001; Kurihara and Sato, 2004), most recent work has followed Klein and Manning (2004) in developing models for the induction of projective dependency grammars. It has been shown that more sophisticated probability models (Headden III et al., 2009; Gillenwater et al., 2011; Cohen and Smith, 2010) and learning regimes (Spitkovsky et al., 2010), as well as the incorporation of prior linguistic knowledge (Cohen and Smith, 2009; BergKirkpatrick and Klein, 2010; Naseem et al., 2010) can lead to significant improvement over Klein and Manning’s baseline model. The use of dependency grammars circumvents the question of how to obta</context>
</contexts>
<marker>Kurihara, Sato, 2004</marker>
<rawString>Kenichi Kurihara and Taisuke Sato. 2004. An Application of the Variational Bayesian Approach to Probabilistic Context-Free Grammars. International Joint Conference on Natural Language Language Processing Workshop Beyond Shallow Analyses, March.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenichi Kurihara</author>
<author>Max Welling</author>
<author>Yee-Whye Teh</author>
</authors>
<title>Collapsed Variational Dirichlet Process Mixture Models.</title>
<date>2007</date>
<booktitle>In Proceedings of the 20th International Joint Conference on Artificial Intelligence (IJCAI07),</booktitle>
<pages>2796--2801</pages>
<location>Hyderabad, India,</location>
<contexts>
<context position="19780" citStr="Kurihara et al. (2007)" startWordPosition="3244" endWordPosition="3247">. As an alternative to Gibbs sampling (Teh et al., 2006), which is exact, but typically very slow and has no clear convergence criteria, variational inference algorithms (Bishop, 2006; Blei and Jordan, 2004) estimate the parameters of a truncated model to maximize a lower bound of the likelihood of the actual model. This allows for factorization of the model and a training procedure analogous to the Inside-Outside algorithm (Lari and Young, 1991), allowing training to run very quickly and in a trivially parallelizable manner. To initialize the base DP’s stick weights, we follow the example of Kurihara et al. (2007) and use an MLE model initialized with uniform distributions to compute global counts for the categories in our grammar. When normalized these provide a better initialization than a uniform set of weights. Updates to the distributions are then performed in a coordinate descent manner which includes re-estimation of the base DPs. In variational inference, multinomial weights W take the place of probabilities. The weights for an outcome Y with conditioning variable P are computed by summing pseudocounts with a scaled mean vector from the base DP. The computation involves moving in the direction </context>
</contexts>
<marker>Kurihara, Welling, Teh, 2007</marker>
<rawString>Kenichi Kurihara, Max Welling, and Yee-Whye Teh. 2007. Collapsed Variational Dirichlet Process Mixture Models. In Proceedings of the 20th International Joint Conference on Artificial Intelligence (IJCAI07), pages 2796–2801, Hyderabad, India, January.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tom Kwiatkowski</author>
<author>Sharon Goldwater</author>
<author>Luke Zettlemoyer</author>
<author>Mark Steedman</author>
</authors>
<title>A probabilistic model of syntactic and semantic acquisition from child-directed utterances and their meanings.</title>
<date>2012</date>
<booktitle>In Proceedings of the 13th Conference of the European Chapter of the Association for Computational Linguistics,</booktitle>
<pages>234--244</pages>
<publisher>Association</publisher>
<institution>for Computational Linguistics.</institution>
<location>Avignon, France,</location>
<contexts>
<context position="15447" citStr="Kwiatkowski et al. (2012)" startWordPosition="2511" endWordPosition="2514">rresponds to the mean of the DP, and a concentration or shape parameter α. In a Hierarchical Dirichlet Process (Teh et al., 2006), there is a hierarchy of DPs, such that the base distribution of a DP at level n is a DP at level n − 1. The HDP-CCG (Figure 1) is a reformulation of the Argument Model introduced above in terms of Hierarchical Dirichlet Processes.5 At the heart of the model is a distribution over CCG categories. By combining a stick breaking process with a multinomial over categories we can define a DP over CCG 5An alternative HDP model for semantic parsing with CCG is proposed by Kwiatkowski et al. (2012). p(t|P) x 78 βY βL z ∞ y φY φL θT θC ∞ zi yi ci zL(i) zR(i) xL(i) xR(i) Because we are working with CCG, the parent zi, argument yi and combinator ci uniquely define the two children categories (zL(i), zR(i)). The dashed arrows here represent the deterministic process used to generate these two categories. HDP-CCG 1) Draw global parameters Define MLE root parameter θTOP Draw top-level symbol weights βY — GEM(αY ) Draw top-level lexical weights βL — GEM(αL) For each grammar symbol z E {1, 2, ...}: Define MLE rule type parameters θTz Draw argument parameters φYz — DP(αY, βY ) Draw lexical emiss</context>
</contexts>
<marker>Kwiatkowski, Goldwater, Zettlemoyer, Steedman, 2012</marker>
<rawString>Tom Kwiatkowski, Sharon Goldwater, Luke Zettlemoyer, and Mark Steedman. 2012. A probabilistic model of syntactic and semantic acquisition from child-directed utterances and their meanings. In Proceedings of the 13th Conference of the European Chapter of the Association for Computational Linguistics, pages 234– 244, Avignon, France, April. Association for Computational Linguistics.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Karim Lari</author>
<author>Steve J Young</author>
</authors>
<title>Applications of stochastic context-free grammars using the InsideOutside algorithm.</title>
<date>1991</date>
<journal>Computer speech &amp; language,</journal>
<volume>5</volume>
<issue>3</issue>
<contexts>
<context position="19608" citStr="Lari and Young, 1991" startWordPosition="3215" endWordPosition="3218">it avoids the need to capture correlations be79 tween different base distributions for Y and Z. Variational Inference HDPs need to be estimated with approximate techniques. As an alternative to Gibbs sampling (Teh et al., 2006), which is exact, but typically very slow and has no clear convergence criteria, variational inference algorithms (Bishop, 2006; Blei and Jordan, 2004) estimate the parameters of a truncated model to maximize a lower bound of the likelihood of the actual model. This allows for factorization of the model and a training procedure analogous to the Inside-Outside algorithm (Lari and Young, 1991), allowing training to run very quickly and in a trivially parallelizable manner. To initialize the base DP’s stick weights, we follow the example of Kurihara et al. (2007) and use an MLE model initialized with uniform distributions to compute global counts for the categories in our grammar. When normalized these provide a better initialization than a uniform set of weights. Updates to the distributions are then performed in a coordinate descent manner which includes re-estimation of the base DPs. In variational inference, multinomial weights W take the place of probabilities. The weights for </context>
</contexts>
<marker>Lari, Young, 1991</marker>
<rawString>Karim Lari and Steve J Young. 1991. Applications of stochastic context-free grammars using the InsideOutside algorithm. Computer speech &amp; language, 5(3):237–257, January.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Percy Liang</author>
<author>Slav Petrov</author>
<author>Michael I Jordan</author>
<author>Dan Klein</author>
</authors>
<title>The Infinite PCFG Using Hierarchical Dirichlet Processes.</title>
<date>2007</date>
<booktitle>In Proceedings of the 2007 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning (EMNLP-CoNLL),</booktitle>
<pages>688--697</pages>
<location>Prague, Czech Republic.</location>
<contexts>
<context position="18754" citStr="Liang et al., 2007" startWordPosition="3074" endWordPosition="3077">ears to be superlinear but subquadratic in n, we present results where p takes the values 0, 1.0, 1.5, and 2.0 to explore the range from uniform to quadratic. This setting for α is the only free parameter in the model. By controlling precision we can tell the model to what extent global corpus statistics should be trusted. We believe this has a similar effect to Bisk and Hockenmaier (2012b)’s top-k upweighting and smoothing scheme. One advantage of the argument model is that it only requires a single distribution over categories for each binary tree. In contrast to similar proposals for CFGs (Liang et al., 2007), which impose no formal restrictions on the nonterminals X, Y, Z that can appear in a rewrite rule X -+ Y Z, this greatly simplifies the modeling problem (yielding effectively a model that is more akin to nonparametric HMMs), since it avoids the need to capture correlations be79 tween different base distributions for Y and Z. Variational Inference HDPs need to be estimated with approximate techniques. As an alternative to Gibbs sampling (Teh et al., 2006), which is exact, but typically very slow and has no clear convergence criteria, variational inference algorithms (Bishop, 2006; Blei and Jo</context>
</contexts>
<marker>Liang, Petrov, Jordan, Klein, 2007</marker>
<rawString>Percy Liang, Slav Petrov, Michael I Jordan, and Dan Klein. 2007. The Infinite PCFG Using Hierarchical Dirichlet Processes. In Proceedings of the 2007 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning (EMNLP-CoNLL), pages 688–697, Prague, Czech Republic.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Percy Liang</author>
<author>Michael I Jordan</author>
<author>Dan Klein</author>
</authors>
<title>Probabilistic Grammars and Hierarchical Dirichlet Processes. In The Oxford Handbook of Applied Bayesian Analysis.</title>
<date>2009</date>
<publisher>Oxford University Press.</publisher>
<contexts>
<context position="18094" citStr="Liang et al. (2009)" startWordPosition="2958" endWordPosition="2961">nes how similar individual draws will be. This precision is determined by the magnitude of the hyperparameter αY . This hierarchy is paralleled for lexical productions which are drawn from a unigram base DP over terminal symbols controlled by αL. For simplicity we use the same scheme for setting the values for αL as αY . We present experimental results in which we vary the value of αY as a function of the number of outcomes allowed by the grammar for argument categories or the corpus in the case of terminal symbols. Specifically, we set αY = np for conditioning contexts with n outcomes. Since Liang et al. (2009) found that the ideal value for alpha appears to be superlinear but subquadratic in n, we present results where p takes the values 0, 1.0, 1.5, and 2.0 to explore the range from uniform to quadratic. This setting for α is the only free parameter in the model. By controlling precision we can tell the model to what extent global corpus statistics should be trusted. We believe this has a similar effect to Bisk and Hockenmaier (2012b)’s top-k upweighting and smoothing scheme. One advantage of the argument model is that it only requires a single distribution over categories for each binary tree. In</context>
</contexts>
<marker>Liang, Jordan, Klein, 2009</marker>
<rawString>Percy Liang, Michael I Jordan, and Dan Klein. 2009. Probabilistic Grammars and Hierarchical Dirichlet Processes. In The Oxford Handbook of Applied Bayesian Analysis. Oxford University Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mitchell P Marcus</author>
<author>Beatrice Santorini</author>
<author>Mary Ann Marcinkiewicz</author>
</authors>
<title>Building a Large Annotated Corpus of English: The Penn Treebank.</title>
<date>1993</date>
<journal>Computational Linguistics,</journal>
<volume>19</volume>
<issue>2</issue>
<contexts>
<context position="24416" citStr="Marcus et al., 1993" startWordPosition="3973" endWordPosition="3976">nsform its output into the desired target representation that is specific to each language. 7 Experiments We evaluate our system on 13 different languages. In each case, we follow the test and training regimes that were used to obtain previously published results in order to allow a direct comparison. We compare our system to the results presented at the PASCAL Challenge on Grammar Induction (Gelling et al., 2012)6, as well as to Gillenwater et al. (2011) and Naseem et al. (2012). We use Nivre (2006)’s Penn2Malt implementation of Collins (2003)’s head rules to translate the WSJ Penn Treebank (Marcus et al., 1993) into dependencies. Finally, when training the MLE version of our model we use a simple smoothing scheme which defines a small rule probability (e−15) to prevent any rule used during training from going to zero. 7.1 PASCAL Challenge on Grammar Induction In Table 1, we compare the performance of the basic Argument model (MLE), of our HDP model with four different settings of the hyperparameters (as explained above) and of the systems presented in the PASCAL Challenge on Grammar Induction (Gelling et al., 2012). The systems in this competition were instructed to train over the full dataset, incl</context>
</contexts>
<marker>Marcus, Santorini, Marcinkiewicz, 1993</marker>
<rawString>Mitchell P Marcus, Beatrice Santorini, and Mary Ann Marcinkiewicz. 1993. Building a Large Annotated Corpus of English: The Penn Treebank. Computational Linguistics, 19(2):313–330, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Marecek</author>
<author>Zdenek Zabokrtsky</author>
</authors>
<title>Unsupervised Dependency Parsing using Reducibility and Fertility features.</title>
<date>2012</date>
<booktitle>In NAACL HLT Workshop on Induction of Linguistic Structure,</booktitle>
<pages>84--89</pages>
<location>Montr´eal, Canada,</location>
<contexts>
<context position="25804" citStr="Marecek and Zabokrtsky, 2012" startWordPosition="4189" endWordPosition="4192">(2004)’s DMV model in a tree-substitution grammar framework (BC), as well as three other dependency based systems which either incorporate Naseem et al. (2010)’s rules in a deterministic fashion (Søgaard, 2012), rely on extensive tuning on 6Numbers are from personal correspondence with the organizers. The previously published numbers are not comparable to literature due to an error in the evaluation. http://wiki. cs.ox.ac.uk/InducingLinguisticStructure/ ResultsDepComparable the development set (Tu, 2012) or incorporate millions of additional tokens from Wikipedia to estimate model parameters (Marecek and Zabokrtsky, 2012). We ignore punctuation for all experiments reported in this paper, but since the training data (but not the evaluation) includes punctuation marks, participants were free to choose whether to include punctuation or ignore it. While BH is the only other system with directly interpretable linguistic output, we also include a direct comparison with BC, whose TSG representation is equally expressive to ours. Finally we present a row with the maximum performance among the other three models. As we have no knowledge of how much data was used in the training of other systems we simply present result</context>
</contexts>
<marker>Marecek, Zabokrtsky, 2012</marker>
<rawString>David Marecek and Zdenek Zabokrtsky. 2012. Unsupervised Dependency Parsing using Reducibility and Fertility features. In NAACL HLT Workshop on Induction of Linguistic Structure, pages 84–89, Montr´eal, Canada, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tahira Naseem</author>
<author>Harr Chen</author>
<author>Regina Barzilay</author>
<author>Mark Johnson</author>
</authors>
<title>Using Universal Linguistic Knowledge to Guide Grammar Induction.</title>
<date>2010</date>
<booktitle>In Proceedings of the 2010 Conference on Empirical Methods in Natural Language Processing,</booktitle>
<pages>1234--1244</pages>
<location>Cambridge, MA,</location>
<contexts>
<context position="1546" citStr="Naseem et al., 2010" startWordPosition="223" endWordPosition="226">ls are essentially arbitrary labels that can be combined in arbitrary ways. While further CFG-based approaches have been proposed (Clark, 2001; Kurihara and Sato, 2004), most recent work has followed Klein and Manning (2004) in developing models for the induction of projective dependency grammars. It has been shown that more sophisticated probability models (Headden III et al., 2009; Gillenwater et al., 2011; Cohen and Smith, 2010) and learning regimes (Spitkovsky et al., 2010), as well as the incorporation of prior linguistic knowledge (Cohen and Smith, 2009; BergKirkpatrick and Klein, 2010; Naseem et al., 2010) can lead to significant improvement over Klein and Manning’s baseline model. The use of dependency grammars circumvents the question of how to obtain an appropriate inventory of categories, since dependency parses are simply defined by unlabeled edges between the lexical items in the sentence. But dependency grammars make it also difficult to capture non-local structures, and Blunsom and Cohn (2010) show that it may be advantageous to reformulate the underlying dependency grammar in terms of a tree-substitution grammar (TSG) which pairs words with treelets that specify the number of left and </context>
<context position="13158" citStr="Naseem et al., 2010" startWordPosition="2134" endWordPosition="2137">-parametric extensions. 5 HDP-CCG: a nonparametric model Simple generative models such as PCFGs or Bisk and Hockenmaier (2012b)’s CCG model are not robust in the face of sparsity, since they assign zero probability to any unseen event. Sparsity is a particular problem for formalisms like CCG that have a rich inventory of object types. Nonparametric Bayesian models, e.g. Dirichlet Processes (Teh, 2010) or their hierarchical variants (Teh et al., 2006) and generalizations (Teh, 2006) overcome this problem in a very elegant manner, and are used by many state-of-the-art grammar induction systems (Naseem et al., 2010; Blunsom and Cohn, 2010; Boonkwan and Steedman, 2011). They also impose a rich-getting-richer behavior that seems to be advantageous in many modeling applications. By contrast, Bisk and Hockenmaier (2012b) propose a weighted top-k scheme to address these issues in an ad-hoc manner. The argument model introduced above lends itself particularly well to nonparametric extensions such as the standard Hierarchical Dirichlet Processes (HDP). In this work the size of the grammar and the number of productions are fixed and small, but we present the formulation as infinite to allow for easy extension i</context>
<context position="25334" citStr="Naseem et al. (2010)" startWordPosition="4125" endWordPosition="4128">e basic Argument model (MLE), of our HDP model with four different settings of the hyperparameters (as explained above) and of the systems presented in the PASCAL Challenge on Grammar Induction (Gelling et al., 2012). The systems in this competition were instructed to train over the full dataset, including the unlabelled test data, and include Bisk and Hockenmaier (2012a)’s CCG-based system (BH) to Cohn et al. (2010)’s reimplementation of Klein and Manning (2004)’s DMV model in a tree-substitution grammar framework (BC), as well as three other dependency based systems which either incorporate Naseem et al. (2010)’s rules in a deterministic fashion (Søgaard, 2012), rely on extensive tuning on 6Numbers are from personal correspondence with the organizers. The previously published numbers are not comparable to literature due to an error in the evaluation. http://wiki. cs.ox.ac.uk/InducingLinguisticStructure/ ResultsDepComparable the development set (Tu, 2012) or incorporate millions of additional tokens from Wikipedia to estimate model parameters (Marecek and Zabokrtsky, 2012). We ignore punctuation for all experiments reported in this paper, but since the training data (but not the evaluation) includes </context>
<context position="30851" citStr="Naseem et al. (2010)" startWordPosition="4982" endWordPosition="4985">hyperparameters, which has a substantial effect on performance. A side effect of the hyperparameters is that their strength also determines the rate of convergence. This may be one of the reasons for the high variance seen in the four settings tested, although we note that since our initialization is always uniform, and not random, consecutive runs do not introduce variance in the model’s performance. 7.2 Comparison with systems that capture linguistic constraints Since our induction algorithm is based on the knowledge of which POS tags are nouns and verbs, we compare in Table 2 our system to Naseem et al. (2010), who present a nonparametric dependency model that incorporates thirteen universal linguistic constraints. Three of these constraints correspond to our rules that verbs are the roots of sentences and may take nouns as dependents, but the other ten constraints (e.g. that adjectives modify nouns, adverbs modify adjectives or verbs, etc.) have no equivalent in our system. Although our system has less prior knowledge, it still performs competitively. On the WSJ, Naseem et al. demonstrate the importance and effect of the specific choice of syntactic rules by comparing the performance of their syst</context>
</contexts>
<marker>Naseem, Chen, Barzilay, Johnson, 2010</marker>
<rawString>Tahira Naseem, Harr Chen, Regina Barzilay, and Mark Johnson. 2010. Using Universal Linguistic Knowledge to Guide Grammar Induction. In Proceedings of the 2010 Conference on Empirical Methods in Natural Language Processing, pages 1234–1244, Cambridge, MA, October.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tahira Naseem</author>
<author>Regina Barzilay</author>
<author>Amir Globerson</author>
</authors>
<title>Selective Sharing for Multilingual Dependency Parsing.</title>
<date>2012</date>
<booktitle>In Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers),</booktitle>
<pages>629--637</pages>
<location>Jeju, Republic of</location>
<contexts>
<context position="24280" citStr="Naseem et al. (2012)" startWordPosition="3952" endWordPosition="3955"> coordinating conjunctions which use different styles (not all shown here). Since our system has explicit rules for coordination, we transform its output into the desired target representation that is specific to each language. 7 Experiments We evaluate our system on 13 different languages. In each case, we follow the test and training regimes that were used to obtain previously published results in order to allow a direct comparison. We compare our system to the results presented at the PASCAL Challenge on Grammar Induction (Gelling et al., 2012)6, as well as to Gillenwater et al. (2011) and Naseem et al. (2012). We use Nivre (2006)’s Penn2Malt implementation of Collins (2003)’s head rules to translate the WSJ Penn Treebank (Marcus et al., 1993) into dependencies. Finally, when training the MLE version of our model we use a simple smoothing scheme which defines a small rule probability (e−15) to prevent any rule used during training from going to zero. 7.1 PASCAL Challenge on Grammar Induction In Table 1, we compare the performance of the basic Argument model (MLE), of our HDP model with four different settings of the hyperparameters (as explained above) and of the systems presented in the PASCAL Cha</context>
</contexts>
<marker>Naseem, Barzilay, Globerson, 2012</marker>
<rawString>Tahira Naseem, Regina Barzilay, and Amir Globerson. 2012. Selective Sharing for Multilingual Dependency Parsing. In Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 629–637, Jeju, Republic of Korea, July.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joakim Nivre</author>
</authors>
<title>Inductive Dependency Parsing.</title>
<date>2006</date>
<publisher>Springer.</publisher>
<contexts>
<context position="24301" citStr="Nivre (2006)" startWordPosition="3958" endWordPosition="3959">ich use different styles (not all shown here). Since our system has explicit rules for coordination, we transform its output into the desired target representation that is specific to each language. 7 Experiments We evaluate our system on 13 different languages. In each case, we follow the test and training regimes that were used to obtain previously published results in order to allow a direct comparison. We compare our system to the results presented at the PASCAL Challenge on Grammar Induction (Gelling et al., 2012)6, as well as to Gillenwater et al. (2011) and Naseem et al. (2012). We use Nivre (2006)’s Penn2Malt implementation of Collins (2003)’s head rules to translate the WSJ Penn Treebank (Marcus et al., 1993) into dependencies. Finally, when training the MLE version of our model we use a simple smoothing scheme which defines a small rule probability (e−15) to prevent any rule used during training from going to zero. 7.1 PASCAL Challenge on Grammar Induction In Table 1, we compare the performance of the basic Argument model (MLE), of our HDP model with four different settings of the hyperparameters (as explained above) and of the systems presented in the PASCAL Challenge on Grammar Ind</context>
</contexts>
<marker>Nivre, 2006</marker>
<rawString>Joakim Nivre. 2006. Inductive Dependency Parsing. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Slav Petrov</author>
<author>Dipanjan Das</author>
<author>Ryan McDonald</author>
</authors>
<title>A Universal Part-of-Speech Tagset.</title>
<date>2012</date>
<booktitle>In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC-2012),</booktitle>
<pages>pages</pages>
<location>Istanbul, Turkey,</location>
<contexts>
<context position="8617" citStr="Petrov et al. (2012)" startWordPosition="1354" endWordPosition="1357">, CCG requires an inventory of lexical categories. Given a set of lexical categories, the combinatory rules define the set of parses for each sentence. We follow the algorithm proposed by Bisk and Hockenmaier (2012b) to automatically induce these categories. The lexicon is initialized by pairing all nominal tags (nouns, pronouns and determiners) with the category N, all verb tags with the category S, and coordinating conjunctions with the category conj: CONJ conj DET, NOUN, NUM, PRON N VERB S Although our lexicons are defined over corpusspecific POS tags, we use a slightly modified version of Petrov et al. (2012)’s Universal POS tagset to categorize them into these broad classes. The primary changes we make to their mappings are the addition of a distinction (where possible) between subordinating and coordinating conjunctions and between main and auxiliary verbs2. Since the initial lexicon consists only of atomic categories, it cannot parse any complex sentences: The man ate quickly DT NNS VBD RB - N S - Complex lexical categories are induced by considering the local context in which tokens appear. Given an input sentence, and a current lexicon which assigns categories to at least some of the tokens i</context>
</contexts>
<marker>Petrov, Das, McDonald, 2012</marker>
<rawString>Slav Petrov, Dipanjan Das, and Ryan McDonald. 2012. A Universal Part-of-Speech Tagset. In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC-2012), pages 2089– 2096, Istanbul, Turkey, May.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Anders Søgaard</author>
</authors>
<title>Two baselines for unsupervised dependency parsing.</title>
<date>2012</date>
<booktitle>In NAACL HLT Workshop on Induction of Linguistic Structure,</booktitle>
<pages>81--83</pages>
<location>Montr´eal, Canada,</location>
<contexts>
<context position="25385" citStr="Søgaard, 2012" startWordPosition="4135" endWordPosition="4136">different settings of the hyperparameters (as explained above) and of the systems presented in the PASCAL Challenge on Grammar Induction (Gelling et al., 2012). The systems in this competition were instructed to train over the full dataset, including the unlabelled test data, and include Bisk and Hockenmaier (2012a)’s CCG-based system (BH) to Cohn et al. (2010)’s reimplementation of Klein and Manning (2004)’s DMV model in a tree-substitution grammar framework (BC), as well as three other dependency based systems which either incorporate Naseem et al. (2010)’s rules in a deterministic fashion (Søgaard, 2012), rely on extensive tuning on 6Numbers are from personal correspondence with the organizers. The previously published numbers are not comparable to literature due to an error in the evaluation. http://wiki. cs.ox.ac.uk/InducingLinguisticStructure/ ResultsDepComparable the development set (Tu, 2012) or incorporate millions of additional tokens from Wikipedia to estimate model parameters (Marecek and Zabokrtsky, 2012). We ignore punctuation for all experiments reported in this paper, but since the training data (but not the evaluation) includes punctuation marks, participants were free to choose</context>
</contexts>
<marker>Søgaard, 2012</marker>
<rawString>Anders Søgaard. 2012. Two baselines for unsupervised dependency parsing. In NAACL HLT Workshop on Induction of Linguistic Structure, pages 81– 83, Montr´eal, Canada, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Valentin I Spitkovsky</author>
<author>Hiyan Alshawi</author>
<author>Daniel Jurafsky</author>
</authors>
<title>From Baby Steps to Leapfrog: How “Less is More” in Unsupervised Dependency Parsing.</title>
<date>2010</date>
<booktitle>In Human Language Technologies: The 2010 Annual Conference of the North American Chapter of the Association for Computational Linguistics,</booktitle>
<pages>751--759</pages>
<location>Los Angeles, California,</location>
<contexts>
<context position="1408" citStr="Spitkovsky et al., 2010" startWordPosition="200" endWordPosition="203">onterminal categories and rewrite rules, but unless one adopts linguistic principles such as X-bar theory (Jackendoff, 1977), these nonterminals are essentially arbitrary labels that can be combined in arbitrary ways. While further CFG-based approaches have been proposed (Clark, 2001; Kurihara and Sato, 2004), most recent work has followed Klein and Manning (2004) in developing models for the induction of projective dependency grammars. It has been shown that more sophisticated probability models (Headden III et al., 2009; Gillenwater et al., 2011; Cohen and Smith, 2010) and learning regimes (Spitkovsky et al., 2010), as well as the incorporation of prior linguistic knowledge (Cohen and Smith, 2009; BergKirkpatrick and Klein, 2010; Naseem et al., 2010) can lead to significant improvement over Klein and Manning’s baseline model. The use of dependency grammars circumvents the question of how to obtain an appropriate inventory of categories, since dependency parses are simply defined by unlabeled edges between the lexical items in the sentence. But dependency grammars make it also difficult to capture non-local structures, and Blunsom and Cohn (2010) show that it may be advantageous to reformulate the underl</context>
<context position="32249" citStr="Spitkovsky et al. (2010)" startWordPosition="5211" endWordPosition="5214">tem drops very significantly as sentence length (and presumable parse complexity) 82 Sl Es Da Pt Sv ∼#Tokens 3.8K 4.2K 9.5K 15K 24K N10 50.9 67.2 51.9 71.5 63.3 HDP 56.6 62.1 51.5 74.7 69.8 Table 2: A comparison of our system with Naseem et al. (2010), both trained and tested on the length 10 training data from the CoNLL-X Shared Task. increases, whereas our system shows significantly less decline, and outperforms their universal system by a significant margin.7 &lt; 10 &lt; 20 Naseem Universal Rules 71.9 50.4 Naseem English Rules 73.8 66.1 HDP-CCG 68.2 64.2 HDP-CCG (train ≤ 20) 71.9 In contrast to Spitkovsky et al. (2010), who reported that performance of their dependency based system degrades when trained on longer sentences, our performance on length 10 sentences increases to 71.9 when we train on sentences up to length 20. Another system that is also based on CCG, but captures significantly more linguistic knowledge than ours, was presented by Boonkwan and Steedman (2011), who achieve an accuracy of 74.5 on WSJ10 section 23 (trained on sections 02-22). Using the same settings, our system achieves an accuracy of 68.4. Unlike our approach, Boonkwan and Steedman do not automatically induce an appropriate inven</context>
</contexts>
<marker>Spitkovsky, Alshawi, Jurafsky, 2010</marker>
<rawString>Valentin I Spitkovsky, Hiyan Alshawi, and Daniel Jurafsky. 2010. From Baby Steps to Leapfrog: How “Less is More” in Unsupervised Dependency Parsing. In Human Language Technologies: The 2010 Annual Conference of the North American Chapter of the Association for Computational Linguistics, pages 751–759, Los Angeles, California, June.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Steedman</author>
</authors>
<title>Surface Structure and Interpretation.</title>
<date>1996</date>
<publisher>The MIT Press,</publisher>
<contexts>
<context position="2310" citStr="Steedman (1996" startWordPosition="345" endWordPosition="346"> an appropriate inventory of categories, since dependency parses are simply defined by unlabeled edges between the lexical items in the sentence. But dependency grammars make it also difficult to capture non-local structures, and Blunsom and Cohn (2010) show that it may be advantageous to reformulate the underlying dependency grammar in terms of a tree-substitution grammar (TSG) which pairs words with treelets that specify the number of left and right dependents they have. In this paper, we explore yet another option: instead of dependency grammars, we use Combinatory Categorial Grammar (CCG, Steedman (1996; 2000)), a linguistically expressive formalism that pairs lexical items with rich categories that capture all language-specific information. This may seem a puzzling choice, since CCG requires a significantly larger inventory of categories than is commonly assumed for CFGs. However, unlike CFG nonterminals, CCG categories are not arbitrary symbols: they encode, and are determined by, the basic word order of the language and the number of arguments each word takes. CCG is very similar to TSG in that it also pairs lexical items with rich items that capture all language-specific information. Lik</context>
</contexts>
<marker>Steedman, 1996</marker>
<rawString>Mark Steedman. 1996. Surface Structure and Interpretation. The MIT Press, January.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Steedman</author>
</authors>
<title>The Syntactic Process.</title>
<date>2000</date>
<publisher>The MIT Press,</publisher>
<contexts>
<context position="4838" citStr="Steedman, 2000" startWordPosition="734" endWordPosition="735">e with other approaches even when paired with a very simple probability model (Gelling et al., 2012). In this paper, we pair this induction algorithm with a novel nonparametric Bayesian model that is based on a different factorization of CCG derivations, and show that it outperforms our original model and many other approaches on a large number of languages. Our results indicate that the use of CCG yields grammars that are significantly more robust when dealing with longer sentences than most dependency grammar-based approaches. 2 Combinatory Categorial Grammar Combinatory Categorial Grammar (Steedman, 2000) is a linguistically expressive, lexicalized grammar formalism that associates rich syntactic types with words and constituents. For simplicity, we restrict ourselves to the standard two atomic types S (sentences) and N (encompassing both nouns and noun phrases) from which we recursively build categories. Complex categories are of the form X/Y or X\Y, and represent functions which return a result of type X when combined with an argument of type Y. The directionality of the slash indicates whether the argument precedes or follows the functor. We write X|Y when the direction of the slash does no</context>
</contexts>
<marker>Steedman, 2000</marker>
<rawString>Mark Steedman. 2000. The Syntactic Process. The MIT Press, September.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yee-Whye Teh</author>
<author>Michael I Jordan</author>
<author>Matthew J Beal</author>
<author>David M Blei</author>
</authors>
<title>Hierarchical Dirichlet Processes.</title>
<date>2006</date>
<journal>Journal of the American Statistical Association,</journal>
<volume>101</volume>
<issue>476</issue>
<contexts>
<context position="12993" citStr="Teh et al., 2006" startWordPosition="2109" endWordPosition="2112">model generates only one CCG category but uniquely defines the two children of a parent node. We will see below that this greatly simplifies the development of non-parametric extensions. 5 HDP-CCG: a nonparametric model Simple generative models such as PCFGs or Bisk and Hockenmaier (2012b)’s CCG model are not robust in the face of sparsity, since they assign zero probability to any unseen event. Sparsity is a particular problem for formalisms like CCG that have a rich inventory of object types. Nonparametric Bayesian models, e.g. Dirichlet Processes (Teh, 2010) or their hierarchical variants (Teh et al., 2006) and generalizations (Teh, 2006) overcome this problem in a very elegant manner, and are used by many state-of-the-art grammar induction systems (Naseem et al., 2010; Blunsom and Cohn, 2010; Boonkwan and Steedman, 2011). They also impose a rich-getting-richer behavior that seems to be advantageous in many modeling applications. By contrast, Bisk and Hockenmaier (2012b) propose a weighted top-k scheme to address these issues in an ad-hoc manner. The argument model introduced above lends itself particularly well to nonparametric extensions such as the standard Hierarchical Dirichlet Processes (H</context>
<context position="14951" citStr="Teh et al., 2006" startWordPosition="2420" endWordPosition="2423">while allowing the model to capture language-specific preferences for the set of categories that can appear in this position. The HDP-CCG model In Bayesian models, multinomials are drawn from a corresponding ndimensional Dirichlet distribution. The Dirichlet Process (DP) generalizes the Dirichlet distribution to an infinite number of possible outcomes, allowing us to deal with a potentially infinite set of categories or words. DPs are defined in terms of a base distribution H that corresponds to the mean of the DP, and a concentration or shape parameter α. In a Hierarchical Dirichlet Process (Teh et al., 2006), there is a hierarchy of DPs, such that the base distribution of a DP at level n is a DP at level n − 1. The HDP-CCG (Figure 1) is a reformulation of the Argument Model introduced above in terms of Hierarchical Dirichlet Processes.5 At the heart of the model is a distribution over CCG categories. By combining a stick breaking process with a multinomial over categories we can define a DP over CCG 5An alternative HDP model for semantic parsing with CCG is proposed by Kwiatkowski et al. (2012). p(t|P) x 78 βY βL z ∞ y φY φL θT θC ∞ zi yi ci zL(i) zR(i) xL(i) xR(i) Because we are working with CCG</context>
<context position="19214" citStr="Teh et al., 2006" startWordPosition="3153" endWordPosition="3156">ent model is that it only requires a single distribution over categories for each binary tree. In contrast to similar proposals for CFGs (Liang et al., 2007), which impose no formal restrictions on the nonterminals X, Y, Z that can appear in a rewrite rule X -+ Y Z, this greatly simplifies the modeling problem (yielding effectively a model that is more akin to nonparametric HMMs), since it avoids the need to capture correlations be79 tween different base distributions for Y and Z. Variational Inference HDPs need to be estimated with approximate techniques. As an alternative to Gibbs sampling (Teh et al., 2006), which is exact, but typically very slow and has no clear convergence criteria, variational inference algorithms (Bishop, 2006; Blei and Jordan, 2004) estimate the parameters of a truncated model to maximize a lower bound of the likelihood of the actual model. This allows for factorization of the model and a training procedure analogous to the Inside-Outside algorithm (Lari and Young, 1991), allowing training to run very quickly and in a trivially parallelizable manner. To initialize the base DP’s stick weights, we follow the example of Kurihara et al. (2007) and use an MLE model initialized </context>
</contexts>
<marker>Teh, Jordan, Beal, Blei, 2006</marker>
<rawString>Yee-Whye Teh, Michael I Jordan, Matthew J Beal, and David M Blei. 2006. Hierarchical Dirichlet Processes. Journal of the American Statistical Association, 101(476):1566–1581.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yee-Whye Teh</author>
</authors>
<title>A Hierarchical Bayesian Language Model based on Pitman-Yor Processes.</title>
<date>2006</date>
<booktitle>In Proceedings of the 21st International Conference on Computational Linguistics and 44th Annual Meeting of the Association for Computational Linguistics,</booktitle>
<pages>985--992</pages>
<location>Sydney, Australia,</location>
<contexts>
<context position="13025" citStr="Teh, 2006" startWordPosition="2115" endWordPosition="2116">ut uniquely defines the two children of a parent node. We will see below that this greatly simplifies the development of non-parametric extensions. 5 HDP-CCG: a nonparametric model Simple generative models such as PCFGs or Bisk and Hockenmaier (2012b)’s CCG model are not robust in the face of sparsity, since they assign zero probability to any unseen event. Sparsity is a particular problem for formalisms like CCG that have a rich inventory of object types. Nonparametric Bayesian models, e.g. Dirichlet Processes (Teh, 2010) or their hierarchical variants (Teh et al., 2006) and generalizations (Teh, 2006) overcome this problem in a very elegant manner, and are used by many state-of-the-art grammar induction systems (Naseem et al., 2010; Blunsom and Cohn, 2010; Boonkwan and Steedman, 2011). They also impose a rich-getting-richer behavior that seems to be advantageous in many modeling applications. By contrast, Bisk and Hockenmaier (2012b) propose a weighted top-k scheme to address these issues in an ad-hoc manner. The argument model introduced above lends itself particularly well to nonparametric extensions such as the standard Hierarchical Dirichlet Processes (HDP). In this work the size of th</context>
</contexts>
<marker>Teh, 2006</marker>
<rawString>Yee-Whye Teh. 2006. A Hierarchical Bayesian Language Model based on Pitman-Yor Processes. In Proceedings of the 21st International Conference on Computational Linguistics and 44th Annual Meeting of the Association for Computational Linguistics, pages 985–992, Sydney, Australia, July.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yee-Whye Teh</author>
</authors>
<title>Dirichlet Process.</title>
<date>2010</date>
<booktitle>In Encyclopedia of Machine Learning,</booktitle>
<pages>280--287</pages>
<publisher>Springer.</publisher>
<contexts>
<context position="12943" citStr="Teh, 2010" startWordPosition="2103" endWordPosition="2104">Y) o.w. Argument Combinator Note that this model generates only one CCG category but uniquely defines the two children of a parent node. We will see below that this greatly simplifies the development of non-parametric extensions. 5 HDP-CCG: a nonparametric model Simple generative models such as PCFGs or Bisk and Hockenmaier (2012b)’s CCG model are not robust in the face of sparsity, since they assign zero probability to any unseen event. Sparsity is a particular problem for formalisms like CCG that have a rich inventory of object types. Nonparametric Bayesian models, e.g. Dirichlet Processes (Teh, 2010) or their hierarchical variants (Teh et al., 2006) and generalizations (Teh, 2006) overcome this problem in a very elegant manner, and are used by many state-of-the-art grammar induction systems (Naseem et al., 2010; Blunsom and Cohn, 2010; Boonkwan and Steedman, 2011). They also impose a rich-getting-richer behavior that seems to be advantageous in many modeling applications. By contrast, Bisk and Hockenmaier (2012b) propose a weighted top-k scheme to address these issues in an ad-hoc manner. The argument model introduced above lends itself particularly well to nonparametric extensions such a</context>
</contexts>
<marker>Teh, 2010</marker>
<rawString>Yee-Whye Teh. 2010. Dirichlet Process. In Encyclopedia of Machine Learning, pages 280–287. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kewei Tu</author>
</authors>
<title>Combining the Sparsity and Unambiguity Biases for Grammar Induction.</title>
<date>2012</date>
<booktitle>In NAACL HLT Workshop on Induction of Linguistic Structure,</booktitle>
<pages>105--110</pages>
<location>Montr´eal, Canada,</location>
<contexts>
<context position="25684" citStr="Tu, 2012" startWordPosition="4173" endWordPosition="4174">maier (2012a)’s CCG-based system (BH) to Cohn et al. (2010)’s reimplementation of Klein and Manning (2004)’s DMV model in a tree-substitution grammar framework (BC), as well as three other dependency based systems which either incorporate Naseem et al. (2010)’s rules in a deterministic fashion (Søgaard, 2012), rely on extensive tuning on 6Numbers are from personal correspondence with the organizers. The previously published numbers are not comparable to literature due to an error in the evaluation. http://wiki. cs.ox.ac.uk/InducingLinguisticStructure/ ResultsDepComparable the development set (Tu, 2012) or incorporate millions of additional tokens from Wikipedia to estimate model parameters (Marecek and Zabokrtsky, 2012). We ignore punctuation for all experiments reported in this paper, but since the training data (but not the evaluation) includes punctuation marks, participants were free to choose whether to include punctuation or ignore it. While BH is the only other system with directly interpretable linguistic output, we also include a direct comparison with BC, whose TSG representation is equally expressive to ours. Finally we present a row with the maximum performance among the other t</context>
</contexts>
<marker>Tu, 2012</marker>
<rawString>Kewei Tu. 2012. Combining the Sparsity and Unambiguity Biases for Grammar Induction. In NAACL HLT Workshop on Induction of Linguistic Structure, pages 105–110, Montr´eal, Canada, June.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>