<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000005">
<title confidence="0.986834">
Quantifiers in Dependency Tree Semantics
</title>
<author confidence="0.993334">
Leonardo Lesmo, Livio Robaldo, Jelle Gerbrandy
</author>
<affiliation confidence="0.836866">
Dipartimento di Informatica - Universit´a di Torino
</affiliation>
<email confidence="0.933967">
{lesmo,robaldo,gerbrand}@di. unito. it
</email>
<sectionHeader confidence="0.933066" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.732458833333333">
Dependency Tree Semantics (DTS) is an underspecified formalism for representing
quantifier scope ambiguities in natural language. DTS features a direct interface
with a Dependency grammar and an incremental, constraint-based disambiguation
mechanism. In this paper, we discuss the meaning of quantifier dependency in DTS
by translating its well formed structures into formulae of a Second Order Logic
augmented with Mostowskian generalized quantifiers.
</bodyText>
<sectionHeader confidence="0.991347" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.993113375">
Dependency Tree Semantics (DTS) is an underspecified formalism for deal-
ing with quantifier scope ambiguity. DTS tries to keep the advantages of
most common underspecification techniques: it has a straightforward syntax-
semantics interface with a Dependency Grammar, just as QLF has [1], and
it allows for monotonically adding constraints to take partial disambiguations
into account, just as in UDRT [12], MRS [3] or CLLS [4]. These features
have been presented in [7] and [8], whereas in [9] DTS is proposed as a
possible underspecified semantic structure of Meaning⇔Text Theory [10].
This paper discusses a third property of DTS in further depth: the possibility
to represent branching quantifier (BQ) readings. Branching quantification in
DTS has partially been discussed in [7] and [8], in which we compared DTS
with First Order Logic (FOL). However, FOL is limited in that it allows to
represent only standard quantifiers (∃ and V); in this paper we compare DTS
with the logic developed in [13] and [14], which is a fragment of Second Or-
der Logic which allows for a representation of branching quantification with
Generalized Quantifiers.
</bodyText>
<subsectionHeader confidence="0.695035">
1.1 Intuitions behind Dependency Tree Semantics
</subsectionHeader>
<bodyText confidence="0.999854">
The key idea of DTS is to specify quantifier scope by explicitly showing the
dependencies between involved (quantified) groups of entities, i.e. by imple-
menting a sort of ”Skolemization” in the underspecified representation. Well-
formed structures in DTS are based on a simple graph G that represents the
predicate-arguments relations, without any quantification. The nodes of G
are either predicates or discourse referents; each arc connects a predicate with
a discourse referent and is labelled with the number of the predicate argument
position. With each discourse referent we associate a quantifier (given by a
function QUANT from discourse referents to quantifiers) and its restriction,
which is given by a function RESTR that associates a subgraph of G to each
discourse referent. In (1), we show a first simple example
</bodyText>
<figure confidence="0.988303647058823">
(1) Two students study three theorems
Quant(x)= two Quant(y)= tree
stud’
1 1
x
1 2
study’
theor’
y
Restr(x)=
Restr(y)=
1
y
theor’
x
1
stud’
</figure>
<bodyText confidence="0.9992338">
The representation in (1) is still ambiguous; to disambiguate, we need to
specify how the quantifiers depend on each other. This is done by inserting
dotted arcs between discourse referents, named semdep arc. In figure 1.a and
fig 1.b two fully-specified representations of sentence (1) are given. Fig.1.a
shows the reading in which the quantifier ‘three’ depends on (has scope inside)
the quantifier ‘two’. In figure 1.b, the arc linking x to y specifies that the two
students depend on the theorems. In both interpretations, the wide-scope
quantifier is linked to a new node called Ctx – the context.
But DTS allows for very natural representation of a third reading of sentence
(1): in figure 1.c, both discourse referents are linked to the context. This is
the branching quantifier (BQ) reading. As we will see, the BQ reading is true
only in those models in which we can find a set of two students and a set of
three theorems, for which it holds that each student in the first set studies each
theorem in the second one. In NL, there are many cases in which the correct
truth conditions can be captured only via a BQ reading; in fact, it is easy to
add some context elements in the sentence in order to force the two involved
sets to be constant; for instance, in (2.i), the involved students and theorems
are explicitly mentioned in two appositions, while in (2.ii) the prepositional
modifier with my sister favours an interpretation in which three persons, two
friends of mine and my sister, went together to three same concerts.
</bodyText>
<figureCaption confidence="0.991115">
Fig. 1. The three readings of sentence (1)
</figureCaption>
<figure confidence="0.993043925925926">
a)
stud’
1 1
x
1 2
study’
Ctx
theor’
y
stud’
1 1
x
1 2
study’
Ctx
theor’
y
b)
c)
Ctx
study’
1 2
x
y
1 1
stud’
theor’
</figure>
<bodyText confidence="0.999683833333333">
Finally, even if there are not explicit syntactic elements forcing a BQ reading,
in many cases this is done by world knowledge; for example, in (2.iii), world
knowledge seems to render the reading in which two students have seen the
same three drug dealers the most salient; in fact, the presence of drug-dealers
in front of a school is (fortunately) a rare event and this induces to prefer the
reading minimizing the number of involved drug dealers.
</bodyText>
<listItem confidence="0.9379024">
(2) (i) Two students, John and Jack, study three theorems: the first three
of the book.
(ii) Two friends of mine went to three concerts with my sister.
(iii) Two students of mine have seen three drug dealers in front of the
school.
</listItem>
<bodyText confidence="0.9915463">
Not all possible configurations of semdep arcs are allowed. For instance, a
well-formed DTS cannot contain cycling paths, which would correspond to a
reading in which two sets of entities depend on each other, which is clearly
absurd. Furthermore, there are constraints to reduce the available readings
to those admitted in NL. In this paper, we will focus on the expressivity of
the general formalism, and provide a precise definition of the meaning of all
configurations that respect a minimal set of syntactic constraints, and abstract
from the question whether they correspond to an actual reading in NL. In other
words, in DTS the set of logical admitted readings is kept separate from the
subset of readings admitted in NL, and this paper focus on the former.
</bodyText>
<subsectionHeader confidence="0.565917">
1.2 Formalisation: Syntax of DTS
</subsectionHeader>
<bodyText confidence="0.891405310344828">
A well-formed structure (wfs) in DTS is a Scoped Dependency Graph (SDG)
as defined below. We take as given a set of predicates pred and a set of
discourse referents D.
Definition 1.1 [Flat Dependency Graphs (FDG)]
A Flat Dependency Graph is a tuple (N, L, A, Dom, f) s.t.:
- N is a set of nodes N, n2, ... , nk}.
- L is a set of labels {l1, l2, ..., lm}; in fig.1, L-11, 2}.
- Dom - pred U D is a set domain objects: predicates and discourse referents
- f is a function f : N H Dom, specifying the node referent, i.e. the domain
object with which the node is associated. In the following, whenever f(n) E
X, we will say that node n is of type X.
- A is a set of arcs. An arc is a triple (ns, nd, l), where ns, nd E N, ns is of
type pred, nd is of type D and l E L.
Without going into further details, we stipulate that Gf is a connected acyclic
graph such that each node of type pred has one node of type D for each of its
places. Note that there can be two different nodes u and v s.t. f(u)=f(v),
i.e. the nodes in N can be seen as occurrences of symbols from Dom.
Definition 1.2 [Scoped Dependency Graph (SDG)]
A Scoped Dependency Graph is a tuple (Gf, ctx, Q, quant, restr, SemDep) s.t.:
- Gf = hN, L, A, Dom, fi is an FDG.
- ctx is a special element called the context.
- Qis a set of 2-place Mostowskian quantifiers {every, most, two, . . .} 1
- quant is a total function ND 7→ Q, where ND ⊆ N are the nodes of type D
- restr is a function assigning to each d ∈ ND its restriction, which is a sub-
graph of Gf.
- SemDep is a relation ND × (ND ∪ {{ctx}}).
When SemDep(d, d′), we say that d depends on d′. Note that a discourse ref-
erent can depend on more than one other discourse referent. The dependence
relation needs to satisfy the following constraints:
</bodyText>
<listItem confidence="0.9292864">
• The transitive closure of SemDep is a partial order on all discourse referents
and ctx, with ctx as its maximal element.
• Let d be a discourse referent, and let R(d) be the smallest set that contains
d, and for which it holds that if d′ is in R(d) and d″occurs in the restriction
of d′, then also d″∈ D. It must hold that:
</listItem>
<bodyText confidence="0.8882805">
· If d1 ∈ R(d), d2 ∈6 R(d), and d1 depends on d2, then also d depends on d2
· If d1 ∈ R(d), d2 ∈6 R(d), and d2 depends on d1, then also d depends on d1
These last two constraints serve to exclude certain dependency relations that
are ‘logically impossible’, and make sure that, for example, a sentence like
“Most representatives of a company took every sample” does not get a reading
in which ‘a’ depends on (only) ‘every’ and ‘every’ depends (only) on ‘most’.
</bodyText>
<sectionHeader confidence="0.811021" genericHeader="method">
2 Branching quantification
</sectionHeader>
<bodyText confidence="0.976133233333333">
Branching quantification was introduced by Henkin [5] in the context of FOL;
Hintikka [6] showed that it can occur also in NL. A great step toward the
definition of a model-theoretic schema for BQ was made by Barwise [2] who
merged Hintikka’s BQ account with the theory of Generalized Quantifiers.
Barwise’s idea was that the truth-conditions of BQ readings are connected
with the monotonicity of the involved quantifiers. He claimed that there is
no uniform schema for BQ: the formulae associated to sentences featuring all
monotone increasing (M↑) quantifiers are different from those associated to
sentences featuring all monotone decreasing (M↓) quantifiers. According to
Barwise, sentences with mixed quantifiers (some M↑ and some M↓) make no
1 A 2-place Mostowskian Quantifier [11] (see also [13]) is a symbol Q such that, if x is an
individual variable and Ψ, Φ are formulae then Qx(Ψ, Φ) is also a formula. Semantically, Q
denotes, in every model M with universe A, a function q which takes in input two subsets B
and C of A and returns a truth-value. Mostowskian Quantifiers are cardinality quantifiers,
in the sense that q(B, C) depends only on the cardinalities of the sets (B ∩ C), (B \ C),
(C \ B) and (A \ (B ∪ C)). Some examples are
· kAllx(P1(x),P2(x))kM = true iff |(kP1(x) ∧ ¬P2(x)kM) |= 0
· kFewx(P1(x),P2(x))kM = true iff |(kP1(x) ∧ P2(x)kM) |&gt; η
sense from a linguistic point of view.
On the other hand, Sher [13], [14] observed that since the semantics of
linearly ordered quantification is provided regardless to monotonicity, there
seems to be no methodological reason for imposing further constraints in case
of partially ordered quantification. In other words, even if readings from NL
are not available, this should not exclude their logical interpretation.
Sher specified the semantics of BQ on the basis of a precise definition of
the involved groups, according to so-called maximality conditions; roughly,
her claim is that the interpretation of a BQ reading with quantifiers of any
type corresponds to the one of Barwise for M↑ quantifiers augmented with
a maximality condition requiring that the involved sets are maximal with
respect to the body of the formula. Consider the two following sentences:
</bodyText>
<listItem confidence="0.9963795">
(3) (i) Most of the dots and most of the stars are all connected by lines.
(ii) Few of the dots and few of the stars are all connected by lines.
</listItem>
<bodyText confidence="0.980044">
In Sher’s logic (let us name it L0) sentences in (3) are associated with formulas
of the following form:
</bodyText>
<equation confidence="0.990329">
(4) ∃P1, P2[ C1 : Q1x(dot(x), P1(x))∧
C2 : Q2y(star(y), P2(y))∧
IN : ∀xy[(P1(x) ∧ P2(y)) → conn(x, y)]∧
Max(hP1, P2i, IN) ]
</equation>
<bodyText confidence="0.999746285714286">
where Q1 and Q2 are the Mostowskian quantifiers corresponding to the deter-
miners in our example: Q1=Q2=Most for (3.i); and Q1=Q2=Few for (3.ii).
The symbols C1, C2, IN are labels on the subformulae and Max(hP1, P2i, IN)
is an abbreviation for a maximality condition that states that two sets P1 and
P2 are maximal with respect to the formula with label IN, in the sense that
there are no strict supersets of P1 and P2 that satisfy IN. Formally, the max-
imality condition in (4) is the following formula:
</bodyText>
<equation confidence="0.99974325">
Max(hP1, P2i, IN) ⇔
∀P′1, P′2[ ∀xy[ (P1(x)∧ P2(y)) → (P′1(x) ∧ P′2(y))∧
(P′1(x) ∧ P′2(y)) → conn(x, y) ] →
∀xy[ (P′1(x) ∧ P′2(y)) → (P1(x)∧ P2(y)) ]]
</equation>
<bodyText confidence="0.999626875">
Sher generalizes the schema of (4), so that it applies to any partially ordered
set of arbitrary quantifiers. To achieve this, it is necessary to existentially
quantify n-ary generalized Skolem functions HZ rather than simple sets PZ,
and to assert maximality conditions also on the subformulae with label CZ.
Here, an n-ary Skolem function is just an n + 1-ary relation H – we will
write H(x1, ... xn+1) if x1 ... xn+1 stand in the relation H, but also write
H(x1 ... xn) for the set of objects xn+1 s.t. H(x1, ... xn+1). Consider now a
branching reading such as in the following sentence:
</bodyText>
<listItem confidence="0.571313">
(5) Few men inserted a coin in three coffee machines.
</listItem>
<table confidence="0.884364818181818">
Fewx(man’(x)) ❅
❅
�
�
T hreey(CoffeeMach’(y))
Az(Coin’(z)) Inserted’(x, z, y)
=df E]Hx, Hy, Hz[ Cx: Fewx(man’(x), Hx(x)) &amp;
Cy: Threey(CoffeeMach’(y), Hy(y)) &amp;
Cz: bxy[(Hx(x)∧Hy(y))—* Az(coin’(z), Hz(x, y))] &amp;
IN: bxyz[Hz(x, y, z)—* inserted’(x, y, z)] &amp;
Max((Hx, Hy), Cz) &amp; Max((Hz), IN) ]
</table>
<bodyText confidence="0.999910555555556">
In this reading, the quantifier A depends on both Three and Few: there can be
a different coin for every pair of a man and a coffee machine. This is reflected
by the fact that Hz, the Skolem function associated with the quantifier A, is a
2-ary function, while Hx, Hy are 0-ary Skolem functions (that is, predicates).
The formula states that we have to find witnesses Hx, Hy and Hz such that
Hz corresponds to the extension of inserted’, and Hx and Hy are maximal
sets of individuals x and y such that the set of objects z inserted by x in
y, Hz(x, y, z), includes at least one coin; Hx is a set of a ”few men” and Hy
contains ”three coffee machines”. See [14] for the formal details.
</bodyText>
<sectionHeader confidence="0.987316" genericHeader="method">
3 Nested Quantification
</sectionHeader>
<bodyText confidence="0.988824">
A limitation of Sher’s logic is that it does not handle the case in which one
quantifier occurs in the syntactical restriction of another quantifier. Consider:
</bodyText>
<figure confidence="0.99416425">
(6) Two representatives of three African countries arrive.
Restr(x)=
Quant(y)= tree
Quant(x)= two
arrive
1
1
1
x
rep’ of’
1
2
y
af_c’
of’
rep’
2
y
x
1 1
y
1
af_c’
Restr(y)=
</figure>
<bodyText confidence="0.9775978">
In this example, the quantifier Three occurs in the syntactic restriction of
Two. This corresponds to the fact that the discourse referent y occurs in the
graph RESTR(x). This type of reading cannot be directly represented in
Sher’s logic. Therefore, we propose to extend her definitions to accommodate
for these cases as well. Lack of space does not permit us to state the precise
definitions; we will give two examples instead which should illustrate how the
definitions work. Before discussing the three possible disambiguations of (6),
we introduce a new abbreviation to increase readability.
If © is a well formed formula, x1 ... xn a sequence of discourse referents, and
S1, ... , Sn a sequence of predicates, we define:
</bodyText>
<equation confidence="0.654033666666667">
(S1, ... , Sn) C ©[x1 ... xn] �?
max
Max((S1, ... , Sn), bx1 ... xn[(S1(x1) ∧ ... ∧ Sn(xn)) —* ©])
</equation>
<bodyText confidence="0.882807">
We will omit the reference to the variables x1 ... xn in the notation when this
does not lead to confusion. By using C
by the following equivalent max
</bodyText>
<table confidence="0.3471442">
E]Hx, Hy, Hz[ Fewx(man’(x), Hx(x)) &amp; Everyy(CoffeeMach’(y), Hy(y)) &amp;
(Hx, Hy)C [ Az(coin’(z), Hz(x, y, z))&amp;
max
(Hz(x, y))C inserted’(x, y, z) ] ]
max
</table>
<bodyText confidence="0.884804666666667">
For representing the restriction of quantifiers in the logic, in addition to the
Skolem functions Hx that represent the body of the quantifiers, we introduce
restriction sets Tx. The three readings of (6) can now be represented as:
</bodyText>
<figure confidence="0.966157233333333">
(arrive’(x)) &amp;
E]Hx, Hy, Tx, Ty[ Twox(Tx(x), Hx(x))&amp; (Hx)C
max
(Ty(x))Cmax (af−c’(y)) &amp;
(Hy(x))C max (repr of’(x,y))
]]
(Tx)C [Threey(Ty(x, y), Hy(x, y)) &amp;
max
Ctx
X
Y
E]Hx, Hy, Tx, Ty[ Threey(Ty(y), Hy(y)) &amp; (Ty)Cmax (af−c’(y)) &amp;
[Twox(Tx(y, x), Hx(y, x)) &amp;
(Tx(y))C (repr of’(x,y)) &amp;
max
(Hx(y))C max (arrive’(x))
]]
Ctx
X
Y
(Hy)C
max
E]Hx, Hy, Tx,Ty[ Twox(Tx(x), Hx(x)) &amp; Threey(Ty(y), Hy(y)) &amp;
(Tx, Hy)C (repr of’(x,y)) &amp; (Ty) C (af−c’(y)) &amp;
max max
(Hx)C max (arrive’(x))
]
Ctx
X
Y
</figure>
<bodyText confidence="0.995819">
, the formula in (5) can be replaced
Let us shortly discuss each of these readings.
In the first reading, y depends on x, which is reflected in the fact that Ty and
Hy are unary Skolem functions whose values depend on the value for x. The
restriction set of ’three’, Ψy(x), is (for each x) the set of all African countries,
while Hy(x) is the set of objects represented by x. Therefore, the restriction
set of ‘two’, Ψx, is a maximal set of individuals x that represent three African
countries. Two of these individuals must be in Hx – the set of those that
arrive.
In the second reading, x depends on y. The set Ψy consists of all African
countries. The set Hy must contain three of these, and it is required that for
each element y in Hy there are two individuals in the set of all its representa-
tives Ψx(y) that are in Hx(y), which consists of all individuals that arrive.
The third formula represents the branching reading of the sentence, in which
the two discourse referents do not depend on each other. This formula states
that there are sets Ψx and Hy such that each individual in Ψx represents all
elements from Hy (this is expressed by the maximality condition on the pair
(Ψx, Hy)), and for which it holds that Hy contains three African countries,
and that two of the representatives from Ψx must arrive. In the following, we
report a last complex example:
(7) Everyx teacher failed twoy students that studied less than halfz of the
topics in thew program.
The following DTS represents a reading of (7) in which the discourse referent
w depends on both y and z, and y and z depend on x.
This DTS gets the translation reported below; in this interpretation, the two
students and the program depend on a teacher, while the set of topics depends
both on a program and on a student. In the formula, the pair of students
associated to a teacher x ∈ Hx has to belong to the set Ψy, i.e. the set of
students y such that the set of things studied by y, i.e. Hz(x, y, w), contains
less than half elements of Ψz, i.e. the set of topic in Hw(x), i.e. the program
of x.
</bodyText>
<figure confidence="0.995829904761905">
failed
teacher
x
1
1 2
stud
y
1
study
1
2
1 1
progr topic
1
2
z
w
of’
of’
topic
1 1
z
2
w
x
1
teacher
Restr(y)=
w
1
progr
Quant(x)= ∀
Quant(y)= ∃
Quant(z)= &lt; z
Quant(w)= the
stud
study
2
z
1 1
y
Restr(x)=
Restr(z)=
Restr(w)=
y
Ctx
x
w
z
∃Hx, Hy, Hz, Hw, Tx, Ty, Tz, Tw[
Everyx(Tx(x), Hx(x)) &amp; {Tx}⊆ (teacher’(x)) &amp;
max
{Hx}⊆ max [ Thew(Tw(x, w), Hw(x, w)) &amp; {Tw(x)}⊆
max
(progr’(w)) &amp;
Twoy(Ty(x, y), Hy(x, y))] &amp; {Hy(x)}⊆ (failed’(x, y)) &amp;
max
{Ty(x), Hw(x)}⊆ [ Lthz(Tz(x, y, w, z), Hz(x, y, w, z)) &amp;
max
{Tz(x, y, w)}⊆ (topic’(z)∧of’(z, w)) &amp;
max
{Hz(x, y, w)}⊆ (stud’(y)∧study’(y, z))]]]
max
</figure>
<sectionHeader confidence="0.817436" genericHeader="conclusions">
4 Conclusions and further works
</sectionHeader>
<bodyText confidence="0.999621916666667">
In this paper, a comparison between Dependency Tree Semantics and Sher’s
work on Branching Quantification and Generalized Quantifiers has been pre-
sented. In particular, we have shown how disambiguated DTS structures can
be related to formulae of an extension of the formalism from [14] to represent
branching quantification. This provides a way to model-theoretically inter-
pret disambiguated DTS structures. Concerning further work, one of the next
steps in research on DTS will be extending its expressivity in order to deal
with cumulativity, which is a topic that has received very little attention in re-
cent studies on underspecification. Cumulative readings arise from a different
kind of branching quantification, as argued in [13], so the step for including
them is more natural in DTS than in other underspecified logics that do not
take BQ into account.
</bodyText>
<sectionHeader confidence="0.998813" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.998868096774193">
[1] Alshawi, H., editor, “The Core Language Engine,” Mit Press, Cambridge, MA,
1992.
[2] Barwise, J., On branching quantifiers in english, The Journal of Philosophical
Logic (1979), pp. 47–80.
[3] Copestake, A., D. Flickinger and I. Sag, Minimal recursion semantics. an
introduction, Technical report, Manuscript, Stanford University (1999).
[4] Egg, M., A. Koller and J. Niehren, The constraint language for lambda
structures, J. of Logic, Language and Information 10 (2001), pp. 457–485.
[5] Henkin, L., Some remarks on infinitely long formulas, in: Finitistic methods,
Proc. Symphosium of Foundations Math, Warsaw, 1961, pp. 167–183.
[6] Hintikka, J., Quantifiers vs quantification theory, Dialectica (1973), pp. 329–
358.
[7] Lesmo, L. and L. Robaldo, Dependency tree semantics and underspecification,
in: Proc. Int. Conf. On Natural language processing (ICON2004), Hyderabad,
India, 2004.
[8] Lesmo, L. and L. Robaldo, From dependency tree semantics to fol, in: Proc. 6th
Workshop on Computational Semantics (IWCS-6), Tilburg, 2005, pp. 384–386.
[9] Lesmo, L. and L. Robaldo, Underspecification of quantifier scope in mtt, in:
Proc. 2th Int.Conf. on Meaning Text Theory, Moscow, 2005.
[10] Melcuk, I., Semantics and the lexicon in modern linguistics., in: A. Gelbukh,
editor, In Proc. of the 1st International Conference on Intelligent Text
Processing and Computational Linguistics (CICLing), 2000, pp. 6–18.
URL www.CICLing.com
[11] Mostowski, A., On a generalization of quantifiers., Fundamenta Mathematicae
44 (1957), pp. 12–36.
[12] Reyle, U., Dealing with ambiguities by underspecification: Construction,
representation and deduction, Journal of Semantics (1993), pp. 123–179.
[13] Sher, G., Ways of branching quantifiers, Linguistics and Philosophy (1990),
pp. 393–422.
[14] Sher, G., Partially-ordered (branching) generalized quantifiers: a general
definition, The Journal of Philosophical Logic (1997), pp. 1–43.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.370083">
<title confidence="0.998768">Quantifiers in Dependency Tree Semantics</title>
<author confidence="0.996033">Leonardo Lesmo</author>
<author confidence="0.996033">Livio Robaldo</author>
<author confidence="0.996033">Jelle Gerbrandy</author>
<affiliation confidence="0.769452">Dipartimento di Informatica - Universit´a di</affiliation>
<abstract confidence="0.92725325">unito. it Abstract Dependency Tree Semantics (DTS) is an underspecified formalism for representing quantifier scope ambiguities in natural language. DTS features a direct interface with a Dependency grammar and an incremental, constraint-based disambiguation mechanism. In this paper, we discuss the meaning of quantifier dependency in DTS by translating its well formed structures into formulae of a Second Order Logic augmented with Mostowskian generalized quantifiers.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<date>1992</date>
<booktitle>The Core Language Engine,”</booktitle>
<editor>Alshawi, H., editor,</editor>
<publisher>Mit Press,</publisher>
<location>Cambridge, MA,</location>
<contexts>
<context position="940" citStr="[1]" startWordPosition="126" endWordPosition="126">ct interface with a Dependency grammar and an incremental, constraint-based disambiguation mechanism. In this paper, we discuss the meaning of quantifier dependency in DTS by translating its well formed structures into formulae of a Second Order Logic augmented with Mostowskian generalized quantifiers. 1 Introduction Dependency Tree Semantics (DTS) is an underspecified formalism for dealing with quantifier scope ambiguity. DTS tries to keep the advantages of most common underspecification techniques: it has a straightforward syntaxsemantics interface with a Dependency Grammar, just as QLF has [1], and it allows for monotonically adding constraints to take partial disambiguations into account, just as in UDRT [12], MRS [3] or CLLS [4]. These features have been presented in [7] and [8], whereas in [9] DTS is proposed as a possible underspecified semantic structure of Meaning⇔Text Theory [10]. This paper discusses a third property of DTS in further depth: the possibility to represent branching quantifier (BQ) readings. Branching quantification in DTS has partially been discussed in [7] and [8], in which we compared DTS with First Order Logic (FOL). However, FOL is limited in that it allo</context>
</contexts>
<marker>[1]</marker>
<rawString>Alshawi, H., editor, “The Core Language Engine,” Mit Press, Cambridge, MA, 1992.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Barwise</author>
</authors>
<title>On branching quantifiers in english,</title>
<date>1979</date>
<journal>The Journal of Philosophical Logic</journal>
<pages>47--80</pages>
<contexts>
<context position="8786" citStr="[2]" startWordPosition="1544" endWordPosition="1544">nd d2 depends on d1, then also d depends on d1 These last two constraints serve to exclude certain dependency relations that are ‘logically impossible’, and make sure that, for example, a sentence like “Most representatives of a company took every sample” does not get a reading in which ‘a’ depends on (only) ‘every’ and ‘every’ depends (only) on ‘most’. 2 Branching quantification Branching quantification was introduced by Henkin [5] in the context of FOL; Hintikka [6] showed that it can occur also in NL. A great step toward the definition of a model-theoretic schema for BQ was made by Barwise [2] who merged Hintikka’s BQ account with the theory of Generalized Quantifiers. Barwise’s idea was that the truth-conditions of BQ readings are connected with the monotonicity of the involved quantifiers. He claimed that there is no uniform schema for BQ: the formulae associated to sentences featuring all monotone increasing (M↑) quantifiers are different from those associated to sentences featuring all monotone decreasing (M↓) quantifiers. According to Barwise, sentences with mixed quantifiers (some M↑ and some M↓) make no 1 A 2-place Mostowskian Quantifier [11] (see also [13]) is a symbol Q su</context>
</contexts>
<marker>[2]</marker>
<rawString>Barwise, J., On branching quantifiers in english, The Journal of Philosophical Logic (1979), pp. 47–80.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Copestake</author>
<author>D Flickinger</author>
<author>I Sag</author>
</authors>
<title>Minimal recursion semantics. an introduction,</title>
<date>1999</date>
<tech>Technical report, Manuscript,</tech>
<institution>Stanford University</institution>
<contexts>
<context position="1068" citStr="[3]" startWordPosition="146" endWordPosition="146">the meaning of quantifier dependency in DTS by translating its well formed structures into formulae of a Second Order Logic augmented with Mostowskian generalized quantifiers. 1 Introduction Dependency Tree Semantics (DTS) is an underspecified formalism for dealing with quantifier scope ambiguity. DTS tries to keep the advantages of most common underspecification techniques: it has a straightforward syntaxsemantics interface with a Dependency Grammar, just as QLF has [1], and it allows for monotonically adding constraints to take partial disambiguations into account, just as in UDRT [12], MRS [3] or CLLS [4]. These features have been presented in [7] and [8], whereas in [9] DTS is proposed as a possible underspecified semantic structure of Meaning⇔Text Theory [10]. This paper discusses a third property of DTS in further depth: the possibility to represent branching quantifier (BQ) readings. Branching quantification in DTS has partially been discussed in [7] and [8], in which we compared DTS with First Order Logic (FOL). However, FOL is limited in that it allows to represent only standard quantifiers (∃ and V); in this paper we compare DTS with the logic developed in [13] and [14], whi</context>
</contexts>
<marker>[3]</marker>
<rawString>Copestake, A., D. Flickinger and I. Sag, Minimal recursion semantics. an introduction, Technical report, Manuscript, Stanford University (1999).</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Egg</author>
<author>A Koller</author>
<author>J Niehren</author>
</authors>
<title>The constraint language for lambda structures,</title>
<date>2001</date>
<journal>J. of Logic, Language and Information</journal>
<volume>10</volume>
<pages>457--485</pages>
<contexts>
<context position="1080" citStr="[4]" startWordPosition="149" endWordPosition="149">of quantifier dependency in DTS by translating its well formed structures into formulae of a Second Order Logic augmented with Mostowskian generalized quantifiers. 1 Introduction Dependency Tree Semantics (DTS) is an underspecified formalism for dealing with quantifier scope ambiguity. DTS tries to keep the advantages of most common underspecification techniques: it has a straightforward syntaxsemantics interface with a Dependency Grammar, just as QLF has [1], and it allows for monotonically adding constraints to take partial disambiguations into account, just as in UDRT [12], MRS [3] or CLLS [4]. These features have been presented in [7] and [8], whereas in [9] DTS is proposed as a possible underspecified semantic structure of Meaning⇔Text Theory [10]. This paper discusses a third property of DTS in further depth: the possibility to represent branching quantifier (BQ) readings. Branching quantification in DTS has partially been discussed in [7] and [8], in which we compared DTS with First Order Logic (FOL). However, FOL is limited in that it allows to represent only standard quantifiers (∃ and V); in this paper we compare DTS with the logic developed in [13] and [14], which is a frag</context>
</contexts>
<marker>[4]</marker>
<rawString>Egg, M., A. Koller and J. Niehren, The constraint language for lambda structures, J. of Logic, Language and Information 10 (2001), pp. 457–485.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Henkin</author>
</authors>
<title>Some remarks on infinitely long formulas, in: Finitistic methods,</title>
<date>1961</date>
<booktitle>Proc. Symphosium of Foundations Math,</booktitle>
<pages>167--183</pages>
<location>Warsaw,</location>
<contexts>
<context position="8619" citStr="[5]" startWordPosition="1512" endWordPosition="1512">in the restriction of d′, then also d″∈ D. It must hold that: · If d1 ∈ R(d), d2 ∈6 R(d), and d1 depends on d2, then also d depends on d2 · If d1 ∈ R(d), d2 ∈6 R(d), and d2 depends on d1, then also d depends on d1 These last two constraints serve to exclude certain dependency relations that are ‘logically impossible’, and make sure that, for example, a sentence like “Most representatives of a company took every sample” does not get a reading in which ‘a’ depends on (only) ‘every’ and ‘every’ depends (only) on ‘most’. 2 Branching quantification Branching quantification was introduced by Henkin [5] in the context of FOL; Hintikka [6] showed that it can occur also in NL. A great step toward the definition of a model-theoretic schema for BQ was made by Barwise [2] who merged Hintikka’s BQ account with the theory of Generalized Quantifiers. Barwise’s idea was that the truth-conditions of BQ readings are connected with the monotonicity of the involved quantifiers. He claimed that there is no uniform schema for BQ: the formulae associated to sentences featuring all monotone increasing (M↑) quantifiers are different from those associated to sentences featuring all monotone decreasing (M↓) qua</context>
</contexts>
<marker>[5]</marker>
<rawString>Henkin, L., Some remarks on infinitely long formulas, in: Finitistic methods, Proc. Symphosium of Foundations Math, Warsaw, 1961, pp. 167–183.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Hintikka</author>
</authors>
<title>Quantifiers vs quantification theory,</title>
<date>1973</date>
<pages>329--358</pages>
<location>Dialectica</location>
<contexts>
<context position="8655" citStr="[6]" startWordPosition="1519" endWordPosition="1519">d″∈ D. It must hold that: · If d1 ∈ R(d), d2 ∈6 R(d), and d1 depends on d2, then also d depends on d2 · If d1 ∈ R(d), d2 ∈6 R(d), and d2 depends on d1, then also d depends on d1 These last two constraints serve to exclude certain dependency relations that are ‘logically impossible’, and make sure that, for example, a sentence like “Most representatives of a company took every sample” does not get a reading in which ‘a’ depends on (only) ‘every’ and ‘every’ depends (only) on ‘most’. 2 Branching quantification Branching quantification was introduced by Henkin [5] in the context of FOL; Hintikka [6] showed that it can occur also in NL. A great step toward the definition of a model-theoretic schema for BQ was made by Barwise [2] who merged Hintikka’s BQ account with the theory of Generalized Quantifiers. Barwise’s idea was that the truth-conditions of BQ readings are connected with the monotonicity of the involved quantifiers. He claimed that there is no uniform schema for BQ: the formulae associated to sentences featuring all monotone increasing (M↑) quantifiers are different from those associated to sentences featuring all monotone decreasing (M↓) quantifiers. According to Barwise, sent</context>
</contexts>
<marker>[6]</marker>
<rawString>Hintikka, J., Quantifiers vs quantification theory, Dialectica (1973), pp. 329– 358.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Lesmo</author>
<author>L Robaldo</author>
</authors>
<title>Dependency tree semantics and underspecification, in:</title>
<date>2004</date>
<booktitle>Proc. Int. Conf. On Natural language processing (ICON2004),</booktitle>
<location>Hyderabad, India,</location>
<contexts>
<context position="1123" citStr="[7]" startWordPosition="156" endWordPosition="156">ing its well formed structures into formulae of a Second Order Logic augmented with Mostowskian generalized quantifiers. 1 Introduction Dependency Tree Semantics (DTS) is an underspecified formalism for dealing with quantifier scope ambiguity. DTS tries to keep the advantages of most common underspecification techniques: it has a straightforward syntaxsemantics interface with a Dependency Grammar, just as QLF has [1], and it allows for monotonically adding constraints to take partial disambiguations into account, just as in UDRT [12], MRS [3] or CLLS [4]. These features have been presented in [7] and [8], whereas in [9] DTS is proposed as a possible underspecified semantic structure of Meaning⇔Text Theory [10]. This paper discusses a third property of DTS in further depth: the possibility to represent branching quantifier (BQ) readings. Branching quantification in DTS has partially been discussed in [7] and [8], in which we compared DTS with First Order Logic (FOL). However, FOL is limited in that it allows to represent only standard quantifiers (∃ and V); in this paper we compare DTS with the logic developed in [13] and [14], which is a fragment of Second Order Logic which allows for</context>
</contexts>
<marker>[7]</marker>
<rawString>Lesmo, L. and L. Robaldo, Dependency tree semantics and underspecification, in: Proc. Int. Conf. On Natural language processing (ICON2004), Hyderabad, India, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Lesmo</author>
<author>L Robaldo</author>
</authors>
<title>From dependency tree semantics to fol, in:</title>
<date>2005</date>
<booktitle>Proc. 6th Workshop on Computational Semantics (IWCS-6),</booktitle>
<pages>384--386</pages>
<location>Tilburg,</location>
<contexts>
<context position="1131" citStr="[8]" startWordPosition="158" endWordPosition="158">well formed structures into formulae of a Second Order Logic augmented with Mostowskian generalized quantifiers. 1 Introduction Dependency Tree Semantics (DTS) is an underspecified formalism for dealing with quantifier scope ambiguity. DTS tries to keep the advantages of most common underspecification techniques: it has a straightforward syntaxsemantics interface with a Dependency Grammar, just as QLF has [1], and it allows for monotonically adding constraints to take partial disambiguations into account, just as in UDRT [12], MRS [3] or CLLS [4]. These features have been presented in [7] and [8], whereas in [9] DTS is proposed as a possible underspecified semantic structure of Meaning⇔Text Theory [10]. This paper discusses a third property of DTS in further depth: the possibility to represent branching quantifier (BQ) readings. Branching quantification in DTS has partially been discussed in [7] and [8], in which we compared DTS with First Order Logic (FOL). However, FOL is limited in that it allows to represent only standard quantifiers (∃ and V); in this paper we compare DTS with the logic developed in [13] and [14], which is a fragment of Second Order Logic which allows for a repre</context>
</contexts>
<marker>[8]</marker>
<rawString>Lesmo, L. and L. Robaldo, From dependency tree semantics to fol, in: Proc. 6th Workshop on Computational Semantics (IWCS-6), Tilburg, 2005, pp. 384–386.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Lesmo</author>
<author>L Robaldo</author>
</authors>
<title>Underspecification of quantifier scope in mtt, in:</title>
<date>2005</date>
<booktitle>Proc. 2th Int.Conf. on Meaning Text Theory,</booktitle>
<location>Moscow,</location>
<contexts>
<context position="1147" citStr="[9]" startWordPosition="161" endWordPosition="161">ctures into formulae of a Second Order Logic augmented with Mostowskian generalized quantifiers. 1 Introduction Dependency Tree Semantics (DTS) is an underspecified formalism for dealing with quantifier scope ambiguity. DTS tries to keep the advantages of most common underspecification techniques: it has a straightforward syntaxsemantics interface with a Dependency Grammar, just as QLF has [1], and it allows for monotonically adding constraints to take partial disambiguations into account, just as in UDRT [12], MRS [3] or CLLS [4]. These features have been presented in [7] and [8], whereas in [9] DTS is proposed as a possible underspecified semantic structure of Meaning⇔Text Theory [10]. This paper discusses a third property of DTS in further depth: the possibility to represent branching quantifier (BQ) readings. Branching quantification in DTS has partially been discussed in [7] and [8], in which we compared DTS with First Order Logic (FOL). However, FOL is limited in that it allows to represent only standard quantifiers (∃ and V); in this paper we compare DTS with the logic developed in [13] and [14], which is a fragment of Second Order Logic which allows for a representation of bra</context>
</contexts>
<marker>[9]</marker>
<rawString>Lesmo, L. and L. Robaldo, Underspecification of quantifier scope in mtt, in: Proc. 2th Int.Conf. on Meaning Text Theory, Moscow, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>I Melcuk</author>
</authors>
<title>Semantics and the lexicon in modern linguistics.,</title>
<date>2000</date>
<booktitle>In Proc. of the 1st International Conference on Intelligent Text Processing and Computational Linguistics (CICLing),</booktitle>
<pages>6--18</pages>
<editor>in: A. Gelbukh, editor,</editor>
<note>URL www.CICLing.com</note>
<contexts>
<context position="1239" citStr="[10]" startWordPosition="174" endWordPosition="174">iers. 1 Introduction Dependency Tree Semantics (DTS) is an underspecified formalism for dealing with quantifier scope ambiguity. DTS tries to keep the advantages of most common underspecification techniques: it has a straightforward syntaxsemantics interface with a Dependency Grammar, just as QLF has [1], and it allows for monotonically adding constraints to take partial disambiguations into account, just as in UDRT [12], MRS [3] or CLLS [4]. These features have been presented in [7] and [8], whereas in [9] DTS is proposed as a possible underspecified semantic structure of Meaning⇔Text Theory [10]. This paper discusses a third property of DTS in further depth: the possibility to represent branching quantifier (BQ) readings. Branching quantification in DTS has partially been discussed in [7] and [8], in which we compared DTS with First Order Logic (FOL). However, FOL is limited in that it allows to represent only standard quantifiers (∃ and V); in this paper we compare DTS with the logic developed in [13] and [14], which is a fragment of Second Order Logic which allows for a representation of branching quantification with Generalized Quantifiers. 1.1 Intuitions behind Dependency Tree Se</context>
</contexts>
<marker>[10]</marker>
<rawString>Melcuk, I., Semantics and the lexicon in modern linguistics., in: A. Gelbukh, editor, In Proc. of the 1st International Conference on Intelligent Text Processing and Computational Linguistics (CICLing), 2000, pp. 6–18. URL www.CICLing.com</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Mostowski</author>
</authors>
<title>On a generalization of quantifiers.,</title>
<date>1957</date>
<journal>Fundamenta Mathematicae</journal>
<volume>44</volume>
<pages>12--36</pages>
<contexts>
<context position="9353" citStr="[11]" startWordPosition="1627" endWordPosition="1627">schema for BQ was made by Barwise [2] who merged Hintikka’s BQ account with the theory of Generalized Quantifiers. Barwise’s idea was that the truth-conditions of BQ readings are connected with the monotonicity of the involved quantifiers. He claimed that there is no uniform schema for BQ: the formulae associated to sentences featuring all monotone increasing (M↑) quantifiers are different from those associated to sentences featuring all monotone decreasing (M↓) quantifiers. According to Barwise, sentences with mixed quantifiers (some M↑ and some M↓) make no 1 A 2-place Mostowskian Quantifier [11] (see also [13]) is a symbol Q such that, if x is an individual variable and Ψ, Φ are formulae then Qx(Ψ, Φ) is also a formula. Semantically, Q denotes, in every model M with universe A, a function q which takes in input two subsets B and C of A and returns a truth-value. Mostowskian Quantifiers are cardinality quantifiers, in the sense that q(B, C) depends only on the cardinalities of the sets (B ∩ C), (B \ C), (C \ B) and (A \ (B ∪ C)). Some examples are · kAllx(P1(x),P2(x))kM = true iff |(kP1(x) ∧ ¬P2(x)kM) |= 0 · kFewx(P1(x),P2(x))kM = true iff |(kP1(x) ∧ P2(x)kM) |&gt; η sense from a linguis</context>
</contexts>
<marker>[11]</marker>
<rawString>Mostowski, A., On a generalization of quantifiers., Fundamenta Mathematicae 44 (1957), pp. 12–36.</rawString>
</citation>
<citation valid="true">
<authors>
<author>U Reyle</author>
</authors>
<title>Dealing with ambiguities by underspecification: Construction, representation and deduction,</title>
<date>1993</date>
<journal>Journal of Semantics</journal>
<pages>123--179</pages>
<contexts>
<context position="1059" citStr="[12]" startWordPosition="144" endWordPosition="144">e discuss the meaning of quantifier dependency in DTS by translating its well formed structures into formulae of a Second Order Logic augmented with Mostowskian generalized quantifiers. 1 Introduction Dependency Tree Semantics (DTS) is an underspecified formalism for dealing with quantifier scope ambiguity. DTS tries to keep the advantages of most common underspecification techniques: it has a straightforward syntaxsemantics interface with a Dependency Grammar, just as QLF has [1], and it allows for monotonically adding constraints to take partial disambiguations into account, just as in UDRT [12], MRS [3] or CLLS [4]. These features have been presented in [7] and [8], whereas in [9] DTS is proposed as a possible underspecified semantic structure of Meaning⇔Text Theory [10]. This paper discusses a third property of DTS in further depth: the possibility to represent branching quantifier (BQ) readings. Branching quantification in DTS has partially been discussed in [7] and [8], in which we compared DTS with First Order Logic (FOL). However, FOL is limited in that it allows to represent only standard quantifiers (∃ and V); in this paper we compare DTS with the logic developed in [13] and </context>
</contexts>
<marker>[12]</marker>
<rawString>Reyle, U., Dealing with ambiguities by underspecification: Construction, representation and deduction, Journal of Semantics (1993), pp. 123–179.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Sher</author>
</authors>
<title>Ways of branching quantifiers,</title>
<date>1990</date>
<journal>Linguistics and Philosophy</journal>
<pages>393--422</pages>
<contexts>
<context position="1654" citStr="[13]" startWordPosition="243" endWordPosition="243">UDRT [12], MRS [3] or CLLS [4]. These features have been presented in [7] and [8], whereas in [9] DTS is proposed as a possible underspecified semantic structure of Meaning⇔Text Theory [10]. This paper discusses a third property of DTS in further depth: the possibility to represent branching quantifier (BQ) readings. Branching quantification in DTS has partially been discussed in [7] and [8], in which we compared DTS with First Order Logic (FOL). However, FOL is limited in that it allows to represent only standard quantifiers (∃ and V); in this paper we compare DTS with the logic developed in [13] and [14], which is a fragment of Second Order Logic which allows for a representation of branching quantification with Generalized Quantifiers. 1.1 Intuitions behind Dependency Tree Semantics The key idea of DTS is to specify quantifier scope by explicitly showing the dependencies between involved (quantified) groups of entities, i.e. by implementing a sort of ”Skolemization” in the underspecified representation. Wellformed structures in DTS are based on a simple graph G that represents the predicate-arguments relations, without any quantification. The nodes of G are either predicates or disc</context>
<context position="9368" citStr="[13]" startWordPosition="1630" endWordPosition="1630">as made by Barwise [2] who merged Hintikka’s BQ account with the theory of Generalized Quantifiers. Barwise’s idea was that the truth-conditions of BQ readings are connected with the monotonicity of the involved quantifiers. He claimed that there is no uniform schema for BQ: the formulae associated to sentences featuring all monotone increasing (M↑) quantifiers are different from those associated to sentences featuring all monotone decreasing (M↓) quantifiers. According to Barwise, sentences with mixed quantifiers (some M↑ and some M↓) make no 1 A 2-place Mostowskian Quantifier [11] (see also [13]) is a symbol Q such that, if x is an individual variable and Ψ, Φ are formulae then Qx(Ψ, Φ) is also a formula. Semantically, Q denotes, in every model M with universe A, a function q which takes in input two subsets B and C of A and returns a truth-value. Mostowskian Quantifiers are cardinality quantifiers, in the sense that q(B, C) depends only on the cardinalities of the sets (B ∩ C), (B \ C), (C \ B) and (A \ (B ∪ C)). Some examples are · kAllx(P1(x),P2(x))kM = true iff |(kP1(x) ∧ ¬P2(x)kM) |= 0 · kFewx(P1(x),P2(x))kM = true iff |(kP1(x) ∧ P2(x)kM) |&gt; η sense from a linguistic point of vi</context>
</contexts>
<marker>[13]</marker>
<rawString>Sher, G., Ways of branching quantifiers, Linguistics and Philosophy (1990), pp. 393–422.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Sher</author>
</authors>
<title>Partially-ordered (branching) generalized quantifiers: a general definition,</title>
<date>1997</date>
<journal>The Journal of Philosophical Logic</journal>
<pages>1--43</pages>
<contexts>
<context position="1663" citStr="[14]" startWordPosition="245" endWordPosition="245">, MRS [3] or CLLS [4]. These features have been presented in [7] and [8], whereas in [9] DTS is proposed as a possible underspecified semantic structure of Meaning⇔Text Theory [10]. This paper discusses a third property of DTS in further depth: the possibility to represent branching quantifier (BQ) readings. Branching quantification in DTS has partially been discussed in [7] and [8], in which we compared DTS with First Order Logic (FOL). However, FOL is limited in that it allows to represent only standard quantifiers (∃ and V); in this paper we compare DTS with the logic developed in [13] and [14], which is a fragment of Second Order Logic which allows for a representation of branching quantification with Generalized Quantifiers. 1.1 Intuitions behind Dependency Tree Semantics The key idea of DTS is to specify quantifier scope by explicitly showing the dependencies between involved (quantified) groups of entities, i.e. by implementing a sort of ”Skolemization” in the underspecified representation. Wellformed structures in DTS are based on a simple graph G that represents the predicate-arguments relations, without any quantification. The nodes of G are either predicates or discourse ref</context>
<context position="10006" citStr="[14]" startWordPosition="1753" endWordPosition="1753"> an individual variable and Ψ, Φ are formulae then Qx(Ψ, Φ) is also a formula. Semantically, Q denotes, in every model M with universe A, a function q which takes in input two subsets B and C of A and returns a truth-value. Mostowskian Quantifiers are cardinality quantifiers, in the sense that q(B, C) depends only on the cardinalities of the sets (B ∩ C), (B \ C), (C \ B) and (A \ (B ∪ C)). Some examples are · kAllx(P1(x),P2(x))kM = true iff |(kP1(x) ∧ ¬P2(x)kM) |= 0 · kFewx(P1(x),P2(x))kM = true iff |(kP1(x) ∧ P2(x)kM) |&gt; η sense from a linguistic point of view. On the other hand, Sher [13], [14] observed that since the semantics of linearly ordered quantification is provided regardless to monotonicity, there seems to be no methodological reason for imposing further constraints in case of partially ordered quantification. In other words, even if readings from NL are not available, this should not exclude their logical interpretation. Sher specified the semantics of BQ on the basis of a precise definition of the involved groups, according to so-called maximality conditions; roughly, her claim is that the interpretation of a BQ reading with quantifiers of any type corresponds to the one</context>
<context position="13421" citStr="[14]" startWordPosition="2352" endWordPosition="2352">and Few: there can be a different coin for every pair of a man and a coffee machine. This is reflected by the fact that Hz, the Skolem function associated with the quantifier A, is a 2-ary function, while Hx, Hy are 0-ary Skolem functions (that is, predicates). The formula states that we have to find witnesses Hx, Hy and Hz such that Hz corresponds to the extension of inserted’, and Hx and Hy are maximal sets of individuals x and y such that the set of objects z inserted by x in y, Hz(x, y, z), includes at least one coin; Hx is a set of a ”few men” and Hy contains ”three coffee machines”. See [14] for the formal details. 3 Nested Quantification A limitation of Sher’s logic is that it does not handle the case in which one quantifier occurs in the syntactical restriction of another quantifier. Consider: (6) Two representatives of three African countries arrive. Restr(x)= Quant(y)= tree Quant(x)= two arrive 1 1 1 x rep’ of’ 1 2 y af_c’ of’ rep’ 2 y x 1 1 y 1 af_c’ Restr(y)= In this example, the quantifier Three occurs in the syntactic restriction of Two. This corresponds to the fact that the discourse referent y occurs in the graph RESTR(x). This type of reading cannot be directly represe</context>
</contexts>
<marker>[14]</marker>
<rawString>Sher, G., Partially-ordered (branching) generalized quantifiers: a general definition, The Journal of Philosophical Logic (1997), pp. 1–43.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>