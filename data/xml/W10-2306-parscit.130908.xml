<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.100600">
<title confidence="0.998209">
A Character-Based Intersection Graph Approach to Linguistic Phylogeny
</title>
<author confidence="0.998915">
Jessica Enright
</author>
<affiliation confidence="0.8657325">
University of Alberta
Edmonton, Alberta, Canada
</affiliation>
<email confidence="0.991199">
enright@cs.ualberta.ca
</email>
<sectionHeader confidence="0.993731" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999814416666667">
Linguists use phylogenetic methods to
build evolutionary trees of languages
given lexical, phonological, and morpho-
logical data. Perfect phylogeny is too re-
strictive to explain most data sets. Con-
servative Dollo phylogeny is more permis-
sive, and has been used in biological ap-
plications. We propose the use of conser-
vative Dollo phylogeny as an alternative
or complementary approach for linguistic
phylogenetics. We test this approach on an
Indo-European dataset.
</bodyText>
<sectionHeader confidence="0.999561" genericHeader="keywords">
1 Introduction
</sectionHeader>
<subsectionHeader confidence="0.999544">
1.1 Language Phylogeny
</subsectionHeader>
<bodyText confidence="0.999988642857143">
A linguistic phylogenetic tree is a tree describing
the evolution of some set of languages. Usually,
we build such a tree using information given by a
set of characters associated with those languages.
We say that a character back-mutated if after
evolving from 0 state to 1 state, it subsequently
is lost and switches back on the tree from 1 state
to 0 state. We say that a character has parallel
evolution if it evolves twice on the tree from state
0 to state 1 independently. We say that a charac-
ter is borrowed if, on the true evolutionary tree, it
has been transfered from one branch to another by
contact between linguistic groups. Loanwords are
an example of this.
</bodyText>
<subsectionHeader confidence="0.987695">
1.2 Perfect phylogeny
</subsectionHeader>
<bodyText confidence="0.992740071428572">
Given a set of binary characters C = {c1...cj1,
we say that a rooted tree T = (r, VT, ET) with
languages L = l1...lk as the leaf nodes of T is
a perfect phylogeny if there is a binary labeling
of each character at each node such that the root
node is labeled with a zero for each character, and
for each character both the subtree induced by the
nodes labeled 1 at that character, and the subtree
induced by the nodes labeled 0 at that character
are connected.
This means that each character evolves exactly
once, and that there is no back-mutation or bor-
rowing.
We can recognize whether a set of characters
admits a perfect phylogeny in polynomial time
(Felsenstein, 2004). Unfortunately, often charac-
ter data does not admit a perfect phylogeny.
Usually the question given character data is:
How far away is this data from admitting a perfect
phylogeny? What is the minimum level of bor-
rowing, back mutation or parallel evolution that
we must allow to produce a tree that describes this
data? Answering this question is NP-Hard (Day et
al., 1986).
Many approaches describe and formalize this
question. Nakhleh et al. (2005b) provide an ex-
cellent survey of linguistic phylogenetic methods.
Nakhleh et al. (2005a) proposed perfect phy-
logeny networks as a way of considering the phy-
logeny problem. A perfect phylogeny network is
a graph that is not required to be a tree such that
every character exhibits a perfect phylogeny on at
least one of the subtrees of that graph.
Unfortunately, even given a phylogenetic tree
and character data, determining the minimum
number of edges one must add to produce a per-
fect phylogeny network is NP-Hard (Day et al.,
1986). Nakhleh et al. (2005a) mention that ap-
plying the perfect phylogeny network approach to
their Indo-European language dataset is tractable
only because one need only add very few edges to
their tree to produce a perfect phylogeny network.
</bodyText>
<subsectionHeader confidence="0.988714">
1.3 Dollo Phylogenies
</subsectionHeader>
<bodyText confidence="0.9981582">
In contrast to a perfect phylogeny, a Dollo phy-
logeny allows an arbitrary number of back muta-
tions.
Given a set of binary characters C = {c1...cj1,
we say that a rooted tree T = (r, VT, ET) with
</bodyText>
<page confidence="0.991419">
42
</page>
<note confidence="0.633368">
Proceedings of the 2010 Workshop on Graph-based Methods for Natural Language Processing, ACL 2010, pages 42–46,
Uppsala, Sweden, 16 July 2010. c�2010 Association for Computational Linguistics
</note>
<bodyText confidence="0.99910995">
languages G = l1...lk as the leaf nodes of T is
a Dollo phylogeny if there is a binary labeling of
each character at each node such that the root node
is labeled with a zero for each character, and for
each character the subtree induced by the nodes
labeled 1 is connected.
This means that each character evolves exactly
once but an arbitrary number of back-mutations
are allowed. Unfortunately, every set of charac-
ter data admits a Dollo phylogeny. Clearly Dollo
phylogeny is too permissive to be a useful notion
in linguistic phylogenetics.
Przytycka et al. (2006) discussed the idea of a
conservative Dollo phylogeny.
Given a set of binary characters C = {c1...cj1,
we say that a rooted tree T = (r, VT, ET) with
languages G = l1...lk as the leaf nodes of T is a
conservative Dollo phylogeny (CDP) if there is a
binary labeling of each character at each node such
that the root node is labeled with a zero for each
character, for each character the subtree induced
by the nodes labeled 1 is connected, and if two
characters appear together in their 1 states in the
tree at an internal node, they also occur together in
their 1 states in the tree at a leaf node. Recall that
the leaves in this tree are the languages for which
we have data. For an example, see Figure 1.
If two characters existed together in some an-
cestral language, they must also exist together in at
least one leaf language. That is, if they have ever
existed together in the same language, we have ev-
idence of it in the form of a known language that
possessed both of those characters. Is this a rea-
sonable assumption? We have no evidence that
it is. However, it’s certainly a more reasonable
assumption than that required for a perfect phy-
logeny. We expect that often, data sets will not
admit a CDP, and that, like for perfect phylogeny,
the question will be: How far away are the data
from admitting a CDP?
Przytycka et al. (2006) prove that a set of char-
acters admit a CDP if and only if their intersection
graph is chordal. Chordal graphs are graphs with
no induced cycles longer than three vertices. Rose
et al. (1976) provide a linear-time recognition al-
gorithm for chordal graphs.
Graph G = (V, E) is an intersection graph of a
family of sets S if there is a bijection F between V
and S such that for every two sets s, t E S F(s)
is adjacent to F(t) if and only if s intersects t.
Set s intersects set t if they share at least one ele-
ment. Given sets, we can compute their intersec-
tion graph in linear time. For an example of an
intersection graph derived from a family of sets,
see Figure 2.
We can then determine if a set of characters ad-
mits a CDP in linear time. This approach to phy-
logeny was used by Przytycka et al. (2006) in a
biological phylogenetic application. Here, we use
it for linguistic phylogeny.
</bodyText>
<sectionHeader confidence="0.997373" genericHeader="introduction">
2 Methodology
</sectionHeader>
<bodyText confidence="0.99981375">
We implemented an algorithm to, given a charac-
ter dataset, compute the intersection graph of those
characters, and determine whether the resulting
graph is chordal as given by Rose et al. (1976).
This tells us whether or not the dataset admits a
CDP. We also implemented an exhaustive search
that computes the minimum number of characters
that must be borrowed to otherwise admit a CDP.
</bodyText>
<figureCaption confidence="0.9946994">
Figure 1: A tree that is a conservative Dollo phy-
logeny, but not a perfect phylogeny, as charac-
ters one and two back-mutate. The lists at each
node contain the state of characters one, two,
and three in that order.
</figureCaption>
<equation confidence="0.9725362">
{1, 1, 0 } {0, 1, 0 } {0, 0, 1 } {1, 0, 1 }
{1, 1, 0 }
{1, 1, 0 }
{0, 0, 0 }
{1, 0, 1 }
</equation>
<figure confidence="0.886690666666667">
a b c d e
{1, 2}, {2, 3}, {3}, {3, 4}, {5, 3}
a b
</figure>
<figureCaption confidence="0.996784333333333">
Figure 2: An example of a family of sets labeled
a, b, c, d, e on the top and the intersection graph
of those sets on the bottom.
</figureCaption>
<figure confidence="0.492531">
c e
d
</figure>
<page confidence="0.999255">
43
</page>
<bodyText confidence="0.99995025">
We ran our program on the Indo-
European character dataset used by Nakhleh
et al. (2005a), and available online at
http://www.cs.rice.edu/ nakhleh/CPHL/.
</bodyText>
<subsectionHeader confidence="0.992042">
2.1 Language Family Grouping
</subsectionHeader>
<bodyText confidence="0.999994111111111">
Nakhleh et al. (2005a) combined established lan-
guage groups into a single language during com-
putation to decrease computation time. We use the
same families as they do, and do the same in two
of our experiments.
For example, we consider the Tocharian lan-
guage family, consisting of Tocharian A and
Tocharian B to be a single language when building
our intersection graph. This language grouping is
done as a preprocessing step to the construction of
the intersection graph of the characters.
We expect this transformation to be particularly
useful in the CDP setting, beyond just decreasing
computation time. We expect it will make our data
closer to admitting a CDP in a way consistent with
true evolutionary history.
Consider the difference between the intersec-
tion graph of a set of characters with family group-
ing and without. Let s and t be two characters that,
are considered to intersect with family grouping,
but not without. Then s and t are not present in
any of the same languages, but there are two lan-
guages li, lj such that li has character s but not t
and language lj has character t but not s, and li
and lj are in the same family L.
We use the language family definitions given by
Nakhleh et al. (2005a), where these language fam-
ilies are identified as consistent with all characters,
and it is argued that it is very unlikely there is any
borrowing between a portion of the tree inside the
family, and a portion of the tree outside the family.
Therefore, if s and t are both present within
leaves in the language family L, and neither is bor-
rowed from outside the family, then each of s, t is
either present only within language family L, or
is present in at least one internal node ancestral
to language family L. If s and t are only present
within the language family, they are not informa-
tive when language family grouping is used.
However, if both s and t are present at an in-
ternal node ancestral to language family L, then
this is important information that we have derived
by applying family language grouping, and will
make the data closer to admitting a CDP in terms
of number of borrowings required.
</bodyText>
<subsectionHeader confidence="0.999084">
2.2 Binary Data
</subsectionHeader>
<bodyText confidence="0.999985111111111">
We made the data binary by separating states of
a given character as best indicated by notes pro-
vided by Nakhleh et al. (2005a) on their coding of
the characters. In making the data binary, we have
likely lost some constraining information. When
a language (or language family, when that group-
ing was used) has a unique state at a character,
we coded this as having all possible non-ancestral
states. The basis for this is that some of these
codes indicate that there is no data for that char-
acter at that language, or that if that language ac-
tually does have a unique state at that character,
it is uninformative, but could have evolved from
any other state. Data processing by someone more
highly trained in linguistics would either confirm
this decision or provide an alternative approach.
We have tried to remain as close as possible to how
the data is used in Nakhleh et al. (2005a).
</bodyText>
<sectionHeader confidence="0.999389" genericHeader="method">
3 Experiments
</sectionHeader>
<bodyText confidence="0.999865666666667">
We ran four experiments to investigate the use-
fulness of the conservative Dollo parsimony ap-
proach. We ran our implementation on:
</bodyText>
<listItem confidence="0.992550857142857">
1. All characters without language family
grouping
2. All characters with language family grouping
3. Phonological and morphological characters
only without language family grouping
4. Phonological and morphological characters
only with language family grouping
</listItem>
<sectionHeader confidence="0.999495" genericHeader="method">
4 Results
</sectionHeader>
<bodyText confidence="0.999572294117647">
We give our results in Table 4
For the morphological and phonological
dataset, both grouped and ungrouped, we ex-
tracted a phylogenetic tree from our program’s
output. These trees were consistent with Tree A
in (Nakhleh et al., 2005a). The fact that we man-
aged to build a tree consistent with expectations
without any input tree is very encouraging.
Recall that when we use language grouping we
combine all languages identified as being from an
established family by Nakhleh et al. (2005a) into
a single language. For example, instead of con-
sidering both Tocharian A and Tocharian B, in our
experiments with language grouping we consider
a single language, Tocharian, that has all charac-
teristics of Tocharian A and all characteristics of
Tocharian B.
</bodyText>
<page confidence="0.999642">
44
</page>
<tableCaption confidence="0.996155333333333">
Table 1: The results of conservative Dollo phylogeny checking algorithm on modified versions of the
Indo-European character dataset as used in (Nakhleh et al., 2005a). We ran each program for at most 1
hour. Entries of ”Too slow” indicate that we did not allow the program to halt.
</tableCaption>
<table confidence="0.999041555555556">
Dataset Admits a CDP? Minimum number of languages
that must borrow
Answer Time Answer Time
Phonological, Morphological Data Yes &lt;1 s 0 &lt;1 s
without Language Grouping
Phonological, Morphological Data Yes &lt;1 s 0 &lt;1 s
with Language Grouping
All Data without Language Grouping No &lt;1 s - Too slow
All Data with Language Grouping No &lt;1 s 2 &lt; 1 s
</table>
<bodyText confidence="0.881359">
In our experiments without language grouping,
we do not combine languages in this way, and in-
stead consider all 24 languages separately.
</bodyText>
<sectionHeader confidence="0.999714" genericHeader="method">
5 Discussion
</sectionHeader>
<bodyText confidence="0.999948586206897">
When is the CDP approach useful for linguistic
phylogenetics?
Because a CDP allows back-mutation, it is
likely most useful for datasets that exhibit a lot of
back mutation, and not a lot of borrowing. Phono-
logical and morphological characters are more
likely to fit this requirement than lexical data. This
is reflected in our positive results on the phonolog-
ical and morphological characters alone.
In contrast, when we included the lexical data,
the dataset did not admit a conservative Dollo par-
simony, whether or not we used language family
grouping. We expect this is due to borrowing of
lexical characters.
The full dataset with language family group-
ing was much closer to admitting a conserva-
tive Dollo parsimony than the full dataset with-
out language family grouping. As explained in our
Methodology section, this was expected and rein-
forces our position that language family grouping
is extremely useful when computing conservative
Dollo phylogenies.
Our experiments ran in either negligible time,
or were not allowed to halt. The speed of the fast
experiments suggests that computing conservative
Dollo phylogenies might be useful in construct-
ing a tree when no tree is known, and the amount
of character data causes computing other types of
phylogenies to be intractable.
</bodyText>
<sectionHeader confidence="0.99985" genericHeader="method">
6 Future Work
</sectionHeader>
<bodyText confidence="0.999989863636364">
We are currently pursuing several extensions to
this work.
First, we are developing an improved heuristic
search for the minimum number of edges that need
to be removed from or added to a graph to make
the resulting graph chordal. This will enable us to
use the Dollo phylogeny approach outlined here
on character data sets that require more borrowing
to fully explain them.
Using this improved search, we will run experi-
ments on other sets of character data.
Nakhleh et al. (2005a) started with several pro-
posed trees in their work on perfect phylogenetic
networks. We plan to implement a version of our
CDP approach that takes as input a proposed tree.
This version will calculate the minimum number
of edges that must be added to create a Dollo
phylogeny network, as analogous to Nakhleh et
al.’s perfect phylogenetic network. This minimum
number of edges would be useful as a lower bound
for the required number of edges one must add to
produce a perfect phylogeny network.
</bodyText>
<sectionHeader confidence="0.998992" genericHeader="conclusions">
7 Conclusion
</sectionHeader>
<bodyText confidence="0.999994833333333">
We have presented an alternative phylogeny that
may be of use in linguistic phylogenetics, par-
ticularly on phonological or morphological data.
We have proposed a number of future extensions
based on our experiments that we hope will im-
prove the performance of this approach.
</bodyText>
<sectionHeader confidence="0.998846" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.997042">
The author would like to acknowledge the helpful
input of reviewers, as well as Dr. Gzegorz Kon-
drak and Dr. Lorna Stewart.
</bodyText>
<page confidence="0.999055">
45
</page>
<sectionHeader confidence="0.995847" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.9997498">
William Day, David Johnson, and David Sankoff.
1986. The computational complexity of inferring
rooted phylogenies by parsimony. Mathematical
Biosciences, 81:33–42.
Joseph Felsenstein. 2004. Inferring Phyloge-
nies. Number 1. Sinauer Associates, Massachusetts,
USA.
Luay Nakhleh, Don Ringe, and Tandy Warnow. 2005a.
Perfect phylogenetic networks: A new methodology
for reconstructing the evolutionary history of natu-
ral languages. Language (Journal of the Linguistic
Society ofAmerica), 81(2):382–420.
Luay Nakhleh, Tandy Warnow, Don Ringe, and
Steven N. Evans. 2005b. A comparison of phyloge-
netic reconstruction methods on an ie dataset. The
Transactions of the Philological Society, 3(2):171 –
192.
Teresa Przytycka, George Davis, Nan Song, and Dan-
nie Durand. 2006. Graph theoretical insights into
evolution of multidomain proteins. Journal of com-
putational biology : a journal of computational
molecular cell biology, 13(2):351–363.
Donald J. Rose, R. Endre Tarjan, and George S. Leuker.
1976. Algorithmic aspects of vertex elimination on
graphs. SIAM Journal of Computing, 5(2):266–283.
</reference>
<page confidence="0.999612">
46
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.636131">
<title confidence="0.999692">A Character-Based Intersection Graph Approach to Linguistic Phylogeny</title>
<author confidence="0.997069">Jessica</author>
<affiliation confidence="0.999807">University of</affiliation>
<address confidence="0.830514">Edmonton, Alberta,</address>
<email confidence="0.99889">enright@cs.ualberta.ca</email>
<abstract confidence="0.982159692307692">Linguists use phylogenetic methods to build evolutionary trees of languages given lexical, phonological, and morphological data. Perfect phylogeny is too restrictive to explain most data sets. Conservative Dollo phylogeny is more permissive, and has been used in biological applications. We propose the use of conservative Dollo phylogeny as an alternative or complementary approach for linguistic phylogenetics. We test this approach on an Indo-European dataset.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>William Day</author>
<author>David Johnson</author>
<author>David Sankoff</author>
</authors>
<title>The computational complexity of inferring rooted phylogenies by parsimony.</title>
<date>1986</date>
<booktitle>Mathematical Biosciences,</booktitle>
<pages>81--33</pages>
<contexts>
<context position="2409" citStr="Day et al., 1986" startWordPosition="399" endWordPosition="402"> that character are connected. This means that each character evolves exactly once, and that there is no back-mutation or borrowing. We can recognize whether a set of characters admits a perfect phylogeny in polynomial time (Felsenstein, 2004). Unfortunately, often character data does not admit a perfect phylogeny. Usually the question given character data is: How far away is this data from admitting a perfect phylogeny? What is the minimum level of borrowing, back mutation or parallel evolution that we must allow to produce a tree that describes this data? Answering this question is NP-Hard (Day et al., 1986). Many approaches describe and formalize this question. Nakhleh et al. (2005b) provide an excellent survey of linguistic phylogenetic methods. Nakhleh et al. (2005a) proposed perfect phylogeny networks as a way of considering the phylogeny problem. A perfect phylogeny network is a graph that is not required to be a tree such that every character exhibits a perfect phylogeny on at least one of the subtrees of that graph. Unfortunately, even given a phylogenetic tree and character data, determining the minimum number of edges one must add to produce a perfect phylogeny network is NP-Hard (Day et</context>
</contexts>
<marker>Day, Johnson, Sankoff, 1986</marker>
<rawString>William Day, David Johnson, and David Sankoff. 1986. The computational complexity of inferring rooted phylogenies by parsimony. Mathematical Biosciences, 81:33–42.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joseph Felsenstein</author>
</authors>
<title>Inferring Phylogenies. Number 1. Sinauer Associates,</title>
<date>2004</date>
<location>Massachusetts, USA.</location>
<contexts>
<context position="2035" citStr="Felsenstein, 2004" startWordPosition="338" endWordPosition="339">that a rooted tree T = (r, VT, ET) with languages L = l1...lk as the leaf nodes of T is a perfect phylogeny if there is a binary labeling of each character at each node such that the root node is labeled with a zero for each character, and for each character both the subtree induced by the nodes labeled 1 at that character, and the subtree induced by the nodes labeled 0 at that character are connected. This means that each character evolves exactly once, and that there is no back-mutation or borrowing. We can recognize whether a set of characters admits a perfect phylogeny in polynomial time (Felsenstein, 2004). Unfortunately, often character data does not admit a perfect phylogeny. Usually the question given character data is: How far away is this data from admitting a perfect phylogeny? What is the minimum level of borrowing, back mutation or parallel evolution that we must allow to produce a tree that describes this data? Answering this question is NP-Hard (Day et al., 1986). Many approaches describe and formalize this question. Nakhleh et al. (2005b) provide an excellent survey of linguistic phylogenetic methods. Nakhleh et al. (2005a) proposed perfect phylogeny networks as a way of considering </context>
</contexts>
<marker>Felsenstein, 2004</marker>
<rawString>Joseph Felsenstein. 2004. Inferring Phylogenies. Number 1. Sinauer Associates, Massachusetts, USA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Luay Nakhleh</author>
<author>Don Ringe</author>
<author>Tandy Warnow</author>
</authors>
<title>Perfect phylogenetic networks: A new methodology for reconstructing the evolutionary history of natural languages.</title>
<date>2005</date>
<journal>Language (Journal of the Linguistic Society ofAmerica),</journal>
<volume>81</volume>
<issue>2</issue>
<contexts>
<context position="2485" citStr="Nakhleh et al. (2005" startWordPosition="410" endWordPosition="413">ctly once, and that there is no back-mutation or borrowing. We can recognize whether a set of characters admits a perfect phylogeny in polynomial time (Felsenstein, 2004). Unfortunately, often character data does not admit a perfect phylogeny. Usually the question given character data is: How far away is this data from admitting a perfect phylogeny? What is the minimum level of borrowing, back mutation or parallel evolution that we must allow to produce a tree that describes this data? Answering this question is NP-Hard (Day et al., 1986). Many approaches describe and formalize this question. Nakhleh et al. (2005b) provide an excellent survey of linguistic phylogenetic methods. Nakhleh et al. (2005a) proposed perfect phylogeny networks as a way of considering the phylogeny problem. A perfect phylogeny network is a graph that is not required to be a tree such that every character exhibits a perfect phylogeny on at least one of the subtrees of that graph. Unfortunately, even given a phylogenetic tree and character data, determining the minimum number of edges one must add to produce a perfect phylogeny network is NP-Hard (Day et al., 1986). Nakhleh et al. (2005a) mention that applying the perfect phylog</context>
<context position="7444" citStr="Nakhleh et al. (2005" startWordPosition="1332" endWordPosition="1335">must be borrowed to otherwise admit a CDP. Figure 1: A tree that is a conservative Dollo phylogeny, but not a perfect phylogeny, as characters one and two back-mutate. The lists at each node contain the state of characters one, two, and three in that order. {1, 1, 0 } {0, 1, 0 } {0, 0, 1 } {1, 0, 1 } {1, 1, 0 } {1, 1, 0 } {0, 0, 0 } {1, 0, 1 } a b c d e {1, 2}, {2, 3}, {3}, {3, 4}, {5, 3} a b Figure 2: An example of a family of sets labeled a, b, c, d, e on the top and the intersection graph of those sets on the bottom. c e d 43 We ran our program on the IndoEuropean character dataset used by Nakhleh et al. (2005a), and available online at http://www.cs.rice.edu/ nakhleh/CPHL/. 2.1 Language Family Grouping Nakhleh et al. (2005a) combined established language groups into a single language during computation to decrease computation time. We use the same families as they do, and do the same in two of our experiments. For example, we consider the Tocharian language family, consisting of Tocharian A and Tocharian B to be a single language when building our intersection graph. This language grouping is done as a preprocessing step to the construction of the intersection graph of the characters. We expect th</context>
<context position="8758" citStr="Nakhleh et al. (2005" startWordPosition="1559" endWordPosition="1562">tion time. We expect it will make our data closer to admitting a CDP in a way consistent with true evolutionary history. Consider the difference between the intersection graph of a set of characters with family grouping and without. Let s and t be two characters that, are considered to intersect with family grouping, but not without. Then s and t are not present in any of the same languages, but there are two languages li, lj such that li has character s but not t and language lj has character t but not s, and li and lj are in the same family L. We use the language family definitions given by Nakhleh et al. (2005a), where these language families are identified as consistent with all characters, and it is argued that it is very unlikely there is any borrowing between a portion of the tree inside the family, and a portion of the tree outside the family. Therefore, if s and t are both present within leaves in the language family L, and neither is borrowed from outside the family, then each of s, t is either present only within language family L, or is present in at least one internal node ancestral to language family L. If s and t are only present within the language family, they are not informative when</context>
<context position="10569" citStr="Nakhleh et al. (2005" startWordPosition="1885" endWordPosition="1888">uage family, when that grouping was used) has a unique state at a character, we coded this as having all possible non-ancestral states. The basis for this is that some of these codes indicate that there is no data for that character at that language, or that if that language actually does have a unique state at that character, it is uninformative, but could have evolved from any other state. Data processing by someone more highly trained in linguistics would either confirm this decision or provide an alternative approach. We have tried to remain as close as possible to how the data is used in Nakhleh et al. (2005a). 3 Experiments We ran four experiments to investigate the usefulness of the conservative Dollo parsimony approach. We ran our implementation on: 1. All characters without language family grouping 2. All characters with language family grouping 3. Phonological and morphological characters only without language family grouping 4. Phonological and morphological characters only with language family grouping 4 Results We give our results in Table 4 For the morphological and phonological dataset, both grouped and ungrouped, we extracted a phylogenetic tree from our program’s output. These trees w</context>
<context position="11907" citStr="Nakhleh et al., 2005" startWordPosition="2094" endWordPosition="2097">ations without any input tree is very encouraging. Recall that when we use language grouping we combine all languages identified as being from an established family by Nakhleh et al. (2005a) into a single language. For example, instead of considering both Tocharian A and Tocharian B, in our experiments with language grouping we consider a single language, Tocharian, that has all characteristics of Tocharian A and all characteristics of Tocharian B. 44 Table 1: The results of conservative Dollo phylogeny checking algorithm on modified versions of the Indo-European character dataset as used in (Nakhleh et al., 2005a). We ran each program for at most 1 hour. Entries of ”Too slow” indicate that we did not allow the program to halt. Dataset Admits a CDP? Minimum number of languages that must borrow Answer Time Answer Time Phonological, Morphological Data Yes &lt;1 s 0 &lt;1 s without Language Grouping Phonological, Morphological Data Yes &lt;1 s 0 &lt;1 s with Language Grouping All Data without Language Grouping No &lt;1 s - Too slow All Data with Language Grouping No &lt;1 s 2 &lt; 1 s In our experiments without language grouping, we do not combine languages in this way, and instead consider all 24 languages separately. 5 Dis</context>
<context position="14292" citStr="Nakhleh et al. (2005" startWordPosition="2495" endWordPosition="2498">a tree when no tree is known, and the amount of character data causes computing other types of phylogenies to be intractable. 6 Future Work We are currently pursuing several extensions to this work. First, we are developing an improved heuristic search for the minimum number of edges that need to be removed from or added to a graph to make the resulting graph chordal. This will enable us to use the Dollo phylogeny approach outlined here on character data sets that require more borrowing to fully explain them. Using this improved search, we will run experiments on other sets of character data. Nakhleh et al. (2005a) started with several proposed trees in their work on perfect phylogenetic networks. We plan to implement a version of our CDP approach that takes as input a proposed tree. This version will calculate the minimum number of edges that must be added to create a Dollo phylogeny network, as analogous to Nakhleh et al.’s perfect phylogenetic network. This minimum number of edges would be useful as a lower bound for the required number of edges one must add to produce a perfect phylogeny network. 7 Conclusion We have presented an alternative phylogeny that may be of use in linguistic phylogenetics</context>
</contexts>
<marker>Nakhleh, Ringe, Warnow, 2005</marker>
<rawString>Luay Nakhleh, Don Ringe, and Tandy Warnow. 2005a. Perfect phylogenetic networks: A new methodology for reconstructing the evolutionary history of natural languages. Language (Journal of the Linguistic Society ofAmerica), 81(2):382–420.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Luay Nakhleh</author>
<author>Tandy Warnow</author>
<author>Don Ringe</author>
<author>Steven N Evans</author>
</authors>
<title>A comparison of phylogenetic reconstruction methods on an ie dataset.</title>
<date>2005</date>
<journal>The Transactions of the Philological Society,</journal>
<volume>3</volume>
<issue>2</issue>
<pages>192</pages>
<contexts>
<context position="2485" citStr="Nakhleh et al. (2005" startWordPosition="410" endWordPosition="413">ctly once, and that there is no back-mutation or borrowing. We can recognize whether a set of characters admits a perfect phylogeny in polynomial time (Felsenstein, 2004). Unfortunately, often character data does not admit a perfect phylogeny. Usually the question given character data is: How far away is this data from admitting a perfect phylogeny? What is the minimum level of borrowing, back mutation or parallel evolution that we must allow to produce a tree that describes this data? Answering this question is NP-Hard (Day et al., 1986). Many approaches describe and formalize this question. Nakhleh et al. (2005b) provide an excellent survey of linguistic phylogenetic methods. Nakhleh et al. (2005a) proposed perfect phylogeny networks as a way of considering the phylogeny problem. A perfect phylogeny network is a graph that is not required to be a tree such that every character exhibits a perfect phylogeny on at least one of the subtrees of that graph. Unfortunately, even given a phylogenetic tree and character data, determining the minimum number of edges one must add to produce a perfect phylogeny network is NP-Hard (Day et al., 1986). Nakhleh et al. (2005a) mention that applying the perfect phylog</context>
<context position="7444" citStr="Nakhleh et al. (2005" startWordPosition="1332" endWordPosition="1335">must be borrowed to otherwise admit a CDP. Figure 1: A tree that is a conservative Dollo phylogeny, but not a perfect phylogeny, as characters one and two back-mutate. The lists at each node contain the state of characters one, two, and three in that order. {1, 1, 0 } {0, 1, 0 } {0, 0, 1 } {1, 0, 1 } {1, 1, 0 } {1, 1, 0 } {0, 0, 0 } {1, 0, 1 } a b c d e {1, 2}, {2, 3}, {3}, {3, 4}, {5, 3} a b Figure 2: An example of a family of sets labeled a, b, c, d, e on the top and the intersection graph of those sets on the bottom. c e d 43 We ran our program on the IndoEuropean character dataset used by Nakhleh et al. (2005a), and available online at http://www.cs.rice.edu/ nakhleh/CPHL/. 2.1 Language Family Grouping Nakhleh et al. (2005a) combined established language groups into a single language during computation to decrease computation time. We use the same families as they do, and do the same in two of our experiments. For example, we consider the Tocharian language family, consisting of Tocharian A and Tocharian B to be a single language when building our intersection graph. This language grouping is done as a preprocessing step to the construction of the intersection graph of the characters. We expect th</context>
<context position="8758" citStr="Nakhleh et al. (2005" startWordPosition="1559" endWordPosition="1562">tion time. We expect it will make our data closer to admitting a CDP in a way consistent with true evolutionary history. Consider the difference between the intersection graph of a set of characters with family grouping and without. Let s and t be two characters that, are considered to intersect with family grouping, but not without. Then s and t are not present in any of the same languages, but there are two languages li, lj such that li has character s but not t and language lj has character t but not s, and li and lj are in the same family L. We use the language family definitions given by Nakhleh et al. (2005a), where these language families are identified as consistent with all characters, and it is argued that it is very unlikely there is any borrowing between a portion of the tree inside the family, and a portion of the tree outside the family. Therefore, if s and t are both present within leaves in the language family L, and neither is borrowed from outside the family, then each of s, t is either present only within language family L, or is present in at least one internal node ancestral to language family L. If s and t are only present within the language family, they are not informative when</context>
<context position="10569" citStr="Nakhleh et al. (2005" startWordPosition="1885" endWordPosition="1888">uage family, when that grouping was used) has a unique state at a character, we coded this as having all possible non-ancestral states. The basis for this is that some of these codes indicate that there is no data for that character at that language, or that if that language actually does have a unique state at that character, it is uninformative, but could have evolved from any other state. Data processing by someone more highly trained in linguistics would either confirm this decision or provide an alternative approach. We have tried to remain as close as possible to how the data is used in Nakhleh et al. (2005a). 3 Experiments We ran four experiments to investigate the usefulness of the conservative Dollo parsimony approach. We ran our implementation on: 1. All characters without language family grouping 2. All characters with language family grouping 3. Phonological and morphological characters only without language family grouping 4. Phonological and morphological characters only with language family grouping 4 Results We give our results in Table 4 For the morphological and phonological dataset, both grouped and ungrouped, we extracted a phylogenetic tree from our program’s output. These trees w</context>
<context position="11907" citStr="Nakhleh et al., 2005" startWordPosition="2094" endWordPosition="2097">ations without any input tree is very encouraging. Recall that when we use language grouping we combine all languages identified as being from an established family by Nakhleh et al. (2005a) into a single language. For example, instead of considering both Tocharian A and Tocharian B, in our experiments with language grouping we consider a single language, Tocharian, that has all characteristics of Tocharian A and all characteristics of Tocharian B. 44 Table 1: The results of conservative Dollo phylogeny checking algorithm on modified versions of the Indo-European character dataset as used in (Nakhleh et al., 2005a). We ran each program for at most 1 hour. Entries of ”Too slow” indicate that we did not allow the program to halt. Dataset Admits a CDP? Minimum number of languages that must borrow Answer Time Answer Time Phonological, Morphological Data Yes &lt;1 s 0 &lt;1 s without Language Grouping Phonological, Morphological Data Yes &lt;1 s 0 &lt;1 s with Language Grouping All Data without Language Grouping No &lt;1 s - Too slow All Data with Language Grouping No &lt;1 s 2 &lt; 1 s In our experiments without language grouping, we do not combine languages in this way, and instead consider all 24 languages separately. 5 Dis</context>
<context position="14292" citStr="Nakhleh et al. (2005" startWordPosition="2495" endWordPosition="2498">a tree when no tree is known, and the amount of character data causes computing other types of phylogenies to be intractable. 6 Future Work We are currently pursuing several extensions to this work. First, we are developing an improved heuristic search for the minimum number of edges that need to be removed from or added to a graph to make the resulting graph chordal. This will enable us to use the Dollo phylogeny approach outlined here on character data sets that require more borrowing to fully explain them. Using this improved search, we will run experiments on other sets of character data. Nakhleh et al. (2005a) started with several proposed trees in their work on perfect phylogenetic networks. We plan to implement a version of our CDP approach that takes as input a proposed tree. This version will calculate the minimum number of edges that must be added to create a Dollo phylogeny network, as analogous to Nakhleh et al.’s perfect phylogenetic network. This minimum number of edges would be useful as a lower bound for the required number of edges one must add to produce a perfect phylogeny network. 7 Conclusion We have presented an alternative phylogeny that may be of use in linguistic phylogenetics</context>
</contexts>
<marker>Nakhleh, Warnow, Ringe, Evans, 2005</marker>
<rawString>Luay Nakhleh, Tandy Warnow, Don Ringe, and Steven N. Evans. 2005b. A comparison of phylogenetic reconstruction methods on an ie dataset. The Transactions of the Philological Society, 3(2):171 – 192.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Teresa Przytycka</author>
<author>George Davis</author>
<author>Nan Song</author>
<author>Dannie Durand</author>
</authors>
<title>Graph theoretical insights into evolution of multidomain proteins.</title>
<date>2006</date>
<journal>Journal of</journal>
<pages>13--2</pages>
<contexts>
<context position="4237" citStr="Przytycka et al. (2006)" startWordPosition="706" endWordPosition="709">y 2010. c�2010 Association for Computational Linguistics languages G = l1...lk as the leaf nodes of T is a Dollo phylogeny if there is a binary labeling of each character at each node such that the root node is labeled with a zero for each character, and for each character the subtree induced by the nodes labeled 1 is connected. This means that each character evolves exactly once but an arbitrary number of back-mutations are allowed. Unfortunately, every set of character data admits a Dollo phylogeny. Clearly Dollo phylogeny is too permissive to be a useful notion in linguistic phylogenetics. Przytycka et al. (2006) discussed the idea of a conservative Dollo phylogeny. Given a set of binary characters C = {c1...cj1, we say that a rooted tree T = (r, VT, ET) with languages G = l1...lk as the leaf nodes of T is a conservative Dollo phylogeny (CDP) if there is a binary labeling of each character at each node such that the root node is labeled with a zero for each character, for each character the subtree induced by the nodes labeled 1 is connected, and if two characters appear together in their 1 states in the tree at an internal node, they also occur together in their 1 states in the tree at a leaf node. R</context>
<context position="5577" citStr="Przytycka et al. (2006)" startWordPosition="957" endWordPosition="960">racters existed together in some ancestral language, they must also exist together in at least one leaf language. That is, if they have ever existed together in the same language, we have evidence of it in the form of a known language that possessed both of those characters. Is this a reasonable assumption? We have no evidence that it is. However, it’s certainly a more reasonable assumption than that required for a perfect phylogeny. We expect that often, data sets will not admit a CDP, and that, like for perfect phylogeny, the question will be: How far away are the data from admitting a CDP? Przytycka et al. (2006) prove that a set of characters admit a CDP if and only if their intersection graph is chordal. Chordal graphs are graphs with no induced cycles longer than three vertices. Rose et al. (1976) provide a linear-time recognition algorithm for chordal graphs. Graph G = (V, E) is an intersection graph of a family of sets S if there is a bijection F between V and S such that for every two sets s, t E S F(s) is adjacent to F(t) if and only if s intersects t. Set s intersects set t if they share at least one element. Given sets, we can compute their intersection graph in linear time. For an example of</context>
</contexts>
<marker>Przytycka, Davis, Song, Durand, 2006</marker>
<rawString>Teresa Przytycka, George Davis, Nan Song, and Dannie Durand. 2006. Graph theoretical insights into evolution of multidomain proteins. Journal of computational biology : a journal of computational molecular cell biology, 13(2):351–363.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Donald J Rose</author>
<author>R Endre Tarjan</author>
<author>George S Leuker</author>
</authors>
<title>Algorithmic aspects of vertex elimination on graphs.</title>
<date>1976</date>
<journal>SIAM Journal of Computing,</journal>
<volume>5</volume>
<issue>2</issue>
<contexts>
<context position="5768" citStr="Rose et al. (1976)" startWordPosition="992" endWordPosition="995"> of it in the form of a known language that possessed both of those characters. Is this a reasonable assumption? We have no evidence that it is. However, it’s certainly a more reasonable assumption than that required for a perfect phylogeny. We expect that often, data sets will not admit a CDP, and that, like for perfect phylogeny, the question will be: How far away are the data from admitting a CDP? Przytycka et al. (2006) prove that a set of characters admit a CDP if and only if their intersection graph is chordal. Chordal graphs are graphs with no induced cycles longer than three vertices. Rose et al. (1976) provide a linear-time recognition algorithm for chordal graphs. Graph G = (V, E) is an intersection graph of a family of sets S if there is a bijection F between V and S such that for every two sets s, t E S F(s) is adjacent to F(t) if and only if s intersects t. Set s intersects set t if they share at least one element. Given sets, we can compute their intersection graph in linear time. For an example of an intersection graph derived from a family of sets, see Figure 2. We can then determine if a set of characters admits a CDP in linear time. This approach to phylogeny was used by Przytycka </context>
</contexts>
<marker>Rose, Tarjan, Leuker, 1976</marker>
<rawString>Donald J. Rose, R. Endre Tarjan, and George S. Leuker. 1976. Algorithmic aspects of vertex elimination on graphs. SIAM Journal of Computing, 5(2):266–283.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>