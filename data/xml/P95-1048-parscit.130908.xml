<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.001744">
<title confidence="0.998784">
Semantic Information Preprocessing
for Natural Language Interfaces to Databases
</title>
<author confidence="0.988545">
Milan Mosny
</author>
<affiliation confidence="0.98628">
Simon Fraser University
</affiliation>
<address confidence="0.7469165">
Burnaby, BC V5A 1S6,
Canada
</address>
<email confidence="0.993443">
mosny@cs.sfu.ca
</email>
<sectionHeader confidence="0.993766" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999697444444445">
An approach is described for supplying se-
lectional restrictions to parsers in natural
language interfaces (NLIs) to databases by
extracting the selectional restrictions from
semantic descriptions of those NLIs. Au-
tomating the process of finding selectional
restrictions reduces NLI development time
and may avoid errors introduced by hand-
coding selectional restrictions.
</bodyText>
<sectionHeader confidence="0.9988" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999927888888889">
An approach is described for supplying selectional
restrictions to parsers in natural language interfaces
(NLIs) to databases. The work is based on Linguis-
tic Domain Theories (LDTs) (Rayner, 1993). In our
approach, we propose a restricted version of LDTs
(RLDTs), that can be normalized and in normal-
ized form used to construct selectional restrictions.
We assume that semantic description of NLIs is de-
scribed by such an RLDT.
The outline of the paper is as follows. Section
2 provides a brief summary of original LDTs, il-
lustrates how Abductive Equivalential Translation
(AET) (Rayner, 1993) can use them at run-time,
and describes RLDTs. Sections 3 and 4 describe off-
line processes - the normalization process and the
extraction of selectional restrictions from normalized
RLDTs respectively. Section 5 contains discussion,
including related and future work.
</bodyText>
<sectionHeader confidence="0.914937" genericHeader="method">
2 LDT, AET and RLDT
</sectionHeader>
<bodyText confidence="0.992190583333333">
LDT and AET. LDT was introduced for a sys-
tem, where input is a logical formula, whose predi-
cates approximately correspond to the content words
of the input utterance in natural language (lexical
predicates). Output is a logical formula, consist-
ing of predicates meaningful to the database engine
(database predicates). AET provides a formalism
for describing how a formula consisting of lexical
predicates can be tranlsated into formula consisting
of database predicates. The information used in the
translation process is an LDT. A theory r contains
horn clauses
</bodyText>
<equation confidence="0.924917">
V(Pi A • • • A Pn --0 Q)
or universal conditional equivalences
V(Pi A • • • A Pn (14 A • • A Ili F))
or existential equivalences
V((3X1 • F)
</equation>
<bodyText confidence="0.999659888888889">
where Pi, Ri denote atomic formulas, Q denotes a
literal, F denotes a formula and V denotes universal
closure. The LDT also contains functional relation-
ships that are used for simplifications of the trans-
lated formulas and assumption declarations. Given a
formula Funs, consisting of lexical predicates and an
LDT, AET tries to find a set of permissible assump-
tions A and a formula Fdb consisting of the database
predicates such that
</bodyText>
<equation confidence="0.776035">
U A V (FlingL.= Fa)
</equation>
<bodyText confidence="0.984289636363636">
The translation of Fung is done one predicate at a
time. For each predicate in the formula Fling, there
is a so-called conjunctive context that consists of
conjuncts occurring together with the predicate in
Fur,g, meaning postulates in the theory r, and the
information stored in the database. Given an LDT,
this conjunctive context determines how the predi-
cate will be translated by AET.
As an example, suppose that the lexical represen-
tation of the sentence Is there a student who takes
cmpt710 or cmpt720? is Fung:
</bodyText>
<equation confidence="0.912929666666667">
3X, E ,Y, Yl.student(X) A
(take(E , X ,Y) A unknown(Y,cmpt710) V
take(E, X, Y1) A unknown(Yi, cmpt720))
</equation>
<bodyText confidence="0.739897">
Suppose that the theory r consists of axioms:
</bodyText>
<equation confidence="0.9841805">
V X .student(X) db_student(X) (1)
VX, E, Y, S.db_course(Y, S) A db_student(X) (2)
(take(E , X ,Y) db_take(E, X ,Y))
VX, S.acourse(S) (3)
(unknown(X , S) db_course(X, S))
VE, X,Y.db_take(E, X, Y) take(E, X, Y) (4)
</equation>
<page confidence="0.979718">
314
</page>
<bodyText confidence="0.992587428571429">
where student, take and unknown are lexical
predicates and db_student, db_course, db_take are
database predicates&apos;. Also suppose, that the LDT
declares as an assumption acourse(X), which can be
read as &amp;quot;X denotes a course&amp;quot;.
Part of the conjunctive context associated with
formula take(E, X ,Y) in Fling is a formula (5).
</bodyText>
<equation confidence="0.980456">
student(X) A unknown(Y, empt710) (5)
</equation>
<bodyText confidence="0.535922">
From (1) and (3) of the theory r it follows that (5)
implies the formula (6):
</bodyText>
<equation confidence="0.938458">
db_student(X) A db_course(Y, cmpt710) (6)
</equation>
<bodyText confidence="0.989803">
According to the translation rules of AET, axiom
(2), and a logical consequence of a conjunctive con-
text (6), the formula take(E, X, Y) can be translated
into formula (7)
</bodyText>
<equation confidence="0.856742">
dbiake(E, X ,Y) (7)
Formulas student(X), take(E , X ,Yi),
</equation>
<bodyText confidence="0.99837975">
unknown(Y, cmpt710) and unknown(Yi, empt720)
are translated similarly. Assuming cmpt710 and
cmpt720 are courses, the input Fling can be
rewritten into Fdb shown below.
</bodyText>
<equation confidence="0.978774333333333">
3X, E, Y, YI.db_student(X) A
(db_take(E, X, Y) A db_course(Y, cmpt710) V
db_take(E, X, Y1) A db_course(Yi,cmpt720))
</equation>
<bodyText confidence="0.989234307692308">
So we can claim that Fdb and Piing are equivalent
in the theory r under an assumption that cmpt710
and cmpt720 are courses.
RLDT. We shall constrain the expressive power of
the LDT to suit tractability and efficiency require-
ments.
We assume that the input is a logical formula,
whose predicates are input predicates. We assume
that input predicates are not only lexical predicates,
but also unresolved predicates used for, e.g., com-
pound nominals (Alshawi, 1992), or for unknown
words, as was demonstrated in the example above,
or synonymous predicates that allow us to represent
two or more different words with only one symbol.
The output will be a logical formula consisting
of output predicates. We do not suppose that the
output formula contains pure database predicates.
However, we allow further translation of the output
formula into database formulae using only existen-
tial conditional equivalences. The process can be
implemented very efficiently, and does not affect se-
lectional restrictions of the input language.
We assume that each atomic formula with input
predicates can be translated into an atomic formula
with output predicates. An RLDT therefore also
&apos;The predicate unknown will be discussed in the next
section.
contains a dictionary of atomic formulas that spec-
ifies which input atomic formulas can be translated
into which output atomic formulas.
Existential equivalences in RLDT&apos;s logic will not
be allowed. We also assume that F in the universal
conditional equivalences is a conjunction of atomic
formulas rather than arbitrary formula.
We demand that an RLDT be nonrecursive. In-
formally RLDT nonrecursivness means that for any
set of facts A, if there is a Prolog-like derivation of an
atomic formula F in the theory I&apos; LIA, then there is
a Prolog-like derivation of F without recursive calls.
</bodyText>
<sectionHeader confidence="0.98807" genericHeader="method">
3 The Normalization Process
</sectionHeader>
<bodyText confidence="0.998214866666667">
Our basic idea is to preprocess the semantic informa-
tion of RLDT to create patterns of possible conjunc-
tive contexts for each lexical predicate. The result
of the preprocessing is a normalized RLDT: the col-
lection of the lexical predicates, their meanings in
terms of the database, and the patterns of the con-
junctive contexts.
First we introduce the term (Nontrivial) Normal
Conditional Equivalence with respect to an RLDT T
((N)NCE(T)).
Definition: Let T be an RLDT and r be a logi-
cal part of T. The quadruple (A, C, Finput, Foutput)
is NCE(T) iff C is a conjunction of input atomic for-
mulas of T, A is a conjunction of assumptions of T,
and formulas
</bodyText>
<equation confidence="0.3189875">
V(A A C (Finput Foutput))
V(A A Foutput Finput)
</equation>
<bodyText confidence="0.99866212">
are logical consequences of the theory r (we
shall refer to the last condition as sound-
ness of the NCE(T)). We shall call the
quadruple (A, C, Finput, Foutput) nontrivial NCE(T)
(NNCE(T)) if formula C A A does not imply truth
of Foutput in the theory F.
Informally it means that Finput can be rewritten
to Foutput if its conjunctive context implies A and
does not imply the negation of C. (A, C) thus can
be viewed as a pattern of conjunctive contexts, that
justifies translation of Finput to Foutput•
We allow RLDTs to form theory hierarchies,
where parent theories can use results of their chil-
dren&apos;s normalization process as their own logical
part.
Given an RLDT T, for each pair consisting of the
ground lexical atomic formula Finput and the ground
database atomic formula Foutput from the dictionary
of T, we find the set S of conditions (A, C) such that
(A, C, Finput, Foutput) is NCE(T). We shall call the
set of all such NCE(T)s a normalized RLDT.
If Finput and Fontput contain constants that do not
occur in the logic of RLDT, the generalization rule
of FOL can be used to derive more general results
by replacing the constants by unique variables.
</bodyText>
<page confidence="0.998301">
315
</page>
<bodyText confidence="0.95230035">
If the T does not contain negative horn clauses of
the form P notQ then the following completeness
property can be proven:
If (A1, C1, Finput, Foutput) is NNCE(T) and S is
a resulting set for the pair F.:
then
- .nput) Foutput
there are conditions (A, C) in S, such that AAC
is weaker or equivalent to A1 A
The normalization process itself is based on SLD-
resolution(Lloyd, 1987) which we have chosen be-
cause it is fast, sound and complete but still provides
enough reasoning power.
Using the example from the previous section, the
normalization algorithm when given the
pairs (student(a), db_student(a)), (unknown(a, b),
db_course(a,b)) and (tak e(e , a, b), db_take(e, a, b))
will produce the results {(true, true)],
{(acourse(b), true)} and {(acourse(X), student(a)
A unknown(b, X)} respectively.
</bodyText>
<sectionHeader confidence="0.994083" genericHeader="method">
4 The Construction of Selectional
Restrictions
</sectionHeader>
<bodyText confidence="0.999972066666667">
The normalized RLDT is used to construct selec-
tional restrictions.
We assign the tags &amp;quot;thing&amp;quot; or &amp;quot;attribute&amp;quot; to argu-
ment positions of the lexical predicates according to
what kind of restriction the predicate imposes on the
referent at its argument position. If the predicate is
a noun or the referent refers to an event, we assign
the tag &amp;quot;thing&amp;quot;. If the predicate explicitly specifies
that the referent has some attribute - e.g. predicate
big(X) specifies the size of the thing referenced by X
and predicate take(_, X, _) specifies that the person
referenced by X takes something - then we tag the
argument position with &amp;quot;attribute&amp;quot;.
The normalized RLDT allows us to compute which
&amp;quot;things&amp;quot; can be combined with which &amp;quot;attributes&amp;quot;.
That is, we can determine which words can be mod-
ified or complemented by which other words.
We assume that the normalized RLDT has cer-
tain properties. Every NCE(T) that describes
a translation of an &amp;quot;attribute&amp;quot; must also define
a &amp;quot;thing&amp;quot; that constrains the same referent, e.g.
the NCE(T) (true, person(X) A drives(E, X,Y),
big(Y), db_big_car(Y)) for translation of the pred-
icate big(Y) does not fulfil the requirement but
NCE(T) (true, car(Y), big(Y), db _big _car(Y)) does.
We also assume that if a certain &amp;quot;thing&amp;quot; does not
occur in any of the NCE(T)s that translates an &amp;quot;at-
tribute&amp;quot; then the &amp;quot;thing&amp;quot; cannot be combined with
the &amp;quot;attribute&amp;quot;.
Using the example above and the assignments
</bodyText>
<equation confidence="0.88427625">
student(X) X is a &amp;quot;thing&amp;quot;
unknown(X,S) X is a &amp;quot;thing&amp;quot;
take(E, X, Y) E is a &amp;quot;thing&amp;quot;, X and Y are
&amp;quot;attributes&amp;quot;
</equation>
<bodyText confidence="0.965709157894737">
we can infer that student(X) can be combined with
attribute take(_, X, _) but cannot have an attribute
take(_, _, X).
To simplify results, we divide &amp;quot;attributes&amp;quot; into
equivalence classes where two &amp;quot;attributes&amp;quot; are equiv-
alent if both attributes are associated with the same
set of &amp;quot;things&amp;quot; that the attributes can be combined
with. We then assign a set of representatives from
these classes to &amp;quot;things&amp;quot;.
To be able to produce more precise results, we dis-
tinguish between two &amp;quot;attributes&amp;quot; that describe the
same argument position of the same predicate ac-
cording to the &amp;quot;thing&amp;quot; in the other &amp;quot;attribute&amp;quot; po-
sition of the predicate, when needed. Consider for
example the preposition &amp;quot;on&amp;quot; as used in the phrases
&amp;quot;on the table&amp;quot; or &amp;quot;on Monday&amp;quot;. We handle the first
argument position of a predicate on(X,Y) associ-
ated with the condition table(Y) as a different &amp;quot;at-
tribute&amp;quot; as compared to the condition monday(Y).
</bodyText>
<sectionHeader confidence="0.999889" genericHeader="conclusions">
5 Discussion
</sectionHeader>
<bodyText confidence="0.999913444444445">
Automating the process of finding selectional restric-
tions reduces NLI development time and may avoid
errors introduced by hand-coding selectional restric-
tions. Althcugh the preprocessing is computation-
ally intensive, it is done off-line during the delevop-
ment of the NLI.
A similar approach was proposed in (Alshawi,
1992) but a different method was suggested. (Al-
shawi, 1992) derives selectional restrictions from
the types associated with the database predicates,
whereas our approach uses only the constraints that
the RLDT imposes on the input language.
Future work will explore other uses of normalized
RLDTs: to construct a sophisticated help system, to
lexicalize some small database domains, and to de-
velop more complex lexical entries. We shall also
consider the possible uses of our work in general
NLP.
</bodyText>
<sectionHeader confidence="0.999195" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.9972255">
The author would like to thank Fred Popowich and
Dan Fass for their valuable discussion and sugges-
tions. This work was partially supported by the Nat-
ural Sciences and Engineering Research Council of
Canada under research grant 0GP0041910, by the
Institute for Robotics and Intelligent Systems, and
by Faculty of Applied Sciences Graduate Fellowship
at Simon Frtser University.
</bodyText>
<sectionHeader confidence="0.999545" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999635111111111">
Alshawi, Hiyan, ed. 1992. The Core Language En-
gine. Cambridge, Massachusetts: The MIT Press.
Lloyd, John W., 1987. Foundations of Logic Pro-
gramming, Second, Extended Edition, Springer-
Verlag, New York.
Rayner, Manny, 1993. Abductive Eguivalential
Translation and its application to Natural Language
Database Interfacing. Ph.D. Thesis, Royal Institute
of Technology, Stockholm, Sweden.
</reference>
<page confidence="0.999279">
316
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.916508">
<title confidence="0.999226">Semantic Information Preprocessing for Natural Language Interfaces to Databases</title>
<author confidence="0.98593">Milan Mosny</author>
<affiliation confidence="0.989099">Simon Fraser University</affiliation>
<address confidence="0.9739455">Burnaby, BC V5A 1S6, Canada</address>
<email confidence="0.998732">mosny@cs.sfu.ca</email>
<abstract confidence="0.9982946">An approach is described for supplying selectional restrictions to parsers in natural language interfaces (NLIs) to databases by extracting the selectional restrictions from semantic descriptions of those NLIs. Automating the process of finding selectional restrictions reduces NLI development time and may avoid errors introduced by handcoding selectional restrictions.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Hiyan Alshawi</author>
<author>ed</author>
</authors>
<title>The Core Language Engine.</title>
<date>1992</date>
<booktitle>Foundations of Logic Programming, Second, Extended Edition,</booktitle>
<publisher>The MIT Press. Lloyd, John W.,</publisher>
<location>Cambridge, Massachusetts:</location>
<marker>Alshawi, ed, 1992</marker>
<rawString>Alshawi, Hiyan, ed. 1992. The Core Language Engine. Cambridge, Massachusetts: The MIT Press. Lloyd, John W., 1987. Foundations of Logic Programming, Second, Extended Edition, SpringerVerlag, New York.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Manny Rayner</author>
</authors>
<title>Abductive Eguivalential Translation and its application to Natural Language Database Interfacing.</title>
<date>1993</date>
<tech>Ph.D. Thesis,</tech>
<institution>Royal Institute of Technology,</institution>
<location>Stockholm,</location>
<contexts>
<context position="751" citStr="Rayner, 1993" startWordPosition="101" endWordPosition="102">anada mosny@cs.sfu.ca Abstract An approach is described for supplying selectional restrictions to parsers in natural language interfaces (NLIs) to databases by extracting the selectional restrictions from semantic descriptions of those NLIs. Automating the process of finding selectional restrictions reduces NLI development time and may avoid errors introduced by handcoding selectional restrictions. 1 Introduction An approach is described for supplying selectional restrictions to parsers in natural language interfaces (NLIs) to databases. The work is based on Linguistic Domain Theories (LDTs) (Rayner, 1993). In our approach, we propose a restricted version of LDTs (RLDTs), that can be normalized and in normalized form used to construct selectional restrictions. We assume that semantic description of NLIs is described by such an RLDT. The outline of the paper is as follows. Section 2 provides a brief summary of original LDTs, illustrates how Abductive Equivalential Translation (AET) (Rayner, 1993) can use them at run-time, and describes RLDTs. Sections 3 and 4 describe offline processes - the normalization process and the extraction of selectional restrictions from normalized RLDTs respectively. </context>
</contexts>
<marker>Rayner, 1993</marker>
<rawString>Rayner, Manny, 1993. Abductive Eguivalential Translation and its application to Natural Language Database Interfacing. Ph.D. Thesis, Royal Institute of Technology, Stockholm, Sweden.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>