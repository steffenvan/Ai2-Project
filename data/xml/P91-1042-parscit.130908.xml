<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000013">
<sectionHeader confidence="0.623293" genericHeader="abstract">
UNIFICATION WITH LAZY NON-REDUNDANT COPYING
</sectionHeader>
<author confidence="0.5860345">
Martin C. Emele*
Project Polygloss
</author>
<affiliation confidence="0.938364">
University of Stuttgart
</affiliation>
<address confidence="0.751773">
IMS-CL/Ifl-AIS, KeplerstraBe 17
D 7000 Stuttgart 1, FRG
</address>
<email confidence="0.825858">
emeleCtinformatik.uni-stuttgart.de
</email>
<sectionHeader confidence="0.870726" genericHeader="keywords">
Abstract
</sectionHeader>
<bodyText confidence="0.999765266666667">
This paper presents a unification pro-
cedure which eliminates the redundant
copying of structures by using a lazy in-
cremental copying approach to achieve
structure sharing. Copying of structures
accounts for a considerable amount of
the total processing time. Several meth-
ods have been proposed to minimize the
amount of necessary copying. Lazy In-
cremental Copying (LIC) is presented as
a new solution to the copying problem.
It synthesizes ideas of lazy copying with
the notion of chronological dereferencing
for achieving a high amount of structure
sharing.
</bodyText>
<sectionHeader confidence="0.958231" genericHeader="introduction">
Introduction
</sectionHeader>
<bodyText confidence="0.999881785714286">
Many modern linguistic theories are using fea-
ture structures (FS) to describe linguistic objects
representing phonological, syntactic, and semantic
properties. These feature structures are specified
in terms of constraints which they must satisfy.
It seems to be useful to maintain the distinction
between the constraint language in which feature
structure constraints are expressed, and the struc-
tures that satisfy these constraints. Unification is
the primary operation for determining the satisfia-
bility of conjunctions of equality constraints. The
efficiency of this operation is thus crucial for the
overall efficiency of any system that uses feature
structures.
</bodyText>
<subsectionHeader confidence="0.969473">
Typed Feature Structure Unification
</subsectionHeader>
<bodyText confidence="0.964107441860465">
In unification-based grammar formalisms, unifica-
tion is the meet operation on the meet semi-lattice
formed by partially ordering the set of feature
structures by a subsumption relation [Shieber 86].
Following ideas presented by [Kit-Kaci 84] and
introduced, for example, in the unification-based
formalism underlying HPSG [Pollard and Sag 87],
first-order unification is extended to the sorted
case using an order-sorted signature instead of a
flat one.
In most existing implementations, descriptions
of feature structure constraints are not directly
used as models that satisfy these constraints; in-
stead, they are represented by directed graphs
(DG) serving as satisfying models. In particular,
in the case where we are dealing only with con-
junctions of equality constraints, efficient graph
unification algorithms exist. The graph unifica-
tion algorithm presented by Ait-Kaci is a node
merging process using the UNION/FIND method
(originally used for testing the equivalence of -fi-
nite automata [Hoperoft/Karp 71]). It has its
analogue in the unification algorithm for rational
terms based on a fast procedure for congruence
closure [Huet 76].
Node merging is a destructive operation
Since actual merging of nodes to build new
node equivalence classes modifies the argument
DGs, they must be copied before unification is in-
voked if the argument DGs need to be preserved.
For example, during parsing there are two kinds of
representations that must be preserved: first, lexi-
cal entries and rules must be preserved. They need
to be copied first before a destructive unification
operation can be applied to combine categories to
form new ones; and second, nondeterminism in
parsing requires the preservation of intermediate
representations that might be used later when the
parser comes back to a choice point to try some
yet unexplored options.
•Research reported in this paper is partly supported by the German Ministry of Research and Technology (BMFT, Bun-
desminister fur Forschung und Technologie), under grant No. 08 B3116 3. The views and conclusions contained herein are
those of the authors and should not be interpreted as representing official policies.
</bodyText>
<page confidence="0.998476">
323
</page>
<bodyText confidence="0.981654826086957">
DG copying as a source of inefficiency
Previous research on unification, in partic-
ular on graph unification [Karttunen/K ay 85,
Pereira 85], and others, identified DG copying as
the main source of inefficiency. The high cost in
terms of time spent for copying and in terms of
space required for the copies themselves accounts
for a significant amount of the total processing
time. Actually, more time is spent for copying
than for unification itself. Hence, it is crucial to
reduce the amount of copying, both in terms of
the number and of the size of copies, in order to
improve the efficiency of unification.
A naive implementation of unification would
copy the arguments even before unification starts.
That is what [Wroblewski 87] calls early copying.
Early copying is wasted effort in cases of fail-
ure. He also introduced the notion of over copy-
ing, which results from copying both arguments in
their entirety. Since unification produces its result
by merging the two arguments, the result usually
contains significantly fewer nodes than the sum of
the nodes of the argument DGs.
</bodyText>
<subsectionHeader confidence="0.995546">
Incremental Copying
</subsectionHeader>
<bodyText confidence="0.999886142857143">
Wroblewski&apos;s nondestructive graph unification
with incremental copying eliminates early copy-
ing and avoids over copying. His method pro-
duces the resulting DG by incrementally copying
the argument DGs. An additional copy field in
the DG structure is used to associate temporary
forwarding relationships to copied nodes. Only
those copies are destructively modified. Finally,
the copy of the newly constructed root will be re-
turned in case of success, and all the copy pointers
will be invalidated in constant time by increment-
ing a global generation counter without traversing
the arguments again, leaving the arguments un-
changed.
</bodyText>
<subsectionHeader confidence="0.988311">
Redundant Copying
</subsectionHeader>
<bodyText confidence="0.999882142857143">
A problem arises with Wroblewski&apos;s account,
because the resulting DG consists only of newly
created structures even if parts of the input DGs
that are not changed could be shared with the re-
sultant DG. A better method would avoid (elim-
inate) such redundant copying as it is called by
[Kogure 90].
</bodyText>
<subsectionHeader confidence="0.99554">
Structure Sharing
</subsectionHeader>
<bodyText confidence="0.998940954545455">
The concept of structure sharing has been intro-
duced to minimize the amount of copying by allow-
ing DGs to share common parts of their structure.
The Boyer and Moore approach uses a
skeleton/environment representation for structure
sharing. The basic idea of structure sharing pre-
sented by [Pereira 85], namely that an initial ob-
ject together with a list of updates contains the
same information as the object that results from
applying the updates destructively to the initial
object, uses a variant of Boyer and Moore&apos;s ap-
proach for structure sharing of term structures
[Boyer/Moore 72]. The method uses a skeleton for
representing the initial DG that will never change
and an environment for representing updates to
the skeleton. There are two kinds of updates:
reroutings that forward one DG node to another;
arc bindings that add to a node a new arc.
Lazy Copying as another method to achieve
structure sharing is based on the idea of lazy
evaluation. Copying is delayed until a destruc-
tive change is about to happen. Lazy copy-
ing to achieve structure sharing has been sug-
gested by [Karttunen/Kay 85], and lately again
by [Godden 90] and [Kogure 90].
Neither of these methods fully avoids redun-
dant copying in cases when we have to copy a
node that is not the root. In general, all nodes
along the path leading from the root to the site
of an update need to be copied as well, even if
they are not affected by this particular unifica-
tion step, and hence could be shared with the re-
sultant DG. Such cases seem to be ubiquitous in
unification-based parsing since the equality con-
straints of phrase structure rules lead to the unifi-
cation of substructures associated with the imme-
diate daughter and mother categories. With re-
spect to the overall structure that serves as the re-
sult of a parse, these unifications of substructures
are even further embedded, yielding a considerable
amount of copying that should be avoided.
All of these methods require the copying of arcs
to a certain extent, either in the form of new arc
bindings or by copying arcs for the resultant DG.
</bodyText>
<subsectionHeader confidence="0.668156">
Lazy Incremental Copying
</subsectionHeader>
<bodyText confidence="0.999947">
We now present Lazy Incremental Copying (LIC)
as a new approach to the copying problem. The
method is based on Wroblewski&apos;s idea of incremen-
tally producing the resultant DG while unification
proceeds, making changes only to copies and leav-
ing argument DGs untouched. Copies are associ-
ated with nodes of the argument DGs by means
</bodyText>
<page confidence="0.99797">
324
</page>
<figureCaption confidence="0.999861">
Figure 1: Chronological dereferencing.
</figureCaption>
<bodyText confidence="0.99998255">
of an additional copy field for the data structures
representing nodes. But instead of creating copies
for all of the nodes of the resultant DG, copying
is done lazily. Copying is required only in• cases
where an update to an initial node leads to a de-
structive change.
The Lazy Incremental Copying method con-
stitutes a synthesis of Pereira&apos;s structure sharing
approach and VVroblewski&apos;s incremental copying
procedure combining the advantages and avoid-
ing disadvantages of both methods. The struc-
ture sharing scheme is imported into Wroblewski &apos;s
method eliminating redundant copying. Instead of
using a global branch environment as in Pereira&apos;s
approach, each node records it&apos;s own updates by
means of the copy field and a generation counter.
The advantages are a uniform unification proce-
dure which makes complex merging of environ-
ments obsolete and which can be furthermore eas-
ily extended to handle disjunctive constraints.
</bodyText>
<subsectionHeader confidence="0.818932">
Data Structures
</subsectionHeader>
<table confidence="0.8847045">
CopyNode structure
type: &lt;symbol&gt;
arcs: &lt;a list of ARCs&gt;
copy: &lt;a pointer to a CopyNode&gt;
generation: &lt;an integer&gt;
ARC structure
label: &lt;symbol&gt;
dest: &lt;a CopyNode&gt;
</table>
<subsectionHeader confidence="0.824906">
Dereferencing
</subsectionHeader>
<bodyText confidence="0.999948489361702">
The main difference between standard unification
algorithms and LIC is the treatment of dereference
pointers for representing node equivalence classes.
The usual dereferencing operation follows a possi-
ble pointer chain until the class representative is
found, whereas in LIC dereferencing is performed
according to the current environment. Each copy-
node carries a generation counter that indicates
to which generation it belongs. This means that
every node is connected with its derivational con-
text. A branch environment is represented as a se-
quence of valid generation counters (which could
be extended to trees of generations for represent-
ing local disjunctions). The current generation is
defined by the last element in this sequence. A
copynode is said to be an active node if it was
created within the current generation.
Nondeterminism during parsing or during the
processs of checking the satisfiability of constraints
is handled through chronological backtracking, i.e.
in case of failure the latest remaining choice is re-
examined first. Whenever we encounter a choice
point, the environment will be extended. The
length of the environment corresponds to the num-
ber of stacked choice points. For every choice point
with n possible continuations, n — 1 new gener-
ation counters are created. The last alternative
pops the last element from the environment, con-
tinues with the old environment and produces n
DG representations, one for each alternative. By
going back to previous generations, already exist-
ing nodes become active nodes, and are thus mod-
ified destructively. This technique resembles the
last call optimization technique of some Prolog im-
plementations, e.g. for the WAM [Warren83]. The
history of making choices is reflected by the deref-
erencing chain for each node which participated in
different unifications.
Figure 1 is an example which illustrates how
dereferencing works with respect to the environ-
ment: node b is the class representative for envi-
ronment &lt;0&gt;, node c is the result of dereferenc-
ing for environments &lt;0 1&gt; and &lt;0 1 2&gt;, and fi-
nally node f corresponds to the representative for
the environment &lt;0 i 2 3&gt; and all further exten-
sions that did not add a new forwarding pointer
to newly created copynodes.
</bodyText>
<page confidence="0.997919">
325
</page>
<tableCaption confidence="0.758002">
Case 1: destructive merge
Cass 3: forwarding to the acthre node
</tableCaption>
<figure confidence="0.4483525">
e-
Case 3: incremental copying by creating a new active node
</figure>
<figureCaption confidence="0.969056">
Figure 2: Node merging.
</figureCaption>
<bodyText confidence="0.910318142857143">
Advantages of this new dereferencing scheme
are:
• It is very easy to undo the effects of uni-
fication upon backtracking. Instead of us-
ing trail information which records the nodes
that must be restored in case of returning to
a previous choice point, the state of com-
putation at that choice point is recovered in
constant time by activating the environment
which is associated with that choice point.
Dereferencing with respect to the environ-
ment will assure that the valid class repre-
sentative will always be found. Pointers to
nodes that do not belong to the current en-
vironment are ignored.
• It is no longer necessary to distinguish be-
tween the forward and copy slot for repre-
senting permanent and temporary relation-
ships as it was needed in Wroblewski&apos;s algo-
rithm. One copy field for storing the copy
pointer is sufficient, thus reducing the size
of node structures. Whether a unification
leads to a destructive change by performing
a rerouting that can not be undone, or to
a nondestructive update by rerouting to a
copynode that belongs to a higher genera-
tion, is reexpressed by means of the environ-
ment.
</bodyText>
<subsectionHeader confidence="0.920068">
Lazy Non-redundant Copying
</subsectionHeader>
<bodyText confidence="0.996908909090909">
Unification itself proceeds roughly like a standard
destructive graph unification algorithm that has
been adapted to the order-sorted case. The dis-
tinction between active and non-active nodes al-
lows us to perform copying lazily and to eliminate
redundant copying completely.
Recall that a node is an active one if it belongs
to the current generation. We distinguish between
three cases when we merge two nodes by unifying
them: (i) both are active nodes, (ii) either one of
them is active, or (iii) they are both non-active.
In the first case, we yield a destructive merge ac-
cording to the current generation. No copying has
to be done. If either one of the two nodes is ac-
tive, the non-active node is forwarded to the ac-
tive one. Again, no copying is required. When we
reset computation to a previous state where the
non-active node is reactivated, this pointer is ig-
nored. In the third case, if there is no active node
yet, we know that a destructive change to an en-
vironment that must be preserved could occur by
building the new equivalence class. Instead, a new
copynode will be created under the current active
generation and both nodes will be forwarded to the
new copy. (For illustration cf. Figure 2.) Notice
that it is not necessary to copy arcs for the method
presented here. Instead of collecting all arcs while
dereferencing nodes, they are just carried over to
new copynodes without any modification. That is
done as an optimization to speed up the compu-
tation of arcs that occur in both argument nodes
to be unified (SharedArcs) and the arcs that are
unique with respect to each other (UniqueArcs).
</bodyText>
<page confidence="0.996027">
326
</page>
<figure confidence="0.849033">
rem
</figure>
<figureCaption confidence="0.99704">
Figure
Figure 3: A unification example.
</figureCaption>
<bodyText confidence="0.999987277777778">
The unification algorithm is shown in Fig-
ure 4 and Figure 3 illustrates its application to
a concrete example of two successive unifications.
Copying the nodes that have been created by the
first unification do not need to be copied again for
the second unification that is applied at the node
appearing as the value of the path pred. verb,
saving five copies in comparison to the other lazy
copying methods.
Another advantage of the new approach is
based on the ability to switch easily between de-
structive and non-destructive unification. During
parsing or during the process of checking the satis-
fiability of constraints via backtracking, there are
in general several choice points. For every choice
point with n possible continuations, n — 1 lazy
incremental copies of the DG are made using non-
destructive unification. The last alternative con-
tinues destructively, resembling the last call op-
timization technique of Prolog implementations,
yielding n DG representations, one for each al-
ternative. Since each node reflects its own up-
date history for each continuation path, all un-
changed parts of the DG are shared. To sum
up, derived DG instances are shared with input
DG representations and updates to certain nodes
by means of copy nodes are shared by different
branches of the search space. Each new update
corresponds to a new choice point in chronological
order. The proposed environment representation
facilitates memory management for allocating and
deallocating copy node structures which is very
important for the algorithm to be efficient. This
holds, in particular, if it takes much more time to
create new structures than to update old reclaimed
structures.
</bodyText>
<subsectionHeader confidence="0.960435">
Comparison with other Approaches
</subsectionHeader>
<bodyText confidence="0.999470052631579">
Karttunen&apos;s Reversible Unification [Karttunen 86]
does not use structure sharing at all. A new DG is
copied from the modified arguments after success-
ful unification, and the argument DGs are then
restored to their original state by undoing all the
changes made during unification hence requiring a
second pass through the DG to assemble the result
and adding a constant time for the save operation
before each modification.
As it has been noticed by [Godden 90] and
[Kogure 90], the key idea of avoiding &amp;quot;redundant
copying&amp;quot; is to do copying lazily. Copying of nodes
will be delayed until a destructive change is about
to take place.
Godden uses active data structures (Lisp clo-
sures) to implement lazy evaluation of copying,
and Kogure uses a revised copynode procedure
which maintains copy dependency information in
order to avoid immediate copying.
</bodyText>
<page confidence="0.991512">
327
</page>
<figure confidence="0.605417411764706">
procedure unify(node1,node2 : CopyNode)
node1 4-- deref(node1)
node2 4-- deref(node2)
IF node1 = node2 THIN return(nodel)
ELSE
newtype 4-- nodei.type A node2.type
IF newtype = I MIN return(1)
ELSE
&lt;SharedArcsl, SharedArcs2&gt; 4-- SharedArcs(node1,node2)
&lt;UniqueArcs1, UniqueArcs2&gt; UniqueArcs(node1,node2)
IF ActiveP(node1) THEN
node 4-- node1
node.arcs 4-- node.arcs U UniqueArcs2
node2.copy 4-- node
ELSE
IF ActiveP(node2) THEN
node node2
node.arcs 4-- node.arcs U UniqueArcs1
nodel.copy 4-- node
ELSE
node 4-- CreateCopyNode
node1.copy 4-- node
node2.copy 4-- node
node.arcs 4-- UniqueArcsi U SharedArcs1 U UniqueArcs2
ENDIF
ENDIF
node.type 4-- newtype
FOR EACH &lt;SharedArc1, SharedArc2&gt;
IN &lt;SharedArcs1, SharedArcs2&gt;
DO unify(5haredArc1.dest,SharedArc2.dest)
return (node)
ENDIF
ENDIF
FNI) unify
</figure>
<figureCaption confidence="0.997941">
Figure 4: The unification procedure
</figureCaption>
<table confidence="0.369388454545454">
approach methods
early over redundant incr. lazy structure
copying copying copying copying copying sharing
naive yes yes yes no no no
Pereira 85 no no no no no yes
Karttunen/Kay 85 no no yes no yes yes
Karttunen 86 no no yes no no no
Wroblewski 87 no yes yes yes no no
Godden 90 no no yes no yes yes
Kogure 90 no yes yes no yes yes
LIC no yes no yes yes yes
</table>
<figureCaption confidence="0.999539">
Figure 5: Comparison of unification approaches
</figureCaption>
<bodyText confidence="0.999938838709677">
Both of these approaches suffer from difficul-
ties of their own. In Godden&apos;s case, part of the
copying is substituted/traded for by the creation
of active data structures (Lisp closures), a poten-
tially very costly operation, even where it would
turn out that those closures remain unchanged in
the final result; hence their creation is unneces-
sary. In addition, the search for already existing
instances of active data structures in the copy en-
vironment and merging of environments for suc-
cessive unifications causes an additional overhead.
Similarly, in Kogure&apos;s approach, not all redun-
dant copying is avoided in cases where there exists
a feature path (a sequence of nodes connected by
arcs) to a node that needs to be copied. All the
nodes along such a path must be copied, even if
they are not affected by the unification procedure.
Furthermore, special copy dependency informa-
tion has to be maintained while copying nodes in
order to trigger copying of such arc sequences lead-
ing to a node where copying is needed later in the
process of unification. In addition to the overhead
of storing copy dependency information, a second
traversal of the set of dependent nodes is required
for actually performing the copying. This copying
itself might eventually trigger further copying of
new dependent nodes.
The table of Figure 5 summarizes the different
unification approaches that have been discussed
and compares them according to the concepts and
methods they use.
</bodyText>
<sectionHeader confidence="0.964233" genericHeader="conclusions">
Conclusion
</sectionHeader>
<bodyText confidence="0.999969685714285">
The lazy-incremental copying (LIC) method used
for the unification algorithm combines incremen-
tal copying with lazy copying to achieve structure
sharing. It eliminates redundant copying in all
cases even where other methods still copy over.
The price to be paid is counted in terms of the
time spent for dereferencing but is licensed for by
the gain of speed we get through the reduction
both in terms of the number of copies to be made
and in terms of the space required for the copies
themselves.
The algorithm has been implemented in Com-
mon Lisp and runs on various workstation ar-
chitectures. It is used as the essential oper-
ation in the implementation of the interpreter
for the Typed Features Structure System (TFS
[Emele/Zajac 90a, Emele/Zajac 90b]). The for-
malism of TFS is based on the notion of inher-
itance and sets of constraints that categories of
the sort signature must satisfy. The formalism
supports to express directly principles and gen-
eralizations of linguistic theories as they are for-
mulated for example in the framework of HPSG
[Pollard and Sag 87]. The efficiency of the LIC ap-
proach has been tested and compared with Wrob-
lewski&apos;s method on a sample grammar of HPSG
using a few test sentences for parsing and gener-
ation. The overall processing time is reduced by
60% — 70% of the original processing time. See
[Emele 91] for further discussion of optimizations
available for specialized applications of this gen-
eral unification algorithm. This paper also pro-
vides a detailed metering statistics for all of the
other unification algorithms that have been com-
pared.
</bodyText>
<sectionHeader confidence="0.996404" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.7743452">
[Alt-Kaci 84] Hassan Ait-Kaci. A Lattice Theo-
retic Approach to Computation based on a Cal-
culus of Partially Ordered Types Structures.
Ph.D Dissertation, University of Pennsylvania,
1984.
</reference>
<bodyText confidence="0.734058333333333">
[Ait-Kaci 86] Hassan lat-Kaci. An algebraic se-
mantics approach to the effective resolution of
type equations. Theoretical Computer Science
.45, pp. 293-351,1986
[Boyer/Moore 72] R. S. Boyer and J. S. Moore.
The sharing of structures in theorem-proving
programs. In B. Meltzer and D. Mitchie (eds.),
Machine Intelligence 7, pp. 101-116, John Wi-
ley and Sons, New York, New York, 1972.
</bodyText>
<reference confidence="0.996075173333333">
[Emele/Zajac 90a] Martin C. Emele and Remi Za-
jac. A fix-point semantics for feature type sys-
tems. In Proceedings of the 2&amp;quot;d International
Workshop on Conditional and Typed Rewriting
Systems, CTRS&apos;90, Montreal, June 1990.
[Emele/Zajac 9013] Martin C. Emele and Remi
Zajac. Typed unification grammars. In Proceed-
ings of 13th International Conference on Com-
putational Linguistics, COLING-90, Helsinki,
August 1990.
[Emele 91] Martin C. Emele. Graph Unification
using Lazy Non-Redundant Copying. Techni-
cal Report AIMS 04-91, Institut fiir maschinelle
Sprachverarbeitung, University of Stuttgart,
1991.
[Godden 90] Kurt Godden. Lazy unification. In
Proceedings of the 28t1 Annual Meeting of
the Association for Computational Linguistics,
ACL, pp. 180-187, Pittsburgh, PA, 1990.
[Huet 76] Gerard Huet. Resolution d&apos;Equations
dans des Langages d&apos;Ordre 1, 2, ..., i. These
de Doctorat d&apos;Etat, Universite de Paris VII,
France. 1976.
[lloperoft/Karp 71] J. E. Hoperoft and R. M.
Karp. An Algorithm for testing the Equivalence
of Finite Automata. Technical report TR-71-
114, Dept. of Computer Science, Cornell Uni-
versity, Ithaca, NY, 1971.
[Karttunen 86] Lauri Karttunen. D-PATR: A De-
velopment Environment for Unification-Based
Grammars. Technical Report CSLI-86-61, Cen-
ter for the Study of Language and Information,
Stanford, August, 1986.
[Karttunen/Kay 85] Lauri Karttunen and Mar-
tin Kay. Structure sharing with binary trees.
In Proceedings of the 23rd Annual Meeting of
the Association for Computational Linguistics,
ACL, pp. 133-136a, Chicago, IL, 1985.
[Kogure 90] Kiyoshi Kogure. Strategic lazy in-
cremental copy graph unification. In Proceed-
ings of the 13th Intl. Conference on Compu-
tational Linguistics, COLING-90, pp. 223-228,
Helsinki, 1990.
[Pereira 85] Fernando C.N. Pereira. A structure-
sharing representation for unification-based
grammar formalisms. In Proceedings of the
23rd Annual Meeting of the Association for
Computational Linguistics, ACL, pp. 137-144,
Chicago, IL, 1985.
[Pereira/Shieber 84] Fernando C.N. Pereira and
Stuart Shieber. The semantics of grammar for-
malisms seen as computer languages. In Pro-
ceedings of the 10th Intl. Conference on Com-
putational Linguistics, COLING-84, Stanford,
1984.
[Pollard and Sag 87] Carl Pollard and Ivan Sag.
Information-Based Syntax and Semantics, Vol-
ume I. CSLI Lecture Notes No 13. Chicago Uni-
versity Press, Chicago, 1987.
[Rounds/Kasper 86] Williams C. Rounds and R.
Kasper. A complete logical calculus for record
structures representing linguistic information.
In IEEE Symposium on Logic in Computer Sci-
ence, 1986.
[Shieber 86] Stuart M. Shieber. An Introduction
to Unification-based Approaches to Grammar.
CSLI Lecture Notes No 4. Chicago University
Press, Chicago, 1986.
[Warren 83] David H. D. Warren. An Abstract
Prolog Instruction Set. Technical Note 309, SRI
International, Menlo Park, CA, 1983.
[Wroblewski 87] David A. Wroblewski. Nonde-
structive graph unification. In Proceedings of
the 6th National Conference on Artificial Intel-
ligence, AAAI, pp. 582-587, Seattle, WA, 1987.
</reference>
<page confidence="0.99834">
330
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.512161">
<title confidence="0.998653">UNIFICATION WITH LAZY NON-REDUNDANT COPYING</title>
<author confidence="0.998999">Martin C Emele</author>
<affiliation confidence="0.968897">Project Polygloss University of Stuttgart</affiliation>
<address confidence="0.7554575">IMS-CL/Ifl-AIS, KeplerstraBe 17 D 7000 Stuttgart 1, FRG</address>
<email confidence="0.985003">emeleCtinformatik.uni-stuttgart.de</email>
<abstract confidence="0.9962495625">This paper presents a unification proeliminates the redundant copying of structures by using a lazy incremental copying approach to achieve structure sharing. Copying of structures accounts for a considerable amount of the total processing time. Several methods have been proposed to minimize the amount of necessary copying. Lazy Incremental Copying (LIC) is presented as a new solution to the copying problem. It synthesizes ideas of lazy copying with the notion of chronological dereferencing for achieving a high amount of structure sharing.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Hassan Ait-Kaci</author>
</authors>
<title>A Lattice Theoretic Approach to Computation based on a Calculus of Partially Ordered Types Structures. Ph.D Dissertation,</title>
<date>1984</date>
<institution>University of Pennsylvania,</institution>
<marker>[Alt-Kaci 84]</marker>
<rawString>Hassan Ait-Kaci. A Lattice Theoretic Approach to Computation based on a Calculus of Partially Ordered Types Structures. Ph.D Dissertation, University of Pennsylvania, 1984.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Martin C Emele</author>
<author>Remi Zajac</author>
</authors>
<title>A fix-point semantics for feature type systems.</title>
<date>1990</date>
<booktitle>In Proceedings of the 2&amp;quot;d International Workshop on Conditional and Typed Rewriting Systems, CTRS&apos;90,</booktitle>
<location>Montreal,</location>
<marker>[Emele/Zajac 90a]</marker>
<rawString>Martin C. Emele and Remi Zajac. A fix-point semantics for feature type systems. In Proceedings of the 2&amp;quot;d International Workshop on Conditional and Typed Rewriting Systems, CTRS&apos;90, Montreal, June 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Martin</author>
</authors>
<title>Emele and Remi Zajac. Typed unification grammars.</title>
<date>1990</date>
<booktitle>In Proceedings of 13th International Conference on Computational Linguistics, COLING-90,</booktitle>
<location>Helsinki,</location>
<marker>[Emele/Zajac 9013]</marker>
<rawString>Martin C. Emele and Remi Zajac. Typed unification grammars. In Proceedings of 13th International Conference on Computational Linguistics, COLING-90, Helsinki, August 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Martin C Emele</author>
</authors>
<title>Graph Unification using Lazy Non-Redundant Copying.</title>
<date>1991</date>
<tech>Technical Report AIMS 04-91,</tech>
<institution>Institut fiir maschinelle Sprachverarbeitung, University of Stuttgart,</institution>
<marker>[Emele 91]</marker>
<rawString>Martin C. Emele. Graph Unification using Lazy Non-Redundant Copying. Technical Report AIMS 04-91, Institut fiir maschinelle Sprachverarbeitung, University of Stuttgart, 1991.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kurt Godden</author>
</authors>
<title>Lazy unification.</title>
<date>1990</date>
<booktitle>In Proceedings of the 28t1 Annual Meeting of the Association for Computational Linguistics, ACL,</booktitle>
<pages>180--187</pages>
<location>Pittsburgh, PA,</location>
<marker>[Godden 90]</marker>
<rawString>Kurt Godden. Lazy unification. In Proceedings of the 28t1 Annual Meeting of the Association for Computational Linguistics, ACL, pp. 180-187, Pittsburgh, PA, 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gerard Huet</author>
</authors>
<title>Resolution d&apos;Equations dans des</title>
<date>1976</date>
<booktitle>Langages d&apos;Ordre 1, 2, ..., i. These de Doctorat d&apos;Etat, Universite de Paris VII,</booktitle>
<marker>[Huet 76]</marker>
<rawString>Gerard Huet. Resolution d&apos;Equations dans des Langages d&apos;Ordre 1, 2, ..., i. These de Doctorat d&apos;Etat, Universite de Paris VII, France. 1976.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J E Hoperoft</author>
<author>R M Karp</author>
</authors>
<title>An Algorithm for testing the Equivalence of Finite Automata.</title>
<date>1971</date>
<tech>Technical report TR-71-114,</tech>
<institution>Dept. of Computer Science, Cornell University,</institution>
<location>Ithaca, NY,</location>
<marker>[lloperoft/Karp 71]</marker>
<rawString>J. E. Hoperoft and R. M. Karp. An Algorithm for testing the Equivalence of Finite Automata. Technical report TR-71-114, Dept. of Computer Science, Cornell University, Ithaca, NY, 1971.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
</authors>
<title>D-PATR: A Development Environment for Unification-Based Grammars.</title>
<date>1986</date>
<tech>Technical Report CSLI-86-61,</tech>
<institution>Center for</institution>
<location>Stanford,</location>
<marker>[Karttunen 86]</marker>
<rawString>Lauri Karttunen. D-PATR: A Development Environment for Unification-Based Grammars. Technical Report CSLI-86-61, Center for the Study of Language and Information, Stanford, August, 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
<author>Martin Kay</author>
</authors>
<title>Structure sharing with binary trees.</title>
<date>1985</date>
<booktitle>In Proceedings of the 23rd Annual Meeting of the Association for Computational Linguistics, ACL,</booktitle>
<pages>133--136</pages>
<location>Chicago, IL,</location>
<marker>[Karttunen/Kay 85]</marker>
<rawString>Lauri Karttunen and Martin Kay. Structure sharing with binary trees. In Proceedings of the 23rd Annual Meeting of the Association for Computational Linguistics, ACL, pp. 133-136a, Chicago, IL, 1985.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kiyoshi Kogure</author>
</authors>
<title>Strategic lazy incremental copy graph unification.</title>
<date>1990</date>
<booktitle>In Proceedings of the 13th Intl. Conference on Computational Linguistics, COLING-90,</booktitle>
<pages>223--228</pages>
<location>Helsinki,</location>
<marker>[Kogure 90]</marker>
<rawString>Kiyoshi Kogure. Strategic lazy incremental copy graph unification. In Proceedings of the 13th Intl. Conference on Computational Linguistics, COLING-90, pp. 223-228, Helsinki, 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fernando C N Pereira</author>
</authors>
<title>A structuresharing representation for unification-based grammar formalisms.</title>
<date>1985</date>
<booktitle>In Proceedings of the 23rd Annual Meeting of the Association for Computational Linguistics, ACL,</booktitle>
<pages>137--144</pages>
<location>Chicago, IL,</location>
<marker>[Pereira 85]</marker>
<rawString>Fernando C.N. Pereira. A structuresharing representation for unification-based grammar formalisms. In Proceedings of the 23rd Annual Meeting of the Association for Computational Linguistics, ACL, pp. 137-144, Chicago, IL, 1985.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fernando C N Pereira</author>
<author>Stuart Shieber</author>
</authors>
<title>The semantics of grammar formalisms seen as computer languages.</title>
<date>1984</date>
<booktitle>In Proceedings of the 10th Intl. Conference on Computational Linguistics, COLING-84,</booktitle>
<location>Stanford,</location>
<marker>[Pereira/Shieber 84]</marker>
<rawString>Fernando C.N. Pereira and Stuart Shieber. The semantics of grammar formalisms seen as computer languages. In Proceedings of the 10th Intl. Conference on Computational Linguistics, COLING-84, Stanford, 1984.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Carl Pollard</author>
<author>Ivan Sag</author>
</authors>
<title>Information-Based Syntax and Semantics, Volume I.</title>
<date>1987</date>
<journal>CSLI Lecture Notes No</journal>
<volume>13</volume>
<publisher>Chicago University Press,</publisher>
<location>Chicago,</location>
<marker>[Pollard and Sag 87]</marker>
<rawString>Carl Pollard and Ivan Sag. Information-Based Syntax and Semantics, Volume I. CSLI Lecture Notes No 13. Chicago University Press, Chicago, 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Williams C Rounds</author>
<author>R Kasper</author>
</authors>
<title>A complete logical calculus for record structures representing linguistic information.</title>
<date>1986</date>
<booktitle>In IEEE Symposium on Logic in Computer Science,</booktitle>
<marker>[Rounds/Kasper 86]</marker>
<rawString>Williams C. Rounds and R. Kasper. A complete logical calculus for record structures representing linguistic information. In IEEE Symposium on Logic in Computer Science, 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stuart M Shieber</author>
</authors>
<title>An Introduction to Unification-based Approaches to Grammar.</title>
<date>1986</date>
<journal>CSLI Lecture Notes No</journal>
<volume>4</volume>
<publisher>Chicago University Press,</publisher>
<location>Chicago,</location>
<marker>[Shieber 86]</marker>
<rawString>Stuart M. Shieber. An Introduction to Unification-based Approaches to Grammar. CSLI Lecture Notes No 4. Chicago University Press, Chicago, 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David H D Warren</author>
</authors>
<title>An Abstract Prolog Instruction Set.</title>
<date>1983</date>
<booktitle>Technical Note 309, SRI International,</booktitle>
<location>Menlo Park, CA,</location>
<marker>[Warren 83]</marker>
<rawString>David H. D. Warren. An Abstract Prolog Instruction Set. Technical Note 309, SRI International, Menlo Park, CA, 1983.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David A Wroblewski</author>
</authors>
<title>Nondestructive graph unification.</title>
<date>1987</date>
<booktitle>In Proceedings of the 6th National Conference on Artificial Intelligence, AAAI,</booktitle>
<pages>582--587</pages>
<location>Seattle, WA,</location>
<marker>[Wroblewski 87]</marker>
<rawString>David A. Wroblewski. Nondestructive graph unification. In Proceedings of the 6th National Conference on Artificial Intelligence, AAAI, pp. 582-587, Seattle, WA, 1987.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>