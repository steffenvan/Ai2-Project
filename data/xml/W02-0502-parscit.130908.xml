<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000003">
<title confidence="0.988535">
Generating Hebrew verb morphology by default inheritance hierarchies
</title>
<author confidence="0.999443">
Raphael Finkel Gregory Stump
</author>
<affiliation confidence="0.99995">
Department of Computer Science Department of English
University of Kentucky University of Kentucky
</affiliation>
<email confidence="0.999424">
raphael@cs.uky.edu gstump@uky.edu
</email>
<sectionHeader confidence="0.995649" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999942">
We apply default inheritance hierarchies
to generating the morphology of Hebrew
verbs. Instead of lexically listing each
of a word form’s various parts, this strat-
egy represents inflectional exponents as
markings associated with the application
of rules by which complex word forms
are deduced from simpler roots or stems.
The high degree of similarity among verbs
of different binyanim allows us to for-
mulate general rules; these general rules
are, however, sometimes overridden by
binyan-specific rules. Similarly, a verb’s
form within a particular binyan is deter-
mined both by default rules and by over-
riding rules specific to individual verbs.
Our result is a concise set of rules defin-
ing the morphology of all strong verbs in
all binyanim. We express these rules in
KATR, both a formalism for default in-
heritance hierarchies and associated soft-
ware for computing the forms specified by
those rules. As we describe the rules, we
point out general strategies for express-
ing morphology in KATR and we discuss
KATR’s advantages over ordinary DATR
for the representation of morphological
systems.
</bodyText>
<sectionHeader confidence="0.998894" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.996219597826088">
Recent research into the nature of morphology sug-
gests that the best definitions of a natural lan-
guage’s inflectional system are inferential and real-
izational (Stump, 2001). A definition is inferential
if it represents inflectional exponents as markings
associated with the application of rules by which
complex word forms are deduced from simpler roots
and stems; an inferential definition of this sort con-
trasts with a lexical definition, according to which
an inflectional exponent’s association with a par-
ticular set of morphosyntactic properties is simply
stated in the lexicon, in exactly the way that the as-
sociation between a lexeme’s formal and contentive
properties is stipulated. In addition, a definition
of a language’s inflectional system is realizational
if it deduces a word’s inflectional exponents from
its grammatical properties; a realizational definition
contrasts with an incremental definition, according
to which words acquire morphosyntactic properties
only by acquiring the morphology which expresses
those properties.
The conclusion that inflectional systems should
be defined realizationally rather than incrementally
is favored by a range of evidence, such as the
widespread incidence of extended exponence in in-
flectional morphology and the fact that a word’s in-
flectional exponents often under-determine its mor-
phosyntactic content (Stump, 2001). Moreover,
inferential-realizational definitions can avoid certain
theoretically unmotivated distinctions upon which
lexical or incremental definitions often depend. For
instance, inferential-realizational definitions do not
entail that concatenative and nonconcatenative mor-
phology are fundamentally different in their gram-
matical status; they do not necessitate the postula-
tion of any relation between inflectional markings
and morphosyntactic properties other than the rela-
tion of simple exponence; and they are compatible
with the assumption that a word form’s morpholog-
ical representation is not distinct from its phonolog-
ical representation.
Various means of defining a language’s inflec-
tional morphology in inferential-realizational terms
are imaginable. In an important series of arti-
cles (Corbett and Fraser, 1993; Fraser and Cor-
bett, 1995; Fraser and Corbett, 1997), Greville Cor-
bett and Norman Fraser proposed Network Mor-
phology, an inferential-realizational morphological
framework that makes extensive use of nonmono-
tonic inheritance hierarchies to represent the infor-
mation constituting a language’s inflectional system.
Analyses in Network Morphology are implemented
in DATR, a formal language for representing lexi-
cal knowledge designed and implemented by Roger
Evans and Gerald Gazdar (Evans and Gazdar, 1989).
In recent work, we have extended DATR, creating
KATR, which is both a formal language and a com-
puter program that generates desired forms by inter-
preting that language.
In this paper, we show how KATR can be used to
provide an inferential-realizational definition of He-
brew verb morphology. Our objectives are twofold.
First, we propose some general strategies for ex-
ploiting the capabilities of nonmonotonic inheri-
tance hierarchies in accounting for the properties of
“root-and-pattern” verb inflection in Hebrew; sec-
ond, we discuss some specific capabilities that dis-
tinguish KATR from DATR and show why these
added capabilities are helpful to account for the He-
brew facts.
2 The pi‘el verb
The purpose of the KATR theory described here is to
generate perfect and imperfect forms of strong verbs
belonging to various binyanim in Hebrew. In par-
ticular, given a verbal lexeme L and a sequence
of morphosyntactic properties appropriate for verbs,
the theory evaluates the pairing of L with as an
inflected verb form. For instance, it evaluates the
pairing of the lexeme “speak” with the property
sequence &lt;perfect 3 sg masc&gt; as the verb
form “he spoke”.
A theory in KATR is a network of nodes; the
network of nodes constituting our verb morphology
theory is represented in Figure 1. The overarching
organizational principle in this network is hierarchi-
cal: The tree structure’s terminal nodes represent in-
dividual verbal lexemes, and each of the nontermi-
nal nodes in the tree defines default properties shared
by the lexemes that it dominates. The status of the
boxed nodes is taken up below.
Each of the nodes in a theory houses a set of rules.
We represent the verb by a node:
</bodyText>
<equation confidence="0.98052525">
Speak:
&lt;root&gt; = % 1
&lt;&gt; = PIEL % 2
.
</equation>
<bodyText confidence="0.999564909090909">
The node is named Speak, and it has two rules, ter-
minated by a single dot. Our convention is to name
the node for a verb by a capitalized English word
representing its meaning. We use KATR-style com-
ments (starting with % and continuing to the end of
the line) to number the rules so we can refer to them
easily.
Rule 1 says that a query asking for the root of this
verb should produce a three-atom result containing
, , and . Our rules assemble Hebrew words in
logical order, which appears in this document as left-
to-right. We accomplish reversal by rules in a RE-
VERSE node, not shown in this paper.
Rule 2 says that all other queries are to be referred
to the PIEL node, which we introduce below.
A query is a list of atoms, such as &lt;root&gt;
or &lt;vowel2 perfect 3 sg masc&gt;; in our
theory, the atoms generally represent form cate-
gories (such as root, binyanprefix, vowel1,
cons2), morphosyntactic properties (such as per-
fect, sg, fem) or specific Hebrew characters.
Queries are directed to a particular node. The query
directed to a given node is matched against all the
rules housed at that node. A rule matches if all the
atoms on its left-hand side match the atoms in the
query. A rule can match even if its atoms do not
exhaust the entire query. In the case of Speak, a
query &lt;root perfect&gt; would match both rules,
but not a rule begining with &lt;spelling&gt;. When
several rules match, KATR picks the best match, that
is, the one whose left-hand side “uses up” the most
of the query. This algorithm means that Rule 2 of
Speak is only used when Rule 1 does not apply,
</bodyText>
<table confidence="0.8223651">
VERBPREFIX ACCENT
VERBSUFFIX
STEM
ROOT1
ROOT2
ROOT3
VERB
QAL PIEL HIPHIL NIPHAL PUAL HOPHAL HITHPAEL
QAL1 QAL2 QAL3
Guard BeHeavy BeSmall Speak Separate FinishSlaughter Doom Slip
</table>
<figureCaption confidence="0.999344">
Figure 1: A network of nodes for generating forms of strong verbs in seven binyanim.
</figureCaption>
<bodyText confidence="0.999506714285714">
because Rule 1 is always a better match if it applies
at all. Rule 2 is called a default rule, because it
applies by default if no other rule applies. Default
rules define a hierarchical relation among some of
the nodes in a KATR theory; thus, in the tree struc-
ture depicted in Figure 1, node X dominates node Y
iff Y houses a default rule that refers queries to X.
KATR generates output based on queries directed
to nodes representing individual words. Since these
nodes, such as Speak, are not referred to by other
nodes, they are called leaves, as opposed to nodes
like PIEL, which are called internal nodes.
Here is the output that KATR generates for the
Speak node and various queries.
</bodyText>
<table confidence="0.999534583333333">
Speak:&lt;perfect sg 3 masc&gt;
Speak:&lt;perfect sg 3 fem&gt;
Speak:&lt;perfect sg 2 masc&gt;
Speak:&lt;perfect sg 2 fem&gt;
Speak:&lt;perfect sg 1 masc&gt;
Speak:&lt;perfect sg 1 fem&gt;
Speak:&lt;perfect pl 3 masc&gt;
Speak:&lt;perfect pl 3 fem&gt;
Speak:&lt;perfect pl 2 masc&gt;
Speak:&lt;perfect pl 2 fem&gt;
Speak:&lt;perfect pl 1 masc&gt;
Speak:&lt;perfect pl 1 fem&gt;
Speak:&lt;imperfect sg 3 masc&gt;
Speak:&lt;imperfect sg 3 fem&gt;
Speak:&lt;imperfect sg 2 masc&gt;
Speak:&lt;imperfect sg 2 fem&gt;
Speak:&lt;imperfect sg 1 masc&gt;
Speak:&lt;imperfect sg 1 fem&gt;
Speak:&lt;imperfect pl 3 masc&gt;
Speak:&lt;imperfect pl 3 fem&gt;
Speak:&lt;imperfect pl 2 masc&gt;
Speak:&lt;imperfect pl 2 fem&gt;
Speak:&lt;imperfect pl 1 masc&gt;
Speak:&lt;imperfect pl 1 fem&gt;
</table>
<bodyText confidence="0.999196076923077">
Our theory represents Hebrew characters and
vowels in Unicode characters (Daniels, 1993). We
use ´ to indicate the accented syllable if it is not the
ultima, and we mark shewa na by .
The rule for Speak illustrates one of the strate-
gies upon which we build KATR theories: A node
representing a category (here, a particular verb) may
provide information (here, the letters of the verb’s
root) needed by more general nodes (here, PIEL and
the nodes to which it, in turn, refers). We refer to this
strategy as priming. As we see below, rules in the
more general nodes refer to primed information by
means of quoted queries.
</bodyText>
<sectionHeader confidence="0.993347" genericHeader="introduction">
3 The PIEL node
</sectionHeader>
<bodyText confidence="0.991831240963855">
We now turn to the PIEL node, to which the Speak
node refers.
.
As with the Speak node, PIEL defers most
queries to its parent, in this case the node called
VERB, as Rule 1 indicates.
Rule 2 modifies a default that VERB will use,
namely, the nature of the second consonant of the
root. Pi‘el verbs double their second consonant by
applying a dagesh. This rule exemplifies a second
strategy of KATR theories: A node representing a
specific category (here, pi‘el verbs) may override in-
formation (here, the nature of the second consonant)
that is assumed by more general nodes (here, VERB
and the nodes to which it, in turn, refers). We refer
to this strategy as overriding. Rule 2 is an overrid-
ing rule because the value it assigns to the sequence
&lt;cons2&gt; is distinct from the value assigned at the
VERB node to which PIEL refers queries by default.
We momentarily defer discussing the strange right-
hand side of this rule.
The other rules in PIEL are all priming rules.
Instead of using angle brackets (“&lt;” and “&gt;”) to
match queries, they use braces (“ ” and “ ”). This
syntax causes the left-hand side of a rule to be
treated as a set instead of an ordered list. The rule
whose left-hand side is binyanprefix per-
fect matches any query containing both the atom
binyanprefix and the atom perfect, in any
order. As before, more than one rule can match a
given query, and the rule with the most comprehen-
sive match is chosen. If there are equally good best
rules, the KATR theory is considered malformed.
In formulating Rules 3 5, we assume a distinc-
tion between binyan prefixes (specific to particular
binyanim) and the personal prefixes (which cross-
cut the various binyanim); thus, the form “we
will speak” contains the binyan prefix and the per-
sonal prefix .
An empty right-hand side in a rule means that the
result of a matching query is the empty string. In
particular, Rule 3,
binyanprefix perfect =
indicates that there is no binyan prefix for pi‘el verbs
in the perfect form, in contrast to, for instance, hif‘il
verbs. The next two rules indicate the binyan prefix
for a pi‘el verb’s imperfect forms. By Rule 4, this
prefix is generally shewa (); but because the per-
sonal prefix cannot co-occur with the binyan prefix
shewa, Rule 5 specifies a different binyan prefix for
a pi‘el verb’s first-person singular imperfect form.
(We can adjust the combination to as a postpro-
cessing step instead, as we show later when we treat
guttural letters.)
Every form of a verb separates the three letters
of the root by two vowels, which we call vowel1
and vowel2. The pi‘el is characterized by the fact
that in the imperfect, these vowels are the patah (by
Rule 7) and the tseyre (by Rule 10), as in “we
will speak”; in the perfect, they are instead generally
the hiriq (by Rule 6) and the patah (by Rule 9), as
in “we spoke”. There is an exception in the
perfect third singular masculine ( ), as specified
in Rule 8.
Rules 5 and 8 are examples of a third strategy for
building KATR theories: A rule may show an excep-
tion to a more general pattern introduced by another
rule housed at the same node. For instance, Rule 8
establishes a special value for vowel2 for one com-
bination of person, number, and gender, supplanting
the more typical value for vowel2 established for
imperfect forms by Rule 9. We refer to this strategy
as specializing.
We now revisit the strange right-hand side of
Rule 2. The term on its right-hand side is a node
name (ROOT2), a colon, and new query to present
to that node. The new query involves a quoted path,
&amp;quot;&lt;root&gt;&amp;quot;. KATR treats quoted paths in this con-
text as queries on the node from which we started,
that is, Speak. In our case, the right-hand side of
this rule is equivalent to ROOT2:&lt; &gt;, because
of the first rule in the Speak node.
ROOT2 is one of a family of three nodes each
</bodyText>
<equation confidence="0.947338363636364">
PIEL:
&lt;&gt; = VERB % 1
&lt;cons2&gt; = ROOT2:&lt;&amp;quot;&lt;root&gt;&amp;quot;&gt; % 2
binyanprefix perfect = % 3
binyanprefix imperfect = % 4
binyanprefix imperfect 1 sg = % 5
vowel1 perfect = % 6
vowel1 imperfect = % 7
vowel2 perfect 3 sg masc = % 8
vowel2 perfect = % 9
vowel2 imperfect = % 10
</equation>
<bodyText confidence="0.9903095">
of which isolates a particular consonant in a verb’s
triliteral root.
</bodyText>
<equation confidence="0.998812">
ROOT1: &lt;$consonant#1 $consonant#2
$consonant#3&gt; = $consonant#1 .
ROOT2: &lt;$consonant#1 $consonant#2
$consonant#3&gt; = $consonant#2 .
ROOT3: &lt;$consonant#1 $consonant#2
$consonant#3&gt; = $consonant#3 .
</equation>
<bodyText confidence="0.999924882352941">
The #vars declaration introduces a class of
atoms: Hebrew consonant characters. Each of the
three ROOT nodes has a single rule that matches a
three-consonant sequence, assigning each member
of the sequence a local number. The rule selects one
of those consonants as the result.
These three nodes follow a fourth strategy for
writing KATR theories: A node may be invoked
solely to provide information (here, a particular con-
sonant in a verb’s root) needed by other rules. We
refer to this strategy as lookup. Lookup nodes (such
as the boxed nodes in Figure 1) do not participate
in the hierarchical relationships defined by the net-
work’s default rules.
To demonstrate that the PIEL node character-
izes its binyan, we present the somewhat simpler
HOPHAL node as a point of comparison.
</bodyText>
<equation confidence="0.953693285714286">
HOPHAL:
&lt;&gt; = VERB % 1
binyanprefix perfect = % 2
binyanprefix imperfect = % 3
vowel1 = % 4
vowel2 = % 5
.
</equation>
<sectionHeader confidence="0.996279" genericHeader="method">
4 The VERB node
</sectionHeader>
<bodyText confidence="0.991128">
Queries on Speak are generally reflected to its
parent, PIEL, which then reflects them further to
VERB.
</bodyText>
<equation confidence="0.89964225">
VERB:
&lt;cons1&gt; = ROOT1:&lt;&amp;quot;&lt;root&gt;&amp;quot;&gt; % 1
&lt;cons2&gt; = ROOT2:&lt;&amp;quot;&lt;root&gt;&amp;quot;&gt; % 2
&lt;cons3&gt; = ROOT3:&lt;&amp;quot;&lt;root&gt;&amp;quot;&gt; % 3
</equation>
<bodyText confidence="0.998925323529412">
Rules 1 3 of VERB determine the three conso-
nants of the root if they have not already been de-
termined by earlier processing. In the case of pi‘el
verbs, &lt;cons2&gt; has been determined (by Rule 2
at the pi‘el node), but the other consonants have not.
That is, if we pose the query Speak:&lt;cons2&gt;, the
Speak node reflects it to the PIEL node, which re-
solves it. But the query Speak:&lt;cons3&gt; is not
resolved by PIEL; it is reflected to VERB, which re-
solves it now by means of lookup.
Rule 4 introduces a priming that is needed by the
lookup node STEM: Usually, the shortened version
of &lt;vowel2&gt; is the shewa. In one binyan, namely
hif‘il, the shortened version of&lt;vowel2&gt; is special
and overrides this priming.
Rule 5 is the most complicated. It exemplifies
two more strategies of programming KATR theo-
ries: (1) Combining: It combines various pieces of
morphology, namely those represented by the nodes
VERBPREFIX, STEM, and VERBSUFFIX, each of
which is referred to by VERB, and (2) Postprocess-
ing: It presents the entire result of that combina-
tion to a postprocessing step represented by the node
ACCENT.
Combining works by invoking each of the
nodes VERBPREFIX, STEM, and VERBSUF-
FIX
ERBSUF-
FIx with the query presented originally to
Speak; such a query might be, for example,
Speak:&lt;imperfect sg 3 masc&gt;. (The fact
that no query list is explicitly presented to those
nodes implies that KATR should use the original
query.)
</bodyText>
<sectionHeader confidence="0.996639" genericHeader="method">
5 Nodes for stems and affixes
</sectionHeader>
<bodyText confidence="0.955782">
Verbs in the imperfect take personal prefixes.
</bodyText>
<equation confidence="0.7861395">
VERBPREFIX:
perfect = % 1
imperfect 1 sg = % 2
imperfect 2 sg = % 3
</equation>
<bodyText confidence="0.733272111111111">
imperfect 3 sg masc = % 4
imperfect 3 sg fem = % 5
imperfect 1 pl = % 6
imperfect 2 pl = % 7
imperfect 3 pl masc = % 8
imperfect 3 pl fem = % 9
.
We choose not to include the vowel following the
prefix as part of this node, but rather as part of STEM.
</bodyText>
<equation confidence="0.982932666666667">
#vars $consonant:
.
shortvowel2 = % 4
&lt;&gt; = ACCENT:&lt;VERBPREFIX STEM
VERBSUFFIX endofword&gt; % 5
.
</equation>
<bodyText confidence="0.999273125">
Such decisions are common in cases of combining;
it often makes little difference whether such “bound-
ary” markers are placed at the end of one combining
formative or the start of the next one.
Rule 1 indicates that for all queries containing the
atom perfect, there is no verb prefix. This single
rule concisely covers many cases, which are implic-
itly included because the atoms pertaining to num-
ber, person, and gender are omitted. The other rules
all apply to the imperfect tense. In the first and sec-
ond person, the prefix is independent of gender, so
the rules there are shorter, again concisely covering
multiple cases with only a few rules.
Suffixes have a similar node; here we choose to
include the vowel that separates the suffix from the
stem.
</bodyText>
<figure confidence="0.784999">
VERBSUFFIX:
perfect 1 sg = @ % 1
perfect 2 sg masc = @ % 2
perfect 2 sg fem = % 3
perfect 3 sg masc = % 4
perfect 3 sg fem = % 5
perfect 1 pl = @ % 6
perfect 2 pl masc = % 8
</figure>
<construct confidence="0.617364166666667">
perfect 2 pl fem = % 9
perfect 3 pl = % 10
imperfect sg = % 11
imperfect 2 sg fem = % 12
imperfect 1 pl ++ = % 13
imperfect pl masc = % 14
</construct>
<equation confidence="0.543826">
imperfect pl fem = @ % 15
.
</equation>
<bodyText confidence="0.995104608695652">
Rules 1, 2, 6, and 15 include the @ character,
which we use to indicate that the given syllable
should not be accented. Hebrew words are gener-
ally accented on the ultima; we place @ on the ul-
tima to force the accent to the penultima. Placing of
accents is one of the jobs relegated to the postpro-
cessing step.
The left-hand side of rule 13 includes the symbol
++. This symbol tells KATR that even if another,
seemingly better rule matches a query, this rule
should take precedence if it matches. The situation
arises for the query &lt;imperfect pl 1 masc&gt;,
for instance. Both rules 13 and 14 match, but the for-
mer is preferred. The other way we could have rep-
resented this situation is by restricting rule 14 to 2nd
or 3rd person, either by explicitly indicating these
morphosyntactic properties or by adding the atom
!1, which means “not first person”. We choose to
use the disambiguator ++ in Rule 13 instead; in the
terminology of (Stump, 2001), the ++ symbol iden-
tifies rules that apply in “expanded mode”.
The most complex node defines the stem part of a
verb.
</bodyText>
<equation confidence="0.975025642857143">
STEM:
&lt;&gt; = &amp;quot;&lt;binyanprefix&gt;&amp;quot; &amp;quot;&lt;cons1&gt;&amp;quot;
&amp;quot;&lt;vowel1&gt;&amp;quot; &amp;quot;&lt;cons2&gt;&amp;quot; &lt;anyvowel2&gt;
&amp;quot;&lt;cons3&gt;&amp;quot; % 1
&lt;anyvowel2&gt; = &amp;quot;&lt;vowel2&gt;&amp;quot; % 2
anyvowel2 perfect 3 sg fem =
&amp;quot;&lt;shortvowel2&gt;&amp;quot; % 3
anyvowel2 perfect 3 pl =
&amp;quot;&lt;shortvowel2&gt;&amp;quot; % 4
anyvowel2 imperfect 2 sg fem =
&amp;quot;&lt;shortvowel2&gt;&amp;quot; % 5
anyvowel2 imperfect !1 pl masc =
&amp;quot;&lt;shortvowel2&gt;&amp;quot; % 6
.
</equation>
<bodyText confidence="0.999873578947368">
Rule 1 uses combining to assemble the parts of
the stem, starting with the binyan prefix, then alter-
nating all the consonants and vowels. Most of these
parts are surrounded in quote marks, meaning that
these elements are queries to be reflected back to the
starting node, in our case, Speak. These queries
percolate through Speak, PIEL, and VERB until a
priming rule satisfies them.
The only exception is that instead of &lt;vowel2&gt;,
this rule queries &lt;anyvowel2&gt; without quote
marks. The absence of quote marks directs this
query to the current node, that is, STEM; the remain-
ing rules determine what vowel is appropriate.
Rule 2 indicates that unless another rule is bet-
ter, anyvowel2 is just vowel2. However, in
four cases, vowel2 must be replaced by short-
vowel2, typically shewa (primed by the VERB
node), but occasionally something else (overridden
by hif‘il verbs).
</bodyText>
<sectionHeader confidence="0.994962" genericHeader="method">
6 Postprocessing
</sectionHeader>
<bodyText confidence="0.999619555555555">
Many languages have rules of euphony. These
rules are often called sandhi operations, based on
a term used in Sanskrit morphology. We use the
node ACCENT to introduce sandhi operations. Its
name comes from the fact that the first operation we
needed was to place the accent on the penultima, but
we use it for other purposes as well.
We begin by defining character classes similar to
the $consonant class introduced earlier.
</bodyText>
<equation confidence="0.9563185">
#vars $accent: &amp;quot; .
#vars $unaccentableVowel: .
#vars $accentableVowel: $vowel -
$unaccentableVowel .
#vars $letter: $vowel + $consonant +
$accent .
#vars $noAccent: $letter -
$accentableVowel .
</equation>
<bodyText confidence="0.999627545454545">
Each class contains a subset of the Hebrew char-
acters. We treat some combinations as single charac-
ters for this purpose, in particular, the vowels and
. The first three classes are defined by enumeration.
The fourth class, $accentableVowel, is defined
in terms of previously defined classes, specifically,
all vowels except those that are unaccentable. Simi-
larly, the $letter class includes all vowels, conso-
nants, and accents, and the $noAccent class con-
tains all letters except for accentable vowels. These
classes are used in the ACCENT node.
</bodyText>
<equation confidence="0.953958833333333">
ACCENT:
&lt;$letter&gt; = $letter &lt;&gt; % 1
&lt;endofword&gt; = % 2
&lt;$accentableVowel#1 $noAccent*
$accentableVowel#2 @&gt; =
$accentableVowel#1 &amp;quot; $noAccent*
&lt; $accentableVowel#2 &lt;&gt; % 3
endofword&gt; = % 4
&lt; endofword&gt; = % 5
&lt; $consonant endofword&gt; =
$consonant % 6
.
</equation>
<bodyText confidence="0.999950785714286">
A query to ACCENT is a fully formed Hebrew
word ready for postprocessing, with the endof-
word tag placed at the end. The first rule is a de-
fault that often is overridden by later rules; it says
that whatever letter the query starts with, that let-
ter can be removed from the query, and placed as a
result. Furthermore, the unmatched portion of the
query, indicated by &lt;&gt; on the right-hand side, is to
be directed to the ACCENT node for further process-
ing. Rule 2 says that if a resulting query has only
endofword, that tag should be removed, and no
further processing is needed.
Rule 3 places accents in words that contain the @
sign, which we use to indicate “do not accent this
syllable.” The left-hand side matches queries that
contain an accentable vowel, followed by any num-
ber (zero or more, indicated by the Kleene star *)
of letters that cannot be accented, followed by a sec-
ond accentable vowel, followed by the @ mark. Such
words must have the @ removed and an accent mark
placed after the first accentable vowel matched, as
indicated in the right-hand side. The empty &lt;&gt; at the
end of the right-hand side directs unused portions of
the query to ACCENT for further processing.
Rules 4, 5, and 6 deal with shewa near the end
of a word. Generally, shewa is deleted at the very
end (rule 4), but not if it follows (rule 5) or if the
previous vowel is also a shewa (rule 6).
</bodyText>
<sectionHeader confidence="0.500655" genericHeader="method">
7 Accommodating guttural letters
</sectionHeader>
<bodyText confidence="0.999560714285714">
Our current efforts involve accommodating verb
roots containing guttural letters. We have found that
new rules in the postprocessing step, that is, the AC-
CENT node, cover many of the cases.
We first introduce postprocessing rules that con-
vert shewa nah. (which we continue to represent as )
to shewa na (which we represent as ).
</bodyText>
<equation confidence="0.879692166666667">
#vars $longVowel: .
ACCENT:
... % other rules as before
&lt;startofword $consonant $dagesh? / &gt;
=+= &lt;&gt; % 8
&lt;/ $consonant#1 $dagesh?
$consonant#2&gt; =+= &lt;&gt; % 9
&lt;$longVowel $consonant / &gt; =+= &lt;&gt;
% 10
&lt;$consonant $dagesh / &gt; =+= &lt;&gt; % 11
&lt;$consonant#1 $dagesh?
/ $consonant#1&gt; =+= &lt;&gt; % 12
</equation>
<bodyText confidence="0.979611384615384">
Rule 8 converts shewa nah. to shewa na on the
first consonant of the word. We introduce the atom
startofword in order to detect this situation, and
we modify the reference to the ACCENT node in the
VERB node to include this new atom. This rule uses
=+= instead of = to separate the two sides. This
notation indicates a non-subtractive rule; the right-
hand side path encompasses the entire query, includ-
ing that part matched by the left-hand side, except
#vars $vowel: .
that the shewa nah. has been replaced by shewa na.
After this replacement, KATR continues to process
the new query at the same node. The left-hand side
uses the ? operator, which means “zero or one in-
stances.” This notation allows a single rule to match
situations both with and without a dagesh.
The other rules use similar notation. Rule 9 con-
verts the first of two shewas in a row to a shewa na,
except at the end of the word. Rule 10 converts a
shewa nah. following a long vowel. Rule 11 converts
a shewa nah. on a consonant with a dagesh. Rule 12
converts the shewa nah. on the first of two identical
consonants.
Given the distinction between the two shewas, we
now add postprocessing rules that convert a guttural
with a shewa na to an appropriate alternative.
</bodyText>
<figure confidence="0.8873405">
#vars $guttural: .
ACCENT:
... % other rules as before
&lt;$guttural &gt; _ $guttural &lt;&gt; % 13
&lt; $guttural
&lt; $guttural
&lt; $letter&gt;
&lt; &gt; _ &lt;&gt; % 17
</figure>
<figureCaption confidence="0.3944135">
Rule 13 corrects, for example, to ;
Rule 14 corrects to , and Rule 15 corrects
</figureCaption>
<bodyText confidence="0.955802666666667">
to . Rules 16 and 17 correct the initial
in ” verbs in the qal.
We add other rules, such as the following Rule 18,
to correct situations where a guttural letter would
otherwise acquire a dagesh.
&lt; $guttural &gt; _ &lt; $guttural&gt; % 18
We have not begun work on weak verbs contain-
ing , , and , which might require different ap-
proaches.
</bodyText>
<sectionHeader confidence="0.998158" genericHeader="method">
8 Further work
</sectionHeader>
<bodyText confidence="0.998963588235294">
We continue to develop our Hebrew KATR theory.
Our goal is to cover all forms, including the waw
consecutive, infinitive, makor, and predicate suf-
fixes, for both strong and weak verbs. We will then
turn to nouns, including personal suffixes. Our suc-
cess so far indicates that KATR is capable of repre-
senting Hebrew morphology in a concise yet read-
able form.
Our larger goal is to host a library of KATR theo-
ries for various languages as a resource for linguists.
Such a library will provide interested researchers
with morphological descriptions that can be directly
converted into actual word forms and will serve as
a substitute, to some extent, for voluminous natural-
language and table-based descriptions. In the case of
endangered languages, it will act as a repository for
linguistic data that may be essential for preservation.
</bodyText>
<sectionHeader confidence="0.987059" genericHeader="evaluation">
9 DATR and KATR
</sectionHeader>
<bodyText confidence="0.999933275862069">
We discuss KATR and its relation to DATR exten-
sively elsewhere (Finkel et al., 2002); here we only
summarize the differences. The DATR formalism is
quite powerful; we have demonstrated that it is capa-
ble of emulating a Turing machine. The KATR en-
hancements are therefore aimed at usability, not the-
oretical power. The principal innovations of KATR
are:
Set notation. The left-hand sides of DATR rules
may only use list notation. KATR allows set
notation as well, which allows us to deal with
morphosyntactic properties in any order.
Hebrew verb morphology provides abundant
motivation for this enhancement. In the VERB-
SUFFIX node, Rule 15 identifies as an ex-
ponent of number and gender but not of person;
Rule 10 identifies as an exponent of person
and number but not of gender. Both rules are
indifferent to the order in which properties of
person, number, and gender are listed in any
matching query. If a rule’s left-hand side were
required to be a list (as in ordinary DATR), then
one of these two rules would have to be compli-
cated by the inclusion of either a variable over
properties of person (Rule 15) or a variable
over properties of gender (Rule 10); moreover,
all queries would have to adhere to a fixed (but
otherwise unmotivated) ordering among prop-
erties of person, number, and gender.
</bodyText>
<footnote confidence="0.9543835">
Regular expressions. KATR allows limited reg-
ular expressions in lists in left-hand sides of
rules; DATR has no such expressions. We use
this facility in the ACCENT node in the Hebrew
theory, both for the Kleene star * and for the ?
operator. More generally, we often find regular
</footnote>
<table confidence="0.69813875">
&gt; _ $guttural &lt;&gt; % 14
&gt; _ $guttural &lt;&gt; % 15
_ &lt;$letter&gt; % 16
expressions valuable in representing non-local
</table>
<bodyText confidence="0.999559127272727">
sandhi phenomena, such as the Sanskrit rule of
n-retroflexion.
Non-subtractive rules. DATR rules have a
subtractive quality: The atoms of the query
matched by the left-hand side are removed
from the query used for subsequent evaluation
in the right-hand side. The KATR =+= opera-
tor allows us to represent rules that preserve the
atoms matched by the left-hand side, substitut-
ing new atoms where necessary. We generally
use this facility for rules of referral. For exam-
ple, Latin neuter nouns share the same nomina-
tive and accusative plural; we capture this fact
by a rule that converts accusative to nominative
in the context of neuter plural. In the Hebrew
theory, we use non-subtractive rules to convert
shewa nah. to shewa na.
Enhanced matching length. In some cases,
competing rules have left-hand sides of the
same length, but one of the rules should always
be chosen when both apply. KATR includes the
++ syntax for explicitly enhancing the effective
length of the preferred left-hand side; we use
this facility in the VERBSUFFIX node. DATR
does not have this syntax.
Syntax. KATR has several minor syntax en-
hancements. It allows special characters to be
used as atoms if escaped by the \ character.
The atom $$ can be used to match the end
of the query. Variables can be computed in-
stead of being enumerated; we use this facility
in defining the $letter variable. KATR al-
lows greater control over which nodes are to be
displayed under default queries. The interac-
tive KATR program has new facilities for rapid
testing and debugging of theories.
KATR is entirely coded in Java, making it quite
portable to a variety of platforms. It runs as an inter-
active program, with commands for compiling the-
ories, executing queries, and performing various de-
bugging functions. The KATR algorithm is based
on evaluating a query at a node within a context.
First, KATR identifies the rule within the node with
the best matching left-hand side. The result of the
query involves evaluating the associated right-hand
side, which might require further evaluations of new
queries at a variety of nodes and contexts; KATR
recursively undertakes these evaluations. The al-
gorithm is completely deterministic and reasonably
fast: Compiling the entire Hebrew theory and eval-
uating all the forms of a verb takes about 2 seconds
on an 863MHz Linux machine.
The interested reader can acquire KATR and our
Hebrew morphology theory from the authors (under
the GNU General Public License).
</bodyText>
<sectionHeader confidence="0.984422" genericHeader="conclusions">
10 Strategies for building KATR theories
</sectionHeader>
<bodyText confidence="0.999517575">
We have been applying KATR to generation of
natural-language morphology for several years. In
addition to Hebrew, we have built a complete mor-
phology of Latin verbs and nouns, large parts of
Sanskrit (and other related languages), and smaller
studies of Bulgarian, Swahili, Georgian, and Turk-
ish. We have found that KATR allows us to rep-
resent morphological rules for these languages with
great elegance. It is especially well-suited to cases
like Hebrew verbs, where a similar structure applies
across the entire spectrum of words, and where that
spectrum is partitioned into binyanim with distin-
guishable rules, but where euphony introduces stan-
dard vowel shifts based on accent, guttural letters,
and weak letters.
As we have gained experience with KATR, we
have noted encoding strategies that apply across lan-
guage families; we used each of these in our Hebrew
verb specification.
Priming. A node representing a specific cate-
gory provides information needed by more gen-
eral nodes to which it refers queries. Rules in
the more general nodes refer to primed infor-
mation by means of quoted queries.
Lookup. A node is invoked solely to provide
information needed by other rules.
Overriding. A node representing a specific
category answers a query that is usually an-
swered (with different results) by a more gen-
eral node to which queries are usually referred.
Specializing. A rule introduces a specific
exception to a more general pattern speci-
fied by another rule housed at the same node.
The strategies of overriding and specializing
both exploit the nonmonotonicity inherent in
KATR’s semantics.
Combining. A rule concatenates various mor-
phological units by referring queries to multi-
ple nodes.
Postprocessing. The result of combining mor-
phological units is referred to a node that makes
local adjustments to account for euphony and
other sandhi principles.
We do not want to leave the impression that writ-
ing specifications in KATR is easy. The tool is ca-
pable of presenting elegant specifications, but arriv-
ing at those specifications requires considerable ef-
fort. Early choices color the entire structure of the
resulting KATR specification, and it happens fre-
quently that the author of a specification must dis-
card code and rethink how to represent the mor-
phological structures that are being specified. Per-
haps our experience will eventually lead to a second-
generation KATR that better facilitates the linguist’s
task.
The definition of Hebrew verb inflection that we
have sketched here rests on the hypothesis that an in-
flected word’s morphological form is determined by
a system of realization rules organized in a default
inheritance hierarchy. There are other approaches to
defining Hebrew verb inflection; one could, for ex-
ample, assume that an inflected word’s form is de-
termined by a ranked system of violable constraints
on morphological structure, as in Optimality The-
ory (Prince and Smolensky, 1993), or by a finite-
state machine (Karttunen, 1993). The facts of He-
brew verb inflection are apparently compatible with
any of these approaches. Even so, there are strong
theoretical grounds for preferring our approach. It
provides a uniform, well-defined architecture for the
representation of both morphological rules and lexi-
cal information. Moreover, it embodies the assump-
tion that inflectional morphology is inferential and
realizational, readily accommodating such phenom-
ena as extended exponence and the frequent under-
determination of morphosyntactic content by inflec-
tional form; in this sense, it effectively excludes a
morpheme-based conception of word structure, un-
like both the optimality-theoretic and the finite-state
approaches.
</bodyText>
<sectionHeader confidence="0.992102" genericHeader="acknowledgments">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.998861714285714">
This work was partially supported by the National
Science Foundation under Grant 0097278 and by
the University of Kentucky Center for Computa-
tional Science. Any opinions, findings, conclusions
or recommendations expressed in this material are
those of the authors and do not necessarily reflect
the views of the funding agencies.
</bodyText>
<sectionHeader confidence="0.999393" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.998383266666667">
Greville G. Corbett and Norman M. Fraser. 1993. Net-
work Morphology: A DATR account of Russian nom-
inal inflection. Journal of Linguistics, 29:113–142.
P. T. Daniels. 1993. The Unicode Consortium: The Uni-
code standard. Language: journal of the Linguistic
Society ofAmerica, 69(1):225–225, March.
Roger Evans and Gerald Gazdar. 1989. Inference in
DATR. In Proceedings of the Fourth Conference of
the European Chapter of the Association for Compu-
tational Linguistics, pages 66–71, Manchester.
Raphael Finkel, Lei Shen, Gregory Stump, and Suresh
Thesayi. 2002. KATR: A set-based extension of
DATR. under review.
Norman M. Fraser and Greville G. Corbett. 1995. Gen-
der, animacy, and declensional class assignment: a
unified account for Russian. In G. Booij and J. van
Marle, editors, Yearbook of Morphology 1994, pages
123–150. Kluwer, Dordrecht.
Norman M. Fraser and Greville G. Corbett. 1997. De-
faults in Arapesh. Lingua, 103:25–57.
Lauri Karttunen. 1993. Finite-state constraints. In John
Goldsmith, editor, The Last Phonological Rule. Uni-
versity of Chicago Press, Chicago.
Alan S. Prince and Paul Smolensky. 1993. Optimality
theory: Constraint interaction in generative grammar.
Technical Report RuCCs Technical Report #2, Rutgers
University Center for Cognitive Science, Piscataway,
NJ.
Gregory T. Stump. 2001. Inflectional morphology. Cam-
bridge University Press, Cambridge, England.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.980270">
<title confidence="0.999946">Generating Hebrew verb morphology by default inheritance hierarchies</title>
<author confidence="0.999961">Raphael Finkel Gregory Stump</author>
<affiliation confidence="0.999968">Department of Computer Science Department of English University of Kentucky University of Kentucky</affiliation>
<email confidence="0.999741">raphael@cs.uky.edugstump@uky.edu</email>
<abstract confidence="0.999294103448276">We apply default inheritance hierarchies to generating the morphology of Hebrew verbs. Instead of lexically listing each of a word form’s various parts, this strategy represents inflectional exponents as markings associated with the application of rules by which complex word forms are deduced from simpler roots or stems. The high degree of similarity among verbs different us to formulate general rules; these general rules are, however, sometimes overridden by rules. Similarly, a verb’s within a particular determined both by default rules and by overriding rules specific to individual verbs. Our result is a concise set of rules defining the morphology of all strong verbs in We express these rules in KATR, both a formalism for default inheritance hierarchies and associated software for computing the forms specified by those rules. As we describe the rules, we point out general strategies for expressing morphology in KATR and we discuss KATR’s advantages over ordinary DATR for the representation of morphological systems.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Greville G Corbett</author>
<author>Norman M Fraser</author>
</authors>
<title>Network Morphology: A DATR account of Russian nominal inflection.</title>
<date>1993</date>
<journal>Journal of Linguistics,</journal>
<pages>29--113</pages>
<contexts>
<context position="3552" citStr="Corbett and Fraser, 1993" startWordPosition="510" endWordPosition="513">ational definitions do not entail that concatenative and nonconcatenative morphology are fundamentally different in their grammatical status; they do not necessitate the postulation of any relation between inflectional markings and morphosyntactic properties other than the relation of simple exponence; and they are compatible with the assumption that a word form’s morphological representation is not distinct from its phonological representation. Various means of defining a language’s inflectional morphology in inferential-realizational terms are imaginable. In an important series of articles (Corbett and Fraser, 1993; Fraser and Corbett, 1995; Fraser and Corbett, 1997), Greville Corbett and Norman Fraser proposed Network Morphology, an inferential-realizational morphological framework that makes extensive use of nonmonotonic inheritance hierarchies to represent the information constituting a language’s inflectional system. Analyses in Network Morphology are implemented in DATR, a formal language for representing lexical knowledge designed and implemented by Roger Evans and Gerald Gazdar (Evans and Gazdar, 1989). In recent work, we have extended DATR, creating KATR, which is both a formal language and a co</context>
</contexts>
<marker>Corbett, Fraser, 1993</marker>
<rawString>Greville G. Corbett and Norman M. Fraser. 1993. Network Morphology: A DATR account of Russian nominal inflection. Journal of Linguistics, 29:113–142.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P T Daniels</author>
</authors>
<title>The Unicode Consortium: The Unicode standard.</title>
<date>1993</date>
<journal>Language: journal of the Linguistic Society ofAmerica,</journal>
<volume>69</volume>
<issue>1</issue>
<contexts>
<context position="9015" citStr="Daniels, 1993" startWordPosition="1443" endWordPosition="1444">erfect sg 1 masc&gt; Speak:&lt;perfect sg 1 fem&gt; Speak:&lt;perfect pl 3 masc&gt; Speak:&lt;perfect pl 3 fem&gt; Speak:&lt;perfect pl 2 masc&gt; Speak:&lt;perfect pl 2 fem&gt; Speak:&lt;perfect pl 1 masc&gt; Speak:&lt;perfect pl 1 fem&gt; Speak:&lt;imperfect sg 3 masc&gt; Speak:&lt;imperfect sg 3 fem&gt; Speak:&lt;imperfect sg 2 masc&gt; Speak:&lt;imperfect sg 2 fem&gt; Speak:&lt;imperfect sg 1 masc&gt; Speak:&lt;imperfect sg 1 fem&gt; Speak:&lt;imperfect pl 3 masc&gt; Speak:&lt;imperfect pl 3 fem&gt; Speak:&lt;imperfect pl 2 masc&gt; Speak:&lt;imperfect pl 2 fem&gt; Speak:&lt;imperfect pl 1 masc&gt; Speak:&lt;imperfect pl 1 fem&gt; Our theory represents Hebrew characters and vowels in Unicode characters (Daniels, 1993). We use ´ to indicate the accented syllable if it is not the ultima, and we mark shewa na by . The rule for Speak illustrates one of the strategies upon which we build KATR theories: A node representing a category (here, a particular verb) may provide information (here, the letters of the verb’s root) needed by more general nodes (here, PIEL and the nodes to which it, in turn, refers). We refer to this strategy as priming. As we see below, rules in the more general nodes refer to primed information by means of quoted queries. 3 The PIEL node We now turn to the PIEL node, to which the Speak no</context>
</contexts>
<marker>Daniels, 1993</marker>
<rawString>P. T. Daniels. 1993. The Unicode Consortium: The Unicode standard. Language: journal of the Linguistic Society ofAmerica, 69(1):225–225, March.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Roger Evans</author>
<author>Gerald Gazdar</author>
</authors>
<title>Inference in DATR.</title>
<date>1989</date>
<booktitle>In Proceedings of the Fourth Conference of the European Chapter of the Association for Computational Linguistics,</booktitle>
<pages>66--71</pages>
<location>Manchester.</location>
<contexts>
<context position="4056" citStr="Evans and Gazdar, 1989" startWordPosition="581" endWordPosition="584">phology in inferential-realizational terms are imaginable. In an important series of articles (Corbett and Fraser, 1993; Fraser and Corbett, 1995; Fraser and Corbett, 1997), Greville Corbett and Norman Fraser proposed Network Morphology, an inferential-realizational morphological framework that makes extensive use of nonmonotonic inheritance hierarchies to represent the information constituting a language’s inflectional system. Analyses in Network Morphology are implemented in DATR, a formal language for representing lexical knowledge designed and implemented by Roger Evans and Gerald Gazdar (Evans and Gazdar, 1989). In recent work, we have extended DATR, creating KATR, which is both a formal language and a computer program that generates desired forms by interpreting that language. In this paper, we show how KATR can be used to provide an inferential-realizational definition of Hebrew verb morphology. Our objectives are twofold. First, we propose some general strategies for exploiting the capabilities of nonmonotonic inheritance hierarchies in accounting for the properties of “root-and-pattern” verb inflection in Hebrew; second, we discuss some specific capabilities that distinguish KATR from DATR and s</context>
</contexts>
<marker>Evans, Gazdar, 1989</marker>
<rawString>Roger Evans and Gerald Gazdar. 1989. Inference in DATR. In Proceedings of the Fourth Conference of the European Chapter of the Association for Computational Linguistics, pages 66–71, Manchester.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Raphael Finkel</author>
<author>Lei Shen</author>
<author>Gregory Stump</author>
<author>Suresh Thesayi</author>
</authors>
<title>KATR: A set-based extension of DATR. under review.</title>
<date>2002</date>
<contexts>
<context position="26434" citStr="Finkel et al., 2002" startWordPosition="4577" endWordPosition="4580"> morphology in a concise yet readable form. Our larger goal is to host a library of KATR theories for various languages as a resource for linguists. Such a library will provide interested researchers with morphological descriptions that can be directly converted into actual word forms and will serve as a substitute, to some extent, for voluminous naturallanguage and table-based descriptions. In the case of endangered languages, it will act as a repository for linguistic data that may be essential for preservation. 9 DATR and KATR We discuss KATR and its relation to DATR extensively elsewhere (Finkel et al., 2002); here we only summarize the differences. The DATR formalism is quite powerful; we have demonstrated that it is capable of emulating a Turing machine. The KATR enhancements are therefore aimed at usability, not theoretical power. The principal innovations of KATR are: Set notation. The left-hand sides of DATR rules may only use list notation. KATR allows set notation as well, which allows us to deal with morphosyntactic properties in any order. Hebrew verb morphology provides abundant motivation for this enhancement. In the VERBSUFFIX node, Rule 15 identifies as an exponent of number and gende</context>
</contexts>
<marker>Finkel, Shen, Stump, Thesayi, 2002</marker>
<rawString>Raphael Finkel, Lei Shen, Gregory Stump, and Suresh Thesayi. 2002. KATR: A set-based extension of DATR. under review.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Norman M Fraser</author>
<author>Greville G Corbett</author>
</authors>
<title>Gender, animacy, and declensional class assignment: a unified account for Russian.</title>
<date>1995</date>
<booktitle>Yearbook of Morphology</booktitle>
<pages>123--150</pages>
<editor>In G. Booij and J. van Marle, editors,</editor>
<publisher>Kluwer,</publisher>
<location>Dordrecht.</location>
<contexts>
<context position="3578" citStr="Fraser and Corbett, 1995" startWordPosition="514" endWordPosition="518"> entail that concatenative and nonconcatenative morphology are fundamentally different in their grammatical status; they do not necessitate the postulation of any relation between inflectional markings and morphosyntactic properties other than the relation of simple exponence; and they are compatible with the assumption that a word form’s morphological representation is not distinct from its phonological representation. Various means of defining a language’s inflectional morphology in inferential-realizational terms are imaginable. In an important series of articles (Corbett and Fraser, 1993; Fraser and Corbett, 1995; Fraser and Corbett, 1997), Greville Corbett and Norman Fraser proposed Network Morphology, an inferential-realizational morphological framework that makes extensive use of nonmonotonic inheritance hierarchies to represent the information constituting a language’s inflectional system. Analyses in Network Morphology are implemented in DATR, a formal language for representing lexical knowledge designed and implemented by Roger Evans and Gerald Gazdar (Evans and Gazdar, 1989). In recent work, we have extended DATR, creating KATR, which is both a formal language and a computer program that genera</context>
</contexts>
<marker>Fraser, Corbett, 1995</marker>
<rawString>Norman M. Fraser and Greville G. Corbett. 1995. Gender, animacy, and declensional class assignment: a unified account for Russian. In G. Booij and J. van Marle, editors, Yearbook of Morphology 1994, pages 123–150. Kluwer, Dordrecht.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Norman M Fraser</author>
<author>Greville G Corbett</author>
</authors>
<date>1997</date>
<booktitle>Defaults in Arapesh. Lingua,</booktitle>
<pages>103--25</pages>
<contexts>
<context position="3605" citStr="Fraser and Corbett, 1997" startWordPosition="519" endWordPosition="522"> and nonconcatenative morphology are fundamentally different in their grammatical status; they do not necessitate the postulation of any relation between inflectional markings and morphosyntactic properties other than the relation of simple exponence; and they are compatible with the assumption that a word form’s morphological representation is not distinct from its phonological representation. Various means of defining a language’s inflectional morphology in inferential-realizational terms are imaginable. In an important series of articles (Corbett and Fraser, 1993; Fraser and Corbett, 1995; Fraser and Corbett, 1997), Greville Corbett and Norman Fraser proposed Network Morphology, an inferential-realizational morphological framework that makes extensive use of nonmonotonic inheritance hierarchies to represent the information constituting a language’s inflectional system. Analyses in Network Morphology are implemented in DATR, a formal language for representing lexical knowledge designed and implemented by Roger Evans and Gerald Gazdar (Evans and Gazdar, 1989). In recent work, we have extended DATR, creating KATR, which is both a formal language and a computer program that generates desired forms by interp</context>
</contexts>
<marker>Fraser, Corbett, 1997</marker>
<rawString>Norman M. Fraser and Greville G. Corbett. 1997. Defaults in Arapesh. Lingua, 103:25–57.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lauri Karttunen</author>
</authors>
<title>Finite-state constraints. In</title>
<date>1993</date>
<booktitle>The Last Phonological Rule.</booktitle>
<editor>John Goldsmith, editor,</editor>
<publisher>University of Chicago Press,</publisher>
<location>Chicago.</location>
<contexts>
<context position="33510" citStr="Karttunen, 1993" startWordPosition="5749" endWordPosition="5750">y lead to a secondgeneration KATR that better facilitates the linguist’s task. The definition of Hebrew verb inflection that we have sketched here rests on the hypothesis that an inflected word’s morphological form is determined by a system of realization rules organized in a default inheritance hierarchy. There are other approaches to defining Hebrew verb inflection; one could, for example, assume that an inflected word’s form is determined by a ranked system of violable constraints on morphological structure, as in Optimality Theory (Prince and Smolensky, 1993), or by a finitestate machine (Karttunen, 1993). The facts of Hebrew verb inflection are apparently compatible with any of these approaches. Even so, there are strong theoretical grounds for preferring our approach. It provides a uniform, well-defined architecture for the representation of both morphological rules and lexical information. Moreover, it embodies the assumption that inflectional morphology is inferential and realizational, readily accommodating such phenomena as extended exponence and the frequent underdetermination of morphosyntactic content by inflectional form; in this sense, it effectively excludes a morpheme-based concep</context>
</contexts>
<marker>Karttunen, 1993</marker>
<rawString>Lauri Karttunen. 1993. Finite-state constraints. In John Goldsmith, editor, The Last Phonological Rule. University of Chicago Press, Chicago.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alan S Prince</author>
<author>Paul Smolensky</author>
</authors>
<title>Optimality theory: Constraint interaction in generative grammar.</title>
<date>1993</date>
<tech>Technical Report RuCCs Technical Report #2,</tech>
<institution>Rutgers University Center for Cognitive Science,</institution>
<location>Piscataway, NJ.</location>
<contexts>
<context position="33463" citStr="Prince and Smolensky, 1993" startWordPosition="5739" endWordPosition="5742">are being specified. Perhaps our experience will eventually lead to a secondgeneration KATR that better facilitates the linguist’s task. The definition of Hebrew verb inflection that we have sketched here rests on the hypothesis that an inflected word’s morphological form is determined by a system of realization rules organized in a default inheritance hierarchy. There are other approaches to defining Hebrew verb inflection; one could, for example, assume that an inflected word’s form is determined by a ranked system of violable constraints on morphological structure, as in Optimality Theory (Prince and Smolensky, 1993), or by a finitestate machine (Karttunen, 1993). The facts of Hebrew verb inflection are apparently compatible with any of these approaches. Even so, there are strong theoretical grounds for preferring our approach. It provides a uniform, well-defined architecture for the representation of both morphological rules and lexical information. Moreover, it embodies the assumption that inflectional morphology is inferential and realizational, readily accommodating such phenomena as extended exponence and the frequent underdetermination of morphosyntactic content by inflectional form; in this sense, </context>
</contexts>
<marker>Prince, Smolensky, 1993</marker>
<rawString>Alan S. Prince and Paul Smolensky. 1993. Optimality theory: Constraint interaction in generative grammar. Technical Report RuCCs Technical Report #2, Rutgers University Center for Cognitive Science, Piscataway, NJ.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gregory T Stump</author>
</authors>
<title>Inflectional morphology.</title>
<date>2001</date>
<publisher>Cambridge University Press,</publisher>
<location>Cambridge, England.</location>
<contexts>
<context position="1525" citStr="Stump, 2001" startWordPosition="230" endWordPosition="231">et of rules defining the morphology of all strong verbs in all binyanim. We express these rules in KATR, both a formalism for default inheritance hierarchies and associated software for computing the forms specified by those rules. As we describe the rules, we point out general strategies for expressing morphology in KATR and we discuss KATR’s advantages over ordinary DATR for the representation of morphological systems. 1 Introduction Recent research into the nature of morphology suggests that the best definitions of a natural language’s inflectional system are inferential and realizational (Stump, 2001). A definition is inferential if it represents inflectional exponents as markings associated with the application of rules by which complex word forms are deduced from simpler roots and stems; an inferential definition of this sort contrasts with a lexical definition, according to which an inflectional exponent’s association with a particular set of morphosyntactic properties is simply stated in the lexicon, in exactly the way that the association between a lexeme’s formal and contentive properties is stipulated. In addition, a definition of a language’s inflectional system is realizational if</context>
<context position="18952" citStr="Stump, 2001" startWordPosition="3269" endWordPosition="3270">rule 13 includes the symbol ++. This symbol tells KATR that even if another, seemingly better rule matches a query, this rule should take precedence if it matches. The situation arises for the query &lt;imperfect pl 1 masc&gt;, for instance. Both rules 13 and 14 match, but the former is preferred. The other way we could have represented this situation is by restricting rule 14 to 2nd or 3rd person, either by explicitly indicating these morphosyntactic properties or by adding the atom !1, which means “not first person”. We choose to use the disambiguator ++ in Rule 13 instead; in the terminology of (Stump, 2001), the ++ symbol identifies rules that apply in “expanded mode”. The most complex node defines the stem part of a verb. STEM: &lt;&gt; = &amp;quot;&lt;binyanprefix&gt;&amp;quot; &amp;quot;&lt;cons1&gt;&amp;quot; &amp;quot;&lt;vowel1&gt;&amp;quot; &amp;quot;&lt;cons2&gt;&amp;quot; &lt;anyvowel2&gt; &amp;quot;&lt;cons3&gt;&amp;quot; % 1 &lt;anyvowel2&gt; = &amp;quot;&lt;vowel2&gt;&amp;quot; % 2 anyvowel2 perfect 3 sg fem = &amp;quot;&lt;shortvowel2&gt;&amp;quot; % 3 anyvowel2 perfect 3 pl = &amp;quot;&lt;shortvowel2&gt;&amp;quot; % 4 anyvowel2 imperfect 2 sg fem = &amp;quot;&lt;shortvowel2&gt;&amp;quot; % 5 anyvowel2 imperfect !1 pl masc = &amp;quot;&lt;shortvowel2&gt;&amp;quot; % 6 . Rule 1 uses combining to assemble the parts of the stem, starting with the binyan prefix, then alternating all the consonants and vowels. Most of these parts are surro</context>
</contexts>
<marker>Stump, 2001</marker>
<rawString>Gregory T. Stump. 2001. Inflectional morphology. Cambridge University Press, Cambridge, England.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>