<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.029083">
<title confidence="0.914694">
Semantic interpretation of Dutch spoken dialogue
</title>
<author confidence="0.934531">
Jeroen Geertzen
</author>
<affiliation confidence="0.987093">
Dept. of Communication &amp; Information Sciences
Tilburg University, The Netherlands
</affiliation>
<email confidence="0.994504">
j.geertzen@uvt.nl
</email>
<sectionHeader confidence="0.998425" genericHeader="abstract">
1 Introduction
</sectionHeader>
<bodyText confidence="0.9999593125">
Semantic interpretation involves the process of ‘translating’ natural language
to a representation of its meaning. It could be understood as the task of
mapping syntax to semantics, assuming that the syntactic relationships in
an utterance correspond to functional relationships in the meaning repre-
sentation. Relevant work in this area often uses techniques from machine
translation and machine learning in the mapping from natural language to
meaning-representation languages (e.g. [9, 7]). These approaches can be ro-
bust, and thus would be useful in dealing with large quantities of utterances,
but require large amounts of annotated data.
Since the syntax of natural language does not change much from do-
main to domain, an alternative way is to use the output of a wide-coverage
syntactic parser as a basis for single, multiple, or even open-domain lan-
guage processing. To obtain a sufficiently detailed semantic representation,
the phrases in the parses should be linked with domain-specific knowledge
concepts. In this paper, a syntactic parsing based system for the semantic
interpretation of Dutch spoken language is presented and evaluated.
</bodyText>
<sectionHeader confidence="0.96008" genericHeader="keywords">
2 Data
</sectionHeader>
<bodyText confidence="0.998974285714286">
Representation of semantic content is often expressed in some form of pred-
icate logic type formula. Examples are varieties of description logics, which
extend semantic frames and networks with a formal logic-based semantics
that uses predicates. In any case, the semantic representation should ideally
be powerful enough to take into account complexities such as negation, quan-
tification, a certain degree of under-specification and (complex) modifiers to
be interesting for use in advanced question answering systems and dialogue
</bodyText>
<page confidence="0.967238">
286
</page>
<bodyText confidence="0.973322583333333">
Proceedings of the 8th International Conference on Computational Semantics, pages 286–290,
Tilburg, January 2009. c�2009 International Conference on Computational Semantics
systems. Moreover, the logical form should be suitable to support feasi-
ble reasoning, for which also theorem provers, model builders, and model
checkers can be used. Several semantic representations have been proposed
that take these aspects into account, such as for example Quasi Logical
Forms [1] and Dynamic Predicate Logic [6]. For the approach presented
here, a simplified first order logic is used similar to quasi logical forms. The
dialogue data that is used for semantic interpretation consists of recorded
interactions with a help desk on how to operate a fax device. Examples of
resulting utterances and their corresponding semantic content, expressed by
A-expressions of first-order logic, are illustrated in the following table:
</bodyText>
<figure confidence="0.551884777777778">
utterance semantic content
1 wat moet ik nu doen? Ax . next-step(x)
(what do I have to do now?)
2 druk op een toets Ax . press(x) n button(x)
(press a button)
3 druk op de groene toets Ax . press(x) n button(x) n color(x,‘green’)
(press the green button)
4 wat doet de grote knop? Ax . function(x) n button(x) n size(x,‘big’)
(what does the big button do?)
</figure>
<bodyText confidence="0.999895857142857">
Three types of predicate groups are distinguished: action predicates,
element predicates, and property predicates. In the domain of operating
a fax device, the predicates and arguments in the logical expressions refer
to entities, properties, events, and tasks in the application domain. The
application domain of the fax device is complex but small: the domain model
consists of 70 entities with at most 10 properties, 72 higher-level actions or
tasks, and 45 different settings.
</bodyText>
<sectionHeader confidence="0.996105" genericHeader="introduction">
3 Approach
</sectionHeader>
<bodyText confidence="0.999821833333333">
The semantic representation is obtained in two stages. In the first stage, the
utterances are syntactically parsed. In the second stage, the most probable
derivation obtained in the syntactic parsing is used to construct the semantic
representation.
For the syntactic interpretation of the utterances, the Alpino Parser is
used [3]. This HPSG-based dependency parser aims to accurately provide
</bodyText>
<page confidence="0.990502">
287
</page>
<tableCaption confidence="0.574094">
full parses of unrestricted Dutch text and is publicly available.1
</tableCaption>
<bodyText confidence="0.989621652173913">
In the context of spoken dialogue processing, a syntactic parser has to
deal with fragmented input and many syntactically less well-formed utter-
ances in comparison to text parsing. For this reason, the utterances are
additionally parsed with a shallow parser, and the resulting parse is used
in case the Alpino parser fails to provide a full parse. As shallow parser, a
memory based chunk parser trained for spoken Dutch [4] is employed.
To resolve pronouns, a simple pronoun resolution algorithm has been
implemented. This algorithm is similar to the centering algorithm proposed
in [8]. While processing the utterances, each noun phrase identified is placed
on a temporary queue which is pushed on a history stack once the utterance
or turn is closed. Upon encountering a pronoun, the first element on the
queue that meets gender and number agreement is selected as antecedent.
If no candidate is found, the previous queue on the stack is evaluated until
an antecedent is found or all queues on the history stack are evaluated.
The semantic representation is constructed by traversing the dependen-
cies in the parse and by mapping words and phrases to domain concepts.
These domain concepts are events, elements, and domain tasks stored in a
database. This process of semantic interpretation is depicted and exempli-
fied in the following figure:
domain model
The approach reported here has several aspects in common with that
of Bos [2], who uses a CCG based parser [5] and assigns Discourse Rep-
resentation Structures (DRSs) to the lexical categories used by the parser
</bodyText>
<figure confidence="0.986400541666667">
&apos;See: http://www.let.rug.nl/∼vannoord/alp/Alpino/.
druk op de groene toets druk op de groene toets
hd/mad hd/mad
hd/asi1
hd/det
press(X) ^ button(X) ^ color(X,’green’)
dependency
graph
DB:events
DB:elements
mapping
DG to LF
DB:tasks
logical
form
Alpino
parser
anaphora
resolution
dependency
graph
MBSP
parse r
utterance
</figure>
<page confidence="0.993719">
288
</page>
<bodyText confidence="0.999908142857143">
after which semantic construction is driven by the syntactic derivation. A
notable difference is that Bos first constructs a DRS representation which
is subsequently translated into first-order logic. Another difference is that
in the approach described in this section, syntactic representations obtained
by the wide-coverage dependency parser are complemented with that of a
chunk parser, which increases robustness when dealing with fragmented in-
put, common in spoken dialogue.
</bodyText>
<sectionHeader confidence="0.998655" genericHeader="acknowledgments">
4 Evaluation
</sectionHeader>
<bodyText confidence="0.999972">
The approach for obtaining semantic representations has been tested on a
dataset of 160 utterances and their corresponding semantic content. All ut-
terances are related to the fax domain. The performance on identifying each
of the three types of predicates in the semantic representations is specified
in the following table:
</bodyText>
<subsubsectionHeader confidence="0.761292">
action element property
predicates predicates predicates overall
</subsubsectionHeader>
<bodyText confidence="0.989027428571428">
accuracy (%) 92.2 81.4 94.3 88.1
The results show that identification of element predicates is the least
successful. Where actions and properties are usually mentioned explicitly,
domain elements can be described in various ways. Moreover, in a sub-
stantial number of utterances pronouns are used, which cannot always be
resolved successfully. Nevertheless, an accuracy of 88.1% is achieved on
recovering complete semantic representations.
</bodyText>
<sectionHeader confidence="0.997422" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.9999788">
[1] Hiyan Alshawi. Resolving Quasi Logical Forms. Computational Linguistics,
16(3):133–144, 1990.
[2] Johan Bos. Computational semantics in discourse: Underspecification, resolu-
tion, and inference. Journal of Logic, Language and Information, 13(2):139–157,
2004.
[3] Gosse Bouma, Gertjan van Noord, and Robert Malouf. Alpino: Wide-coverage
computational analysis of dutch. In Proc. CLIN-11, pages 45–59. Amsterdam,
2001.
[4] Sander Canisius and Antal van den Bosch. A memory-based shallow parser for
spoken dutch. In Proc. CLIN-14, pages 31–45, Antwerp, 2003.
</reference>
<page confidence="0.977702">
289
</page>
<reference confidence="0.999953545454546">
[5] Stephen Clark and James R. Curran. Parsing the WSJ using CCG and log-linear
models. In Proc. ACL 2004, pages 103–110, Barcelona, 2004.
[6] Jeroen Groenendijk and Martin Stokhof. Dynamic Predicate Logic. Linguistics
and Philosophy, 14(1):39–100, 1991.
[7] Rohit J. Kate and Raymond J. Mooney. Using string-kernels for learning se-
mantic parsers. In Proc. ACL-COLING, pages 913–920, Sydney, 2006.
[8] Joel R. Tetreault. A corpus-based evaluation of centering and pronoun resolu-
tion. Computational Linguistics, 27(4):507–520, 2001.
[9] Yuk W. Wong and Raymond Mooney. Learning for semantic parsing with
statistical machine translation. In Proceedings of HLT/NAACL, pages 439–446,
New York, 2006.
</reference>
<page confidence="0.997137">
290
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.553129">
<title confidence="0.998013">Semantic interpretation of Dutch spoken dialogue</title>
<author confidence="0.983458">Jeroen</author>
<affiliation confidence="0.9978425">Dept. of Communication &amp; Information Tilburg University, The</affiliation>
<email confidence="0.565883">j.geertzen@uvt.nl</email>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Hiyan Alshawi</author>
</authors>
<title>Resolving Quasi Logical Forms.</title>
<date>1990</date>
<journal>Computational Linguistics,</journal>
<volume>16</volume>
<issue>3</issue>
<contexts>
<context position="2344" citStr="[1]" startWordPosition="340" endWordPosition="340">e of under-specification and (complex) modifiers to be interesting for use in advanced question answering systems and dialogue 286 Proceedings of the 8th International Conference on Computational Semantics, pages 286–290, Tilburg, January 2009. c�2009 International Conference on Computational Semantics systems. Moreover, the logical form should be suitable to support feasible reasoning, for which also theorem provers, model builders, and model checkers can be used. Several semantic representations have been proposed that take these aspects into account, such as for example Quasi Logical Forms [1] and Dynamic Predicate Logic [6]. For the approach presented here, a simplified first order logic is used similar to quasi logical forms. The dialogue data that is used for semantic interpretation consists of recorded interactions with a help desk on how to operate a fax device. Examples of resulting utterances and their corresponding semantic content, expressed by A-expressions of first-order logic, are illustrated in the following table: utterance semantic content 1 wat moet ik nu doen? Ax . next-step(x) (what do I have to do now?) 2 druk op een toets Ax . press(x) n button(x) (press a butto</context>
</contexts>
<marker>[1]</marker>
<rawString>Hiyan Alshawi. Resolving Quasi Logical Forms. Computational Linguistics, 16(3):133–144, 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Johan Bos</author>
</authors>
<title>Computational semantics in discourse: Underspecification, resolution, and inference.</title>
<date>2004</date>
<journal>Journal of Logic, Language and Information,</journal>
<volume>13</volume>
<issue>2</issue>
<contexts>
<context position="5538" citStr="[2]" startWordPosition="853" endWordPosition="853">nd number agreement is selected as antecedent. If no candidate is found, the previous queue on the stack is evaluated until an antecedent is found or all queues on the history stack are evaluated. The semantic representation is constructed by traversing the dependencies in the parse and by mapping words and phrases to domain concepts. These domain concepts are events, elements, and domain tasks stored in a database. This process of semantic interpretation is depicted and exemplified in the following figure: domain model The approach reported here has several aspects in common with that of Bos [2], who uses a CCG based parser [5] and assigns Discourse Representation Structures (DRSs) to the lexical categories used by the parser &apos;See: http://www.let.rug.nl/∼vannoord/alp/Alpino/. druk op de groene toets druk op de groene toets hd/mad hd/mad hd/asi1 hd/det press(X) ^ button(X) ^ color(X,’green’) dependency graph DB:events DB:elements mapping DG to LF DB:tasks logical form Alpino parser anaphora resolution dependency graph MBSP parse r utterance 288 after which semantic construction is driven by the syntactic derivation. A notable difference is that Bos first constructs a DRS representatio</context>
</contexts>
<marker>[2]</marker>
<rawString>Johan Bos. Computational semantics in discourse: Underspecification, resolution, and inference. Journal of Logic, Language and Information, 13(2):139–157, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gosse Bouma</author>
<author>Gertjan van Noord</author>
<author>Robert Malouf</author>
</authors>
<title>Alpino: Wide-coverage computational analysis of dutch.</title>
<date>2001</date>
<booktitle>In Proc. CLIN-11,</booktitle>
<pages>45--59</pages>
<location>Amsterdam,</location>
<contexts>
<context position="3968" citStr="[3]" startWordPosition="600" endWordPosition="600"> entities, properties, events, and tasks in the application domain. The application domain of the fax device is complex but small: the domain model consists of 70 entities with at most 10 properties, 72 higher-level actions or tasks, and 45 different settings. 3 Approach The semantic representation is obtained in two stages. In the first stage, the utterances are syntactically parsed. In the second stage, the most probable derivation obtained in the syntactic parsing is used to construct the semantic representation. For the syntactic interpretation of the utterances, the Alpino Parser is used [3]. This HPSG-based dependency parser aims to accurately provide 287 full parses of unrestricted Dutch text and is publicly available.1 In the context of spoken dialogue processing, a syntactic parser has to deal with fragmented input and many syntactically less well-formed utterances in comparison to text parsing. For this reason, the utterances are additionally parsed with a shallow parser, and the resulting parse is used in case the Alpino parser fails to provide a full parse. As shallow parser, a memory based chunk parser trained for spoken Dutch [4] is employed. To resolve pronouns, a simpl</context>
</contexts>
<marker>[3]</marker>
<rawString>Gosse Bouma, Gertjan van Noord, and Robert Malouf. Alpino: Wide-coverage computational analysis of dutch. In Proc. CLIN-11, pages 45–59. Amsterdam, 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Sander Canisius</author>
<author>Antal van den Bosch</author>
</authors>
<title>A memory-based shallow parser for spoken dutch.</title>
<date>2003</date>
<booktitle>In Proc. CLIN-14,</booktitle>
<pages>31--45</pages>
<location>Antwerp,</location>
<contexts>
<context position="4526" citStr="[4]" startWordPosition="689" endWordPosition="689">the utterances, the Alpino Parser is used [3]. This HPSG-based dependency parser aims to accurately provide 287 full parses of unrestricted Dutch text and is publicly available.1 In the context of spoken dialogue processing, a syntactic parser has to deal with fragmented input and many syntactically less well-formed utterances in comparison to text parsing. For this reason, the utterances are additionally parsed with a shallow parser, and the resulting parse is used in case the Alpino parser fails to provide a full parse. As shallow parser, a memory based chunk parser trained for spoken Dutch [4] is employed. To resolve pronouns, a simple pronoun resolution algorithm has been implemented. This algorithm is similar to the centering algorithm proposed in [8]. While processing the utterances, each noun phrase identified is placed on a temporary queue which is pushed on a history stack once the utterance or turn is closed. Upon encountering a pronoun, the first element on the queue that meets gender and number agreement is selected as antecedent. If no candidate is found, the previous queue on the stack is evaluated until an antecedent is found or all queues on the history stack are evalu</context>
</contexts>
<marker>[4]</marker>
<rawString>Sander Canisius and Antal van den Bosch. A memory-based shallow parser for spoken dutch. In Proc. CLIN-14, pages 31–45, Antwerp, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stephen Clark</author>
<author>James R Curran</author>
</authors>
<title>Parsing the WSJ using CCG and log-linear models.</title>
<date>2004</date>
<booktitle>In Proc. ACL 2004,</booktitle>
<pages>103--110</pages>
<location>Barcelona,</location>
<contexts>
<context position="5571" citStr="[5]" startWordPosition="860" endWordPosition="860">s antecedent. If no candidate is found, the previous queue on the stack is evaluated until an antecedent is found or all queues on the history stack are evaluated. The semantic representation is constructed by traversing the dependencies in the parse and by mapping words and phrases to domain concepts. These domain concepts are events, elements, and domain tasks stored in a database. This process of semantic interpretation is depicted and exemplified in the following figure: domain model The approach reported here has several aspects in common with that of Bos [2], who uses a CCG based parser [5] and assigns Discourse Representation Structures (DRSs) to the lexical categories used by the parser &apos;See: http://www.let.rug.nl/∼vannoord/alp/Alpino/. druk op de groene toets druk op de groene toets hd/mad hd/mad hd/asi1 hd/det press(X) ^ button(X) ^ color(X,’green’) dependency graph DB:events DB:elements mapping DG to LF DB:tasks logical form Alpino parser anaphora resolution dependency graph MBSP parse r utterance 288 after which semantic construction is driven by the syntactic derivation. A notable difference is that Bos first constructs a DRS representation which is subsequently translate</context>
</contexts>
<marker>[5]</marker>
<rawString>Stephen Clark and James R. Curran. Parsing the WSJ using CCG and log-linear models. In Proc. ACL 2004, pages 103–110, Barcelona, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jeroen Groenendijk</author>
<author>Martin Stokhof</author>
</authors>
<title>Dynamic Predicate Logic.</title>
<date>1991</date>
<journal>Linguistics and Philosophy,</journal>
<volume>14</volume>
<issue>1</issue>
<contexts>
<context position="2376" citStr="[6]" startWordPosition="345" endWordPosition="345">mplex) modifiers to be interesting for use in advanced question answering systems and dialogue 286 Proceedings of the 8th International Conference on Computational Semantics, pages 286–290, Tilburg, January 2009. c�2009 International Conference on Computational Semantics systems. Moreover, the logical form should be suitable to support feasible reasoning, for which also theorem provers, model builders, and model checkers can be used. Several semantic representations have been proposed that take these aspects into account, such as for example Quasi Logical Forms [1] and Dynamic Predicate Logic [6]. For the approach presented here, a simplified first order logic is used similar to quasi logical forms. The dialogue data that is used for semantic interpretation consists of recorded interactions with a help desk on how to operate a fax device. Examples of resulting utterances and their corresponding semantic content, expressed by A-expressions of first-order logic, are illustrated in the following table: utterance semantic content 1 wat moet ik nu doen? Ax . next-step(x) (what do I have to do now?) 2 druk op een toets Ax . press(x) n button(x) (press a button) 3 druk op de groene toets Ax </context>
</contexts>
<marker>[6]</marker>
<rawString>Jeroen Groenendijk and Martin Stokhof. Dynamic Predicate Logic. Linguistics and Philosophy, 14(1):39–100, 1991.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Rohit J Kate</author>
<author>Raymond J Mooney</author>
</authors>
<title>Using string-kernels for learning semantic parsers.</title>
<date>2006</date>
<booktitle>In Proc. ACL-COLING,</booktitle>
<pages>913--920</pages>
<location>Sydney,</location>
<contexts>
<context position="670" citStr="[9, 7]" startWordPosition="89" endWordPosition="90"> Dept. of Communication &amp; Information Sciences Tilburg University, The Netherlands j.geertzen@uvt.nl 1 Introduction Semantic interpretation involves the process of ‘translating’ natural language to a representation of its meaning. It could be understood as the task of mapping syntax to semantics, assuming that the syntactic relationships in an utterance correspond to functional relationships in the meaning representation. Relevant work in this area often uses techniques from machine translation and machine learning in the mapping from natural language to meaning-representation languages (e.g. [9, 7]). These approaches can be robust, and thus would be useful in dealing with large quantities of utterances, but require large amounts of annotated data. Since the syntax of natural language does not change much from domain to domain, an alternative way is to use the output of a wide-coverage syntactic parser as a basis for single, multiple, or even open-domain language processing. To obtain a sufficiently detailed semantic representation, the phrases in the parses should be linked with domain-specific knowledge concepts. In this paper, a syntactic parsing based system for the semantic interpre</context>
</contexts>
<marker>[7]</marker>
<rawString>Rohit J. Kate and Raymond J. Mooney. Using string-kernels for learning semantic parsers. In Proc. ACL-COLING, pages 913–920, Sydney, 2006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joel R Tetreault</author>
</authors>
<title>A corpus-based evaluation of centering and pronoun resolution.</title>
<date>2001</date>
<journal>Computational Linguistics,</journal>
<volume>27</volume>
<issue>4</issue>
<contexts>
<context position="4689" citStr="[8]" startWordPosition="713" endWordPosition="713">cly available.1 In the context of spoken dialogue processing, a syntactic parser has to deal with fragmented input and many syntactically less well-formed utterances in comparison to text parsing. For this reason, the utterances are additionally parsed with a shallow parser, and the resulting parse is used in case the Alpino parser fails to provide a full parse. As shallow parser, a memory based chunk parser trained for spoken Dutch [4] is employed. To resolve pronouns, a simple pronoun resolution algorithm has been implemented. This algorithm is similar to the centering algorithm proposed in [8]. While processing the utterances, each noun phrase identified is placed on a temporary queue which is pushed on a history stack once the utterance or turn is closed. Upon encountering a pronoun, the first element on the queue that meets gender and number agreement is selected as antecedent. If no candidate is found, the previous queue on the stack is evaluated until an antecedent is found or all queues on the history stack are evaluated. The semantic representation is constructed by traversing the dependencies in the parse and by mapping words and phrases to domain concepts. These domain conc</context>
</contexts>
<marker>[8]</marker>
<rawString>Joel R. Tetreault. A corpus-based evaluation of centering and pronoun resolution. Computational Linguistics, 27(4):507–520, 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yuk W Wong</author>
<author>Raymond Mooney</author>
</authors>
<title>Learning for semantic parsing with statistical machine translation.</title>
<date>2006</date>
<booktitle>In Proceedings of HLT/NAACL,</booktitle>
<pages>439--446</pages>
<location>New York,</location>
<contexts>
<context position="670" citStr="[9, 7]" startWordPosition="89" endWordPosition="90"> Dept. of Communication &amp; Information Sciences Tilburg University, The Netherlands j.geertzen@uvt.nl 1 Introduction Semantic interpretation involves the process of ‘translating’ natural language to a representation of its meaning. It could be understood as the task of mapping syntax to semantics, assuming that the syntactic relationships in an utterance correspond to functional relationships in the meaning representation. Relevant work in this area often uses techniques from machine translation and machine learning in the mapping from natural language to meaning-representation languages (e.g. [9, 7]). These approaches can be robust, and thus would be useful in dealing with large quantities of utterances, but require large amounts of annotated data. Since the syntax of natural language does not change much from domain to domain, an alternative way is to use the output of a wide-coverage syntactic parser as a basis for single, multiple, or even open-domain language processing. To obtain a sufficiently detailed semantic representation, the phrases in the parses should be linked with domain-specific knowledge concepts. In this paper, a syntactic parsing based system for the semantic interpre</context>
</contexts>
<marker>[9]</marker>
<rawString>Yuk W. Wong and Raymond Mooney. Learning for semantic parsing with statistical machine translation. In Proceedings of HLT/NAACL, pages 439–446, New York, 2006.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>