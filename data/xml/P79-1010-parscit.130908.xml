<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.742486">
Semantics of Conceptual Graphs
</title>
<note confidence="0.812872">
John F. Sowa
IBM Systems Research Institute
205 East 42nd Street
New York, NY 10017
</note>
<bodyText confidence="0.995500111111111">
ABSTRACT: Conceptual graphs are both a language for
representing knowledge and patterns for constructing models.
They form models in the Al sense of structures that approxi-
mate some actual or possible system in the real world. They
also form models in the logical sense of structures for which
some set of axioms are true. When combined with recent
developments in nonstandard logic and semantics, conceptual
graphs can form a bridge between heuristic techniques of Al
and formal techniques of model theory.
</bodyText>
<sectionHeader confidence="0.895909" genericHeader="method">
1. Surface Models
</sectionHeader>
<bodyText confidence="0.999635625">
Semantic networks are often used in Al for representing
meaning. But as Woods (1975) and McDermott (1976) ob-
served, the semantic networks themselves have no well-defined
semantics. Standard predicate calculus does have a precisely
defined, model theoretic semantics; it is adequate for describ-
ing mathematical theories with a closed set of axioms. But the
real world is messy, incompletely explored, and full of unex-
pected surprises. Furthermore, the infinite sets commonly
used in logic are intractable both for computers and for the
human brain.
To develop a more realistic semantics, Hintikka (1973)
proposed surface models as incomplete, but extendible, finite
constructions:
Usually, models are thought of as being given through a specifi-
cation of a number of properties and relations defined on the
domain. If the domain is infinite, this specification (as well as
many operations with such entities) may require non-trivial set-
theoretical assumptions. The process is thus often non-finitistic.
It is doubtful whether we can realistically expect such structures
to be somehow actually involved in our understanding of a sen-
tence or in our contemplation of its meaning, notwithstanding the
fact that this meaning is too often thought of as being determined
by the class of possible worlds in which the sentence in question
is true. It seems to me much likelier that what is involved in
one&apos;s actual understanding of a sentence S is a mental anticipa-
tion of what can happen in one&apos;s step-by-step investigation of a
world in which S is true. (p. 129)
The first stage of constructing a surface model begins with the
entities occurring in a sentence or story. During the construc-
tion, new facts may be asserted that block certain extensions
or facilitate others. A standard model is the limit of a surface
model that has been extended infinitely deep, but such infinite
processes are not a normal part of understanding.
This paper adapts Hintikka&apos;s surface models to the formal-
ism of conceptual graphs (Sowa 1976, 1978). Conceptual
graphs serve two purposes: like other forms of semantic net-
works, they can be used as a canonical representation of mean-
ing in natural language: but they can also be used as building
blocks for constructing abstract structures that serve as models
in the model-theoretic sense.
</bodyText>
<listItem confidence="0.97911125">
• Understanding a sentence begins with a translation of that
sentence into a conceptual graph.
• During the translation, that graph may be joined to frame-
like (Minsky 1975) or script-like (Sc;hank &amp; Abelson
1977) graphs that help resolve ambiguities and incorporate
background information.
• The resulting graph is a nucleus for constructing models of
possible worlds in which the sentence is true.
• Laws of the world behave like demons or triggers that
monitor the models and block illegal extensions.
• If a surface model could be extended infinitely deep, the
result would be a complete standard model.
</listItem>
<bodyText confidence="0.99986028125">
This approach leads to an infinite sequence of algorithms
ranging from plausible inference to exact deduction; they are
analogous to the varying levels of search in game playing pro-
grams. Level 0 would simply translate a sentence into a con-
ceptual graph, but do no inference. Level I would do frame-
like plausible inferences in joining other background graphs.
Level 2 would check constraints by testing the model against
the laws. Level 3 would join more background graphs. Level
4 would check further constraints, and so on. If the const-
raints at level n+1 are violated, the system would have to
backtrack and undo joins at level n. If at some level, all possi-
ble extensions are blocked by violations of the laws, then that
means the original sentence (or story) was inconsistent with
the laws. lithe surface model is infinitely extendible, then the
original sentence or story was consistent.
Exact inference techniques may let the surface models
grow indefinitely; but for many applications, they are as im-
practical as letting a chess playing program search the entire
game tree. Plausible inferences with varying degrees of confi-
dence are possible by stopping the surface models at different
levels of extension. For story understanding, the initial surface
model would be derived completely from the input story. For
consistency checks in updating a data base, the initial model
would be derived by joining new information to the pre-
existing data base. For question-answering, a query graph
would be joined to the data base; the depth of search permit-
ted in extending the join would determine the limits of com-
plexity of the questions that are answerable. As a result of
this theory, algorithms for plausible and exact inference can be
compared within the same framework: it is then possible to
make informed trade-offs of speed vs. consistency in data base
updates or speed vs. completeness in question answering.
</bodyText>
<sectionHeader confidence="0.839931" genericHeader="method">
2. Conceptual Graphs
</sectionHeader>
<bodyText confidence="0.856371285714286">
The following conceptual graph shows the concepts and
relationships in the sentence &amp;quot;Mary hit the piggy bank with a
hammer.&amp;quot; The boxes are concepts and the circles are concep-
tual relations. Inside each box or circle is a type label that
designates the type of concept or relation. The conceptual
relations labeled Aoni-r. INST. and p-rwr represent the linguistic
cases agent, instrument, and patient of case grammar.
</bodyText>
<page confidence="0.998965">
39
</page>
<bodyText confidence="0.994779">
Conceptual graphs are a kind of semantic network. See
Findler (1979) for surveys of a variety of such networks that
have been used in Al. The diagram above illustrates some
features of the conceptual graph notation:
</bodyText>
<listItem confidence="0.9612232">
• Some concepts are generic. They have only a type label
inside the box, e.g. HIT Or HAMMER.
• Other concepts are individual. They have a colon after the
type label, followed by a name (Mary) or a unique identifi-
er called an individual marker (122103).
</listItem>
<bodyText confidence="0.917783777777778">
To keep the diagram from looking overly busy, the hierarchy
of types and subtypes is not drawn explicitly, but is determined
by a separate partial ordering of type labels. The type labels
are used by the formation rules to enforce selection constraints
and to support the inheritance of properties from a supertype
to a subtype.
For convenience, the diagram could be linearized by using
square brackets for concepts and parentheses for conceptual
relations:
PERSON: Maryj—ik AGNT)—o(HIT:c INST)41-4HAMMERI
IHIT:c11.--IPTNThdo—IPIGOY-BANK:i22103I
Linearizing the diagram requires a coreference index, c 1, on the
generic concept HIT. The index shows that the two occur-
rences designate the same act of hitting. If HIT had been an
individual concept, its name or individual marker would be
sufficient to indicate the same act.
Besides the features illustrated in the diagram, the theory
of conceptual graphs includes the following:
</bodyText>
<listItem confidence="0.99101745">
• For any particular domain of discourse, a specially desig-
nated set of conceptual graphs called the canon.
• Four canonical formation rules for deriving new canonical
graphs from any given canon,
• A method for defining new concept types: some canonical
graph is specified as the differentia and a concept in that
graph is designated the genus of the new type.
• A method for defining new types of conceptual relations:
some canonical graph is specified as the relator and one or
more concepts in that graph are specified as parameters,
• A method for defining composite entities as structures
having other entities as parts,
• Optional quantifiers on generic concepts,
• Scope of quantifiers specified either by embedding them
inside type definitions or by linking them with functional
dependency arcs,
• Procedural attachments associated with the functional
dependency arcs,
• Control marks that determine when attached procedures
should be invoked.
</listItem>
<bodyText confidence="0.999886125">
These features have been described in the earlier papers; for
completeness, the appendix recapitulates the axioms and defi-
nitions that are explicitly used in this paper.
Heidorn&apos;s (1972, 1975) Natural Language Processor
(NLP) is being used to implement the theory of conceptual
graphs. The NLP system processes two kinds of Augmented
Phrase Structure rules: decoding rules parse language inputs
and create graphs that represent their meaning, and encoding
rules scan the graphs to generate language output. Since the
NLP structures are very similar to conceptual graphs, much of
the implementation amounts to identifying some feature or
combination of features in NLP for each construct in concep-
tual graphs. Constructs that would be difficult or inefficient to
implement directly in NIP rules can be supported by LISP
functions. The inference algorithms in this paper, however,
have not yet been implemented.
</bodyText>
<sectionHeader confidence="0.971206" genericHeader="method">
3. Logical Connectives
</sectionHeader>
<bodyText confidence="0.978566851851852">
Canonical formation rules enforce the selection constraints
in linguistics: they do not guarantee that all derived graphs
are true, but they rule out semantic anomalies. In terms of
graph grammars, the canonical formation rules are context-
free. This section defines logical operations that are context-
sensitive. They enforce tighter constraints on graph deriva-
tions, but they require more complex pattern matching. For-
mation rules and logical operations are complementary mecha-
nisms for building models of possible worlds and checking their
consistency.
Sowa (1976) discussed two ways of handling logical oper-
ators in conceptual graphs: the abstract approach, which treats
them as functions of truth values, and the direct approach,
which treats implications, conjunctions, disjunctions, and nega-
tions as operations for building, splitting, and discarding con-
ceptual graphs. That paper, however, merely mentioned the
approach; this paper develops a notation adapted from
Gentzen&apos;s sequents (1934), but with an interpretation based
on Belnap&apos;s conditional assertions (1973) and with computa-
tional techniques similar to Hendrix&apos;s partitioned semantic
networks (1975, 1979). Deliyanni and Kowalski (1979) used
a similar notation for logic in semantic networks, but with the
arrows reversed.
Definition: A sequent is a collection of conceptual graphs
divided into two sets, called the conditions and the
assertions It is written u1 u,, Sever-
al special cases are distinguished:
</bodyText>
<listItem confidence="0.965065538461538">
• A simple assertion has no conditions and only one
assertion: v.
• A disjunction has no conditions and two or more
assertions: ■••
• A simple denial has only one condition and no
assertions: u
• A compound denial has two or more conditions and no
assertions: u1,...,u„
• A conditional assertion has one or more conditions and
one or more assertions: 1 y,„.
• An empty clause has no conditions or assertions:
• A Horn clause has at most one assertion; i.e. it is ei-
ther an empty clause, a denial, a simple assertion, or a
</listItem>
<bodyText confidence="0.984021142857143">
conditional assertion of the form tit u„ v.
For any concept a in an assertion vh there may be a con-
cept b in a condition uf that is declared to be coreferent
with a.
Informally, a sequent states that if all of the conditions are
true, then at least one of the assertions must be true. A se-
quent with no conditions is an unconditional assertion; if there
</bodyText>
<figure confidence="0.986807">
PERSON Mary
HAMMER
HIT
PIGGY-BANK: i22103
</figure>
<page confidence="0.984516">
40
</page>
<bodyText confidence="0.999925444444444">
are two or more assertions, it states that one must be true, but
it doesn&apos;t say which. Multiple assertions are necessary for
generality, but in deductions, they may cause a model to split
into models of multiple alternative worlds. A sequent with no
assertions denies that the combination of conditions can ever
occur. The empty clause is an unconditional denial; it is self-
contradictory. Horn clauses are special cases for which deduc-
tions are simplified: they have no disjunctions that cause
models of the world to split into multiple alternatives.
</bodyText>
<listItem confidence="0.840530166666667">
Definition: Let C be a collection of canonical graphs, and let s
be the sequent ul
• If every condition graph is covered by some graph in
C, then the conditions are said to be satisfied.
• If some condition graph is not covered by any graph in
C, then the sequent s is said to be inapplicable to C.
</listItem>
<bodyText confidence="0.973189166666667">
If n=0 (there are no conditions), then the conditions are
trivially satisfied.
A sequent is like a conditional assertion in Belnap&apos;s sense:
When its conditions are not satisfied, it asserts nothing. But
when they are satisfied, the assertions must be added to the
current context. The next axiom states how they are added.
</bodyText>
<listItem confidence="0.858817307692308">
Axiom: Let C be a collection of canonical graphs, and let s be
the sequent vi,...,v„,. If the conditions of s are
satisfied by C, then s may be applied to C as follows:
• If m.0 (a denial or the empty clause), the collection
C is said to be blocked.
• If m.1 (a Horn clause), a copy of each graph u, is
joined to some graph in C by a covering join. Then
the assertion v is added to the resulting collection C&apos;.
• If rn&gt;2, a copy of each graph u; is joined to some
graph in C by a covering join. Then all graphs in the
resulting collection C&apos; are copied to make m disjoint
collections identical to C&apos;. Finally, for each j from I
to m, ihe assertion v, is added to the j-th copy of C&apos;.
</listItem>
<bodyText confidence="0.99985692">
After an assertion v is added to one of the collections C&apos;,
each concept in v that was declared to be coreferent with
some concept b in one of the conditions u; is joined to that
concept to which b was joined.
When a collection of graphs is inconsistent with a sequent,
they are blocked by it. If the sequent represents a fundamen-
tal law about the world, then the collection represents an
impossible situation. When there is only one assertion in an
applicable sequent, the collection is extended. But when there
are two or more assertions, the collection splits into as many
successors as there are .assertions; this splitting is typical of
algorithms for dealing with disjunctions. The rules for apply-
ing sequents are based on Beth&apos;s semantic tableaux (1955).
but the computational techniques are similar to typical Al
methods of production rules, demons, triggers, and monitors.
Deliyanni and Kowalski (1979) relate their algorithms for
logic in semantic networks to the resolution principle. This
relationship is natural because a sequent whose conditions and
assertions are all atoms is equivalent to the standard clause
form for resolution. But since the sequents defined in this
paper may be arbitrary conceptual graphs, they can package a
much larger amount of information in each graph than the low
level atoms of ordinary resolution. As a result, many fewer
steps may be needed to answer a question or do plausible
inferences.
</bodyText>
<listItem confidence="0.446014">
4. Laws, Facts, and Possible Worlds
</listItem>
<bodyText confidence="0.998899322033899">
Infinite families of possible worlds are computationally
intractable, hut Dunn (1973) showed that they are not needed
for the semantics of modal logic. He considered each possible
world w to he characterized by two sets of propositions: laws
L and facts F. Every law is also a fact, but some facts are
merely contingently true and are not considered laws. A prop-
osition p is necessarily true in w if it follows from the laws of
w, and it is possible in w if it is consistent with the laws of w.
Dunn proved that semantics in terms of laws and facts is
equivalent to the possible worlds semantics.
Dunn&apos;s approach to modal logic can be combined with
Hintikka&apos;s surface models and Al methods for handling de-
faults. Instead of dealing with an infinite set of possible
worlds, the system can construct finite, but extendible surface
models. The basis for the surface models is a canon that
contains the blueprints for assembling models and a set of laws
that must be true for each model. The laws impose obligatory
constraints on the models, and the canon contains common
background information that serves as a heuristic for extending
the models.
An initial surface model would start as a canonical graph
or collection of graphs that represent a given set of facts in a
sentence or story. Consider the story,
Mary hit the piggy bank with a hammer. She wanted to go to the
movies with Janet. but she wouldn&apos;t get her allowance until
Thursday. And today was only Tuesday.
The first sentence would be translated to a conceptual graph
like the one in Section 2. Each of the following sentences
would be translated into other conceptual graphs and joined to
the original graph. But the story as stated is not understanda-
ble without a lot of background information: piggy banks
normally contain money; piggy banks are usually made of
pottery that is easily broken; going to the movies requires
money; an allowance is money; and Tuesday precedes Thurs-
day.
Charniak (1972) handled such stories with demons that
encapsulate knowledge: demons normally lie dormant, but
when their associated patterns occur in a story, they wake up
and apply their piece of knowledge to the process of under-
standing. Similar techniques are embodied in production sys-
tems, languages like PLANNER (Hewitt 1972), and knowl-
edge representation systems like KRL (Bobrow &amp; Winograd
1977). But the trouble with demons is that they are uncon-
strained: anything can happen when a demon wakes up, no
theorems are possible about what a collection of demons can
or cannot do, and there is no way of relating plausible reason-
ing with demons to any of the techniques of standard or non-
standard logic.
With conceptual graphs, the computational overhead is
about the same as with related Al techniques, but the advan-
tage is that the methods can be analyzed by the vast body of
techniques that have been developed in logic. The graph for
&amp;quot;Mary hit the piggy-bank with a hammer&amp;quot; is a nucleus around
which an infinite number of possible worlds can be built. Two
individuals. Mary and PIGGY-BANK:122103, are fixed, but the
particular act of hitting, the hammer Mary used, and all other
circumstances are undetermined. As the story continues, some
other individuals may be named, graphs from the canon may
be joined to add default information, and laws of the world in
</bodyText>
<page confidence="0.998731">
41
</page>
<bodyText confidence="0.999707068965517">
the form of sequents may be triggered (like demons) to en-
force constraints. The next definition introduces the notion of
a world basis that provides the building material (a canon) and
the laws (sequents) for such a family of possible worlds.
Definition: A world basis has three components: a canon C, a
finite set of sequents L called laws, and one or more finite
collections of canonical graphs [C1 .....C,,} called contexts.
No context C, may be blocked by any law in L.
A world basis is a collection of nuclei from which complete
possible worlds may evolve. The contexts are like Hintikka&apos;s
surface models: they are finite, but extendible. The graphs in
the canon provide default or plausible information that can be
joined to extend the contexts, and the laws are constraints on
the kinds of extensions that are possible.
When a law is violated, it blocks a context as a candidate
for a possible world. A default, however, is optional; if con-
tradicted, a default must be undone, and the context restored
to the state before the default was applied. In the sample
story, the next sentence might continue: &amp;quot;The piggy bank was
made of bronze, and when Mary hit it, a genie appeared and
gave her two tickets to Animal House.&amp;quot; This continuation
violates all the default assumptions; it would be unreasonable
to assume it in advance, but once given, it forces the system to
back up to a context before the defaults were applied and join
the new information to it. Several practical issues arise: how
much backtracking is necessary, how is the world basis used to
develop possible worlds, and what criteria are used to decide
when to stop the (possibly infinite) extensions. The next sec-
tion suggests an answer.
</bodyText>
<sectionHeader confidence="0.963264" genericHeader="method">
5. Game Theoretic Semantics
</sectionHeader>
<bodyText confidence="0.99949">
The distinction between optional defaults and obligatory
laws is reminiscent of the AND-OR trees that often arise in
Al, especially in game playing programs. In fact, Hintikka
(1973, 1974) proposed a game theoretic semantics for testing
the truth of a formula in terms of a model and for elaborating
a surface model in which that formula is true. Hintikka&apos;s
approach can be adapted to elaborating a world basis in much
the same way that a chess playing program explores the game
tree:
</bodyText>
<listItem confidence="0.955294333333333">
• Each context represents a position in the game.
• The canon defines Possible moves by the current player.
• Conditional assertions are moves by the opponent.
• Denials are checkmating moves by the opponent.
• A given context is consistent with the laws if there exists a
strategy for avoiding checkmate.
</listItem>
<bodyText confidence="0.9752092">
By following this suggestion, one can adapt the techniques
developed for game playing programs to other kinds of reason-
ing in Al.
Definition: A game over a world basis W is defined by the
following rules:
</bodyText>
<listItem confidence="0.92371">
• There are two participants named Player and Oppo-
nent.
• For each context in W, Player has the first move.
• Player moves in context C either by joining two graphs
in C or by selecting any graph in the canon of W that
is joinable to some graph u in C and joining it maxi-
mally to u. If no joins are possible. Player passes.
Then Opponent has the right to move in context C.
• Opponent moves by checking whether any denials in
</listItem>
<bodyText confidence="0.7069828">
W are satisfied by C. If so, context C is blocked and
is deleted from W. If no denials are satisfied, Oppo-
nent may apply any other sequent that is satisfied in C.
If no sequent is satisfied, Opponent passes. Then
Player has the right to move in context C.
</bodyText>
<listItem confidence="0.898751333333333">
• If no contexts are left in W, Player loses.
• If both Player and Opponent pass in succession, Player
wins.
</listItem>
<bodyText confidence="0.9998806875">
Player wins this game by building a complete model that is
consistent with the laws and with the initial information in the
problem. But like playing a perfect game of chess, the cost of
elaborating a complete model is prohibitive. Yet a computer
can play chess as well as most people do by using heuristics to
choose moves and terminating the search after a few levels.
To develop systematic heuristics for choosing which graphs to
join, Sows (1976) stated rules similar to Wilks&apos; preference
semantics (1975).
The amount of computation required to play this game
might be compared to chess: a typical middle game in chess
has about 30 or 40 moves on each side, and chess playing
programs can consistently beat beginners by searching only 3
levels deep; they can play good games by searching 5 levels.
The number of moves in a world basis depends on the number
of graphs in the canon, the number of laws in L, and the num-
ber of graphs in each context. But for many common applica-
tions, 30 or 40 moves is a reasonable estimate at any given
level, and useful inferences are possible with just a shallow
search. The scripts applied by Schank and Abelson (1977),
for example, correspond to a game with only one level of
look-ahead; a game with two levels would provide the plausible
information of scripts together with a round of consistency
checks to eliminate obvious blunders.
By deciding how far to search the game tree, one can
derive algorithms for plausible inference with varying levels of
confidence. Rigorous deduction similar to model elimination
(Loveland 1972) can be performed by starting with laws and a
context that correspond to the negation of what is to be proved
and showing that Opponent has a winning strategy. By similar
transformations, methods of plausible and exact inference can
be related as variations on a general method of reasoning.
</bodyText>
<sectionHeader confidence="0.852559" genericHeader="method">
6. Appendix: Summary of the Formalism
</sectionHeader>
<bodyText confidence="0.992184">
This section summarizes axioms, definitions, and theorems about
conceptual graphs that are used in this paper. For a more complete discus-
sion and for other features of the theory that are not used here, see the
earlier articles by Sowa (1976, 1978).
Definition I: A conceptual graph is a finite, connected, bipartite graph
with nodes of the first kind called concepts and nodes of the second
kind called conceptual relations.
Definition 2: Every conceptual relation has one or more arcs, each of
which must be attached to a concept. If the relation has n arcs, it is
said to be n-adic, and its arcs are labeled 1. 2.....a.
The most common conceptual relations are dyadic (2-adic). but the
definition mechanisms can create ones with any number of arcs. Although
the formal definition says that the arcs are numbered, for dyadic relations.
arc I is drawn as an arrow pointing towards the circle, and arc 2 as an
arrow pointing away from the circle.
</bodyText>
<page confidence="0.997638">
42
</page>
<bodyText confidence="0.591787">
Axiom I: There is a set T of type labels and a function type, which maps
concepts and conceptual relations into T.
</bodyText>
<listItem confidence="0.972311666666667">
• If typelal=type(h), then a and h are said to he of the same type.
• Type labels are partially ordered: if typetal&lt;type(b). then a is
said to be a subtype of h.
</listItem>
<bodyText confidence="0.82253275">
Type labels of concepts and conceptual relations are disjoint.
noncomparable subsets of T: if a is a concept and r is a concep-
tual relation, then a and r may never he of the same type, nor
may one be a subtype of the other.
</bodyText>
<listItem confidence="0.772791333333333">
Axiom 2: There is a set llil, i2, i3. whose elements are called
individual markers. The function referent applies to concepts:
• If a is a concept, then referent/a) is either an individual marker in
I or the symbol @, which may be read any.
• When referenda) e I. then a is said to be an individual concept.
• When referenda)..@, then a is said to he a generic concept.
</listItem>
<figureCaption confidence="0.834454222222222">
In diagrams, the referent is written after the type label, separated by a
colon. A concept of a particular cat could be written as IcAT:i4i331. A
generic concept, which would refer to any cat, could he written icAT:00 or
simply ICAT1. In data base systems, individual markers correspond to the
surrogates (Codd 1979), which serve as unique internal identifiers for
external entities. The symbol @ is Codd&apos;s notation for null or unknown
values in a data base. Externally printable or speakable names are related
to the internal surrogates by the next axiom.
Axiom 3: There is a dyadic conceptual relation with type label NAME. If
a relation of type NAME occurs in a conceptual graph, then the con-
cept attached to arc 1 must be a subtype of WORD, and the concept
attached to arc 2 must be a subtype of ENTITY. If the second concept
is individual, then the first concept is called a name of that individual.
The following graph states that the word &amp;quot;Mary&amp;quot; is the name of a
particular person: (&amp;quot;Mary&amp;quot;1—.INAMEJ—.1.PERSON:i30741. If there is only one
person named Mary in the context, the graph could be abbreviated to just
(PERSON:Maryl.
Axiom 4: The conformity relation :: relates type labels in T to individual
</figureCaption>
<listItem confidence="0.894394">
markers in I. If tET, in, and then i is said to conform to t.
• If and then s::i.
• For any type t.
• For any concept c. type(c)::referent(c).
</listItem>
<bodyText confidence="0.898353357142857">
The conformity relation says that the individual for which the marker
i is a surrogate is of type t. In previous papers, the terms permissible or
applicable were used instead of conforms to. but the present term and the
symbol :: have been adopted from ALGOL-68. Suppose the individual
marker i273 is a surrogate for a beagle named Snoopy. Then BEAGLE::i273
is true. By extension, one may also write the name instead of the marker,
as BEAGLE::Snoopy. By axiom 4, Snoopy also conforms to all supertypes of
BEAGLE. such as DOG::Snoopy, ANIMAL::Snoopy, or ENTITY::Snoopy.
Definition 3: A star graph is a conceptual graph consisting of a single
conceptual relation and the concepts attached to each of its arcs.
(Two or more arcs of the conceptual relation may be attached to the
same concept.)
Definition 4: Two concepts a and b are said to be joinable if both of the
following properties are true:
</bodyText>
<listItem confidence="0.9989525">
• They are of the same type: typelali.typelb).
• Either referentlah.referent(b), referent(a)@, or referendblmg.
</listItem>
<bodyText confidence="0.933229">
Two star graphs with conceptual relations r and s are said to be
joinable if • and a have the same number of arcs, type(r)-type(s), and
for each i, the concept attached to arc i of r is joinable to the concept
attached to arc i of s.
Not all combinations of concepts and conceptual relations are mean-
ingful. Yet to say that some graphs are meaningful and others are not is
begging the question, because the purpose of conceptual graphs is to form
the basis of a theory of meaning. To avoid prejudging the issue, the term
canonical is used for those graphs derivable from a designated set called
the canon. For any given domain of discourse, a canon is defined that
rules out anomalous combinations.
</bodyText>
<listItem confidence="0.807008666666667">
Definition 5: A canon has three components:
• A partially ordered set T of type labels.
• A set 1 of individual markers with a conformity relation ::.
</listItem>
<bodyText confidence="0.865187769230769">
A finite set of conceptual graphs with type of concepts and
conceptual relations in I and with referents either (a. or markers
in I.
The number of possible canonical graphs may be infinite. hut the
canon contains a finite number from which all the others can he derived.
With an appropriate canon. many undesirable graphs arc ruled out as
noncanonical, but the canonical graphs are not necessarily true. To ensure
that only true graphs are derived from true graphs. the laws discussed in
Section 4 eliminate inconsistent combinations.
Axiom 5: A conceptual graph is called canonical either if it is in the canon
or if it is derivable from canonical graphs by one of the following
canonical formation rules. Let u and v be canonical graphs (a and v
may be the same graph).
</bodyText>
<listItem confidence="0.944459">
• Copy: An exact copy of u is canonical.
• Restrict: Let a be a concept in u, and let t be a type label where
i&lt;typelal and t::referentla). Then the graph obtained by changing
the type label of a to t and leaving referenda) unchanged is can-
onical.
• Join on a concept: Let a be a concept in u, and b a concept in v.
If a and b are joinable, then the graph derived by the following
steps is canonical: First delete b from v; then attach to a all arcs
of conceptual relations that had been attached to b. If referenda)
e 1, then referent(a) is unchanged: otherwise, referenda) is re-
placed by referent(b).
• Join on a star: Let r be a conceptual relation in u, and a a con-
</listItem>
<bodyText confidence="0.979385476190476">
ceptual relation in v. If the star graphs of r and s are joinable,
then the graph derived by the following steps is canonical: First
delete s and its arcs from v; then for each i. join the concept
attached to arc i of r to the concept that had been attached to
arc i of a.
Restriction replaces a type label in a graph by the label of a subtype:
this rule lets subtypes inherit the structures that apply to more general
types. Join on a concept combines graphs that have concepts of the same
type: one graph is overlaid on the other so that two concepts of the same
type merge into a single concept; as a result, all the arcs that had been
connected to either concept are connected to the single merged concept.
Join on a star merges a conceptual relation and all of its attached concepts
in a single operation.
Definition 6: Let v be a conceptual graph, let to be a suhgraph of v in
which every conceptual relation has exactly the same arcs as in v, and
let u be a copy of v in which zero or more concepts may he restricted
to subtypes. Then u is called a projection of v, and v is called a
projective origin of u in v.
The main purpose of projections is to define the rule of join on a
common projection, which is a generalization of the rules for joining on a
concept or a star.
</bodyText>
<construct confidence="0.858660222222222">
Definition 7: If a conceptual graph u is a projection of both v and w. it is
called a common projection of v and w.
Theorem 1: If u is a common projection of canonical graphs v and w. then
v and w may be joined on the common projection u to form a canonical
graph by the following steps:
Let v be a projective origin of u in v, and let w be a projective
origin of u in w.
Restrict each concept of v and w to the type label of the corre-
sponding concept in u.
</construct>
<listItem confidence="0.9881065">
• Join each concept of v to the corresponding concept of w.
• Join each star graph of v to the corresponding star of iv.
</listItem>
<page confidence="0.999557">
43
</page>
<bodyText confidence="0.992740375">
The concepts and conceptual relations in the resulting graph consist of
those in v— w—w, and a copy of u.
Definition 8: If v and w are joined on a common projection u, then all
concepts and conceptual relations in the projective origin of u in v and
the projective origin of u in w are said to be covered by the join. In
particular, if the projective origin of u in v includes all of v, then the
entire graph v is covered by the join, and the join is called a covering
join of v by w.
</bodyText>
<construct confidence="0.889061666666667">
Definition 9: Let v and w be joined on a common projection u. The join
is called extendible if there exist some concepts a in v and b in w with
the following properties:
</construct>
<listItem confidence="0.989355285714286">
• The concepts a and b were joined to each other.
• a is attached to a conceptual relation r that was not covered by
the join.
• b is attached to a conceptual relation s that was not covered by
the join.
• The star graphs of r and s are joinable.
If a join is not extendible, it is called maximal.
</listItem>
<bodyText confidence="0.9621598">
The definition of maximal join given here is simpler than the one
given in Sowa (1976), but it has the same result. Maximal joins have the
effect of Wilks&apos; preference rules (1975) in forcing a maximum connectivity
of the graphs. Covering joins are used in Section 3 in the rules for apply-
ing sequence.
</bodyText>
<subsubsectionHeader confidence="0.442388">
Theorem 2: Every covering join is maximal.
</subsubsectionHeader>
<bodyText confidence="0.998651666666667">
Sowa (1976) continued with further material on quantifiers and
procedural attachments. and Sowa (1978) continued with mechanisms for
defining new types of concepts, conceptual relations, and composite
entities that have other entities as parts. Note that the terms sort, subsort,
and well-formed in Sows (1976) have now been replaced by the terms type,
subtype, and canonical.
</bodyText>
<sectionHeader confidence="0.969678" genericHeader="conclusions">
7. Acknowledgment
</sectionHeader>
<bodyText confidence="0.9939245">
I would like to thank Charles Bontempo, Jon Handel. and George
Heidorn for helpful comments on earlier versions of this paper.
</bodyText>
<sectionHeader confidence="0.971559" genericHeader="references">
8. References
</sectionHeader>
<reference confidence="0.999659483870968">
Belnap, Nuel D.. Jr. (1973) &amp;quot;Restricted Quantification and Conditional
Assertion,&amp;quot; in Leblanc (1973) pp. 48-75.
Beth, E. W. (1955) &amp;quot;Semantic Entailment and Formal Derivability,&amp;quot;
reprinted in J. Hintikka, ed., The Philosophy of Mathematics, Oxford
University Press, 1969. pp. 9-41.
Bobrow, D. G.. &amp; T. Winograd (1977) &amp;quot;An Overview of KRL-0, a Knowl-
edge Representation Language,&amp;quot; Cognitive Science. voL 1, pp. 3-46.
Charniak, Eugene (1972) Towards a Model of Children&apos;s Stoty Comprehen-
sion. Al Memo No. 266, MIT Project MAC. Cambridge, Mass.
Codd, E. F. (1979) &amp;quot;Extending the Data Base Relational Model to Cap-
ture More Meaning.&amp;quot; to appear in Transactions on Database Systems.
Deliyanni, Amaryllis. &amp; Robert A. Kowalski (1979) &amp;quot;Logic and Semantic
Networks,&amp;quot; Communications of the ACM, vol. 22, no. 3, pp. 184-192.
Dunn. J. Michael (1973) &amp;quot;A Truth Value Semantics for Modal Logic,&amp;quot; in
Leblanc (1973) pp. 87-100.
Findler, Nicholas V., ed. (1979) Associative Networks, Academic Press,
New York,
Gentzen. Gerhard (1934) &amp;quot;Investigations into Logical Deduction,&amp;quot; reprint-
ed in M. E. Szabo. ed., The Collected Papers of Gerhard Gentsen,
North-Holland. Amsterdam, 1969. pp. 68-131.
1-leidorn, George E. (1972) Natural Language Inputs to a Simulation
Programming System. Technical Report NPS-55HD7210IA, Naval
Postgraduate School. Monterey.
Heidorn, George E. (1975) &amp;quot;Augmented Phrase Structure Grammar.&amp;quot; in
R. Schank &amp; B. L. Nash-Webber, eds., Theoretical Issues in Natural
Language Processing, pp. 1-5.
Hendrix, Gary G. (1975) &amp;quot;Expanding the Utility of Semantic Networks
through Partitioning,&amp;quot; in Proc. of the Fourth 1./CAL Tbilisi, Georgia.
USSR. pp. 115-121.
Hendrix. Gary G. (1979) &amp;quot;Encoding Knowledge in Partitioned Networks.&amp;quot;
in Findler (1979) pp. 51-92.
Hewitt. Carl (1972) Description and Theoretical Analysis (Using Schemata)
of PLANNER, Al Memo No. 251, MIT Project MAC, Cambridge,
Mass.
Hintikka. Jaakko (1973) &amp;quot;Surface Semantics: Definition and its Motiva-
tion,&amp;quot; in Leblanc (1973) pp. 128-147.
Hintikka, Jaakko (1974) &amp;quot;Quantifiers vs. Quantification Theory,&amp;quot; Linguis-
tic Inquiry. vol. 5, no. 2. pp. 153-177.
Hintikka, Jaakko, &amp; Esa Saarinen (1975) &amp;quot;Semantical Games and the
Bach-Peters Paradox.&amp;quot; Theoretical Linguistics. vol. 2, pp. 1-20.
Leblanc, Hughes, ed. (1973) Truth. Syntax, and Modality. North-Holland
Publishing Co., Amsterdam,
Loveland, D. W. (1972) &amp;quot;A Unifying View of Some Linear Herbrand
Procedures,&amp;quot; Journal of the ACM, vol. 19, no. 2, pp. 366-384.
McDermott, Drew V. (1976) &amp;quot;Artificial Intelligence Meets Natural Stupid-
ity,&amp;quot; SiGART Newsletter. No. 57, pp. 4-9.
Minsky, Marvin (1975) &amp;quot;A Framework for Representing Knowledge.&amp;quot; in
Winston, P. H., ed.. The Psychology of Computer Vision, McGraw-Hill,
New York. pp. 211-280.
Schank, Roger, &amp; Robert Abelson (1977) Scripts. Plans. Goals and Under-
standing, Lawrence Erlbaum Associates, Hillsdale. N. J.
Sown, John F. (1976) &amp;quot;Conceptual Graphs for a Data Base Interface,&amp;quot;
IBM Journal of Research &amp; Development, vol. 20, pp. 336-357.
Sowa, John F. (1978) &amp;quot;Definitional Mechanisms for Conceptual Graphs,&amp;quot;
presented at the International Workshop on Graph Grammars, Bad
Honnef, Germany, Nov. 1978.
Wilks. Yorick (1975) &amp;quot;Preference Semantics.&amp;quot; in E. L. Keenan, ed.,
Formal Semantics of Natural Language. Cambridge University Press,
pp. 329-348.
Woods, William A. (1975) &amp;quot;What&apos;s in a Link: Foundations for Semantic
Networks.&amp;quot; in D. G. Bobrow &amp; A. Collins, eds., Representation and
Understanding, Academic Press. New York.
</reference>
<page confidence="0.999295">
44
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.030227">
<title confidence="0.999718">Semantics of Conceptual Graphs</title>
<author confidence="0.999889">John F Sowa</author>
<affiliation confidence="0.999999">IBM Systems Research Institute</affiliation>
<address confidence="0.9995535">205 East 42nd Street New York, NY 10017</address>
<abstract confidence="0.996189643564357">Conceptual graphs are both a language for representing knowledge and patterns for constructing models. They form models in the Al sense of structures that approximate some actual or possible system in the real world. They also form models in the logical sense of structures for which some set of axioms are true. When combined with recent developments in nonstandard logic and semantics, conceptual graphs can form a bridge between heuristic techniques of Al and formal techniques of model theory. 1. Surface Models Semantic networks are often used in Al for representing meaning. But as Woods (1975) and McDermott (1976) observed, the semantic networks themselves have no well-defined semantics. Standard predicate calculus does have a precisely defined, model theoretic semantics; it is adequate for describmathematical theories with a closed set of axioms. real world is messy, incompletely explored, and full of unexpected surprises. Furthermore, the infinite sets commonly used in logic are intractable both for computers and for the human brain. To develop a more realistic semantics, Hintikka (1973) proposed surface models as incomplete, but extendible, finite constructions: Usually, models are thought of as being given through a specification of a number of properties and relations defined on the domain. If the domain is infinite, this specification (as well as many operations with such entities) may require non-trivial settheoretical assumptions. The process is thus often non-finitistic. It is doubtful whether we can realistically expect such structures to be somehow actually involved in our understanding of a sentence or in our contemplation of its meaning, notwithstanding the fact that this meaning is too often thought of as being determined by the class of possible worlds in which the sentence in question is true. It seems to me much likelier that what is involved in one&apos;s actual understanding of a sentence S is a mental anticipation of what can happen in one&apos;s step-by-step investigation of a world in which S is true. (p. 129) stage of constructing a surface model begins with the entities occurring in a sentence or story. During the construcmay be asserted that block certain extensions facilitate others. A standard model is the limit of a has infinitely deep, but such infinite processes are not a normal part of understanding. This paper adapts Hintikka&apos;s surface models to the formalism of conceptual graphs (Sowa 1976, 1978). Conceptual graphs serve two purposes: like other forms of semantic networks, they can be used as a canonical representation of meaning in natural language: but they can also be used as building blocks for constructing abstract structures that serve as models in the model-theoretic sense. • Understanding a sentence begins with a translation of that sentence into a conceptual graph. During the translation, that graph may be joined framelike (Minsky 1975) or script-like (Sc;hank &amp; Abelson 1977) graphs that help resolve ambiguities and incorporate background information. The resulting graph a for constructing models of possible worlds in which the sentence is true. • Laws of the world behave like demons or triggers that monitor the models and block illegal extensions. • If a surface model could be extended infinitely deep, the result would be a complete standard model. This approach leads to an infinite sequence of algorithms ranging from plausible inference to exact deduction; they are analogous to the varying levels of search in game playing programs. Level 0 would simply translate a sentence into a congraph, but do no inference. Level do framelike plausible inferences in joining other background graphs. Level 2 would check constraints by testing the model against the laws. Level 3 would join more background graphs. Level 4 would check further constraints, and so on. If the constraints at level n+1 are violated, the system would have to and undo joins at level at some level, all possible extensions are blocked by violations of the laws, then that means the original sentence (or story) was inconsistent with the laws. lithe surface model is infinitely extendible, then the original sentence or story was consistent. Exact inference techniques may let the surface models grow indefinitely; but for many applications, they are as impractical as letting a chess playing program search the entire game tree. Plausible inferences with varying degrees of confidence are possible by stopping the surface models at different levels of extension. For story understanding, the initial surface model would be derived completely from the input story. For consistency checks in updating a data base, the initial model would be derived by joining new information to the preexisting data base. For question-answering, a query graph would be joined to the data base; the depth of search permitted in extending the join would determine the limits of complexity of the questions that are answerable. As a result of theory, algorithms for plausible exact inference can be compared within the same framework: it is then possible to make informed trade-offs of speed vs. consistency in data base updates or speed vs. completeness in question answering. 2. Conceptual Graphs The following conceptual graph shows the concepts and relationships in the sentence &amp;quot;Mary hit the piggy bank with a hammer.&amp;quot; The boxes are concepts and the circles are conceptual relations. Inside each box or circle is a type label that designates the type of concept or relation. The conceptual labeled represent the linguistic cases agent, instrument, and patient of case grammar. 39 Conceptual graphs are a kind of semantic network. See Findler (1979) for surveys of a variety of such networks that have been used in Al. The diagram above illustrates some features of the conceptual graph notation: Some concepts generic. have only a label the box, e.g. Or HAMMER. Other concepts individual. They a colon after the label, followed by name or a unique identificalled an marker keep from looking overly busy, the hierarchy of types and subtypes is not drawn explicitly, but is determined by a separate partial ordering of type labels. The type labels are used by the formation rules to enforce selection constraints and to support the inheritance of properties from a supertype to a subtype. For convenience, the diagram could be linearized by using square brackets for concepts and parentheses for conceptual relations: PERSON: Maryj—ik AGNT)—o(HIT:c INST)41-4HAMMERI IHIT:c11.--IPTNThdo—IPIGOY-BANK:i22103I the diagram requires a index, 1, on the concept index shows that the two occurdesignate the same act of hitting. If been an individual concept, its name or individual marker would be sufficient to indicate the same act. Besides the features illustrated in the diagram, the theory of conceptual graphs includes the following: • For any particular domain of discourse, a specially desigset of conceptual graphs called the Four formation rules deriving new any given canon, • A method for defining new concept types: some canonical is specified as the a concept in that is designated the the new type. • A method for defining new types of conceptual relations: canonical graph is specified as the one or concepts in that graph are specified as • A method for defining composite entities as structures other entities as • Optional quantifiers on generic concepts, • Scope of quantifiers specified either by embedding them inside type definitions or by linking them with functional dependency arcs, • Procedural attachments associated with the functional dependency arcs, • Control marks that determine when attached procedures should be invoked. These features have been described in the earlier papers; for completeness, the appendix recapitulates the axioms and definitions that are explicitly used in this paper. Heidorn&apos;s (1972, 1975) Natural Language Processor (NLP) is being used to implement the theory of conceptual graphs. The NLP system processes two kinds of Augmented Structure rules: rules language inputs create graphs that represent their meaning, and the graphs to generate language output. Since the NLP structures are very similar to conceptual graphs, much of the implementation amounts to identifying some feature or combination of features in NLP for each construct in conceptual graphs. Constructs that would be difficult or inefficient to implement directly in NIP rules can be supported by LISP functions. The inference algorithms in this paper, however, have not yet been implemented. 3. Logical Connectives Canonical formation rules enforce the selection constraints in linguistics: they do not guarantee that all derived graphs are true, but they rule out semantic anomalies. In terms of graph grammars, the canonical formation rules are contextfree. This section defines logical operations that are contextsensitive. They enforce tighter constraints on graph derivations, but they require more complex pattern matching. Formation rules and logical operations are complementary mechanisms for building models of possible worlds and checking their consistency. Sowa (1976) discussed two ways of handling logical operin conceptual graphs: the approach, treats as functions of truth values, and the approach, which treats implications, conjunctions, disjunctions, and negations as operations for building, splitting, and discarding conceptual graphs. That paper, however, merely mentioned the approach; this paper develops a notation adapted from Gentzen&apos;s sequents (1934), but with an interpretation based on Belnap&apos;s conditional assertions (1973) and with computational techniques similar to Hendrix&apos;s partitioned semantic networks (1975, 1979). Deliyanni and Kowalski (1979) used a similar notation for logic in semantic networks, but with the arrows reversed. A a collection of conceptual graphs into two sets, called the the is written u,, al special cases are distinguished: A assertion no conditions and only one assertion: v. A no conditions and two or more A denial only one condition and no A denial two or more conditions and no A assertion one or more conditions and or more assertions: An clause no conditions or assertions: A clause most one assertion; i.e. it is either an empty clause, a denial, a simple assertion, or a assertion of the form tit v. any concept an assertion there may be a cona condition is declared to be Informally, a sequent states that if all of the conditions are true, then at least one of the assertions must be true. A sequent with no conditions is an unconditional assertion; if there PERSON Mary HAMMER HIT PIGGY-BANK: i22103 40 are two or more assertions, it states that one must be true, but it doesn&apos;t say which. Multiple assertions are necessary for generality, but in deductions, they may cause a model to split into models of multiple alternative worlds. A sequent with no assertions denies that the combination of conditions can ever occur. The empty clause is an unconditional denial; it is selfcontradictory. Horn clauses are special cases for which deductions are simplified: they have no disjunctions that cause models of the world to split into multiple alternatives. Let C be a collection of canonical graphs, and let the sequent • If every condition graph is covered by some graph in then the conditions are said to be • If some condition graph is not covered by any graph in then the sequent said to be C. If n=0 (there are no conditions), then the conditions are trivially satisfied. A sequent is like a conditional assertion in Belnap&apos;s sense: its conditions satisfied, it asserts nothing. But when they are satisfied, the assertions must be added to the current context. The next axiom states how they are added. Let C be a collection of canonical graphs, and let sequent If the conditions of by C, then be C as follows: If denial or the empty clause), the collection is said to be If Horn clause), a copy of each graph u, is joined to some graph in C by a covering join. Then the assertion v is added to the resulting collection C&apos;. • If rn&gt;2, a copy of each graph u; is joined to some graph in C by a covering join. Then all graphs in the collection C&apos; are copied to make identical to C&apos;. Finally, for each I assertion v, is added to the j-th copy of C&apos;. After an assertion v is added to one of the collections C&apos;, each concept in v that was declared to be coreferent with some concept b in one of the conditions u; is joined to that concept to which b was joined. When a collection of graphs is inconsistent with a sequent, they are blocked by it. If the sequent represents a fundamental law about the world, then the collection represents an impossible situation. When there is only one assertion in an applicable sequent, the collection is extended. But when there are two or more assertions, the collection splits into as many as there are this splitting is typical of algorithms for dealing with disjunctions. The rules for applying sequents are based on Beth&apos;s semantic tableaux (1955). but the computational techniques are similar to typical Al methods of production rules, demons, triggers, and monitors. Deliyanni and Kowalski (1979) relate their algorithms for logic in semantic networks to the resolution principle. This relationship is natural because a sequent whose conditions and assertions are all atoms is equivalent to the standard clause form for resolution. But since the sequents defined in this paper may be arbitrary conceptual graphs, they can package a much larger amount of information in each graph than the low level atoms of ordinary resolution. As a result, many fewer may be answer a question or do plausible inferences. 4. Laws, Facts, and Possible Worlds Infinite families of possible worlds are computationally hut Dunn (1973) showed they are not needed the semantics of modal logic. considered each possible w to he characterized by two of propositions: laws and facts F. Every law is also a but some facts are contingently true and are not considered A propnecessarily true in w if it follows from laws of and it is possible in w if it is consistent with the laws of proved that semantics in terms of and facts is to possible worlds semantics. approach to modal logic can be with models and Al methods for defaults. Instead of dealing with an infinite set of possible the can construct finite, but extendible surface The basis for models is a canon that contains the blueprints for assembling models and a set of laws that must be true for each model. The laws impose obligatory constraints on the models, and the canon contains common background information that serves as a heuristic for extending the models. initial model would start as a canonical graph or collection of graphs that represent a given set of facts in a sentence or story. Consider the story, the piggy bank with a hammer. She wanted to go to the movies with Janet. but she wouldn&apos;t get her allowance until Thursday. And today was only Tuesday. The first sentence would be translated to a conceptual graph like the one in Section 2. Each of the following sentences be translated into other conceptual graphs and joined original graph. But the story as stated is understandaa lot of background information: piggy contain piggy banks are usually of that is easily broken; going to movies an allowance is money; and Tuesday Thursday. Charniak (1972) handled such stories with demons that encapsulate knowledge: demons normally lie dormant, but when their associated patterns occur in a story, they wake up and apply their piece of knowledge to the process of understanding. Similar techniques are embodied in production systems, languages like PLANNER (Hewitt 1972), and knowledge representation systems like KRL (Bobrow &amp; Winograd 1977). But the trouble with demons is that they are unconstrained: anything can happen when a demon wakes up, no theorems are possible about what a collection of demons can cannot and there is no way of relating plausible reasoning with demons to any of the techniques of standard or nonstandard logic. With conceptual graphs, the computational overhead is about the same as with related Al techniques, but the advanthat the methods can be analyzed by vast body of techniques that have been developed in logic. The graph for hit the piggy-bank a is a nucleus around an infinite number of worlds can be built. Two Mary and fixed, but the particular act of hitting, the hammer Mary used, and all other undetermined. As the continues, some individuals may be named, graphs from the may be joined to add default information, and laws of the world in 41 the form of sequents may be triggered (like demons) to enforce constraints. The next definition introduces the notion of basis provides the building material (a canon) and the laws (sequents) for such a family of possible worlds. A basis three components: a canon C, a set of sequents L called one or more finite of canonical graphs [C1 .....C,,} called No context C, may be blocked by any law in L. A world basis is a collection of nuclei from which complete possible worlds may evolve. The contexts are like Hintikka&apos;s surface models: they are finite, but extendible. The graphs in the canon provide default or plausible information that can be joined to extend the contexts, and the laws are constraints on the kinds of extensions that are possible. When a law is violated, it blocks a context as a candidate for a possible world. A default, however, is optional; if contradicted, a default must be undone, and the context restored before the default was applied. In the sample story, the next sentence might continue: &amp;quot;The piggy bank was made of bronze, and when Mary hit it, a genie appeared and her two tickets to continuation violates all the default assumptions; it would be unreasonable to assume it in advance, but once given, it forces the system to back up to a context before the defaults were applied and join the new information to it. Several practical issues arise: how much backtracking is necessary, how is the world basis used to develop possible worlds, and what criteria are used to decide when to stop the (possibly infinite) extensions. The next section suggests an answer. 5. Game Theoretic Semantics The distinction between optional defaults and obligatory laws is reminiscent of the AND-OR trees that often arise in Al, especially in game playing programs. In fact, Hintikka (1973, 1974) proposed a game theoretic semantics for testing the truth of a formula in terms of a model and for elaborating a surface model in which that formula is true. Hintikka&apos;s approach can be adapted to elaborating a world basis in much the same way that a chess playing program explores the game tree: • Each context represents a position in the game. • The canon defines Possible moves by the current player. • Conditional assertions are moves by the opponent. • Denials are checkmating moves by the opponent. • A given context is consistent with the laws if there exists a strategy for avoiding checkmate. By following this suggestion, one can adapt the techniques developed for game playing programs to other kinds of reasoning in Al. A a world basis W is defined by the following rules: There are two participants named Opponent. • For each context in W, Player has the first move. • Player moves in context C either by joining two graphs in C or by selecting any graph in the canon of W that joinable to some graph u in C and joining it maxito no joins are possible. Player passes. Then Opponent has the right to move in context C. • Opponent moves by checking whether any denials in W are satisfied by C. If so, context C is blocked and is deleted from W. If no denials are satisfied, Opponent may apply any other sequent that is satisfied in C. If no sequent is satisfied, Opponent passes. Then Player has the right to move in context C. • If no contexts are left in W, Player loses. • If both Player and Opponent pass in succession, Player wins. Player wins this game by building a complete model that is consistent with the laws and with the initial information in the problem. But like playing a perfect game of chess, the cost of elaborating a complete model is prohibitive. Yet a computer can play chess as well as most people do by using heuristics to choose moves and terminating the search after a few levels. To develop systematic heuristics for choosing which graphs to join, Sows (1976) stated rules similar to Wilks&apos; preference semantics (1975). The amount of computation required to play this game might be compared to chess: a typical middle game in chess has about 30 or 40 moves on each side, and chess playing programs can consistently beat beginners by searching only 3 levels deep; they can play good games by searching 5 levels. The number of moves in a world basis depends on the number of graphs in the canon, the number of laws in L, and the number of graphs in each context. But for many common applications, 30 or 40 moves is a reasonable estimate at any given level, and useful inferences are possible with just a shallow search. The scripts applied by Schank and Abelson (1977), for example, correspond to a game with only one level of look-ahead; a game with two levels would provide the plausible information of scripts together with a round of consistency checks to eliminate obvious blunders. By deciding how far to search the game tree, one can derive algorithms for plausible inference with varying levels of confidence. Rigorous deduction similar to model elimination (Loveland 1972) can be performed by starting with laws and a context that correspond to the negation of what is to be proved and showing that Opponent has a winning strategy. By similar transformations, methods of plausible and exact inference can be related as variations on a general method of reasoning. 6. Appendix: Summary of the Formalism This section summarizes axioms, definitions, and theorems about conceptual graphs that are used in this paper. For a more complete discussion and for other features of the theory that are not used here, see the earlier articles by Sowa (1976, 1978). I: conceptual graph is a connected, bipartite graph nodes of the first kind called nodes of the second called relations. 2: Every conceptual relation has one or more of must be attached to a concept. If the relation has it is to be its arcs are labeled 1. 2.....a. The most common conceptual relations are dyadic (2-adic). but the definition mechanisms can create ones with any number of arcs. Although the formal definition says that the arcs are numbered, for dyadic relations. arc I is drawn as an arrow pointing towards the circle, and arc 2 as an arrow pointing away from the circle. 42 I: is a set T of labels a maps concepts and conceptual relations into T. If said to he of the type. Type labels are partially ordered: to be subtype labels of concepts conceptual relations are subsets of T: if a concept and a conceprelation, then may he the same type, nor be a subtype of the other. Axiom 2: There is a set llil, i2, i3. whose elements are called markers. function to concepts: If a concept, then either an individual marker in or the symbol @, which may be read When said to be an concept. When a is said to he a concept. In diagrams, the referent is written after the type label, separated by a colon. A concept of a particular cat could be written as IcAT:i4i331. A concept, which would refer to any could he written simply ICAT1. In data base systems, individual markers correspond to the surrogates (Codd 1979), which serve as unique internal identifiers for external entities. The symbol @ is Codd&apos;s notation for null or unknown in a data base. Externally printable or speakable related to the internal surrogates by the next axiom. 3: There is a dyadic conceptual relation with type label a relation of type NAME occurs in a conceptual graph, then the conattached to arc be a subtype of the concept to arc 2 must be a subtype of the second concept individual, then the first concept is called name that individual. The following graph states that the word &amp;quot;Mary&amp;quot; is the name of a person: there is only one person named Mary in the context, the graph could be abbreviated to just (PERSON:Maryl. 4: The relation :: type labels in T to individual markers in I. If in, then said to to t. If and then For For any concept type(c)::referent(c). The conformity relation says that the individual for which the marker a surrogate is of type In papers, the terms or used instead of to. the present term and the symbol :: have been adopted from ALGOL-68. Suppose the individual i273 is a surrogate for a beagle named Snoopy. Then is true. By extension, one may also write the name instead of the marker, axiom 4, Snoopy also conforms to all supertypes of such ANIMAL::Snoopy, 3: A graph a conceptual graph consisting of a single conceptual relation and the concepts attached to each of its arcs. (Two or more arcs of the conceptual relation may be attached to the same concept.) 4: Two concepts said to be both of the following properties are true: They are of the same type: Either referent(a)@, star graphs with conceptual relations said to be if • a have the same number of arcs, each concept attached to arc joinable to the concept to arc Not all combinations of concepts and conceptual relations are meaningful. Yet to say that some graphs are meaningful and others are not is begging the question, because the purpose of conceptual graphs is to form basis of of meaning. To avoid prejudging the issue, the term used for those graphs derivable from a designated set called any given domain of discourse, a canon is that rules out anomalous combinations. 5: A three components: • A partially ordered set T of type labels. • A set 1 of individual markers with a conformity relation ::. finite set of conceptual with type of concepts and relations in I and with referents markers in I. number of possible canonical graphs may be infinite. hut contains finite number from which all the others can he derived. an appropriate canon. many undesirable graphs arc ruled out but the canonical graphs are not necessarily true. To only true graphs are derived from true graphs. the laws discussed 4 eliminate combinations. 5: conceptual graph if it is in canon or if it is derivable from canonical graphs by one of the following formation rules. Let u v be canonical graphs v may be the same graph). Copy: An exact copy of canonical. Restrict: Let a concept in let a type label the graph obtained by changing type label of leaving is canonical. Join on a concept: Let a concept in concept in v. joinable, then the graph derived by the following is canonical: First delete v; then attach to arcs conceptual relations that had been attached to then unchanged: otherwise, re- Join on a star: Let a conceptual relation in a a conrelation in the star graphs of joinable, then the graph derived by the following steps is canonical: First its arcs from for each i. join the concept to arc the concept that had been attached to a. Restriction replaces a type label in a graph by the label of a subtype: this rule lets subtypes inherit the structures that apply to more general Join on a concept combines graphs that have concepts of same one graph is overlaid on the other so that two concepts of same type merge into a single concept; as a result, all the arcs that had been connected to either concept are connected to the single merged concept. Join on a star merges a conceptual relation and all of its attached concepts in a single operation. 6: Let v be a conceptual graph, let to be a suhgraph v which every conceptual relation has exactly the same arcs as in v, and a copy of v in which zero or more concepts may he restricted subtypes. Then called projection v, and v is called a origin v. main purpose of projections is to define the rule of join on projection, which is a generalization of the rules for joining a concept or a star. 7: If a conceptual graph a projection of both v and w. it is a projection v and w. a common projection of canonical graphs v and w. then and be on the common projection u form a canonical graph by the following steps: v be a projective origin of v, and let w be a projective of w. Restrict each concept of v and w to the type label of the corresponding concept in u. • Join each concept of v to the corresponding concept of w. Join each star graph of vto the corresponding star of iv. 43 The concepts and conceptual relations in the resulting graph consist of in v— w—w, and a copy of 8: If are on a common projection u, then all and conceptual relations in the projective origin of projective origin of w said to be by the join. if the projective origin of u in all of v, then the graph v is covered join, and the join is called covering Definition 9: Let v and w be joined on a common projection u. The join called there exist some concepts v and w with the following properties: The concepts joined to each other. a is attached to a conceptual relation was not covered by the join. b attached to a conceptual relation s that was not covered by the join. The star graphs of joinable. a join is not extendible, it is called The definition of maximal join given here is simpler than the one given in Sowa (1976), but it has the same result. Maximal joins have the effect of Wilks&apos; preference rules (1975) in forcing a maximum connectivity of the graphs. Covering joins are used in Section 3 in the rules for applying sequence. Theorem 2: Every covering join is maximal. Sowa (1976) continued with further material on quantifiers and procedural attachments. and Sowa (1978) continued with mechanisms for defining new types of concepts, conceptual relations, and composite that have other entities as parts. Note that the terms subsort, Sows (1976) have now been replaced by the terms 7. Acknowledgment I would like to thank Charles Bontempo, Jon Handel. and George Heidorn for helpful comments on earlier versions of this paper.</abstract>
<note confidence="0.96107303125">8. References Belnap, Nuel D.. Jr. (1973) &amp;quot;Restricted Quantification and Conditional Assertion,&amp;quot; in Leblanc (1973) pp. 48-75. Beth, E. W. (1955) &amp;quot;Semantic Entailment and Formal Derivability,&amp;quot; in J. Hintikka, ed., Philosophy of Mathematics, University Press, 1969. pp. 9-41. Bobrow, D. G.. &amp; T. Winograd (1977) &amp;quot;An Overview of KRL-0, a Knowl- Representation Language,&amp;quot; Science. 1, pp. 3-46. Eugene (1972) a Model of Children&apos;s Stoty Comprehen- Memo No. 266, MIT Project MAC. Cambridge, Mass. Codd, E. F. (1979) &amp;quot;Extending the Data Base Relational Model to Cap- More Meaning.&amp;quot; to appear in on Database Systems. Deliyanni, Amaryllis. &amp; Robert A. Kowalski (1979) &amp;quot;Logic and Semantic of the ACM, 22, no. 3, pp. 184-192. Dunn. J. Michael (1973) &amp;quot;A Truth Value Semantics for Modal Logic,&amp;quot; in Leblanc (1973) pp. 87-100. Nicholas V., ed. (1979) Networks, Press, New York, Gentzen. Gerhard (1934) &amp;quot;Investigations into Logical Deduction,&amp;quot; reprintin M. E. Szabo. ed., Collected Papers of Gerhard Gentsen, North-Holland. Amsterdam, 1969. pp. 68-131. George E. (1972) Language Inputs to a Simulation System. Report NPS-55HD7210IA, Naval Postgraduate School. Monterey. Heidorn, George E. (1975) &amp;quot;Augmented Phrase Structure Grammar.&amp;quot; in Schank &amp; B. L. Nash-Webber, eds., Issues in Natural Processing, 1-5. Hendrix, Gary G. (1975) &amp;quot;Expanding the Utility of Semantic Networks Partitioning,&amp;quot; in of the Fourth 1./CAL Georgia. USSR. pp. 115-121. Hendrix. Gary G. (1979) &amp;quot;Encoding Knowledge in Partitioned Networks.&amp;quot; in Findler (1979) pp. 51-92. Carl (1972) and Theoretical Analysis (Using Schemata) PLANNER, Memo No. 251, MIT Project MAC, Cambridge, Mass. Hintikka. Jaakko (1973) &amp;quot;Surface Semantics: Definition and its Motivation,&amp;quot; in Leblanc (1973) pp. 128-147. Jaakko (1974) &amp;quot;Quantifiers vs. Quantification Theory,&amp;quot; Linguis- Inquiry. 5, no. 2. pp. 153-177. Hintikka, Jaakko, &amp; Esa Saarinen (1975) &amp;quot;Semantical Games and the Paradox.&amp;quot; Linguistics. 2, pp. 1-20. Hughes, ed. (1973) Syntax, and Modality. Publishing Co., Amsterdam, Loveland, D. W. (1972) &amp;quot;A Unifying View of Some Linear Herbrand of the ACM, 19, no. 2, pp. 366-384. Drew V. (1976) &amp;quot;Artificial Intelligence Meets Natural Stupid- 57, pp. 4-9. Minsky, Marvin (1975) &amp;quot;A Framework for Representing Knowledge.&amp;quot; in P. H., ed.. Psychology of Computer Vision, New York. pp. 211-280. Roger, &amp; Robert Abelson (1977) Plans. Goals and Under- Erlbaum Associates, Hillsdale. N. J. Sown, John F. (1976) &amp;quot;Conceptual Graphs for a Data Base Interface,&amp;quot; Journal of Research &amp; Development, 20, pp. 336-357. Sowa, John F. (1978) &amp;quot;Definitional Mechanisms for Conceptual Graphs,&amp;quot; presented at the International Workshop on Graph Grammars, Bad Honnef, Germany, Nov. 1978. Wilks. Yorick (1975) &amp;quot;Preference Semantics.&amp;quot; in E. L. Keenan, ed., Semantics of Natural Language. University Press, pp. 329-348. Woods, William A. (1975) &amp;quot;What&apos;s in a Link: Foundations for Semantic in D. G. Bobrow &amp; A. Collins, eds., and Press. New York. 44</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Nuel D Jr Belnap</author>
</authors>
<title>Restricted Quantification and Conditional Assertion,&amp;quot;</title>
<date>1973</date>
<booktitle>in Leblanc</booktitle>
<pages>48--75</pages>
<marker>Belnap, 1973</marker>
<rawString>Belnap, Nuel D.. Jr. (1973) &amp;quot;Restricted Quantification and Conditional Assertion,&amp;quot; in Leblanc (1973) pp. 48-75.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E W Beth</author>
</authors>
<title>Semantic Entailment and Formal Derivability,&amp;quot; reprinted</title>
<date>1955</date>
<booktitle>The Philosophy of Mathematics,</booktitle>
<pages>9--41</pages>
<editor>in J. Hintikka, ed.,</editor>
<publisher>University Press,</publisher>
<location>Oxford</location>
<marker>Beth, 1955</marker>
<rawString>Beth, E. W. (1955) &amp;quot;Semantic Entailment and Formal Derivability,&amp;quot; reprinted in J. Hintikka, ed., The Philosophy of Mathematics, Oxford University Press, 1969. pp. 9-41.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D G Bobrow</author>
<author>T Winograd</author>
</authors>
<title>An Overview of KRL-0, a Knowledge Representation Language,&amp;quot;</title>
<date>1977</date>
<journal>Cognitive Science.</journal>
<volume>1</volume>
<pages>3--46</pages>
<contexts>
<context position="17276" citStr="Bobrow &amp; Winograd 1977" startWordPosition="2852" endWordPosition="2855">lot of background information: piggy banks normally contain money; piggy banks are usually made of pottery that is easily broken; going to the movies requires money; an allowance is money; and Tuesday precedes Thursday. Charniak (1972) handled such stories with demons that encapsulate knowledge: demons normally lie dormant, but when their associated patterns occur in a story, they wake up and apply their piece of knowledge to the process of understanding. Similar techniques are embodied in production systems, languages like PLANNER (Hewitt 1972), and knowledge representation systems like KRL (Bobrow &amp; Winograd 1977). But the trouble with demons is that they are unconstrained: anything can happen when a demon wakes up, no theorems are possible about what a collection of demons can or cannot do, and there is no way of relating plausible reasoning with demons to any of the techniques of standard or nonstandard logic. With conceptual graphs, the computational overhead is about the same as with related Al techniques, but the advantage is that the methods can be analyzed by the vast body of techniques that have been developed in logic. The graph for &amp;quot;Mary hit the piggy-bank with a hammer&amp;quot; is a nucleus around w</context>
</contexts>
<marker>Bobrow, Winograd, 1977</marker>
<rawString>Bobrow, D. G.. &amp; T. Winograd (1977) &amp;quot;An Overview of KRL-0, a Knowledge Representation Language,&amp;quot; Cognitive Science. voL 1, pp. 3-46.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Eugene Charniak</author>
</authors>
<title>Towards a Model of Children&apos;s Stoty Comprehension.</title>
<date>1972</date>
<booktitle>Al Memo No. 266, MIT Project MAC.</booktitle>
<location>Cambridge, Mass.</location>
<contexts>
<context position="16888" citStr="Charniak (1972)" startWordPosition="2794" endWordPosition="2795">he wanted to go to the movies with Janet. but she wouldn&apos;t get her allowance until Thursday. And today was only Tuesday. The first sentence would be translated to a conceptual graph like the one in Section 2. Each of the following sentences would be translated into other conceptual graphs and joined to the original graph. But the story as stated is not understandable without a lot of background information: piggy banks normally contain money; piggy banks are usually made of pottery that is easily broken; going to the movies requires money; an allowance is money; and Tuesday precedes Thursday. Charniak (1972) handled such stories with demons that encapsulate knowledge: demons normally lie dormant, but when their associated patterns occur in a story, they wake up and apply their piece of knowledge to the process of understanding. Similar techniques are embodied in production systems, languages like PLANNER (Hewitt 1972), and knowledge representation systems like KRL (Bobrow &amp; Winograd 1977). But the trouble with demons is that they are unconstrained: anything can happen when a demon wakes up, no theorems are possible about what a collection of demons can or cannot do, and there is no way of relatin</context>
</contexts>
<marker>Charniak, 1972</marker>
<rawString>Charniak, Eugene (1972) Towards a Model of Children&apos;s Stoty Comprehension. Al Memo No. 266, MIT Project MAC. Cambridge, Mass.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E F Codd</author>
</authors>
<title>Extending the Data Base Relational Model to Capture More Meaning.&amp;quot;</title>
<date>1979</date>
<note>to appear in Transactions on Database Systems.</note>
<contexts>
<context position="25807" citStr="Codd 1979" startWordPosition="4362" endWordPosition="4363">arkers. The function referent applies to concepts: • If a is a concept, then referent/a) is either an individual marker in I or the symbol @, which may be read any. • When referenda) e I. then a is said to be an individual concept. • When referenda)..@, then a is said to he a generic concept. In diagrams, the referent is written after the type label, separated by a colon. A concept of a particular cat could be written as IcAT:i4i331. A generic concept, which would refer to any cat, could he written icAT:00 or simply ICAT1. In data base systems, individual markers correspond to the surrogates (Codd 1979), which serve as unique internal identifiers for external entities. The symbol @ is Codd&apos;s notation for null or unknown values in a data base. Externally printable or speakable names are related to the internal surrogates by the next axiom. Axiom 3: There is a dyadic conceptual relation with type label NAME. If a relation of type NAME occurs in a conceptual graph, then the concept attached to arc 1 must be a subtype of WORD, and the concept attached to arc 2 must be a subtype of ENTITY. If the second concept is individual, then the first concept is called a name of that individual. The followi</context>
</contexts>
<marker>Codd, 1979</marker>
<rawString>Codd, E. F. (1979) &amp;quot;Extending the Data Base Relational Model to Capture More Meaning.&amp;quot; to appear in Transactions on Database Systems.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert A Kowalski</author>
</authors>
<title>Logic and Semantic Networks,&amp;quot;</title>
<date>1979</date>
<journal>Communications of the ACM,</journal>
<volume>22</volume>
<pages>184--192</pages>
<contexts>
<context position="10404" citStr="Kowalski (1979)" startWordPosition="1648" endWordPosition="1649">f handling logical operators in conceptual graphs: the abstract approach, which treats them as functions of truth values, and the direct approach, which treats implications, conjunctions, disjunctions, and negations as operations for building, splitting, and discarding conceptual graphs. That paper, however, merely mentioned the approach; this paper develops a notation adapted from Gentzen&apos;s sequents (1934), but with an interpretation based on Belnap&apos;s conditional assertions (1973) and with computational techniques similar to Hendrix&apos;s partitioned semantic networks (1975, 1979). Deliyanni and Kowalski (1979) used a similar notation for logic in semantic networks, but with the arrows reversed. Definition: A sequent is a collection of conceptual graphs divided into two sets, called the conditions and the assertions It is written u1 u,, Several special cases are distinguished: • A simple assertion has no conditions and only one assertion: v. • A disjunction has no conditions and two or more assertions: ■•• • A simple denial has only one condition and no assertions: u • A compound denial has two or more conditions and no assertions: u1,...,u„ • A conditional assertion has one or more conditions and o</context>
<context position="14365" citStr="Kowalski (1979)" startWordPosition="2363" endWordPosition="2364"> the sequent represents a fundamental law about the world, then the collection represents an impossible situation. When there is only one assertion in an applicable sequent, the collection is extended. But when there are two or more assertions, the collection splits into as many successors as there are .assertions; this splitting is typical of algorithms for dealing with disjunctions. The rules for applying sequents are based on Beth&apos;s semantic tableaux (1955). but the computational techniques are similar to typical Al methods of production rules, demons, triggers, and monitors. Deliyanni and Kowalski (1979) relate their algorithms for logic in semantic networks to the resolution principle. This relationship is natural because a sequent whose conditions and assertions are all atoms is equivalent to the standard clause form for resolution. But since the sequents defined in this paper may be arbitrary conceptual graphs, they can package a much larger amount of information in each graph than the low level atoms of ordinary resolution. As a result, many fewer steps may be needed to answer a question or do plausible inferences. 4. Laws, Facts, and Possible Worlds Infinite families of possible worlds a</context>
</contexts>
<marker>Kowalski, 1979</marker>
<rawString>Deliyanni, Amaryllis. &amp; Robert A. Kowalski (1979) &amp;quot;Logic and Semantic Networks,&amp;quot; Communications of the ACM, vol. 22, no. 3, pp. 184-192.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Michael</author>
</authors>
<title>A Truth Value Semantics for Modal Logic,&amp;quot;</title>
<date>1973</date>
<booktitle>in Leblanc</booktitle>
<pages>87--100</pages>
<marker>Michael, 1973</marker>
<rawString>Dunn. J. Michael (1973) &amp;quot;A Truth Value Semantics for Modal Logic,&amp;quot; in Leblanc (1973) pp. 87-100.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Nicholas V Findler</author>
<author>ed</author>
</authors>
<title>Associative Networks,</title>
<date>1979</date>
<publisher>Academic Press,</publisher>
<location>New York,</location>
<marker>Findler, ed, 1979</marker>
<rawString>Findler, Nicholas V., ed. (1979) Associative Networks, Academic Press, New York,</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gerhard</author>
</authors>
<title>Investigations into Logical Deduction,&amp;quot; reprinted</title>
<date>1934</date>
<booktitle>The Collected Papers of Gerhard Gentsen, North-Holland.</booktitle>
<pages>68--131</pages>
<editor>in M. E. Szabo. ed.,</editor>
<location>Amsterdam,</location>
<marker>Gerhard, 1934</marker>
<rawString>Gentzen. Gerhard (1934) &amp;quot;Investigations into Logical Deduction,&amp;quot; reprinted in M. E. Szabo. ed., The Collected Papers of Gerhard Gentsen, North-Holland. Amsterdam, 1969. pp. 68-131.</rawString>
</citation>
<citation valid="true">
<authors>
<author>George E 1-leidorn</author>
</authors>
<title>Natural Language Inputs to a Simulation Programming System.</title>
<date>1972</date>
<tech>Technical Report NPS-55HD7210IA,</tech>
<institution>Naval Postgraduate School. Monterey.</institution>
<marker>1-leidorn, 1972</marker>
<rawString>1-leidorn, George E. (1972) Natural Language Inputs to a Simulation Programming System. Technical Report NPS-55HD7210IA, Naval Postgraduate School. Monterey.</rawString>
</citation>
<citation valid="true">
<authors>
<author>George E Heidorn</author>
</authors>
<title>Augmented Phrase Structure Grammar.&amp;quot;</title>
<date>1975</date>
<booktitle>Theoretical Issues in Natural Language Processing,</booktitle>
<pages>1--5</pages>
<editor>in R. Schank &amp; B. L. Nash-Webber, eds.,</editor>
<marker>Heidorn, 1975</marker>
<rawString>Heidorn, George E. (1975) &amp;quot;Augmented Phrase Structure Grammar.&amp;quot; in R. Schank &amp; B. L. Nash-Webber, eds., Theoretical Issues in Natural Language Processing, pp. 1-5.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gary G Hendrix</author>
</authors>
<title>Expanding the Utility of Semantic Networks through Partitioning,&amp;quot;</title>
<date>1975</date>
<booktitle>in Proc. of the Fourth 1./CAL Tbilisi, Georgia. USSR.</booktitle>
<pages>115--121</pages>
<marker>Hendrix, 1975</marker>
<rawString>Hendrix, Gary G. (1975) &amp;quot;Expanding the Utility of Semantic Networks through Partitioning,&amp;quot; in Proc. of the Fourth 1./CAL Tbilisi, Georgia. USSR. pp. 115-121.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Gary</author>
</authors>
<title>Encoding Knowledge in Partitioned Networks.&amp;quot;</title>
<date>1979</date>
<booktitle>in Findler</booktitle>
<pages>51--92</pages>
<marker>Gary, 1979</marker>
<rawString>Hendrix. Gary G. (1979) &amp;quot;Encoding Knowledge in Partitioned Networks.&amp;quot; in Findler (1979) pp. 51-92.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Carl</author>
</authors>
<title>Description and Theoretical Analysis (Using Schemata) of PLANNER,</title>
<date>1972</date>
<booktitle>Al Memo No. 251, MIT Project MAC,</booktitle>
<location>Cambridge, Mass.</location>
<marker>Carl, 1972</marker>
<rawString>Hewitt. Carl (1972) Description and Theoretical Analysis (Using Schemata) of PLANNER, Al Memo No. 251, MIT Project MAC, Cambridge, Mass.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jaakko</author>
</authors>
<title>Surface Semantics: Definition and its Motivation,&amp;quot;</title>
<date>1973</date>
<booktitle>in Leblanc</booktitle>
<pages>128--147</pages>
<marker>Jaakko, 1973</marker>
<rawString>Hintikka. Jaakko (1973) &amp;quot;Surface Semantics: Definition and its Motivation,&amp;quot; in Leblanc (1973) pp. 128-147.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jaakko Hintikka</author>
</authors>
<title>Quantifiers vs. Quantification Theory,&amp;quot; Linguistic Inquiry.</title>
<date>1974</date>
<volume>5</volume>
<pages>153--177</pages>
<marker>Hintikka, 1974</marker>
<rawString>Hintikka, Jaakko (1974) &amp;quot;Quantifiers vs. Quantification Theory,&amp;quot; Linguistic Inquiry. vol. 5, no. 2. pp. 153-177.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jaakko Hintikka</author>
</authors>
<title>Esa Saarinen</title>
<date>1975</date>
<journal>Theoretical Linguistics.</journal>
<volume>2</volume>
<pages>1--20</pages>
<marker>Hintikka, 1975</marker>
<rawString>Hintikka, Jaakko, &amp; Esa Saarinen (1975) &amp;quot;Semantical Games and the Bach-Peters Paradox.&amp;quot; Theoretical Linguistics. vol. 2, pp. 1-20.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hughes Leblanc</author>
<author>ed</author>
</authors>
<date>1973</date>
<editor>Truth. Syntax, and Modality.</editor>
<publisher>North-Holland Publishing Co.,</publisher>
<location>Amsterdam,</location>
<marker>Leblanc, ed, 1973</marker>
<rawString>Leblanc, Hughes, ed. (1973) Truth. Syntax, and Modality. North-Holland Publishing Co., Amsterdam,</rawString>
</citation>
<citation valid="true">
<authors>
<author>D W Loveland</author>
</authors>
<title>A Unifying View of Some Linear Herbrand Procedures,&amp;quot;</title>
<date>1972</date>
<journal>Journal of the ACM,</journal>
<volume>19</volume>
<pages>366--384</pages>
<contexts>
<context position="23340" citStr="Loveland 1972" startWordPosition="3919" endWordPosition="3920">for many common applications, 30 or 40 moves is a reasonable estimate at any given level, and useful inferences are possible with just a shallow search. The scripts applied by Schank and Abelson (1977), for example, correspond to a game with only one level of look-ahead; a game with two levels would provide the plausible information of scripts together with a round of consistency checks to eliminate obvious blunders. By deciding how far to search the game tree, one can derive algorithms for plausible inference with varying levels of confidence. Rigorous deduction similar to model elimination (Loveland 1972) can be performed by starting with laws and a context that correspond to the negation of what is to be proved and showing that Opponent has a winning strategy. By similar transformations, methods of plausible and exact inference can be related as variations on a general method of reasoning. 6. Appendix: Summary of the Formalism This section summarizes axioms, definitions, and theorems about conceptual graphs that are used in this paper. For a more complete discussion and for other features of the theory that are not used here, see the earlier articles by Sowa (1976, 1978). Definition I: A conc</context>
</contexts>
<marker>Loveland, 1972</marker>
<rawString>Loveland, D. W. (1972) &amp;quot;A Unifying View of Some Linear Herbrand Procedures,&amp;quot; Journal of the ACM, vol. 19, no. 2, pp. 366-384.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Drew V McDermott</author>
</authors>
<title>Artificial Intelligence Meets Natural Stupidity,&amp;quot;</title>
<date>1976</date>
<journal>SiGART Newsletter.</journal>
<volume>57</volume>
<pages>4--9</pages>
<contexts>
<context position="746" citStr="McDermott (1976)" startWordPosition="118" endWordPosition="119">ptual graphs are both a language for representing knowledge and patterns for constructing models. They form models in the Al sense of structures that approximate some actual or possible system in the real world. They also form models in the logical sense of structures for which some set of axioms are true. When combined with recent developments in nonstandard logic and semantics, conceptual graphs can form a bridge between heuristic techniques of Al and formal techniques of model theory. 1. Surface Models Semantic networks are often used in Al for representing meaning. But as Woods (1975) and McDermott (1976) observed, the semantic networks themselves have no well-defined semantics. Standard predicate calculus does have a precisely defined, model theoretic semantics; it is adequate for describing mathematical theories with a closed set of axioms. But the real world is messy, incompletely explored, and full of unexpected surprises. Furthermore, the infinite sets commonly used in logic are intractable both for computers and for the human brain. To develop a more realistic semantics, Hintikka (1973) proposed surface models as incomplete, but extendible, finite constructions: Usually, models are thoug</context>
</contexts>
<marker>McDermott, 1976</marker>
<rawString>McDermott, Drew V. (1976) &amp;quot;Artificial Intelligence Meets Natural Stupidity,&amp;quot; SiGART Newsletter. No. 57, pp. 4-9.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Marvin Minsky</author>
</authors>
<title>A Framework for Representing Knowledge.&amp;quot;</title>
<date>1975</date>
<booktitle>The Psychology of Computer Vision,</booktitle>
<pages>211--280</pages>
<editor>in Winston, P. H., ed..</editor>
<publisher>McGraw-Hill,</publisher>
<location>New York.</location>
<contexts>
<context position="3124" citStr="Minsky 1975" startWordPosition="503" endWordPosition="504">processes are not a normal part of understanding. This paper adapts Hintikka&apos;s surface models to the formalism of conceptual graphs (Sowa 1976, 1978). Conceptual graphs serve two purposes: like other forms of semantic networks, they can be used as a canonical representation of meaning in natural language: but they can also be used as building blocks for constructing abstract structures that serve as models in the model-theoretic sense. • Understanding a sentence begins with a translation of that sentence into a conceptual graph. • During the translation, that graph may be joined to framelike (Minsky 1975) or script-like (Sc;hank &amp; Abelson 1977) graphs that help resolve ambiguities and incorporate background information. • The resulting graph is a nucleus for constructing models of possible worlds in which the sentence is true. • Laws of the world behave like demons or triggers that monitor the models and block illegal extensions. • If a surface model could be extended infinitely deep, the result would be a complete standard model. This approach leads to an infinite sequence of algorithms ranging from plausible inference to exact deduction; they are analogous to the varying levels of search in </context>
</contexts>
<marker>Minsky, 1975</marker>
<rawString>Minsky, Marvin (1975) &amp;quot;A Framework for Representing Knowledge.&amp;quot; in Winston, P. H., ed.. The Psychology of Computer Vision, McGraw-Hill, New York. pp. 211-280.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Roger Schank</author>
<author>Robert Abelson</author>
</authors>
<title>Scripts. Plans. Goals and Understanding, Lawrence Erlbaum Associates, Hillsdale.</title>
<date>1977</date>
<journal>N. J.</journal>
<contexts>
<context position="22927" citStr="Schank and Abelson (1977)" startWordPosition="3853" endWordPosition="3856">tion required to play this game might be compared to chess: a typical middle game in chess has about 30 or 40 moves on each side, and chess playing programs can consistently beat beginners by searching only 3 levels deep; they can play good games by searching 5 levels. The number of moves in a world basis depends on the number of graphs in the canon, the number of laws in L, and the number of graphs in each context. But for many common applications, 30 or 40 moves is a reasonable estimate at any given level, and useful inferences are possible with just a shallow search. The scripts applied by Schank and Abelson (1977), for example, correspond to a game with only one level of look-ahead; a game with two levels would provide the plausible information of scripts together with a round of consistency checks to eliminate obvious blunders. By deciding how far to search the game tree, one can derive algorithms for plausible inference with varying levels of confidence. Rigorous deduction similar to model elimination (Loveland 1972) can be performed by starting with laws and a context that correspond to the negation of what is to be proved and showing that Opponent has a winning strategy. By similar transformations,</context>
</contexts>
<marker>Schank, Abelson, 1977</marker>
<rawString>Schank, Roger, &amp; Robert Abelson (1977) Scripts. Plans. Goals and Understanding, Lawrence Erlbaum Associates, Hillsdale. N. J.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John F Sown</author>
</authors>
<title>Conceptual Graphs for a Data Base Interface,&amp;quot;</title>
<date>1976</date>
<journal>IBM Journal of Research &amp; Development,</journal>
<volume>20</volume>
<pages>336--357</pages>
<marker>Sown, 1976</marker>
<rawString>Sown, John F. (1976) &amp;quot;Conceptual Graphs for a Data Base Interface,&amp;quot; IBM Journal of Research &amp; Development, vol. 20, pp. 336-357.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John F Sowa</author>
</authors>
<title>Definitional Mechanisms for Conceptual Graphs,&amp;quot; presented at the International Workshop on Graph Grammars,</title>
<date>1978</date>
<location>Bad Honnef, Germany,</location>
<marker>Sowa, 1978</marker>
<rawString>Sowa, John F. (1978) &amp;quot;Definitional Mechanisms for Conceptual Graphs,&amp;quot; presented at the International Workshop on Graph Grammars, Bad Honnef, Germany, Nov. 1978.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yorick</author>
</authors>
<title>Preference Semantics.&amp;quot;</title>
<date>1975</date>
<pages>329--348</pages>
<editor>in E. L. Keenan, ed.,</editor>
<publisher>Cambridge University Press,</publisher>
<marker>Yorick, 1975</marker>
<rawString>Wilks. Yorick (1975) &amp;quot;Preference Semantics.&amp;quot; in E. L. Keenan, ed., Formal Semantics of Natural Language. Cambridge University Press, pp. 329-348.</rawString>
</citation>
<citation valid="true">
<authors>
<author>William A Woods</author>
</authors>
<title>What&apos;s in a Link: Foundations for Semantic Networks.&amp;quot;</title>
<date>1975</date>
<booktitle>Representation and Understanding,</booktitle>
<editor>in D. G. Bobrow &amp; A. Collins, eds.,</editor>
<publisher>Academic Press.</publisher>
<location>New York.</location>
<contexts>
<context position="725" citStr="Woods (1975)" startWordPosition="115" endWordPosition="116">7 ABSTRACT: Conceptual graphs are both a language for representing knowledge and patterns for constructing models. They form models in the Al sense of structures that approximate some actual or possible system in the real world. They also form models in the logical sense of structures for which some set of axioms are true. When combined with recent developments in nonstandard logic and semantics, conceptual graphs can form a bridge between heuristic techniques of Al and formal techniques of model theory. 1. Surface Models Semantic networks are often used in Al for representing meaning. But as Woods (1975) and McDermott (1976) observed, the semantic networks themselves have no well-defined semantics. Standard predicate calculus does have a precisely defined, model theoretic semantics; it is adequate for describing mathematical theories with a closed set of axioms. But the real world is messy, incompletely explored, and full of unexpected surprises. Furthermore, the infinite sets commonly used in logic are intractable both for computers and for the human brain. To develop a more realistic semantics, Hintikka (1973) proposed surface models as incomplete, but extendible, finite constructions: Usua</context>
</contexts>
<marker>Woods, 1975</marker>
<rawString>Woods, William A. (1975) &amp;quot;What&apos;s in a Link: Foundations for Semantic Networks.&amp;quot; in D. G. Bobrow &amp; A. Collins, eds., Representation and Understanding, Academic Press. New York.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>