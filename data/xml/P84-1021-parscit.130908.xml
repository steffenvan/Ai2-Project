<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<note confidence="0.743617">
GIT : A GENERAL TRANSDUCER FOR TEACHING COMPUTATIONAL LINGUISTICS
</note>
<author confidence="0.888893">
P. Shann J.L. Cochard
</author>
<affiliation confidence="0.973971">
Dalle Molle Institute for Semantic and Cognitive Studies
University of Geneva
</affiliation>
<sectionHeader confidence="0.488285" genericHeader="abstract">
Switzerland
ABSTRACT
</sectionHeader>
<bodyText confidence="0.9997289">
The (ii-system is a tree-to-tree transducer
developed for teaching purposes in madhine.transla-
tion. The transducer is a specialized production
system giving the linguists the tools for express-
ing information in a syntax that is close to theo-
retical linguistics. Major emphasis was placed on
developing a system that is user friendly, uniform
and legible. This paper describes the linguistic
data structure, the rule formalism and the control
facilities that the linguist is provided with.
</bodyText>
<listItem confidence="0.483248">
1. INTRODUCTION
</listItem>
<bodyText confidence="0.999868444444445">
The GTT-system (Geneva Teaching Transducer)1
is a general tree-to-tree transducer developed as
a tool for training linguists in machine transla-
tion and computational linguistics. The transducer
is a specialized production system tailored to the
requirements of carputational linguists providing
them with a means of expressing information in a
format close to the linguistic theory they are
familiar with.
GTT has been developed for teaching purposes
and cannot be considered as a system for large
scale development. A first version has been imple-
mented in standard Pascal and is currently running
on a Univac 1100/61 and a V7X-780 under UNIX. At
present it is being used by a team of linguists
for experimental development of an MT system for a
special purpose language (Buchmann et al., 1984),
and to train students in computational linguistics.
</bodyText>
<sectionHeader confidence="0.939677" genericHeader="method">
2. THE UNIFORMITY AND SIMPLICITY OF THE SYSTEM
</sectionHeader>
<bodyText confidence="0.995173763157895">
As a tool for training computational linguists,
major ermahasis was placed on developing a system
that is user friendly, uniform, and which provides
a legible syntax.
One of the important requirements in machine
translation is the separation of linguistic data
and algorithms (Vavquois, 1975). The linguist
should have the means to express his knowledge
declaratively without being obliged to mix compu-
1
This project is sponsored by the Swiss govern-
ment.
tational algorithms and linguistic data. Produc-
tion systems (Rosner, 1983) seem particularly
suited to meet such requirements (Johnson, 1982);
the production set that expresses the object-level
knowledge is clearly separated from the control
part that drives the application of the produc-
tions. Colmerauer&apos;s 0-system is the classic exam-
ple of such a uniform production system used for
machine translation (Colmerauer, 1970; Chevalier,
1978: TAUM-METEO). The linguistic knowledge is ex-
pressed declaratively using the same data structu-
re during the whole translation process as well as
the same type of production rules for dictionary
entries, morphology, analysis, transfer and gene-
ration. The disadvantage of the 0-system is its
quite unnatural rule-syntax for non-programmers
and its lack of flexible control mechanism for the
user (Vauquois, 1978).
In the design of our system the basic uniform
. scheme of 0-systems has been followed, but the
rule syntax, the linguistic data structure and the
control facilities have been modernized according
to recent developments in machine translation
(Vauquois, 1978;.Bortet, 1977; Johnson, 1980;
Slocum, 1982). These three points will be deve-
loped in the next section.
</bodyText>
<listItem confidence="0.711615">
3. DESCRIPTION OF THE SYSTEM
3.1 Overview
</listItem>
<bodyText confidence="0.999856857142857">
The general framework is a production system
where linguistic object knowledge is expressed in
a rule-based declarative way. The system takes the
dictionaries and the grammars as data, compiles
these data and the interpreter then uses them to
process the input text. The decoder transforms the
result into a digestable form for the user.
</bodyText>
<subsectionHeader confidence="0.999614">
3.2 Data structure
</subsectionHeader>
<bodyText confidence="0.9998121">
The data structure of the system is based on
a chart (Varile, 1983). One of the main advantages
of using a chart is that the data structure does
not change throughout the whole process of trans-
lation (Vauquois, 1978).
In the 0-system all linguistic data on the
arcs is represented by bracketed strings causing
an unclean mixture of constituent structure and
other linguistic attributes such as grammatical
and semantic labels, etc. With this representation
</bodyText>
<page confidence="0.996464">
88
</page>
<listItem confidence="0.761577888888889">
type checking is not possible. Vauquois proposes
two changes :
1) Tree structures with complex labels on the nodes
in order to allow interaction between different
linguistic levels such as syntax or semantics, etc.
2) A dissociation of the geometry from a particular
linguistic level. With these modifications a single
tree structure with complex labels increases the
power of representation in that several levels of
</listItem>
<bodyText confidence="0.933520111111111">
interpretation can be processed simultaneously
(Vallquois, 1978; Boltet, 1977).
In our system each arc of the chart carries a
tree geometry and each node of the tree has a cam+
plex labelling consisting of a possible string and
the linguistic attributes. Through the separation
of geometry and attributes, the linguist can deal .
with two distinct objects: with tree structures and
complex labels on the nodes of the trees.
</bodyText>
<equation confidence="0.605569">
42t=np, gender=pg
=det J Icat=noun, gender=p
string=ithel ptxing=11inguist&apos;
gat
</equation>
<figureCaption confidence="0.995224">
Figure 1. Tree with complex labelling
</figureCaption>
<bodyText confidence="0.996866818181818">
The range or kind of linguistic attributes
possible is not predefined by the system. The lin-
guist has to define the types he wants to use in
a declaration part.
e.g.: category = verb, noun, np, pp.
semantic-features = human, animate.
gender = masc, fem, neut.
An important aspect of type declaration is the con-
trol it offers. The system provides strong syntac-
tic and semantic type checking, thereby constrain-
ing the application range in order to avoid inap-
propriate transductions. The actual implementation
allows the use of sets and subsets in the type de-
finition. Further extensions are planned.
Given that in this system the tree geometry
is not bound to a specific linguistic level, the
linguist has the freedom to decide which information
will be represented by the geometry and which will
be treated as attributes on the nodes. This repre-
sentation tool is thus fairly general and allows
the testing of different theories and strategies
in MT or computational linguistics.
</bodyText>
<subsectionHeader confidence="0.953885">
3.3 The rule syntax
</subsectionHeader>
<bodyText confidence="0.999294310344828">
The basic tool to express object-knowledge is
a set of production rules which are similar in form
to context-free phrase structure rules, and well-
known to linguists from formal grammar. In order to
have the same rule type for all operations in a
translation system the power of the rules must be
of type 0 in the Chcmsky classification, including
string handling facilities.
The rules exhibit two important additions to
context-free phrase structure rules:
- arbitrary structures can be matched on the left-
hand side or built on the right-hand side, giving
the power of unrestricted rules or transforma-
tional grammar;
- arbitrary conditions on the application of the
rule can be added, giving the power of a context
sensitive grammar.
The power of unrestricted rewriting rules makes
the transducer a versatile instrument for express-
ing any rule-governed aspect of language whether
this be morphology, syntax, semantics. The fact
that the statements are basically phrase structure
rules makes this language particularly congenial
to linguists and hence well-suited for teaching
purposes.
The format of rules is determined by the sepa-
ration of tree structure and attributes on the
nodes. Each rule has three parts: geometry, condi-
tions and assignments, e.g.:
</bodyText>
<equation confidence="0.944484">
RULE 1
(geometry) a + b c(a,b)
(conditions) IF cat (a) = Pet] and cat (b) = [nourg
(assignment) THEN cat (c) :=
</equation>
<bodyText confidence="0.850782818181818">
The geometry has the standard left-hand side, pro-
duction symbol (44, and right-hand side of a pro-
duction rule. a,b,c are variables describing the
nodes of the tree structure. The &apos;+&apos; indicates the
sequence in the chart, e.g. a+b :
Tree configurations are indicated by bracketing,
c(a,b) corresponds to :
xcx
a b
Conditions and assignments affect only the objects
on the nodes.
</bodyText>
<subsectionHeader confidence="0.995968">
3.4 Control structure
</subsectionHeader>
<bodyText confidence="0.907309928571429">
The linguist has two tools for controlling the
application of the rewriting rules :
1) The rules can be grouped into packets (grammars)
which are executed in sequence.
2) Within a given grammar the rule-application can
be controlled by means of parameters set by the
linguist. According to the linguistic operation en-
visaged, the parameters can be set to a oombination
of serial or parallel and one-pass or iterate.
In all, 4 different combinations are possible :
parallel and one-pass
parallel and iterate
serial and one-pass
serial and iterate
</bodyText>
<page confidence="0.99901">
89
</page>
<bodyText confidence="0.99769425">
In the parallel mode the rules within a gram-
mar are considered as being unordered from a logi-
cal point of view. Different rules can be applied
on the same piece of data and produce alternatives
in the chart. The chart is updated at the end of
every application-cycle. In the serial mode the
rules are considered as being ordered in a sequen-
ce. Only one rule can be fired for a particular
piece of data. But the following rules can match
the result produced by a preceding rule. The chart
is updated after every rule that fired. The para-
meters one-pass and iterate control the number of
cycles. Either the interpreter goes through a cy-
cle only once, or iterates the cycles as long as.
any rule of the grammar can fire.
The four coMbinations allow different uses
according to the linguistic task to be performed,
e.g.:
Parallel and iterate applies the rules non-deter-
ministically to compute all possibilities, which
gives the system the power of a Turing Machine
.(this is the only control mode for the Q.-system).
Parallel and one-pass is the typical ccrnbination
for dictionaries that contain alternatives. TWo
different rules can apply to the same piece of
data. The example below (fig. 2) uses this caMbi-
nation in the first GRAMMAR &apos;vocabulary&apos;.
Serial and one-pass allows rule ordering. A
possible application of this combination is a pre-
ference mechanism via the explicit rule ordering
using the longest-match-first technique. The
GRAMMAR &apos;preference&apos; in the example below (fig. 2)
makes use of that by progressive weakening of the
selectional restriction of the verb &apos;drink&apos;. -
Rule 24 fires without semantic restrictions and
rule 25 accepts sentences where the optional argu-
ment is missing.
The example should be sufficiently self-expla-
natory. It begins with the declaration of the
attributes and contains three grammars. The result
is shown for two sentences (fig. 3). TO demonstrate
which rule in the preference grammar has fired
each rule produces a different tap label:
rule 21 P111, rule 22 PH2, etc.
</bodyText>
<figureCaption confidence="0.999653">
Figure 2. Example of a grammar file.
</figureCaption>
<figure confidence="0.989194045454546">
DECLARE
cat = det.noun.verb.val node.np.phl,ph2,ph3.ph4,ph5;
number sg.pl,
human,liquid.notdrinkable.physobj.abstr,
valency v1.v2,v3;
argument = argl.arg2.arg3,
GRAMMAR vocabulary PARALLEL ONEPASS
RULE 1 a .7 a
THEN cat(a) Cdet7,
IF string(a). &apos;the&apos;
RULE 2 a a
IF string(a). &apos;man&apos;
THEN cat(a) [noun]; number(a) Csg7;
marker(a) := Chuman7,
RULE 3 a .&gt; a
IF string(a). &apos;beer&apos;
THEN tet(e) :. [noun], number(a) := Cep];
marker(a) [liquid],
RULE 4 a .7 a
IF string(a)., &apos;car&apos;
THEN cat(a) :■ InounD number(a) :■ Csg7;
marker(a) :■ CphysobJD
a =&gt; a
string(a)=. &apos;gasoline&apos;
cat(a) [noun]; number(a) rag];
marker(a) := Cnotdrinkablel,
a .7 a
string(a). &apos;drinks&apos;
cat(a) :■ [nautili number(a) 417)
marker(a) := Cliquid7;
RULE 7 a .7 a(b.c)
IF string(a). &apos;drinks&apos;
• THEN cat(a):.Cverb7, valency(a):./v23;
cat(b):=Cval node]; cat(c):■Cval node]1
argument(b):Z[arg17; marker(b):=MumanD
argument(c):■Carg2L marker(c):■CliquidL
GRAMMAR nounphrase SERIAL ONEPASS
RULE 11 + b .&gt; c(a.b)
IF cat(a) = [dot] and cat(b) [noun]
THEN cat(c) Inpl; marker(c) := marker(b),
GRAMMAR preference SERIAL ONEPASS
RULE 21 a + 0(111.c.412.d.03) + • .&gt; z(b.a.e)
IF cat(a)■Cnpl and cet(b)=Cverb3 and cat(e).Cnpl
and valency(b)=Cv27
and argument(c).Cargil and marker(C).marker(a)
and argument(d)■Carg27 and m 00000 (d)=In (e)
THEN cat(x) := [phi];
RULE 22 a + b(111.c.412) + • .7 x(b.a.e)
IF cat(a)■Cnp] and cat(b)■Cverb7 and cat(e)=Cnp2
and valency(b).Cv27
and argument(c).Carg17 and marker(c)-marker(a)
THEN cat(x) := Cph27;
RULE 23 • + b(01.c.*2) + e x(b.a.e)
IF cat(a)=Inp7 and cat(b)■Cverb7 and cat(e)=Enpl
and valency(D)/V2]
and argument(c)■1a1&apos;927 and marker(c)marker(e)
THEN cat(x) Cph37;
RULE 24 a + b + • =&gt; x(b.a..41)
IF cat(a)■[nO and cat(b).Everb7 and cat(e).CnO
and valency(b)=Cv27
THEN cat(x) := Iph43;
RULE 25 a + b .&gt; x(b.a)
IF cat(a)./np] and cat(b)■Iverb7
and valency(b)=Cv27
THEN cat(x) := /ph52J
ENDFILE
</figure>
<figureCaption confidence="0.999529">
Figure 3. Output of upper grammar file.
</figureCaption>
<table confidence="0.905032846153846">
Input sentence :
(1) The man drinks the beer.
Result :
PHI CAT.CPH17
CAT=CVERD7 VALENCV.CV27
! !-VAL NODE CAT.CVAL_NODE7 MARKER■CHUMAN7 ARGUMENT.0111017
! i-VAL NODE CAT=CVAL_NODE7 MARKER.CLIGUIM ARGUMENT.CARG27
!-NP CAT.CNP7 MARKER.CHUMAN7
! 1-&apos;THE&apos; CAT=CDET]
i-&apos;MAN&apos; CAT■CNOUN7 NUMBER=CS07 MARKER.CHUMAN7
i-NP CAT.[NP7 MARKER.CLIGUID7
&apos;-&apos;THE&apos; CAT■CDEll
i-&apos;BEER&apos; CAT■CNIGUN1 NUMBEAWS07 MARKER.CLIGUID]
Input sentence :
(2) The man drinks the gasoline.
Result :
PH2 CAT.CPH2
!-:DRINKS&apos; CAT=CVERB7 VALENCY=CV2]
i-VAL_NODE CAT.CVAL_NODE7 MARKER.CHUMAN] ARGUMENT.CARG1]
! i-VAL_NODE CAT.EVAL_NODE7 MARKER.CLIGUID] ARGUMENT.CARG27
!-NP CAT.INP7 MARKER=CHUMAN]
! !-&apos;THE&apos; CAT.IDET7
i-&apos;MAN&apos; CAT.CNOUN7 NUMBER.CSG] MARKER=CHUMAN7
i-NP CAT■INP7 MARKER.CNOTDRINKABLE]
-&apos;THE&apos; CAT.CDET7
i-&apos;GAZOLINE&apos; CAT.CNOUW NUMSER.CSG] MARKER.CNOTDRINKABLE]
</table>
<figure confidence="0.9443955">
RULE 5
IF
THEN
RULE 6
IF
THEN
</figure>
<page confidence="0.882446">
90
</page>
<sectionHeader confidence="0.363959" genericHeader="method">
4. FACILITIES FOR THE USER quistics such as morphology, valency matching and
</sectionHeader>
<bodyText confidence="0.959901636363637">
preference mechanisms Milks, 1983).
There is a system user-interaction in the two
main programs of the system, the compiler and the
interpreter. The following example (fig. 4) shows
how the error messages of the compiler are printed
in the compilation listing. Each star with a number
points to the approximate position of the error
and a message explains the possible errors. The
compiler tries to correct the error and in the
worst case ignores that portion of the text follo-
wing the error.
</bodyText>
<figure confidence="0.495228066666667">
GRAMMAR test
PARALEL ITERATE
*0
pos. 0 : —ES— /SERIAL/ ou /PARALLEL/ attendu
RULE 1
arb *), c(a,b)
IF STRING(a).blabla AND cat(b)*Cnom THEN cat(d) :* Cnoml;
*O*1 *2
—ES— /,/ attendue
—ES— /7/ attendue
—SEM— id. pas defini dans la geometria (cote droit)
*&gt; c(a.0)
: —SEM— id deja utilise sur sortie gauche
IF cat(a)m[det7 THEN categ(b) :* Cnoun2i
*0 *1
</figure>
<figureCaption confidence="0.738738666666667">
pos. 0 : —SEM— id. ne rap I. pas un 00000 ble
pos. 1 : —SEM— id. nw represent, pas un element
Figure 4. Compilation listing with error message.
</figureCaption>
<bodyText confidence="0.785146375">
The interpreter has a parameter that allows the
sequence of rules that fired to be traced. The tra-
ce in figure 5 below corresponds to the execution
of the example (1) in figure 3.
intsrpreteur de 0—codes 83.1 few-14-84
application de la regle 21
PREFERENCE execute(a)
temps d&apos;interpretation : 0.516 sec. CPU
</bodyText>
<figureCaption confidence="0.65169">
3.583 sec. utilisateur
Figure 5. Trace of execution.
</figureCaption>
<sectionHeader confidence="0.763371" genericHeader="method">
5. CONCLUSION
</sectionHeader>
<bodyText confidence="0.9976250625">
The transducer is implemented in a modular
style to allow easy changes to or addition of carn-
ponents as the need arises. This provides the pos-
sibility of experimntation and of further deve-
lopment in various directions:
- integration of a lexical database with special
editing facilities for lexicographers;
- developments of special interpreters for trans-
fer or scoring mechanisms for heuristics;
- refinement of linguistically motivated type
checking.
In this paper we have mainly concentrated on syn-
tactic applications to illustrate the use of the
transducer. However, as we hope to have shown, the
formalism of the system is general enough to allow
interesting applications in various domains of lin-
</bodyText>
<sectionHeader confidence="0.831146" genericHeader="method">
ACENCFAILEDGEMENTS
</sectionHeader>
<bodyText confidence="0.9758235">
Special thanks should go to Roderick Johnson of
CCL, UMIST, who contributed a great deal in the
original design of the system presented here, and
who, through frequent fruitful discussion, has
continued to stimulate and influence later deve-
lopments, as well as to Dominique Petitpierre and
Lindsay Hammond who progranrred the initial imple-
mentation. We would also like to thank all mem-
bers of ISSCO who have participated in the work,
particularly B. Budhmann and S. Warwick.
</bodyText>
<reference confidence="0.981900974358974">
REFERM&apos;NCES
Budhmann, B., Shann, P., Warwick, S. (1984).
Design of a Machine Translation System for a
SUblanguage. Proceedings, COLING &apos;84.
Chevalier, M:, Dansereau, J., Poulin, G. (1978).
TAUM-METEO : description du systeme. T.A&amp;quot;U.M.,
Groupe de reCherthe en traduction autamatique,
Uhiversite de MOontreal, janvier 1978.
Colmerauer, A. (1970). Les systemes-Q ou un forma-
lisme pour analyser et synthetiser des phrases
sur ordinateur. Uhiversite de Montreal.
Johnson, R.L. (1982). Parsing - an MT Perspective.
In: K. Spark Jones and Y. Wilks (ads.), Autama-
tic Natural Language Parsing, Memorandum 10,
Cognitive Studies Centre, University of Essex.
Rosner, M. (1983). Production Systems. In:
M. King (ed.), Parsing Natural Language, Aca-
demic Press, London.
Slocum, J. and Bennett, W.S. (1982). The LRC Ma-
chine Translation System: An Application of
State-of-the-Art Text and Natural Language
Processing Techniques to the Translation of
Technical Manuals. Working paper LRC-82-1,
Linguistics Research Center, University of
Texas at Austin.
Vauquois, B. (1975). La traduction automatique A
Grenoble. Documents de Linguistique Quantita-
tive, 24. Dunod, Paris.
Vauquois, B. (1978). L&apos;evOlution des logiciels et
des modeles linguistiques pour la traduction
automatisee. T.A. Informations, 19.
Varile, G.B. (1983). Charts: A Data Structure for
Parsing. In: M. King (ed.), Parsing Natural
Language, Academic Press, London.
Wiiks, Y. (1973). An Artificial Intelligence Ap-
proach to Machine Translation. In: R.C. Sdhank
and K.M. Colby (eds.), CoompthterMcdels of
Thought and Language, W.H. Freeman, San Fran-
cisco., pp. 114-151.
</reference>
<figureCaption confidence="0.620094285714286">
application de la regle 1
application de la resin 1
application de la regle 2
application de la raffle 3
application de la regls 6
application de la regle 7
VOCABULARY execute(e)
</figureCaption>
<figure confidence="0.9638322">
application de la regle 11
11
NUARAW:.::ut:(;Ig&amp;quot;
pos. 0
pos. 1
pos. 2
RULE 2
a(a)
*0
pos. 0
</figure>
<page confidence="0.976002">
91
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.472107">
<title confidence="0.999054">A GENERAL TRANSDUCER FOR TEACHING COMPUTATIONAL</title>
<author confidence="0.604383">Shann</author>
<affiliation confidence="0.8123185">Dalle Molle Institute for Semantic and Cognitive Studies University of Geneva</affiliation>
<address confidence="0.844913">Switzerland</address>
<abstract confidence="0.999070363636364">The (ii-system is a tree-to-tree transducer developed for teaching purposes in madhine.translation. The transducer is a specialized production system giving the linguists the tools for expressing information in a syntax that is close to theoretical linguistics. Major emphasis was placed on developing a system that is user friendly, uniform and legible. This paper describes the linguistic data structure, the rule formalism and the control facilities that the linguist is provided with.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>B Budhmann</author>
<author>P Shann</author>
<author>S Warwick</author>
</authors>
<title>Design of a Machine Translation System for a SUblanguage. Proceedings,</title>
<date>1984</date>
<journal>COLING</journal>
<volume>84</volume>
<marker>Budhmann, Shann, Warwick, 1984</marker>
<rawString>Budhmann, B., Shann, P., Warwick, S. (1984). Design of a Machine Translation System for a SUblanguage. Proceedings, COLING &apos;84.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Dansereau</author>
<author>G Poulin</author>
</authors>
<title>TAUM-METEO : description du systeme. T.A&amp;quot;U.M., Groupe de reCherthe en traduction autamatique, Uhiversite de MOontreal,</title>
<date>1978</date>
<location>janvier</location>
<marker>Dansereau, Poulin, 1978</marker>
<rawString>Chevalier, M:, Dansereau, J., Poulin, G. (1978). TAUM-METEO : description du systeme. T.A&amp;quot;U.M., Groupe de reCherthe en traduction autamatique, Uhiversite de MOontreal, janvier 1978.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Colmerauer</author>
</authors>
<title>Les systemes-Q ou un formalisme pour analyser et synthetiser des phrases sur ordinateur. Uhiversite de Montreal.</title>
<date>1970</date>
<contexts>
<context position="2464" citStr="Colmerauer, 1970" startWordPosition="373" endWordPosition="374">and algorithms (Vavquois, 1975). The linguist should have the means to express his knowledge declaratively without being obliged to mix compu1 This project is sponsored by the Swiss government. tational algorithms and linguistic data. Production systems (Rosner, 1983) seem particularly suited to meet such requirements (Johnson, 1982); the production set that expresses the object-level knowledge is clearly separated from the control part that drives the application of the productions. Colmerauer&apos;s 0-system is the classic example of such a uniform production system used for machine translation (Colmerauer, 1970; Chevalier, 1978: TAUM-METEO). The linguistic knowledge is expressed declaratively using the same data structure during the whole translation process as well as the same type of production rules for dictionary entries, morphology, analysis, transfer and generation. The disadvantage of the 0-system is its quite unnatural rule-syntax for non-programmers and its lack of flexible control mechanism for the user (Vauquois, 1978). In the design of our system the basic uniform . scheme of 0-systems has been followed, but the rule syntax, the linguistic data structure and the control facilities have b</context>
</contexts>
<marker>Colmerauer, 1970</marker>
<rawString>Colmerauer, A. (1970). Les systemes-Q ou un formalisme pour analyser et synthetiser des phrases sur ordinateur. Uhiversite de Montreal.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R L Johnson</author>
</authors>
<title>Parsing - an</title>
<date>1982</date>
<journal>Autamatic Natural Language Parsing, Memorandum</journal>
<volume>10</volume>
<institution>Cognitive Studies Centre, University of Essex.</institution>
<contexts>
<context position="2183" citStr="Johnson, 1982" startWordPosition="331" endWordPosition="332">ITY OF THE SYSTEM As a tool for training computational linguists, major ermahasis was placed on developing a system that is user friendly, uniform, and which provides a legible syntax. One of the important requirements in machine translation is the separation of linguistic data and algorithms (Vavquois, 1975). The linguist should have the means to express his knowledge declaratively without being obliged to mix compu1 This project is sponsored by the Swiss government. tational algorithms and linguistic data. Production systems (Rosner, 1983) seem particularly suited to meet such requirements (Johnson, 1982); the production set that expresses the object-level knowledge is clearly separated from the control part that drives the application of the productions. Colmerauer&apos;s 0-system is the classic example of such a uniform production system used for machine translation (Colmerauer, 1970; Chevalier, 1978: TAUM-METEO). The linguistic knowledge is expressed declaratively using the same data structure during the whole translation process as well as the same type of production rules for dictionary entries, morphology, analysis, transfer and generation. The disadvantage of the 0-system is its quite unnatu</context>
</contexts>
<marker>Johnson, 1982</marker>
<rawString>Johnson, R.L. (1982). Parsing - an MT Perspective. In: K. Spark Jones and Y. Wilks (ads.), Autamatic Natural Language Parsing, Memorandum 10, Cognitive Studies Centre, University of Essex.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Rosner</author>
</authors>
<title>Production Systems.</title>
<date>1983</date>
<booktitle>Parsing Natural Language,</booktitle>
<editor>In: M. King (ed.),</editor>
<publisher>Academic Press,</publisher>
<location>London.</location>
<contexts>
<context position="2116" citStr="Rosner, 1983" startWordPosition="322" endWordPosition="323">udents in computational linguistics. 2. THE UNIFORMITY AND SIMPLICITY OF THE SYSTEM As a tool for training computational linguists, major ermahasis was placed on developing a system that is user friendly, uniform, and which provides a legible syntax. One of the important requirements in machine translation is the separation of linguistic data and algorithms (Vavquois, 1975). The linguist should have the means to express his knowledge declaratively without being obliged to mix compu1 This project is sponsored by the Swiss government. tational algorithms and linguistic data. Production systems (Rosner, 1983) seem particularly suited to meet such requirements (Johnson, 1982); the production set that expresses the object-level knowledge is clearly separated from the control part that drives the application of the productions. Colmerauer&apos;s 0-system is the classic example of such a uniform production system used for machine translation (Colmerauer, 1970; Chevalier, 1978: TAUM-METEO). The linguistic knowledge is expressed declaratively using the same data structure during the whole translation process as well as the same type of production rules for dictionary entries, morphology, analysis, transfer a</context>
</contexts>
<marker>Rosner, 1983</marker>
<rawString>Rosner, M. (1983). Production Systems. In: M. King (ed.), Parsing Natural Language, Academic Press, London.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Slocum</author>
<author>W S Bennett</author>
</authors>
<title>The LRC Machine Translation System: An Application of State-of-the-Art Text and Natural Language Processing Techniques to the Translation of Technical Manuals.</title>
<date>1982</date>
<tech>Working paper LRC-82-1,</tech>
<institution>Linguistics Research Center, University of Texas at Austin.</institution>
<marker>Slocum, Bennett, 1982</marker>
<rawString>Slocum, J. and Bennett, W.S. (1982). The LRC Machine Translation System: An Application of State-of-the-Art Text and Natural Language Processing Techniques to the Translation of Technical Manuals. Working paper LRC-82-1, Linguistics Research Center, University of Texas at Austin.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Vauquois</author>
</authors>
<title>La traduction automatique A Grenoble.</title>
<date>1975</date>
<booktitle>Documents de Linguistique Quantitative, 24. Dunod,</booktitle>
<location>Paris.</location>
<marker>Vauquois, 1975</marker>
<rawString>Vauquois, B. (1975). La traduction automatique A Grenoble. Documents de Linguistique Quantitative, 24. Dunod, Paris.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Vauquois</author>
</authors>
<title>L&apos;evOlution des logiciels et des modeles linguistiques pour la traduction automatisee.</title>
<date>1978</date>
<journal>T.A. Informations,</journal>
<volume>19</volume>
<contexts>
<context position="2891" citStr="Vauquois, 1978" startWordPosition="436" endWordPosition="437">control part that drives the application of the productions. Colmerauer&apos;s 0-system is the classic example of such a uniform production system used for machine translation (Colmerauer, 1970; Chevalier, 1978: TAUM-METEO). The linguistic knowledge is expressed declaratively using the same data structure during the whole translation process as well as the same type of production rules for dictionary entries, morphology, analysis, transfer and generation. The disadvantage of the 0-system is its quite unnatural rule-syntax for non-programmers and its lack of flexible control mechanism for the user (Vauquois, 1978). In the design of our system the basic uniform . scheme of 0-systems has been followed, but the rule syntax, the linguistic data structure and the control facilities have been modernized according to recent developments in machine translation (Vauquois, 1978;.Bortet, 1977; Johnson, 1980; Slocum, 1982). These three points will be developed in the next section. 3. DESCRIPTION OF THE SYSTEM 3.1 Overview The general framework is a production system where linguistic object knowledge is expressed in a rule-based declarative way. The system takes the dictionaries and the grammars as data, compiles t</context>
</contexts>
<marker>Vauquois, 1978</marker>
<rawString>Vauquois, B. (1978). L&apos;evOlution des logiciels et des modeles linguistiques pour la traduction automatisee. T.A. Informations, 19.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G B Varile</author>
</authors>
<title>Charts: A Data Structure for Parsing.</title>
<date>1983</date>
<booktitle>Parsing Natural Language,</booktitle>
<editor>In: M. King (ed.),</editor>
<publisher>Academic Press,</publisher>
<location>London.</location>
<contexts>
<context position="3720" citStr="Varile, 1983" startWordPosition="569" endWordPosition="570">ents in machine translation (Vauquois, 1978;.Bortet, 1977; Johnson, 1980; Slocum, 1982). These three points will be developed in the next section. 3. DESCRIPTION OF THE SYSTEM 3.1 Overview The general framework is a production system where linguistic object knowledge is expressed in a rule-based declarative way. The system takes the dictionaries and the grammars as data, compiles these data and the interpreter then uses them to process the input text. The decoder transforms the result into a digestable form for the user. 3.2 Data structure The data structure of the system is based on a chart (Varile, 1983). One of the main advantages of using a chart is that the data structure does not change throughout the whole process of translation (Vauquois, 1978). In the 0-system all linguistic data on the arcs is represented by bracketed strings causing an unclean mixture of constituent structure and other linguistic attributes such as grammatical and semantic labels, etc. With this representation 88 type checking is not possible. Vauquois proposes two changes : 1) Tree structures with complex labels on the nodes in order to allow interaction between different linguistic levels such as syntax or semantic</context>
</contexts>
<marker>Varile, 1983</marker>
<rawString>Varile, G.B. (1983). Charts: A Data Structure for Parsing. In: M. King (ed.), Parsing Natural Language, Academic Press, London.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Wiiks</author>
</authors>
<title>An Artificial Intelligence Approach to Machine Translation.</title>
<date>1973</date>
<booktitle>CoompthterMcdels of Thought and Language, W.H. Freeman,</booktitle>
<pages>114--151</pages>
<editor>In: R.C. Sdhank and K.M. Colby (eds.),</editor>
<location>San Francisco.,</location>
<marker>Wiiks, 1973</marker>
<rawString>Wiiks, Y. (1973). An Artificial Intelligence Approach to Machine Translation. In: R.C. Sdhank and K.M. Colby (eds.), CoompthterMcdels of Thought and Language, W.H. Freeman, San Francisco., pp. 114-151.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>