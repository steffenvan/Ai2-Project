<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000063">
<title confidence="0.9978">
A semantically-derived subset of English for hardware verification
</title>
<author confidence="0.99619">
Alexander Holt and Ewan Klein
</author>
<affiliation confidence="0.997510666666667">
HCRC Language Technology Group
Division of Informatics
University of Edinburgh
</affiliation>
<email confidence="0.922804">
al exander .hol t@ed. ac .uk ewan klein@ed. ac uk
</email>
<sectionHeader confidence="0.99208" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999967333333333">
To verify hardware designs by model checking,
circuit specifications are commonly expressed in
the temporal logic CTL. Automatic conversion
of English to CTL requires the definition of an
appropriately restricted subset of English. We
show how the limited semantic expressibility of
CTL can be exploited to derive a hierarchy of
subsets. Our strategy avoids potential difficulties
with approaches that take existing computational
semantic analyses of English as their starting
point—such as the need to ensure that all sentences
in the subset possess a CTL translation.
</bodyText>
<sectionHeader confidence="0.914244" genericHeader="method">
1 Specifications in Natural Language
</sectionHeader>
<bodyText confidence="0.999322904761905">
Mechanised formal specification and verification
tools can significantly aid system design in both
software and hardware (Clarke and Wing, 1996).
One well-established approach to verification, par-
ticularly of hardware and protocols, is temporal
model checking, which allows the designer to
check that certain desired properties hold of the
system (Clarke and Emerson, 1981). In this
approach, specifications are expressed in a temporal
logic and systems are represented as finite state
transition systems.&apos; An efficient search method
determines whether the desired property is true in
the model provided by the transition system; if
not, it provides a counterexample. Despite the
undoubted success of temporal model checking as
a technique, the requirement that specifications be
expressed in temporal logic has proved an obstacle
to its take-up by circuit designers and therefore
alternative interfaces involving graphics and natural
language have been explored. In this paper, we
address some of the challenges raised by converting
</bodyText>
<footnote confidence="0.752100333333333">
1In practice, it turns out to be preferable to use a symbolic
representation of the state model, thereby avoiding the state
explosion problem (Macmillan, 1993).
</footnote>
<bodyText confidence="0.994926513513513">
English specifications into temporal logic as a
prelude to hardware verification.
One general approach to this kind of task exploits
existing results in the computational analysis of
natural language semantics, including contextual
phenomena such as anaphora and ellipsis, in order
to bridge the gap between informal specifications
in English and formal specifications in some target
formalism (Fuchs and Schwitter, 1996; Schwitter
and Fuchs, 1996; Pulman, 1996; Nelken and
Francez, 1996). English input sentences are initially
mapped into a general purpose semantic formalism
such as Discourse Representation Theory (Kamp
and Reyle, 1993) or the Core Language Engine&apos;s
quasi logical form (Alshawi, 1992) at which point
context dependencies are resolved. The output of
this stage then undergoes a further mapping into
the application-specific language which expresses
formal specifications. One system which departs
from this framework is presented by Fantechi et al.
(1994), whose grammar contains special purpose
rules for recognising constructions that map directly
into ACTL formulas,2 and can trigger clarification
dialogues with the user in the case of a one-to-many
mapping.
Independently, the interface may require the user
to employ a controlled language, in which syntax
and lexicon are restricted in order to minimise
ambiguity with respect to the formal specification
language (Macias and Pulman, 1995; Fuchs and
Schwitter, 1996; Schwitter and Fuchs, 1996). The
design of a controlled language is one method
of addressing the key problem pointed out by
Pulman (1996, p. 235), namely to ensure that an
English input has a valid translation into the target
formalism; this is the problem that we focus on
here. Inevitably, we need to pay some attention to
</bodyText>
<footnote confidence="0.996767666666667">
2ACTL is an action-based branching temporal logic which,
despite the name, is not directly related to the CTL language
that we discuss below.
</footnote>
<page confidence="0.99299">
451
</page>
<figureCaption confidence="0.99992">
Figure 1: A CTL structure
Figure 2: Computation tree
</figureCaption>
<bodyText confidence="0.9921135">
the syntactic and semantic properties of our target
formalism and this is the topic of the next section.
</bodyText>
<sectionHeader confidence="0.650792" genericHeader="method">
2 CTL Specification and Model Checking
</sectionHeader>
<bodyText confidence="0.99593675">
While early attempts to use temporal logics for
verification had explored both linear and branching
models of time, Clarke et at. (1986) showed that
the branching temporal logic CTL (Computation
Tree Logic) allowed efficient model-checking in
place of laborious proof construction methods.3
In models of CTL, the temporal order relation &lt;
defines a tree which branches towards the future.
As pointed out by Thomason (1984), branching
time provides a basis for formalising the intuition
that statements of necessity and possibility are often
non-trivially tensed. As we move forward through
time, certain possible worlds (i.e., paths in the tree)
are eliminated, and thus what was possible at t is no
longer available as an option at some t&apos; later than t.
CTL uses formulas beginning with A to express
necessity. AG f is true at a time t just in case f
is true along all paths that branch forward from the
tree at t (true globally). AF f holds when, on all
paths, f is true at some time in the future. AX f is
true at t when f is true at the next time point, along
all paths. Finally, A[f U g] holds if, for each path,
g is true at some time, and from now until that point
f is true.
</bodyText>
<figureCaption confidence="0.6039195">
Figure 1, from Clarke et at. (1986), illustrates
a CTL model structure, with the relation &lt;
</figureCaption>
<bodyText confidence="0.98994375">
represented by arrows between circles (states), and
the atomic propositions holding at a state being the
letters contained in the circle. A CTL structure gives
rise to an infinite computation tree, and Figure 2
</bodyText>
<footnote confidence="0.8337695">
3Subsequently, model-checking methods which use linear
temporal logic have been developed. While theoretically less
efficient that those based on CTL, they may turn out to be
effective in practice (Vardi, 1998).
</footnote>
<bodyText confidence="0.999622">
shows the initial part of such a tree corresponding
to Figure 1, when so is selected as the initial
state. States correspond to points of time in the
course of a computation, and branches represent
non-determinism. Formulas of CTL are either true
or false with respect to any given model; see Table 1
for three examples interpreted at so in the Figure 1
structure.
</bodyText>
<sectionHeader confidence="0.996647" genericHeader="method">
3 Data
</sectionHeader>
<bodyText confidence="0.977972791666667">
One of our key tasks has been to collect an
initial sample of specifications in English, so as to
identify linguistic constructions and usages typical
of specification discourse. We currently have a
corpus of around a hundred sentences, most of
which were elicited by asking suitably qualified
respondents to describe the behaviour manifested by
timing diagrams. An example of such a diagram is
displayed in Figure 3, which is adapted from one of
Fisler&apos;s (1996, p. 5).
The horizontal axis of the diagram indicates the
passing of time (as measured by clock cycles) and
the vertical axis indicates the transition of signals
between the states of high and low. (A signal is
formula sense
AXc for all paths, at the next
state c is true
AGb for all paths, globally b
is true
for all paths, eventually
there is a state from
which, for all paths, at true
the following state a
and b are true
</bodyText>
<tableCaption confidence="0.998254">
Table 1: Interpretation of CTL formulas
</tableCaption>
<figure confidence="0.907128166666667">
AF(AX(a A b))
at so
true
false
452
=1
</figure>
<figureCaption confidence="0.987486">
Figure 3: Timing diagram for pulsing circuit
</figureCaption>
<bodyText confidence="0.850065090909091">
=1
(3) a. Every request is eventually acknowledged
and once a request is acknowledged the
request is eventually deasserted and
eventually after that the acknowledge
signal goes low.
b. If r rises then after one cycle eventually a
rises and then after one cycle eventually r
falls and then after one cycle eventually a
falls.
which can be rendered in CTL as (4).
</bodyText>
<figure confidence="0.93662">
r
a
</figure>
<figureCaption confidence="0.999462">
Figure 4: Timing diagram for handshaking protocol
</figureCaption>
<bodyText confidence="0.966910428571429">
a time-varying value present at some point in the
circuit.) In Figure 3, the input signal i makes a
transition from high to low which after a one-cycle
delay triggers a unit-duration pulse on the output
signal o.
(1 a—b) give two possible English descriptions of
the regularity illustrated by Figure 3,
</bodyText>
<listItem confidence="0.762768333333333">
(1) a. A pulse of width one is generated on the
output o one cycle after it detects a falling
edge on input i.
</listItem>
<bodyText confidence="0.9234152">
b. If i is high and then is low on the next
cycle, then o is low and after one cycle
becomes high and then after one more
cycle becomes low.
while (2) is a CTL description.
</bodyText>
<listItem confidence="0.620651">
(2) AG(i —&gt; AX(-4 —&gt; (—io A AX(o AAX—io))))
</listItem>
<bodyText confidence="0.999924333333333">
A noteworthy difference between the two English
renderings is that the first is clearly more abstract
than the second. Description (lb) is closer to
the CTL formula (2), and consequently easier to
translate into CTL.4
For another example of the same phenomenon,
consider the timing diagram in Figure 4. As
before, sentences (3a—b) give two possible English
descriptions of the regularity illustrated by Figure 4,
</bodyText>
<footnote confidence="0.560043">
4Our system does not yet resolve anaphoric references, as
in (la). There are existing English-to-CTL systems which do,
however, such as that of Nelken and Francez (1996).
</footnote>
<figure confidence="0.880673">
(4) AG(—&apos;r A AXr —&gt; AF(—.a AX(a
A AF(r A AX(—ir A AF(a AAX—a))))))
</figure>
<bodyText confidence="0.8835862">
Example (3b) parallels (lb) in being closer to
CTL than its (a) counterpart. Nevertheless, (3b)
is ontologically richer than CTL in an important
respect, in that it makes reference to the event
predicates rise and fall.
</bodyText>
<sectionHeader confidence="0.969709" genericHeader="method">
4 Defining a Controlled Language
</sectionHeader>
<bodyText confidence="0.999978793103448">
Even confining our attention to hardware speci-
fications of the level of complexity examined so
far, we can conclude there are some kinds of
English locutions which will map rather directly
into CTL, whereas others have a much less direct
relation. What is the nature of this indirect
relation? Our claim in this paper is that we can
give semantically-oriented characterisations of the
relation between complexity in English sentences
and their suitability for inclusion in a controlled
language for hardware verification. Moreover, this
semantic orientation yields a hierarchy of subsets
of English. (This hierarchy is a theoretical entity
constructed for our specific purposes, of course, not
a general linguistic hypothesis about English.)
Our first step in developing an English-to-CTL
conversion system was to build a prototype based
on the Alvey Natural Language Tools Grammar
(Grover et al., 1993). The Alvey grammar is a broad
coverage grammar of English using GPSG-style
rules, and maps into a event-based, unscoped
semantic representation.
For this application, we used a highly restricted
lexicon and simplified the grammar in a number
of ways (for example: fewer coordination rules;
no deontic readings of modals). Tidhar (1998)
reports an initial experiment in taking the semantic
output generated from a small set S of English
specifications, and converting it into CTL. Given
</bodyText>
<page confidence="0.997175">
453
</page>
<bodyText confidence="0.999719285714286">
that the Alvey grammar will produce plausible
semantic readings for a much larger set S&apos;, the
challenge is to characterise an intermediate set S,
with S CSC 5&apos;, that would admit a translation
into formulas of CTL. Let&apos;s assume that we have a
reverse translation 0-1 from CTL to English; then
we would like S = range (0-1) .
</bodyText>
<subsectionHeader confidence="0.96555">
4.1 Transliteration
</subsectionHeader>
<bodyText confidence="0.9999236">
Now suppose that 0-1 is a literal translation from
CTL to English. That is, we recurse on the formulas
of CTL, choosing a canonical lexical item or phrase
in English as a direct counterpart to each constituent
of the CTL formula. In fact, we have implemented
such a translation as a DCG ct12 eng. To illustrate,
c t12 eng maps the formula (2) into (5):
(5) globally if i is high then after 1 cycle if i is
low then o is low and after 1 cycle o is high
and after 1 cycle o is low
Let VI 1 be the function defined by ct12 eng;
then we call = range(C-1) the canonical
transliteration level of English. We can be confident
that it is possible to build a translation 01 which
will map any sentence in CI into a formula of
CTL. r1 can be trivially augmented by adding
near-synonymous lexical and syntactic variants. For
example, i is high can be replaced by signal i holds,
and after 1 cycle ... by 1 cycle later... . This adds
no semantic complexity. We call the this language
(notated Gt) the augmented transliteration level.
One potential problem with defining 01 in this
way is that the sentences generated by c t 12 eng
soon become structurally ambiguous. We can solve
this either by generating unambiguous paraphrases,
or by analysing the relevant class of ambiguities and
making sure that 01 is able to provide all relevant
CTL interpretations.
These languages contain only sentences. Hard-
ware specifications often have the form of multi-
sentence discourses, however. Such discourses, and
the additional phenomena they introduce, occur at
higher levels of our language hierarchy, and we
presently lack any detailed analysis of them in the
terms of this paper.
</bodyText>
<subsectionHeader confidence="0.958051">
4.2 Compositional indirect semantics
</subsectionHeader>
<bodyText confidence="0.987283">
We&apos;ll say that an English input expression has
compositional indirect semantics just in case
1. there is a compositional mapping to CTL, but
where
2. the semantics of the English is ontologically
richer than the intended CTL translation.
The best way to explain these notions is by way
of some examples. First, consider expressions like
the nouns pulse, edge and the verbs rise, fall. These
refer to certain kinds of event. For example, an edge
denotes the event where a signal changes between
two distinct states; from high at time t to low at time
t 1 or conversely. In CTL, the notion of an edge on
signal i corresponds approximately to the following
expression:5
</bodyText>
<listItem confidence="0.877925">
(6) (i A AX-&apos;i) v (-i A AX i)
</listItem>
<bodyText confidence="0.9995276">
Similarly, a pulse can be analysed in terms of a
rising edge followed by a falling edge.
What do we mean by saying that there is a
compositional mapping of locutions at this level to
CTL? Our claim is that they can be algorithmically
converted into pure CTL without reference to
unbounded context. What do we mean by saying
that these English expressions involve a richer
ontology than CTL? If compositional mapping
holds, then clearly we are not forced to augment the
standard models for CTL in order to interpret them
(although this route might be desirable for other
reasons). Rather, we are saying that the &apos;natural&apos;
ontology for these expressions is richer than that
allowed for CTL, even if reduction is possible.6
</bodyText>
<subsectionHeader confidence="0.993963">
4.3 Non-compositional indirect semantics
</subsectionHeader>
<bodyText confidence="0.999997571428571">
We consider the conversion to involve non-
compositional indirect semantics when there is
some aspect of non-locality in the domain of the
translation function. That is, some form of inference
is required—probably involving domain-specific
axioms or general temporal axioms—in order to
obtain a CTL formula from the English expression.
Here are two examples. The first comes from
sentence (3a), where the use of eventually might
normally be taken to correspond directly to the CTL
operator AF. However because of the domain of
(3a)—a handshaking protocol, evidenced by the use
of the verbs acknowledge and request—it is in fact
more accurate to require an extra AX in the CTL.
</bodyText>
<footnote confidence="0.735326857142857">
5Approximately, in the sense that one cannot simply
substitute this expression arbitrarily into a larger formula, as
it depends on the syntactic context—for example, whether it
occurs in the antecedent or consequent of an implication.
6There is a further kind of ontological richness in English at
this level, involving the relation between events, rather than the
events themselves. Space prohibits a closer examination here.
</footnote>
<page confidence="0.993265">
454
</page>
<construct confidence="0.986551142857143">
examples
i is high; after 1 cycle
i holds; 1 cycle later
i rises; there is a pulse
of unit duration
r is eventually
acknowledged
</construct>
<tableCaption confidence="0.989705">
Table 2: Language hierarchy
</tableCaption>
<bodyText confidence="0.99019675">
This ensures that the three transitions cannot occur
at the same time.
We see here an example of domain-specific
interpretation conventions that our system needs to
be aware of. Clearly, it must incorporate them
in such a way that users are still able to reliably
predict how the system will react to their English
specifications.
The second example is
(7) From one cycle after i changes until it changes
again x and y are different.
In this case there is an interaction between a
non-local linguistic phenomenon and something
specific to the CTL conversion, namely how to
make the right connection between the first and the
second changes.
</bodyText>
<subsectionHeader confidence="0.999407">
4.4 Language hierarchy
</subsectionHeader>
<bodyText confidence="0.999993302325582">
Table 2 summarises the main proposals of this
section. The left-hand column lists the hierarchy
of postulated sublanguages, in increasing order of
semantic expressiveness. The middle column tries
to calibrate this expressiveness. By &apos;extended CTL&apos;,
we mean a superset of CTL which is syntactically
augmented to allow formulas such ,as rise(p),
fall( p), discussed earlier, and pulse (p , v, n), where
p is an atom, v is a Boolean indicating a high or
low value, and n is a natural number indicating
duration. The semantic clauses would have to
be correspondingly augmented—as carried out for
example by Nelken and Francez (1996), for rise(p)
and fall(p). By &apos;full SR&apos;, we are hypothesising that
it would be necessary to invoke a general semantic
representation language for English.
We have constructed a context-free grammar for
£2, in order to obtain a concrete approximation to
a controlled subset of English for expressing spec-
ifications. There are two cautionary observations.
First, as just indicated, £2 maps directly not into
CTL, but into extended CTL. Second, our grammar
for £2 ignores some subtleties of English syntax and
morphology. For example, subject-verb agreement;
modal auxiliary subcategorisation; varieties of verb
phrase modification by adverbs; and forms of
anaphora.
These defects in our CFG for ,C2 are not
fundamental problems, however. The device of
using the c tl2eng mapping to define a sublanguage
is a specific methodology for finding a semantically
motivated sublanguage. As such it is only an
approximation to the language that we wish our
system to deal with. This CFG is not the
grammar used by our parser (which can, in fact,
deal with many of the details of English syntax
just mentioned). We may, therefore, introduce a
language .C1- which corrects the grammatical errors
of £2 and extends it with some degree of anaphora
and ellipsis.
We note that it would be useful to have a
firmer theoretical grasp on the relations between our
sublanguages; we have ongoing work in this area.
</bodyText>
<sectionHeader confidence="0.998834" genericHeader="conclusions">
5 Conclusion
</sectionHeader>
<bodyText confidence="0.985060241379311">
Much work on controlled languages has been
motivated by the ambition to &amp;quot;find the right trade-
off between expressiveness and processability&amp;quot;
(Schwitter and Fuchs, 1996). An alternative,
suggested by what we have proposed here, is to
bring into play a hierarchy of controlled languages,
ordered by the degree to which they semantically
approximate the target formalism. Each point in
the hierarchy brings different trade-offs between
expressiveness and tractability, and evaluating their
different merits will depend heavily on the particu-
lar task within a generic application domain, as well
as on the class of users.
As a final remark, we wish to point out that
there may be advantages in identifying plausible
restrictions on the target formalism. Dwyer et
al. (1998a; 1998b) have convincingly argued that
users of formal verification languages make use
of recurring specification patterns. That is, rather
than drawing on the full complexity of languages
such as CTL, documented specifications tend to
fall into much simpler formulations which express
commonly desired properties. In future work, we
plan to investigate specification patterns as a further
source of constraints that propagate backwards into
the controlled English, perhaps providing additional
mechanisms for dealing with apparent ambiguity in
user input.
level expressiveness
</bodyText>
<figure confidence="0.943794">
Li pure CTL
pure CTL
£2 extended CTL
£3 full SR?
</figure>
<page confidence="0.997879">
455
</page>
<sectionHeader confidence="0.996514" genericHeader="acknowledgments">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.997984428571429">
The work reported here has been carried out as part
of PROSPER (Proof and Specification Assisted De-
sign Environments), ESPRIT Framework IV LTR
26241, http: //www.dcs .gla .ac .uk/prosper/.
Thanks to Marc Moens, Claire Grover, Mike
Fourman, Dirk Hoffman, Tom Melham, Thomas
Kropf, Mike Gordon, and our ACL reviewers.
</bodyText>
<sectionHeader confidence="0.998501" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999698011111111">
Hiyan Alshawi, editor. 1992. The Core Language
Engine. MIT Press.
Edmund M. Clarke and E. Allen Emerson.
1981. Synthesis of synchronization skeletons
for branching time temporal logic. In Logic of
Programs: Workshop, Yorktown Heights, NY,
May 1981, volume 131 of Lecture Notes in
Computer Science. Springer-Verlag.
Edmund M. Clarke and Jeanette M. Wing. 1996.
Formal methods: State of the art and future direc-
tions. ACM Computing Surveys, 28(4):626-643.
Edmund M. Clarke, E. Allen Emerson, and
A. Prasad Sistla. 1986. Automatic verification
of finite-state concurrent systems using tempo-
ral logic specifications. ACM Transactions on
Programming Languages and Systems, 8(2):244-
263.
Matthew B. Dwyer, George S. Avrunin, and
James C. Corbett. 1998a. Patterns in property
specifications for finite-state verification. Tech-
nical Report KSU CIS TR-98-9, Department of
Computing and Information Sciences, Kansas
State University.
Matthew B. Dwyer, George S. Avrunin, and
James C. Corbett. 1998b. Property specification
patterns for finite-state verification. In M. Ardis,
editor, Proceedings of the Second Workshop on
Formal Methods in Software Practice, pages
7-15.
A. Fantechi, S. Gnesi, G. Ristori, M. Carenini,
M. Marino, and P. Moreschini. 1994. Assisting
requirement formalization by means of natural
language translation. Formal Methods in System
Design, 4:243-263.
Kathryn Fisler. 1996. A Unified Approach to Hard-
ware Verification through a Heterogeneous Logic
of Design Diagrams. Ph.D. thesis, Department of
Computer Science, Indiana University.
Norbert E. Fuchs and Rolf Schwitter. 1996.
Attempto Controlled English (ACE). In CLAW
96: First International Workshop on Controlled
Language Applications. Centre for Computa-
tional Linguistics, Katholieke Universiteit Leu-
ven, Belgium.
Claire Grover, John Carroll, and Ted Briscoe. 1993.
The Alvey Natural Language Tools Grammar
(4th release). Technical Report 284, Computer
Laboratory, University of Cambridge.
Hans Kamp and Uwe Reyle. 1993. From Discourse
to Logic: Introduction to Modeltheoretic Se-
mantics of Natural Language, Formal Logic and
Discourse Representation Theory. Number 42 in
Studies in Linguistics and Philosophy. Kluwer.
Benjamin Macias and Stephen G. Pulman. 1995.
A method for controlling the production of
specifications in natural language. The Computer
Journal, 38(4):310-318.
Kenneth L. Macmillan. 1993. Symbolic Model
Checking. Kluwer.
Rani Nelken and Nissim Francez. 1996. Translat-
ing natural language system specifications into
temporal logic via DRT. Technical Report LCL-
96-2, Laboratory for Computational Linguistics,
Technion, Israel Institute of Technology.
Stephen G. Pulman. 1996. Controlled language
for knowledge representation. In CLAW 96:
Proceedings of the First International Workshop
on Controlled Language Applications, pages
233-242. Centre for Computational Linguistics,
Katholieke Universiteit Leuven, Belgium.
Rolf Schwitter and Norbert E. Fuchs. 1996.
Attempto — from specifications in controlled
natural language towards executable specifica-
tions. In GI EMISA Workshop. Natiirlichsprach-
licher Entwurf von Informations-systemen, Tutz-
ing, Germany.
Richmond H. Thomason. 1984. Combinations
of tense and modality. In D. Gabbay and
F. Guenthner, editors, Handbook of Philosophical
Logic. Volume II: Extensions of Classical Logic,
volume 146 of Synthese Library, chapter 11.3,
pages 89-134. D. Reidel.
Dan Tidhar. 1998. ALVEY to CTL translation —
A preparatory study for finite-state verification
natural language interface. Msc dissertation, De-
partment of Linguistics, University of Edinburgh.
Moshe Y. Vardi. 1998. Linear vs. branching time:
A complexity-theoretic perspective. In LICS&apos;98:
Proceedings of the Annual IEEE Symposium on
Logic in Computer Science. Indiana University.
</reference>
<page confidence="0.999082">
456
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.000136">
<title confidence="0.999682">A semantically-derived subset of English for hardware verification</title>
<author confidence="0.999975">Holt Klein</author>
<affiliation confidence="0.999458">HCRC Language Technology Group Division of Informatics University of Edinburgh</affiliation>
<email confidence="0.720116">exander.holac.ukewanklein@ed.acuk</email>
<abstract confidence="0.991218388127855">To verify hardware designs by model checking, circuit specifications are commonly expressed in the temporal logic CTL. Automatic conversion of English to CTL requires the definition of an appropriately restricted subset of English. We show how the limited semantic expressibility of can be exploited to derive a subsets. Our strategy avoids potential difficulties with approaches that take existing computational semantic analyses of English as their starting point—such as the need to ensure that all sentences in the subset possess a CTL translation. 1 Specifications in Natural Language Mechanised formal specification and verification tools can significantly aid system design in both software and hardware (Clarke and Wing, 1996). One well-established approach to verification, parof hardware and protocols, is checking, allows the designer to check that certain desired properties hold of the system (Clarke and Emerson, 1981). In this approach, specifications are expressed in a temporal logic and systems are represented as finite state transition systems.&apos; An efficient search method determines whether the desired property is true in the model provided by the transition system; if not, it provides a counterexample. Despite the undoubted success of temporal model checking as a technique, the requirement that specifications be expressed in temporal logic has proved an obstacle to its take-up by circuit designers and therefore alternative interfaces involving graphics and natural language have been explored. In this paper, we address some of the challenges raised by converting practice, it turns out to be preferable to use a symbolic of the state model, thereby avoiding the problem 1993). English specifications into temporal logic as a prelude to hardware verification. One general approach to this kind of task exploits existing results in the computational analysis of natural language semantics, including contextual phenomena such as anaphora and ellipsis, in order to bridge the gap between informal specifications in English and formal specifications in some target formalism (Fuchs and Schwitter, 1996; Schwitter and Fuchs, 1996; Pulman, 1996; Nelken and Francez, 1996). English input sentences are initially mapped into a general purpose semantic formalism such as Discourse Representation Theory (Kamp and Reyle, 1993) or the Core Language Engine&apos;s quasi logical form (Alshawi, 1992) at which point context dependencies are resolved. The output of this stage then undergoes a further mapping into the application-specific language which expresses formal specifications. One system which departs from this framework is presented by Fantechi et al. (1994), whose grammar contains special purpose rules for recognising constructions that map directly ACTL and can trigger clarification dialogues with the user in the case of a one-to-many mapping. Independently, the interface may require the user to employ a controlled language, in which syntax and lexicon are restricted in order to minimise ambiguity with respect to the formal specification language (Macias and Pulman, 1995; Fuchs and Schwitter, 1996; Schwitter and Fuchs, 1996). The design of a controlled language is one method of addressing the key problem pointed out by (1996, p. 235), namely to ensure that English input has a valid translation into the target is the problem that we focus on here. Inevitably, we need to pay some attention to is an action-based branching temporal logic which, despite the name, is not directly related to the CTL language that we discuss below. 451 Figure 1: A CTL structure Figure 2: Computation tree the syntactic and semantic properties of our target formalism and this is the topic of the next section. 2 CTL Specification and Model Checking While early attempts to use temporal logics for verification had explored both linear and branching models of time, Clarke et at. (1986) showed that branching temporal logic CTL Logic) efficient model-checking in of laborious proof construction In models of CTL, the temporal order relation &lt; defines a tree which branches towards the future. As pointed out by Thomason (1984), branching time provides a basis for formalising the intuition that statements of necessity and possibility are often non-trivially tensed. As we move forward through time, certain possible worlds (i.e., paths in the tree) eliminated, and thus what was possible at no available as an option at some than CTL uses formulas beginning with A to express f true at a time in case is true along all paths that branch forward from the at globally). f when, on all true at some time in the future. f at true at the next time point, along paths. Finally, U g] if, for each path, true at some time, and from now until that point true. Figure 1, from Clarke et at. (1986), illustrates a CTL model structure, with the relation &lt; represented by arrows between circles (states), and the atomic propositions holding at a state being the letters contained in the circle. A CTL structure gives rise to an infinite computation tree, and Figure 2 model-checking methods which use linear temporal logic have been developed. While theoretically less efficient that those based on CTL, they may turn out to be effective in practice (Vardi, 1998). shows the initial part of such a tree corresponding to Figure 1, when so is selected as the initial state. States correspond to points of time in the course of a computation, and branches represent non-determinism. Formulas of CTL are either true or false with respect to any given model; see Table 1 for three examples interpreted at so in the Figure 1 structure. 3 Data One of our key tasks has been to collect an initial sample of specifications in English, so as to identify linguistic constructions and usages typical of specification discourse. We currently have a corpus of around a hundred sentences, most of which were elicited by asking suitably qualified respondents to describe the behaviour manifested by timing diagrams. An example of such a diagram is displayed in Figure 3, which is adapted from one of Fisler&apos;s (1996, p. 5). The horizontal axis of the diagram indicates the passing of time (as measured by clock cycles) and the vertical axis indicates the transition of signals between the states of high and low. (A signal is formula sense all paths, at the next true all paths, globally is true for all paths, eventually there is a state from which, for all paths, at true following state true Table 1: Interpretation of CTL formulas true false 452 Figure 3: Timing diagram for pulsing circuit =1 (3) a. Every request is eventually acknowledged and once a request is acknowledged the request is eventually deasserted and eventually after that the acknowledge signal goes low. If then after one cycle eventually and then after one cycle eventually and then after one cycle eventually falls. which can be rendered in CTL as (4). r a Figure 4: Timing diagram for handshaking protocol a time-varying value present at some point in the In Figure 3, the input signal a transition from high to low which after a one-cycle delay triggers a unit-duration pulse on the output (1 a—b) give two possible English descriptions of the regularity illustrated by Figure 3, (1) a. A pulse of width one is generated on the cycle after it detects a falling on input If high and then is low on the next then low and after one cycle becomes high and then after one more cycle becomes low. while (2) is a CTL description. (2) AG(i —&gt; AX(-4 —&gt; (—io A AX(o AAX—io)))) A noteworthy difference between the two English renderings is that the first is clearly more abstract than the second. Description (lb) is closer to the CTL formula (2), and consequently easier to into For another example of the same phenomenon, consider the timing diagram in Figure 4. As before, sentences (3a—b) give two possible English descriptions of the regularity illustrated by Figure 4, system does not yet resolve anaphoric references, as in (la). There are existing English-to-CTL systems which do, however, such as that of Nelken and Francez (1996). —&gt; AF(—.a AX(a A AF(r A AX(—ir A AF(a AAX—a)))))) Example (3b) parallels (lb) in being closer to CTL than its (a) counterpart. Nevertheless, (3b) richer CTL in an important respect, in that it makes reference to the event 4 Defining a Controlled Language Even confining our attention to hardware specifications of the level of complexity examined so far, we can conclude there are some kinds of English locutions which will map rather directly into CTL, whereas others have a much less direct relation. What is the nature of this indirect relation? Our claim in this paper is that we can give semantically-oriented characterisations of the relation between complexity in English sentences and their suitability for inclusion in a controlled language for hardware verification. Moreover, this semantic orientation yields a hierarchy of subsets of English. (This hierarchy is a theoretical entity constructed for our specific purposes, of course, not a general linguistic hypothesis about English.) Our first step in developing an English-to-CTL conversion system was to build a prototype based on the Alvey Natural Language Tools Grammar (Grover et al., 1993). The Alvey grammar is a broad coverage grammar of English using GPSG-style rules, and maps into a event-based, unscoped semantic representation. For this application, we used a highly restricted lexicon and simplified the grammar in a number of ways (for example: fewer coordination rules; no deontic readings of modals). Tidhar (1998) reports an initial experiment in taking the semantic generated from a small set English specifications, and converting it into CTL. Given 453 that the Alvey grammar will produce plausible readings for a much larger set challenge is to characterise an intermediate set S, 5&apos;, that would admit a translation into formulas of CTL. Let&apos;s assume that we have a translation from CTL to English; then would like S = . 4.1 Transliteration suppose that is a from CTL to English. That is, we recurse on the formulas of CTL, choosing a canonical lexical item or phrase in English as a direct counterpart to each constituent of the CTL formula. In fact, we have implemented such a translation as a DCG ct12 eng. To illustrate, c t12 eng maps the formula (2) into (5): globally if high then after 1 cycle if then low and after 1 cycle high after 1 cycle low 1be the function defined by ct12 eng; we call = canonical of English. We can be confident it is possible to build a translation which map any sentence in a formula of CTL. r1 can be trivially augmented by adding near-synonymous lexical and syntactic variants. For is high be replaced by i holds, 1 cycle ... cycle later... . adds no semantic complexity. We call the this language transliteration One potential problem with defining 01 in this way is that the sentences generated by c t 12 eng soon become structurally ambiguous. We can solve this either by generating unambiguous paraphrases, or by analysing the relevant class of ambiguities and sure that is able to provide all relevant CTL interpretations. These languages contain only sentences. Hardware specifications often have the form of multisentence discourses, however. Such discourses, and the additional phenomena they introduce, occur at higher levels of our language hierarchy, and we presently lack any detailed analysis of them in the terms of this paper. 4.2 Compositional indirect semantics We&apos;ll say that an English input expression has indirect just in case 1. there is a compositional mapping to CTL, but where 2. the semantics of the English is ontologically richer than the intended CTL translation. The best way to explain these notions is by way of some examples. First, consider expressions like nouns edge the verbs fall. to certain kinds of event. For example, an denotes the event where a signal changes between distinct states; from high at time low at time or conversely. In CTL, the notion of an edge on approximately to the following v (-i A AX i) a be analysed in terms of a rising edge followed by a falling edge. What do we mean by saying that there is a of locutions at this level to CTL? Our claim is that they can be algorithmically converted into pure CTL without reference to unbounded context. What do we mean by saying that these English expressions involve a richer ontology than CTL? If compositional mapping holds, then clearly we are not forced to augment the standard models for CTL in order to interpret them (although this route might be desirable for other reasons). Rather, we are saying that the &apos;natural&apos; ontology for these expressions is richer than that for CTL, even if reduction is 4.3 Non-compositional indirect semantics consider the conversion to involve nonindirect semantics there is some aspect of non-locality in the domain of the translation function. That is, some form of inference is required—probably involving domain-specific axioms or general temporal axioms—in order to obtain a CTL formula from the English expression. Here are two examples. The first comes from (3a), where the use of normally be taken to correspond directly to the CTL because of the domain of (3a)—a handshaking protocol, evidenced by the use the verbs in fact accurate to require an extra the CTL. in the sense that one cannot simply substitute this expression arbitrarily into a larger formula, as it depends on the syntactic context—for example, whether it occurs in the antecedent or consequent of an implication. is a further kind of ontological richness in English at level, involving the events, rather than the events themselves. Space prohibits a closer examination here. 454 examples i is high; after 1 cycle holds; 1 cyclelater i rises; there is a pulse of unit duration r is eventually acknowledged Table 2: Language hierarchy This ensures that the three transitions cannot occur at the same time. We see here an example of domain-specific interpretation conventions that our system needs to be aware of. Clearly, it must incorporate them in such a way that users are still able to reliably predict how the system will react to their English specifications. The second example is From one cycle after until it changes again x and y are different. In this case there is an interaction between a non-local linguistic phenomenon and something specific to the CTL conversion, namely how to make the right connection between the first and the second changes. hierarchy Table 2 summarises the main proposals of this section. The left-hand column lists the hierarchy of postulated sublanguages, in increasing order of semantic expressiveness. The middle column tries to calibrate this expressiveness. By &apos;extended CTL&apos;, we mean a superset of CTL which is syntactically to allow formulas such p), earlier, and (p , v, n), an atom, v is a Boolean indicating a high or low value, and n is a natural number indicating duration. The semantic clauses would have to be correspondingly augmented—as carried out for by Nelken and Francez (1996), for &apos;full SR&apos;, we are hypothesising that it would be necessary to invoke a general semantic representation language for English. We have constructed a context-free grammar for order to obtain a concrete approximation to a controlled subset of English for expressing specifications. There are two cautionary observations. as just indicated, directly not into CTL, but into extended CTL. Second, our grammar some subtleties of English syntax and morphology. For example, subject-verb agreement; modal auxiliary subcategorisation; varieties of verb phrase modification by adverbs; and forms of anaphora. defects in our CFG for not fundamental problems, however. The device of using the c tl2eng mapping to define a sublanguage is a specific methodology for finding a semantically motivated sublanguage. As such it is only an approximation to the language that we wish our to deal with. This CFG is the grammar used by our parser (which can, in fact, deal with many of the details of English syntax just mentioned). We may, therefore, introduce a which corrects the grammatical errors extends it with some degree of anaphora and ellipsis. We note that it would be useful to have a firmer theoretical grasp on the relations between our sublanguages; we have ongoing work in this area. 5 Conclusion Much work on controlled languages has been motivated by the ambition to &amp;quot;find the right tradeoff between expressiveness and processability&amp;quot; (Schwitter and Fuchs, 1996). An alternative, suggested by what we have proposed here, is to into play a controlled languages, ordered by the degree to which they semantically approximate the target formalism. Each point in the hierarchy brings different trade-offs between expressiveness and tractability, and evaluating their different merits will depend heavily on the particular task within a generic application domain, as well as on the class of users. As a final remark, we wish to point out that there may be advantages in identifying plausible restrictions on the target formalism. Dwyer et al. (1998a; 1998b) have convincingly argued that users of formal verification languages make use recurring patterns. is, rather than drawing on the full complexity of languages such as CTL, documented specifications tend to fall into much simpler formulations which express commonly desired properties. In future work, we plan to investigate specification patterns as a further source of constraints that propagate backwards into the controlled English, perhaps providing additional mechanisms for dealing with apparent ambiguity in user input. Li CTL pure CTL CTL SR? 455 Acknowledgements The work reported here has been carried out as part of PROSPER (Proof and Specification Assisted Design Environments), ESPRIT Framework IV LTR //www.dcs .gla .ac .uk/prosper/.</abstract>
<note confidence="0.937616846153846">Thanks to Marc Moens, Claire Grover, Mike Fourman, Dirk Hoffman, Tom Melham, Thomas Kropf, Mike Gordon, and our ACL reviewers. References Alshawi, editor. 1992. Core Language Press. Edmund M. Clarke and E. Allen Emerson. 1981. Synthesis of synchronization skeletons branching time temporal logic. In of Programs: Workshop, Yorktown Heights, NY, 1981, 131 of Notes in Science. Edmund M. Clarke and Jeanette M. Wing. 1996.</note>
<title confidence="0.8459925">Formal methods: State of the art and future direc- Computing Surveys,</title>
<author confidence="0.992664">Edmund M Clarke</author>
<author confidence="0.992664">E Allen Emerson</author>
<abstract confidence="0.573997222222222">A. Prasad Sistla. 1986. Automatic verification of finite-state concurrent systems using tempologic specifications. Transactions on Languages and Systems, 8(2):244- 263. Matthew B. Dwyer, George S. Avrunin, and James C. Corbett. 1998a. Patterns in property specifications for finite-state verification. Technical Report KSU CIS TR-98-9, Department of</abstract>
<affiliation confidence="0.909061">Computing and Information Sciences, Kansas State University.</affiliation>
<author confidence="0.586160666666667">b Property specification patterns for finite-state verification In M Ardis</author>
<note confidence="0.823974">of the Second Workshop on Methods in Software Practice, 7-15. A. Fantechi, S. Gnesi, G. Ristori, M. Carenini, M. Marino, and P. Moreschini. 1994. Assisting requirement formalization by means of natural</note>
<title confidence="0.525532">translation. Methods in System</title>
<author confidence="0.483724">A Approach to Hard-</author>
<affiliation confidence="0.515529333333333">ware Verification through a Heterogeneous Logic Design Diagrams. thesis, Department of Computer Science, Indiana University.</affiliation>
<note confidence="0.793999909090909">Norbert E. Fuchs and Rolf Schwitter. 1996. Controlled English (ACE). In 96: First International Workshop on Controlled Applications. for Computational Linguistics, Katholieke Universiteit Leuven, Belgium. Claire Grover, John Carroll, and Ted Briscoe. 1993. The Alvey Natural Language Tools Grammar (4th release). Technical Report 284, Computer Laboratory, University of Cambridge. Kamp and Uwe Reyle. 1993. Discourse</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<title>The Core Language Engine.</title>
<date>1992</date>
<editor>Hiyan Alshawi, editor.</editor>
<publisher>MIT Press.</publisher>
<marker>1992</marker>
<rawString>Hiyan Alshawi, editor. 1992. The Core Language Engine. MIT Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Edmund M Clarke</author>
<author>E Allen Emerson</author>
</authors>
<title>Synthesis of synchronization skeletons for branching time temporal logic.</title>
<date>1981</date>
<booktitle>In Logic of Programs: Workshop,</booktitle>
<volume>131</volume>
<publisher>Springer-Verlag.</publisher>
<location>Yorktown Heights, NY,</location>
<contexts>
<context position="1215" citStr="Clarke and Emerson, 1981" startWordPosition="173" endWordPosition="176">ds potential difficulties with approaches that take existing computational semantic analyses of English as their starting point—such as the need to ensure that all sentences in the subset possess a CTL translation. 1 Specifications in Natural Language Mechanised formal specification and verification tools can significantly aid system design in both software and hardware (Clarke and Wing, 1996). One well-established approach to verification, particularly of hardware and protocols, is temporal model checking, which allows the designer to check that certain desired properties hold of the system (Clarke and Emerson, 1981). In this approach, specifications are expressed in a temporal logic and systems are represented as finite state transition systems.&apos; An efficient search method determines whether the desired property is true in the model provided by the transition system; if not, it provides a counterexample. Despite the undoubted success of temporal model checking as a technique, the requirement that specifications be expressed in temporal logic has proved an obstacle to its take-up by circuit designers and therefore alternative interfaces involving graphics and natural language have been explored. In this p</context>
</contexts>
<marker>Clarke, Emerson, 1981</marker>
<rawString>Edmund M. Clarke and E. Allen Emerson. 1981. Synthesis of synchronization skeletons for branching time temporal logic. In Logic of Programs: Workshop, Yorktown Heights, NY, May 1981, volume 131 of Lecture Notes in Computer Science. Springer-Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Edmund M Clarke</author>
<author>Jeanette M Wing</author>
</authors>
<title>Formal methods: State of the art and future directions.</title>
<date>1996</date>
<journal>ACM Computing Surveys,</journal>
<pages>28--4</pages>
<contexts>
<context position="986" citStr="Clarke and Wing, 1996" startWordPosition="140" endWordPosition="143">conversion of English to CTL requires the definition of an appropriately restricted subset of English. We show how the limited semantic expressibility of CTL can be exploited to derive a hierarchy of subsets. Our strategy avoids potential difficulties with approaches that take existing computational semantic analyses of English as their starting point—such as the need to ensure that all sentences in the subset possess a CTL translation. 1 Specifications in Natural Language Mechanised formal specification and verification tools can significantly aid system design in both software and hardware (Clarke and Wing, 1996). One well-established approach to verification, particularly of hardware and protocols, is temporal model checking, which allows the designer to check that certain desired properties hold of the system (Clarke and Emerson, 1981). In this approach, specifications are expressed in a temporal logic and systems are represented as finite state transition systems.&apos; An efficient search method determines whether the desired property is true in the model provided by the transition system; if not, it provides a counterexample. Despite the undoubted success of temporal model checking as a technique, the</context>
</contexts>
<marker>Clarke, Wing, 1996</marker>
<rawString>Edmund M. Clarke and Jeanette M. Wing. 1996. Formal methods: State of the art and future directions. ACM Computing Surveys, 28(4):626-643.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Edmund M Clarke</author>
<author>E Allen Emerson</author>
<author>A Prasad Sistla</author>
</authors>
<title>Automatic verification of finite-state concurrent systems using temporal logic specifications.</title>
<date>1986</date>
<journal>ACM Transactions on Programming Languages and Systems,</journal>
<pages>8--2</pages>
<marker>Clarke, Emerson, Sistla, 1986</marker>
<rawString>Edmund M. Clarke, E. Allen Emerson, and A. Prasad Sistla. 1986. Automatic verification of finite-state concurrent systems using temporal logic specifications. ACM Transactions on Programming Languages and Systems, 8(2):244-263.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Matthew B Dwyer</author>
<author>George S Avrunin</author>
<author>James C Corbett</author>
</authors>
<title>Patterns in property specifications for finite-state verification.</title>
<date>1998</date>
<tech>Technical Report KSU CIS TR-98-9,</tech>
<institution>Department of Computing and Information Sciences, Kansas State University.</institution>
<contexts>
<context position="18797" citStr="Dwyer et al. (1998" startWordPosition="3086" endWordPosition="3089">r and Fuchs, 1996). An alternative, suggested by what we have proposed here, is to bring into play a hierarchy of controlled languages, ordered by the degree to which they semantically approximate the target formalism. Each point in the hierarchy brings different trade-offs between expressiveness and tractability, and evaluating their different merits will depend heavily on the particular task within a generic application domain, as well as on the class of users. As a final remark, we wish to point out that there may be advantages in identifying plausible restrictions on the target formalism. Dwyer et al. (1998a; 1998b) have convincingly argued that users of formal verification languages make use of recurring specification patterns. That is, rather than drawing on the full complexity of languages such as CTL, documented specifications tend to fall into much simpler formulations which express commonly desired properties. In future work, we plan to investigate specification patterns as a further source of constraints that propagate backwards into the controlled English, perhaps providing additional mechanisms for dealing with apparent ambiguity in user input. level expressiveness Li pure CTL pure CTL </context>
</contexts>
<marker>Dwyer, Avrunin, Corbett, 1998</marker>
<rawString>Matthew B. Dwyer, George S. Avrunin, and James C. Corbett. 1998a. Patterns in property specifications for finite-state verification. Technical Report KSU CIS TR-98-9, Department of Computing and Information Sciences, Kansas State University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Matthew B Dwyer</author>
<author>George S Avrunin</author>
<author>James C Corbett</author>
</authors>
<title>Property specification patterns for finite-state verification.</title>
<date>1998</date>
<booktitle>Proceedings of the Second Workshop on Formal Methods in Software Practice,</booktitle>
<pages>7--15</pages>
<editor>In M. Ardis, editor,</editor>
<contexts>
<context position="18797" citStr="Dwyer et al. (1998" startWordPosition="3086" endWordPosition="3089">r and Fuchs, 1996). An alternative, suggested by what we have proposed here, is to bring into play a hierarchy of controlled languages, ordered by the degree to which they semantically approximate the target formalism. Each point in the hierarchy brings different trade-offs between expressiveness and tractability, and evaluating their different merits will depend heavily on the particular task within a generic application domain, as well as on the class of users. As a final remark, we wish to point out that there may be advantages in identifying plausible restrictions on the target formalism. Dwyer et al. (1998a; 1998b) have convincingly argued that users of formal verification languages make use of recurring specification patterns. That is, rather than drawing on the full complexity of languages such as CTL, documented specifications tend to fall into much simpler formulations which express commonly desired properties. In future work, we plan to investigate specification patterns as a further source of constraints that propagate backwards into the controlled English, perhaps providing additional mechanisms for dealing with apparent ambiguity in user input. level expressiveness Li pure CTL pure CTL </context>
</contexts>
<marker>Dwyer, Avrunin, Corbett, 1998</marker>
<rawString>Matthew B. Dwyer, George S. Avrunin, and James C. Corbett. 1998b. Property specification patterns for finite-state verification. In M. Ardis, editor, Proceedings of the Second Workshop on Formal Methods in Software Practice, pages 7-15.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Fantechi</author>
<author>S Gnesi</author>
<author>G Ristori</author>
<author>M Carenini</author>
<author>M Marino</author>
<author>P Moreschini</author>
</authors>
<title>Assisting requirement formalization by means of natural language translation.</title>
<date>1994</date>
<booktitle>Formal Methods in System Design,</booktitle>
<pages>4--243</pages>
<contexts>
<context position="3011" citStr="Fantechi et al. (1994)" startWordPosition="436" endWordPosition="439">l specifications in some target formalism (Fuchs and Schwitter, 1996; Schwitter and Fuchs, 1996; Pulman, 1996; Nelken and Francez, 1996). English input sentences are initially mapped into a general purpose semantic formalism such as Discourse Representation Theory (Kamp and Reyle, 1993) or the Core Language Engine&apos;s quasi logical form (Alshawi, 1992) at which point context dependencies are resolved. The output of this stage then undergoes a further mapping into the application-specific language which expresses formal specifications. One system which departs from this framework is presented by Fantechi et al. (1994), whose grammar contains special purpose rules for recognising constructions that map directly into ACTL formulas,2 and can trigger clarification dialogues with the user in the case of a one-to-many mapping. Independently, the interface may require the user to employ a controlled language, in which syntax and lexicon are restricted in order to minimise ambiguity with respect to the formal specification language (Macias and Pulman, 1995; Fuchs and Schwitter, 1996; Schwitter and Fuchs, 1996). The design of a controlled language is one method of addressing the key problem pointed out by Pulman (1</context>
</contexts>
<marker>Fantechi, Gnesi, Ristori, Carenini, Marino, Moreschini, 1994</marker>
<rawString>A. Fantechi, S. Gnesi, G. Ristori, M. Carenini, M. Marino, and P. Moreschini. 1994. Assisting requirement formalization by means of natural language translation. Formal Methods in System Design, 4:243-263.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kathryn Fisler</author>
</authors>
<title>A Unified Approach to Hardware Verification through a Heterogeneous Logic of Design Diagrams.</title>
<date>1996</date>
<tech>Ph.D. thesis,</tech>
<institution>Department of Computer Science, Indiana University.</institution>
<marker>Fisler, 1996</marker>
<rawString>Kathryn Fisler. 1996. A Unified Approach to Hardware Verification through a Heterogeneous Logic of Design Diagrams. Ph.D. thesis, Department of Computer Science, Indiana University.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Norbert E Fuchs</author>
<author>Rolf Schwitter</author>
</authors>
<title>Attempto Controlled English (ACE).</title>
<date>1996</date>
<booktitle>In CLAW 96: First International Workshop on Controlled Language Applications. Centre for Computational Linguistics,</booktitle>
<institution>Katholieke Universiteit Leuven, Belgium.</institution>
<contexts>
<context position="2457" citStr="Fuchs and Schwitter, 1996" startWordPosition="356" endWordPosition="359">some of the challenges raised by converting 1In practice, it turns out to be preferable to use a symbolic representation of the state model, thereby avoiding the state explosion problem (Macmillan, 1993). English specifications into temporal logic as a prelude to hardware verification. One general approach to this kind of task exploits existing results in the computational analysis of natural language semantics, including contextual phenomena such as anaphora and ellipsis, in order to bridge the gap between informal specifications in English and formal specifications in some target formalism (Fuchs and Schwitter, 1996; Schwitter and Fuchs, 1996; Pulman, 1996; Nelken and Francez, 1996). English input sentences are initially mapped into a general purpose semantic formalism such as Discourse Representation Theory (Kamp and Reyle, 1993) or the Core Language Engine&apos;s quasi logical form (Alshawi, 1992) at which point context dependencies are resolved. The output of this stage then undergoes a further mapping into the application-specific language which expresses formal specifications. One system which departs from this framework is presented by Fantechi et al. (1994), whose grammar contains special purpose rules</context>
</contexts>
<marker>Fuchs, Schwitter, 1996</marker>
<rawString>Norbert E. Fuchs and Rolf Schwitter. 1996. Attempto Controlled English (ACE). In CLAW 96: First International Workshop on Controlled Language Applications. Centre for Computational Linguistics, Katholieke Universiteit Leuven, Belgium.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Claire Grover</author>
<author>John Carroll</author>
<author>Ted Briscoe</author>
</authors>
<title>The Alvey Natural Language Tools Grammar (4th release).</title>
<date>1993</date>
<tech>Technical Report 284,</tech>
<institution>Computer Laboratory, University of Cambridge.</institution>
<contexts>
<context position="10079" citStr="Grover et al., 1993" startWordPosition="1637" endWordPosition="1640"> relation? Our claim in this paper is that we can give semantically-oriented characterisations of the relation between complexity in English sentences and their suitability for inclusion in a controlled language for hardware verification. Moreover, this semantic orientation yields a hierarchy of subsets of English. (This hierarchy is a theoretical entity constructed for our specific purposes, of course, not a general linguistic hypothesis about English.) Our first step in developing an English-to-CTL conversion system was to build a prototype based on the Alvey Natural Language Tools Grammar (Grover et al., 1993). The Alvey grammar is a broad coverage grammar of English using GPSG-style rules, and maps into a event-based, unscoped semantic representation. For this application, we used a highly restricted lexicon and simplified the grammar in a number of ways (for example: fewer coordination rules; no deontic readings of modals). Tidhar (1998) reports an initial experiment in taking the semantic output generated from a small set S of English specifications, and converting it into CTL. Given 453 that the Alvey grammar will produce plausible semantic readings for a much larger set S&apos;, the challenge is to</context>
</contexts>
<marker>Grover, Carroll, Briscoe, 1993</marker>
<rawString>Claire Grover, John Carroll, and Ted Briscoe. 1993. The Alvey Natural Language Tools Grammar (4th release). Technical Report 284, Computer Laboratory, University of Cambridge.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hans Kamp</author>
<author>Uwe Reyle</author>
</authors>
<title>From Discourse to Logic: Introduction to Modeltheoretic Semantics of Natural Language, Formal Logic and Discourse Representation Theory.</title>
<date>1993</date>
<journal>Number</journal>
<booktitle>in Studies in Linguistics and Philosophy.</booktitle>
<volume>42</volume>
<publisher>Kluwer.</publisher>
<contexts>
<context position="2676" citStr="Kamp and Reyle, 1993" startWordPosition="387" endWordPosition="390">ions into temporal logic as a prelude to hardware verification. One general approach to this kind of task exploits existing results in the computational analysis of natural language semantics, including contextual phenomena such as anaphora and ellipsis, in order to bridge the gap between informal specifications in English and formal specifications in some target formalism (Fuchs and Schwitter, 1996; Schwitter and Fuchs, 1996; Pulman, 1996; Nelken and Francez, 1996). English input sentences are initially mapped into a general purpose semantic formalism such as Discourse Representation Theory (Kamp and Reyle, 1993) or the Core Language Engine&apos;s quasi logical form (Alshawi, 1992) at which point context dependencies are resolved. The output of this stage then undergoes a further mapping into the application-specific language which expresses formal specifications. One system which departs from this framework is presented by Fantechi et al. (1994), whose grammar contains special purpose rules for recognising constructions that map directly into ACTL formulas,2 and can trigger clarification dialogues with the user in the case of a one-to-many mapping. Independently, the interface may require the user to empl</context>
</contexts>
<marker>Kamp, Reyle, 1993</marker>
<rawString>Hans Kamp and Uwe Reyle. 1993. From Discourse to Logic: Introduction to Modeltheoretic Semantics of Natural Language, Formal Logic and Discourse Representation Theory. Number 42 in Studies in Linguistics and Philosophy. Kluwer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Benjamin Macias</author>
<author>Stephen G Pulman</author>
</authors>
<title>A method for controlling the production of specifications in natural language.</title>
<date>1995</date>
<journal>The Computer Journal,</journal>
<pages>38--4</pages>
<contexts>
<context position="3450" citStr="Macias and Pulman, 1995" startWordPosition="501" endWordPosition="504">goes a further mapping into the application-specific language which expresses formal specifications. One system which departs from this framework is presented by Fantechi et al. (1994), whose grammar contains special purpose rules for recognising constructions that map directly into ACTL formulas,2 and can trigger clarification dialogues with the user in the case of a one-to-many mapping. Independently, the interface may require the user to employ a controlled language, in which syntax and lexicon are restricted in order to minimise ambiguity with respect to the formal specification language (Macias and Pulman, 1995; Fuchs and Schwitter, 1996; Schwitter and Fuchs, 1996). The design of a controlled language is one method of addressing the key problem pointed out by Pulman (1996, p. 235), namely to ensure that an English input has a valid translation into the target formalism; this is the problem that we focus on here. Inevitably, we need to pay some attention to 2ACTL is an action-based branching temporal logic which, despite the name, is not directly related to the CTL language that we discuss below. 451 Figure 1: A CTL structure Figure 2: Computation tree the syntactic and semantic properties of our tar</context>
</contexts>
<marker>Macias, Pulman, 1995</marker>
<rawString>Benjamin Macias and Stephen G. Pulman. 1995. A method for controlling the production of specifications in natural language. The Computer Journal, 38(4):310-318.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenneth L Macmillan</author>
</authors>
<title>Symbolic Model Checking.</title>
<date>1993</date>
<publisher>Kluwer.</publisher>
<contexts>
<context position="2035" citStr="Macmillan, 1993" startWordPosition="298" endWordPosition="299">true in the model provided by the transition system; if not, it provides a counterexample. Despite the undoubted success of temporal model checking as a technique, the requirement that specifications be expressed in temporal logic has proved an obstacle to its take-up by circuit designers and therefore alternative interfaces involving graphics and natural language have been explored. In this paper, we address some of the challenges raised by converting 1In practice, it turns out to be preferable to use a symbolic representation of the state model, thereby avoiding the state explosion problem (Macmillan, 1993). English specifications into temporal logic as a prelude to hardware verification. One general approach to this kind of task exploits existing results in the computational analysis of natural language semantics, including contextual phenomena such as anaphora and ellipsis, in order to bridge the gap between informal specifications in English and formal specifications in some target formalism (Fuchs and Schwitter, 1996; Schwitter and Fuchs, 1996; Pulman, 1996; Nelken and Francez, 1996). English input sentences are initially mapped into a general purpose semantic formalism such as Discourse Rep</context>
</contexts>
<marker>Macmillan, 1993</marker>
<rawString>Kenneth L. Macmillan. 1993. Symbolic Model Checking. Kluwer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Rani Nelken</author>
<author>Nissim Francez</author>
</authors>
<title>Translating natural language system specifications into temporal logic via DRT.</title>
<date>1996</date>
<tech>Technical Report LCL96-2,</tech>
<institution>Laboratory for Computational Linguistics, Technion, Israel Institute of Technology.</institution>
<contexts>
<context position="2525" citStr="Nelken and Francez, 1996" startWordPosition="366" endWordPosition="369">ut to be preferable to use a symbolic representation of the state model, thereby avoiding the state explosion problem (Macmillan, 1993). English specifications into temporal logic as a prelude to hardware verification. One general approach to this kind of task exploits existing results in the computational analysis of natural language semantics, including contextual phenomena such as anaphora and ellipsis, in order to bridge the gap between informal specifications in English and formal specifications in some target formalism (Fuchs and Schwitter, 1996; Schwitter and Fuchs, 1996; Pulman, 1996; Nelken and Francez, 1996). English input sentences are initially mapped into a general purpose semantic formalism such as Discourse Representation Theory (Kamp and Reyle, 1993) or the Core Language Engine&apos;s quasi logical form (Alshawi, 1992) at which point context dependencies are resolved. The output of this stage then undergoes a further mapping into the application-specific language which expresses formal specifications. One system which departs from this framework is presented by Fantechi et al. (1994), whose grammar contains special purpose rules for recognising constructions that map directly into ACTL formulas,</context>
<context position="8854" citStr="Nelken and Francez (1996)" startWordPosition="1444" endWordPosition="1447">2) AG(i —&gt; AX(-4 —&gt; (—io A AX(o AAX—io)))) A noteworthy difference between the two English renderings is that the first is clearly more abstract than the second. Description (lb) is closer to the CTL formula (2), and consequently easier to translate into CTL.4 For another example of the same phenomenon, consider the timing diagram in Figure 4. As before, sentences (3a—b) give two possible English descriptions of the regularity illustrated by Figure 4, 4Our system does not yet resolve anaphoric references, as in (la). There are existing English-to-CTL systems which do, however, such as that of Nelken and Francez (1996). (4) AG(—&apos;r A AXr —&gt; AF(—.a AX(a A AF(r A AX(—ir A AF(a AAX—a)))))) Example (3b) parallels (lb) in being closer to CTL than its (a) counterpart. Nevertheless, (3b) is ontologically richer than CTL in an important respect, in that it makes reference to the event predicates rise and fall. 4 Defining a Controlled Language Even confining our attention to hardware specifications of the level of complexity examined so far, we can conclude there are some kinds of English locutions which will map rather directly into CTL, whereas others have a much less direct relation. What is the nature of this ind</context>
<context position="16625" citStr="Nelken and Francez (1996)" startWordPosition="2738" endWordPosition="2741">le 2 summarises the main proposals of this section. The left-hand column lists the hierarchy of postulated sublanguages, in increasing order of semantic expressiveness. The middle column tries to calibrate this expressiveness. By &apos;extended CTL&apos;, we mean a superset of CTL which is syntactically augmented to allow formulas such ,as rise(p), fall( p), discussed earlier, and pulse (p , v, n), where p is an atom, v is a Boolean indicating a high or low value, and n is a natural number indicating duration. The semantic clauses would have to be correspondingly augmented—as carried out for example by Nelken and Francez (1996), for rise(p) and fall(p). By &apos;full SR&apos;, we are hypothesising that it would be necessary to invoke a general semantic representation language for English. We have constructed a context-free grammar for £2, in order to obtain a concrete approximation to a controlled subset of English for expressing specifications. There are two cautionary observations. First, as just indicated, £2 maps directly not into CTL, but into extended CTL. Second, our grammar for £2 ignores some subtleties of English syntax and morphology. For example, subject-verb agreement; modal auxiliary subcategorisation; varieties</context>
</contexts>
<marker>Nelken, Francez, 1996</marker>
<rawString>Rani Nelken and Nissim Francez. 1996. Translating natural language system specifications into temporal logic via DRT. Technical Report LCL96-2, Laboratory for Computational Linguistics, Technion, Israel Institute of Technology.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stephen G Pulman</author>
</authors>
<title>Controlled language for knowledge representation. In</title>
<date>1996</date>
<booktitle>CLAW 96: Proceedings of the First International Workshop on Controlled Language Applications,</booktitle>
<pages>233--242</pages>
<institution>Centre for Computational Linguistics, Katholieke Universiteit Leuven, Belgium.</institution>
<contexts>
<context position="2498" citStr="Pulman, 1996" startWordPosition="364" endWordPosition="365">ce, it turns out to be preferable to use a symbolic representation of the state model, thereby avoiding the state explosion problem (Macmillan, 1993). English specifications into temporal logic as a prelude to hardware verification. One general approach to this kind of task exploits existing results in the computational analysis of natural language semantics, including contextual phenomena such as anaphora and ellipsis, in order to bridge the gap between informal specifications in English and formal specifications in some target formalism (Fuchs and Schwitter, 1996; Schwitter and Fuchs, 1996; Pulman, 1996; Nelken and Francez, 1996). English input sentences are initially mapped into a general purpose semantic formalism such as Discourse Representation Theory (Kamp and Reyle, 1993) or the Core Language Engine&apos;s quasi logical form (Alshawi, 1992) at which point context dependencies are resolved. The output of this stage then undergoes a further mapping into the application-specific language which expresses formal specifications. One system which departs from this framework is presented by Fantechi et al. (1994), whose grammar contains special purpose rules for recognising constructions that map d</context>
</contexts>
<marker>Pulman, 1996</marker>
<rawString>Stephen G. Pulman. 1996. Controlled language for knowledge representation. In CLAW 96: Proceedings of the First International Workshop on Controlled Language Applications, pages 233-242. Centre for Computational Linguistics, Katholieke Universiteit Leuven, Belgium.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Rolf Schwitter</author>
<author>Norbert E Fuchs</author>
</authors>
<title>Attempto — from specifications in controlled natural language towards executable specifications.</title>
<date>1996</date>
<booktitle>In GI EMISA Workshop. Natiirlichsprachlicher Entwurf von Informations-systemen,</booktitle>
<location>Tutzing, Germany.</location>
<contexts>
<context position="2484" citStr="Schwitter and Fuchs, 1996" startWordPosition="360" endWordPosition="363">ed by converting 1In practice, it turns out to be preferable to use a symbolic representation of the state model, thereby avoiding the state explosion problem (Macmillan, 1993). English specifications into temporal logic as a prelude to hardware verification. One general approach to this kind of task exploits existing results in the computational analysis of natural language semantics, including contextual phenomena such as anaphora and ellipsis, in order to bridge the gap between informal specifications in English and formal specifications in some target formalism (Fuchs and Schwitter, 1996; Schwitter and Fuchs, 1996; Pulman, 1996; Nelken and Francez, 1996). English input sentences are initially mapped into a general purpose semantic formalism such as Discourse Representation Theory (Kamp and Reyle, 1993) or the Core Language Engine&apos;s quasi logical form (Alshawi, 1992) at which point context dependencies are resolved. The output of this stage then undergoes a further mapping into the application-specific language which expresses formal specifications. One system which departs from this framework is presented by Fantechi et al. (1994), whose grammar contains special purpose rules for recognising constructi</context>
<context position="18197" citStr="Schwitter and Fuchs, 1996" startWordPosition="2991" endWordPosition="2994">system to deal with. This CFG is not the grammar used by our parser (which can, in fact, deal with many of the details of English syntax just mentioned). We may, therefore, introduce a language .C1- which corrects the grammatical errors of £2 and extends it with some degree of anaphora and ellipsis. We note that it would be useful to have a firmer theoretical grasp on the relations between our sublanguages; we have ongoing work in this area. 5 Conclusion Much work on controlled languages has been motivated by the ambition to &amp;quot;find the right tradeoff between expressiveness and processability&amp;quot; (Schwitter and Fuchs, 1996). An alternative, suggested by what we have proposed here, is to bring into play a hierarchy of controlled languages, ordered by the degree to which they semantically approximate the target formalism. Each point in the hierarchy brings different trade-offs between expressiveness and tractability, and evaluating their different merits will depend heavily on the particular task within a generic application domain, as well as on the class of users. As a final remark, we wish to point out that there may be advantages in identifying plausible restrictions on the target formalism. Dwyer et al. (1998</context>
</contexts>
<marker>Schwitter, Fuchs, 1996</marker>
<rawString>Rolf Schwitter and Norbert E. Fuchs. 1996. Attempto — from specifications in controlled natural language towards executable specifications. In GI EMISA Workshop. Natiirlichsprachlicher Entwurf von Informations-systemen, Tutzing, Germany.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Richmond H Thomason</author>
</authors>
<title>Combinations of tense and modality.</title>
<date>1984</date>
<booktitle>Handbook of Philosophical Logic. Volume II: Extensions of Classical Logic, volume 146 of Synthese Library, chapter 11.3,</booktitle>
<pages>89--134</pages>
<editor>In D. Gabbay and F. Guenthner, editors,</editor>
<contexts>
<context position="4568" citStr="Thomason (1984)" startWordPosition="686" endWordPosition="687">re 1: A CTL structure Figure 2: Computation tree the syntactic and semantic properties of our target formalism and this is the topic of the next section. 2 CTL Specification and Model Checking While early attempts to use temporal logics for verification had explored both linear and branching models of time, Clarke et at. (1986) showed that the branching temporal logic CTL (Computation Tree Logic) allowed efficient model-checking in place of laborious proof construction methods.3 In models of CTL, the temporal order relation &lt; defines a tree which branches towards the future. As pointed out by Thomason (1984), branching time provides a basis for formalising the intuition that statements of necessity and possibility are often non-trivially tensed. As we move forward through time, certain possible worlds (i.e., paths in the tree) are eliminated, and thus what was possible at t is no longer available as an option at some t&apos; later than t. CTL uses formulas beginning with A to express necessity. AG f is true at a time t just in case f is true along all paths that branch forward from the tree at t (true globally). AF f holds when, on all paths, f is true at some time in the future. AX f is true at t whe</context>
</contexts>
<marker>Thomason, 1984</marker>
<rawString>Richmond H. Thomason. 1984. Combinations of tense and modality. In D. Gabbay and F. Guenthner, editors, Handbook of Philosophical Logic. Volume II: Extensions of Classical Logic, volume 146 of Synthese Library, chapter 11.3, pages 89-134. D. Reidel.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dan Tidhar</author>
</authors>
<title>ALVEY to CTL translation — A preparatory study for finite-state verification natural language interface.</title>
<date>1998</date>
<institution>Department of Linguistics, University of Edinburgh.</institution>
<note>Msc dissertation,</note>
<contexts>
<context position="10415" citStr="Tidhar (1998)" startWordPosition="1690" endWordPosition="1691">etical entity constructed for our specific purposes, of course, not a general linguistic hypothesis about English.) Our first step in developing an English-to-CTL conversion system was to build a prototype based on the Alvey Natural Language Tools Grammar (Grover et al., 1993). The Alvey grammar is a broad coverage grammar of English using GPSG-style rules, and maps into a event-based, unscoped semantic representation. For this application, we used a highly restricted lexicon and simplified the grammar in a number of ways (for example: fewer coordination rules; no deontic readings of modals). Tidhar (1998) reports an initial experiment in taking the semantic output generated from a small set S of English specifications, and converting it into CTL. Given 453 that the Alvey grammar will produce plausible semantic readings for a much larger set S&apos;, the challenge is to characterise an intermediate set S, with S CSC 5&apos;, that would admit a translation into formulas of CTL. Let&apos;s assume that we have a reverse translation 0-1 from CTL to English; then we would like S = range (0-1) . 4.1 Transliteration Now suppose that 0-1 is a literal translation from CTL to English. That is, we recurse on the formula</context>
</contexts>
<marker>Tidhar, 1998</marker>
<rawString>Dan Tidhar. 1998. ALVEY to CTL translation — A preparatory study for finite-state verification natural language interface. Msc dissertation, Department of Linguistics, University of Edinburgh.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Moshe Y Vardi</author>
</authors>
<title>Linear vs. branching time: A complexity-theoretic perspective.</title>
<date>1998</date>
<booktitle>In LICS&apos;98: Proceedings of the Annual IEEE Symposium on Logic in Computer</booktitle>
<institution>Science. Indiana University.</institution>
<contexts>
<context position="5842" citStr="Vardi, 1998" startWordPosition="916" endWordPosition="917">A[f U g] holds if, for each path, g is true at some time, and from now until that point f is true. Figure 1, from Clarke et at. (1986), illustrates a CTL model structure, with the relation &lt; represented by arrows between circles (states), and the atomic propositions holding at a state being the letters contained in the circle. A CTL structure gives rise to an infinite computation tree, and Figure 2 3Subsequently, model-checking methods which use linear temporal logic have been developed. While theoretically less efficient that those based on CTL, they may turn out to be effective in practice (Vardi, 1998). shows the initial part of such a tree corresponding to Figure 1, when so is selected as the initial state. States correspond to points of time in the course of a computation, and branches represent non-determinism. Formulas of CTL are either true or false with respect to any given model; see Table 1 for three examples interpreted at so in the Figure 1 structure. 3 Data One of our key tasks has been to collect an initial sample of specifications in English, so as to identify linguistic constructions and usages typical of specification discourse. We currently have a corpus of around a hundred </context>
</contexts>
<marker>Vardi, 1998</marker>
<rawString>Moshe Y. Vardi. 1998. Linear vs. branching time: A complexity-theoretic perspective. In LICS&apos;98: Proceedings of the Annual IEEE Symposium on Logic in Computer Science. Indiana University.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>