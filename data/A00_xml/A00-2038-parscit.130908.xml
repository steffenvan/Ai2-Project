<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000039">
<title confidence="0.998766">
A New Algorithm for the Alignment of Phonetic Sequences
</title>
<author confidence="0.995355">
Grzegorz Kondrak
</author>
<affiliation confidence="0.894351666666667">
Department of Computer Science
University of Toronto
Toronto, Ontario, Canada M5S 304
</affiliation>
<email confidence="0.99742">
kondrak@cs.toronto.edu
</email>
<sectionHeader confidence="0.993881" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9990079">
Alignment of phonetic sequences is a necessary
step in many applications in computational phonol-
ogy. After discussing various approaches to pho-
netic alignment, I present a new algorithm that com-
bines a number of techniques developed for se-
quence comparison with a scoring scheme for com-
puting phonetic similarity on the basis of multival-
ued features. The algorithm performs better on cog-
nate alignment, in terms of accuracy and efficiency,
than other algorithms reported in the literature.
</bodyText>
<sectionHeader confidence="0.998798" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999679">
Identification of the corresponding segments in se-
quences of phones is a necessary step in many appli-
cations in both diachronic and synchronic phonol-
ogy. Usually we are interested in aligning sequences
that represent forms that are related in some way:
a pair of cognates, or the underlying and the sur-
face forms of a word, or the intended and the ac-
tual pronunciations of a word. Alignment of pho-
netic sequences presupposes transcription of sounds
into discrete phonetic segments, and so differs from
matching of utterances in speech recognition. On
the other hand, it has much in common with the
alignment of proteins and DNA sequences. Many
methods developed for molecular biology can be
adapted to perform accurate phonetic alignment.
Alignment algorithms usually contain two main
components: a metric for measuring distance be-
tween phones, and a procedure for finding the op-
timal alignment. The former is often calculated on
the basis of phonological features that encode cer-
tain properties of phones. An obvious candidate for
the latter is a well-known dynamic programming
(DP) algorithm for string alignment (Wagner and
Fischer, 1974), although other algorithms can used
as well. The task of finding the optimal alignment is
closely linked to the task of calculating the distance
between two sequences. The basic DP algorithm
accomplishes both tasks. Depending on the appli-
cation, either of the results, or both, can be used.
Within the last few years, several different ap-
proaches to phonetic alignment have been reported.
Covington (1996) used depth-first search and a spe-
cial distance function to align words for histori-
cal comparison. In a follow-up paper (Covington,
1998), he extended the algorithm to align words
from more than two languages. Somers (1998) pro-
posed a special algorithm for aligning children&apos;s ar-
ticulation data with the adult model. Gildea and Ju-
rafsky (1996) applied the DP algorithm to pre-align
input and output phonetic strings in order to im-
prove the performance of their transducer induction
system. Nerbonne and Heeringa (1997) employed a
similar procedure to compute relative distance be-
tween words from various Dutch dialects. Some
characteristics of these implementations are juxta-
posed in Table 1.
In this paper, I present a new algorithm for the
alignment of cognates. It combines various tech-
niques developed for sequence comparison with an
appropriate scoring scheme for computing phonetic
similarity on the basis of multivalued features. The
new algorithm performs better, in terms of accuracy
and efficiency, than comparable algorithms reported
by Covington (1996) and Somers (1999). Although
the main focus of this paper is diachronic phonol-
ogy, the techniques proposed here can also be ap-
plied in other contexts where it is necessary to align
phonetic sequences.
</bodyText>
<sectionHeader confidence="0.982644" genericHeader="method">
2 Comparing Phones
</sectionHeader>
<bodyText confidence="0.999883857142857">
To align phonetic sequences, we first need a func-
tion for calculating the distance between individual
phones. The numerical value assigned by the func-
tion to a pair of segments is referred to as the cost,
or penalty, of substitution. The function is often ex-
tended to cover pairs consisting of a segment and
the null character, which correspond to the opera-
</bodyText>
<page confidence="0.995657">
288
</page>
<note confidence="0.800835166666667">
Algorithm Calculation Calculation Dynamic Phonological
of alignment of distance programming features
Covington (1996) explicit implicit no no
Somers (1998) explicit no no multivalued
Nerbonne and Heeringa (1997) implicit explicit yes binary
Gildea and Jurafsky (1996) explicit implicit yes binary
</note>
<tableCaption confidence="0.999661">
Table 1: Comparison of alignment algorithms.
</tableCaption>
<bodyText confidence="0.994854666666667">
tions of insertion and deletion (also called indels).
A distance function that satisfies the following ax-
ioms is called a metric:
</bodyText>
<listItem confidence="0.999754">
1. Va,b : d(a,b) &gt; 0 (nonnegative property)
2. Va, b : d(a,b) = 0 &lt;=&gt; a = b (zero property)
3. Va, b : d(a,b) = d(b,a) (symmetry)
4. Va, b, c : d(a, b) d(b , c)&gt; d (a, c) (triangle in-
equality)
</listItem>
<subsectionHeader confidence="0.996022">
2.1 Covington&apos;s Distance Function vs.
Feature-Based Metrics
</subsectionHeader>
<bodyText confidence="0.98181071875">
Covington (1996), for his cognate alignment algo-
rithm, constructed a special distance function. It
was developed by trial and error on a test set of 82
cognate pairs from various related languages. The
distance function is very simple; it uses no phono-
logical features and distinguishes only three types
of segments: consonants, vowels, and glides. Many
important characteristics of sounds, such as place
or manner of articulation, are ignored. For example,
both yacht and will are treated identically as a glide-
vowel-consonant sequence. The function&apos;s values
for substitutions are listed in the &amp;quot;penalty&amp;quot; column
in Table 2. The penalty for an indel is 40 if it is pre-
ceded by another indel, and 50 otherwise. Coving-
ton (1998) acknowledges that his distance function
is &amp;quot;just a stand-in for a more sophisticated, perhaps
feature-based, system&amp;quot;.1
Both Gildea and Jurafsky (1996) and Nerbonne
and Heeringa (1997) use distance functions based
on binary features. Such functions have the ability
to distinguish a large number of different phones.
The underlying assumption is that the number of bi-
nary features by which two given sounds differ is
1Covington&apos;s distance function is not a metric. The zero
property is not satisfied because the function&apos;s value for two
identical vowels is greater than zero. Also, the triangle in-
equality does not hold in all cases; for example: p(e,i) = 30
and p(i,y)= 10, but p(e,y)= 100, where p(x,y) is the penalty
for aligning [x] with [y].
a good indication of their proximity. Phonetic seg-
ments are represented by binary vectors in which
every entry stands for a single articulatory feature.
The penalty for a substitution is defined as the Ham-
ming distance between two feature vectors. The
penalty for indels is established more or less arbi-
trarily.2 A distance function defined in such a way
satisfies all metric axioms.
It is interesting to compare the values of Cov-
ington&apos;s distance function with the average Ham-
ming distances produced by a feature-based met-
ric. Since neither Gildea and Jurafsky (1996) nor
Nerbonne and Heeringa (1997) present their fea-
ture vectors in sufficient detail to perform the cal-
culations, I adopted a fairly standard set of 17 bi-
nary features from Hartman (1981).3 The average
feature distances between pairs of segments corre-
sponding to every clause in Covington&apos;s distance
function are given in Table 2, next to Covington&apos;s
&amp;quot;penalties&amp;quot;. By definition, the Hamming distance
between identical segments is zero. The distance
between the segments covered by clause #3 is also
constant and equal to one (the feature in question
being [long] or [syllabic]). The remaining average
feature distances were calculated using a set of most
frequent phonemes represented by 25 letters of the
Latin alphabet (all but q). In order to facilitate com-
parison, the rightmost column of Table 2 contains
the average distances interpolated between the min-
imum and the maximum value of Covington&apos;s dis-
tance function. The very high correlation (0.998)
between Covington&apos;s penalties and the average dis-
tances demonstrates that feature-based phonology
provides a theoretical basis for Covington&apos;s manu-
ally constructed distance function.
</bodyText>
<footnote confidence="0.996507166666667">
2Nerbonne and Heeringa (1997) fix the penalty for indels as
half the average of the values of all substitutions. Gildea and
Jurafsky (1996) set it at one fourth of the maximum substitution
cost.
3In order to handle all the phones in Covington&apos;s data set,
two features were added: [tense] and [spread glottis].
</footnote>
<page confidence="0.994806">
289
</page>
<table confidence="0.982456333333333">
Clause in Covington&apos;s Covington&apos;s Average Interpolated
distance function penalty Hamming average
distance distance
1 &amp;quot;identical consonants or glides&amp;quot; 0 0.0 0.0
2 &amp;quot;identical vowels&amp;quot; 5 0.0 0.0
3 &amp;quot;vowel length difference only&amp;quot; 10 1.0 12.4
4 &amp;quot;non-identical vowels&amp;quot; 30 2.2 27.3
5 &amp;quot;non-identical consonants&amp;quot; 60 4.81 58.1
6 &amp;quot;no similarity&amp;quot; 100 8.29 100.0
</table>
<tableCaption confidence="0.978395">
Table 2: The clause-by-clause comparison of Covington&apos;s distance function (column 3) and a feature-based
distance function (columns 4 and 5).
</tableCaption>
<subsectionHeader confidence="0.997631">
2.2 Binary vs. Multivalued Features
</subsectionHeader>
<bodyText confidence="0.999974075">
Although binary features are elegant and widely
used, they might not be optimal for phonetic align-
ment. Their primary motivation is to classify
phonological oppositions rather than to reflect the
phonetic characteristics of sounds. In a strictly bi-
nary system, sounds that are similar often differ in a
disproportionately large number of features. It can
be argued that allowing features to have several pos-
sible values results in a more natural and phoneti-
cally adequate system. For example, there are many
possible places of articulation, which form a near-
continuum ranging from [labial] to [glottal].
Ladefoged (1995) devised a phonetically-based
multivalued feature system. This system has been
adapted by Connolly (1997) and implemented by
Somers (1998). It contains about 20 features with
values between 0 and 1. Some of them can take
as many as ten different values (e.g. [place]),
while others are basically binary oppositions (e.g.
[nasal]). Table 3 contains examples of multivalued
features.
The main problem with both Somers&apos;s and Con-
nolly&apos;s approaches is that they do not differenti-
ate the weights, or saliences, that express the rel-
ative importance of individual features. For ex-
ample, they assign the same salience to the fea-
ture [place] as to the feature [aspiration], which
results in a smaller distance between [p] and [k]
than between [p] and [ph]. I found that in order
to avoid such incongruous outcomes, the salience
values need to be carefully differentiated; specifi-
cally, the features [place] and [manner] should be
assigned significantly higher saliences than other
features (the actual values used in my algorithm are
given in Table 4). Nerbonne and Heeringa (1997)
experimented with weighting each feature by infor-
mation gain but found it had an adverse effect on
the quality of the alignments. The question of how
to derive salience values in a principled manner is
still open.
</bodyText>
<subsectionHeader confidence="0.998028">
2.3 Similarity vs. Distance
</subsectionHeader>
<bodyText confidence="0.999990733333333">
Although all four algorithms listed in Table 1 mea-
sure relatedness between phones by means of a dis-
tance function, such an approach does not seem to
be the best for dealing with phonetic units. The fact
that Covington&apos;s distance function is not a metric is
not an accidental oversight; rather, it reflects certain
inherent characteristics of phones. Since vowels are
in general more volatile than consonants, the pref-
erence for matching identical consonants over iden-
tical vowels is justified. This insight cannot be ex-
pressed by a metric, which, by definition, assigns a
zero distance to all identical pairs of segments. Nor
is it certain that the triangle inequality should hold
for phonetic segments. A phone that has two dif-
ferent places of articulation, such as labio-velar [w],
can be close to two phones that are distant from each
other, such as labial [b] and velar [g].
In my algorithm, below, I employ an alternative
approach to comparing segments, which is based on
the notion of similarity. A similarity scoring scheme
assigns large positive scores to pairs of related seg-
ments; large negative scores to pairs of dissimilar
segments; and small negative scores to indels. The
optimal alignment is the one that maximizes the
overall score. Under the similarity approach, the
score obtained by two identical segments does not
have to be constant. Another important advantage of
the similarity approach is the possibility of perform-
ing local alignment of phonetic sequences, which is
discussed in the following section.
</bodyText>
<sectionHeader confidence="0.967608" genericHeader="method">
3 Tree Search vs. Dynamic Programming
</sectionHeader>
<bodyText confidence="0.9941165">
Once an appropriate function for measuring simi-
larity between pairs of segments has been designed,
</bodyText>
<page confidence="0.986894">
290
</page>
<table confidence="0.994128538461538">
Feature Phonological Numerical
name term value
Place [bilabial] 1.0
[labiodental] 0.95
[dental] 0.9
[alveolar] 0.85
[retroflex] 0.8
[palato-alveolar] 0.75
[palatal] 0.7
[velar] 0.6
[uvular] 0.5
[pharyngeal] 0.3
[glottal] 0.1
Manner [stop] 1.0
[affricate] 0.9
[fricative] 0.8
[approximant] 0.6
[high vowel] 0.4
[mid vowel] 0.2
[low vowel] 0.0
High [high] 1.0
[mid] 0.5
[low] 0.0
Back [front] 1.0
[central] 0.5
[back] 0.0
</table>
<tableCaption confidence="0.999797">
Table 3: Multivalued features and their values.
</tableCaption>
<bodyText confidence="0.9998754">
we need an algorithm for finding the optimal align-
ment of phonetic sequences. While the DP algo-
rithm, which operates in quadratic time, seems to
be optimal for the task, both Somers and Covington
opt for exhaustive search strategies. In my opinion,
this is unwarranted.
Somers&apos;s algorithm is unusual because the se-
lected alignment is not necessarily the one that
minimizes the sum of distances between individ-
ual segments. Instead, it recursively selects the
most similar segments, or &amp;quot;anchor points&amp;quot;, in the
sequences being compared. Such an approach has
a serious flaw. Suppose that the sequences to be
aligned are tewos and divut. Even though the corre-
sponding segments are slightly different, the align-
ment is straightforward. However, an algorithm that
looks for the best matching segments first, will er-
roneously align the two t&apos;s. Because of its recursive
nature, the algorithm has no chance of recovering
from such an error.4
</bodyText>
<table confidence="0.997403833333333">
Syllabic 5 Place 40
Voice 10 Nasal 10
Lateral 10 Aspirated 5
High 5 Back 5
Manner 50 Retroflex 10
Long 1 Round 5
</table>
<tableCaption confidence="0.936125">
Table 4: Features used in ALINE and their salience
settings.
</tableCaption>
<bodyText confidence="0.999872236842105">
Covington, who uses a straightforward depth-first
search to find the optimal alignment, provides the
following arguments for eschewing the DP algo-
rithm.
First, the strings being aligned are rel-
atively short, so the efficiency of dy-
namic programming on long strings is not
needed. Second, dynamic programming
normally gives only one alignment for
each pair of strings, but comparative re-
construction may need the n best alter-
natives, or all that meet some criterion.
Third, the tree search algorithm lends it-
self to modification for special handling
of metathesis or assimilation.5 (Coving-
ton, 1996)
The efficiency of the algorithm might not be rel-
evant in the simple case of comparing two words,
but if the algorithm is to be of practical use, it will
have to operate on large bilingual wordlists. More-
over, combining the alignment algorithm with some
sort of strategy for identifying cognates on the basis
of phonetic similarity is likely to require comparing
thousands of words against one another. Having a
polynomially bound algorithm in the core of such a
system is crucial. In any case, since the DP algo-
rithm involves neither significantly larger overhead
nor greater programming effort, there is no reason
to avoid using it even for relatively small data sets.
The DP algorithm is also sufficiently flexible to
accommodate most of the required extensions with-
out compromising its polynomial complexity. A
simple modification will produce all alignments that
are within c of the optimal distance (Myers, 1995).
By applying methods from the operations research
literature (Fox, 1973), the algorithm can be adapted
to deliver the n best solutions. Moreover, the basic
set of editing operations (substitutions and indels)
</bodyText>
<footnote confidence="0.9901695">
4The criticism applies regardless of the method of choosing 5Covington does not elaborate on the nature of the modifi-
the best matching segments (see also Section 5). cations.
</footnote>
<page confidence="0.994742">
291
</page>
<bodyText confidence="0.999979714285714">
can be extended to include both transpositions of ad-
jacent segments (metathesis) (Lowrance and Wag-
ner, 1975) and compressions and expansions (Oom-
men, 1995). Other extensions of the DP algorithm
that are applicable to the problem of phonetic align-
ment include affine gap scores and local compari-
son.
The motivation for generalized gap scores arises
from the fact that in diachronic phonology not only
individual segments but also entire morphemes and
syllables are sometimes deleted. In order to take
this fact into account, the penalty for a gap can be
calculated as a function of its length, rather than as
a simple sum of individual deletions. One solution
is to use an affine function of the form gap(x)
where r is the penalty for the introduction of a
gap, and s is the penalty for each symbol in the gap.
Gotoh (1982) describes a method for incorporating
affine gap scores into the DP alignment algorithm.
Incidentally, Covington&apos;s penalties for indels can be
expressed by an affine gap function with r = 10 and
s= 40.
Local comparison (Smith and Waterman, 1981)
is made possible by using both positive and neg-
ative similarity scores. In local, as opposed to
global, comparison, only similar subsequences are
matched, rather than entire sequences. This often
has the beneficial effect of separating inflectional
and derivational affixes from the roots. Such affixes
tend to make finding the proper alignment more dif-
ficult. It would be unreasonable to expect affixes
to be stripped before applying the algorithm to the
data, because one of the very reasons to use an au-
tomatic aligner is to avoid analyzing every word in-
dividually.
</bodyText>
<sectionHeader confidence="0.988192" genericHeader="method">
4 The algorithm
</sectionHeader>
<bodyText confidence="0.999924090909091">
Many of the ideas discussed in previous sections
have been incorporated into the new algorithm for
the alignment of phonetic sequences (ALINE). Sim-
ilarity rather than distance is used to determine a
set of best local alignments that fall within c of
the optimal alignment.6 The set of operations con-
tains insertions/deletions, substitutions, and expan-
sions/compressions. Multivalued features are em-
ployed to calculate similarity of phonetic segments.
Affine gaps were found to make little difference
when local comparison is used and they were subse-
</bodyText>
<footnote confidence="0.927814666666667">
6Global and semiglobal comparison can also be used. In
a semiglobal comparison, the leading and trailing indels are
assigned a score of zero.
</footnote>
<subsectionHeader confidence="0.306125">
algorithm Alignment
</subsectionHeader>
<bodyText confidence="0.4134815">
input: phonetic sequences x and y
output: alignment of x and y
</bodyText>
<equation confidence="0.803326684210526">
define S(i, j) = —00 when i &lt;0 or j &lt;0
for i 4-- 0 to Ix 1 do
S(i, 0) 4— 0
for j 4— 0 tO IA do
S(0, j) 0
for 1 4— Ito (xi do
for j to IA do
S(i, j) 4— max(
S(i— 1, j) + askip(xi),
S(i, j— 1) + askip(Yi),
S(i-1, j—i) Crsub (Xi , yi),
S(i— 1, j —2) + Gexp (xi ,
S(i-2, j— 1) + ctexp (xi— xi
0)
T (1 — c) x max, S(ij)
for i +— 1 to Ix( do
for j 4— i to IA do
if S(i, j) &gt; T then
Retrieve(i, j, 0)
</equation>
<figureCaption confidence="0.924503">
Figure 1: The algorithm for computing the align-
ment of two phonetic sequences.
</figureCaption>
<bodyText confidence="0.794402318181818">
quently removed from ALINE.7 The algorithm has
been implemented in C++ and will be made avail-
able in the near future.
Figure 1 contains the main components of the
algorithm. First, the DP approach is applied to
compute the similarity matrix S using the a scor-
ing functions. The optimal score is the maximum
entry in the whole matrix. A recursive procedure
Retrieve (Figure 2) is called on every matrix en-
try that exceeds the threshold score T. The align-
ments are retrieved by traversing the matrix until a
zero entry is encountered. The scoring functions for
indels, substitutions and expansions are defined in
Figure 3. Cskip, Csub, and Cexp are the maximum
scores for indels, substitutions, and expansions, re-
spectively. C,„/ determines the relative weight of
consonants and vowels. The default values are Cskip
= —10, Csub = 35, Cexp = 45 and Gym = 10. The cliff
function returns the difference between segments p
and q for a given feature f. Set Rv contains fea-
tures relevant for comparing two vowels: Syllabic,
Nasal, Retroflex, High, Back, Round, and Long. Set
</bodyText>
<footnote confidence="0.8945005">
7They may be necessary, however, when dealing with lan-
guages that are rich in infixes.
</footnote>
<page confidence="0.971663">
292
</page>
<construct confidence="0.84578784">
procedure Retrieve(i, j, s)
if S(i, j) = 0 then
print(Out)
print(&amp;quot;alignment score is s&amp;quot;)
else
if S(i— 1, j— 1) + as„b(xi,yi) +s&gt; T then
push(Out, &amp;quot;align xi with xi&amp;quot;)
Retrieve(i— 1, j— 1, s + as„b(xi,yi))
pop(Out)
if S(1, j — 1) + askip(xj) + s &gt; T then
push(Out, &amp;quot;align null with yj&amp;quot;)
Retrieve(i, j — 1, s + askip(M)
pop(Out)
if S(i— 1, j —2) + aexp(xi,yj_iyi) + s &gt; T then
push(Out, &amp;quot;align xi with yi-1Y3&amp;quot;)
Retrieve(i— 1, j —2, s + 6exp(XilYj—OV))
pop(Out)
if S(i— 1, j) + askip(xj) + s &gt; T then
push(Out, &amp;quot;align xi with null&amp;quot;)
Retrieve(i— 1, j, s + askip(xj))
pop(Out)
if S(i-2, j — 1) + aexp + s &gt; T then
push(Out, &amp;quot;align xixi_i with xi&amp;quot;)
Retrieve(i-2, j— 1, s + aexp (yi,xj_ixi))
pop(Out)
</construct>
<figureCaption confidence="0.991341">
Figure 2: The procedure for retrieving alignments
from the similarity matrix.
</figureCaption>
<bodyText confidence="0.996225052631579">
Rc contains features for comparing other segments:
Syllabic, Manner, Voice, Nasal, Retroflex, Lateral,
Aspirated, and Place. When dealing with double-
articulation consonantal segments, only the nearest
places of articulation are used. For a more detailed
description of the algorithm see (Kondrak, 1999).
ALINE represents phonetic segments as vectors
of feature values. Table 4 shows the features that
are currently used by ALINE. Feature values are
encoded as floating-point numbers in the range
[0.0, 1.0]. The numerical values of four principal
features are listed in Table 3. The numbers are
based on the measurements performed by Lade-
foged (1995). The remaining features have exactly
two possible values, 0.0 and 1.0. A special fea-
ture &apos;Double&apos;, which has the same values as &apos;Place&apos;,
indicates the second place of articulation. Thanks
to its continuous nature, the system of features and
their values can easily be adjusted and augmented.
</bodyText>
<sectionHeader confidence="0.998228" genericHeader="evaluation">
5 Evaluation
</sectionHeader>
<bodyText confidence="0.995385">
The best alignments are obtained when local com-
parison is used. For example, when aligning En-
</bodyText>
<equation confidence="0.829748625">
= Cskip
=
= CexP 15(13) (11) 8(13,q2)
11(14 max(V(q1) )17 (q2))
{
Ci 0
if p is a consonant
otherwise
</equation>
<figureCaption confidence="0.998194">
Figure 3: Scoring functions.
</figureCaption>
<bodyText confidence="0.999959133333334">
glish grass with Latin gramen, it is important to
match only the first three segments in each word;
the remaining segments are unrelated. ALINE obvi-
ously does not know the particular etymologies, but
it can make a guess because [s] and [m] are not very
similar phonetically. Only local alignment is able to
distinguish between the essential and non-essential
correspondences in this case (Table 5).
The operations of compression and expansion
prove to be very useful in the case of complex cor-
respondences. For example, in the alignment of
Latin factum with Spanish hecho, the affricate [If]
should be linked with both [k] and [t] rather than
with just one of them, because it originates from the
merger of the two consonants. Note that taking a se-
</bodyText>
<figure confidence="0.3884805">
g r s
g r a me n
Mgr
Mgr a m II en
II g r eII
II g r a II men
</figure>
<tableCaption confidence="0.88916325">
Table 5: Three alignments of English grass and
Latin gramen obtained with global, semiglobal, and
local comparison. The double bars delimit the
aligned subsequences.
</tableCaption>
<figure confidence="0.997374">
Oskip(P)
asub(P)9)
aexP(Plqlq2)
where
V(p)
8(p, q) = I diff(p, q, f) x salience(f)
f ER
where {
R = Rc if p or q is a consonant
RI, otherwise
</figure>
<page confidence="0.984041">
293
</page>
<table confidence="0.996797307692308">
Covington&apos;s alignments ALINE &apos;s alignments
three: tres Or II Or iy
blow : flare t r a s e 1 II t r 6 I I re
full: plenus b 1 r u s II b 1 A I I anus
f 1 nu II f I 1 II
II 1
II
fish: piscis i g f i g
I: ego e i s ki s p i s kis
g a II ay II go
o II
tooth: dentis t u t uw 0 II
dent i den II t i s II
</table>
<tableCaption confidence="0.999071">
Table 6: Examples of alignments of English and Latin cognates.
</tableCaption>
<bodyText confidence="0.99992642">
quence of substitution and deletion as compression
is unsatisfactory because it cannot be distinguished
from an actual sequence of substitution and dele-
tion. ALINE posits this operation particularly fre-
quently in cases of diphthongization of vowels (see
the alignments in Table 6).
Covington&apos;s data set of 82 cognates provides a
convenient test for the algorithm. His English/Latin
set is particularly interesting, because these two
languages are not closely related. Some of the
alignments produced by Covington&apos;s algorithm and
ALINE are shown in Table 6. ALINE accurately
discards inflectional affixes in piscis and flare. In
fish/piscis, Covington&apos;s aligner produces four alter-
native alignments, while ALINE selects the cor-
rect one. Both algorithms are technically wrong
on tooth/dentis, but this is hardly an error consid-
ering that only the information contained in the
phonetic string is available to the aligners. On
Covington&apos;s Spanish/French data, ALINE does not
make any mistakes. Unlike Covington&apos;s aligner,
it properly aligns [1] in arbol with the second [r]
in arbre. On his English/German data, it selects
the correct alignment in those cases where Coving-
ton&apos;s aligner produces two alternatives. In the fi-
nal, mixed set, ALINE makes a single mistake in
daughter/thugater, in which it posits a dropped pre-
fix rather than a syncopated syllable; in all other
cases, it is right on target. Overall, ALINE clearly
performs better than Covington&apos;s aligner.
Somers (1999) tests one version of his algo-
rithm, CAT, on the same set of cognates. CAT em-
ploys binary, rather than multivalued, features. An-
other important characteristic is that it pre-aligns
the stressed segments in both sequences. Since
CAT distinguishes between individual consonants,
in some cases it produces more accurate alignments
than Covington&apos;s aligner. However, because of its
pre-alignment strategy, it is guaranteed to produce
wrong alignments in all cases when the stress has
moved in one of the cognates. For example, in
the Spanish/French pair cabeza/cap, it aligns [p]
with [0] rather than [b] and fails to align the two
[al&apos;s. The problem is even more acute for closely
related languages that have different stress rules.8
In contrast, ALINE does not even consider stress,
which, in the context of diachronic phonology, is
too volatile to depend on. Except for the single case
of daughter/thugater, ALINE produces better align-
ments than Somers&apos;s algorithm.
</bodyText>
<sectionHeader confidence="0.999268" genericHeader="conclusions">
6 Future Directions
</sectionHeader>
<bodyText confidence="0.999858">
The goal of my current research is to combine the
new alignment algorithm with a cognate identifica-
tion procedure. The alignment of cognates is possi-
</bodyText>
<footnote confidence="0.995829666666667">
8For example, stress regularly falls on the initial syllable
in Czech and on the penultimate syllable in Polish, while in
Russian it can fall anywhere in the word.
</footnote>
<page confidence="0.996686">
294
</page>
<bodyText confidence="0.999970769230769">
ble only after the pairs of words that are suspected
of being cognate have been identified. Identification
of cognates is, however, an even more difficult task
than the alignment itself. Moreover, it is hardly fea-
sible without some kind of pre-alignment between
candidate lexemes. A high alignment score of two
words should indicate whether they are related. An
integrated cognate identification algorithm would
take as input unordered wordlists from two or more
related languages, and produce a list of aligned cog-
nate pairs as output. Such an algorithm would be a
step towards developing a fully automated language
reconstruction system.
</bodyText>
<sectionHeader confidence="0.999506" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.99975275">
I would like to thank Graeme Hirst, Elan Dresher,
Steven Bird, and Carole Bracco for their comments.
This research was supported by Natural Sciences
and Engineering Research Council of Canada.
</bodyText>
<sectionHeader confidence="0.999674" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.995872507042253">
John H. Connolly. 1997. Quantifying target-
realization differences. Clinical Linguistics &amp;
Phonetics, 11:267-298.
Michael A. Covington. 1996. An algorithm to align
words for historical comparison. Computational
Linguistics, 22(4):481-496.
Michael A. Covington. 1998. Alignment of mul-
tiple languages for historical comparison. In
Proceedings of COLING-ACL&apos;98: 36th Annual
Meeting of the Association for Computational
Linguistics and 17th International Conference on
Computational Linguistics, pages 275-280.
Bennett L. Fox. 1973. Calculating the Kth short-
est paths. INFOR - Canadian Journal of Op-
erational Research and Information Processing,
11(1):66-70.
Daniel Gildea and Daniel Jurafsky. 1996. Learning
bias and phonological-rule induction. Computa-
tional Linguistics, 22(4):497-530.
Osamu Gotoh. 1982. An improved algorithm
for matching biological sequences. Journal of
Molecular Biology, 162:705-708.
Steven Lee Hartman. 1981. A universal alphabet
for experiments in comparative phonology. Com-
puters and the Humanities, 15:75-82.
Grzegorz Kondrak. 1999. Alignment of pho-
netic sequences. Technical Report CSRG-
402, University of Toronto. Available from
ftp.cs.toronto.edu/csri-technical-reports.
Joseph B. Kruskal. 1983. An overview of sequence
comparison. In David Sankoff and Joseph B.
ICruskal, editors, Time warps, string edits, and
macromolecules: the theory and practice of se-
quence comparison, pages 1-44. Reading, Mass.:
Addison-Wesley.
Peter Ladefoged. 1995. A Course in Phonetics.
New York: Harcourt Brace Jovanovich.
Roy Lowrance and Robert A. Wagner. 1975. An
extension of the string-to-string correction prob-
lem. Journal of the Association for Computing
Machinery, 22:177-183.
Eugene W. Myers. 1995. Seeing conserved signals.
In Eric S. Lander and Michael S. Waterman, edi-
tors, Calculating the Secrets of Life, pages 56-89.
Washington, D.C.: National Academy Press.
John Nerbonne and Wilbert Heeringa. 1997.
Measuring dialect distance phonetically. In
Proceedings of the Third Meeting of the ACL
Special Interest Group in Computational
Phonology (SIGPHON-97). Available at
http://www.cogsci.ed.ac.uk/sigphon/.
B. John Oommen. 1995. String alignment with
substitution, insertion, deletion, squashing; and
expansion operations. Information Sciences,
83:89-107.
T. F. Smith and Michael S. Waterman. 1981. Iden-
tification of common molecular sequences. Jour-
nal of Molecular Biology, 147:195-197.
Harold L. Somers. 1998. Similarity metrics for
aligning children&apos;s articulation data. In Proceed-
ings of COLING-ACL&apos;98: 36th Annual Meeting
of the Association for Computational Linguistics
and 17th International Conference on Computa-
tional Linguistics, pages 1227-1231.
Harold L. Somers. 1999. Aligning phonetic
segments for children&apos;s articulation assessment.
Computational Linguistics, 25(2):267-275.
Robert A. Wagner and Michael J. Fischer. 1974.
The string-to-string correction problem. Jour-
nal of the Association for Computing Machinery,
21(1):168-173.
</reference>
<page confidence="0.9985">
295
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.957442">
<title confidence="0.999964">A New Algorithm for the Alignment of Phonetic Sequences</title>
<author confidence="0.997677">Grzegorz Kondrak</author>
<affiliation confidence="0.9999785">Department of Computer Science University of Toronto</affiliation>
<address confidence="0.999858">Toronto, Ontario, Canada M5S 304</address>
<email confidence="0.99982">kondrak@cs.toronto.edu</email>
<abstract confidence="0.996032454545454">Alignment of phonetic sequences is a necessary step in many applications in computational phonology. After discussing various approaches to phonetic alignment, I present a new algorithm that combines a number of techniques developed for sequence comparison with a scoring scheme for computing phonetic similarity on the basis of multivalued features. The algorithm performs better on cognate alignment, in terms of accuracy and efficiency, than other algorithms reported in the literature.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>John H Connolly</author>
</authors>
<title>Quantifying targetrealization differences.</title>
<date>1997</date>
<journal>Clinical Linguistics &amp; Phonetics,</journal>
<pages>11--267</pages>
<contexts>
<context position="9357" citStr="Connolly (1997)" startWordPosition="1481" endWordPosition="1482">primary motivation is to classify phonological oppositions rather than to reflect the phonetic characteristics of sounds. In a strictly binary system, sounds that are similar often differ in a disproportionately large number of features. It can be argued that allowing features to have several possible values results in a more natural and phonetically adequate system. For example, there are many possible places of articulation, which form a nearcontinuum ranging from [labial] to [glottal]. Ladefoged (1995) devised a phonetically-based multivalued feature system. This system has been adapted by Connolly (1997) and implemented by Somers (1998). It contains about 20 features with values between 0 and 1. Some of them can take as many as ten different values (e.g. [place]), while others are basically binary oppositions (e.g. [nasal]). Table 3 contains examples of multivalued features. The main problem with both Somers&apos;s and Connolly&apos;s approaches is that they do not differentiate the weights, or saliences, that express the relative importance of individual features. For example, they assign the same salience to the feature [place] as to the feature [aspiration], which results in a smaller distance betwe</context>
</contexts>
<marker>Connolly, 1997</marker>
<rawString>John H. Connolly. 1997. Quantifying targetrealization differences. Clinical Linguistics &amp; Phonetics, 11:267-298.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael A Covington</author>
</authors>
<title>An algorithm to align words for historical comparison.</title>
<date>1996</date>
<journal>Computational Linguistics,</journal>
<pages>22--4</pages>
<contexts>
<context position="2243" citStr="Covington (1996)" startWordPosition="350" endWordPosition="351">he basis of phonological features that encode certain properties of phones. An obvious candidate for the latter is a well-known dynamic programming (DP) algorithm for string alignment (Wagner and Fischer, 1974), although other algorithms can used as well. The task of finding the optimal alignment is closely linked to the task of calculating the distance between two sequences. The basic DP algorithm accomplishes both tasks. Depending on the application, either of the results, or both, can be used. Within the last few years, several different approaches to phonetic alignment have been reported. Covington (1996) used depth-first search and a special distance function to align words for historical comparison. In a follow-up paper (Covington, 1998), he extended the algorithm to align words from more than two languages. Somers (1998) proposed a special algorithm for aligning children&apos;s articulation data with the adult model. Gildea and Jurafsky (1996) applied the DP algorithm to pre-align input and output phonetic strings in order to improve the performance of their transducer induction system. Nerbonne and Heeringa (1997) employed a similar procedure to compute relative distance between words from vari</context>
<context position="4005" citStr="Covington (1996)" startWordPosition="627" endWordPosition="628"> the techniques proposed here can also be applied in other contexts where it is necessary to align phonetic sequences. 2 Comparing Phones To align phonetic sequences, we first need a function for calculating the distance between individual phones. The numerical value assigned by the function to a pair of segments is referred to as the cost, or penalty, of substitution. The function is often extended to cover pairs consisting of a segment and the null character, which correspond to the opera288 Algorithm Calculation Calculation Dynamic Phonological of alignment of distance programming features Covington (1996) explicit implicit no no Somers (1998) explicit no no multivalued Nerbonne and Heeringa (1997) implicit explicit yes binary Gildea and Jurafsky (1996) explicit implicit yes binary Table 1: Comparison of alignment algorithms. tions of insertion and deletion (also called indels). A distance function that satisfies the following axioms is called a metric: 1. Va,b : d(a,b) &gt; 0 (nonnegative property) 2. Va, b : d(a,b) = 0 &lt;=&gt; a = b (zero property) 3. Va, b : d(a,b) = d(b,a) (symmetry) 4. Va, b, c : d(a, b) d(b , c)&gt; d (a, c) (triangle inequality) 2.1 Covington&apos;s Distance Function vs. Feature-Based </context>
<context position="14409" citStr="Covington, 1996" startWordPosition="2296" endWordPosition="2298">alience settings. Covington, who uses a straightforward depth-first search to find the optimal alignment, provides the following arguments for eschewing the DP algorithm. First, the strings being aligned are relatively short, so the efficiency of dynamic programming on long strings is not needed. Second, dynamic programming normally gives only one alignment for each pair of strings, but comparative reconstruction may need the n best alternatives, or all that meet some criterion. Third, the tree search algorithm lends itself to modification for special handling of metathesis or assimilation.5 (Covington, 1996) The efficiency of the algorithm might not be relevant in the simple case of comparing two words, but if the algorithm is to be of practical use, it will have to operate on large bilingual wordlists. Moreover, combining the alignment algorithm with some sort of strategy for identifying cognates on the basis of phonetic similarity is likely to require comparing thousands of words against one another. Having a polynomially bound algorithm in the core of such a system is crucial. In any case, since the DP algorithm involves neither significantly larger overhead nor greater programming effort, the</context>
</contexts>
<marker>Covington, 1996</marker>
<rawString>Michael A. Covington. 1996. An algorithm to align words for historical comparison. Computational Linguistics, 22(4):481-496.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael A Covington</author>
</authors>
<title>Alignment of multiple languages for historical comparison.</title>
<date>1998</date>
<booktitle>In Proceedings of COLING-ACL&apos;98: 36th Annual Meeting of the Association for Computational Linguistics and 17th International Conference on Computational Linguistics,</booktitle>
<pages>275--280</pages>
<contexts>
<context position="2380" citStr="Covington, 1998" startWordPosition="372" endWordPosition="373">rogramming (DP) algorithm for string alignment (Wagner and Fischer, 1974), although other algorithms can used as well. The task of finding the optimal alignment is closely linked to the task of calculating the distance between two sequences. The basic DP algorithm accomplishes both tasks. Depending on the application, either of the results, or both, can be used. Within the last few years, several different approaches to phonetic alignment have been reported. Covington (1996) used depth-first search and a special distance function to align words for historical comparison. In a follow-up paper (Covington, 1998), he extended the algorithm to align words from more than two languages. Somers (1998) proposed a special algorithm for aligning children&apos;s articulation data with the adult model. Gildea and Jurafsky (1996) applied the DP algorithm to pre-align input and output phonetic strings in order to improve the performance of their transducer induction system. Nerbonne and Heeringa (1997) employed a similar procedure to compute relative distance between words from various Dutch dialects. Some characteristics of these implementations are juxtaposed in Table 1. In this paper, I present a new algorithm for</context>
<context position="5339" citStr="Covington (1998)" startWordPosition="849" endWordPosition="851">ed by trial and error on a test set of 82 cognate pairs from various related languages. The distance function is very simple; it uses no phonological features and distinguishes only three types of segments: consonants, vowels, and glides. Many important characteristics of sounds, such as place or manner of articulation, are ignored. For example, both yacht and will are treated identically as a glidevowel-consonant sequence. The function&apos;s values for substitutions are listed in the &amp;quot;penalty&amp;quot; column in Table 2. The penalty for an indel is 40 if it is preceded by another indel, and 50 otherwise. Covington (1998) acknowledges that his distance function is &amp;quot;just a stand-in for a more sophisticated, perhaps feature-based, system&amp;quot;.1 Both Gildea and Jurafsky (1996) and Nerbonne and Heeringa (1997) use distance functions based on binary features. Such functions have the ability to distinguish a large number of different phones. The underlying assumption is that the number of binary features by which two given sounds differ is 1Covington&apos;s distance function is not a metric. The zero property is not satisfied because the function&apos;s value for two identical vowels is greater than zero. Also, the triangle inequ</context>
</contexts>
<marker>Covington, 1998</marker>
<rawString>Michael A. Covington. 1998. Alignment of multiple languages for historical comparison. In Proceedings of COLING-ACL&apos;98: 36th Annual Meeting of the Association for Computational Linguistics and 17th International Conference on Computational Linguistics, pages 275-280.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bennett L Fox</author>
</authors>
<title>Calculating the Kth shortest paths. INFOR -</title>
<date>1973</date>
<journal>Canadian Journal of Operational Research and Information Processing,</journal>
<pages>11--1</pages>
<contexts>
<context position="15400" citStr="Fox, 1973" startWordPosition="2457" endWordPosition="2458"> against one another. Having a polynomially bound algorithm in the core of such a system is crucial. In any case, since the DP algorithm involves neither significantly larger overhead nor greater programming effort, there is no reason to avoid using it even for relatively small data sets. The DP algorithm is also sufficiently flexible to accommodate most of the required extensions without compromising its polynomial complexity. A simple modification will produce all alignments that are within c of the optimal distance (Myers, 1995). By applying methods from the operations research literature (Fox, 1973), the algorithm can be adapted to deliver the n best solutions. Moreover, the basic set of editing operations (substitutions and indels) 4The criticism applies regardless of the method of choosing 5Covington does not elaborate on the nature of the modifithe best matching segments (see also Section 5). cations. 291 can be extended to include both transpositions of adjacent segments (metathesis) (Lowrance and Wagner, 1975) and compressions and expansions (Oommen, 1995). Other extensions of the DP algorithm that are applicable to the problem of phonetic alignment include affine gap scores and loc</context>
</contexts>
<marker>Fox, 1973</marker>
<rawString>Bennett L. Fox. 1973. Calculating the Kth shortest paths. INFOR - Canadian Journal of Operational Research and Information Processing, 11(1):66-70.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Daniel Gildea</author>
<author>Daniel Jurafsky</author>
</authors>
<title>Learning bias and phonological-rule induction.</title>
<date>1996</date>
<journal>Computational Linguistics,</journal>
<pages>22--4</pages>
<contexts>
<context position="2586" citStr="Gildea and Jurafsky (1996)" startWordPosition="403" endWordPosition="407">lculating the distance between two sequences. The basic DP algorithm accomplishes both tasks. Depending on the application, either of the results, or both, can be used. Within the last few years, several different approaches to phonetic alignment have been reported. Covington (1996) used depth-first search and a special distance function to align words for historical comparison. In a follow-up paper (Covington, 1998), he extended the algorithm to align words from more than two languages. Somers (1998) proposed a special algorithm for aligning children&apos;s articulation data with the adult model. Gildea and Jurafsky (1996) applied the DP algorithm to pre-align input and output phonetic strings in order to improve the performance of their transducer induction system. Nerbonne and Heeringa (1997) employed a similar procedure to compute relative distance between words from various Dutch dialects. Some characteristics of these implementations are juxtaposed in Table 1. In this paper, I present a new algorithm for the alignment of cognates. It combines various techniques developed for sequence comparison with an appropriate scoring scheme for computing phonetic similarity on the basis of multivalued features. The ne</context>
<context position="4155" citStr="Gildea and Jurafsky (1996)" startWordPosition="647" endWordPosition="650"> align phonetic sequences, we first need a function for calculating the distance between individual phones. The numerical value assigned by the function to a pair of segments is referred to as the cost, or penalty, of substitution. The function is often extended to cover pairs consisting of a segment and the null character, which correspond to the opera288 Algorithm Calculation Calculation Dynamic Phonological of alignment of distance programming features Covington (1996) explicit implicit no no Somers (1998) explicit no no multivalued Nerbonne and Heeringa (1997) implicit explicit yes binary Gildea and Jurafsky (1996) explicit implicit yes binary Table 1: Comparison of alignment algorithms. tions of insertion and deletion (also called indels). A distance function that satisfies the following axioms is called a metric: 1. Va,b : d(a,b) &gt; 0 (nonnegative property) 2. Va, b : d(a,b) = 0 &lt;=&gt; a = b (zero property) 3. Va, b : d(a,b) = d(b,a) (symmetry) 4. Va, b, c : d(a, b) d(b , c)&gt; d (a, c) (triangle inequality) 2.1 Covington&apos;s Distance Function vs. Feature-Based Metrics Covington (1996), for his cognate alignment algorithm, constructed a special distance function. It was developed by trial and error on a test </context>
<context position="5490" citStr="Gildea and Jurafsky (1996)" startWordPosition="869" endWordPosition="872">ological features and distinguishes only three types of segments: consonants, vowels, and glides. Many important characteristics of sounds, such as place or manner of articulation, are ignored. For example, both yacht and will are treated identically as a glidevowel-consonant sequence. The function&apos;s values for substitutions are listed in the &amp;quot;penalty&amp;quot; column in Table 2. The penalty for an indel is 40 if it is preceded by another indel, and 50 otherwise. Covington (1998) acknowledges that his distance function is &amp;quot;just a stand-in for a more sophisticated, perhaps feature-based, system&amp;quot;.1 Both Gildea and Jurafsky (1996) and Nerbonne and Heeringa (1997) use distance functions based on binary features. Such functions have the ability to distinguish a large number of different phones. The underlying assumption is that the number of binary features by which two given sounds differ is 1Covington&apos;s distance function is not a metric. The zero property is not satisfied because the function&apos;s value for two identical vowels is greater than zero. Also, the triangle inequality does not hold in all cases; for example: p(e,i) = 30 and p(i,y)= 10, but p(e,y)= 100, where p(x,y) is the penalty for aligning [x] with [y]. a go</context>
<context position="7931" citStr="Gildea and Jurafsky (1996)" startWordPosition="1260" endWordPosition="1263">ost frequent phonemes represented by 25 letters of the Latin alphabet (all but q). In order to facilitate comparison, the rightmost column of Table 2 contains the average distances interpolated between the minimum and the maximum value of Covington&apos;s distance function. The very high correlation (0.998) between Covington&apos;s penalties and the average distances demonstrates that feature-based phonology provides a theoretical basis for Covington&apos;s manually constructed distance function. 2Nerbonne and Heeringa (1997) fix the penalty for indels as half the average of the values of all substitutions. Gildea and Jurafsky (1996) set it at one fourth of the maximum substitution cost. 3In order to handle all the phones in Covington&apos;s data set, two features were added: [tense] and [spread glottis]. 289 Clause in Covington&apos;s Covington&apos;s Average Interpolated distance function penalty Hamming average distance distance 1 &amp;quot;identical consonants or glides&amp;quot; 0 0.0 0.0 2 &amp;quot;identical vowels&amp;quot; 5 0.0 0.0 3 &amp;quot;vowel length difference only&amp;quot; 10 1.0 12.4 4 &amp;quot;non-identical vowels&amp;quot; 30 2.2 27.3 5 &amp;quot;non-identical consonants&amp;quot; 60 4.81 58.1 6 &amp;quot;no similarity&amp;quot; 100 8.29 100.0 Table 2: The clause-by-clause comparison of Covington&apos;s distance function (co</context>
</contexts>
<marker>Gildea, Jurafsky, 1996</marker>
<rawString>Daniel Gildea and Daniel Jurafsky. 1996. Learning bias and phonological-rule induction. Computational Linguistics, 22(4):497-530.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Osamu Gotoh</author>
</authors>
<title>An improved algorithm for matching biological sequences.</title>
<date>1982</date>
<journal>Journal of Molecular Biology,</journal>
<pages>162--705</pages>
<contexts>
<context position="16538" citStr="Gotoh (1982)" startWordPosition="2649" endWordPosition="2650">ble to the problem of phonetic alignment include affine gap scores and local comparison. The motivation for generalized gap scores arises from the fact that in diachronic phonology not only individual segments but also entire morphemes and syllables are sometimes deleted. In order to take this fact into account, the penalty for a gap can be calculated as a function of its length, rather than as a simple sum of individual deletions. One solution is to use an affine function of the form gap(x) where r is the penalty for the introduction of a gap, and s is the penalty for each symbol in the gap. Gotoh (1982) describes a method for incorporating affine gap scores into the DP alignment algorithm. Incidentally, Covington&apos;s penalties for indels can be expressed by an affine gap function with r = 10 and s= 40. Local comparison (Smith and Waterman, 1981) is made possible by using both positive and negative similarity scores. In local, as opposed to global, comparison, only similar subsequences are matched, rather than entire sequences. This often has the beneficial effect of separating inflectional and derivational affixes from the roots. Such affixes tend to make finding the proper alignment more diff</context>
</contexts>
<marker>Gotoh, 1982</marker>
<rawString>Osamu Gotoh. 1982. An improved algorithm for matching biological sequences. Journal of Molecular Biology, 162:705-708.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Steven Lee Hartman</author>
</authors>
<title>A universal alphabet for experiments in comparative phonology.</title>
<date>1981</date>
<booktitle>Computers and the Humanities,</booktitle>
<pages>15--75</pages>
<contexts>
<context position="6841" citStr="Hartman (1981)" startWordPosition="1096" endWordPosition="1097">ry feature. The penalty for a substitution is defined as the Hamming distance between two feature vectors. The penalty for indels is established more or less arbitrarily.2 A distance function defined in such a way satisfies all metric axioms. It is interesting to compare the values of Covington&apos;s distance function with the average Hamming distances produced by a feature-based metric. Since neither Gildea and Jurafsky (1996) nor Nerbonne and Heeringa (1997) present their feature vectors in sufficient detail to perform the calculations, I adopted a fairly standard set of 17 binary features from Hartman (1981).3 The average feature distances between pairs of segments corresponding to every clause in Covington&apos;s distance function are given in Table 2, next to Covington&apos;s &amp;quot;penalties&amp;quot;. By definition, the Hamming distance between identical segments is zero. The distance between the segments covered by clause #3 is also constant and equal to one (the feature in question being [long] or [syllabic]). The remaining average feature distances were calculated using a set of most frequent phonemes represented by 25 letters of the Latin alphabet (all but q). In order to facilitate comparison, the rightmost colu</context>
</contexts>
<marker>Hartman, 1981</marker>
<rawString>Steven Lee Hartman. 1981. A universal alphabet for experiments in comparative phonology. Computers and the Humanities, 15:75-82.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Grzegorz Kondrak</author>
</authors>
<title>Alignment of phonetic sequences.</title>
<date>1999</date>
<tech>Technical Report CSRG402,</tech>
<institution>University of Toronto.</institution>
<note>Available from ftp.cs.toronto.edu/csri-technical-reports.</note>
<contexts>
<context position="20847" citStr="Kondrak, 1999" startWordPosition="3415" endWordPosition="3416">f S(i— 1, j) + askip(xj) + s &gt; T then push(Out, &amp;quot;align xi with null&amp;quot;) Retrieve(i— 1, j, s + askip(xj)) pop(Out) if S(i-2, j — 1) + aexp + s &gt; T then push(Out, &amp;quot;align xixi_i with xi&amp;quot;) Retrieve(i-2, j— 1, s + aexp (yi,xj_ixi)) pop(Out) Figure 2: The procedure for retrieving alignments from the similarity matrix. Rc contains features for comparing other segments: Syllabic, Manner, Voice, Nasal, Retroflex, Lateral, Aspirated, and Place. When dealing with doublearticulation consonantal segments, only the nearest places of articulation are used. For a more detailed description of the algorithm see (Kondrak, 1999). ALINE represents phonetic segments as vectors of feature values. Table 4 shows the features that are currently used by ALINE. Feature values are encoded as floating-point numbers in the range [0.0, 1.0]. The numerical values of four principal features are listed in Table 3. The numbers are based on the measurements performed by Ladefoged (1995). The remaining features have exactly two possible values, 0.0 and 1.0. A special feature &apos;Double&apos;, which has the same values as &apos;Place&apos;, indicates the second place of articulation. Thanks to its continuous nature, the system of features and their valu</context>
</contexts>
<marker>Kondrak, 1999</marker>
<rawString>Grzegorz Kondrak. 1999. Alignment of phonetic sequences. Technical Report CSRG402, University of Toronto. Available from ftp.cs.toronto.edu/csri-technical-reports.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Joseph B Kruskal</author>
</authors>
<title>An overview of sequence comparison.</title>
<date>1983</date>
<pages>1--44</pages>
<editor>In David Sankoff and Joseph B. ICruskal, editors, Time warps, string edits, and</editor>
<publisher>Addison-Wesley.</publisher>
<location>Reading, Mass.:</location>
<marker>Kruskal, 1983</marker>
<rawString>Joseph B. Kruskal. 1983. An overview of sequence comparison. In David Sankoff and Joseph B. ICruskal, editors, Time warps, string edits, and macromolecules: the theory and practice of sequence comparison, pages 1-44. Reading, Mass.: Addison-Wesley.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Peter Ladefoged</author>
</authors>
<title>A Course in Phonetics.</title>
<date>1995</date>
<publisher>Harcourt Brace Jovanovich.</publisher>
<location>New York:</location>
<contexts>
<context position="9252" citStr="Ladefoged (1995)" startWordPosition="1467" endWordPosition="1468">ough binary features are elegant and widely used, they might not be optimal for phonetic alignment. Their primary motivation is to classify phonological oppositions rather than to reflect the phonetic characteristics of sounds. In a strictly binary system, sounds that are similar often differ in a disproportionately large number of features. It can be argued that allowing features to have several possible values results in a more natural and phonetically adequate system. For example, there are many possible places of articulation, which form a nearcontinuum ranging from [labial] to [glottal]. Ladefoged (1995) devised a phonetically-based multivalued feature system. This system has been adapted by Connolly (1997) and implemented by Somers (1998). It contains about 20 features with values between 0 and 1. Some of them can take as many as ten different values (e.g. [place]), while others are basically binary oppositions (e.g. [nasal]). Table 3 contains examples of multivalued features. The main problem with both Somers&apos;s and Connolly&apos;s approaches is that they do not differentiate the weights, or saliences, that express the relative importance of individual features. For example, they assign the same </context>
<context position="21195" citStr="Ladefoged (1995)" startWordPosition="3470" endWordPosition="3472"> other segments: Syllabic, Manner, Voice, Nasal, Retroflex, Lateral, Aspirated, and Place. When dealing with doublearticulation consonantal segments, only the nearest places of articulation are used. For a more detailed description of the algorithm see (Kondrak, 1999). ALINE represents phonetic segments as vectors of feature values. Table 4 shows the features that are currently used by ALINE. Feature values are encoded as floating-point numbers in the range [0.0, 1.0]. The numerical values of four principal features are listed in Table 3. The numbers are based on the measurements performed by Ladefoged (1995). The remaining features have exactly two possible values, 0.0 and 1.0. A special feature &apos;Double&apos;, which has the same values as &apos;Place&apos;, indicates the second place of articulation. Thanks to its continuous nature, the system of features and their values can easily be adjusted and augmented. 5 Evaluation The best alignments are obtained when local comparison is used. For example, when aligning En= Cskip = = CexP 15(13) (11) 8(13,q2) 11(14 max(V(q1) )17 (q2)) { Ci 0 if p is a consonant otherwise Figure 3: Scoring functions. glish grass with Latin gramen, it is important to match only the first </context>
</contexts>
<marker>Ladefoged, 1995</marker>
<rawString>Peter Ladefoged. 1995. A Course in Phonetics. New York: Harcourt Brace Jovanovich.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Roy Lowrance</author>
<author>Robert A Wagner</author>
</authors>
<title>An extension of the string-to-string correction problem.</title>
<date>1975</date>
<journal>Journal of the Association for Computing Machinery,</journal>
<pages>22--177</pages>
<contexts>
<context position="15824" citStr="Lowrance and Wagner, 1975" startWordPosition="2521" endWordPosition="2525"> polynomial complexity. A simple modification will produce all alignments that are within c of the optimal distance (Myers, 1995). By applying methods from the operations research literature (Fox, 1973), the algorithm can be adapted to deliver the n best solutions. Moreover, the basic set of editing operations (substitutions and indels) 4The criticism applies regardless of the method of choosing 5Covington does not elaborate on the nature of the modifithe best matching segments (see also Section 5). cations. 291 can be extended to include both transpositions of adjacent segments (metathesis) (Lowrance and Wagner, 1975) and compressions and expansions (Oommen, 1995). Other extensions of the DP algorithm that are applicable to the problem of phonetic alignment include affine gap scores and local comparison. The motivation for generalized gap scores arises from the fact that in diachronic phonology not only individual segments but also entire morphemes and syllables are sometimes deleted. In order to take this fact into account, the penalty for a gap can be calculated as a function of its length, rather than as a simple sum of individual deletions. One solution is to use an affine function of the form gap(x) w</context>
</contexts>
<marker>Lowrance, Wagner, 1975</marker>
<rawString>Roy Lowrance and Robert A. Wagner. 1975. An extension of the string-to-string correction problem. Journal of the Association for Computing Machinery, 22:177-183.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Eugene W Myers</author>
</authors>
<title>Seeing conserved signals.</title>
<date>1995</date>
<booktitle>Calculating the Secrets of Life,</booktitle>
<pages>56--89</pages>
<editor>In Eric S. Lander and Michael S. Waterman, editors,</editor>
<publisher>National Academy Press.</publisher>
<location>Washington, D.C.:</location>
<contexts>
<context position="15327" citStr="Myers, 1995" startWordPosition="2447" endWordPosition="2448">is of phonetic similarity is likely to require comparing thousands of words against one another. Having a polynomially bound algorithm in the core of such a system is crucial. In any case, since the DP algorithm involves neither significantly larger overhead nor greater programming effort, there is no reason to avoid using it even for relatively small data sets. The DP algorithm is also sufficiently flexible to accommodate most of the required extensions without compromising its polynomial complexity. A simple modification will produce all alignments that are within c of the optimal distance (Myers, 1995). By applying methods from the operations research literature (Fox, 1973), the algorithm can be adapted to deliver the n best solutions. Moreover, the basic set of editing operations (substitutions and indels) 4The criticism applies regardless of the method of choosing 5Covington does not elaborate on the nature of the modifithe best matching segments (see also Section 5). cations. 291 can be extended to include both transpositions of adjacent segments (metathesis) (Lowrance and Wagner, 1975) and compressions and expansions (Oommen, 1995). Other extensions of the DP algorithm that are applicab</context>
</contexts>
<marker>Myers, 1995</marker>
<rawString>Eugene W. Myers. 1995. Seeing conserved signals. In Eric S. Lander and Michael S. Waterman, editors, Calculating the Secrets of Life, pages 56-89. Washington, D.C.: National Academy Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>John Nerbonne</author>
<author>Wilbert Heeringa</author>
</authors>
<title>Measuring dialect distance phonetically.</title>
<date>1997</date>
<booktitle>In Proceedings of the Third Meeting of the ACL Special Interest Group in Computational Phonology (SIGPHON-97). Available at http://www.cogsci.ed.ac.uk/sigphon/.</booktitle>
<contexts>
<context position="2761" citStr="Nerbonne and Heeringa (1997)" startWordPosition="431" endWordPosition="434">in the last few years, several different approaches to phonetic alignment have been reported. Covington (1996) used depth-first search and a special distance function to align words for historical comparison. In a follow-up paper (Covington, 1998), he extended the algorithm to align words from more than two languages. Somers (1998) proposed a special algorithm for aligning children&apos;s articulation data with the adult model. Gildea and Jurafsky (1996) applied the DP algorithm to pre-align input and output phonetic strings in order to improve the performance of their transducer induction system. Nerbonne and Heeringa (1997) employed a similar procedure to compute relative distance between words from various Dutch dialects. Some characteristics of these implementations are juxtaposed in Table 1. In this paper, I present a new algorithm for the alignment of cognates. It combines various techniques developed for sequence comparison with an appropriate scoring scheme for computing phonetic similarity on the basis of multivalued features. The new algorithm performs better, in terms of accuracy and efficiency, than comparable algorithms reported by Covington (1996) and Somers (1999). Although the main focus of this pa</context>
<context position="4099" citStr="Nerbonne and Heeringa (1997)" startWordPosition="639" endWordPosition="642">cessary to align phonetic sequences. 2 Comparing Phones To align phonetic sequences, we first need a function for calculating the distance between individual phones. The numerical value assigned by the function to a pair of segments is referred to as the cost, or penalty, of substitution. The function is often extended to cover pairs consisting of a segment and the null character, which correspond to the opera288 Algorithm Calculation Calculation Dynamic Phonological of alignment of distance programming features Covington (1996) explicit implicit no no Somers (1998) explicit no no multivalued Nerbonne and Heeringa (1997) implicit explicit yes binary Gildea and Jurafsky (1996) explicit implicit yes binary Table 1: Comparison of alignment algorithms. tions of insertion and deletion (also called indels). A distance function that satisfies the following axioms is called a metric: 1. Va,b : d(a,b) &gt; 0 (nonnegative property) 2. Va, b : d(a,b) = 0 &lt;=&gt; a = b (zero property) 3. Va, b : d(a,b) = d(b,a) (symmetry) 4. Va, b, c : d(a, b) d(b , c)&gt; d (a, c) (triangle inequality) 2.1 Covington&apos;s Distance Function vs. Feature-Based Metrics Covington (1996), for his cognate alignment algorithm, constructed a special distance </context>
<context position="5523" citStr="Nerbonne and Heeringa (1997)" startWordPosition="874" endWordPosition="877">shes only three types of segments: consonants, vowels, and glides. Many important characteristics of sounds, such as place or manner of articulation, are ignored. For example, both yacht and will are treated identically as a glidevowel-consonant sequence. The function&apos;s values for substitutions are listed in the &amp;quot;penalty&amp;quot; column in Table 2. The penalty for an indel is 40 if it is preceded by another indel, and 50 otherwise. Covington (1998) acknowledges that his distance function is &amp;quot;just a stand-in for a more sophisticated, perhaps feature-based, system&amp;quot;.1 Both Gildea and Jurafsky (1996) and Nerbonne and Heeringa (1997) use distance functions based on binary features. Such functions have the ability to distinguish a large number of different phones. The underlying assumption is that the number of binary features by which two given sounds differ is 1Covington&apos;s distance function is not a metric. The zero property is not satisfied because the function&apos;s value for two identical vowels is greater than zero. Also, the triangle inequality does not hold in all cases; for example: p(e,i) = 30 and p(i,y)= 10, but p(e,y)= 100, where p(x,y) is the penalty for aligning [x] with [y]. a good indication of their proximity.</context>
<context position="7821" citStr="Nerbonne and Heeringa (1997)" startWordPosition="1241" endWordPosition="1244">n question being [long] or [syllabic]). The remaining average feature distances were calculated using a set of most frequent phonemes represented by 25 letters of the Latin alphabet (all but q). In order to facilitate comparison, the rightmost column of Table 2 contains the average distances interpolated between the minimum and the maximum value of Covington&apos;s distance function. The very high correlation (0.998) between Covington&apos;s penalties and the average distances demonstrates that feature-based phonology provides a theoretical basis for Covington&apos;s manually constructed distance function. 2Nerbonne and Heeringa (1997) fix the penalty for indels as half the average of the values of all substitutions. Gildea and Jurafsky (1996) set it at one fourth of the maximum substitution cost. 3In order to handle all the phones in Covington&apos;s data set, two features were added: [tense] and [spread glottis]. 289 Clause in Covington&apos;s Covington&apos;s Average Interpolated distance function penalty Hamming average distance distance 1 &amp;quot;identical consonants or glides&amp;quot; 0 0.0 0.0 2 &amp;quot;identical vowels&amp;quot; 5 0.0 0.0 3 &amp;quot;vowel length difference only&amp;quot; 10 1.0 12.4 4 &amp;quot;non-identical vowels&amp;quot; 30 2.2 27.3 5 &amp;quot;non-identical consonants&amp;quot; 60 4.81 58.1 </context>
<context position="10323" citStr="Nerbonne and Heeringa (1997)" startWordPosition="1636" endWordPosition="1639"> is that they do not differentiate the weights, or saliences, that express the relative importance of individual features. For example, they assign the same salience to the feature [place] as to the feature [aspiration], which results in a smaller distance between [p] and [k] than between [p] and [ph]. I found that in order to avoid such incongruous outcomes, the salience values need to be carefully differentiated; specifically, the features [place] and [manner] should be assigned significantly higher saliences than other features (the actual values used in my algorithm are given in Table 4). Nerbonne and Heeringa (1997) experimented with weighting each feature by information gain but found it had an adverse effect on the quality of the alignments. The question of how to derive salience values in a principled manner is still open. 2.3 Similarity vs. Distance Although all four algorithms listed in Table 1 measure relatedness between phones by means of a distance function, such an approach does not seem to be the best for dealing with phonetic units. The fact that Covington&apos;s distance function is not a metric is not an accidental oversight; rather, it reflects certain inherent characteristics of phones. Since v</context>
</contexts>
<marker>Nerbonne, Heeringa, 1997</marker>
<rawString>John Nerbonne and Wilbert Heeringa. 1997. Measuring dialect distance phonetically. In Proceedings of the Third Meeting of the ACL Special Interest Group in Computational Phonology (SIGPHON-97). Available at http://www.cogsci.ed.ac.uk/sigphon/.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B John Oommen</author>
</authors>
<title>String alignment with substitution, insertion, deletion, squashing; and expansion operations.</title>
<date>1995</date>
<journal>Information Sciences,</journal>
<pages>83--89</pages>
<contexts>
<context position="15871" citStr="Oommen, 1995" startWordPosition="2530" endWordPosition="2532">ll alignments that are within c of the optimal distance (Myers, 1995). By applying methods from the operations research literature (Fox, 1973), the algorithm can be adapted to deliver the n best solutions. Moreover, the basic set of editing operations (substitutions and indels) 4The criticism applies regardless of the method of choosing 5Covington does not elaborate on the nature of the modifithe best matching segments (see also Section 5). cations. 291 can be extended to include both transpositions of adjacent segments (metathesis) (Lowrance and Wagner, 1975) and compressions and expansions (Oommen, 1995). Other extensions of the DP algorithm that are applicable to the problem of phonetic alignment include affine gap scores and local comparison. The motivation for generalized gap scores arises from the fact that in diachronic phonology not only individual segments but also entire morphemes and syllables are sometimes deleted. In order to take this fact into account, the penalty for a gap can be calculated as a function of its length, rather than as a simple sum of individual deletions. One solution is to use an affine function of the form gap(x) where r is the penalty for the introduction of a</context>
</contexts>
<marker>Oommen, 1995</marker>
<rawString>B. John Oommen. 1995. String alignment with substitution, insertion, deletion, squashing; and expansion operations. Information Sciences, 83:89-107.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T F Smith</author>
<author>Michael S Waterman</author>
</authors>
<title>Identification of common molecular sequences.</title>
<date>1981</date>
<journal>Journal of Molecular Biology,</journal>
<pages>147--195</pages>
<contexts>
<context position="16783" citStr="Smith and Waterman, 1981" startWordPosition="2686" endWordPosition="2689">mes and syllables are sometimes deleted. In order to take this fact into account, the penalty for a gap can be calculated as a function of its length, rather than as a simple sum of individual deletions. One solution is to use an affine function of the form gap(x) where r is the penalty for the introduction of a gap, and s is the penalty for each symbol in the gap. Gotoh (1982) describes a method for incorporating affine gap scores into the DP alignment algorithm. Incidentally, Covington&apos;s penalties for indels can be expressed by an affine gap function with r = 10 and s= 40. Local comparison (Smith and Waterman, 1981) is made possible by using both positive and negative similarity scores. In local, as opposed to global, comparison, only similar subsequences are matched, rather than entire sequences. This often has the beneficial effect of separating inflectional and derivational affixes from the roots. Such affixes tend to make finding the proper alignment more difficult. It would be unreasonable to expect affixes to be stripped before applying the algorithm to the data, because one of the very reasons to use an automatic aligner is to avoid analyzing every word individually. 4 The algorithm Many of the id</context>
</contexts>
<marker>Smith, Waterman, 1981</marker>
<rawString>T. F. Smith and Michael S. Waterman. 1981. Identification of common molecular sequences. Journal of Molecular Biology, 147:195-197.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Harold L Somers</author>
</authors>
<title>Similarity metrics for aligning children&apos;s articulation data.</title>
<date>1998</date>
<booktitle>In Proceedings of COLING-ACL&apos;98: 36th Annual Meeting of the Association for Computational Linguistics and 17th International Conference on Computational Linguistics,</booktitle>
<pages>1227--1231</pages>
<contexts>
<context position="2466" citStr="Somers (1998)" startWordPosition="386" endWordPosition="387"> algorithms can used as well. The task of finding the optimal alignment is closely linked to the task of calculating the distance between two sequences. The basic DP algorithm accomplishes both tasks. Depending on the application, either of the results, or both, can be used. Within the last few years, several different approaches to phonetic alignment have been reported. Covington (1996) used depth-first search and a special distance function to align words for historical comparison. In a follow-up paper (Covington, 1998), he extended the algorithm to align words from more than two languages. Somers (1998) proposed a special algorithm for aligning children&apos;s articulation data with the adult model. Gildea and Jurafsky (1996) applied the DP algorithm to pre-align input and output phonetic strings in order to improve the performance of their transducer induction system. Nerbonne and Heeringa (1997) employed a similar procedure to compute relative distance between words from various Dutch dialects. Some characteristics of these implementations are juxtaposed in Table 1. In this paper, I present a new algorithm for the alignment of cognates. It combines various techniques developed for sequence comp</context>
<context position="4043" citStr="Somers (1998)" startWordPosition="633" endWordPosition="634"> applied in other contexts where it is necessary to align phonetic sequences. 2 Comparing Phones To align phonetic sequences, we first need a function for calculating the distance between individual phones. The numerical value assigned by the function to a pair of segments is referred to as the cost, or penalty, of substitution. The function is often extended to cover pairs consisting of a segment and the null character, which correspond to the opera288 Algorithm Calculation Calculation Dynamic Phonological of alignment of distance programming features Covington (1996) explicit implicit no no Somers (1998) explicit no no multivalued Nerbonne and Heeringa (1997) implicit explicit yes binary Gildea and Jurafsky (1996) explicit implicit yes binary Table 1: Comparison of alignment algorithms. tions of insertion and deletion (also called indels). A distance function that satisfies the following axioms is called a metric: 1. Va,b : d(a,b) &gt; 0 (nonnegative property) 2. Va, b : d(a,b) = 0 &lt;=&gt; a = b (zero property) 3. Va, b : d(a,b) = d(b,a) (symmetry) 4. Va, b, c : d(a, b) d(b , c)&gt; d (a, c) (triangle inequality) 2.1 Covington&apos;s Distance Function vs. Feature-Based Metrics Covington (1996), for his cogn</context>
<context position="9390" citStr="Somers (1998)" startWordPosition="1486" endWordPosition="1487">honological oppositions rather than to reflect the phonetic characteristics of sounds. In a strictly binary system, sounds that are similar often differ in a disproportionately large number of features. It can be argued that allowing features to have several possible values results in a more natural and phonetically adequate system. For example, there are many possible places of articulation, which form a nearcontinuum ranging from [labial] to [glottal]. Ladefoged (1995) devised a phonetically-based multivalued feature system. This system has been adapted by Connolly (1997) and implemented by Somers (1998). It contains about 20 features with values between 0 and 1. Some of them can take as many as ten different values (e.g. [place]), while others are basically binary oppositions (e.g. [nasal]). Table 3 contains examples of multivalued features. The main problem with both Somers&apos;s and Connolly&apos;s approaches is that they do not differentiate the weights, or saliences, that express the relative importance of individual features. For example, they assign the same salience to the feature [place] as to the feature [aspiration], which results in a smaller distance between [p] and [k] than between [p] a</context>
</contexts>
<marker>Somers, 1998</marker>
<rawString>Harold L. Somers. 1998. Similarity metrics for aligning children&apos;s articulation data. In Proceedings of COLING-ACL&apos;98: 36th Annual Meeting of the Association for Computational Linguistics and 17th International Conference on Computational Linguistics, pages 1227-1231.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Harold L Somers</author>
</authors>
<title>Aligning phonetic segments for children&apos;s articulation assessment.</title>
<date>1999</date>
<journal>Computational Linguistics,</journal>
<pages>25--2</pages>
<contexts>
<context position="3325" citStr="Somers (1999)" startWordPosition="517" endWordPosition="518">er induction system. Nerbonne and Heeringa (1997) employed a similar procedure to compute relative distance between words from various Dutch dialects. Some characteristics of these implementations are juxtaposed in Table 1. In this paper, I present a new algorithm for the alignment of cognates. It combines various techniques developed for sequence comparison with an appropriate scoring scheme for computing phonetic similarity on the basis of multivalued features. The new algorithm performs better, in terms of accuracy and efficiency, than comparable algorithms reported by Covington (1996) and Somers (1999). Although the main focus of this paper is diachronic phonology, the techniques proposed here can also be applied in other contexts where it is necessary to align phonetic sequences. 2 Comparing Phones To align phonetic sequences, we first need a function for calculating the distance between individual phones. The numerical value assigned by the function to a pair of segments is referred to as the cost, or penalty, of substitution. The function is often extended to cover pairs consisting of a segment and the null character, which correspond to the opera288 Algorithm Calculation Calculation Dyn</context>
<context position="24685" citStr="Somers (1999)" startWordPosition="4098" endWordPosition="4099">ed in the phonetic string is available to the aligners. On Covington&apos;s Spanish/French data, ALINE does not make any mistakes. Unlike Covington&apos;s aligner, it properly aligns [1] in arbol with the second [r] in arbre. On his English/German data, it selects the correct alignment in those cases where Covington&apos;s aligner produces two alternatives. In the final, mixed set, ALINE makes a single mistake in daughter/thugater, in which it posits a dropped prefix rather than a syncopated syllable; in all other cases, it is right on target. Overall, ALINE clearly performs better than Covington&apos;s aligner. Somers (1999) tests one version of his algorithm, CAT, on the same set of cognates. CAT employs binary, rather than multivalued, features. Another important characteristic is that it pre-aligns the stressed segments in both sequences. Since CAT distinguishes between individual consonants, in some cases it produces more accurate alignments than Covington&apos;s aligner. However, because of its pre-alignment strategy, it is guaranteed to produce wrong alignments in all cases when the stress has moved in one of the cognates. For example, in the Spanish/French pair cabeza/cap, it aligns [p] with [0] rather than [b]</context>
</contexts>
<marker>Somers, 1999</marker>
<rawString>Harold L. Somers. 1999. Aligning phonetic segments for children&apos;s articulation assessment. Computational Linguistics, 25(2):267-275.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robert A Wagner</author>
<author>Michael J Fischer</author>
</authors>
<title>The string-to-string correction problem.</title>
<date>1974</date>
<journal>Journal of the Association for Computing Machinery,</journal>
<pages>21--1</pages>
<contexts>
<context position="1837" citStr="Wagner and Fischer, 1974" startWordPosition="283" endWordPosition="286">terances in speech recognition. On the other hand, it has much in common with the alignment of proteins and DNA sequences. Many methods developed for molecular biology can be adapted to perform accurate phonetic alignment. Alignment algorithms usually contain two main components: a metric for measuring distance between phones, and a procedure for finding the optimal alignment. The former is often calculated on the basis of phonological features that encode certain properties of phones. An obvious candidate for the latter is a well-known dynamic programming (DP) algorithm for string alignment (Wagner and Fischer, 1974), although other algorithms can used as well. The task of finding the optimal alignment is closely linked to the task of calculating the distance between two sequences. The basic DP algorithm accomplishes both tasks. Depending on the application, either of the results, or both, can be used. Within the last few years, several different approaches to phonetic alignment have been reported. Covington (1996) used depth-first search and a special distance function to align words for historical comparison. In a follow-up paper (Covington, 1998), he extended the algorithm to align words from more than</context>
</contexts>
<marker>Wagner, Fischer, 1974</marker>
<rawString>Robert A. Wagner and Michael J. Fischer. 1974. The string-to-string correction problem. Journal of the Association for Computing Machinery, 21(1):168-173.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>